[
    {
        "title": "Scramble String",
        "question_content": "We can scramble a string s to get a string t using the following algorithm:\n\n\tIf the length of the string is 1, stop.\n\tIf the length of the string is > 1, do the following:\n\t\n\t\tSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\n\t\tRandomly&nbsp;decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\n\t\tApply step 1 recursively on each of the two substrings x and y.\n\t\n\t\n\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\n&nbsp;\nExample 1:\n\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n\nExample 2:\n\nInput: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false\n\nExample 3:\n\nInput: s1 = \"a\", s2 = \"a\"\nOutput: true\n\n&nbsp;\nConstraints:\n\n\ts1.length == s2.length\n\t1 <= s1.length <= 30\n\ts1 and s2 consist of lowercase English letters.",
        "solutions": [
            {
                "id": 29392,
                "title": "share-my-4ms-c-recursive-solution",
                "content": "Assume the strings are all lower case letters\\n\\n    class Solution {\\n    public:\\n        bool isScramble(string s1, string s2) {\\n            if(s1==s2)\\n                return true;\\n                \\n            int len = s1.length();\\n            int count[26] = {0};\\n            for(int i=0; i<len; i++)\\n            {\\n                count[s1[i]-'a']++;\\n                count[s2[i]-'a']--;\\n            }\\n            \\n            for(int i=0; i<26; i++)\\n            {\\n                if(count[i]!=0)\\n                    return false;\\n            }\\n            \\n            for(int i=1; i<=len-1; i++)\\n            {\\n                if( isScramble(s1.substr(0,i), s2.substr(0,i)) && isScramble(s1.substr(i), s2.substr(i)))\\n                    return true;\\n                if( isScramble(s1.substr(0,i), s2.substr(len-i)) && isScramble(s1.substr(i), s2.substr(0,len-i)))\\n                    return true;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isScramble(string s1, string s2) {\\n            if(s1==s2)\\n                return true;\\n                \\n            int len = s1.length();\\n            int count[26] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 29396,
                "title": "simple-iterative-dp-java-solution-with-explanation",
                "content": "Explanation in code itself. The iterative version of the idea is considerably slower than the recursive simply because here we consider all possible states, while the recursive will only compute required states as it founds them. Time complexity of both is, in any case, the same.\\n    \\n    public class Solution {\\n    \\tpublic boolean isScramble(String s1, String s2) {\\n    \\t\\tif (s1.length() != s2.length()) return false;\\n    \\t\\tint len = s1.length();\\n    \\t\\t/**\\n    \\t\\t * Let F(i, j, k) = whether the substring S1[i..i + k - 1] is a scramble of S2[j..j + k - 1] or not\\n    \\t\\t * Since each of these substrings is a potential node in the tree, we need to check for all possible cuts.\\n    \\t\\t * Let q be the length of a cut (hence, q < k), then we are in the following situation:\\n    \\t\\t * \\n    \\t\\t * S1 [   x1    |         x2         ]\\n    \\t\\t *    i         i + q                i + k - 1\\n    \\t\\t * \\n    \\t\\t * here we have two possibilities:\\n    \\t\\t *      \\n    \\t\\t * S2 [   y1    |         y2         ]\\n    \\t\\t *    j         j + q                j + k - 1\\n    \\t\\t *    \\n    \\t\\t * or \\n    \\t\\t * \\n    \\t\\t * S2 [       y1        |     y2     ]\\n    \\t\\t *    j                 j + k - q    j + k - 1\\n    \\t\\t * \\n    \\t\\t * which in terms of F means:\\n    \\t\\t * \\n    \\t\\t * F(i, j, k) = for some 1 <= q < k we have:\\n    \\t\\t *  (F(i, j, q) AND F(i + q, j + q, k - q)) OR (F(i, j + k - q, q) AND F(i + q, j, k - q))\\n    \\t\\t *  \\n    \\t\\t * Base case is k = 1, where we simply need to check for S1[i] and S2[j] to be equal \\n    \\t\\t * */\\n    \\t\\tboolean [][][] F = new boolean[len][len][len + 1];\\n    \\t\\tfor (int k = 1; k <= len; ++k)\\n    \\t\\t\\tfor (int i = 0; i + k <= len; ++i)\\n    \\t\\t\\t\\tfor (int j = 0; j + k <= len; ++j)\\n    \\t\\t\\t\\t\\tif (k == 1)\\n    \\t\\t\\t\\t\\t\\tF[i][j][k] = s1.charAt(i) == s2.charAt(j);\\n    \\t\\t\\t\\t\\telse for (int q = 1; q < k && !F[i][j][k]; ++q) {\\n    \\t\\t\\t\\t\\t\\tF[i][j][k] = (F[i][j][q] && F[i + q][j + q][k - q]) || (F[i][j + k - q][q] && F[i + q][j][k - q]);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\treturn F[0][0][len];\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    \\tpublic boolean isScramble(String s1, String s2) {\\n    \\t\\tif (s1.length() != s2.length()) return false;\\n    \\t\\tint len = s1.length();\\n    \\t\\t/**\\n    \\t\\t * Let F(i, j, k) = whether the substring S1[i..i + k - 1] is a scramble of S2[j..j + k - 1] or not\\n    \\t\\t * Since each of these substrings is a potential node in the tree, we need to check for all possible cuts.\\n    \\t\\t * Let q be the length of a cut (hence, q < k), then we are in the following situation:\\n    \\t\\t * \\n    \\t\\t * S1 [   x1    |         x2         ]\\n    \\t\\t *    i         i + q                i + k - 1\\n    \\t\\t * \\n    \\t\\t * here we have two possibilities:\\n    \\t\\t *      \\n    \\t\\t * S2 [   y1    |         y2         ]\\n    \\t\\t *    j         j + q                j + k - 1\\n    \\t\\t *    \\n    \\t\\t * or \\n    \\t\\t * \\n    \\t\\t * S2 [       y1        |     y2     ]\\n    \\t\\t *    j                 j + k - q    j + k - 1\\n    \\t\\t * \\n    \\t\\t * which in terms of F means:\\n    \\t\\t * \\n    \\t\\t * F(i, j, k) = for some 1 <= q < k we have:\\n    \\t\\t *  (F(i, j, q) AND F(i + q, j + q, k - q)) OR (F(i, j + k - q, q) AND F(i + q, j, k - q))\\n    \\t\\t *  \\n    \\t\\t * Base case is k = 1, where we simply need to check for S1[i] and S2[j] to be equal \\n    \\t\\t * */\\n    \\t\\tboolean [][][] F = new boolean[len][len][len + 1];\\n    \\t\\tfor (int k = 1; k <= len; ++k)\\n    \\t\\t\\tfor (int i = 0; i + k <= len; ++i)\\n    \\t\\t\\t\\tfor (int j = 0; j + k <= len; ++j)\\n    \\t\\t\\t\\t\\tif (k == 1)\\n    \\t\\t\\t\\t\\t\\tF[i][j][k] = s1.charAt(i) == s2.charAt(j);\\n    \\t\\t\\t\\t\\telse for (int q = 1; q < k && !F[i][j][k]; ++q) {\\n    \\t\\t\\t\\t\\t\\tF[i][j][k] = (F[i][j][q] && F[i + q][j + q][k - q]) || (F[i][j + k - q][q] && F[i + q][j][k - q]);\\n    \\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 29387,
                "title": "accepted-java-solution",
                "content": "    public class Solution {\\n        public boolean isScramble(String s1, String s2) {\\n            if (s1.equals(s2)) return true; \\n            \\n            int[] letters = new int[26];\\n            for (int i=0; i<s1.length(); i++) {\\n                letters[s1.charAt(i)-'a']++;\\n                letters[s2.charAt(i)-'a']--;\\n            }\\n            for (int i=0; i<26; i++) if (letters[i]!=0) return false;\\n        \\n            for (int i=1; i<s1.length(); i++) {\\n                if (isScramble(s1.substring(0,i), s2.substring(0,i)) \\n                 && isScramble(s1.substring(i), s2.substring(i))) return true;\\n                if (isScramble(s1.substring(0,i), s2.substring(s2.length()-i)) \\n                 && isScramble(s1.substring(i), s2.substring(0,s2.length()-i))) return true;\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isScramble(String s1, String s2) {\\n            if (s1.equals(s2)) return true; \\n            \\n            int[] letters = new int[26];\\n            for (int i=0; i<s1.length(); i++) {\\n                letters[s1.charAt(i)-'a']++;\\n                letters[s2.charAt(i)-'a']--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 29394,
                "title": "my-c-solutions-recursion-with-cache-dp-recursion-with-cache-and-pruning-with-explanation-4ms",
                "content": "The basic idea is to divide s1(s2) into two substrings with length k and len-k and check if the two substrings s1[0..k-1] and s1[k, len-1] are the scrambles of s2[0..k-1] and s2[k,len-1] or s2[len-k, len-1] and s2[0..len-k-1] via recursion. The straigtforward recursion will be very slow due to many repeated recursive function calls. To speed up the recursion, we can use an unordered_map isScramblePair to save intermediate results. The key used here is s1+s2, but other keys are also possible (e.g. using indices)\\n\\n        class Solution {\\n            bool DP_helper(unordered_map<string, bool> &isScramblePair, string s1, string s2)\\n            {\\n                int i,len = s1.size();\\n                bool res = false;\\n                if(0==len) return true;\\n                else if(1==len) return s1 == s2;\\n                else\\n                {\\n                    if(isScramblePair.count(s1+s2)) return isScramblePair[s1+s2]; // checked before, return intermediate result directly\\n                    if(s1==s2) res=true;\\n                    else{\\n                        for(i=1; i<len && !res; ++i)\\n                        {\\n    //check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1]\\n                            res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(0,i)) && DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(i,len-i)));\\n     //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i]\\n                           res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(len-i,i)) && DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(0,len-i)));\\n                        }\\n                    }\\n                    return isScramblePair[s1+s2]= res; //save the intermediate results\\n                    \\n                }\\n            }\\n        public:\\n            bool isScramble(string s1, string s2) {\\n               unordered_map<string, bool> isScramblePair;\\n               return DP_helper(isScramblePair, s1, s2);\\n            }\\n        };\\n\\nThe recursive version has exponential complexity. To further improve the performance, we can use bottom-up DP, which is O(N^4) complexity. Here we build a table isS[len][i][j], which indicates whether s1[i..i+len-1] is a scramble of s2[j..j+len-1].\\n\\n    class Solution {\\n    public:\\n        bool isScramble(string s1, string s2) {\\n            int sSize = s1.size(), len, i, j, k;\\n            if(0==sSize) return true;\\n            if(1==sSize) return s1==s2;\\n            bool isS[sSize+1][sSize][sSize];\\n    \\n            for(i=0; i<sSize; ++i)\\n                for(j=0; j<sSize; ++j)\\n                    isS[1][i][j] = s1[i] == s2[j];\\n                    \\n            for(len=2; len <=sSize; ++len)\\n                for(i=0; i<=sSize-len; ++i)\\n                    for(j=0; j<=sSize-len; ++j)\\n                    {\\n                        isS[len][i][j] = false;\\n                            for(k=1; k<len && !isS[len][i][j]; ++k)\\n                            {\\n                                isS[len][i][j] = isS[len][i][j] || (isS[k][i][j] && isS[len-k][i+k][j+k]);\\n                                isS[len][i][j] = isS[len][i][j] || (isS[k][i+len-k][j] && isS[len-k][i][j+k]);\\n                            }\\n                    }\\n            return isS[sSize][0][0];            \\n    \\n        }\\n    }; \\n\\nFurhtermore, in many cases, we found we can terminate our recursion early by pruning: i.e. by first checking if s1 and s2 have the same character set before we do recursion: if not, just terminate without recursion.  This observation leads us to the following Recursion+cache+pruning version. Here the key of the cache changes to idx1*sSize +idx2 + len*sSize*sSize;\\n\\n    class Solution {\\n    private:\\n        bool DP_helper(string &s1, string &s2, int idx1, int idx2, int len, char isS[])\\n        {\\n            int sSize = s1.size(),i, j, k, hist[26] , zero_count =0;\\n            if(isS[(len*sSize+idx1)*sSize+idx2]) return isS[(len*sSize+idx1)*sSize+idx2]==1;\\n            bool res = false;\\n            \\n            fill_n(hist, 26, 0);\\n            for(k=0; k<len;++k)\\n            { // check if s1[idx1:idx1+len-1] and s2[idx2:idx2+len-1] have same characters\\n                zero_count +=  (0==hist[s1[idx1+k]-'a']) - (0== ++hist[s1[idx1+k]-'a']);\\n                zero_count +=  (0==hist[s2[idx2+k]-'a']) - (0== --hist[s2[idx2+k]-'a']);\\n            }\\n            if(zero_count) {isS[(len*sSize+idx1)*sSize+idx2] = 2; return false;} //if not, return directly\\n            if(len==1)     {isS[(len*sSize+idx1)*sSize+idx2] = 1; return true;}\\n            for(k=1;k<len && !res;++k) //otherwise, recursion with cache\\n            {\\n                res = res || (DP_helper(s1, s2, idx1, idx2, k, isS) && DP_helper(s1, s2, idx1+k, idx2+k, len-k, isS) );\\n                res = res || (DP_helper(s1, s2, idx1+len-k, idx2, k, isS) && DP_helper(s1, s2, idx1, idx2+k, len-k, isS) );\\n            }\\n            isS[(len*sSize+idx1)*sSize+idx2] = res?1:2;\\n            return res;\\n        }\\n    public:\\n        bool isScramble(string s1, string s2) {\\n            const int sSize = s1.size();\\n            if(0==sSize) return true;\\n            char isS[(sSize+1)*sSize*sSize];\\n            fill_n(isS, (sSize+1)*sSize*sSize, 0);\\n            return DP_helper(s1, s2, 0, 0, sSize, isS);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n            bool DP_helper(unordered_map<string, bool> &isScramblePair, string s1, string s2)\\n            {\\n                int i,len = s1.size();\\n                bool res = false;\\n                if(0==len) return true;\\n                else if(1==len) return s1 == s2;\\n                else\\n                {\\n                    if(isScramblePair.count(s1+s2)) return isScramblePair[s1+s2]; // checked before, return intermediate result directly\\n                    if(s1==s2) res=true;\\n                    else{\\n                        for(i=1; i<len && !res; ++i)\\n                        {\\n    //check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1]\\n                            res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(0,i)) && DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(i,len-i)));\\n     //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i]\\n                           res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(len-i,i)) && DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(0,len-i)));\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3357439,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to check whether s2 is scrambled string of s1 or not. The scrambled string of a given string is defined as any string that can be obtained by swapping some characters of the original string. So we can solve this problem recursively by dividing the string into left and right substrings and check for two cases i.e., whether we need to swap the substrings before checking for the next recursive call or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will first check the base cases i.e., if the two strings are equal or not or if they are of different sizes. Then, we will create a key for the current problem by concatenating the two strings and storing it in a dictionary to avoid repeated computations. We will iterate over all possible splits of the current string and check whether we need to swap the left and right substrings or not. We will then make recursive calls on these two substrings and return true if any of the calls return true.\\n\\n# Complexity\\n- Time complexity: $$O(n^4)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsince for each character in s1, we are trying out all possible splits of the string which takes $$O(n^2)$$ time and we are calling the recursion twice for each split which takes another $$O(n^2)$$ time. And for each such problem, we are storing it in a dictionary which takes $$O(1)$$ time. So overall time complexity is $$O(n^4)$$.\\n\\n- Space complexity: $$O(n^3)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nsince we are using a dictionary to store previously solved problems and the depth of the recursion tree can go up to n. Therefore, the space complexity of this solution is $$O(n^3)$$.\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    // for storing already solved problems\\n    Map<String, Boolean> mp = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n\\n        // if both strings are not equal in size\\n        if (s2.length() != n)\\n            return false;\\n\\n        // if both strings are equal\\n        if (s1.equals(s2))\\n            return true;\\n\\n        // if code is reached to this condition then following this are sure:\\n        // 1. size of both string is equal\\n        // 2. string are not equal\\n        // so size is equal (where size==1) and they are not equal then obviously false\\n        // example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if (n == 1)\\n            return false;\\n\\n        String key = s1 + \" \" + s2;\\n\\n        // check if this problem has already been solved\\n        if (mp.containsKey(key))\\n            return mp.get(key);\\n\\n        // for every iteration it can two condition\\n        // 1.we should proceed without swapping\\n        // 2.we should swap before looking next\\n        for (int i = 1; i < n; i++) {\\n            // ex of without swap: gr|eat and rg|eat\\n            boolean withoutswap = (\\n                    // left part of first and second string\\n                    isScramble(s1.substring(0, i), s2.substring(0, i))\\n\\n                            &&\\n\\n                            // right part of first and second string;\\n                            isScramble(s1.substring(i), s2.substring(i))\\n            );\\n\\n            // if without swap give us right answer then we do not need\\n            // to call the recursion withswap\\n            if (withoutswap) {\\n                mp.put(key, true);\\n                return true;\\n            }\\n\\n            // ex of withswap: gr|eat rge|at\\n            // here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            boolean withswap = (\\n                    // left part of first and right part of second\\n                    isScramble(s1.substring(0, i), s2.substring(n - i))\\n\\n                            &&\\n\\n                            // right part of first and left part of second\\n                            isScramble(s1.substring(i), s2.substring(0, n - i))\\n            );\\n\\n            // if withswap give us right answer then we return true\\n            // otherwise the for loop do it work\\n            if (withswap) {\\n                mp.put(key, true);\\n                return true;\\n            }\\n            // we are not returning false in else case\\n            // because we want to check further cases with the for loop\\n        }\\n        mp.put(key, false);\\n        return false;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n//for storing already solved problems\\n    unordered_map<string,bool> mp;\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        //base cases\\n        \\n        int n = s1.size();\\n        \\n        //if both string are not equal in size\\n        if(s2.size()!=n)\\n            return false;\\n        \\n        //if both string are equal\\n        if(s1==s2)\\n         return true;   \\n        \\n            \\n        \\n        //if code is reached to this condition then following this are sure:\\n        //1. size of both string is equal\\n        //2.  string are not equal\\n        //so size is equal (where size==1) and they are not equal then obviously false\\n        //example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if(n==1)\\n            return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n\\t\\t//check if this problem has already been solved\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        //for every iteration it can two condition \\n        //1.we should proceed without swapping\\n        //2.we should swap before looking next\\n        for(int i=1;i<n;i++)\\n        {\\n\\n            //ex of without swap: gr|eat and rg|eat\\n            bool withoutswap = (\\n                //left part of first and second string\\n                isScramble(s1.substr(0,i),s2.substr(0,i)) \\n                \\n                &&\\n                \\n                //right part of first and second string;\\n                isScramble(s1.substr(i),s2.substr(i))\\n                );\\n            \\n            \\n            \\n            //if without swap give us right answer then we do not need \\n            //to call the recursion withswap\\n            if(withoutswap)\\n                return true;\\n            \\n            //ex of withswap: gr|eat  rge|at\\n\\t\\t\\t//here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            bool withswap = (\\n                //left part of first and right part of second \\n                isScramble(s1.substr(0,i),s2.substr(n-i)) \\n                \\n                &&\\n                \\n                //right part of first and left part of second\\n                isScramble(s1.substr(i),s2.substr(0,n-i)) \\n                );\\n            \\n            \\n            \\n            //if withswap give us right answer then we return true\\n            //otherwise the for loop do it work\\n            if(withswap)\\n                return true;\\n            //we are not returning false in else case \\n            //because we want to check further cases with the for loop\\n        }\\n        \\n        \\n        return mp[key] = false;\\n        \\n    }\\n};\\n```\\n``` Python []\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        # Base cases\\n\\n        n = len(s1)\\n\\n        # If both strings are not equal in size\\n        if len(s2) != n:\\n            return False\\n\\n        # If both strings are equal\\n        if s1 == s2:\\n            return True\\n\\n        # If code is reached to this condition then following this are sure:\\n        # 1. size of both string is equal\\n        # 2. string are not equal\\n        # so size is equal (where size==1) and they are not equal then obviously false\\n        # example \\'a\\' and \\'b\\' size is equal, string are not equal\\n        if n == 1:\\n            return False\\n\\n        key = s1 + \" \" + s2\\n\\n        # Check if this problem has already been solved\\n        if key in self.mp:\\n            return self.mp[key]\\n\\n        # For every iteration it can two condition\\n        # 1. We should proceed without swapping\\n        # 2. We should swap before looking next\\n        for i in range(1, n):\\n            # ex of without swap: gr|eat and rg|eat\\n            without_swap = (\\n                # Left part of first and second string\\n                self.isScramble(s1[:i], s2[:i])\\n                and\\n                # Right part of first and second string;\\n                self.isScramble(s1[i:], s2[i:])\\n            )\\n\\n            # If without swap gives us the right answer then we do not need\\n            # to call the recursion with swap\\n            if without_swap:\\n                return True\\n\\n            # ex of with swap: gr|eat rge|at\\n            # here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            with_swap = (\\n                # Left part of first and right part of second\\n                self.isScramble(s1[:i], s2[n-i:])\\n                and\\n                # Right part of first and left part of second\\n                self.isScramble(s1[i:], s2[:n-i])\\n            )\\n\\n            # If with swap gives us the right answer then we return True\\n            # otherwise, the for loop does its work\\n            if with_swap:\\n                return True\\n\\n        self.mp[key] = False\\n        return False\\n\\n    # for storing already solved problems\\n    mp = {}\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    // for storing already solved problems\\n    Map<String, Boolean> mp = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n\\n        // if both strings are not equal in size\\n        if (s2.length() != n)\\n            return false;\\n\\n        // if both strings are equal\\n        if (s1.equals(s2))\\n            return true;\\n\\n        // if code is reached to this condition then following this are sure:\\n        // 1. size of both string is equal\\n        // 2. string are not equal\\n        // so size is equal (where size==1) and they are not equal then obviously false\\n        // example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if (n == 1)\\n            return false;\\n\\n        String key = s1 + \" \" + s2;\\n\\n        // check if this problem has already been solved\\n        if (mp.containsKey(key))\\n            return mp.get(key);\\n\\n        // for every iteration it can two condition\\n        // 1.we should proceed without swapping\\n        // 2.we should swap before looking next\\n        for (int i = 1; i < n; i++) {\\n            // ex of without swap: gr|eat and rg|eat\\n            boolean withoutswap = (\\n                    // left part of first and second string\\n                    isScramble(s1.substring(0, i), s2.substring(0, i))\\n\\n                            &&\\n\\n                            // right part of first and second string;\\n                            isScramble(s1.substring(i), s2.substring(i))\\n            );\\n\\n            // if without swap give us right answer then we do not need\\n            // to call the recursion withswap\\n            if (withoutswap) {\\n                mp.put(key, true);\\n                return true;\\n            }\\n\\n            // ex of withswap: gr|eat rge|at\\n            // here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            boolean withswap = (\\n                    // left part of first and right part of second\\n                    isScramble(s1.substring(0, i), s2.substring(n - i))\\n\\n                            &&\\n\\n                            // right part of first and left part of second\\n                            isScramble(s1.substring(i), s2.substring(0, n - i))\\n            );\\n\\n            // if withswap give us right answer then we return true\\n            // otherwise the for loop do it work\\n            if (withswap) {\\n                mp.put(key, true);\\n                return true;\\n            }\\n            // we are not returning false in else case\\n            // because we want to check further cases with the for loop\\n        }\\n        mp.put(key, false);\\n        return false;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n//for storing already solved problems\\n    unordered_map<string,bool> mp;\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        //base cases\\n        \\n        int n = s1.size();\\n        \\n        //if both string are not equal in size\\n        if(s2.size()!=n)\\n            return false;\\n        \\n        //if both string are equal\\n        if(s1==s2)\\n         return true;   \\n        \\n            \\n        \\n        //if code is reached to this condition then following this are sure:\\n        //1. size of both string is equal\\n        //2.  string are not equal\\n        //so size is equal (where size==1) and they are not equal then obviously false\\n        //example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if(n==1)\\n            return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n\\t\\t//check if this problem has already been solved\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        //for every iteration it can two condition \\n        //1.we should proceed without swapping\\n        //2.we should swap before looking next\\n        for(int i=1;i<n;i++)\\n        {\\n\\n            //ex of without swap: gr|eat and rg|eat\\n            bool withoutswap = (\\n                //left part of first and second string\\n                isScramble(s1.substr(0,i),s2.substr(0,i)) \\n                \\n                &&\\n                \\n                //right part of first and second string;\\n                isScramble(s1.substr(i),s2.substr(i))\\n                );\\n            \\n            \\n            \\n            //if without swap give us right answer then we do not need \\n            //to call the recursion withswap\\n            if(withoutswap)\\n                return true;\\n            \\n            //ex of withswap: gr|eat  rge|at\\n\\t\\t\\t//here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            bool withswap = (\\n                //left part of first and right part of second \\n                isScramble(s1.substr(0,i),s2.substr(n-i)) \\n                \\n                &&\\n                \\n                //right part of first and left part of second\\n                isScramble(s1.substr(i),s2.substr(0,n-i)) \\n                );\\n            \\n            \\n            \\n            //if withswap give us right answer then we return true\\n            //otherwise the for loop do it work\\n            if(withswap)\\n                return true;\\n            //we are not returning false in else case \\n            //because we want to check further cases with the for loop\\n        }\\n        \\n        \\n        return mp[key] = false;\\n        \\n    }\\n};\\n```\n``` Python []\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        # Base cases\\n\\n        n = len(s1)\\n\\n        # If both strings are not equal in size\\n        if len(s2) != n:\\n            return False\\n\\n        # If both strings are equal\\n        if s1 == s2:\\n            return True\\n\\n        # If code is reached to this condition then following this are sure:\\n        # 1. size of both string is equal\\n        # 2. string are not equal\\n        # so size is equal (where size==1) and they are not equal then obviously false\\n        # example \\'a\\' and \\'b\\' size is equal, string are not equal\\n        if n == 1:\\n            return False\\n\\n        key = s1 + \" \" + s2\\n\\n        # Check if this problem has already been solved\\n        if key in self.mp:\\n            return self.mp[key]\\n\\n        # For every iteration it can two condition\\n        # 1. We should proceed without swapping\\n        # 2. We should swap before looking next\\n        for i in range(1, n):\\n            # ex of without swap: gr|eat and rg|eat\\n            without_swap = (\\n                # Left part of first and second string\\n                self.isScramble(s1[:i], s2[:i])\\n                and\\n                # Right part of first and second string;\\n                self.isScramble(s1[i:], s2[i:])\\n            )\\n\\n            # If without swap gives us the right answer then we do not need\\n            # to call the recursion with swap\\n            if without_swap:\\n                return True\\n\\n            # ex of with swap: gr|eat rge|at\\n            # here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            with_swap = (\\n                # Left part of first and right part of second\\n                self.isScramble(s1[:i], s2[n-i:])\\n                and\\n                # Right part of first and left part of second\\n                self.isScramble(s1[i:], s2[:n-i])\\n            )\\n\\n            # If with swap gives us the right answer then we return True\\n            # otherwise, the for loop does its work\\n            if with_swap:\\n                return True\\n\\n        self.mp[key] = False\\n        return False\\n\\n    # for storing already solved problems\\n    mp = {}\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29459,
                "title": "python-recursive-solution",
                "content": "    class Solution:\\n    # @return a boolean\\n    def isScramble(self, s1, s2):\\n        n, m = len(s1), len(s2)\\n        if n != m or sorted(s1) != sorted(s2):\\n            return False\\n        if n < 4 or s1 == s2:\\n            return True\\n        f = self.isScramble\\n        for i in range(1, n):\\n            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\\\\n               f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\\n                return True\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @return a boolean\\n    def isScramble(self, s1, s2):\\n        n, m = len(s1), len(s2)\\n        if n != m or sorted(s1) != sorted(s2):\\n            return False\\n        if n < 4 or s1 == s2:\\n            return True\\n        f = self.isScramble\\n        for i in range(1, n):\\n            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\\\\n               f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\\n                return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 3357574,
                "title": "day-364-100-java-c-python-explained-intution-dry-run-proof",
                "content": "\\n\\n# Happy Sri Ram Navami to all !! \\uD83D\\uDEA9\\uD83D\\uDEA9\\uD83D\\uDEA9\\n![image.png](https://assets.leetcode.com/users/images/a2267944-10b8-41f2-b624-81a67ccea163_1680148646.205976.png)\\n# NOTE:- if you found anyone\\'s post helpful please upvote that post because some persons are downvoting unneccesarily, and you are the one guys that save our post from getting unvisible, upvote for remains visible for others so and other people can also get benefitted.\\n\\n##### \\u2022\\tThere are several ways to solve the Scramble String problem\\n##### \\u2022\\tRecursion with memoization: This is the approach used in the solution we discussed earlier. The idea is to recursively check all possible splits of the two strings, and memoize the results to avoid recomputing the same substrings multiple times.\\n##### \\u2022\\tDynamic programming: This approach involves building a 3D table to store the results of all possible substrings of the two strings. The table is filled in a bottom-up manner, starting with the smallest substrings and building up to the largest substrings. The table can then be used to check if the two strings are scrambled versions of each other.\\n##### \\u2022\\tTop-down dynamic programming: This approach is similar to recursion with memoization, but uses a 3D table to store the results of all possible substrings of the two strings. The table is filled in a top-down manner, starting with the largest substrings and building down to the smallest substrings. The table can then be used to check if the two strings are scrambled versions of each other.\\n##### \\u2022\\tBFS: This approach involves using a queue to generate all possible scrambled versions of one of the strings, and checking if any of them match the other string. The idea is to generate all possible substrings of the first string, and then generate all possible permutations of each substring. The resulting strings can then be checked to see if they match the second string.\\n##### \\u2022\\tAll of these approaches have the same time and space complexity of O(n^4), but they differ in their implementation details and performance characteristics.\\n\\n# Intuition &  Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tThe problem is to determine if two strings s1 and s2 are scrambled versions of each other. The algorithm works by recursively splitting the strings into two non-empty substrings and swapping them randomly. The algorithm stops when the length of the string is 1.\\n##### \\u2022\\tThe approach used to solve the problem use a recursive function that checks if the two strings are scrambled versions of each other. The function checks if the two strings are equal, and if not, it checks if the two strings have the same characters and if the substrings of the two strings are scrambled versions of each other.\\n##### \\u2022\\tThe algorithm uses an unordered map to store the results of previously computed substrings to avoid recomputing them. It also uses three vectors to keep track of the frequency of characters in the two strings and the current substring being checked.\\n##### \\u2022\\tThe intuition behind the algorithm is that if two strings are scrambled versions of each other, then they can be split into two non-empty substrings that are also scrambled versions of each other. The algorithm checks all possible splits of the two strings and recursively checks if the substrings are scrambled versions of each other.\\n##### \\u2022\\tThe algorithm starts by checking if the two strings are equal. If they are, it returns true. If not, it initializes three vectors to keep track of the frequency of characters in the two strings and the current substring being checked. It then checks if the current substring of s1 and s2 have the same characters. If they do, it recursively checks if the substrings of s1 and s2 are scrambled versions of each other. If they are, it returns true.\\n##### \\u2022\\tIf the current substrings of s1 and s2 do not have the same characters, the algorithm checks all possible splits of the two strings. For each split, it checks if the substrings of s1 and s2 are scrambled versions of each other. If they are, it returns true.\\n##### \\u2022\\tThe algorithm uses an unordered map to store the results of previously computed substrings to avoid recomputing them. If the current substring of s1 and s2 has already been computed, the algorithm returns the stored result.\\n##### \\u2022\\tOverall, the algorithm uses a recursive approach to check if two strings are scrambled versions of each other. It uses an unordered map and three vectors to store previously computed substrings and keep track of the frequency of characters in the two strings and the current substring being checked.\\n\\n\\n# here\\'s the complete recursion tree for the isScramble method with  s1 = \"great\" and  s2 = \"rgeat\"\\n\\n```\\nisScramble(\"great\", \"rgeat\")\\n           /           |           |           |           \\\\\\nisScramble(\"g\", \"r\")  isScramble(\"g\", \"at\")  isScramble(\"gr\", \"ra\")  isScramble(\"gr\", \"eat\")  isScramble(\"gre\", \"rge\")\\n           |           /           |           |           |           \\\\           |           /           |\\nisScramble(\"\", \"\")  isScramble(\"g\", \"a\")  isScramble(\"g\", \"r\")  isScramble(\"g\", \"e\")  isScramble(\"g\", \"r\")  isScramble(\"g\", \"r\")  isScramble(\"gr\", \"e\")  isScramble(\"gr\", \"g\")  isScramble(\"gr\", \"er\")  isScramble(\"gr\", \"gea\")  isScramble(\"gre\", \"rg\")  isScramble(\"gre\", \"er\")\\n      /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\\\nfalse  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  true\\n```\\n\\n\\n# Code\\n```java []\\nclass Solution {\\n    // to store previously computed substrings\\n    Map<String, Boolean> map = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        // check if the two strings are equal\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        // initialize frequency arrays for s1, s2, and current substring\\n        int[] a = new int[26], b = new int[26], c = new int[26];\\n        // check if the current substring has already been computed\\n        if (map.containsKey(s1 + s2)) {\\n            return map.get(s1 + s2);\\n        }\\n        // check all possible splits of the two strings\\n        for (int i = 1; i <= n - 1; i++) {\\n            int j = n - i;\\n            // update frequency arrays for s1, s2, and current substring\\n            a[s1.charAt(i - 1) - \\'a\\']++;\\n            b[s2.charAt(i - 1) - \\'a\\']++;\\n            c[s2.charAt(j) - \\'a\\']++;\\n            // check if the current substring has the same characters\\n            if (Arrays.equals(a, b) && isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i))) {\\n                // if the substrings are scrambled versions of each other, return true\\n                map.put(s1 + s2, true);\\n                return true;\\n            }\\n            // check if the current substring and its complement have the same characters\\n            if (Arrays.equals(a, c) && isScramble(s1.substring(0, i), s2.substring(j)) && isScramble(s1.substring(i), s2.substring(0, j))) {\\n                // if the substrings are scrambled versions of each other, return true\\n                map.put(s1 + s2, true);\\n                return true;\\n            }\\n        }\\n        // if none of the splits result in scrambled versions, return false\\n        map.put(s1 + s2, false);\\n        return false;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution\\n{\\n\\t// unordered map to store previously computed substrings\\n\\tunordered_map<string,bool> mp;\\n\\npublic:\\n\\tbool isScramble(string s1, string s2)\\n\\t{\\n\\t\\tint n = s1.size();\\n\\t\\t// check if the two strings are equal\\n\\t\\tif (s1 == s2)\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t// initialize frequency vectors for s1, s2, and current substring\\n\\t\\tvector a(26, 0), b(26, 0), c(26, 0);\\n\\t\\t// check if the current substring has already been computed\\n\\t\\tif (mp.count(s1 + s2))\\n\\t\\t{\\n\\t\\t\\treturn mp[s1 + s2];\\n\\t\\t}\\n\\t\\t// check all possible splits of the two strings\\n\\t\\tfor (int i = 1; i <= n - 1; i++)\\n\\t\\t{\\n\\t\\t\\tint j = n - i;\\n\\t\\t\\t// update frequency vectors for s1, s2, and current substring\\n\\t\\t\\ta[s1[i - 1] - \\'a\\']++;\\n\\t\\t\\tb[s2[i - 1] - \\'a\\']++;\\n\\t\\t\\tc[s2[j] - \\'a\\']++;\\n\\t\\t\\t// check if the current substring has the same characters\\n\\t\\t\\tif (a == b && isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\\n\\t\\t\\t{\\n\\t\\t\\t\\t// if the substrings are scrambled versions of each other, return true\\n\\t\\t\\t\\tmp[s1 + s2] = true;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\t// check if the current substring and its complement have the same characters\\n\\t\\t\\tif (a == c && isScramble(s1.substr(0, i), s2.substr(j)) && isScramble(s1.substr(i), s2.substr(0, j)))\\n\\t\\t\\t{\\n\\t\\t\\t\\t// if the substrings are scrambled versions of each other, return true\\n\\t\\t\\t\\tmp[s1 + s2] = true;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// if none of the splits result in scrambled versions, return false\\n\\t\\tmp[s1 + s2] = false;\\n\\t\\treturn false;\\n\\t}\\n};\\n```\\n```python []\\nclass Solution:\\n    # dictionary to store previously computed substrings\\n    map = {}\\n\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        # check if the two strings are equal\\n        if s1 == s2:\\n            return True\\n        # initialize frequency lists for s1, s2, and current substring\\n        a, b, c = [0] * 26, [0] * 26, [0] * 26\\n        # check if the current substring has already been computed\\n        if (s1 + s2) in self.map:\\n            return self.map[s1 + s2]\\n        # check all possible splits of the two strings\\n        for i in range(1, n):\\n            j = n - i\\n            # update frequency lists for s1, s2, and current substring\\n            a[ord(s1[i - 1]) - ord(\\'a\\')] += 1\\n            b[ord(s2[i - 1]) - ord(\\'a\\')] += 1\\n            c[ord(s2[j]) - ord(\\'a\\')] += 1\\n            # check if the current substring has the same characters\\n            if a == b and self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                # if the substrings are scrambled versions of each other, return True\\n                self.map[s1 + s2] = True\\n                return True\\n            # check if the current substring and its complement have the same characters\\n            if a == c and self.isScramble(s1[:i], s2[j:]) and self.isScramble(s1[i:], s2[:j]):\\n                # if the substrings are scrambled versions of each other, return True\\n                self.map[s1 + s2] = True\\n                return True\\n        # if none of the splits result in scrambled versions, return False\\n        self.map[s1 + s2] = False\\n        return False\\n```\\n\\n\\n\\n# Complexity\\n\\n##### \\u2022\\tThe time complexity of the algorithm is O(n^4), n is the length of the strings. This is because the algorithm checks all possible splits of the two strings, which takes O(n^2) time, and for each split, it recursively checks if the substrings are scrambled versions of each other, which takes O(n^2) time in the worst case. Therefore, the overall time complexity is O(n^2 * n^2) = O(n^4).\\n##### \\u2022\\tThe space complexity of the algorithm is also O(n^4), due to the use of the unordered map to store previously computed substrings. In the worst case, the map can store all possible substrings of the two strings, which takes O(n^4) space. Additionally, the algorithm uses three arrays to keep track of the frequency of characters in the two strings and the current substring being checked, which also takes O(n^3) space in the worst case. Therefore, the overall space complexity is O(n^4).\\n##### \\u2022\\tHowever, the use of the unordered map to store previously computed substrings allows the algorithm to avoid recomputing the same substrings multiple times, which can significantly improve the performance of the algorithm for large inputs.\\n\\n\\n\\n\\n# DP  Intuition\\n##### \\u2022\\tThe problem involves checking if two strings are scrambled versions of each other.\\n##### \\u2022\\tWe have a recursive definition of scrambling a string s, which involves dividing s into x and y, and scrambling x and y independently.\\n##### \\u2022\\tTo check if a given string t is a scrambled string of s, we choose an index and cut s into x and y, and see if we can cut t into scrambled versions of x and y.\\n##### \\u2022\\tWe can solve the problem using dynamic programming by defining a 3D table with variables for length, i, and j to represent the subproblems.\\n##### \\u2022\\tEach state focuses on two substrings: a substring of s1 starting at index i with length equal to length, and a substring of s2 starting at index j with length equal to length.\\n##### \\u2022\\tWe use a base case for substrings of length 1 and fill the table for substrings of length 2 to n.\\n##### \\u2022\\tAt each state, we perform a split on s1 and consider all possible splits, and write down the transitions for each case.\\n##### \\u2022\\tThe answer to the problem is dp[n][0][0], where n is the length of the input strings.\\n#\\tAlgorithm:\\n##### \\u2022\\tIterate i from 0 to n-1.\\n##### \\u2022\\tIterate j from 0 to n-1.\\n##### \\u2022\\tSet dp[1][i][j] to the boolean value of s1[i] == s2[j] (the base case of the DP).\\n##### \\u2022\\tIterate length from 2 to n.\\n##### \\u2022\\tIterate i from 0 to n + 1 - length.\\n##### \\u2022\\tIterate j from 0 to n + 1 - length.\\n##### \\u2022\\tIterate newLength from 1 to length - 1.\\n##### \\u2022\\tIf dp[newLength][i][j] && dp[length-newLength][i+newLength][j+newLength]) || (dp[newLength][i][j+l-newLength] && dp[l-newLength][i+newLength][j] is true, set dp[length][i][j] to true.\\n##### \\u2022\\tReturn dp[n][0][0].\\n\\n\\n\\n```PYTHON []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        # Initialize a 3D table to store the results of all possible substrings of the two strings\\n        dp = [[[False for _ in range(n)] for _ in range(n)] for _ in range(n+1)]\\n\\n        # Initialize the table for substrings of length 1\\n        for i in range(n):\\n            for j in range(n):\\n                dp[1][i][j] = s1[i] == s2[j]\\n\\n        # Fill the table for substrings of length 2 to n\\n        for length in range(2, n+1):\\n            for i in range(n+1-length):\\n                for j in range(n+1-length):\\n                    # Iterate over all possible lengths of the first substring\\n                    for newLength in range(1, length):\\n                        # Check if the two possible splits of the substrings are scrambled versions of each other\\n                        dp1 = dp[newLength][i]\\n                        dp2 = dp[length-newLength][i+newLength]\\n                        dp[length][i][j] |= dp1[j] and dp2[j+newLength]\\n                        dp[length][i][j] |= dp1[j+length-newLength] and dp2[j]\\n\\n        # Return whether the entire strings s1 and s2 are scrambled versions of each other\\n        return dp[n][0][0]\\n```\\n```JAVA []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        // Initialize a 3D table to store the results of all possible substrings of the two strings\\n        boolean[][][] dp = new boolean[n+1][n][n];\\n\\n        // Initialize the table for substrings of length 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[1][i][j] = s1.charAt(i) == s2.charAt(j);\\n            }\\n        }\\n\\n        // Fill the table for substrings of length 2 to n\\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    // Iterate over all possible lengths of the first substring\\n                    for (int newLength = 1; newLength < length; newLength++) {\\n                        // Check if the two possible splits of the substrings are scrambled versions of each other\\n                        boolean[] dp1 = dp[newLength][i];\\n                        boolean[] dp2 = dp[length-newLength][i+newLength];\\n                        dp[length][i][j] |= dp1[j] && dp2[j+newLength];\\n                        dp[length][i][j] |= dp1[j+length-newLength] && dp2[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return whether the entire strings s1 and s2 are scrambled versions of each other\\n        return dp[n][0][0];\\n    }\\n}\\n```\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.length();\\n        // Initialize a 3D table to store the results of all possible substrings of the two strings\\n        vector<vector<vector<bool>>> dp(n+1, vector<vector<bool>>(n, vector<bool>(n)));\\n\\n        // Initialize the table for substrings of length 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[1][i][j] = s1[i] == s2[j];\\n            }\\n        }\\n\\n        // Fill the table for substrings of length 2 to n\\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    // Iterate over all possible lengths of the first substring\\n                    for (int newLength = 1; newLength < length; newLength++) {\\n                        // Check if the two possible splits of the substrings are scrambled versions of each other\\n                        vector<bool>& dp1 = dp[newLength][i];\\n                        vector<bool>& dp2 = dp[length-newLength][i+newLength];\\n                        dp[length][i][j] |= dp1[j] && dp2[j+newLength];\\n                        dp[length][i][j] |= dp1[j+length-newLength] && dp2[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return whether the entire strings s1 and s2 are scrambled versions of each other\\n        return dp[n][0][0];\\n    }\\n};\\n```\\n\\n# TC & SC\\n\\n##### \\u2022\\tThe time complexity of this algorithm is O(n^4), and the space complexity is also O(n^4), due to the use of the 3D table. \\n##### \\u2022\\tHowever, this approach can be faster than the recursive approach with memoization for some inputs, since it avoids the overhead of function calls and memoization lookups.\\n\\n\\n# 3RD WAY RECURSIVE \\n\\n\\n```C++ []\\nclass Solution {\\n    bool isScrambleHelper(unordered_map<string, bool> &memo, string s1, string s2) {\\n        int i, len = s1.size();\\n        bool result = false;\\n\\n        // Base cases\\n        if (len == 0) {\\n            return true;\\n        } else if (len == 1) {\\n            return s1 == s2;\\n        } else {\\n            // Check if we have already computed the result for this pair of strings\\n            if (memo.count(s1 + s2)) {\\n                return memo[s1 + s2];\\n            }\\n\\n            // Check if the two strings are equal\\n            if (s1 == s2) {\\n                result = true;\\n            } else {\\n                // Check all possible split positions\\n                for (i = 1; i < len && !result; ++i) {\\n                    // Check if s1[0..i-1] and s2[0..i-1] are valid scrambles of each other\\n                    // and if s1[i..len-1] and s2[i..len-1] are valid scrambles of each other\\n                    result = result || (isScrambleHelper(memo, s1.substr(0, i), s2.substr(0, i)) && isScrambleHelper(memo, s1.substr(i, len - i), s2.substr(i, len - i)));\\n\\n                    // Check if s1[0..i-1] and s2[len-i..len-1] are valid scrambles of each other\\n                    // and if s1[i..len-1] and s2[0..len-i-1] are valid scrambles of each other\\n                    result = result || (isScrambleHelper(memo, s1.substr(0, i), s2.substr(len - i, i)) && isScrambleHelper(memo, s1.substr(i, len - i), s2.substr(0, len - i)));\\n                }\\n            }\\n\\n            // Save the intermediate result in the memoization table\\n            return memo[s1 + s2] = result;\\n        }\\n    }\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string, bool> memo;\\n        return isScrambleHelper(memo, s1, s2);\\n    }\\n};\\n```\\n```PYTHON []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        if n != len(s2):\\n            return False\\n        if n == 0:\\n            return True\\n        elif n == 1:\\n            return s1 == s2\\n        else:\\n            memo = {}\\n            return self.isScrambleHelper(memo, s1, s2)\\n\\n    def isScrambleHelper(self, memo: dict, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        result = False\\n\\n        if n == 0:\\n            return True\\n        elif n == 1:\\n            return s1 == s2\\n        else:\\n            if (s1, s2) in memo:\\n                return memo[(s1, s2)]\\n\\n            if s1 == s2:\\n                result = True\\n            else:\\n                for i in range(1, n):\\n                    result = (self.isScrambleHelper(memo, s1[:i], s2[:i]) and self.isScrambleHelper(memo, s1[i:], s2[i:])) or \\\\\\n                             (self.isScrambleHelper(memo, s1[:i], s2[n - i:]) and self.isScrambleHelper(memo, s1[i:], s2[:n - i]))\\n                    if result:\\n                        break\\n\\n            memo[(s1, s2)] = result\\n            return result\\n```\\n```JAVA []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        int len = s1.length();\\n        if (len != s2.length()) {\\n            return false;\\n        }\\n        if (len == 0) {\\n            return true;\\n        } else if (len == 1) {\\n            return s1.equals(s2);\\n        } else {\\n            Map<String, Boolean> memo = new HashMap<>();\\n            return isScrambleHelper(memo, s1, s2);\\n        }\\n    }\\n\\n    private boolean isScrambleHelper(Map<String, Boolean> memo, String s1, String s2) {\\n        int len = s1.length();\\n        boolean result = false;\\n\\n        if (len == 0) {\\n            return true;\\n        } else if (len == 1) {\\n            return s1.equals(s2);\\n        } else {\\n            if (memo.containsKey(s1 + s2)) {\\n                return memo.get(s1 + s2);\\n            }\\n\\n            if (s1.equals(s2)) {\\n                result = true;\\n            } else {\\n                for (int i = 1; i < len && !result; i++) {\\n                    result = (isScrambleHelper(memo, s1.substring(0, i), s2.substring(0, i)) && isScrambleHelper(memo, s1.substring(i), s2.substring(i))) ||\\n                             (isScrambleHelper(memo, s1.substring(0, i), s2.substring(len - i)) && isScrambleHelper(memo, s1.substring(i), s2.substring(0, len - i)));\\n                }\\n            }\\n\\n            memo.put(s1 + s2, result);\\n            return result;\\n        }\\n    }\\n}\\n```\\n\\n# TC & SC\\n\\n##### \\u2022\\tThe time complexity of the given solution is O(n^4), where n is the length of the input strings. This is because we are checking all possible split positions for each substring, which takes O(n^2) time, and we are doing this for all possible substrings, which takes another O(n^2) time. The recursive calls also add to the time complexity.\\n##### \\u2022\\tThe space complexity of the given solution is O(n^3), which is the size of the memoization table. This is because we are storing the results of all possible substring pairs in the memoization table.\\n\\n# 4th way  cache is implemented\\n```c++ []\\nclass Solution {\\nprivate:\\n   bool DP_helper(string &s1, string &s2, int idx1, int idx2, int len, char isS[]) {\\n        int sSize = s1.size(), i, j, k, hist[26], zero_count = 0;\\n\\n        // Check if we have already computed the result for this substring pair\\n        if (isS[(len * sSize + idx1) * sSize + idx2]) {\\n            return isS[(len * sSize + idx1) * sSize + idx2] == 1;\\n        }\\n\\n        bool res = false;\\n\\n        // Count the frequency of each character in the two substrings\\n        fill_n(hist, 26, 0);\\n        for (k = 0; k < len; ++k) {\\n            zero_count += (0 == hist[s1[idx1 + k] - \\'a\\']) - (0 == ++hist[s1[idx1 + k] - \\'a\\']);\\n            zero_count += (0 == hist[s2[idx2 + k] - \\'a\\']) - (0 == --hist[s2[idx2 + k] - \\'a\\']);\\n        }\\n\\n        // If the two substrings have different characters, return false\\n        if (zero_count) {\\n            isS[(len * sSize + idx1) * sSize + idx2] = 2;\\n            return false;\\n        }\\n\\n        // If the length of the substrings is 1, return true\\n        if (len == 1) {\\n            isS[(len * sSize + idx1) * sSize + idx2] = 1;\\n            return true;\\n        }\\n\\n        // Recursively check all possible split positions\\n        for (k = 1; k < len && !res; ++k) {\\n            res = res || (DP_helper(s1, s2, idx1, idx2, k, isS) && DP_helper(s1, s2, idx1 + k, idx2 + k, len - k, isS));\\n            res = res || (DP_helper(s1, s2, idx1 + len - k, idx2, k, isS) && DP_helper(s1, s2, idx1, idx2 + k, len - k, isS));\\n        }\\n\\n        // Save the intermediate result in the cache\\n        isS[(len * sSize + idx1) * sSize + idx2] = res ? 1 : 2;\\n        return res;\\n    }\\n\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        const int sSize = s1.size();\\n\\n        // Base case: empty strings are always valid scrambles of each other\\n        if (0 == sSize) {\\n            return true;\\n        }\\n\\n        // Initialize the cache\\n        char isS[(sSize + 1) * sSize * sSize];\\n        fill_n(isS, (sSize + 1) * sSize * sSize, 0);\\n\\n        // Recursively check if s1 and s2 are valid scrambles of each other\\n        return DP_helper(s1, s2, 0, 0, sSize, isS);\\n    }\\n};\\n```\\n# explaination \\n\\n##### \\u2022\\tIt does this by recursively checking all possible split positions of the two strings, and caching the intermediate results to avoid redundant computations. \\n##### \\u2022\\tThe cache is implemented as a one-dimensional array isS , where isS[idx1 * sSize + idx2 + len * sSize * sSize] stores the result of checking whether the substring of s1 starting at index idx1 and the substring of s2 starting at index idx2 , both of length len , are valid scrambles of each other. The value of isS[idx1 * sSize + idx2 + len * sSize * sSize] can be either 0 (not computed yet), 1 (valid scramble), or 2 (invalid scramble). \\n##### \\u2022\\tThe recursion is implemented in the DP_helper function, which takes as input the two strings s1 and s2 , the starting indices idx1 and idx2 , the length len , and the cache isS . \\n##### \\u2022\\tThe function first checks if the result for this substring pair has already been computed and cached, and returns the cached result if it exists. \\n##### \\u2022\\tOtherwise, it counts the frequency of each character in the two substrings, and returns false if the two substrings have different characters. If the length of the substrings is 1, the function returns true.\\n##### \\u2022\\tIf the two substrings have the same character set, the function recursively checks all possible split positions and returns true if any of them are valid scrambles of each other. \\n##### \\u2022\\tFinally, the function saves the intermediate result in the cache and returns the result. \\n##### \\u2022\\tTo optimize the recursion, the function uses early pruning by checking if the two substrings have the same character set before recursively checking all possible split positions. \\n##### \\u2022\\tIf the two substrings have different character sets, the function immediately returns false without doing any further computation. \\n##### \\u2022\\tThis helps to reduce the number of recursive calls and improve the overall performance of the algorithm.\\n\\n\\n# DRY RUN 1\\n\\n##### \\u2022\\tLet\\'s dry run the algorithm with the input \"great\" andrgeat\".\\n##### \\u2022\\tFirst, the algorithm checks if the two strings are equal. Since they are not, it initializes the frequency vectors for s1, s2, and the current substring, and checks if the current substring has already been computed in the unordered map. Since it has not, the algorithm proceeds to check all possible splits of the two strings.\\n##### \\u2022\\tFor the first split, i = 1 and j = 4. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"g\" and \"r\" are different, the algorithm moves on to the next split.\\n##### \\u2022\\tFor the second split, i = 2 and j = 3. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"gr\" and \"rg\" have the same characters, the algorithm recursively checks if the substrings of s1 and s2 are scrambled versions of each other. It does this by calling the isScramble function with the substrings \"g\" and \"r\" for both s1 and s2. Since \"g\" and \"r\" are not scrambled versions of each other, the algorithm backtracks and checks the other possible split.\\n##### \\u2022\\tFor the third split, i = 3 and j = 2. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"gre\" and \"rge\" have the same characters, the algorithm recursively checks if the substrings of s1 and s2 are scrambled versions of each other. It does this by calling the isScramble function with the substrings \"g\" and \"r\" for s1 and s2, and the substrings \"re\" and \"eat\" for s1 and s2. Since \"g\" and \"r\" are not scrambled versions of each other, the algorithm backtracks and checks the other possible split.\\n##### \\u2022\\tFor the fourth split, i = 4 and j = 1. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"reat\" and \"rgea\" have the same characters, the algorithm recursively checks if the substrings of s1 and s2 are scrambled versions of each other. It does this by calling the  isScramble function with the substrings \"r\" and \"r\" for s1 and s2, and the substrings \"eat\" and \"gea\" for s1 and s2. Since \"r\" and \"r\" are scrambled versions of each other, the algorithm proceeds to check if \"eat\" and \"gea\" are scrambled versions of each other. It does this by calling the  isScramble function with the substrings \"e\" and \"e\" for s1 and s2, and the substrings \"at\" and \"ga\" for s1 and s2. Since \"e\" and \"e\" are scrambled versions of each other, the algorithm proceeds to check if \"at\" and \"ga\" are scrambled versions of each other. It does this by calling the  isScramble function with the substrings \"a\" and \"a\" for s1 and s2, and the substrings \"t\" and \"g\" for s1 and s2. Since \"a\" and \"a\" are scrambled versions of each other, and \"t\" and \"g\" are scrambled versions of each other, the algorithm returns true.\\n##### \\u2022\\tTherefore, the output of the algorithm for the input \"great\" and \"rgeat\" is true, indicating that the two strings are scrambled versions of each other.\\n\\n# DRY RUN 2\\n##### \\u2022\\tLet\\'s dry run the algorithm with the input \"abcde\" and \"caebd\".\\n##### \\u2022\\tFirst, the algorithm checks if the two strings are equal. Since they are not, it initializes the frequency vectors for s1, s2, and the current substring, and checks if the current substring has already been computed in the unordered map. Since it has not, the algorithm proceeds to check all possible splits of the two strings.\\n##### \\u2022\\tFor the first split, i = 1 and j = 4. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"a\" and \"c\" are different, the algorithm moves on to the next split.\\n##### \\u2022\\tFor the second split, i = 2 and j = 3. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"ab\" and \"ca\" have different characters, the algorithm moves on to the next split.\\n##### \\u2022\\tFor the third split, i = 3 and j = 2. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"abc\" and \"cae\" have different characters, the algorithm moves on to the next split.\\n##### \\u2022\\tFor the fourth split, i = 4 and j = 1. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"abcd\" and \"caeb\" have different characters, the algorithm moves on to the next split.\\n##### \\u2022\\tSince none of the splits result in scrambled versions of each other, the algorithm returns false.\\n##### \\u2022\\tTherefore, the output of the algorithm for the input \"abcde\" and \"caebd\" is false, indicating that the two strings are not scrambled versions of each other.\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n![meme2.png](https://assets.leetcode.com/users/images/d588f492-3f95-45f6-8e4a-10d6069002a5_1680054021.7117147.png)\\n\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nisScramble(\"great\", \"rgeat\")\\n           /           |           |           |           \\\\\\nisScramble(\"g\", \"r\")  isScramble(\"g\", \"at\")  isScramble(\"gr\", \"ra\")  isScramble(\"gr\", \"eat\")  isScramble(\"gre\", \"rge\")\\n           |           /           |           |           |           \\\\           |           /           |\\nisScramble(\"\", \"\")  isScramble(\"g\", \"a\")  isScramble(\"g\", \"r\")  isScramble(\"g\", \"e\")  isScramble(\"g\", \"r\")  isScramble(\"g\", \"r\")  isScramble(\"gr\", \"e\")  isScramble(\"gr\", \"g\")  isScramble(\"gr\", \"er\")  isScramble(\"gr\", \"gea\")  isScramble(\"gre\", \"rg\")  isScramble(\"gre\", \"er\")\\n      /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\\\nfalse  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  true\\n```\n```java []\\nclass Solution {\\n    // to store previously computed substrings\\n    Map<String, Boolean> map = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        // check if the two strings are equal\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        // initialize frequency arrays for s1, s2, and current substring\\n        int[] a = new int[26], b = new int[26], c = new int[26];\\n        // check if the current substring has already been computed\\n        if (map.containsKey(s1 + s2)) {\\n            return map.get(s1 + s2);\\n        }\\n        // check all possible splits of the two strings\\n        for (int i = 1; i <= n - 1; i++) {\\n            int j = n - i;\\n            // update frequency arrays for s1, s2, and current substring\\n            a[s1.charAt(i - 1) - \\'a\\']++;\\n            b[s2.charAt(i - 1) - \\'a\\']++;\\n            c[s2.charAt(j) - \\'a\\']++;\\n            // check if the current substring has the same characters\\n            if (Arrays.equals(a, b) && isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i))) {\\n                // if the substrings are scrambled versions of each other, return true\\n                map.put(s1 + s2, true);\\n                return true;\\n            }\\n            // check if the current substring and its complement have the same characters\\n            if (Arrays.equals(a, c) && isScramble(s1.substring(0, i), s2.substring(j)) && isScramble(s1.substring(i), s2.substring(0, j))) {\\n                // if the substrings are scrambled versions of each other, return true\\n                map.put(s1 + s2, true);\\n                return true;\\n            }\\n        }\\n        // if none of the splits result in scrambled versions, return false\\n        map.put(s1 + s2, false);\\n        return false;\\n    }\\n}\\n```\n```c++ []\\nclass Solution\\n{\\n\\t// unordered map to store previously computed substrings\\n\\tunordered_map<string,bool> mp;\\n\\npublic:\\n\\tbool isScramble(string s1, string s2)\\n\\t{\\n\\t\\tint n = s1.size();\\n\\t\\t// check if the two strings are equal\\n\\t\\tif (s1 == s2)\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t// initialize frequency vectors for s1, s2, and current substring\\n\\t\\tvector a(26, 0), b(26, 0), c(26, 0);\\n\\t\\t// check if the current substring has already been computed\\n\\t\\tif (mp.count(s1 + s2))\\n\\t\\t{\\n\\t\\t\\treturn mp[s1 + s2];\\n\\t\\t}\\n\\t\\t// check all possible splits of the two strings\\n\\t\\tfor (int i = 1; i <= n - 1; i++)\\n\\t\\t{\\n\\t\\t\\tint j = n - i;\\n\\t\\t\\t// update frequency vectors for s1, s2, and current substring\\n\\t\\t\\ta[s1[i - 1] - \\'a\\']++;\\n\\t\\t\\tb[s2[i - 1] - \\'a\\']++;\\n\\t\\t\\tc[s2[j] - \\'a\\']++;\\n\\t\\t\\t// check if the current substring has the same characters\\n\\t\\t\\tif (a == b && isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\\n\\t\\t\\t{\\n\\t\\t\\t\\t// if the substrings are scrambled versions of each other, return true\\n\\t\\t\\t\\tmp[s1 + s2] = true;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\t// check if the current substring and its complement have the same characters\\n\\t\\t\\tif (a == c && isScramble(s1.substr(0, i), s2.substr(j)) && isScramble(s1.substr(i), s2.substr(0, j)))\\n\\t\\t\\t{\\n\\t\\t\\t\\t// if the substrings are scrambled versions of each other, return true\\n\\t\\t\\t\\tmp[s1 + s2] = true;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// if none of the splits result in scrambled versions, return false\\n\\t\\tmp[s1 + s2] = false;\\n\\t\\treturn false;\\n\\t}\\n};\\n```\n```python []\\nclass Solution:\\n    # dictionary to store previously computed substrings\\n    map = {}\\n\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        # check if the two strings are equal\\n        if s1 == s2:\\n            return True\\n        # initialize frequency lists for s1, s2, and current substring\\n        a, b, c = [0] * 26, [0] * 26, [0] * 26\\n        # check if the current substring has already been computed\\n        if (s1 + s2) in self.map:\\n            return self.map[s1 + s2]\\n        # check all possible splits of the two strings\\n        for i in range(1, n):\\n            j = n - i\\n            # update frequency lists for s1, s2, and current substring\\n            a[ord(s1[i - 1]) - ord(\\'a\\')] += 1\\n            b[ord(s2[i - 1]) - ord(\\'a\\')] += 1\\n            c[ord(s2[j]) - ord(\\'a\\')] += 1\\n            # check if the current substring has the same characters\\n            if a == b and self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                # if the substrings are scrambled versions of each other, return True\\n                self.map[s1 + s2] = True\\n                return True\\n            # check if the current substring and its complement have the same characters\\n            if a == c and self.isScramble(s1[:i], s2[j:]) and self.isScramble(s1[i:], s2[:j]):\\n                # if the substrings are scrambled versions of each other, return True\\n                self.map[s1 + s2] = True\\n                return True\\n        # if none of the splits result in scrambled versions, return False\\n        self.map[s1 + s2] = False\\n        return False\\n```\n```PYTHON []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        # Initialize a 3D table to store the results of all possible substrings of the two strings\\n        dp = [[[False for _ in range(n)] for _ in range(n)] for _ in range(n+1)]\\n\\n        # Initialize the table for substrings of length 1\\n        for i in range(n):\\n            for j in range(n):\\n                dp[1][i][j] = s1[i] == s2[j]\\n\\n        # Fill the table for substrings of length 2 to n\\n        for length in range(2, n+1):\\n            for i in range(n+1-length):\\n                for j in range(n+1-length):\\n                    # Iterate over all possible lengths of the first substring\\n                    for newLength in range(1, length):\\n                        # Check if the two possible splits of the substrings are scrambled versions of each other\\n                        dp1 = dp[newLength][i]\\n                        dp2 = dp[length-newLength][i+newLength]\\n                        dp[length][i][j] |= dp1[j] and dp2[j+newLength]\\n                        dp[length][i][j] |= dp1[j+length-newLength] and dp2[j]\\n\\n        # Return whether the entire strings s1 and s2 are scrambled versions of each other\\n        return dp[n][0][0]\\n```\n```JAVA []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        // Initialize a 3D table to store the results of all possible substrings of the two strings\\n        boolean[][][] dp = new boolean[n+1][n][n];\\n\\n        // Initialize the table for substrings of length 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[1][i][j] = s1.charAt(i) == s2.charAt(j);\\n            }\\n        }\\n\\n        // Fill the table for substrings of length 2 to n\\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    // Iterate over all possible lengths of the first substring\\n                    for (int newLength = 1; newLength < length; newLength++) {\\n                        // Check if the two possible splits of the substrings are scrambled versions of each other\\n                        boolean[] dp1 = dp[newLength][i];\\n                        boolean[] dp2 = dp[length-newLength][i+newLength];\\n                        dp[length][i][j] |= dp1[j] && dp2[j+newLength];\\n                        dp[length][i][j] |= dp1[j+length-newLength] && dp2[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return whether the entire strings s1 and s2 are scrambled versions of each other\\n        return dp[n][0][0];\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.length();\\n        // Initialize a 3D table to store the results of all possible substrings of the two strings\\n        vector<vector<vector<bool>>> dp(n+1, vector<vector<bool>>(n, vector<bool>(n)));\\n\\n        // Initialize the table for substrings of length 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[1][i][j] = s1[i] == s2[j];\\n            }\\n        }\\n\\n        // Fill the table for substrings of length 2 to n\\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    // Iterate over all possible lengths of the first substring\\n                    for (int newLength = 1; newLength < length; newLength++) {\\n                        // Check if the two possible splits of the substrings are scrambled versions of each other\\n                        vector<bool>& dp1 = dp[newLength][i];\\n                        vector<bool>& dp2 = dp[length-newLength][i+newLength];\\n                        dp[length][i][j] |= dp1[j] && dp2[j+newLength];\\n                        dp[length][i][j] |= dp1[j+length-newLength] && dp2[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return whether the entire strings s1 and s2 are scrambled versions of each other\\n        return dp[n][0][0];\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\n    bool isScrambleHelper(unordered_map<string, bool> &memo, string s1, string s2) {\\n        int i, len = s1.size();\\n        bool result = false;\\n\\n        // Base cases\\n        if (len == 0) {\\n            return true;\\n        } else if (len == 1) {\\n            return s1 == s2;\\n        } else {\\n            // Check if we have already computed the result for this pair of strings\\n            if (memo.count(s1 + s2)) {\\n                return memo[s1 + s2];\\n            }\\n\\n            // Check if the two strings are equal\\n            if (s1 == s2) {\\n                result = true;\\n            } else {\\n                // Check all possible split positions\\n                for (i = 1; i < len && !result; ++i) {\\n                    // Check if s1[0..i-1] and s2[0..i-1] are valid scrambles of each other\\n                    // and if s1[i..len-1] and s2[i..len-1] are valid scrambles of each other\\n                    result = result || (isScrambleHelper(memo, s1.substr(0, i), s2.substr(0, i)) && isScrambleHelper(memo, s1.substr(i, len - i), s2.substr(i, len - i)));\\n\\n                    // Check if s1[0..i-1] and s2[len-i..len-1] are valid scrambles of each other\\n                    // and if s1[i..len-1] and s2[0..len-i-1] are valid scrambles of each other\\n                    result = result || (isScrambleHelper(memo, s1.substr(0, i), s2.substr(len - i, i)) && isScrambleHelper(memo, s1.substr(i, len - i), s2.substr(0, len - i)));\\n                }\\n            }\\n\\n            // Save the intermediate result in the memoization table\\n            return memo[s1 + s2] = result;\\n        }\\n    }\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string, bool> memo;\\n        return isScrambleHelper(memo, s1, s2);\\n    }\\n};\\n```\n```PYTHON []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        if n != len(s2):\\n            return False\\n        if n == 0:\\n            return True\\n        elif n == 1:\\n            return s1 == s2\\n        else:\\n            memo = {}\\n            return self.isScrambleHelper(memo, s1, s2)\\n\\n    def isScrambleHelper(self, memo: dict, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        result = False\\n\\n        if n == 0:\\n            return True\\n        elif n == 1:\\n            return s1 == s2\\n        else:\\n            if (s1, s2) in memo:\\n                return memo[(s1, s2)]\\n\\n            if s1 == s2:\\n                result = True\\n            else:\\n                for i in range(1, n):\\n                    result = (self.isScrambleHelper(memo, s1[:i], s2[:i]) and self.isScrambleHelper(memo, s1[i:], s2[i:])) or \\\\\\n                             (self.isScrambleHelper(memo, s1[:i], s2[n - i:]) and self.isScrambleHelper(memo, s1[i:], s2[:n - i]))\\n                    if result:\\n                        break\\n\\n            memo[(s1, s2)] = result\\n            return result\\n```\n```JAVA []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        int len = s1.length();\\n        if (len != s2.length()) {\\n            return false;\\n        }\\n        if (len == 0) {\\n            return true;\\n        } else if (len == 1) {\\n            return s1.equals(s2);\\n        } else {\\n            Map<String, Boolean> memo = new HashMap<>();\\n            return isScrambleHelper(memo, s1, s2);\\n        }\\n    }\\n\\n    private boolean isScrambleHelper(Map<String, Boolean> memo, String s1, String s2) {\\n        int len = s1.length();\\n        boolean result = false;\\n\\n        if (len == 0) {\\n            return true;\\n        } else if (len == 1) {\\n            return s1.equals(s2);\\n        } else {\\n            if (memo.containsKey(s1 + s2)) {\\n                return memo.get(s1 + s2);\\n            }\\n\\n            if (s1.equals(s2)) {\\n                result = true;\\n            } else {\\n                for (int i = 1; i < len && !result; i++) {\\n                    result = (isScrambleHelper(memo, s1.substring(0, i), s2.substring(0, i)) && isScrambleHelper(memo, s1.substring(i), s2.substring(i))) ||\\n                             (isScrambleHelper(memo, s1.substring(0, i), s2.substring(len - i)) && isScrambleHelper(memo, s1.substring(i), s2.substring(0, len - i)));\\n                }\\n            }\\n\\n            memo.put(s1 + s2, result);\\n            return result;\\n        }\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\nprivate:\\n   bool DP_helper(string &s1, string &s2, int idx1, int idx2, int len, char isS[]) {\\n        int sSize = s1.size(), i, j, k, hist[26], zero_count = 0;\\n\\n        // Check if we have already computed the result for this substring pair\\n        if (isS[(len * sSize + idx1) * sSize + idx2]) {\\n            return isS[(len * sSize + idx1) * sSize + idx2] == 1;\\n        }\\n\\n        bool res = false;\\n\\n        // Count the frequency of each character in the two substrings\\n        fill_n(hist, 26, 0);\\n        for (k = 0; k < len; ++k) {\\n            zero_count += (0 == hist[s1[idx1 + k] - \\'a\\']) - (0 == ++hist[s1[idx1 + k] - \\'a\\']);\\n            zero_count += (0 == hist[s2[idx2 + k] - \\'a\\']) - (0 == --hist[s2[idx2 + k] - \\'a\\']);\\n        }\\n\\n        // If the two substrings have different characters, return false\\n        if (zero_count) {\\n            isS[(len * sSize + idx1) * sSize + idx2] = 2;\\n            return false;\\n        }\\n\\n        // If the length of the substrings is 1, return true\\n        if (len == 1) {\\n            isS[(len * sSize + idx1) * sSize + idx2] = 1;\\n            return true;\\n        }\\n\\n        // Recursively check all possible split positions\\n        for (k = 1; k < len && !res; ++k) {\\n            res = res || (DP_helper(s1, s2, idx1, idx2, k, isS) && DP_helper(s1, s2, idx1 + k, idx2 + k, len - k, isS));\\n            res = res || (DP_helper(s1, s2, idx1 + len - k, idx2, k, isS) && DP_helper(s1, s2, idx1, idx2 + k, len - k, isS));\\n        }\\n\\n        // Save the intermediate result in the cache\\n        isS[(len * sSize + idx1) * sSize + idx2] = res ? 1 : 2;\\n        return res;\\n    }\\n\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        const int sSize = s1.size();\\n\\n        // Base case: empty strings are always valid scrambles of each other\\n        if (0 == sSize) {\\n            return true;\\n        }\\n\\n        // Initialize the cache\\n        char isS[(sSize + 1) * sSize * sSize];\\n        fill_n(isS, (sSize + 1) * sSize * sSize, 0);\\n\\n        // Recursively check if s1 and s2 are valid scrambles of each other\\n        return DP_helper(s1, s2, 0, 0, sSize, isS);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227919,
                "title": "well-commented-code-dp-memoization-mcm",
                "content": "```\\nclass Solution {\\npublic:\\n//for storing already solved problems\\n    unordered_map<string,bool> mp;\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        //base cases\\n        \\n        int n = s1.size();\\n        \\n        //if both string are not equal in size\\n        if(s2.size()!=n)\\n            return false;\\n        \\n        //if both string are equal\\n        if(s1==s2)\\n         return true;   \\n        \\n            \\n        \\n        //if code is reached to this condition then following this are sure:\\n        //1. size of both string is equal\\n        //2.  string are not equal\\n        //so size is equal (where size==1) and they are not equal then obviously false\\n        //example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if(n==1)\\n            return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n\\t\\t//check if this problem has already been solved\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        //for every iteration it can two condition \\n        //1.we should proceed without swapping\\n        //2.we should swap before looking next\\n        for(int i=1;i<n;i++)\\n        {\\n\\n            //ex of without swap: gr|eat and rg|eat\\n            bool withoutswap = (\\n                //left part of first and second string\\n                isScramble(s1.substr(0,i),s2.substr(0,i)) \\n                \\n                &&\\n                \\n                //right part of first and second string;\\n                isScramble(s1.substr(i),s2.substr(i))\\n                );\\n            \\n            \\n            \\n            //if without swap give us right answer then we do not need \\n            //to call the recursion withswap\\n            if(withoutswap)\\n                return true;\\n            \\n            //ex of withswap: gr|eat  rge|at\\n\\t\\t\\t//here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            bool withswap = (\\n                //left part of first and right part of second \\n                isScramble(s1.substr(0,i),s2.substr(n-i)) \\n                \\n                &&\\n                \\n                //right part of first and left part of second\\n                isScramble(s1.substr(i),s2.substr(0,n-i)) \\n                );\\n            \\n            \\n            \\n            //if withswap give us right answer then we return true\\n            //otherwise the for loop do it work\\n            if(withswap)\\n                return true;\\n            //we are not returning false in else case \\n            //because we want to check further cases with the for loop\\n        }\\n        \\n        \\n        return mp[key] = false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//for storing already solved problems\\n    unordered_map<string,bool> mp;\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        //base cases\\n        \\n        int n = s1.size();\\n        \\n        //if both string are not equal in size\\n        if(s2.size()!=n)\\n            return false;\\n        \\n        //if both string are equal\\n        if(s1==s2)\\n         return true;   \\n        \\n            \\n        \\n        //if code is reached to this condition then following this are sure:\\n        //1. size of both string is equal\\n        //2.  string are not equal\\n        //so size is equal (where size==1) and they are not equal then obviously false\\n        //example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if(n==1)\\n            return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n\\t\\t//check if this problem has already been solved\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        //for every iteration it can two condition \\n        //1.we should proceed without swapping\\n        //2.we should swap before looking next\\n        for(int i=1;i<n;i++)\\n        {\\n\\n            //ex of without swap: gr|eat and rg|eat\\n            bool withoutswap = (\\n                //left part of first and second string\\n                isScramble(s1.substr(0,i),s2.substr(0,i)) \\n                \\n                &&\\n                \\n                //right part of first and second string;\\n                isScramble(s1.substr(i),s2.substr(i))\\n                );\\n            \\n            \\n            \\n            //if without swap give us right answer then we do not need \\n            //to call the recursion withswap\\n            if(withoutswap)\\n                return true;\\n            \\n            //ex of withswap: gr|eat  rge|at\\n\\t\\t\\t//here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            bool withswap = (\\n                //left part of first and right part of second \\n                isScramble(s1.substr(0,i),s2.substr(n-i)) \\n                \\n                &&\\n                \\n                //right part of first and left part of second\\n                isScramble(s1.substr(i),s2.substr(0,n-i)) \\n                );\\n            \\n            \\n            \\n            //if withswap give us right answer then we return true\\n            //otherwise the for loop do it work\\n            if(withswap)\\n                return true;\\n            //we are not returning false in else case \\n            //because we want to check further cases with the for loop\\n        }\\n        \\n        \\n        return mp[key] = false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357546,
                "title": "python3-35ms-beats-99-38-recursion-with-memoization",
                "content": "The solution uses recursion with memoization to check all possible partitions of the two strings and determine if they are scrambled versions of each other. The memoization is achieved using a dictionary m that stores the result of previous computations for the same inputs.\\n\\nThe func function takes in two strings s1 and s2, and returns a boolean value indicating whether they are scrambled versions of each other. The function first checks the length of the strings - if they are both of length 1, it simply compares the characters. If the sorted characters in the two strings are not equal, it returns False.\\n\\nOtherwise, the function loops through all possible partitions of s1 and checks if they are valid scrambles of corresponding partitions in s2. The partitions are formed by looping through the length of s1 from index 1 to the end. If a valid partition is found, the function recursively checks the remaining partitions to see if they are also valid scrambles.\\n\\nIf at least one valid partition is found, the function returns True and stores the result in the m dictionary. If no valid partitions are found, the function returns False and stores the result in the m dictionary.\\n\\nFinally, the isScramble function calls the func function with the two input strings and returns the resulting boolean value.\\n# Please Upvote \\uD83D\\uDE07\\n![image.png](https://assets.leetcode.com/users/images/a85197c0-ca4e-4b4b-9d0e-6c3e999491f0_1680140610.86559.png)\\n\\n\\n# Python3\\n```\\nclass Solution:\\n    def isScramble(self,s1, s2):\\n        m ={}\\n        def func(s1, s2):\\n            if (s1, s2) in m:\\n                return m[(s1, s2)]\\n            if not sorted(s1) == sorted(s2):\\n                return False\\n            if len(s1) == 1:\\n                return True\\n            \\n\\n            for i in range(1, len(s1)):\\n                if func(s1[:i], s2[-i:]) and func(s1[i:], s2[:-i]) or func(s1[:i], s2[:i]) and func(s1[i:], s2[i:]):\\n                    m[(s1, s2)] = True\\n                    return True\\n            m[(s1, s2)] = False\\n            return False\\n        return func(s1, s2)\\n\\n\\n\\n\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self,s1, s2):\\n        m ={}\\n        def func(s1, s2):\\n            if (s1, s2) in m:\\n                return m[(s1, s2)]\\n            if not sorted(s1) == sorted(s2):\\n                return False\\n            if len(s1) == 1:\\n                return True\\n            \\n\\n            for i in range(1, len(s1)):\\n                if func(s1[:i], s2[-i:]) and func(s1[i:], s2[:-i]) or func(s1[:i], s2[:i]) and func(s1[i:], s2[i:]):\\n                    m[(s1, s2)] = True\\n                    return True\\n            m[(s1, s2)] = False\\n            return False\\n        return func(s1, s2)\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29452,
                "title": "python-dp-solutions-with-and-without-memorization",
                "content": "    # DP \\n    def isScramble1(self, s1, s2):\\n        if len(s1) != len(s2):\\n            return False\\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2): # prunning\\n            return False\\n        for i in xrange(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\\\\n            (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                return True\\n        return False\\n        \\n    # DP with memorization\\n    def __init__(self):\\n        self.dic = {}\\n        \\n    def isScramble(self, s1, s2):\\n        if (s1, s2) in self.dic:\\n            return self.dic[(s1, s2)]\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2): # prunning\\n            self.dic[(s1, s2)] = False\\n            return False\\n        if s1 == s2:\\n            self.dic[(s1, s2)] = True\\n            return True\\n        for i in xrange(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\\\\n            (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                return True\\n        self.dic[(s1, s2)] = False\\n        return False",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    # DP \\n    def isScramble1(self, s1, s2):\\n        if len(s1) != len(s2):\\n            return False\\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2): # prunning\\n            return False\\n        for i in xrange(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\\\\n            (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                return True\\n        return False\\n        \\n    # DP with memorization\\n    def __init__(self):\\n        self.dic = {}\\n        \\n    def isScramble(self, s1, s2):\\n        if (s1, s2) in self.dic:\\n            return self.dic[(s1, s2)]\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2): # prunning\\n            self.dic[(s1, s2)] = False\\n            return False\\n        if s1 == s2:\\n            self.dic[(s1, s2)] = True\\n            return True\\n        for i in xrange(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\\\\n            (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                return True\\n        self.dic[(s1, s2)] = False\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 3357814,
                "title": "image-explanation-recursion-dp-complexity-analysis-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Scramble String` by `Aryan Mittal`\\n![Google5.png](https://assets.leetcode.com/users/images/686e8c0a-9b17-46c6-bb66-fccb88c23d3b_1680160513.964775.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/722ed5f3-cb83-4348-adad-8d7741606b53_1680150801.3812325.png)\\n![image.png](https://assets.leetcode.com/users/images/47fab9c2-8e24-4528-93fb-776cd024beb6_1680150821.2099686.png)\\n![image.png](https://assets.leetcode.com/users/images/b56f8c7a-211a-47c0-8cda-3e1b1a964a51_1680150836.9387395.png)\\n![image.png](https://assets.leetcode.com/users/images/6936e020-774e-47ea-83e7-ce6d910dcc1f_1680150849.6459093.png)\\n![image.png](https://assets.leetcode.com/users/images/c4b90c3f-ab12-4bf9-8274-078e4d5269da_1680150862.8997695.png)\\n![image.png](https://assets.leetcode.com/users/images/c5ca5695-e8ed-41be-9765-4617b1216217_1680150878.5818756.png)\\n\\n[`Don\\'t fall for this Small Optimization, It is Leetcode\\'s Test Case Bug`] \\n![image.png](https://assets.leetcode.com/users/images/b9c26979-3449-4ec1-8ece-53bc1df27bb1_1680150888.9371839.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        int n = s1.size();\\n        if(s1==s2) return true;   \\n        if(n==1) return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n        if(mp.find(key)!=mp.end()) return mp[key];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            if(isScramble(s1.substr(0,i),s2.substr(0,i)) && \\n                            isScramble(s1.substr(i),s2.substr(i)))\\n                return mp[key] = true;\\n            \\n            if(isScramble(s1.substr(0,i),s2.substr(n-i)) &&\\n                        isScramble(s1.substr(i),s2.substr(0,n-i)))\\n                return mp[key] = true;\\n        }\\n        \\n        return mp[key] = false;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    Map<String, Boolean> mp = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        if (s1.equals(s2)) return true;\\n        if (n == 1) return false;\\n\\n        String key = s1 + \" \" + s2;\\n\\n        if (mp.containsKey(key)) return mp.get(key);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i))){\\n                mp.put(key, true);\\n                return true;\\n            }\\n\\n            if (isScramble(s1.substring(0, i), s2.substring(n - i)) && isScramble(s1.substring(i), s2.substring(0, n - i))){\\n                mp.put(key, true);\\n                return true;\\n            }\\n        }\\n\\n        mp.put(key, false);\\n        return false;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.mp = {}\\n\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        if s1 == s2:\\n            return True\\n        if n == 1:\\n            return False\\n\\n        key = s1 + \" \" + s2\\n\\n        if key in self.mp:\\n            return self.mp[key]\\n\\n        for i in range(1, n):\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                self.mp[key] = True\\n                return True\\n\\n            if self.isScramble(s1[:i], s2[n - i:]) and self.isScramble(s1[i:], s2[:n - i]):\\n                self.mp[key] = True\\n                return True\\n\\n        self.mp[key] = False\\n        return False\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        int n = s1.size();\\n        if(s1==s2) return true;   \\n        if(n==1) return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n        if(mp.find(key)!=mp.end()) return mp[key];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            if(isScramble(s1.substr(0,i),s2.substr(0,i)) && \\n                            isScramble(s1.substr(i),s2.substr(i)))\\n                return mp[key] = true;\\n            \\n            if(isScramble(s1.substr(0,i),s2.substr(n-i)) &&\\n                        isScramble(s1.substr(i),s2.substr(0,n-i)))\\n                return mp[key] = true;\\n        }\\n        \\n        return mp[key] = false;\\n    }\\n};\\n```\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    Map<String, Boolean> mp = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        if (s1.equals(s2)) return true;\\n        if (n == 1) return false;\\n\\n        String key = s1 + \" \" + s2;\\n\\n        if (mp.containsKey(key)) return mp.get(key);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i))){\\n                mp.put(key, true);\\n                return true;\\n            }\\n\\n            if (isScramble(s1.substring(0, i), s2.substring(n - i)) && isScramble(s1.substring(i), s2.substring(0, n - i))){\\n                mp.put(key, true);\\n                return true;\\n            }\\n        }\\n\\n        mp.put(key, false);\\n        return false;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.mp = {}\\n\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        if s1 == s2:\\n            return True\\n        if n == 1:\\n            return False\\n\\n        key = s1 + \" \" + s2\\n\\n        if key in self.mp:\\n            return self.mp[key]\\n\\n        for i in range(1, n):\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                self.mp[key] = True\\n                return True\\n\\n            if self.isScramble(s1[:i], s2[n - i:]) and self.isScramble(s1[i:], s2[:n - i]):\\n                self.mp[key] = True\\n                return True\\n\\n        self.mp[key] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285215,
                "title": "java-2ms-recursive-solution-with-explanation",
                "content": "We can judge whether ```s1``` and ```s2``` can scramble into each other through mathematical induction:\\n* The base case that ```s1``` can scramble into ```s2```  if ```s1```== ```s2```. If the frequencies of each characters appearing in ```s1``` and ```s2``` differ, then ```s1``` can not scramble into ```s2```.\\n* If there exist ```0 <= i <= s1.length()``` where\\n\\t* s1[0,i] can scramble into s2[0,i] and s1[i,length] can scramble into s2[i, length]; or \\n\\t* s1[0,i] can scramble into s2[length - i, length] and s1[i,length] can scramble into s2[0, length - i]\\n\\t\\n\\tthen, s1 can scramble into s2.\\n\\n```\\npublic boolean isScramble(String s1, String s2) {\\n    if( s1.equals(s2) )\\n        return true;\\n    int s1Array[] = new int[26];\\n    int s2Array[] = new int[26];\\n    for(int i = 0; i < s1.length(); i++) {\\n        s1Array[s1.charAt(i) - \\'a\\']++;\\n        s2Array[s2.charAt(i) - \\'a\\']++;\\n    }\\n    for(int i = 0; i < 26; i++)\\n        if( s1Array[i] != s2Array[i] )\\n            return false;\\n    for(int i = 1; i < s1.length(); i++) {\\n        if( isScramble(s1.substring(0, i), s2.substring(0, i))\\n            && isScramble(s1.substring(i), s2.substring(i)) )\\n            return true;\\n        if( isScramble(s1.substring(0, i), s2.substring(s1.length() - i))\\n            && isScramble(s1.substring(i), s2.substring(0, s1.length() - i)))\\n            return true;\\n    }\\n    return false;\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```s1```\n```s2```\n```s1```\n```s2```\n```s1```\n```s2```\n```s1```\n```s2```\n```s1```\n```s2```\n```0 <= i <= s1.length()```\n```\\npublic boolean isScramble(String s1, String s2) {\\n    if( s1.equals(s2) )\\n        return true;\\n    int s1Array[] = new int[26];\\n    int s2Array[] = new int[26];\\n    for(int i = 0; i < s1.length(); i++) {\\n        s1Array[s1.charAt(i) - \\'a\\']++;\\n        s2Array[s2.charAt(i) - \\'a\\']++;\\n    }\\n    for(int i = 0; i < 26; i++)\\n        if( s1Array[i] != s2Array[i] )\\n            return false;\\n    for(int i = 1; i < s1.length(); i++) {\\n        if( isScramble(s1.substring(0, i), s2.substring(0, i))\\n            && isScramble(s1.substring(i), s2.substring(i)) )\\n            return true;\\n        if( isScramble(s1.substring(0, i), s2.substring(s1.length() - i))\\n            && isScramble(s1.substring(i), s2.substring(0, s1.length() - i)))\\n            return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29469,
                "title": "c-solutions-w-explanation-both-recursive-and-top-down-dynamic-programming",
                "content": "    // This was a very interesting problem! Here is my solution, using top down dynamic programming. \\n    //\\n    // Lets discuss the recurrence. The question posed is, when is string s1 considered to be a scrambling of string s2? \\n    // Let us pose this as a modified question in the form of the following boolean function:\\n    // bool isScrambling(int s1s, int s1e, int s2s, int s2e);\\n    // i.e., given two strings s1 and s2, are their SUBSTRINGS s1[s1s, s1e] and s2[s2s, s2e] scramblings of each other?\\n    // The original question can be answered by isScrambling(0, s1.length()-1, 0, s2.length() -1);\\n    //\\n    //    First the trivial cases which result in false result:\\n    //     1. The two strings are not of same length, then it cannot be a scrambling.\\n    //     2. if s1e < s1s, or s2e < s2s, then they are not scramblings of each other.\\n    //\\n    //    Now the case for identity scrambling (i.e. no scrambling at all)\\n    //    If s1[s1s, s1e] == s2[s2s, s2e] then they are trivial scramblings of each other\\n    //\\n    //    Another trivial case, if the two strings are of length 1, just check that character\\n    //    \\n    //    Now we come to the meat of the problem. Consider all breaks of the string s1:\\n    //    s1[s1s, s1s+k] and s1[s1s+k+1, s1e] for all k <-[0..(s1e-s1s)]\\n    //       for each of these substrings, the original strings are scramblings if\\n    //       1. Either isScrambling(s1s, s1s+k, s2s, s2s+k)   && isScrambling(s1s+k+1, s1e, s2s+k+1, s2e)\\n    //       2. Or isScrambling(s1s, s1s+k, (s2e-k), s2e)     && isScrambling(s1s+k+1, s1e, s2s, s2e-k-1)\\n    //     The first case is one where we do NOT flip the current node in the tree.\\n    //     The second case is one where we flip the current node in the tree.\\n    //\\n    //    If none of the above cases return true, then the strings are NOT scramblings of each other.\\n    //\\n    // Here is a non-memoized (hence non-DP) recursive version:\\n    class Solution {\\n        string s1;\\n        string s2;\\n    public:\\n        // is s1[s1s, s1e] a scrambling of s2[s2s, s2e]?\\n        bool isScrambling (int s1s, int s1e, int s2s, int s2e) {\\n            if ((s1e-s1s) != (s2e-s2s)) return false;\\n            if (s1e < s1s || s2e < s2s) return false;\\n            if (s1.substr(s1s, (s1e - s1s + 1)) == s2.substr(s2s, (s2e - s2s + 1))) return true; //identity scrambling\\n            if (s1e == s1s) return s1[s1s] == s2[s2s];     \\n            for (int k=0; k<(s1e-s1s); k++) { \\n                if (isScrambling(s1s, s1s+k, s2s, s2s+k)   && isScrambling(s1s+k+1, s1e, s2s+k+1, s2e)) return true;\\n                if (isScrambling(s1s, s1s+k, (s2e-k), s2e) && isScrambling(s1s+k+1, s1e, s2s, s2e-k-1)) return true;\\n            }\\n            return false;\\n        }\\n        bool isScramble(string is1, string is2) {\\n            if (is1.length() == 0 || is2.length() == 0) return false;\\n            s1 = is1;\\n            s2 = is2;\\n            return isScrambling(0, s1.length()-1, 0, s2.length()-1);\\n        }\\n    };\\n    // The above solution is functionally correct, but will result in Time-Limit-Exceeded, \\n    // because we are solving the same sub-problems again and again and again\\n    //\\n    // To make this dynamic programming, we just have to memoize the results. \\n    // i.e. first check if results are in the cache, if so return them\\n    // else compute the results, store in cache, and return the result.\\n    // Here is a Top-Down dynamic programming version, which now passes in the online judge:\\n    //\\n    class Solution {\\n        string s1;\\n        string s2;\\n        std::hash<std::string> str_hash;\\n        unordered_map<size_t, bool> cache;\\n        \\n        // is s1[s1s, s1e] a scrambling of s2[s2s, s2e]?\\n        bool isScrambling (int s1s, int s1e, int s2s, int s2e) {\\n            string hashStr = s1.substr(s1s, s1e-s1s+1) + \"#\" + s2.substr(s2s, s2e-s2s+1);\\n            auto it = cache.find(str_hash(hashStr));\\n            if (it != cache.end()) { \\n                return it->second;\\n            }\\n            bool ret = false;\\n            if ((s1e-s1s) != (s2e-s2s)) {ret = false;}\\n            else if (s1e < s1s || s2e < s2s) {ret = false;}\\n            else if (s1.substr(s1s, (s1e - s1s + 1)) == s2.substr(s2s, (s2e - s2s + 1)))  { ret = true;} //identity scrambling\\n            else if (s1e == s1s) {ret = s1[s1s] == s2[s2s];}      \\n            else {\\n                for (int k=0; k<(s1e-s1s); k++) { \\n                    if (isScrambling(s1s, s1s+k, s2s, s2s+k)   && isScrambling(s1s+k+1, s1e, s2s+k+1, s2e)) {ret = true; break;}\\n                    if (isScrambling(s1s, s1s+k, (s2e-k), s2e) && isScrambling(s1s+k+1, s1e, s2s, s2e-k-1)) {ret = true; break;}\\n                }\\n            }\\n            cache[str_hash(hashStr)] = ret;\\n            return ret;\\n        }\\n    public:\\n        bool isScramble(string is1, string is2) {\\n            if (is1.length() == 0 || is2.length() == 0) return false;\\n            s1 = is1;\\n            s2 = is2;\\n            return isScrambling(0, s1.length()-1, 0, s2.length()-1);\\n        }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n        string s1;\\n        string s2;\\n    public:\\n        // is s1[s1s, s1e] a scrambling of s2[s2s, s2e]?\\n        bool isScrambling (int s1s, int s1e, int s2s, int s2e) {\\n            if ((s1e-s1s) != (s2e-s2s)) return false;\\n            if (s1e < s1s || s2e < s2s) return false;\\n            if (s1.substr(s1s, (s1e - s1s + 1)) == s2.substr(s2s, (s2e - s2s + 1))) return true; //identity scrambling\\n            if (s1e == s1s) return s1[s1s] == s2[s2s];     \\n            for (int k=0; k<(s1e-s1s); k++) { \\n                if (isScrambling(s1s, s1s+k, s2s, s2s+k)   && isScrambling(s1s+k+1, s1e, s2s+k+1, s2e)) return true;\\n                if (isScrambling(s1s, s1s+k, (s2e-k), s2e) && isScrambling(s1s+k+1, s1e, s2s, s2e-k-1)) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3357490,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. I planned to give for next 10,000 Subscribers as well. So **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n# OR \\n**Click the Link in my Leetcode Profile to Subscribe**\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\nWe can use dynamic programming to solve this problem. We can define a 3D boolean array dp[i][j][length] to represent whether s1[i:i+length] and s2[j:j+length] are scrambled versions of each other. The array dp will have dimensions n x n x (n+1), where n is the length of the strings. The base case is when length=1, and in this case, dp[i][j][1] is true if and only if s1[i] is equal to s2[j]. For each value of length, we can iterate through all possible starting indices i and j, and all possible split points k such that 1 <= k < length. We can then check if the substrings of s1 and s2 starting at indices i and j, respectively, and both of length k, are scrambled versions of each other, and if the substrings of s1 and s2 starting at indices i+k and j+k, respectively, and both of length length-k, are scrambled versions of each other. If either of these conditions are met, then dp[i][j][length] is true.\\n\\n# Intuition:\\n\\n- The intuition behind this approach is that if two strings s1 and s2 are scrambled versions of each other, then there must exist a split point k such that either the substrings of s1 and s2 starting at indices 0 and 0, respectively, and both of length k, are scrambled versions of each other, and the substrings of s1 and s2 starting at indices k and k, respectively, and both of length length-k, are scrambled versions of each other, or the substrings of s1 and s2 starting at indices 0 and length-k, respectively, and both of length k, are scrambled versions of each other, and the substrings of s1 and s2 starting at indices k and 0, respectively, and both of length length-k, are scrambled versions of each other. This is because a scrambled version of a string can be obtained by swapping any two non-adjacent substrings of the string.\\n\\n- By using dynamic programming to store the results of the subproblems, we can avoid recomputing the same subproblems multiple times, leading to a more efficient solution. The time complexity of this approach is O(n^4), and the space complexity is O(n^3)\\n\\n\\n```Python []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2):\\n            return False\\n        \\n        n = len(s1)\\n        dp = [[[False] * (n+1) for _ in range(n)] for _ in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                dp[i][j][1] = (s1[i] == s2[j])\\n        \\n        for length in range(2, n+1):\\n            for i in range(n-length+1):\\n                for j in range(n-length+1):\\n                    for k in range(1, length):\\n                        if (dp[i][j][k] and dp[i+k][j+k][length-k]) or (dp[i][j+length-k][k] and dp[i+k][j][length-k]):\\n                            dp[i][j][length] = True\\n                            break\\n        \\n        return dp[0][0][n]\\n\\n    \\n        # An Upvote will be encouraging\\n\\n```\\n```Java []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (!Arrays.equals(s1.chars().sorted().toArray(), s2.chars().sorted().toArray())) {\\n            return false;\\n        }\\n        \\n        int n = s1.length();\\n        boolean[][][] dp = new boolean[n][n][n+1];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j][1] = (s1.charAt(i) == s2.charAt(j));\\n            }\\n        }\\n        \\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    for (int k = 1; k < length; k++) {\\n                        if ((dp[i][j][k] && dp[i+k][j+k][length-k]) || (dp[i][j+length-k][k] && dp[i+k][j][length-k])) {\\n                            dp[i][j][length] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][n];\\n    }\\n}\\n\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if (s1 == s2) {\\n            return true;\\n        }\\n        if (!is_permutation(s1.begin(), s1.end(), s2.begin())) {\\n            return false;\\n        }\\n        \\n        int n = s1.length();\\n        vector<vector<vector<bool>>> dp(n, vector<vector<bool>>(n, vector<bool>(n+1, false)));\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j][1] = (s1[i] == s2[j]);\\n            }\\n        }\\n        \\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    for (int k = 1; k < length; k++) {\\n                        if ((dp[i][j][k] && dp[i+k][j+k][length-k]) || (dp[i][j+length-k][k] && dp[i+k][j][length-k])) {\\n                            dp[i][j][length] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][n];\\n    }\\n};\\n\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```Python []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2):\\n            return False\\n        \\n        n = len(s1)\\n        dp = [[[False] * (n+1) for _ in range(n)] for _ in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                dp[i][j][1] = (s1[i] == s2[j])\\n        \\n        for length in range(2, n+1):\\n            for i in range(n-length+1):\\n                for j in range(n-length+1):\\n                    for k in range(1, length):\\n                        if (dp[i][j][k] and dp[i+k][j+k][length-k]) or (dp[i][j+length-k][k] and dp[i+k][j][length-k]):\\n                            dp[i][j][length] = True\\n                            break\\n        \\n        return dp[0][0][n]\\n\\n    \\n        # An Upvote will be encouraging\\n\\n```\n```Java []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (!Arrays.equals(s1.chars().sorted().toArray(), s2.chars().sorted().toArray())) {\\n            return false;\\n        }\\n        \\n        int n = s1.length();\\n        boolean[][][] dp = new boolean[n][n][n+1];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j][1] = (s1.charAt(i) == s2.charAt(j));\\n            }\\n        }\\n        \\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    for (int k = 1; k < length; k++) {\\n                        if ((dp[i][j][k] && dp[i+k][j+k][length-k]) || (dp[i][j+length-k][k] && dp[i+k][j][length-k])) {\\n                            dp[i][j][length] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][n];\\n    }\\n}\\n\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if (s1 == s2) {\\n            return true;\\n        }\\n        if (!is_permutation(s1.begin(), s1.end(), s2.begin())) {\\n            return false;\\n        }\\n        \\n        int n = s1.length();\\n        vector<vector<vector<bool>>> dp(n, vector<vector<bool>>(n, vector<bool>(n+1, false)));\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j][1] = (s1[i] == s2[j]);\\n            }\\n        }\\n        \\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    for (int k = 1; k < length; k++) {\\n                        if ((dp[i][j][k] && dp[i+k][j+k][length-k]) || (dp[i][j+length-k][k] && dp[i+k][j][length-k])) {\\n                            dp[i][j][length] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][n];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517108,
                "title": "cpp-and-java-concise-recursive-memoized-sol-n-with-explanation",
                "content": "Given two strings, we need to determine whether the strings are scrambled or not. The condition for being scrambled is to make a complete binary tree and swap their non-leaf nodes. For example, after swapping, the string becomes rgeat.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/46f5dba3-193b-468d-9bd0-5f14fcc19730_1634010235.2960505.png\" width=400>\\n</p>\\n\\n- The red ones are leaf nodes, and the blue ones are non-leaf nodes. It depends on which non-leaf nodes we want to swap, and no of swaps can be equal to or greater than zero.\\n- What happens when both strings are the same, then also both strings are scrambled.\\n- We can break it at any kth position, but the tree should be complete i.e. no empty nodes.\\n\\n- *This is MCM type question, as we need to check for every kth position.*\\n\\n#####  *Approach*\\n\\n- We will break the strings into two parts i.e from (0, ith) to (ith, n - ith) and check whether they are equal or not\\n- This arise two cases, whether the substring is swapped or not. So we have to check \\n ```\\n           left part of string1 == left part of string2 along with right part of string1 == right part of string2\\n                                                              or\\n\\t\\t      left part of string1 == right part of string2 along with right part of string1 == left part of string2\\n```\\n\\n- If any one condition becomes true then the string are scrambled. Checking it recursively as child can also be swapped. Take third example in image below for reference.\\n- If length of two strings are not equal then they are not scrambled. \\n\\n<p align=\"center\">\\n   <img src=\"https://assets.leetcode.com/users/images/1c67fd8a-2afc-456b-90e2-7192d305771c_1634008449.219847.png\" width=300>\\n  </p>\\n\\n#### *Recursive Cpp* (TLE)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool helper(string a, string b)\\n    {\\n        if(a.compare(b) == 0) return true;\\n        \\n        if(a.length() <= 1) return false;  //1character can\\'t be compared\\n        \\n        int n = a.length();\\n        bool check = false;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n           bool swap = helper(a.substr(0,i), b.substr(n - i,i)) and helper(a.substr(i), b.substr(0, n - i));\\n           bool unswap = helper(a.substr(0,i), b.substr(0,i)) and helper(a.substr(i,n - i), b.substr(i,n - i));\\n            \\n           if(swap || unswap){\\n               check = true;\\n               break;\\n           }\\n        }\\n        \\n        return check;\\n    }\\n    \\n    bool isScramble(string a, string b) \\n    {\\n        if(a == b) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.empty() and b.empty()) return true;\\n        \\n        return helper(a, b);\\n    }\\n};\\n```\\n\\n*The same Java version.*\\n\\n```\\nclass Solution {\\n    public boolean helper(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;  \\n        \\n        if(a.length() <= 1) return false;   // as we can\\'t compare 1 character\\n        \\n        int n = a.length();\\n        boolean check = false;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\\n            \\n            if(swap || unswap){\\n                check = true;\\n                break;\\n            }\\n        }\\n        \\n        return check;\\n    }\\n    \\n    public boolean isScramble(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() != b.length()) return false;   \\n        \\n        if(a.isEmpty() == true) return true;\\n        \\n        return helper(a, b);\\n    }\\n}\\n```\\n\\n#### *Memoized version*\\n\\nStoring the values in a map where the key is string a + \\' \\' + string b.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> mp;\\n    \\n    bool helper(string a, string b)\\n    {\\n        if(a.compare(b) == 0) return true;\\n        \\n        if(a.length() <= 1) return false;  //1character can\\'t be compared\\n        \\n        int n = a.length();\\n        bool check = false;\\n        \\n        string key = a;\\n        \\n        key += \\' \\' + b;\\n        \\n        if(mp.find(key) != mp.end()) \\n            return mp[key];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n           bool swap = helper(a.substr(0,i), b.substr(n - i,i)) and helper(a.substr(i), b.substr(0, n - i));\\n           bool unswap = helper(a.substr(0,i), b.substr(0,i)) and helper(a.substr(i,n - i), b.substr(i,n - i));\\n            \\n           if(swap || unswap){\\n               check = true;\\n               break;\\n           }\\n        }\\n        \\n        return mp[key] =  check;\\n    }\\n    \\n    bool isScramble(string a, string b) \\n    {\\n        if(a == b) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.empty() and b.empty()) return true;\\n        \\n        return helper(a, b);\\n    }\\n};\\n```\\n\\n*The same Java version.*\\n\\n```\\nclass Solution {\\n    Map<String, Boolean> mp = new HashMap<>();\\n    \\n    public boolean helper(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() <= 1) return false;\\n        \\n        int n = a.length();\\n        boolean check = false;\\n        \\n        String key = a;\\n        \\n        key += \\' \\' + b;\\n        \\n        if(mp.containsKey(key))\\n             return mp.get(key);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\\n            \\n            if(swap || unswap){\\n                check = true;\\n                break;\\n            }\\n        }\\n        \\n        mp.put(key, check);\\n        \\n        return check;\\n    }\\n    \\n    public boolean isScramble(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.isEmpty() == true) return true;\\n        \\n        return helper(a, b);\\n    }\\n}\\n```\\n\\nFeel free to ask your queries.\\uD83D\\uDE42\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n           left part of string1 == left part of string2 along with right part of string1 == right part of string2\\n                                                              or\\n\\t\\t      left part of string1 == right part of string2 along with right part of string1 == left part of string2\\n```\n```\\nclass Solution {\\npublic:\\n    bool helper(string a, string b)\\n    {\\n        if(a.compare(b) == 0) return true;\\n        \\n        if(a.length() <= 1) return false;  //1character can\\'t be compared\\n        \\n        int n = a.length();\\n        bool check = false;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n           bool swap = helper(a.substr(0,i), b.substr(n - i,i)) and helper(a.substr(i), b.substr(0, n - i));\\n           bool unswap = helper(a.substr(0,i), b.substr(0,i)) and helper(a.substr(i,n - i), b.substr(i,n - i));\\n            \\n           if(swap || unswap){\\n               check = true;\\n               break;\\n           }\\n        }\\n        \\n        return check;\\n    }\\n    \\n    bool isScramble(string a, string b) \\n    {\\n        if(a == b) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.empty() and b.empty()) return true;\\n        \\n        return helper(a, b);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean helper(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;  \\n        \\n        if(a.length() <= 1) return false;   // as we can\\'t compare 1 character\\n        \\n        int n = a.length();\\n        boolean check = false;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\\n            \\n            if(swap || unswap){\\n                check = true;\\n                break;\\n            }\\n        }\\n        \\n        return check;\\n    }\\n    \\n    public boolean isScramble(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() != b.length()) return false;   \\n        \\n        if(a.isEmpty() == true) return true;\\n        \\n        return helper(a, b);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> mp;\\n    \\n    bool helper(string a, string b)\\n    {\\n        if(a.compare(b) == 0) return true;\\n        \\n        if(a.length() <= 1) return false;  //1character can\\'t be compared\\n        \\n        int n = a.length();\\n        bool check = false;\\n        \\n        string key = a;\\n        \\n        key += \\' \\' + b;\\n        \\n        if(mp.find(key) != mp.end()) \\n            return mp[key];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n           bool swap = helper(a.substr(0,i), b.substr(n - i,i)) and helper(a.substr(i), b.substr(0, n - i));\\n           bool unswap = helper(a.substr(0,i), b.substr(0,i)) and helper(a.substr(i,n - i), b.substr(i,n - i));\\n            \\n           if(swap || unswap){\\n               check = true;\\n               break;\\n           }\\n        }\\n        \\n        return mp[key] =  check;\\n    }\\n    \\n    bool isScramble(string a, string b) \\n    {\\n        if(a == b) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.empty() and b.empty()) return true;\\n        \\n        return helper(a, b);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    Map<String, Boolean> mp = new HashMap<>();\\n    \\n    public boolean helper(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() <= 1) return false;\\n        \\n        int n = a.length();\\n        boolean check = false;\\n        \\n        String key = a;\\n        \\n        key += \\' \\' + b;\\n        \\n        if(mp.containsKey(key))\\n             return mp.get(key);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\\n            \\n            if(swap || unswap){\\n                check = true;\\n                break;\\n            }\\n        }\\n        \\n        mp.put(key, check);\\n        \\n        return check;\\n    }\\n    \\n    public boolean isScramble(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.isEmpty() == true) return true;\\n        \\n        return helper(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357954,
                "title": "clean-c-code-with-great-explanation",
                "content": "This is a very interesting problem!\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs soon as I read the problem, I understood that it is a DP problem cause there were overlaping subproblems. So I started thinking about what will be the DP states, what things can we solve recursively, what will be the base case and transistions be like. I have used top-down dynamic programming to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nProblem asks us to find whether string `s1` is scramble of `s2` or not. We can also look this problem as for given two string `s1` and `s2`, and their substrings `s1[l1...r1]` and `s2[l2...r2]` are scrambles of each other or not. So the original question can be answered for the substrings from `0` to `n - 1`.\\n\\nWe have a `helper` function that returns us exactly what we need to find above, and it takes `l1`, `r1`, `l2` and `r2` as parameters.\\nNote: we will always call the `helper` function such that the length of both the substring from `s1` and `s2` are of same size.\\n\\nBase Case: if both the substrings are same, we simply return `true`.\\nNow, if it is not the base case, i.e. the substrings are not same, we need to further divide this substring into two more substrings `x` and `y` (as named in the question). As we can randomly partition the substring, we will have to check for all the partitions. After each partition, we have two options: \\n\\n**Option 1:** DON\\'T FLIP\\nWe keep the current substring of `s1` as it is, i.e. `x + y`. Here we check scrambles of `x` with the prefix of substring of `s2` of the same size as `x`, and check `y` with the remaining suffix of substring of `s2`, which will be also of same size as that of `y`.\\n\\n**Option 2:** FLIP\\nWe swap the `x` and `y` after partition, i.e. `y + x`. Here we check the scrambles of `x` with the suffix of substring of `s2` of the same size as `x`, and check `y` with the remaining prefix of substring of `s2`, which will be also of same size as that of `y`.\\n\\nIf none of the above options return true, we simply return false.\\n\\nIn the code below, I have used boolean arrays to store whether we have visited any state, and its answer. Hence it is a memoized DP. Also I have used the lambda functions just cause I am addicted to it :)\\n\\n<!-- # Complexityd -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n = (int) s1.size();\\n        bool vis[n][n][n][n];\\n        bool dp[n][n][n][n];\\n        memset(vis, false, sizeof(vis));\\n        memset(dp, false, sizeof(dp));\\n\\n        // we are always calling the function such that, the substring we are checking on both the\\n        // substrings are of same length, i.e. (r1 - l1 + 1 == r2 - l2 + 1)\\n\\n        // helper takes in two substrings of both string\\n        // and returns whether they are scamble of each other\\n        function<bool(int, int, int, int)> helper = [&] (int l1, int r1, int l2, int r2) {\\n            if (vis[l1][r1][l2][r2]) return dp[l1][r1][l2][r2];\\n            vis[l1][r1][l2][r2] = true;\\n\\n            bool isSame = true;\\n            for (int i = l1, j = l2; i <= r1 && j <= r2; i++, j++)\\n                if (s1[i] != s2[j]) isSame = false;\\n            \\n            // is already same, simply return true\\n            if (isSame) {\\n                dp[l1][r1][l2][r2] = true;\\n                return true;\\n            }\\n\\n            bool res = false;\\n            for (int i = l1; i < r1; i++) {\\n                // opt1: prefix1 matches to prefix2 and suffix1 matches to suffix2\\n                res |= (helper(l1, i, l2, l2 + (i - l1)) && helper(i + 1, r1, l2 + (i - l1) + 1, r2));\\n\\n                // opt2: prefix1 matches to suffix2 and prefix2 matches to suffix1\\n                res |= (helper(l1, i, r2 - (i - l1), r2) && helper(i + 1, r1, l2, r2 - (i - l1) - 1));\\n            }\\n\\n            dp[l1][r1][l2][r2] = res;\\n            return res;\\n        };\\n\\n        return helper(0, n - 1, 0, n - 1);\\n    }\\n};\\n```\\n\\nFeedbacks are appreciated :)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n = (int) s1.size();\\n        bool vis[n][n][n][n];\\n        bool dp[n][n][n][n];\\n        memset(vis, false, sizeof(vis));\\n        memset(dp, false, sizeof(dp));\\n\\n        // we are always calling the function such that, the substring we are checking on both the\\n        // substrings are of same length, i.e. (r1 - l1 + 1 == r2 - l2 + 1)\\n\\n        // helper takes in two substrings of both string\\n        // and returns whether they are scamble of each other\\n        function<bool(int, int, int, int)> helper = [&] (int l1, int r1, int l2, int r2) {\\n            if (vis[l1][r1][l2][r2]) return dp[l1][r1][l2][r2];\\n            vis[l1][r1][l2][r2] = true;\\n\\n            bool isSame = true;\\n            for (int i = l1, j = l2; i <= r1 && j <= r2; i++, j++)\\n                if (s1[i] != s2[j]) isSame = false;\\n            \\n            // is already same, simply return true\\n            if (isSame) {\\n                dp[l1][r1][l2][r2] = true;\\n                return true;\\n            }\\n\\n            bool res = false;\\n            for (int i = l1; i < r1; i++) {\\n                // opt1: prefix1 matches to prefix2 and suffix1 matches to suffix2\\n                res |= (helper(l1, i, l2, l2 + (i - l1)) && helper(i + 1, r1, l2 + (i - l1) + 1, r2));\\n\\n                // opt2: prefix1 matches to suffix2 and prefix2 matches to suffix1\\n                res |= (helper(l1, i, r2 - (i - l1), r2) && helper(i + 1, r1, l2, r2 - (i - l1) - 1));\\n            }\\n\\n            dp[l1][r1][l2][r2] = res;\\n            return res;\\n        };\\n\\n        return helper(0, n - 1, 0, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29445,
                "title": "any-better-solution",
                "content": "My AC code is as below. I think it's not very efficient. Is there any better solution?\\n\\n    class Solution {\\n    private:\\n    \\tbool anagram(string &s1, string &s2){\\n    \\t\\tif(s1.size() != s2.size()) return false;\\n    \\t\\tunordered_map<char, int> m;\\n    \\t\\tint n = s1.size();\\n    \\t\\tfor(int i = 0; i < n; ++i){\\n    \\t\\t\\tif(m.find(s1[i]) != m.end()){\\n    \\t\\t\\t\\t++m[s1[i]];\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tm[s1[i]] = 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tfor(int i = 0; i < n; ++i){\\n    \\t\\t\\tif(m.find(s2[i]) != m.end()){\\n    \\t\\t\\t\\t--m[s2[i]];\\n    \\t\\t\\t\\tif(m[s2[i]] < 0){\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn true;\\n    \\t}\\n    public:\\n        bool isScramble(string s1, string s2) {\\n        \\tif(s1.size() != s2.size()) return false;\\n        \\tif(s1 == s2) return true;\\n        \\tint n = s1.size();\\n        \\tfor(int i = 1; i < n; ++i){\\n        \\t\\tstring s11 = s1.substr(0, i);\\n        \\t\\tstring s12 = s1.substr(i, n - i);\\n        \\t\\tstring s21 = s2.substr(0, i);\\n        \\t\\tstring s22 = s2.substr(i, n - i);\\n        \\t\\tstring s23 = s2.substr(n - i, i);\\n        \\t\\tstring s24 = s2.substr(0, n - i);\\n        \\t\\tif(anagram(s11, s21) && anagram(s12, s22) &&\\n        \\t\\t\\tisScramble(s11, s21) && isScramble(s12, s22)\\n        \\t\\t\\t||\\n        \\t\\t\\tanagram(s11, s23) && anagram(s12, s24) &&\\n        \\t\\t\\tisScramble(s11, s23) && isScramble(s12, s24)){\\n        \\t\\t\\treturn true;\\n        \\t\\t}\\n        \\t}\\n            return false;\\n        }\\n    };\\n\\nThe main idea is:\\n\\n1. separate `s1` into two parts, namely `--s11--`, `--------s12--------`\\n2. separate `s2` into two parts, namely `--s21--`, `--------s22--------`, and test the corresponding part (`s11` and `s21` && `s12` and `s22`) with `isScramble`.\\n3. separate `s2` into two parts, namely `--------s23--------`, `--s24--`, and test the corresponding part (`s11` and `s24` && `s12` and `s23`) with `isScramble`.\\n4. Note that before testing each sub-part with `isScramble`, `anagram` is used first to test if the corresponding parts are anagrams. If not, skip directly.",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n    \\tbool anagram(string &s1, string &s2){\\n    \\t\\tif(s1.size() != s2.size()) return false;\\n    \\t\\tunordered_map<char, int> m;\\n    \\t\\tint n = s1.size();\\n    \\t\\tfor(int i = 0; i < n; ++i){\\n    \\t\\t\\tif(m.find(s1[i]) != m.end()){\\n    \\t\\t\\t\\t++m[s1[i]];\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2395245,
                "title": "clean-python3-recursion-memoization-faster-than-98",
                "content": "Please upvote if it helps! :)\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.scrambles = {}\\n        \\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if (s1, s2) in self.scrambles:\\n            return self.scrambles[(s1, s2)]\\n        if s1 == s2:\\n            self.scrambles[(s1, s2)] = True\\n            return True\\n        ls = len(s1)\\n        if ls == 1 or sorted(s1) != sorted(s2):\\n            self.scrambles[(s1, s2)] = False\\n            return False\\n\\n        for i in range(1, ls):\\n            \\n            s1_left, s1_right = s1[:i], s1[i:]\\n            s2_left, s2_right = s2[:i], s2[i:]\\n            match1 = self.isScramble(s1_left, s2_left) and self.isScramble(s1_right, s2_right)\\n            \\n            s2_left2, s2_right2 = s2[:ls - i], s2[ls - i:]\\n            match2 = self.isScramble(s1_left, s2_right2) and self.isScramble(s1_right, s2_left2)\\n            \\n            if match1 or match2:\\n                self.scrambles[(s1, s2)] = True\\n                return True\\n            \\n        self.scrambles[(s1, s2)] = False\\n        return False",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def __init__(self):\\n        self.scrambles = {}",
                "codeTag": "Java"
            },
            {
                "id": 1025628,
                "title": "python-top-down-dp-solution",
                "content": "```\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        def recur(s1, s2):\\n            if s1 == s2:\\n                return True\\n            if Counter(s1) != Counter(s2):\\n                return False\\n            if (s1, s2) in dp:\\n                return dp[(s1, s2)]\\n            dp[(s1, s2)] = False\\n            for i in range(1, len(s1)):\\n                if recur(s1[:i], s2[:i]) and recur(s1[i:], s2[i:]):\\n                    dp[(s1, s2)] = True\\n                    return True\\n                if recur(s1[:i], s2[-i:]) and recur(s1[i:], s2[:-i]):\\n                    dp[(s1, s2)] = True\\n                    return True\\n            return dp[(s1, s2)]\\n        \\n        dp = dict()\\n        return recur(s1, s2)\\n```",
                "solutionTags": [],
                "code": "```\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        def recur(s1, s2):\\n            if s1 == s2:\\n                return True\\n            if Counter(s1) != Counter(s2):\\n                return False\\n            if (s1, s2) in dp:\\n                return dp[(s1, s2)]\\n            dp[(s1, s2)] = False\\n            for i in range(1, len(s1)):\\n                if recur(s1[:i], s2[:i]) and recur(s1[i:], s2[i:]):\\n                    dp[(s1, s2)] = True\\n                    return True\\n                if recur(s1[:i], s2[-i:]) and recur(s1[i:], s2[:-i]):\\n                    dp[(s1, s2)] = True\\n                    return True\\n            return dp[(s1, s2)]\\n        \\n        dp = dict()\\n        return recur(s1, s2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 29411,
                "title": "optimized-recursive-0ms-and-dp-20ms-solution-c-beating-100-submissions",
                "content": "Simply we can just use recursive method to traverse every possible situations but as we can expect that we will run into TLE. \\n\\nThere are other factors we should make full use of to reduce the traversing range \\n- the limited characters \\n- the scrambled string is containing just exactly the same set of characters as the original string \\n\\nwhich can be used to `prune` almost all invalid traversing branches and result in the best time cost.  \\n\\n    #define SIZE 256\\n    bool isnScramble(char* s1, char* s2, int len) \\n    {\\n        \\n        if(!strncmp(s1, s2, len)) return true;\\n        int count[SIZE] = {0};\\n        for(int i = 0; i < len; i++)\\n            count[s1[i]-'a']++, count[s2[i]-'a']--;\\n        for(int i = 0; i < SIZE; i++)\\n            if(count[i]) return false;\\n        for(int i=1; i < len; i++)\\n            if(isnScramble(s1, s2, i) && isnScramble(s1+i, s2+i, len-i) ||\\n                    isnScramble(s1, s2+len-i, i) && isnScramble(s1+i, s2, len-i)) return true;\\n        return false;\\n    }\\n    \\n    //AC - 0ms - beats 100% submissions;\\n    bool isScramble(char* s1, char* s2)\\n    {\\n        int len = strlen(s1);\\n        return isnScramble(s1, s2, len);\\n    }\\n\\nA DP solution is also provided here with 20ms time cost, which is inspired by the above recursive method using three-dimension array to store the state \\n\\n> match[size][index1][index2]\\n\\nthe size is the comparing size of the two strings, index1 is the start index of string 1 and index2 is that of string 2.\\n\\n    //AC - 20ms - beats 100% submissions - DP solution;\\n    bool isScramble(char* s1, char* s2)\\n    {\\n        int len = strlen(s1);\\n        if(!len) return true;\\n        if(len==1) return *s1==*s2;\\n        bool*** match = (bool***)malloc(sizeof(bool**)*(len+1));\\n        for(int i = 0; i <= len; i++)\\n        {\\n            match[i] = (bool**)malloc(sizeof(bool*)*len);\\n            for(int j = 0; j < len; j++)\\n            {\\n                match[i][j] = (bool*)malloc(sizeof(bool)*len);\\n                memset(match[i][j], 0, sizeof(bool)*len);\\n            }\\n        }\\n        for(int i = 0; i < len; i++)\\n            for(int j = 0; j < len; j++)\\n                match[1][i][j] = (s1[i] == s2[j]);\\n        for(int size = 2; size <= len; size++)\\n            for(int i = 0; i <= len-size; i++)\\n                for(int j = 0; j <= len-size; j++)\\n                    for(int k = 1; k<size && !match[size][i][j]; k++)\\n                        match[size][i][j] = (match[k][i][j] && match[size-k][i+k][j+k]) || (match[k][i+size-k][j] && match[size-k][i][j+k]);\\n        return match[len][0][0];\\n    }\\n\\nThere are still lots of redundant search in the above methods; can someone further improve it? Thanks in advance!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Simply we can just use recursive method to traverse every possible situations but as we can expect that we will run into TLE. \\n\\nThere are other factors we should make full use of to reduce the traversing range \\n- the limited characters \\n- the scrambled string is containing just exactly the same set of characters as the original string \\n\\nwhich can be used to `prune` almost all invalid traversing branches and result in the best time cost.  \\n\\n    #define SIZE 256\\n    bool isnScramble(char* s1, char* s2, int len) \\n    {\\n        \\n        if(!strncmp(s1, s2, len)) return true;\\n        int count[SIZE] = {0};\\n        for(int i = 0; i < len; i++)\\n            count[s1[i]-'a']++, count[s2[i]-'a']--;\\n        for(int i = 0; i < SIZE; i++)\\n            if(count[i]) return false;\\n        for(int i=1; i < len; i++)\\n            if(isnScramble(s1, s2, i) && isnScramble(s1+i, s2+i, len-i) ||\\n                    isnScramble(s1, s2+len-i, i) && isnScramble(s1+i, s2, len-i)) return true;\\n        return false;\\n    }\\n    \\n    //AC - 0ms - beats 100% submissions;\\n    bool isScramble(char* s1, char* s2)\\n    {\\n        int len = strlen(s1);\\n        return isnScramble(s1, s2, len);\\n    }\\n\\nA DP solution is also provided here with 20ms time cost, which is inspired by the above recursive method using three-dimension array to store the state \\n\\n> match[size][index1][index2]\\n\\nthe size is the comparing size of the two strings, index1 is the start index of string 1 and index2 is that of string 2.\\n\\n    //AC - 20ms - beats 100% submissions - DP solution;\\n    bool isScramble(char* s1, char* s2)\\n    {\\n        int len = strlen(s1);\\n        if(!len) return true;\\n        if(len==1) return *s1==*s2;\\n        bool*** match = (bool***)malloc(sizeof(bool**)*(len+1));\\n        for(int i = 0; i <= len; i++)\\n        {\\n            match[i] = (bool**)malloc(sizeof(bool*)*len);\\n            for(int j = 0; j < len; j++)\\n            {\\n                match[i][j] = (bool*)malloc(sizeof(bool)*len);\\n                memset(match[i][j], 0, sizeof(bool)*len);\\n            }\\n        }\\n        for(int i = 0; i < len; i++)\\n            for(int j = 0; j < len; j++)\\n                match[1][i][j] = (s1[i] == s2[j]);\\n        for(int size = 2; size <= len; size++)\\n            for(int i = 0; i <= len-size; i++)\\n                for(int j = 0; j <= len-size; j++)\\n                    for(int k = 1; k<size && !match[size][i][j]; k++)\\n                        match[size][i][j] = (match[k][i][j] && match[size-k][i+k][j+k]) || (match[k][i+size-k][j] && match[size-k][i][j+k]);\\n        return match[len][0][0];\\n    }\\n\\nThere are still lots of redundant search in the above methods; can someone further improve it? Thanks in advance!",
                "codeTag": "Unknown"
            },
            {
                "id": 29458,
                "title": "a-simple-solution-without-dp-in-c",
                "content": "    class Solution {\\n    public:\\n        bool isScramble(string s1, string s2) {\\n            int n = s1.length();\\n            return judge(s1.c_str(), s2.c_str(), 0, n-1, 0, n-1);\\n        }\\n        \\n        bool judge(const char* s1, const char* s2,int a,int b,int u, int v){\\n            if(b-a!=v-u) return false;\\n            if(b-a==0 && s1[a]==s2[u]) return true;\\n            \\n            int cnt[256]={0};\\n            for(int i=a;i<=b;++i){\\n                cnt[s1[i]]++;\\n            }\\n            for(int i=u;i<=v;++i){\\n                cnt[s2[i]]--;\\n            }\\n            for(int i=0;i<256;++i){\\n                if(cnt[i]!=0) return false;\\n            }\\n            \\n            for(int i=a;i<b;++i){\\n                if(judge(s1,s2,a,i,u,u+i-a) && judge(s1,s2,i+1,b,v-(b-i-1),v)){                    \\n                    return true;\\n                }\\n                if(judge(s1,s2,a,i,v-(i-a),v) && judge(s1,s2,i+1,b,u,u+b-(i+1))){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    };\\n\\nSurprisingly, it runs very fast even without dynamic programming.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isScramble(string s1, string s2) {\\n            int n = s1.length();\\n            return judge(s1.c_str(), s2.c_str(), 0, n-1, 0, n-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 29471,
                "title": "66-ms-python-solution-with-dict",
                "content": "    def is_scramble(s1, s2):\\n        m = {}\\n        return f(s1, s2, m)\\n\\n\\n    def f(s1, s2, m):\\n        if (s1, s2) in m:\\n            return m[(s1, s2)]\\n    \\n        if len(s1) == 1:\\n            return s1 == s2\\n        elif not sorted(s1) == sorted(s2):\\n            return False\\n    \\n        for i in range(1, len(s1)):\\n            if f(s1[:i], s2[-i:], m) and f(s1[i:], s2[:-i], m) or \\\\\\n               f(s1[:i], s2[:i], m) and f(s1[i:], s2[i:], m):\\n                m[(s1, s2)] = True\\n                return True\\n        m[(s1, s2)] = False\\n        return False",
                "solutionTags": [],
                "code": "    def is_scramble(s1, s2):\\n        m = {}\\n        return f(s1, s2, m)\\n\\n\\n    def f(s1, s2, m):\\n        if (s1, s2) in m:\\n            return m[(s1, s2)]\\n    \\n        if len(s1) == 1:\\n            return s1 == s2\\n        elif not sorted(s1) == sorted(s2):\\n            return False\\n    \\n        for i in range(1, len(s1)):\\n            if f(s1[:i], s2[-i:], m) and f(s1[i:], s2[:-i], m) or \\\\\\n               f(s1[:i], s2[:i], m) and f(s1[i:], s2[i:], m):\\n                m[(s1, s2)] = True\\n                return True\\n        m[(s1, s2)] = False\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 3358542,
                "title": "python-elegant-short-top-down-dp-memoization",
                "content": "# Complexity\\n- Time complexity: $$O(n^{2})$$\\n- Space complexity: $$O(n^{2})$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isScramble(self, first: str, second: str) -> bool:\\n        @cache\\n        def dp(a: str, b: str) -> bool:\\n            if a == b:\\n                return True\\n\\n            if Counter(a) != Counter(b):\\n                return False\\n\\n            return any(\\n                dp(a[:i], b[:i]) and dp(a[i:], b[i:]) or \\\\\\n                dp(a[:i], b[-i:]) and dp(a[i:], b[:-i])\\n                for i in range(1, len(a))\\n            )\\n\\n        return dp(first, second)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self, first: str, second: str) -> bool:\\n        @cache\\n        def dp(a: str, b: str) -> bool:\\n            if a == b:\\n                return True\\n\\n            if Counter(a) != Counter(b):\\n                return False\\n\\n            return any(\\n                dp(a[:i], b[:i]) and dp(a[i:], b[i:]) or \\\\\\n                dp(a[:i], b[-i:]) and dp(a[i:], b[:-i])\\n                for i in range(1, len(a))\\n            )\\n\\n        return dp(first, second)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921919,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func isScramble(_ s1: String, _ s2: String) -> Bool {\\n        var dp: [String: Bool] = [:]\\n        \\n\\n        func _isScramble(_ chs1: [Character], _ chs2: [Character]) -> Bool {\\n            let key = String(chs1) + \"-\" +  String(chs2)\\n            if let v = dp[key] { return v }            \\n            if chs1.count == 1 { return chs1[0] == chs2[0] }\\n            var val = false\\n\\n            for i in 1..<chs1.count {\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[0..<i])) \\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[i..<chs2.count])))\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[chs2.count - i..<chs2.count]))\\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[0..<chs2.count-i]))) \\n            }\\n            \\n            dp[key] = val\\n            return val\\n        }\\n        \\n        if s1.count != s2.count {\\n            return false\\n        } else {\\n            return _isScramble(Array(s1), Array(s2))\\n        }\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isScramble(_ s1: String, _ s2: String) -> Bool {\\n        var dp: [String: Bool] = [:]\\n        \\n\\n        func _isScramble(_ chs1: [Character], _ chs2: [Character]) -> Bool {\\n            let key = String(chs1) + \"-\" +  String(chs2)\\n            if let v = dp[key] { return v }            \\n            if chs1.count == 1 { return chs1[0] == chs2[0] }\\n            var val = false\\n\\n            for i in 1..<chs1.count {\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[0..<i])) \\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[i..<chs2.count])))\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[chs2.count - i..<chs2.count]))\\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[0..<chs2.count-i]))) \\n            }\\n            \\n            dp[key] = val\\n            return val\\n        }\\n        \\n        if s1.count != s2.count {\\n            return false\\n        } else {\\n            return _isScramble(Array(s1), Array(s2))\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136817,
                "title": "c-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> ump;\\n    bool isScrambled(string s1, string s2){\\n        if(s1.size() != s2.size()) return false;\\n        int n = s1.size();\\n        if(s1==s2 or n==0) return true;\\n        \\n        string key = s1+\" \"+s2;\\n        if(ump.find(key) != ump.end()) return ump[key];\\n        \\n        \\n        bool flag = false;\\n        for(int i=1;i<n;i++){\\n            //for swaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(n-i,i)) and isScrambled(s1.substr(i,n-i),s2.substr(0,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n\\n            //for unswaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(0,i)) and isScrambled(s1.substr(i,n-i),s2.substr(i,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n        }\\n        ump[key]=flag;\\n        return flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size()) return false;\\n        return isScrambled(s1,s2);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> ump;\\n    bool isScrambled(string s1, string s2){\\n        if(s1.size() != s2.size()) return false;\\n        int n = s1.size();\\n        if(s1==s2 or n==0) return true;\\n        \\n        string key = s1+\" \"+s2;\\n        if(ump.find(key) != ump.end()) return ump[key];\\n        \\n        \\n        bool flag = false;\\n        for(int i=1;i<n;i++){\\n            //for swaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(n-i,i)) and isScrambled(s1.substr(i,n-i),s2.substr(0,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n\\n            //for unswaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(0,i)) and isScrambled(s1.substr(i,n-i),s2.substr(i,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n        }\\n        ump[key]=flag;\\n        return flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size()) return false;\\n        return isScrambled(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357479,
                "title": "java-easy-solution-using-hashmap-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    Map<String, Boolean> mp = new HashMap<>();\\n    \\n    public boolean helper(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() <= 1) return false;\\n        \\n        int n = a.length();\\n        boolean check = false;\\n        \\n        String key = a;\\n        \\n        key += \\' \\' + b;\\n        \\n        if(mp.containsKey(key))\\n             return mp.get(key);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\\n            \\n            if(swap || unswap){\\n                check = true;\\n                break;\\n            }\\n        }\\n        \\n        mp.put(key, check);\\n        \\n        return check;\\n    }\\n    \\n    public boolean isScramble(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.isEmpty() == true) return true;\\n        \\n        return helper(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Boolean> mp = new HashMap<>();\\n    \\n    public boolean helper(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() <= 1) return false;\\n        \\n        int n = a.length();\\n        boolean check = false;\\n        \\n        String key = a;\\n        \\n        key += \\' \\' + b;\\n        \\n        if(mp.containsKey(key))\\n             return mp.get(key);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\\n            \\n            if(swap || unswap){\\n                check = true;\\n                break;\\n            }\\n        }\\n        \\n        mp.put(key, check);\\n        \\n        return check;\\n    }\\n    \\n    public boolean isScramble(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.isEmpty() == true) return true;\\n        \\n        return helper(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779801,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> ump;\\n    bool isScrambled(string s1, string s2){\\n        if(s1.size() != s2.size()) return false;\\n        int n = s1.size();\\n        if(s1==s2 or n==0) return true;\\n        \\n        string key = s1+\" \"+s2;\\n        if(ump.find(key) != ump.end()) return ump[key];\\n        \\n        \\n        bool flag = false;\\n        for(int i=1;i<n;i++){\\n            //for swaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(n-i,i)) and isScrambled(s1.substr(i,n-i),s2.substr(0,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n\\n            //for unswaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(0,i)) and isScrambled(s1.substr(i,n-i),s2.substr(i,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n        }\\n        ump[key]=flag;\\n        return flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size()) return false;\\n        return isScrambled(s1,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> ump;\\n    bool isScrambled(string s1, string s2){\\n        if(s1.size() != s2.size()) return false;\\n        int n = s1.size();\\n        if(s1==s2 or n==0) return true;\\n        \\n        string key = s1+\" \"+s2;\\n        if(ump.find(key) != ump.end()) return ump[key];\\n        \\n        \\n        bool flag = false;\\n        for(int i=1;i<n;i++){\\n            //for swaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(n-i,i)) and isScrambled(s1.substr(i,n-i),s2.substr(0,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n\\n            //for unswaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(0,i)) and isScrambled(s1.substr(i,n-i),s2.substr(i,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n        }\\n        ump[key]=flag;\\n        return flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size()) return false;\\n        return isScrambled(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533183,
                "title": "python-9-line-recursive-solution-explained",
                "content": "Basically we try to simulate the construction of the binary tree, and recursively split both `s1` and `s2` into same size every time and check every pair of possible splits until all splits has only one character.\\nThe `sorted` is to avoid unnecessary recursions (that grow exponentially), and it turns out to be better than `set` and `collections.Counter` in terms of runtime.\\n```python\\ndef isScramble(self, s1: str, s2: str) -> bool:\\n    def split(l1, r1, l2, r2):\\n        if r1 - l1 == 1:\\n            return s1[l1] == s2[l2]\\n        if sorted(s1[l1:r1]) != sorted(s2[l2:r2]):\\n            return False\\n        for i in range(1, r1-l1):\\n            if split(l1, l1+i, l2, l2+i) and split(l1+i, r1, l2+i, r2) or \\\\\\n               split(l1, l1+i, r2-i, r2) and split(l1+i, r1, l2, r2-i):\\n                return True\\n    return split(0, len(s1), 0, len(s2))\\n```\\nVote up if you find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\ndef isScramble(self, s1: str, s2: str) -> bool:\\n    def split(l1, r1, l2, r2):\\n        if r1 - l1 == 1:\\n            return s1[l1] == s2[l2]\\n        if sorted(s1[l1:r1]) != sorted(s2[l2:r2]):\\n            return False\\n        for i in range(1, r1-l1):\\n            if split(l1, l1+i, l2, l2+i) and split(l1+i, r1, l2+i, r2) or \\\\\\n               split(l1, l1+i, r2-i, r2) and split(l1+i, r1, l2, r2-i):\\n                return True\\n    return split(0, len(s1), 0, len(s2))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 307320,
                "title": "c-solution-4ms-and-9-7-mb",
                "content": "```\\nbool isScramble(const string s1, const string s2) {\\n    if(s1==s2)\\n            return 1;\\n\\n        int len = s1.length();\\n        int count[26] = {0};\\n        for(int i=0; i<len; i++){\\n            count[s1[i]-\\'a\\']++;\\n            count[s2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(count[i]!=0)\\n                return 0;\\n        }\\n\\n        for(int i=1; i<=len-1; i++) {\\n            if( isScramble(s1.substr(0,i), s2.substr(0,i)) && isScramble(s1.substr(i), s2.substr(i)))\\n                return 1;\\n            if( isScramble(s1.substr(0,i), s2.substr(len-i)) && isScramble(s1.substr(i), s2.substr(0,len-i)))\\n                return 1;\\n        }\\n        return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isScramble(const string s1, const string s2) {\\n    if(s1==s2)\\n            return 1;\\n\\n        int len = s1.length();\\n        int count[26] = {0};\\n        for(int i=0; i<len; i++){\\n            count[s1[i]-\\'a\\']++;\\n            count[s2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(count[i]!=0)\\n                return 0;\\n        }\\n\\n        for(int i=1; i<=len-1; i++) {\\n            if( isScramble(s1.substr(0,i), s2.substr(0,i)) && isScramble(s1.substr(i), s2.substr(i)))\\n                return 1;\\n            if( isScramble(s1.substr(0,i), s2.substr(len-i)) && isScramble(s1.substr(i), s2.substr(0,len-i)))\\n                return 1;\\n        }\\n        return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3108635,
                "title": "c-dp-memoization-easy-to-understand-recursion",
                "content": "# Complexity\\n- Time complexity:\\no(m*n)  m and n are sizes of given two strings\\n\\n- Space complexity:\\no(n+m)\\n\\n# Code\\n```\\nclass Solution {\\n\\nprivate:\\n\\n    unordered_map<string,bool> dp;\\n\\n    bool solve(string s1, string s2) {\\n        if(s1 == s2) return true;\\n\\n        if(dp.find(s1 + s2) != dp.end()) return dp[s1 + s2];\\n\\n        int n = s1.size();\\n        bool sub_check = false;\\n\\n        for(int i=1;i<n;i++) {\\n            bool swap = (solve(s1.substr(0,i), s2.substr(n-i,i)) && solve(s1.substr(i,n-i), s2.substr(0,n-i)));\\n            bool not_swap = (solve(s1.substr(0,i), s2.substr(0,i)) && solve(s1.substr(i,n), s2.substr(i,n)));\\n\\n            if(swap || not_swap) {\\n                sub_check = true;\\n                break;\\n            }\\n        }\\n\\n        return dp[s1 + s2] = sub_check;\\n    }\\n\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size()) return false;\\n        if(s1 == \"\" && s2 == \"\") return true;\\n        return solve(s1, s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n\\n    unordered_map<string,bool> dp;\\n\\n    bool solve(string s1, string s2) {\\n        if(s1 == s2) return true;\\n\\n        if(dp.find(s1 + s2) != dp.end()) return dp[s1 + s2];\\n\\n        int n = s1.size();\\n        bool sub_check = false;\\n\\n        for(int i=1;i<n;i++) {\\n            bool swap = (solve(s1.substr(0,i), s2.substr(n-i,i)) && solve(s1.substr(i,n-i), s2.substr(0,n-i)));\\n            bool not_swap = (solve(s1.substr(0,i), s2.substr(0,i)) && solve(s1.substr(i,n), s2.substr(i,n)));\\n\\n            if(swap || not_swap) {\\n                sub_check = true;\\n                break;\\n            }\\n        }\\n\\n        return dp[s1 + s2] = sub_check;\\n    }\\n\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size()) return false;\\n        if(s1 == \"\" && s2 == \"\") return true;\\n        return solve(s1, s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155263,
                "title": "aditya-verma-matrix-chain-multiplication-memoized-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> mp;\\n    bool isScramble(string a, string b) {\\n        if(a.compare(b)==0)\\n            return true;\\n        if(a.size()<=1)\\n            return false;\\n        string key=a;\\n        key.push_back(\\' \\');\\n        key.append(b);\\n        \\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        int n=a.size();\\n        bool flag=false;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if((isScramble(a.substr(0,i),b.substr(n-i,i))  && isScramble(a.substr(i,n-i),b.substr(0,n-i)))\\n              ||\\n              (isScramble(a.substr(0,i),b.substr(0,i))  && isScramble(a.substr(i,n-i),b.substr(i,n-i)))) {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        \\n        return mp[key]=flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> mp;\\n    bool isScramble(string a, string b) {\\n        if(a.compare(b)==0)\\n            return true;\\n        if(a.size()<=1)\\n            return false;\\n        string key=a;\\n        key.push_back(\\' \\');\\n        key.append(b);\\n        \\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        int n=a.size();\\n        bool flag=false;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if((isScramble(a.substr(0,i),b.substr(n-i,i))  && isScramble(a.substr(i,n-i),b.substr(0,n-i)))\\n              ||\\n              (isScramble(a.substr(0,i),b.substr(0,i))  && isScramble(a.substr(i,n-i),b.substr(i,n-i)))) {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        \\n        return mp[key]=flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099843,
                "title": "java-recursive-solution-mcm-type-aditya-verma-approach",
                "content": "```\\nclass Solution {\\n    Map<String,Boolean> map = new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length() != s2.length()) return false;\\n        return solve(s1,s2);\\n    }\\n    private boolean solve(String a, String b){\\n        int n = a.length();\\n        if(a.equals(b)) return true;\\n        \\n        String key = a + \" \" + b;\\n        if(map.containsKey(key)){\\n            return map.get(key);\\n        }\\n        boolean flag = false;\\n        for(int i=1;i<=n-1;i++){\\n            boolean noswap = solve(a.substring(0,i), b.substring(0,i)) &&\\n                            solve(a.substring(i), b.substring(i));\\n            \\n            boolean swap = solve(a.substring(0,i), b.substring(n-i)) &&\\n                            solve(a.substring(i), b.substring(0,n-i));\\n            \\n            if(swap || noswap){\\n                flag = true;\\n                break;\\n            }\\n        }\\n        map.put(key, flag);\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Map<String,Boolean> map = new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length() != s2.length()) return false;\\n        return solve(s1,s2);\\n    }\\n    private boolean solve(String a, String b){\\n        int n = a.length();\\n        if(a.equals(b)) return true;\\n        \\n        String key = a + \" \" + b;\\n        if(map.containsKey(key)){\\n            return map.get(key);\\n        }\\n        boolean flag = false;\\n        for(int i=1;i<=n-1;i++){\\n            boolean noswap = solve(a.substring(0,i), b.substring(0,i)) &&\\n                            solve(a.substring(i), b.substring(i));\\n            \\n            boolean swap = solve(a.substring(0,i), b.substring(n-i)) &&\\n                            solve(a.substring(i), b.substring(0,n-i));\\n            \\n            if(swap || noswap){\\n                flag = true;\\n                break;\\n            }\\n        }\\n        map.put(key, flag);\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205451,
                "title": "java-another-dp-solution-with-explanation",
                "content": "1. dp[i][j][1] indiates whether s1(i) equals to s2(j) and third dimension represents length.\\n2. dp[i][j][k] indicates whether s1(i, i+k) can be changed from s2(j, j+k).\\n3. if dp[i][j][l] and dp[i+l][j+l][k-l] are true, dp[i][j][k] is true. You can understand as which s1(i, i+l) and s2(j, j+l) is scramble and s1(i+l, i+k) and s2(j+l, j+k) is scramble, so s1(i, i+k) and s2(j, j+k) is scramble.\\n4. There is same argument. if dp[i][j+k-l][l] and dp[i+l][j][k-l] are true, dp[i][j][k] is true. \\n```\\npublic class Solution {\\n\\tpublic boolean isScramble(String s1, String s2) {\\n        if (s1 == null || s2 == null) return false;\\n        int m = s1.length();\\n        int n = s2.length();\\n        if (m != n) return false;\\n\\n        boolean[][][] dp = new boolean[m][m][m+1];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < m; j++) {\\n                dp[i][j][1] = s1.charAt(i) == s2.charAt(j);\\n            }\\n        }\\n\\n        for (int k = 2; k <= m; k++) {\\n            for (int i = 0; i <= m - k; i++) {\\n                for (int j = 0; j <= m - k; j++) {\\n                    dp[i][j][k] = false;\\n                    for (int part = 1; part < k; part++) {\\n                        if ((dp[i][j][l] && dp[i+l][j+l][k-l])\\n                                || (dp[i][j+k-l][l] && dp[i+l][j][k-l])) {\\n                            dp[i][j][k] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][s1.length()];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic boolean isScramble(String s1, String s2) {\\n        if (s1 == null || s2 == null) return false;\\n        int m = s1.length();\\n        int n = s2.length();\\n        if (m != n) return false;\\n\\n        boolean[][][] dp = new boolean[m][m][m+1];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < m; j++) {\\n                dp[i][j][1] = s1.charAt(i) == s2.charAt(j);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3357645,
                "title": "day-89-dp-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n*The problem of determining whether two strings are scrambled versions of each other is a challenging one. One way to approach this problem is to use dynamic programming. The key idea is to divide the strings into two non-empty substrings at a random index, and recursively apply the same process to each of these substrings. If one or both of the substrings can be scrambled into the corresponding substrings of the other string, then the original strings can be scrambled into each other as well.*\\n\\n*To solve this problem using dynamic programming, we can define a 3D boolean array dp[l][i][j] that stores whether a substring of length l starting at index i of s1 and a substring of length l starting at index j of s2 can be scrambled into each other. We can use a bottom-up approach and fill the array dp in a way that depends on its smaller values, i.e., we start with dp[1][i][j] for all i and j, which is simply the base case where l is 1. We then compute dp[l][i][j] for l > 1 by trying all possible ways to divide the substrings into two non-empty parts and recursively checking if the two parts can be scrambled into each other. If we find such a way, we set dp[l][i][j] to true.*\\n\\n*Finally, the answer to the problem is the value of dp[n][0][0], where n is the length of the input strings. This is because we want to determine whether the entire strings s1 and s2 can be scrambled into each other, which corresponds to the case where we consider substrings of length n starting at the beginning of both strings. If dp[n][0][0] is true, then the answer is yes, otherwise it is no.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Get the length of both strings s1 and s2 and check if they are equal. If not, return false.\\n2. Define a 3D boolean array dp[n+1][n][n] to store the results, where n is the length of the strings.\\n3. Initialize all values of dp to false using memset.\\n4. For the base case where the length of strings is 1, loop through both strings and if the characters are equal, set dp[1][i][j] to true.\\n5. For the general case where the length of strings is greater than 1, loop through all possible lengths of substrings (from 2 to n) and all possible starting positions of substrings (from 0 to n - length).\\n6. Divide the strings into two substrings at all possible positions and check if they are scrambled strings of each other in both swapped and same order using dp[k][i][j] and dp[l-k][i+k][j+k] and dp[k][i][j+l-k] and dp[l-k][i+k][j] respectively. If any of these checks returns true, set dp[l][i][j] to true and break out of the loop.\\n7. Return dp[n][0][0], which is the final result.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.length(); // Get the length of the strings\\n        if (n != s2.length()) { // If the lengths are not equal, return false\\n            return false;\\n        }\\n        bool dp[n + 1][n][n]; // Define a 3D boolean array to store the results\\n        memset(dp, false, sizeof(dp)); // Initialize all values to false\\n        for (int i = 0; i < n; i++) { // Base case: length 1\\n            for (int j = 0; j < n; j++) {\\n                if (s1[i] == s2[j]) { // If the characters are equal, set dp[1][i][j] to true\\n                    dp[1][i][j] = true;\\n                }\\n            }\\n        }\\n        for (int l = 2; l <= n; l++) { // General case: length > 1\\n            for (int i = 0; i <= n - l; i++) {\\n                for (int j = 0; j <= n - l; j++) {\\n                    for (int k = 1; k < l; k++) { // Divide the strings into two substrings at all possible positions\\n                        if ((dp[k][i][j] && dp[l - k][i + k][j + k]) || // Check if the two substrings are scrambled strings of each other in swapped order\\n                            (dp[k][i][j + l - k] && dp[l - k][i + k][j])) { // Check if the two substrings are scrambled strings of each other in same order\\n                            dp[l][i][j] = true; // If any one of these checks returns true, set dp[l][i][j] to true\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][0][0]; // Return dp[n][0][0], which is the final result\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        if (n != s2.length()) {\\n            return false;\\n        }\\n        boolean[][][] dp = new boolean[n + 1][n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    dp[1][i][j] = true;\\n                }\\n            }\\n        }\\n        for (int l = 2; l <= n; l++) {\\n            for (int i = 0; i <= n - l; i++) {\\n                for (int j = 0; j <= n - l; j++) {\\n                    for (int k = 1; k < l; k++) {\\n                        if ((dp[k][i][j] && dp[l - k][i + k][j + k]) ||\\n                            (dp[k][i][j + l - k] && dp[l - k][i + k][j])) {\\n                            dp[l][i][j] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][0][0];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        if n != len(s2):\\n            return False\\n        dp = [[[False for _ in range(n)] for _ in range(n)] for _ in range(n + 1)]\\n        for i in range(n):\\n            for j in range(n):\\n                if s1[i] == s2[j]:\\n                    dp[1][i][j] = True\\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                for j in range(n - l + 1):\\n                    for k in range(1, l):\\n                        if (dp[k][i][j] and dp[l - k][i + k][j + k]) or (dp[k][i][j + l - k] and dp[l - k][i + k][j]):\\n                            dp[l][i][j] = True\\n                            break\\n        return dp[n][0][0]\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** ***O(n^4)**, where n is the length of s1. This is because there are n^2 possible starting indices for the substrings, and for each pair (i,j), we iterate over k, which can take up to l-1 values. Therefore, the innermost loop runs at most (l-1) times for each pair (i,j). The total number of iterations of the innermost loop is bounded by the sum of (l-1) over all possible values of l, which is O(n^3). The initialization of dp takes O(n^3) time, so the overall time complexity of the algorithm is O(n^4).*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** ***O(n^3)**, since we use a 3D array of size n+1 x n x n to store the intermediate results.*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.length(); // Get the length of the strings\\n        if (n != s2.length()) { // If the lengths are not equal, return false\\n            return false;\\n        }\\n        bool dp[n + 1][n][n]; // Define a 3D boolean array to store the results\\n        memset(dp, false, sizeof(dp)); // Initialize all values to false\\n        for (int i = 0; i < n; i++) { // Base case: length 1\\n            for (int j = 0; j < n; j++) {\\n                if (s1[i] == s2[j]) { // If the characters are equal, set dp[1][i][j] to true\\n                    dp[1][i][j] = true;\\n                }\\n            }\\n        }\\n        for (int l = 2; l <= n; l++) { // General case: length > 1\\n            for (int i = 0; i <= n - l; i++) {\\n                for (int j = 0; j <= n - l; j++) {\\n                    for (int k = 1; k < l; k++) { // Divide the strings into two substrings at all possible positions\\n                        if ((dp[k][i][j] && dp[l - k][i + k][j + k]) || // Check if the two substrings are scrambled strings of each other in swapped order\\n                            (dp[k][i][j + l - k] && dp[l - k][i + k][j])) { // Check if the two substrings are scrambled strings of each other in same order\\n                            dp[l][i][j] = true; // If any one of these checks returns true, set dp[l][i][j] to true\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][0][0]; // Return dp[n][0][0], which is the final result\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        if (n != s2.length()) {\\n            return false;\\n        }\\n        boolean[][][] dp = new boolean[n + 1][n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    dp[1][i][j] = true;\\n                }\\n            }\\n        }\\n        for (int l = 2; l <= n; l++) {\\n            for (int i = 0; i <= n - l; i++) {\\n                for (int j = 0; j <= n - l; j++) {\\n                    for (int k = 1; k < l; k++) {\\n                        if ((dp[k][i][j] && dp[l - k][i + k][j + k]) ||\\n                            (dp[k][i][j + l - k] && dp[l - k][i + k][j])) {\\n                            dp[l][i][j] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][0][0];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        if n != len(s2):\\n            return False\\n        dp = [[[False for _ in range(n)] for _ in range(n)] for _ in range(n + 1)]\\n        for i in range(n):\\n            for j in range(n):\\n                if s1[i] == s2[j]:\\n                    dp[1][i][j] = True\\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                for j in range(n - l + 1):\\n                    for k in range(1, l):\\n                        if (dp[k][i][j] and dp[l - k][i + k][j + k]) or (dp[k][i][j + l - k] and dp[l - k][i + k][j]):\\n                            dp[l][i][j] = True\\n                            break\\n        return dp[n][0][0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357423,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if len(s1)!=len(s2):\\n            return False\\n        m=dict()\\n        def f(a,b):\\n            if (a,b) in m:\\n                return m[(a,b)]\\n            if a==b:\\n                m[a,b]=True\\n                return True\\n            if len(a)!=len(b):\\n                m[(a,b)]=False\\n                return False\\n            \\n            for i in range(1,len(a)):\\n                if f(a[:i],b[:i]) and f(a[i:],b[i:]):\\n                    m[(a,b)]=True\\n                    return True\\n                if f(a[:i],b[-i:]) and f(a[i:],b[:len(a)-i]):\\n                    m[(a,b)]=True\\n                    return True\\n                \\n            m[(a,b)]=False\\n            return False\\n        return f(s1,s2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if len(s1)!=len(s2):\\n            return False\\n        m=dict()\\n        def f(a,b):\\n            if (a,b) in m:\\n                return m[(a,b)]\\n            if a==b:\\n                m[a,b]=True\\n                return True\\n            if len(a)!=len(b):\\n                m[(a,b)]=False\\n                return False\\n            \\n            for i in range(1,len(a)):\\n                if f(a[:i],b[:i]) and f(a[i:],b[i:]):\\n                    m[(a,b)]=True\\n                    return True\\n                if f(a[:i],b[-i:]) and f(a[i:],b[:len(a)-i]):\\n                    m[(a,b)]=True\\n                    return True\\n                \\n            m[(a,b)]=False\\n            return False\\n        return f(s1,s2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991482,
                "title": "c-mcm-variation-detailed-of-each-line-memoization-top-down-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> mp;          //Create Map Globally\\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size())          //Checking length of both string\\n            return false;\\n        if(s1.size()==0 && s2.size()==0)    //If both strings are empty\\n            return true;\\n        if(s1.compare(s2)==0)               //If both strings are same\\n            return true;\\n        if(s1.size()<=1)                    //Check size of String s1 is less tha 1 OR not\\n            return false;\\n        \\n        string key=s1;                      //Generating Key for Map which should be unique\\n        key.push_back(\\' \\');\\n        key.append(s2);\\n        if(mp.find(key) != mp.end())        //Storing value in map if found \\n            return mp[key];\\n        /*Till now if we didn\\'t find our value then we will calculate particularly */\\n        int n=s1.size();\\n        bool flag=false;\\n        for(int i=1;i<n;i++) {\\n            if((isScramble(s1.substr(0,i),s2.substr(n-i,i))==true\\n              && isScramble(s1.substr(i,n-i),s2.substr(0,n-i))==true)\\n                                      || \\n               (isScramble(s1.substr(0,i),s2.substr(0,i))==true\\n                && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))==true)) {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return mp[key]=flag;\\n    }\\n};\\n```\\n*NOTE : Guys this question is super Complex to understand at first time. So, if found difficult ,refer below links of Aditya Verma Sir :*\\n**First watch Recursive approach to understand concept (Must Watch) **: https://www.youtube.com/watch?v=SqA0o-DGmEw&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=40\\n **Then watch below video of Memoization DP Approach **: https://www.youtube.com/watch?v=VyHEglhbm-A&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=41",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> mp;          //Create Map Globally\\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size())          //Checking length of both string\\n            return false;\\n        if(s1.size()==0 && s2.size()==0)    //If both strings are empty\\n            return true;\\n        if(s1.compare(s2)==0)               //If both strings are same\\n            return true;\\n        if(s1.size()<=1)                    //Check size of String s1 is less tha 1 OR not\\n            return false;\\n        \\n        string key=s1;                      //Generating Key for Map which should be unique\\n        key.push_back(\\' \\');\\n        key.append(s2);\\n        if(mp.find(key) != mp.end())        //Storing value in map if found \\n            return mp[key];\\n        /*Till now if we didn\\'t find our value then we will calculate particularly */\\n        int n=s1.size();\\n        bool flag=false;\\n        for(int i=1;i<n;i++) {\\n            if((isScramble(s1.substr(0,i),s2.substr(n-i,i))==true\\n              && isScramble(s1.substr(i,n-i),s2.substr(0,n-i))==true)\\n                                      || \\n               (isScramble(s1.substr(0,i),s2.substr(0,i))==true\\n                && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))==true)) {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return mp[key]=flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357803,
                "title": "dynamic-programming-c-recursion-with-explanation",
                "content": "Hi LeetCode Heros, Hope you are doing great.\\nTo solve this problem we just have to try all possible opration on first string and see If we can get the second string.\\nTo do that we maintain two indcies one for the first string **l1** \\nand the second for the second string **l2** \\nand another variable for the current string size **len** \\nlets start from this example input string \\n![image](https://assets.leetcode.com/users/images/05d7ac32-b194-4fb0-93e3-3558db4ea0a1_1680149563.9615712.png)\\nlets declare that  \\n**a[l1: len]** -> substring of first string that start at index **l1** and has size = len\\n**b[l2: len]** -> substring of first string that start at index **l2** and has size = len\\n**solve(l1, l2, len)** = is **string a[l1:len] == b[l2:len]**\\nif **a[l1: len] == b[l2: len]** we are done just return true \\notherwise we can try all possoble split to split the first string \\ntry cut = 1 \\nwe have string \\n**a = x + y** \\n**x = \"4\"**\\n**y = \"132\"**\\nwe have \\n![image](https://assets.leetcode.com/users/images/13147b93-ba46-4fc1-8d20-539faa98a030_1680149739.7371008.png)\\nand solve the two parts recursivley \\n**solve(l1, l2, len) = solve(l1, l2, cut) && solve(l1+cut, l2+cut, (len-cut))**\\nor we make \\n**a = y + x** \\n**x = \"4\"**\\n**y = \"132\"**\\n![image](https://assets.leetcode.com/users/images/0d11bd7c-a4a7-4a9e-912a-9183f6f30eaa_1680150156.2705226.png)\\nkeep in mind that string **b** still without change we just play with string **a**\\nand solve two parts recursivley \\n**solve(l1, l2, len) = solve(l1, l2+(len-cut), cut) && solve(l1+cut, l2, len - cut)**\\nand these 3 variable are enough to determine the two substrings so we can memo on them\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[30][30][31];\\n    int solve(string& a, string& b, int l1, int l2, int len){\\n        int& ret = dp[l1][l2][len];\\n        if (~ret) return ret;\\n        ret = 0;\\n        bool sameString = 1;\\n        for (int i = 0; i < len && sameString; i++){\\n            sameString &= (a[i+l1] == b[i+l2]);\\n        }\\n        ret = sameString;\\n\\t\\t// if the two substrings are equal or only remain substring of size = 1 \\n        if (len == 1 || sameString) return sameString;\\n        for (int cut = 1; !ret && cut < len; cut++){\\n            ret = (solve(a, b, l1, l2, cut) && \\n\\t\\t\\t\\t\\tsolve(a, b, l1 + cut, l2 + cut, len - cut));\\n\\t\\t\\t// if ret == 1, we won\\'t going to try this ... reason for ret || \\n            ret = (ret || (solve(a, b, l1+cut, l2, len - cut) && \\n\\t\\t\\t\\t\\t\\t\\tsolve(a, b, l1, l2 + len - cut, cut)));\\n        }\\n        return ret;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp, -1 ,sizeof dp);\\n        return solve(s1, s2, 0, 0, s1.size());\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[30][30][31];\\n    int solve(string& a, string& b, int l1, int l2, int len){\\n        int& ret = dp[l1][l2][len];\\n        if (~ret) return ret;\\n        ret = 0;\\n        bool sameString = 1;\\n        for (int i = 0; i < len && sameString; i++){\\n            sameString &= (a[i+l1] == b[i+l2]);\\n        }\\n        ret = sameString;\\n\\t\\t// if the two substrings are equal or only remain substring of size = 1 \\n        if (len == 1 || sameString) return sameString;\\n        for (int cut = 1; !ret && cut < len; cut++){\\n            ret = (solve(a, b, l1, l2, cut) && \\n\\t\\t\\t\\t\\tsolve(a, b, l1 + cut, l2 + cut, len - cut));\\n\\t\\t\\t// if ret == 1, we won\\'t going to try this ... reason for ret || \\n            ret = (ret || (solve(a, b, l1+cut, l2, len - cut) && \\n\\t\\t\\t\\t\\t\\t\\tsolve(a, b, l1, l2 + len - cut, cut)));\\n        }\\n        return ret;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp, -1 ,sizeof dp);\\n        return solve(s1, s2, 0, 0, s1.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357592,
                "title": "c-dp-faster-easy-to-understand",
                "content": "* ***DP***\\n\\n* ***Time Complexity :- O(N ^ 4)***\\n\\n* ***Space Complexity :- O(N ^ 2)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare an unordered map\\n    \\n    unordered_map<string, bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        // base case\\n        \\n        if(s1 == s2)\\n            return true;\\n        \\n        // create an unique key\\n        \\n        string key = s1 + \"*\" + s2;\\n        \\n        // if already calculated\\n        \\n        if(mp.count(key))\\n            return mp[key];\\n        \\n        for(int i = 0; i < s1.size() - 1; i++)\\n        {\\n            if(isScramble(s1.substr(0, i + 1), s2.substr(0, i + 1)) && isScramble(s1.substr(i + 1), s2.substr(i + 1)))\\n            {\\n                return mp[key] = true;\\n            }\\n            \\n            if(isScramble(s1.substr(0, i + 1), s2.substr(s2.size() - i - 1)) && isScramble(s1.substr(i + 1), s2.substr(0, s2.size() - i - 1)))\\n            {\\n                return mp[key] = true;\\n            } \\n        }\\n        \\n        // store the res and return it\\n        \\n        return mp[key] = false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare an unordered map\\n    \\n    unordered_map<string, bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        // base case\\n        \\n        if(s1 == s2)\\n            return true;\\n        \\n        // create an unique key\\n        \\n        string key = s1 + \"*\" + s2;\\n        \\n        // if already calculated\\n        \\n        if(mp.count(key))\\n            return mp[key];\\n        \\n        for(int i = 0; i < s1.size() - 1; i++)\\n        {\\n            if(isScramble(s1.substr(0, i + 1), s2.substr(0, i + 1)) && isScramble(s1.substr(i + 1), s2.substr(i + 1)))\\n            {\\n                return mp[key] = true;\\n            }\\n            \\n            if(isScramble(s1.substr(0, i + 1), s2.substr(s2.size() - i - 1)) && isScramble(s1.substr(i + 1), s2.substr(0, s2.size() - i - 1)))\\n            {\\n                return mp[key] = true;\\n            } \\n        }\\n        \\n        // store the res and return it\\n        \\n        return mp[key] = false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923664,
                "title": "92-faster-recursive-solution-unordered-map-optimization",
                "content": "just a recursive Solution with some optimizaions.\\n1.  Length of Both String should be same to match.\\n2. Use of unordered_map to  store recursive Calls (concat both String  and assign boolean value  )\\n3. True if Both Strings are Same.\\n\\n```\\n   unordered_map<string,bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())return false;\\n        if(s1.length()==1)return s1[0]==s2[0];\\n        if(s1==s2)return true;\\n        string concat = s1+\"/\"+s2;\\n        if(mp.find(concat)!=mp.end())return mp[concat];\\n        mp[concat] =false;\\n        vector<int> c(256,0);\\n        int  n = s1.length();\\n        for(int i=0;i<n;i++){\\n            c[s1[i]]++;\\n            c[s2[i]]--;\\n        }\\n        for(auto ch:s1){\\n            if(c[ch]!=0)return false;\\n        }\\n        for(int i=1;i<n;i++){\\n            \\n            if(isScramble(s1.substr(0,i),s2.substr(0,i))&& \\n               isScramble(s1.substr(i),s2.substr(i)))return   mp[concat]= true;\\n            if(isScramble(s1.substr(0,i),s2.substr(n-i))&& \\n               isScramble(s1.substr(i),s2.substr(0,n-i)))return mp[concat]= true;\\n        }\\n        \\n        return false;\\n    }\\n```\\n15 ms Solution\\n93% faster .\\nC++",
                "solutionTags": [
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n   unordered_map<string,bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())return false;\\n        if(s1.length()==1)return s1[0]==s2[0];\\n        if(s1==s2)return true;\\n        string concat = s1+\"/\"+s2;\\n        if(mp.find(concat)!=mp.end())return mp[concat];\\n        mp[concat] =false;\\n        vector<int> c(256,0);\\n        int  n = s1.length();\\n        for(int i=0;i<n;i++){\\n            c[s1[i]]++;\\n            c[s2[i]]--;\\n        }\\n        for(auto ch:s1){\\n            if(c[ch]!=0)return false;\\n        }\\n        for(int i=1;i<n;i++){\\n            \\n            if(isScramble(s1.substr(0,i),s2.substr(0,i))&& \\n               isScramble(s1.substr(i),s2.substr(i)))return   mp[concat]= true;\\n            if(isScramble(s1.substr(0,i),s2.substr(n-i))&& \\n               isScramble(s1.substr(i),s2.substr(0,n-i)))return mp[concat]= true;\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1223854,
                "title": "python-o-n-4-bottom-up-dp-solution",
                "content": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        dp = [[[False for i in range(n + 1)] for i in range(n)] for i in range(n)]\\n        \\n        for l in range(1,n + 1):\\n            for i in range(n - l + 1):\\n                for j in range(n - l + 1):\\n                    if l == 1:\\n                        dp[i][j][l] = s1[i] == s2[j]\\n                    else:\\n                        for k in range(1,l):\\n                            dp[i][j][l] = dp[i][j][l] or ((dp[i][j][k] and dp[i + k][j + k][l - k]) or (dp[i][j + l - k][k] and dp[i + k][j][l - k]))\\n                            if dp[i][j][l]:\\n                                break\\n        return dp[0][0][n]\\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        dp = [[[False for i in range(n + 1)] for i in range(n)] for i in range(n)]\\n        \\n        for l in range(1,n + 1):\\n            for i in range(n - l + 1):\\n                for j in range(n - l + 1):\\n                    if l == 1:\\n                        dp[i][j][l] = s1[i] == s2[j]\\n                    else:\\n                        for k in range(1,l):\\n                            dp[i][j][l] = dp[i][j][l] or ((dp[i][j][k] and dp[i + k][j + k][l - k]) or (dp[i][j + l - k][k] and dp[i + k][j][l - k]))\\n                            if dp[i][j][l]:\\n                                break\\n        return dp[0][0][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525488,
                "title": "c-dp-top-down-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/scramble-string/submissions/\\n    TC: O(N^2)\\n*/\\nclass Solution {\\npublic:\\n    // checks if s2 is scrambled form of s1\\n    /*\\n        The idea is to find a position in string s1, from where scrambling must have\\n        started to create s2. So if k is the position, then s1[0-k] and s1[k+1, N-1]\\n        were the last scramble op. We do this recursively for the smaller substrings.\\n        \\n    */\\n    bool isScrambled(int s1_start, int s1_end, int s2_start, int s2_end,\\n                    string& s1, string& s2, unordered_map<string, bool>& dp) {\\n        // create the current position combination\\n        string curr_cmb = to_string(s1_start) + \\',\\' + to_string(s1_end) + \\n                            \\',\\' + to_string(s2_start) + \\',\\' + to_string(s2_end);\\n        // check if the values is in cache \\n        auto it = dp.find(curr_cmb);\\n        if(it != dp.end())\\n            return dp[curr_cmb];\\n        \\n        // base cases\\n        if(s1_end < s1_start || s2_end < s2_start)\\n            return false;\\n        // if the size of two strings is diff, then scrambling not poss\\n        if(s1_end - s1_start != s2_end - s2_start)\\n            return false;\\n        // if the two substrings match, then they are scrambled\\n        if(s1.substr(s1_start, s1_end - s1_start + 1) == s2.substr(s2_start, s2_end - s2_start + 1))\\n            return true;\\n        \\n        // check if the two substrings contains the same set of chars\\n        vector<int> char_freq(256, 0);\\n        for(int i = 0; i <= s1_end - s1_start; i++)\\n            char_freq[s1[s1_start + i]-\\'a\\']++, char_freq[s2[s2_start + i]-\\'a\\']--;\\n        for(int i = 0; i < 256; i++)\\n            if(char_freq[i]) \\n\\t\\t\\t\\treturn false;\\n        \\n        // find a position which is the potential scramble point\\n        for(int k = 0; k < (s1_end - s1_start); k++) {\\n            // check for s1[start: k], s2[start:k] and s1[k+1 : end], s2[k+1 : end]\\n            if(isScrambled(s1_start, s1_start + k, s2_start, s2_start + k, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start + k + 1, s2_end, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n            // Now incase of s2, maybe scramble opertation was performed at k, so \\n            // now check if the other half of s2\\n            // check for s1[start: k], s2[end - k : end] and s1[k+1 : end], s2[s : end - k - 1]\\n            if(isScrambled(s1_start, s1_start + k, s2_end - k, s2_end, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start, s2_end - k - 1, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n        }\\n        return dp[curr_cmb] = false;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        // DP cache: saves the result of (s1_start, s1_end, s2_start, s2_end) cmb\\n        unordered_map<string, bool> dp;\\n        return isScrambled(0, s1.size()-1, 0, s2.size()-1, s1, s2, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/scramble-string/submissions/\\n    TC: O(N^2)\\n*/\\nclass Solution {\\npublic:\\n    // checks if s2 is scrambled form of s1\\n    /*\\n        The idea is to find a position in string s1, from where scrambling must have\\n        started to create s2. So if k is the position, then s1[0-k] and s1[k+1, N-1]\\n        were the last scramble op. We do this recursively for the smaller substrings.\\n        \\n    */\\n    bool isScrambled(int s1_start, int s1_end, int s2_start, int s2_end,\\n                    string& s1, string& s2, unordered_map<string, bool>& dp) {\\n        // create the current position combination\\n        string curr_cmb = to_string(s1_start) + \\',\\' + to_string(s1_end) + \\n                            \\',\\' + to_string(s2_start) + \\',\\' + to_string(s2_end);\\n        // check if the values is in cache \\n        auto it = dp.find(curr_cmb);\\n        if(it != dp.end())\\n            return dp[curr_cmb];\\n        \\n        // base cases\\n        if(s1_end < s1_start || s2_end < s2_start)\\n            return false;\\n        // if the size of two strings is diff, then scrambling not poss\\n        if(s1_end - s1_start != s2_end - s2_start)\\n            return false;\\n        // if the two substrings match, then they are scrambled\\n        if(s1.substr(s1_start, s1_end - s1_start + 1) == s2.substr(s2_start, s2_end - s2_start + 1))\\n            return true;\\n        \\n        // check if the two substrings contains the same set of chars\\n        vector<int> char_freq(256, 0);\\n        for(int i = 0; i <= s1_end - s1_start; i++)\\n            char_freq[s1[s1_start + i]-\\'a\\']++, char_freq[s2[s2_start + i]-\\'a\\']--;\\n        for(int i = 0; i < 256; i++)\\n            if(char_freq[i]) \\n\\t\\t\\t\\treturn false;\\n        \\n        // find a position which is the potential scramble point\\n        for(int k = 0; k < (s1_end - s1_start); k++) {\\n            // check for s1[start: k], s2[start:k] and s1[k+1 : end], s2[k+1 : end]\\n            if(isScrambled(s1_start, s1_start + k, s2_start, s2_start + k, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start + k + 1, s2_end, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n            // Now incase of s2, maybe scramble opertation was performed at k, so \\n            // now check if the other half of s2\\n            // check for s1[start: k], s2[end - k : end] and s1[k+1 : end], s2[s : end - k - 1]\\n            if(isScrambled(s1_start, s1_start + k, s2_end - k, s2_end, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start, s2_end - k - 1, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n        }\\n        return dp[curr_cmb] = false;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        // DP cache: saves the result of (s1_start, s1_end, s2_start, s2_end) cmb\\n        unordered_map<string, bool> dp;\\n        return isScrambled(0, s1.size()-1, 0, s2.size()-1, s1, s2, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29425,
                "title": "simple-to-understand-python-recursive-solution",
                "content": "    from collections import Counter\\n    class Solution(object):\\n        def isScramble(self, s1, s2):\\n            if s1 == s2: return True\\n            if Counter(s1) != Counter(s2): return False # early backtracking\\n            for i in xrange(1,len(s1)):\\n                if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])): return True\\n                if (self.isScramble(s1[:i], s2[-(i):]) and self.isScramble(s1[i:], s2[:-(i)])): return True\\n            return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "    from collections import Counter\\n    class Solution(object):\\n        def isScramble(self, s1, s2):\\n            if s1 == s2: return True\\n            if Counter(s1) != Counter(s2): return False # early backtracking\\n            for i in xrange(1,len(s1)):\\n                if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])): return True\\n                if (self.isScramble(s1[:i], s2[-(i):]) and self.isScramble(s1[i:], s2[:-(i)])): return True\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 3358593,
                "title": "python-3-dfs-dp-top-down-memoization-steps-by-steps-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS Solution (TLE)\\n\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        def dfs(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n\\n            for i in range(1, len(s1)):\\n                if (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) or \\\\\\n                    (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dfs(s1,s2)\\n```\\n\\n2. Optimized DFS (TLE - 3 tests)\\n\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        def dfs(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n            if sorted(s1) != sorted(s2): return False\\n\\n            for i in range(1, len(s1)):\\n                if (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) or \\\\\\n                    (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dfs(s1,s2)\\n```\\n\\n3. DP Top-down memoization\\n\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def dp(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n\\n            for i in range(1, len(s1)):\\n                if (dp(s1[:i], s2[:i]) and dp(s1[i:], s2[i:])) or \\\\\\n                    (dp(s1[:i], s2[-i:]) and dp(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dp(s1,s2)\\n```\\n\\n4. Optimized DP\\n\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def dp(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n            if sorted(s1) != sorted(s2): return False\\n\\n            for i in range(1, len(s1)):\\n                if (dp(s1[:i], s2[:i]) and dp(s1[i:], s2[i:])) or \\\\\\n                    (dp(s1[:i], s2[-i:]) and dp(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dp(s1,s2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        def dfs(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n\\n            for i in range(1, len(s1)):\\n                if (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) or \\\\\\n                    (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dfs(s1,s2)\\n```\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        def dfs(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n            if sorted(s1) != sorted(s2): return False\\n\\n            for i in range(1, len(s1)):\\n                if (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) or \\\\\\n                    (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dfs(s1,s2)\\n```\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def dp(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n\\n            for i in range(1, len(s1)):\\n                if (dp(s1[:i], s2[:i]) and dp(s1[i:], s2[i:])) or \\\\\\n                    (dp(s1[:i], s2[-i:]) and dp(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dp(s1,s2)\\n```\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def dp(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n            if sorted(s1) != sorted(s2): return False\\n\\n            for i in range(1, len(s1)):\\n                if (dp(s1[:i], s2[:i]) and dp(s1[i:], s2[i:])) or \\\\\\n                    (dp(s1[:i], s2[-i:]) and dp(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dp(s1,s2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358560,
                "title": "dynamic-programming-solution-to-check-if-strings-are-scrambled-with-easy-and-full-explanation",
                "content": "# Intuition\\nThe problem can be solved using a dynamic programming approach where we check if the substrings of s1 and s2 are scrambled strings or not. We start by checking the base cases, which is when the length of the substring is 1. We then recursively check all possible split points and if the substrings are swapped or not.\\n\\n# Approach\\nThe solution uses a dynamic programming approach to solve the problem. Let dp[i][j][len] be true if the substring s1[i:i+len] is a scrambled string of the substring s2[j:j+len], and false otherwise.\\n\\nThe base case is when len = 1, in which case we just need to check if the characters in the substrings are equal. If they are, then we set dp[i][j][1] to true, otherwise to false.\\n\\nFor the recursive case, we try all possible split points of the substrings s1[i:i+len] and s2[j:j+len]. If the substrings are split at position k, we have two possibilities: either the substrings are not swapped, or they are swapped. If they are not swapped, then we need to check if the left halves and right halves are scrambled strings, i.e., dp[i][j][k] && dp[i+k][j+k][len-k]. If they are swapped, then we need to check if the left half of s1 and the right half of s2 are scrambled strings, and if the right half of s1 and the left half of s2 are scrambled strings, i.e., dp[i][j+len-k][k] && dp[i+k][j][len-k].\\n\\nThe overall solution is the value of dp[0][0][n], where n is the length of the input strings.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is O(n^4), where n is the length of the input strings. This is because we have three nested loops, and the length of the substrings can be up to n.\\n\\n- Space complexity:\\nThe space complexity of the solution is O(n^3), where n is the length of the input strings. This is because we need to store the results of all possible substring combinations in the 3D array dp.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if (s1 == s2) {\\n            return true;\\n        }\\n        int n = s1.length();\\n        if (n != s2.length()) {\\n            return false;\\n        }\\n        vector<int> count(26, 0);\\n        for (int i = 0; i < n; i++) {\\n            count[s1[i] - \\'a\\']++;\\n            count[s2[i] - \\'a\\']--;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                return false;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(n + 1, -1)));\\n        return isScrambleHelper(s1, s2, 0, 0, n, dp);\\n    }\\n    \\n    bool isScrambleHelper(string& s1, string& s2, int i, int j, int len, vector<vector<vector<int>>>& dp) {\\n        if (dp[i][j][len] != -1) {\\n            return dp[i][j][len];\\n        }\\n        if (s1.substr(i, len) == s2.substr(j, len)) {\\n            return dp[i][j][len] = true;\\n        }\\n        vector<int> count(26, 0);\\n        for (int k = 0; k < len; k++) {\\n            count[s1[i + k] - \\'a\\']++;\\n            count[s2[j + k] - \\'a\\']--;\\n        }\\n        for (int k = 0; k < 26; k++) {\\n            if (count[k] != 0) {\\n                return dp[i][j][len] = false;\\n            }\\n        }\\n        for (int k = 1; k < len; k++) {\\n            if ((isScrambleHelper(s1, s2, i, j, k, dp) && isScrambleHelper(s1, s2, i + k, j + k, len - k, dp)) ||\\n               (isScrambleHelper(s1, s2, i, j + len - k, k, dp) && isScrambleHelper(s1, s2, i + k, j, len - k, dp))) {\\n                return dp[i][j][len] = true;\\n            }\\n        }\\n        return dp[i][j][len] = false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if (s1 == s2) {\\n            return true;\\n        }\\n        int n = s1.length();\\n        if (n != s2.length()) {\\n            return false;\\n        }\\n        vector<int> count(26, 0);\\n        for (int i = 0; i < n; i++) {\\n            count[s1[i] - \\'a\\']++;\\n            count[s2[i] - \\'a\\']--;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                return false;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(n + 1, -1)));\\n        return isScrambleHelper(s1, s2, 0, 0, n, dp);\\n    }\\n    \\n    bool isScrambleHelper(string& s1, string& s2, int i, int j, int len, vector<vector<vector<int>>>& dp) {\\n        if (dp[i][j][len] != -1) {\\n            return dp[i][j][len];\\n        }\\n        if (s1.substr(i, len) == s2.substr(j, len)) {\\n            return dp[i][j][len] = true;\\n        }\\n        vector<int> count(26, 0);\\n        for (int k = 0; k < len; k++) {\\n            count[s1[i + k] - \\'a\\']++;\\n            count[s2[j + k] - \\'a\\']--;\\n        }\\n        for (int k = 0; k < 26; k++) {\\n            if (count[k] != 0) {\\n                return dp[i][j][len] = false;\\n            }\\n        }\\n        for (int k = 1; k < len; k++) {\\n            if ((isScrambleHelper(s1, s2, i, j, k, dp) && isScrambleHelper(s1, s2, i + k, j + k, len - k, dp)) ||\\n               (isScrambleHelper(s1, s2, i, j + len - k, k, dp) && isScrambleHelper(s1, s2, i + k, j, len - k, dp))) {\\n                return dp[i][j][len] = true;\\n            }\\n        }\\n        return dp[i][j][len] = false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357734,
                "title": "easiest-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n^4)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n\\n        Map<String, Boolean> memo = new HashMap<>();\\n        return isScrambleHelper(s1, s2, memo);\\n    }\\n\\n    private boolean isScrambleHelper(String s1, String s2, Map<String, Boolean> memo) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (memo.containsKey(s1 + \"#\" + s2)) {\\n            return memo.get(s1 + \"#\" + s2);\\n        }\\n\\n        int n = s1.length();\\n        for (int i = 1; i < n; i++) {\\n            if (isScrambleHelper(s1.substring(0, i), s2.substring(0, i), memo) &&\\n                isScrambleHelper(s1.substring(i), s2.substring(i), memo)) {\\n                memo.put(s1 + \"#\" + s2, true);\\n                return true;\\n            }\\n            if (isScrambleHelper(s1.substring(0, i), s2.substring(n-i), memo) &&\\n                isScrambleHelper(s1.substring(i), s2.substring(0, n-i), memo)) {\\n                memo.put(s1 + \"#\" + s2, true);\\n                return true;\\n            }\\n        }\\n\\n        memo.put(s1 + \"#\" + s2, false);\\n        return false;\\n    }\\n}\\n```\\n# Upvoting is much appreciated",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n\\n        Map<String, Boolean> memo = new HashMap<>();\\n        return isScrambleHelper(s1, s2, memo);\\n    }\\n\\n    private boolean isScrambleHelper(String s1, String s2, Map<String, Boolean> memo) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (memo.containsKey(s1 + \"#\" + s2)) {\\n            return memo.get(s1 + \"#\" + s2);\\n        }\\n\\n        int n = s1.length();\\n        for (int i = 1; i < n; i++) {\\n            if (isScrambleHelper(s1.substring(0, i), s2.substring(0, i), memo) &&\\n                isScrambleHelper(s1.substring(i), s2.substring(i), memo)) {\\n                memo.put(s1 + \"#\" + s2, true);\\n                return true;\\n            }\\n            if (isScrambleHelper(s1.substring(0, i), s2.substring(n-i), memo) &&\\n                isScrambleHelper(s1.substring(i), s2.substring(0, n-i), memo)) {\\n                memo.put(s1 + \"#\" + s2, true);\\n                return true;\\n            }\\n        }\\n\\n        memo.put(s1 + \"#\" + s2, false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426144,
                "title": "c-bottom-up",
                "content": "just get gud to understand\\n\\n```cpp\\nclass Solution {\\n   public:\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.size();\\n        bool dp[n][n][n + 1];\\n        memset(dp, 0, sizeof dp);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s1[i] == s2[j]) {\\n                    dp[i][j][0] = true;\\n                }\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                for (int j = 0; j <= n - len; j++) {\\n                    for (int len1 = 1; len1 <= len - 1; len1++) {\\n                        int len2 = len - len1;\\n                        dp[i][j][len - 1] |= dp[i][j][len1 - 1] && dp[i + len1][j + len1][len2 - 1];\\n                        dp[i][j][len - 1] |= dp[i][j + len2][len1 - 1] && dp[i + len1][j][len2 - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][n - 1];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n   public:\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.size();\\n        bool dp[n][n][n + 1];\\n        memset(dp, 0, sizeof dp);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s1[i] == s2[j]) {\\n                    dp[i][j][0] = true;\\n                }\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                for (int j = 0; j <= n - len; j++) {\\n                    for (int len1 = 1; len1 <= len - 1; len1++) {\\n                        int len2 = len - len1;\\n                        dp[i][j][len - 1] |= dp[i][j][len1 - 1] && dp[i + len1][j + len1][len2 - 1];\\n                        dp[i][j][len - 1] |= dp[i][j + len2][len1 - 1] && dp[i + len1][j][len2 - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][n - 1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990829,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\npublic class Solution {\\n\\tpublic boolean isScramble(String s1, String s2) {\\n\\t\\tif (s1.length() != s2.length()) return false;\\n\\t\\tint len = s1.length();\\n\\t\\t/**\\n\\t\\t * Let F(i, j, k) = whether the substring S1[i..i + k - 1] is a scramble of S2[j..j + k - 1] or not\\n\\t\\t * Since each of these substrings is a potential node in the tree, we need to check for all possible cuts.\\n\\t\\t * Let q be the length of a cut (hence, q < k), then we are in the following situation:\\n\\t\\t * \\n\\t\\t * S1 [   x1    |         x2         ]\\n\\t\\t *    i         i + q                i + k - 1\\n\\t\\t * \\n\\t\\t * here we have two possibilities:\\n\\t\\t *      \\n\\t\\t * S2 [   y1    |         y2         ]\\n\\t\\t *    j         j + q                j + k - 1\\n\\t\\t *    \\n\\t\\t * or \\n\\t\\t * \\n\\t\\t * S2 [       y1        |     y2     ]\\n\\t\\t *    j                 j + k - q    j + k - 1\\n\\t\\t * \\n\\t\\t * which in terms of F means:\\n\\t\\t * \\n\\t\\t * F(i, j, k) = for some 1 <= q < k we have:\\n\\t\\t *  (F(i, j, q) AND F(i + q, j + q, k - q)) OR (F(i, j + k - q, q) AND F(i + q, j, k - q))\\n\\t\\t *  \\n\\t\\t * Base case is k = 1, where we simply need to check for S1[i] and S2[j] to be equal \\n\\t\\t * */\\n\\t\\tboolean [][][] F = new boolean[len][len][len + 1];\\n\\t\\tfor (int k = 1; k <= len; ++k)\\n\\t\\t\\tfor (int i = 0; i + k <= len; ++i)\\n\\t\\t\\t\\tfor (int j = 0; j + k <= len; ++j)\\n\\t\\t\\t\\t\\tif (k == 1)\\n\\t\\t\\t\\t\\t\\tF[i][j][k] = s1.charAt(i) == s2.charAt(j);\\n\\t\\t\\t\\t\\telse for (int q = 1; q < k && !F[i][j][k]; ++q) {\\n\\t\\t\\t\\t\\t\\tF[i][j][k] = (F[i][j][q] && F[i + q][j + q][k - q]) || (F[i][j + k - q][q] && F[i + q][j][k - q]);\\n\\t\\t\\t\\t\\t}\\n\\t\\treturn F[0][0][len];\\n\\t}\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    // checks if s2 is scrambled form of s1\\n    /*\\n        The idea is to find a position in string s1, from where scrambling must have\\n        started to create s2. So if k is the position, then s1[0-k] and s1[k+1, N-1]\\n        were the last scramble op. We do this recursively for the smaller substrings.\\n        \\n    */\\n    bool isScrambled(int s1_start, int s1_end, int s2_start, int s2_end,\\n                    string& s1, string& s2, unordered_map<string, bool>& dp) {\\n        // create the current position combination\\n        string curr_cmb = to_string(s1_start) + \\',\\' + to_string(s1_end) + \\n                            \\',\\' + to_string(s2_start) + \\',\\' + to_string(s2_end);\\n        // check if the values is in cache \\n        auto it = dp.find(curr_cmb);\\n        if(it != dp.end())\\n            return dp[curr_cmb];\\n        \\n        // base cases\\n        if(s1_end < s1_start || s2_end < s2_start)\\n            return false;\\n        // if the size of two strings is diff, then scrambling not poss\\n        if(s1_end - s1_start != s2_end - s2_start)\\n            return false;\\n        // if the two substrings match, then they are scrambled\\n        if(s1.substr(s1_start, s1_end - s1_start + 1) == s2.substr(s2_start, s2_end - s2_start + 1))\\n            return true;\\n        \\n        // check if the two substrings contains the same set of chars\\n        vector<int> char_freq(256, 0);\\n        for(int i = 0; i <= s1_end - s1_start; i++)\\n            char_freq[s1[s1_start + i]-\\'a\\']++, char_freq[s2[s2_start + i]-\\'a\\']--;\\n        for(int i = 0; i < 256; i++)\\n            if(char_freq[i]) \\n\\t\\t\\t\\treturn false;\\n        \\n        // find a position which is the potential scramble point\\n        for(int k = 0; k < (s1_end - s1_start); k++) {\\n            // check for s1[start: k], s2[start:k] and s1[k+1 : end], s2[k+1 : end]\\n            if(isScrambled(s1_start, s1_start + k, s2_start, s2_start + k, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start + k + 1, s2_end, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n            // Now incase of s2, maybe scramble opertation was performed at k, so \\n            // now check if the other half of s2\\n            // check for s1[start: k], s2[end - k : end] and s1[k+1 : end], s2[s : end - k - 1]\\n            if(isScrambled(s1_start, s1_start + k, s2_end - k, s2_end, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start, s2_end - k - 1, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n        }\\n        return dp[curr_cmb] = false;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        // DP cache: saves the result of (s1_start, s1_end, s2_start, s2_end) cmb\\n        unordered_map<string, bool> dp;\\n        return isScrambled(0, s1.size()-1, 0, s2.size()-1, s1, s2, dp);\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if s1 == s2:\\n            return True\\n        if len(s1) != len(s2):\\n            return False\\n            \\n        # Check both strings have same count of letters\\n        count1 = collections.defaultdict(int)\\n        count2 = collections.defaultdict(int)\\n        for c1, c2 in zip(s1, s2):\\n            count1[c1] += 1\\n            count2[c2] += 1\\n        if count1 != count2: return False\\n        \\n        # Iterate through letters and check if it results in a partition of \\n        # string 1 where the collection of letters are the same\\n        # on the left (non-swapped) or right (swapped) sides of string 2\\n        # Then we recursively check these partitioned strings to see if they are scrambled\\n        lcount1 = collections.defaultdict(int) # s1 count from left\\n        lcount2 = collections.defaultdict(int) # s2 count from left\\n        rcount2 = collections.defaultdict(int) # s2 count from right\\n        for i in xrange(len(s1) - 1):\\n            lcount1[s1[i]] += 1          \\n            lcount2[s2[i]] += 1\\n            rcount2[s2[len(s1) - 1 - i]] += 1\\n            if lcount1 == lcount2:  # Left sides of both strings have same letters\\n                if self.isScramble(s1[:i + 1], s2[:i + 1]) and \\\\\\n                   self.isScramble(s1[i + 1:], s2[i + 1:]):\\n                    return True\\n            elif lcount1 == rcount2: # Left side of s1 has same letters as right side of s2\\n                if self.isScramble(s1[:i + 1], s2[-(i + 1):]) and \\\\\\n                   self.isScramble(s1[i + 1:], s2[:-(i + 1)]):\\n                    return True\\n        return False\\n```\\n\\n***JavaScript***\\n```\\nconst _isScramble = function (s1, s2, trackMap) {    \\n    if (s1.length !== s2.length) return false;\\n    if (s1 === s2) return true;\\n    if (s1.length === 0 || s2.length === 0) return true;\\n    const trackKey = s1 + s2;\\n    if (trackKey in trackMap) return !!trackMap[trackKey];\\n\\n    let result = false;\\n    let xorFW = 0;\\n    let xorBW = 0;\\n\\n    for (var i = 0, j = s1.length - 1, iPlus = 1; i < s1.length - 1; i++, j--, iPlus++) {\\n        xorFW ^= s1.charCodeAt(i) ^ s2.charCodeAt(i);\\n        xorBW ^= s1.charCodeAt(i) ^ s2.charCodeAt(j);\\n\\n        if (xorFW === 0 &&\\n            _isScramble(s1.substring(0, iPlus), s2.substring(0, iPlus), trackMap) &&\\n            _isScramble(s1.substring(iPlus), s2.substring(iPlus), trackMap)) {\\n            result = true;\\n            break;\\n        }\\n\\n        if (xorBW === 0 &&\\n            _isScramble(s1.substring(0, iPlus), s2.substring(s1.length - iPlus), trackMap) &&\\n            _isScramble(s1.substring(iPlus), s2.substring(0, s1.length - iPlus), trackMap)) {\\n            result = true;\\n            break;\\n        }\\n    }\\n\\n    trackMap[trackKey] = result;\\n    trackMap[s2 + s1] = result;\\n    return result;\\n};\\n\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {boolean}\\n */\\nconst isScramble = function (s1, s2) {\\n    return _isScramble(s1, s2, {});\\n};\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n    val memo = mutableMapOf<String, Boolean>()\\n    \\n    fun isNotAnagram(s1: String, s2: String): Boolean {\\n        val f1 = MutableList(26) {0}\\n        val f2 = MutableList(26) {0}\\n        for (c in s1) {\\n            f1[(c-\\'a\\').toInt()]++\\n        }\\n        for (c in s2) {\\n            f2[(c-\\'a\\').toInt()]++\\n        }\\n        return f1.toString() != f2.toString()\\n    }\\n    \\n    fun isScramble(s1: String, s2: String): Boolean {\\n        if (s1 == s2) return true\\n        if (isNotAnagram(s1, s2)) return false\\n        memo[\"$s1*$s2\"]?.let {\\n            return it\\n        }\\n        val n = s1.length\\n        for (i in 1 .. n-1) {\\n            \\n            if ((isScramble(s1.substring(0,i), s2.substring(0,i)) && isScramble(s1.substring(i,n), s2.substring(i,n))) || (isScramble(s1.substring(0,i), s2.substring(n-i,n)) && isScramble(s1.substring(i,n), s2.substring(0,n-i)))) {\\n                memo[\"$s1*$s2\"] = true\\n                return true\\n            }\\n        }\\n        memo[\"$s1*$s2\"] = false\\n        return false\\n    }\\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func isScramble(_ s1: String, _ s2: String) -> Bool {\\n        var dp: [String: Bool] = [:]\\n        \\n\\n        func _isScramble(_ chs1: [Character], _ chs2: [Character]) -> Bool {\\n            let key = String(chs1) + \"-\" +  String(chs2)\\n            if let v = dp[key] { return v }            \\n            if chs1.count == 1 { return chs1[0] == chs2[0] }\\n            var val = false\\n\\n            for i in 1..<chs1.count {\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[0..<i])) \\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[i..<chs2.count])))\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[chs2.count - i..<chs2.count]))\\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[0..<chs2.count-i]))) \\n            }\\n            \\n            dp[key] = val\\n            return val\\n        }\\n        \\n        if s1.count != s2.count {\\n            return false\\n        } else {\\n            return _isScramble(Array(s1), Array(s2))\\n        }\\n    }\\n    \\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***\\n***\"Open your eyes.\"***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\npublic class Solution {\\n\\tpublic boolean isScramble(String s1, String s2) {\\n\\t\\tif (s1.length() != s2.length()) return false;\\n\\t\\tint len = s1.length();\\n\\t\\t/**\\n\\t\\t * Let F(i, j, k) = whether the substring S1[i..i + k - 1] is a scramble of S2[j..j + k - 1] or not\\n\\t\\t * Since each of these substrings is a potential node in the tree, we need to check for all possible cuts.\\n\\t\\t * Let q be the length of a cut (hence, q < k), then we are in the following situation:\\n\\t\\t * \\n\\t\\t * S1 [   x1    |         x2         ]\\n\\t\\t *    i         i + q                i + k - 1\\n\\t\\t * \\n\\t\\t * here we have two possibilities:\\n\\t\\t *      \\n\\t\\t * S2 [   y1    |         y2         ]\\n\\t\\t *    j         j + q                j + k - 1\\n\\t\\t *    \\n\\t\\t * or \\n\\t\\t * \\n\\t\\t * S2 [       y1        |     y2     ]\\n\\t\\t *    j                 j + k - q    j + k - 1\\n\\t\\t * \\n\\t\\t * which in terms of F means:\\n\\t\\t * \\n\\t\\t * F(i, j, k) = for some 1 <= q < k we have:\\n\\t\\t *  (F(i, j, q) AND F(i + q, j + q, k - q)) OR (F(i, j + k - q, q) AND F(i + q, j, k - q))\\n\\t\\t *  \\n\\t\\t * Base case is k = 1, where we simply need to check for S1[i] and S2[j] to be equal \\n\\t\\t * */\\n\\t\\tboolean [][][] F = new boolean[len][len][len + 1];\\n\\t\\tfor (int k = 1; k <= len; ++k)\\n\\t\\t\\tfor (int i = 0; i + k <= len; ++i)\\n\\t\\t\\t\\tfor (int j = 0; j + k <= len; ++j)\\n\\t\\t\\t\\t\\tif (k == 1)\\n\\t\\t\\t\\t\\t\\tF[i][j][k] = s1.charAt(i) == s2.charAt(j);\\n\\t\\t\\t\\t\\telse for (int q = 1; q < k && !F[i][j][k]; ++q) {\\n\\t\\t\\t\\t\\t\\tF[i][j][k] = (F[i][j][q] && F[i + q][j + q][k - q]) || (F[i][j + k - q][q] && F[i + q][j][k - q]);\\n\\t\\t\\t\\t\\t}\\n\\t\\treturn F[0][0][len];\\n\\t}\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    // checks if s2 is scrambled form of s1\\n    /*\\n        The idea is to find a position in string s1, from where scrambling must have\\n        started to create s2. So if k is the position, then s1[0-k] and s1[k+1, N-1]\\n        were the last scramble op. We do this recursively for the smaller substrings.\\n        \\n    */\\n    bool isScrambled(int s1_start, int s1_end, int s2_start, int s2_end,\\n                    string& s1, string& s2, unordered_map<string, bool>& dp) {\\n        // create the current position combination\\n        string curr_cmb = to_string(s1_start) + \\',\\' + to_string(s1_end) + \\n                            \\',\\' + to_string(s2_start) + \\',\\' + to_string(s2_end);\\n        // check if the values is in cache \\n        auto it = dp.find(curr_cmb);\\n        if(it != dp.end())\\n            return dp[curr_cmb];\\n        \\n        // base cases\\n        if(s1_end < s1_start || s2_end < s2_start)\\n            return false;\\n        // if the size of two strings is diff, then scrambling not poss\\n        if(s1_end - s1_start != s2_end - s2_start)\\n            return false;\\n        // if the two substrings match, then they are scrambled\\n        if(s1.substr(s1_start, s1_end - s1_start + 1) == s2.substr(s2_start, s2_end - s2_start + 1))\\n            return true;\\n        \\n        // check if the two substrings contains the same set of chars\\n        vector<int> char_freq(256, 0);\\n        for(int i = 0; i <= s1_end - s1_start; i++)\\n            char_freq[s1[s1_start + i]-\\'a\\']++, char_freq[s2[s2_start + i]-\\'a\\']--;\\n        for(int i = 0; i < 256; i++)\\n            if(char_freq[i]) \\n\\t\\t\\t\\treturn false;\\n        \\n        // find a position which is the potential scramble point\\n        for(int k = 0; k < (s1_end - s1_start); k++) {\\n            // check for s1[start: k], s2[start:k] and s1[k+1 : end], s2[k+1 : end]\\n            if(isScrambled(s1_start, s1_start + k, s2_start, s2_start + k, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start + k + 1, s2_end, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n            // Now incase of s2, maybe scramble opertation was performed at k, so \\n            // now check if the other half of s2\\n            // check for s1[start: k], s2[end - k : end] and s1[k+1 : end], s2[s : end - k - 1]\\n            if(isScrambled(s1_start, s1_start + k, s2_end - k, s2_end, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start, s2_end - k - 1, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n        }\\n        return dp[curr_cmb] = false;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        // DP cache: saves the result of (s1_start, s1_end, s2_start, s2_end) cmb\\n        unordered_map<string, bool> dp;\\n        return isScrambled(0, s1.size()-1, 0, s2.size()-1, s1, s2, dp);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if s1 == s2:\\n            return True\\n        if len(s1) != len(s2):\\n            return False\\n            \\n        # Check both strings have same count of letters\\n        count1 = collections.defaultdict(int)\\n        count2 = collections.defaultdict(int)\\n        for c1, c2 in zip(s1, s2):\\n            count1[c1] += 1\\n            count2[c2] += 1\\n        if count1 != count2: return False\\n        \\n        # Iterate through letters and check if it results in a partition of \\n        # string 1 where the collection of letters are the same\\n        # on the left (non-swapped) or right (swapped) sides of string 2\\n        # Then we recursively check these partitioned strings to see if they are scrambled\\n        lcount1 = collections.defaultdict(int) # s1 count from left\\n        lcount2 = collections.defaultdict(int) # s2 count from left\\n        rcount2 = collections.defaultdict(int) # s2 count from right\\n        for i in xrange(len(s1) - 1):\\n            lcount1[s1[i]] += 1          \\n            lcount2[s2[i]] += 1\\n            rcount2[s2[len(s1) - 1 - i]] += 1\\n            if lcount1 == lcount2:  # Left sides of both strings have same letters\\n                if self.isScramble(s1[:i + 1], s2[:i + 1]) and \\\\\\n                   self.isScramble(s1[i + 1:], s2[i + 1:]):\\n                    return True\\n            elif lcount1 == rcount2: # Left side of s1 has same letters as right side of s2\\n                if self.isScramble(s1[:i + 1], s2[-(i + 1):]) and \\\\\\n                   self.isScramble(s1[i + 1:], s2[:-(i + 1)]):\\n                    return True\\n        return False\\n```\n```\\nconst _isScramble = function (s1, s2, trackMap) {    \\n    if (s1.length !== s2.length) return false;\\n    if (s1 === s2) return true;\\n    if (s1.length === 0 || s2.length === 0) return true;\\n    const trackKey = s1 + s2;\\n    if (trackKey in trackMap) return !!trackMap[trackKey];\\n\\n    let result = false;\\n    let xorFW = 0;\\n    let xorBW = 0;\\n\\n    for (var i = 0, j = s1.length - 1, iPlus = 1; i < s1.length - 1; i++, j--, iPlus++) {\\n        xorFW ^= s1.charCodeAt(i) ^ s2.charCodeAt(i);\\n        xorBW ^= s1.charCodeAt(i) ^ s2.charCodeAt(j);\\n\\n        if (xorFW === 0 &&\\n            _isScramble(s1.substring(0, iPlus), s2.substring(0, iPlus), trackMap) &&\\n            _isScramble(s1.substring(iPlus), s2.substring(iPlus), trackMap)) {\\n            result = true;\\n            break;\\n        }\\n\\n        if (xorBW === 0 &&\\n            _isScramble(s1.substring(0, iPlus), s2.substring(s1.length - iPlus), trackMap) &&\\n            _isScramble(s1.substring(iPlus), s2.substring(0, s1.length - iPlus), trackMap)) {\\n            result = true;\\n            break;\\n        }\\n    }\\n\\n    trackMap[trackKey] = result;\\n    trackMap[s2 + s1] = result;\\n    return result;\\n};\\n\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {boolean}\\n */\\nconst isScramble = function (s1, s2) {\\n    return _isScramble(s1, s2, {});\\n};\\n```\n```\\nclass Solution {\\n    val memo = mutableMapOf<String, Boolean>()\\n    \\n    fun isNotAnagram(s1: String, s2: String): Boolean {\\n        val f1 = MutableList(26) {0}\\n        val f2 = MutableList(26) {0}\\n        for (c in s1) {\\n            f1[(c-\\'a\\').toInt()]++\\n        }\\n        for (c in s2) {\\n            f2[(c-\\'a\\').toInt()]++\\n        }\\n        return f1.toString() != f2.toString()\\n    }\\n    \\n    fun isScramble(s1: String, s2: String): Boolean {\\n        if (s1 == s2) return true\\n        if (isNotAnagram(s1, s2)) return false\\n        memo[\"$s1*$s2\"]?.let {\\n            return it\\n        }\\n        val n = s1.length\\n        for (i in 1 .. n-1) {\\n            \\n            if ((isScramble(s1.substring(0,i), s2.substring(0,i)) && isScramble(s1.substring(i,n), s2.substring(i,n))) || (isScramble(s1.substring(0,i), s2.substring(n-i,n)) && isScramble(s1.substring(i,n), s2.substring(0,n-i)))) {\\n                memo[\"$s1*$s2\"] = true\\n                return true\\n            }\\n        }\\n        memo[\"$s1*$s2\"] = false\\n        return false\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func isScramble(_ s1: String, _ s2: String) -> Bool {\\n        var dp: [String: Bool] = [:]\\n        \\n\\n        func _isScramble(_ chs1: [Character], _ chs2: [Character]) -> Bool {\\n            let key = String(chs1) + \"-\" +  String(chs2)\\n            if let v = dp[key] { return v }            \\n            if chs1.count == 1 { return chs1[0] == chs2[0] }\\n            var val = false\\n\\n            for i in 1..<chs1.count {\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[0..<i])) \\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[i..<chs2.count])))\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[chs2.count - i..<chs2.count]))\\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[0..<chs2.count-i]))) \\n            }\\n            \\n            dp[key] = val\\n            return val\\n        }\\n        \\n        if s1.count != s2.count {\\n            return false\\n        } else {\\n            return _isScramble(Array(s1), Array(s2))\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137834,
                "title": "mcm-aditya-verma-matrix-chain-multiplication-memoized-dp-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    bool solve(string s1,string s2)\\n    {\\n        int n=s1.length();\\n        if(s1.compare(s2)==0)\\n            return true;\\n        string key=s1+\" \"+s2;\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        bool flag=false;\\n        for(int i=1;i<n;i++)\\n        {\\n        bool unswap=solve(s1.substr(0,i),s2.substr(0,i)) && solve(s1.substr(i,n-i),s2.substr(i,n-i));\\n    bool swapped=solve(s1.substr(0,i),s2.substr(n-i,i)) && solve(s1.substr(i),s2.substr(0,n-i));\\n            if(unswap || swapped)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        mp[key]=flag;\\n        return flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        if(s1.length()>s2.length())\\n            return false;\\n        return solve(s1,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    bool solve(string s1,string s2)\\n    {\\n        int n=s1.length();\\n        if(s1.compare(s2)==0)\\n            return true;\\n        string key=s1+\" \"+s2;\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        bool flag=false;\\n        for(int i=1;i<n;i++)\\n        {\\n        bool unswap=solve(s1.substr(0,i),s2.substr(0,i)) && solve(s1.substr(i,n-i),s2.substr(i,n-i));\\n    bool swapped=solve(s1.substr(0,i),s2.substr(n-i,i)) && solve(s1.substr(i),s2.substr(0,n-i));\\n            if(unswap || swapped)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        mp[key]=flag;\\n        return flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        if(s1.length()>s2.length())\\n            return false;\\n        return solve(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342546,
                "title": "my-4ms-concise-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2)\\n    {\\n        if (s1.size()!=s2.size()) return false;\\n        if (s1==s2) return true;\\n        string tmp1=s1, tmp2=s2;\\n        sort(tmp1.begin(), tmp1.end());\\n        sort(tmp2.begin(), tmp2.end());\\n        if (tmp1!=tmp2) return false;\\n\\n        for (int i=1; i<s1.size(); i++)\\n        {\\n            // left<->left, right<->right\\n            // or left<->right, right<->left\\n            if ( (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i),s2.substr(i))) \\\\\\n            || (isScramble(s1.substr(0, i), s2.substr(s2.size()-i)) && isScramble(s1.substr(i),s2.substr(0, s2.size()-i))) )\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2)\\n    {\\n        if (s1.size()!=s2.size()) return false;\\n        if (s1==s2) return true;\\n        string tmp1=s1, tmp2=s2;\\n        sort(tmp1.begin(), tmp1.end());\\n        sort(tmp2.begin(), tmp2.end());\\n        if (tmp1!=tmp2) return false;\\n\\n        for (int i=1; i<s1.size(); i++)\\n        {\\n            // left<->left, right<->right\\n            // or left<->right, right<->left\\n            if ( (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i),s2.substr(i))) \\\\\\n            || (isScramble(s1.substr(0, i), s2.substr(s2.size()-i)) && isScramble(s1.substr(i),s2.substr(0, s2.size()-i))) )\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29447,
                "title": "60-ms-recursive-python-solution-faster-than-100-of-python-solutions-with-comments",
                "content": "    class Solution(object):\\n        def isScramble(self, s1, s2):\\n            \"\"\"\\n            :type s1: str\\n            :type s2: str\\n            :rtype: bool\\n            \"\"\"\\n            if s1 == s2:\\n                return True\\n            if len(s1) != len(s2):\\n                return False\\n                \\n            # Check both strings have same count of letters\\n            count1 = collections.defaultdict(int)\\n            count2 = collections.defaultdict(int)\\n            for c1, c2 in zip(s1, s2):\\n                count1[c1] += 1\\n                count2[c2] += 1\\n            if count1 != count2: return False\\n            \\n            # Iterate through letters and check if it results in a partition of \\n            # string 1 where the collection of letters are the same\\n            # on the left (non-swapped) or right (swapped) sides of string 2\\n            # Then we recursively check these partitioned strings to see if they are scrambled\\n            lcount1 = collections.defaultdict(int) # s1 count from left\\n            lcount2 = collections.defaultdict(int) # s2 count from left\\n            rcount2 = collections.defaultdict(int) # s2 count from right\\n            for i in xrange(len(s1) - 1):\\n                lcount1[s1[i]] += 1          \\n                lcount2[s2[i]] += 1\\n                rcount2[s2[len(s1) - 1 - i]] += 1\\n                if lcount1 == lcount2:  # Left sides of both strings have same letters\\n                    if self.isScramble(s1[:i + 1], s2[:i + 1]) and \\\\\\n                       self.isScramble(s1[i + 1:], s2[i + 1:]):\\n                        return True\\n                elif lcount1 == rcount2: # Left side of s1 has same letters as right side of s2\\n                    if self.isScramble(s1[:i + 1], s2[-(i + 1):]) and \\\\\\n                       self.isScramble(s1[i + 1:], s2[:-(i + 1)]):\\n                        return True\\n            return False",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "    class Solution(object):\\n        def isScramble(self, s1, s2):\\n            \"\"\"\\n            :type s1: str\\n            :type s2: str\\n            :rtype: bool\\n            \"\"\"\\n            if s1 == s2:\\n                return True\\n            if len(s1) != len(s2):\\n                return False\\n                \\n            # Check both strings have same count of letters\\n            count1 = collections.defaultdict(int)\\n            count2 = collections.defaultdict(int)\\n            for c1, c2 in zip(s1, s2):\\n                count1[c1] += 1\\n                count2[c2] += 1\\n            if count1 != count2: return False\\n            \\n            # Iterate through letters and check if it results in a partition of \\n            # string 1 where the collection of letters are the same\\n            # on the left (non-swapped) or right (swapped) sides of string 2\\n            # Then we recursively check these partitioned strings to see if they are scrambled\\n            lcount1 = collections.defaultdict(int) # s1 count from left\\n            lcount2 = collections.defaultdict(int) # s2 count from left\\n            rcount2 = collections.defaultdict(int) # s2 count from right\\n            for i in xrange(len(s1) - 1):\\n                lcount1[s1[i]] += 1          \\n                lcount2[s2[i]] += 1\\n                rcount2[s2[len(s1) - 1 - i]] += 1\\n                if lcount1 == lcount2:  # Left sides of both strings have same letters\\n                    if self.isScramble(s1[:i + 1], s2[:i + 1]) and \\\\\\n                       self.isScramble(s1[i + 1:], s2[i + 1:]):\\n                        return True\\n                elif lcount1 == rcount2: # Left side of s1 has same letters as right side of s2\\n                    if self.isScramble(s1[:i + 1], s2[-(i + 1):]) and \\\\\\n                       self.isScramble(s1[i + 1:], s2[:-(i + 1)]):\\n                        return True\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 3826197,
                "title": "c-top-down-solution-with-memoization-3ms-beats-99",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince there is no official Top-down solution, this is meant to serve as a simple approach with recursion. \\n\\nThe dfs function come with three parameters. Idx1 and Idx2 represent the indices that the substring is starting from string s1 and s2 with len. If length is 1, we check if the characters match.\\n\\nWe do a simple trim before the search to check if the two substring has the same freqency of unique characters. Then we split the string into substrings with length 1 to len-1, s1 = x1 + y1, s2 = x2 + y2 for each state, we consider two cases:\\n\\n1. (x1,x2) and (y1, y2)\\n2. (x1, y2) and (x2, y1)\\n\\nIf either of them is scramble, we return true.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^4)\\n\\n- Space complexity:\\nO(n^3)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        const int sz = s1.size();\\n        int8_t memo[sz][sz][sz+1];\\n        memset(memo,-1,sizeof(memo));\\n\\n        function<bool(int,int,int)>dfs= [&](int idx1, int idx2, int len)->bool{\\n            if(memo[idx1][idx2][len]!=-1)return (memo[idx1][idx2][len]==1);\\n            \\n            if(len==1&&s1[idx1]==s2[idx2])return true;\\n            \\n            int count[26];\\n            memset(count,0,sizeof(count));\\n\\n            for(int i = 0;i<len;i++){\\n                count[s1[idx1+i]-\\'a\\']++;\\n                count[s2[idx2+i]-\\'a\\']--;\\n            }\\n            for(int i = 0;i<26;i++){\\n                if(count[i]!=0){\\n                    memo[idx1][idx2][len] = 0;\\n                    return false;\\n                }\\n            }\\n\\n            for(int i = 1;i<len;i++){\\n                if ((dfs(idx1, idx2, i) && dfs(idx1 + i, idx2 + i, len - i)) ||\\n                    (dfs(idx1, idx2 + len - i, i) && dfs(idx1 + i, idx2, len - i))) {\\n                    \\n                    memo[idx1][idx2][len] = 1;\\n                    return true;\\n                }\\n            }\\n\\n            memo[idx1][idx2][len] = 0;\\n            return false;\\n        };\\n\\n        return dfs(0,0,sz);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        const int sz = s1.size();\\n        int8_t memo[sz][sz][sz+1];\\n        memset(memo,-1,sizeof(memo));\\n\\n        function<bool(int,int,int)>dfs= [&](int idx1, int idx2, int len)->bool{\\n            if(memo[idx1][idx2][len]!=-1)return (memo[idx1][idx2][len]==1);\\n            \\n            if(len==1&&s1[idx1]==s2[idx2])return true;\\n            \\n            int count[26];\\n            memset(count,0,sizeof(count));\\n\\n            for(int i = 0;i<len;i++){\\n                count[s1[idx1+i]-\\'a\\']++;\\n                count[s2[idx2+i]-\\'a\\']--;\\n            }\\n            for(int i = 0;i<26;i++){\\n                if(count[i]!=0){\\n                    memo[idx1][idx2][len] = 0;\\n                    return false;\\n                }\\n            }\\n\\n            for(int i = 1;i<len;i++){\\n                if ((dfs(idx1, idx2, i) && dfs(idx1 + i, idx2 + i, len - i)) ||\\n                    (dfs(idx1, idx2 + len - i, i) && dfs(idx1 + i, idx2, len - i))) {\\n                    \\n                    memo[idx1][idx2][len] = 1;\\n                    return true;\\n                }\\n            }\\n\\n            memo[idx1][idx2][len] = 0;\\n            return false;\\n        };\\n\\n        return dfs(0,0,sz);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358755,
                "title": "brute-force-optimsed-both-explained-well",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbrute force\\nin this brute force i am trying to generate all possible scramble string of s1 and checking whether s2 is a part of it\\nthis will give tle\\n\\nin the second solution first we will recursively finding whether \\ns1 and s2 are sramble strings of each other\\nthe base given in the question is that 2 equal characters are scramble strings of each other\\nwe can extend this logic to that 2 equal strings are scramble strings of each \\nnow understand each state of the recursive function that i am using\\ndp[i][j][k] or say rec(s1,s2,k,i,j)\\nit means whether s1[i..k] and s2[j..k] are scramble strings of each other\\n\\nnow comes the recurrence part \\nlet us partition 2 string after kth character whre k range[1,len)\\n\\nfor the current 2 strings to be scramble strings of each other \\ns1[i..k] and s2[j..k] should be scramble string of each other and\\ns1[i+k..len] and s2[j+k.len] should be scramble string ofg each other \\nthis is case one in which after partition we are not swapping to check for scramble string\\n\\n\\n\\ncase2 is that when we swap for after partition  to check for scramble string\\nin that case the first part of s1 wil be scramble string wth lastpart of s2\\nand vice versa\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nint brute force \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n1.\\n```\\n\\nclass Solution {\\npublic:\\n\\n\\n\\n\\n\\n\\n    vector<string> help(string& s1,int i,int j,    map<string,vector<string>>&dp){\\n\\n        //understand each state of  this recursive function\\n        vector<string>th;\\n\\n        string curr=to_string(i)+\"#\"+to_string(j);\\n        if(i>j){\\n            return th;\\n            \\n        }\\n        if(i==j){\\n            th.push_back(s1.substr(i,1));\\n            return dp[curr]=th;\\n        }\\n        if(dp.find(curr)!=dp.end()){\\n            return dp[curr];\\n        }\\n\\n        //now recurrence in the current recursive call\\n\\n        for(int a=i;a<j;a++){\\n            //we are trying to partition after a-1th character in the current recursive call\\n            auto t1=help(s1,i,a,dp);\\n            auto t2=help(s1,a+1,j,dp);\\n            //include that cases in which t1 and t2 are swapped \\n            for(auto e:t1){\\n                for(auto f:t2){\\n                    th.push_back(e+f);\\n                    th.push_back(f+e);\\n                }\\n            }\\n            \\n        }\\n        return dp[curr]=th;\\n        //returning the answer for the use to the upper recursive call\\n    }\\n    bool isScramble(string s1, string s2) {\\n        //first we will be starting with a brute force approach\\n\\n\\n        map<string,int>mp;\\n        //this map will contain all possible scramble strings that we can generate from s1\\n        //finaally wed will search s2 is a part of it or not\\n        map<string,vector<string>>dp;\\n        auto t=help(s1,0 ,s1.size()-1,dp);\\n        for(auto e:t){\\n            mp[e]++;\\n\\n        }\\n        return mp.find(s2)!=mp.end();\\n        \\n \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int dp[32][32][32];\\n    int  help(string& s1,string&s2,int len,int s1s,int s2s){\\n\\n        //understand each of the recursive state of this function\\n        //what is the base case \\n        //we just need to check \\n        if(s1.substr(s1s,len)==s2.substr(s2s,len)){\\n            return 1;\\n        }\\n\\n        if(dp[s1s][s2s][len]!=-1){\\n            return dp[s1s][s2s][len];\\n\\n        }\\n\\n\\n\\n        //trying all partitions in the current recursive call\\n        int curr=0;\\n\\n        for(int k=1;k<len;k++){\\n            //in each iteration we will breaking after the kth char \\n            int c1=help(s1,s2,k,s1s,s2s);\\n            int c2=help(s1,s2,len-k,s1s+k,s2s+k);\\n            int c3=help(s1,s2,k,s1s,s2s+len-k);\\n            int c4=help(s1,s2,len-k,s1s+k,s2s);\\n\\n            if((c1 && c2)||(c3 && c4)){\\n                curr=1;\\n                break;\\n            }\\n        }\\n        return dp[s1s][s2s][len]=curr;\\n\\n    }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp,-1,sizeof(dp));\\n\\n\\n        //here we need to follow dynamic programming instead of generating all possible scramble strings of s1\\n        //we just need to check not generate\\n\\n        int t=help(s1,s2,s1.size(),0,0);\\n        return t==1?true:false;\\n\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n\\n\\n\\n\\n\\n    vector<string> help(string& s1,int i,int j,    map<string,vector<string>>&dp){\\n\\n        //understand each state of  this recursive function\\n        vector<string>th;\\n\\n        string curr=to_string(i)+\"#\"+to_string(j);\\n        if(i>j){\\n            return th;\\n            \\n        }\\n        if(i==j){\\n            th.push_back(s1.substr(i,1));\\n            return dp[curr]=th;\\n        }\\n        if(dp.find(curr)!=dp.end()){\\n            return dp[curr];\\n        }\\n\\n        //now recurrence in the current recursive call\\n\\n        for(int a=i;a<j;a++){\\n            //we are trying to partition after a-1th character in the current recursive call\\n            auto t1=help(s1,i,a,dp);\\n            auto t2=help(s1,a+1,j,dp);\\n            //include that cases in which t1 and t2 are swapped \\n            for(auto e:t1){\\n                for(auto f:t2){\\n                    th.push_back(e+f);\\n                    th.push_back(f+e);\\n                }\\n            }\\n            \\n        }\\n        return dp[curr]=th;\\n        //returning the answer for the use to the upper recursive call\\n    }\\n    bool isScramble(string s1, string s2) {\\n        //first we will be starting with a brute force approach\\n\\n\\n        map<string,int>mp;\\n        //this map will contain all possible scramble strings that we can generate from s1\\n        //finaally wed will search s2 is a part of it or not\\n        map<string,vector<string>>dp;\\n        auto t=help(s1,0 ,s1.size()-1,dp);\\n        for(auto e:t){\\n            mp[e]++;\\n\\n        }\\n        return mp.find(s2)!=mp.end();\\n        \\n \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int dp[32][32][32];\\n    int  help(string& s1,string&s2,int len,int s1s,int s2s){\\n\\n        //understand each of the recursive state of this function\\n        //what is the base case \\n        //we just need to check \\n        if(s1.substr(s1s,len)==s2.substr(s2s,len)){\\n            return 1;\\n        }\\n\\n        if(dp[s1s][s2s][len]!=-1){\\n            return dp[s1s][s2s][len];\\n\\n        }\\n\\n\\n\\n        //trying all partitions in the current recursive call\\n        int curr=0;\\n\\n        for(int k=1;k<len;k++){\\n            //in each iteration we will breaking after the kth char \\n            int c1=help(s1,s2,k,s1s,s2s);\\n            int c2=help(s1,s2,len-k,s1s+k,s2s+k);\\n            int c3=help(s1,s2,k,s1s,s2s+len-k);\\n            int c4=help(s1,s2,len-k,s1s+k,s2s);\\n\\n            if((c1 && c2)||(c3 && c4)){\\n                curr=1;\\n                break;\\n            }\\n        }\\n        return dp[s1s][s2s][len]=curr;\\n\\n    }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp,-1,sizeof(dp));\\n\\n\\n        //here we need to follow dynamic programming instead of generating all possible scramble strings of s1\\n        //we just need to check not generate\\n\\n        int t=help(s1,s2,s1.size(),0,0);\\n        return t==1?true:false;\\n\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358626,
                "title": "simple-recursive-solution-3d-array-solution-with-detailed-comments",
                "content": "## Simpler, recursive solution (cache + pruning)\\n```\\n// helper function that checks if the two strings have the same characters\\nconst hasSameChars = (word1, word2) => {\\n  // If the two words have different lengths, they can\\'t have the same characters\\n  if (word1.length !== word2.length) return false;\\n\\n  // Create an object to keep track of the count of each character in the two words\\n  const charCount = {};\\n\\n  // Loop through each character in the two words and update the character count\\n  for (let i = 0; i < word1.length; i++) {\\n    const char1 = word1[i];\\n    const char2 = word2[i];\\n    charCount[char1] = char1 in charCount ? charCount[char1] + 1 : 1;\\n    charCount[char2] = char2 in charCount ? charCount[char2] - 1 : -1;\\n  }\\n\\n  // If any character count is not zero, the two words don\\'t have the same characters\\n  for (const char in charCount) {\\n    if (charCount[char] !== 0) return false;\\n  }\\n\\n  return true;\\n};\\n\\nvar isScramble = function (s1, s2, memo = {}) {\\n  // Create a key for the memoization object\\n  const key = `${s1}-${s2}`;\\n\\n  // If the result for this key has already been calculated, return it\\n  if (key in memo) return memo[key];\\n\\n  // If the two strings are equal, s1 can be scrambled to get s2\\n  if (s1 === s2) return true;\\n\\n  // If the two strings don\\'t have the same characters, s1 can\\'t be scrambled to get s2\\n  if (!hasSameChars(s1, s2)) {\\n    memo[key] = false;\\n    return false;\\n  }\\n\\n  // Try all possible splits of s1 and s2 and recursively check if the resulting substrings can be scrambled\\n  const length = s1.length;\\n\\n  for (let i = 1; i < length; i++) {\\n    if (\\n      (isScramble(s1.slice(0, i), s2.slice(0, i), memo) &&\\n        isScramble(s1.slice(i), s2.slice(i), memo)) ||\\n      (isScramble(s1.slice(0, i), s2.slice(length - i), memo) &&\\n        isScramble(s1.slice(i), s2.slice(0, length - i), memo))\\n    ) {\\n      memo[key] = true;\\n      return true;\\n    }\\n  }\\n\\n  // If none of the splits worked, s1 can\\'t be scrambled to get s2\\n  memo[key] = false;\\n  return false;\\n};\\n```\\nThe time complexity of this solution is not optimal, and it\\'s possible to solve this problem more efficiently using dynamic programming. The basic idea is to use a 3D array to store the intermediate results of the recursive calls, so that we can avoid repeating the same computation multiple times.\\n\\n## Dynamic Programming Solution\\n```\\nvar isScramble = function (s1, s2) {\\n  const totalLength = s1.length;\\n\\n  // Initialize a 3D array to store the intermediate results\\n  const canScramble = new Array(totalLength + 1)\\n    .fill(null)\\n    .map(() =>\\n      new Array(totalLength)\\n        .fill(null)\\n        .map(() => new Array(totalLength).fill(false))\\n    );\\n\\n  // Initialize the base case where the two strings have length 1\\n  for (let i = 0; i < totalLength; i++) {\\n    for (let j = 0; j < totalLength; j++) {\\n      canScramble[1][i][j] = s1[i] === s2[j];\\n    }\\n  }\\n\\n  // Solve the subproblems in a bottom-up manner\\n  for (let len = 2; len <= totalLength; len++) {\\n    for (let i = 0; i <= totalLength - len; i++) {\\n      for (let j = 0; j <= totalLength - len; j++) {\\n        for (let k = 1; k < len; k++) {\\n          // Partition s1[0,len] into two parts: s1[0,k] and s1[k,len]\\n          // Check if s1[0,k] can be scrambled to get s2[0,k]\\n          const canScrambleLeft = canScramble[k][i][j];\\n          // Check if s1[k,n] can be scrambled to get s2[k,n]\\n          const canScrambleRight = canScramble[len - k][i + k][j + k];\\n          // Check if s1[0,k] can be scrambled to get s2[len-k,n]\\n          const canScrambleLeftReverse = canScramble[k][i][j + len - k];\\n          // Check if s1[k,n] can be scrambled to get s2[0,len-k]\\n          const canScrambleRightReverse = canScramble[len - k][i + k][j];\\n\\n          // Check if s1[0,k] can be scrambled to get s2[0,k] and s1[k,n] can be scrambled to get s2[k,n]\\n          // OR if s1[0,k] can be scrambled to get s2[len-k,n] and s1[k,n] can be scrambled to get s2[0,len-k]\\n          if (\\n            (canScrambleLeft && canScrambleRight) ||\\n            (canScrambleLeftReverse && canScrambleRightReverse)\\n          ) {\\n            // If either case is true, s1[0,len] can be scrambled to get s2[0,len]\\n            canScramble[len][i][j] = true;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  // The answer is stored in canScramble[n][0][0]\\n  return canScramble[totalLength][0][0];\\n};\\n```\\nThis solution uses a dynamic programming approach to solve the problem of determining whether one string can be scrambled into another. The idea behind dynamic programming is to solve a problem by breaking it down into smaller subproblems and storing the results of these subproblems in memory so that we can avoid recalculating them.\\n\\nTo solve this problem, we create a 3D boolean array called canScramble to store intermediate results. canScramble[k][i][j] represents whether the substring of s1 starting at index i and of length k can be scrambled into the substring of s2 starting at index j and of length k.\\n\\nThe base case for our dynamic programming approach is when both strings have length 1. In this case, we simply compare the two characters at the same index in both strings and store the result.\\n\\nNext, we solve the subproblems in a bottom-up manner. We start by looking at substrings of length 2, then length 3, and so on, until we reach the length of the entire string. For each substring of length len, we consider all possible ways to split the substring into two parts, with lengths k and len - k. We then check if the two parts of s1 can be scrambled into the corresponding parts of s2. We do this by checking the following conditions:\\n\\n1) The first part of s1 can be scrambled into the first part of s2 and the second part of s1 can be scrambled into the second part of s2.\\n2) The first part of s1 can be scrambled into the second part of s2 and the second part of s1 can be scrambled into the first part of s2.\\n\\nIf any of these conditions is true, then we can scramble the substring of s1 into the substring of s2. We store the result in canScramble[len][i][j].\\n\\nFinally, we return the value of canScramble[n][0][0], which represents whether the entire s1 can be scrambled into s2.\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n// helper function that checks if the two strings have the same characters\\nconst hasSameChars = (word1, word2) => {\\n  // If the two words have different lengths, they can\\'t have the same characters\\n  if (word1.length !== word2.length) return false;\\n\\n  // Create an object to keep track of the count of each character in the two words\\n  const charCount = {};\\n\\n  // Loop through each character in the two words and update the character count\\n  for (let i = 0; i < word1.length; i++) {\\n    const char1 = word1[i];\\n    const char2 = word2[i];\\n    charCount[char1] = char1 in charCount ? charCount[char1] + 1 : 1;\\n    charCount[char2] = char2 in charCount ? charCount[char2] - 1 : -1;\\n  }\\n\\n  // If any character count is not zero, the two words don\\'t have the same characters\\n  for (const char in charCount) {\\n    if (charCount[char] !== 0) return false;\\n  }\\n\\n  return true;\\n};\\n\\nvar isScramble = function (s1, s2, memo = {}) {\\n  // Create a key for the memoization object\\n  const key = `${s1}-${s2}`;\\n\\n  // If the result for this key has already been calculated, return it\\n  if (key in memo) return memo[key];\\n\\n  // If the two strings are equal, s1 can be scrambled to get s2\\n  if (s1 === s2) return true;\\n\\n  // If the two strings don\\'t have the same characters, s1 can\\'t be scrambled to get s2\\n  if (!hasSameChars(s1, s2)) {\\n    memo[key] = false;\\n    return false;\\n  }\\n\\n  // Try all possible splits of s1 and s2 and recursively check if the resulting substrings can be scrambled\\n  const length = s1.length;\\n\\n  for (let i = 1; i < length; i++) {\\n    if (\\n      (isScramble(s1.slice(0, i), s2.slice(0, i), memo) &&\\n        isScramble(s1.slice(i), s2.slice(i), memo)) ||\\n      (isScramble(s1.slice(0, i), s2.slice(length - i), memo) &&\\n        isScramble(s1.slice(i), s2.slice(0, length - i), memo))\\n    ) {\\n      memo[key] = true;\\n      return true;\\n    }\\n  }\\n\\n  // If none of the splits worked, s1 can\\'t be scrambled to get s2\\n  memo[key] = false;\\n  return false;\\n};\\n```\n```\\nvar isScramble = function (s1, s2) {\\n  const totalLength = s1.length;\\n\\n  // Initialize a 3D array to store the intermediate results\\n  const canScramble = new Array(totalLength + 1)\\n    .fill(null)\\n    .map(() =>\\n      new Array(totalLength)\\n        .fill(null)\\n        .map(() => new Array(totalLength).fill(false))\\n    );\\n\\n  // Initialize the base case where the two strings have length 1\\n  for (let i = 0; i < totalLength; i++) {\\n    for (let j = 0; j < totalLength; j++) {\\n      canScramble[1][i][j] = s1[i] === s2[j];\\n    }\\n  }\\n\\n  // Solve the subproblems in a bottom-up manner\\n  for (let len = 2; len <= totalLength; len++) {\\n    for (let i = 0; i <= totalLength - len; i++) {\\n      for (let j = 0; j <= totalLength - len; j++) {\\n        for (let k = 1; k < len; k++) {\\n          // Partition s1[0,len] into two parts: s1[0,k] and s1[k,len]\\n          // Check if s1[0,k] can be scrambled to get s2[0,k]\\n          const canScrambleLeft = canScramble[k][i][j];\\n          // Check if s1[k,n] can be scrambled to get s2[k,n]\\n          const canScrambleRight = canScramble[len - k][i + k][j + k];\\n          // Check if s1[0,k] can be scrambled to get s2[len-k,n]\\n          const canScrambleLeftReverse = canScramble[k][i][j + len - k];\\n          // Check if s1[k,n] can be scrambled to get s2[0,len-k]\\n          const canScrambleRightReverse = canScramble[len - k][i + k][j];\\n\\n          // Check if s1[0,k] can be scrambled to get s2[0,k] and s1[k,n] can be scrambled to get s2[k,n]\\n          // OR if s1[0,k] can be scrambled to get s2[len-k,n] and s1[k,n] can be scrambled to get s2[0,len-k]\\n          if (\\n            (canScrambleLeft && canScrambleRight) ||\\n            (canScrambleLeftReverse && canScrambleRightReverse)\\n          ) {\\n            // If either case is true, s1[0,len] can be scrambled to get s2[0,len]\\n            canScramble[len][i][j] = true;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  // The answer is stored in canScramble[n][0][0]\\n  return canScramble[totalLength][0][0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3107720,
                "title": "c-easy-solution-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool f(string s1,string s2){\\n        int n=s1.length();\\n        if(s1.size()==1) return s1==s2;\\n        if(s1==s2) return true;\\n        string k=s1+s2;\\n        if(mp.find(k)!=mp.end()) return mp[k];\\n        for(int i=1;i<n;i++){\\n            if((f(s1.substr(0,i),s2.substr(0,i)) && f(s1.substr(i),s2.substr(i))) or (f(s1.substr(0,i),s2.substr(n-i)) && f(s1.substr(i),s2.substr(0,n-i))))\\n            return mp[k]=true;\\n        }\\n        return mp[k]=false;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        return f(s1,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool f(string s1,string s2){\\n        int n=s1.length();\\n        if(s1.size()==1) return s1==s2;\\n        if(s1==s2) return true;\\n        string k=s1+s2;\\n        if(mp.find(k)!=mp.end()) return mp[k];\\n        for(int i=1;i<n;i++){\\n            if((f(s1.substr(0,i),s2.substr(0,i)) && f(s1.substr(i),s2.substr(i))) or (f(s1.substr(0,i),s2.substr(n-i)) && f(s1.substr(i),s2.substr(0,n-i))))\\n            return mp[k]=true;\\n        }\\n        return mp[k]=false;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        return f(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325841,
                "title": "java-mcm-aditya-verma-recursion-memoization",
                "content": "```\\n\\nclass Solution {\\n    Map<String, Boolean> map = new HashMap<>();\\n\\t\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length() != s2.length()) return false;\\n        return solve(s1, s2);   \\n    }\\n    \\n    private boolean solve(String a, String b) {\\n        if(a.equals(b)) return true;\\n        if(a.length() <= 1) return false;\\n        \\n        String key = a + \"_\" + b;\\n        if(map.containsKey(key)) return map.get(key);\\n\\n        int n = a.length();\\n        \\n        boolean flag = false;\\n        for(int i=1; i<n; i++) {\\n            boolean noswap = solve(a.substring(0,i), b.substring(0,i)) &&\\n                             solve(a.substring(i), b.substring(i));\\n            \\n            boolean swap = solve(a.substring(0,i), b.substring(n-i)) &&\\n                           solve(a.substring(i), b.substring(0,n-i));\\n            if(swap || noswap){\\n                flag = true;\\n                break;\\n            }\\n        }\\n        map.put(key, flag);\\n        return flag;    \\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    Map<String, Boolean> map = new HashMap<>();\\n\\t\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length() != s2.length()) return false;\\n        return solve(s1, s2);   \\n    }\\n    \\n    private boolean solve(String a, String b) {\\n        if(a.equals(b)) return true;\\n        if(a.length() <= 1) return false;\\n        \\n        String key = a + \"_\" + b;\\n        if(map.containsKey(key)) return map.get(key);\\n\\n        int n = a.length();\\n        \\n        boolean flag = false;\\n        for(int i=1; i<n; i++) {\\n            boolean noswap = solve(a.substring(0,i), b.substring(0,i)) &&\\n                             solve(a.substring(i), b.substring(i));\\n            \\n            boolean swap = solve(a.substring(0,i), b.substring(n-i)) &&\\n                           solve(a.substring(i), b.substring(0,n-i));\\n            if(swap || noswap){\\n                flag = true;\\n                break;\\n            }\\n        }\\n        map.put(key, flag);\\n        return flag;    \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670707,
                "title": "12-ms-c-faster-solution",
                "content": "* **Idea?**\\n1.  For current string s1 and s2,**we can divide the string at any position**.\\n2.  Traverse each position and find the left and right substrings.\\n3.  Check out all combinations we can have accroding to the problem statement.\\n4.  Also, to speed up the runtime, we can use **dynamic programming** since we are visiting same states again and again.\\n5.  Also, we would be checking the** condition to anagram to pair up any two substrings**.\\n6.  Check code for better understanding.\\n\\n```\\nclass Solution {\\npublic:\\n    map<pair<string,string>,bool> dp;\\n    bool ok(string s1,string s2){ //  to check anagram\\n        vector<int> dp(26);\\n        for(auto& c:s1)\\n            dp[c-\\'a\\']++;\\n        for(auto& c:s2)\\n            dp[c-\\'a\\']--;\\n        for(auto& c:dp){\\n            if(c!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // dynamic programming with memoization\\n    bool solve(string s1,string s2){\\n        int n = s1.length();\\n        if(n==1)\\n            return dp[{s1,s2}] = s1==s2;\\n        if(dp.count({s1,s2}))\\n            return dp[{s1,s2}];\\n        for(int i=0;i<n-1;i++){\\n            string f1 = s1.substr(0,i+1);\\n            string f2 = s1.substr(i+1);\\n            string f3 = s2.substr(0,i+1);\\n            string f4 = s2.substr(i+1);\\n            string f5 = s2.substr(n-i-1);\\n            string f6 = s2.substr(0,n-i-1);\\n            if(ok(f1,f3) and ok(f2,f4) and solve(f1,f3) and solve(f2,f4))\\n                return true;\\n            if(ok(f1,f5) and ok(f2,f6) and solve(f1,f5) and solve(f2,f6))\\n                return true;\\n        }\\n        return dp[{s1,s2}] = false;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        return solve(s1,s2);\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<string,string>,bool> dp;\\n    bool ok(string s1,string s2){ //  to check anagram\\n        vector<int> dp(26);\\n        for(auto& c:s1)\\n            dp[c-\\'a\\']++;\\n        for(auto& c:s2)\\n            dp[c-\\'a\\']--;\\n        for(auto& c:dp){\\n            if(c!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // dynamic programming with memoization\\n    bool solve(string s1,string s2){\\n        int n = s1.length();\\n        if(n==1)\\n            return dp[{s1,s2}] = s1==s2;\\n        if(dp.count({s1,s2}))\\n            return dp[{s1,s2}];\\n        for(int i=0;i<n-1;i++){\\n            string f1 = s1.substr(0,i+1);\\n            string f2 = s1.substr(i+1);\\n            string f3 = s2.substr(0,i+1);\\n            string f4 = s2.substr(i+1);\\n            string f5 = s2.substr(n-i-1);\\n            string f6 = s2.substr(0,n-i-1);\\n            if(ok(f1,f3) and ok(f2,f4) and solve(f1,f3) and solve(f2,f4))\\n                return true;\\n            if(ok(f1,f5) and ok(f2,f6) and solve(f1,f5) and solve(f2,f6))\\n                return true;\\n        }\\n        return dp[{s1,s2}] = false;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        return solve(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359204,
                "title": "dp-solution-aditya-verma",
                "content": "```\\nclass Solution {\\n     static HashMap<String,Boolean> map=new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        \\n        return solve(s1,s2);\\n    }\\n    public static boolean solve(String a,String b)\\n    {\\n        if(a.equals(b))\\n        {\\n            return true;\\n        }\\n             \\n        String key=a+\"_\"+b;\\n        if(map.containsKey(key))\\n        {\\n            return map.get(key);\\n        }\\n        boolean flag=false;\\n        int n=a.length();\\n        for(int i=1;i<n;i++)\\n        {\\n             boolean noswap=(solve(a.substring(0, i),b.substring(n - i,n)) && solve(a.substring(i, n),b.substring(0, n-i)));\\n         \\n            boolean swap=(solve(a.substring(0, i),b.substring(0, i))  && solve(a.substring(i, n),b.substring(i, n)));\\n            \\n            if(noswap||swap)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        map.put(a+\"_\"+b,flag);\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n     static HashMap<String,Boolean> map=new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        \\n        return solve(s1,s2);\\n    }\\n    public static boolean solve(String a,String b)\\n    {\\n        if(a.equals(b))\\n        {\\n            return true;\\n        }\\n             \\n        String key=a+\"_\"+b;\\n        if(map.containsKey(key))\\n        {\\n            return map.get(key);\\n        }\\n        boolean flag=false;\\n        int n=a.length();\\n        for(int i=1;i<n;i++)\\n        {\\n             boolean noswap=(solve(a.substring(0, i),b.substring(n - i,n)) && solve(a.substring(i, n),b.substring(0, n-i)));\\n         \\n            boolean swap=(solve(a.substring(0, i),b.substring(0, i))  && solve(a.substring(i, n),b.substring(i, n)));\\n            \\n            if(noswap||swap)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        map.put(a+\"_\"+b,flag);\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272195,
                "title": "java-standard-solution",
                "content": "```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.equals(s2))\\n            return true;\\n        if(s1.length() != s2.length())\\n            return false;\\n        \\n        return solve(s1,s2);\\n    }\\n    Map<String,Boolean> map = new HashMap<>();\\n    boolean solve(String a,String b)\\n    {\\n        if(a.equals(b))\\n            return true;\\n        if(a.length() !=b.length())\\n            return false;\\n        String key = a+\"*\"+b;\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        \\n        int n = a.length();\\n        for(int i=1;i<n;i++)\\n        {\\n            if( (solve(a.substring(0,i),b.substring(n-i)) && solve(a.substring(i),b.substring(0,n-i))) ||\\n             (solve(a.substring(0,i),b.substring(0,i)) && solve(a.substring(i),b.substring(i))) )\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.equals(s2))\\n            return true;\\n        if(s1.length() != s2.length())\\n            return false;\\n        \\n        return solve(s1,s2);\\n    }\\n    Map<String,Boolean> map = new HashMap<>();\\n    boolean solve(String a,String b)\\n    {\\n        if(a.equals(b))\\n            return true;\\n        if(a.length() !=b.length())\\n            return false;\\n        String key = a+\"*\"+b;\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        \\n        int n = a.length();\\n        for(int i=1;i<n;i++)\\n        {\\n            if( (solve(a.substring(0,i),b.substring(n-i)) && solve(a.substring(i),b.substring(0,n-i))) ||\\n             (solve(a.substring(0,i),b.substring(0,i)) && solve(a.substring(i),b.substring(i))) )\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261625,
                "title": "c-16-ms-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,bool> mp;\\n    \\n    bool check(string a, string b){\\n        string key = a + \" \" + b;\\n        if (mp.find(key) != mp.end()) return mp[key];\\n        if(a==b) return mp[key]=true;\\n        if(a.length()<=1 || b.length()<=1) return mp[key]=false;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0; i<a.length(); i++){\\n            sum1=sum1+int(a[i]);\\n        }\\n        for(int i=0; i<b.length(); i++){\\n            sum2=sum2+int(b[i]);\\n        }\\n        if(sum1!=sum2) return mp[key]=false;\\n        \\n        int n=a.length();\\n        for(int i=1; i< a.length(); i++){\\n            if( check(a.substr(0,i),b.substr(0,i)) && check(a.substr(i,n-i),b.substr(i,n-i)) ){\\n                 return true;\\n                 break;\\n             }\\n            if( check(a.substr(0,i),b.substr(n-i,i)) && check(a.substr(i,n-i),b.substr(0,n-i))) {\\n                 return true;\\n                 break;\\n             }\\n        }\\n        return mp[key]=false;\\n        \\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1.length()!=s2.length()) return false;        \\n        return check(s1,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,bool> mp;\\n    \\n    bool check(string a, string b){\\n        string key = a + \" \" + b;\\n        if (mp.find(key) != mp.end()) return mp[key];\\n        if(a==b) return mp[key]=true;\\n        if(a.length()<=1 || b.length()<=1) return mp[key]=false;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0; i<a.length(); i++){\\n            sum1=sum1+int(a[i]);\\n        }\\n        for(int i=0; i<b.length(); i++){\\n            sum2=sum2+int(b[i]);\\n        }\\n        if(sum1!=sum2) return mp[key]=false;\\n        \\n        int n=a.length();\\n        for(int i=1; i< a.length(); i++){\\n            if( check(a.substr(0,i),b.substr(0,i)) && check(a.substr(i,n-i),b.substr(i,n-i)) ){\\n                 return true;\\n                 break;\\n             }\\n            if( check(a.substr(0,i),b.substr(n-i,i)) && check(a.substr(i,n-i),b.substr(0,n-i))) {\\n                 return true;\\n                 break;\\n             }\\n        }\\n        return mp[key]=false;\\n        \\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1.length()!=s2.length()) return false;        \\n        return check(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114466,
                "title": "c-dp-with-memoization",
                "content": "```\\n    /*\\n     * Recursive Approach or TopDown Approach\\n     *\\n     * There are n-1 ways to split the string into 2 parts L, R where L is the length of s1\\n     * For Eg:\\n     *   s1 = \"XY\"   s2 = \"YX\"\\n     *   \\n     * Partition s1 at 1\\n     *            XY\\n     *             |\\n     *          ---------\\n     *         |         |\\n     *         X         Y\\n     * 2 ways to merge the stirng\\n     *       . without swaping - XY\\n     *       . with swapping - YX\\n     *  It is seen from above that s1 and s2 are scrambled.\\n     *\\n     * Pseudo Code:\\n     * Partition the strings(s1, s2) into 2 parts to form x and y\\n     *        s1(0...j), s1(j+1...n)\\n     *        s2(0...j), s2(j+1...n)   where j = 1.. n-1\\n     *\\n     *  Both the stirng are scramble only if \\n     *        s1(0..j) & s2(0..j) are equal and s1(j+1...n) & s2(j+1...n) are equal\\n     *                               or (swap is allowed)\\n     *        s1(0..j) & s2(j+1...n) are equal and s1(j+1...n) & s2(0...j) are equal\\n     *\\n     * As there are many duplicate subproblems, implementing dynamic programming with\\n     * memorization\\n    */\\n    // DP table to store the result of subproblems ie.., whether the subproblems\\n    // s2 is scramble string of s1 or not.\\n    std::unordered_map<string, bool> dp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        if (s1.length() != s2.length()) {\\n            // Both are different sizes, then s2 can\\'t be scramble of s1\\n            return false;\\n        }\\n        // Check if both the strings are equal\\n        if (s1 == s2) {\\n            // Both strings are equal i.e.., s2 is a scramble stirng of s1\\n            return true;\\n        }\\n        // Initializing the key key with s1 and s2 with * as differentiator\\n        string key = s1 + \"*\" + s2;\\n        // Check if the subproblem is already evaluated\\n        if (dp.count(key) == 1) {\\n            // Subproblem is already evaluated\\n            return dp[key];\\n        }\\n\\n        int n = s1.length();\\n        int res = false;\\n        \\n        // Partition the string, As both the strings of equal length\\n        for (int i = 1; i < s1.length(); i++) {\\n            if ( isScramble(s1.substr(0,i), s2.substr(0,i)) && \\n                 isScramble(s1.substr(i, n-i), s2.substr(i, n-i))) {\\n                res = true;\\n                break;\\n            }\\n            if ( isScramble(s1.substr(0,i), s2.substr(n-i, i)) && \\n                 isScramble(s1.substr(i, n-i), s2.substr(0, n-i))) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        \\n        dp[key] = res;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Recursive Approach or TopDown Approach\\n     *\\n     * There are n-1 ways to split the string into 2 parts L, R where L is the length of s1\\n     * For Eg:\\n     *   s1 = \"XY\"   s2 = \"YX\"\\n     *   \\n     * Partition s1 at 1\\n     *            XY\\n     *             |\\n     *          ---------\\n     *         |         |\\n     *         X         Y\\n     * 2 ways to merge the stirng\\n     *       . without swaping - XY\\n     *       . with swapping - YX\\n     *  It is seen from above that s1 and s2 are scrambled.\\n     *\\n     * Pseudo Code:\\n     * Partition the strings(s1, s2) into 2 parts to form x and y\\n     *        s1(0...j), s1(j+1...n)\\n     *        s2(0...j), s2(j+1...n)   where j = 1.. n-1\\n     *\\n     *  Both the stirng are scramble only if \\n     *        s1(0..j) & s2(0..j) are equal and s1(j+1...n) & s2(j+1...n) are equal\\n     *                               or (swap is allowed)\\n     *        s1(0..j) & s2(j+1...n) are equal and s1(j+1...n) & s2(0...j) are equal\\n     *\\n     * As there are many duplicate subproblems, implementing dynamic programming with\\n     * memorization\\n    */\\n    // DP table to store the result of subproblems ie.., whether the subproblems\\n    // s2 is scramble string of s1 or not.\\n    std::unordered_map<string, bool> dp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        if (s1.length() != s2.length()) {\\n            // Both are different sizes, then s2 can\\'t be scramble of s1\\n            return false;\\n        }\\n        // Check if both the strings are equal\\n        if (s1 == s2) {\\n            // Both strings are equal i.e.., s2 is a scramble stirng of s1\\n            return true;\\n        }\\n        // Initializing the key key with s1 and s2 with * as differentiator\\n        string key = s1 + \"*\" + s2;\\n        // Check if the subproblem is already evaluated\\n        if (dp.count(key) == 1) {\\n            // Subproblem is already evaluated\\n            return dp[key];\\n        }\\n\\n        int n = s1.length();\\n        int res = false;\\n        \\n        // Partition the string, As both the strings of equal length\\n        for (int i = 1; i < s1.length(); i++) {\\n            if ( isScramble(s1.substr(0,i), s2.substr(0,i)) && \\n                 isScramble(s1.substr(i, n-i), s2.substr(i, n-i))) {\\n                res = true;\\n                break;\\n            }\\n            if ( isScramble(s1.substr(0,i), s2.substr(n-i, i)) && \\n                 isScramble(s1.substr(i, n-i), s2.substr(0, n-i))) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        \\n        dp[key] = res;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925246,
                "title": "bottom-up-dp-o-n-4-clean-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string a, string b) {\\n        int n = a.length();\\n\\t\\t// dp[i][j][k] = Whether the strings a[i, ..., i+k-1] and b[j, ..., j+k-1] \\n\\t\\t// are scrambled version of each other\\n        bool dp[n][n][n+1];\\n        memset(dp, 0, sizeof(dp));\\n        \\n\\t\\t// Base case: comparing all substrings of size 1 \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) \\n                dp[i][j][1] = a[i] == b[j];\\n        }\\n        \\n        for(int k = 2; k <= n; k++) {\\n            for(int i = 0; i <= (n-k); i++) {\\n                for(int j = 0; j <= (n-k); j++) {\\n                    \\n\\t\\t\\t\\t\\t// Split the strings A = a[i, ... , i + k-1], B = b[j, ..., j + k-1]\\n\\t\\t\\t\\t\\t// into length r and (k-r) length. (say A1, A2 and B1, B2)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// For A and B to be scrambled versions of each other, \\n\\t\\t\\t\\t\\t// either A1 = scrambled(B1) and A2 = scrambled(B2) or\\n\\t\\t\\t\\t\\t// A1 = scrambled(B2) and A2 = scrambled(B1)\\n                    for(int r = 1; r < k; r++) {\\n                        dp[i][j][k] |= (dp[i][j][r] && dp[i+r][j+r][k-r]) || \\n                                       (dp[i][j+k-r][r] && dp[i+r][j][k-r]);\\n                    }\\n                    \\n                }\\n            }    \\n        }\\n        \\n        return dp[0][0][n];\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isScramble(string a, string b) {\\n        int n = a.length();\\n\\t\\t// dp[i][j][k] = Whether the strings a[i, ..., i+k-1] and b[j, ..., j+k-1] \\n\\t\\t// are scrambled version of each other\\n        bool dp[n][n][n+1];\\n        memset(dp, 0, sizeof(dp));\\n        \\n\\t\\t// Base case: comparing all substrings of size 1 \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) \\n                dp[i][j][1] = a[i] == b[j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 832610,
                "title": "java-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\n    Map<Integer, Boolean> cache;\\n    public boolean isScramble(String a, String b) {\\n        if(a.length() != b.length()) return false;\\n        if(a.length() == 0) return false;\\n        cache = new HashMap<>();\\n        return isSR(a, b);\\n    }\\n\\n    private boolean isSR(String a, String b) {\\n        int hash = (a + \"_\" + b).hashCode();\\n        if(cache.get(hash) != null) {\\n            return cache.get(hash);\\n        }\\n        int n = a.length();\\n        if(a.equals(b)) return true;\\n        if(n <= 1) return false;\\n        \\n        boolean isSS = false;\\n        boolean swapped = false;\\n        boolean not_swapped = false;\\n        for(int i = 1; i < n; i++) {\\n            if(isSR(a.substring(0, i), b.substring(n-i, n)) &&\\n                              isSR(a.substring(i, n), b.substring(0, n-i))) {\\n                swapped = true;\\n            } else if(isSR(a.substring(0, i), b.substring(0, i)) && \\n                      isSR(a.substring(i, n), b.substring(i, n))) {\\n                not_swapped = true;\\n            }\\n            if(swapped || not_swapped) {\\n                isSS = true;\\n                break;\\n            }\\n        }\\n        cache.put(hash, isSS);\\n        return isSS;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Boolean> cache;\\n    public boolean isScramble(String a, String b) {\\n        if(a.length() != b.length()) return false;\\n        if(a.length() == 0) return false;\\n        cache = new HashMap<>();\\n        return isSR(a, b);\\n    }\\n\\n    private boolean isSR(String a, String b) {\\n        int hash = (a + \"_\" + b).hashCode();\\n        if(cache.get(hash) != null) {\\n            return cache.get(hash);\\n        }\\n        int n = a.length();\\n        if(a.equals(b)) return true;\\n        if(n <= 1) return false;\\n        \\n        boolean isSS = false;\\n        boolean swapped = false;\\n        boolean not_swapped = false;\\n        for(int i = 1; i < n; i++) {\\n            if(isSR(a.substring(0, i), b.substring(n-i, n)) &&\\n                              isSR(a.substring(i, n), b.substring(0, n-i))) {\\n                swapped = true;\\n            } else if(isSR(a.substring(0, i), b.substring(0, i)) && \\n                      isSR(a.substring(i, n), b.substring(i, n))) {\\n                not_swapped = true;\\n            }\\n            if(swapped || not_swapped) {\\n                isSS = true;\\n                break;\\n            }\\n        }\\n        cache.put(hash, isSS);\\n        return isSS;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316778,
                "title": "c-o-2-n-splitting-solution-very-small-input",
                "content": "Micro explanation is this:\\n\\nFor a given string, s. of length N, we could split the string at any point from 1...N-1\\n\\nThen we would have s1 and s2, which we could re-order to a string b which is either s1s2 or s2s1.\\n\\nLet\\'s try an example, for only 1 level of scrambling depth...:\\n\\ns = hamburger\\nb = burgerham\\n\\nWe have some possible solutions:\\n\\n1.)\\nh amburger\\nWe compare with \\nb|urgerham OR burgerha|m\\n\\n2.)\\nha mburger\\nWe compare with \\nbu|rgerham OR burgerh|am\\n\\n3.)\\nham burger\\nWe compare with \\nbur|gerham OR burger|ham\\n\\nWe see that #3 is a valid scramble since \"ham\" is a scramble of \"ham\" and \"burger\" is a scramble of \"burger\"\\n\\nSo, essentially we recursively check valid sub-scrambles, for being scrambles... \\n\\nScrambles always have the same number of each letter. So this can be a quick heuristic to exit and side-search.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        \\n        if (s1 == s2) { return true; }\\n        if (s1.size() != s2.size()) { return false; }\\n        \\n        string aComp1 = s1;\\n        string aComp2 = s2;\\n        \\n        int aLen = s1.size();\\n        \\n        sort(aComp1.begin(), aComp1.end());\\n        sort(aComp2.begin(), aComp2.end());\\n        if (aComp1 != aComp2) { return false; }\\n        \\n        for (int i=1;i<s1.size();i++) {\\n            \\n            string aComps11 = s1.substr(0, i);\\n            string aComps12 = s1.substr(i);\\n            \\n            string aComp1s21 = s2.substr(0, i);\\n            string aComp1s22 = s2.substr(i);\\n            \\n            string aComp2s21 = s2.substr(aLen - i);\\n            string aComp2s22 = s2.substr(0, aLen - i);\\n            \\n            if (isScramble(aComps11, aComp1s21) && isScramble(aComps12, aComp1s22)) {\\n                return true;\\n            }\\n            \\n            if (isScramble(aComps11, aComp2s21) && isScramble(aComps12, aComp2s22)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        \\n        if (s1 == s2) { return true; }\\n        if (s1.size() != s2.size()) { return false; }\\n        \\n        string aComp1 = s1;\\n        string aComp2 = s2;\\n        \\n        int aLen = s1.size();\\n        \\n        sort(aComp1.begin(), aComp1.end());\\n        sort(aComp2.begin(), aComp2.end());\\n        if (aComp1 != aComp2) { return false; }\\n        \\n        for (int i=1;i<s1.size();i++) {\\n            \\n            string aComps11 = s1.substr(0, i);\\n            string aComps12 = s1.substr(i);\\n            \\n            string aComp1s21 = s2.substr(0, i);\\n            string aComp1s22 = s2.substr(i);\\n            \\n            string aComp2s21 = s2.substr(aLen - i);\\n            string aComp2s22 = s2.substr(0, aLen - i);\\n            \\n            if (isScramble(aComps11, aComp1s21) && isScramble(aComps12, aComp1s22)) {\\n                return true;\\n            }\\n            \\n            if (isScramble(aComps11, aComp2s21) && isScramble(aComps12, aComp2s22)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250761,
                "title": "java-simple-code-1ms",
                "content": "````\\n\\tpublic boolean isScramble(String s1, String s2) {\\n        if (s1.length() != s2.length()) return false;\\n        if (s1.isEmpty()) return true;\\n        if (s1.equals(s2)) return true;\\n        return isScramble(s1, s2, 0, 0, s1.length());\\n    }\\n\\n    public boolean permutation(String s1, String s2, int i1, int i2, int n) {\\n        int[] cs = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            cs[s1.charAt(i1+i)-\\'a\\']++;\\n            cs[s2.charAt(i2+i)-\\'a\\']--;\\n        }\\n        for (int m : cs) if (m != 0) return false;        \\n        return true;\\n    }\\n\\n    public boolean equal(String s1, String s2, int i1, int i2, int n) {\\n        for (int i = 0; i < n; i++) {\\n            if (s1.charAt(i1+i) != s2.charAt(i2+i)) return false;\\n        }\\n        return true;\\n    }\\n\\n    public boolean isScramble(String s1, String s2, int i1, int i2, int n) {\\n        if (equal(s1,s2,i1,i2,n)) return true;\\n        if (!permutation(s1,s2,i1,i2,n)) return false;\\n        for (int len=1; len<n; len++) {\\n            if (isScramble(s1, s2, i1, i2, len) && isScramble(s1, s2, i1+len, i2+len, n-len)) return true;\\n            if (isScramble(s1, s2, i1, i2+n-len, len) && isScramble(s1, s2, i1+len, i2, n-len)) return true;\\n        }\\n        return false;\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n\\tpublic boolean isScramble(String s1, String s2) {\\n        if (s1.length() != s2.length()) return false;\\n        if (s1.isEmpty()) return true;\\n        if (s1.equals(s2)) return true;\\n        return isScramble(s1, s2, 0, 0, s1.length());\\n    }\\n\\n    public boolean permutation(String s1, String s2, int i1, int i2, int n) {\\n        int[] cs = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            cs[s1.charAt(i1+i)-\\'a\\']++;\\n            cs[s2.charAt(i2+i)-\\'a\\']--;\\n        }\\n        for (int m : cs) if (m != 0) return false;        \\n        return true;\\n    }\\n\\n    public boolean equal(String s1, String s2, int i1, int i2, int n) {\\n        for (int i = 0; i < n; i++) {\\n            if (s1.charAt(i1+i) != s2.charAt(i2+i)) return false;\\n        }\\n        return true;\\n    }\\n\\n    public boolean isScramble(String s1, String s2, int i1, int i2, int n) {\\n        if (equal(s1,s2,i1,i2,n)) return true;\\n        if (!permutation(s1,s2,i1,i2,n)) return false;\\n        for (int len=1; len<n; len++) {\\n            if (isScramble(s1, s2, i1, i2, len) && isScramble(s1, s2, i1+len, i2+len, n-len)) return true;\\n            if (isScramble(s1, s2, i1, i2+n-len, len) && isScramble(s1, s2, i1+len, i2, n-len)) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29432,
                "title": "sharing-recursive-python-solution-with-memo-beats-99",
                "content": "        def isScramble(self, s, t, memo={}):\\n\\n            # Check with sorted is fundamental, otherwise TLE\\n            if len(s) != len(t) or sorted(s) != sorted(t):\\n                return False\\n            if len(s) <= len(t) <= 1:\\n                return s == t\\n            if s == t:\\n                return True\\n            if (s, t) in memo:\\n                return memo[s, t]\\n            n = len(s)\\n            for i in range(1, n):\\n                    a = self.isScramble(s[:i], t[:i], memo) and self.isScramble(s[i:], t[i:], memo)\\n                    if not a:\\n                        b = self.isScramble(s[:i], t[-i:], memo) and self.isScramble(s[i:], t[:-i], memo)\\n                    if a or b:\\n                        memo[s, t] = True\\n                        return True\\n            memo[s, t] = False\\n            return False",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        def isScramble(self, s, t, memo={}):\\n\\n            # Check with sorted is fundamental, otherwise TLE\\n            if len(s) != len(t) or sorted(s) != sorted(t):\\n                return False\\n            if len(s) <= len(t) <= 1:\\n                return s == t\\n            if s == t:\\n                return True\\n            if (s, t) in memo:\\n                return memo[s, t]\\n            n = len(s)\\n            for i in range(1, n):\\n                    a = self.isScramble(s[:i], t[:i], memo) and self.isScramble(s[i:], t[i:], memo)\\n                    if not a:\\n                        b = self.isScramble(s[:i], t[-i:], memo) and self.isScramble(s[i:], t[:-i], memo)\\n                    if a or b:\\n                        memo[s, t] = True\\n                        return True\\n            memo[s, t] = False\\n            return False",
                "codeTag": "Python3"
            },
            {
                "id": 29434,
                "title": "2ms-java-recursive-solution-beat-100",
                "content": "    public class Solution {\\n        int[] p = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\\n        public boolean isScramble(String s1, String s2) {\\n            int l1=s1.length(), l2=s2.length();\\n            if(l1!=l2) return false;\\n            if(l1<=1) return s1.equals(s2);\\n            if(s1.equals(s2)) return true;\\n            long a=1, b=1, c=1;\\n            for(int i=0; i<l1; i++){\\n                if(i>0 && a==b && isScramble(s1.substring(0,i),s2.substring(l2-i)) && isScramble(s1.substring(i),s2.substring(0,l2-i)))\\n                    return true;\\n                if(i>0 && a==c && isScramble(s1.substring(0,i),s2.substring(0,i)) && isScramble(s1.substring(i),s2.substring(i)))\\n                    return true;\\n                a*=p[s1.charAt(i)-'A'];\\n                b*=p[s2.charAt(l2-1-i)-'A'];\\n                c*=p[s2.charAt(i)-'A'];\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int[] p = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997}",
                "codeTag": "Java"
            },
            {
                "id": 29414,
                "title": "java-fast-dp-iteration-solution-and-recursion-solution",
                "content": "Iterative version:\\n\\n    public class Solution {\\n        public boolean isScramble(String s1, String s2) {\\n            int len = s1.length();\\n            if(len!=s2.length()) return false;\\n            if(len==0) return true;\\n            boolean[][][] isScr = new boolean[len][len][len];\\n            for(int i = 0; i < len; i++) { //length of current substring, 0 means length==1\\n                for(int j = 0; j + i < len; j++) { //start point of current substring at s1.\\n                    for(int k = 0; k + i < len; k++) { //start point of current substring at s2.\\n                        if(i==0) isScr[i][j][k] = s1.charAt(j)==s2.charAt(k);\\n                        for(int m = 0; m < i; m++) {\\n                            if(isScr[m][j][k] && isScr[i-(m+1)][j+m+1][k+m+1]) isScr[i][j][k] = true;\\n                            else if(isScr[m][j][k+i-m] && isScr[i-(m+1)][j+m+1][k]) isScr[i][j][k] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            return isScr[len-1][0][0];\\n        }\\n    }\\n\\nRecursive version: with some pruning check at the beginning, finally get rid of TLE...\\n\\n\\n    public class Solution {\\n        public boolean isScramble(String s1, String s2) {\\n            int len= s1.length();\\n            if(s2.length()!=len) return false;\\n            if(s1.equals(s2)) return true;\\n            Map<Character,Integer> checkPermutation = new HashMap<Character,Integer>();\\n            for(int i = 0; i < len; i++) {\\n                char a = s1.charAt(i), b = s2.charAt(i);\\n                if(checkPermutation.containsKey(a)) checkPermutation.put(a,checkPermutation.get(a)+1);\\n                else checkPermutation.put(a,1);\\n                if(checkPermutation.containsKey(b)) checkPermutation.put(b,checkPermutation.get(b)-1);\\n                else checkPermutation.put(b,-1);\\n            }\\n            for(char c : checkPermutation.keySet()) if(checkPermutation.get(c)!=0) return false;\\n            \\n            for(int i = 1; i < s1.length(); i++) {\\n                if(isScramble(s1.substring(0,i),s2.substring(0,i))&&isScramble(s1.substring(i,len),s2.substring(i,len))) return true;\\n                else if(isScramble(s1.substring(0,i),s2.substring(len-i,len))&&isScramble(s1.substring(i,len),s2.substring(0,len-i))) return true;\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isScramble(String s1, String s2) {\\n            int len = s1.length();\\n            if(len!=s2.length()) return false;\\n            if(len==0) return true;\\n            boolean[][][] isScr = new boolean[len][len][len];\\n            for(int i = 0; i < len; i++) { //length of current substring, 0 means length==1\\n                for(int j = 0; j + i < len; j++) { //start point of current substring at s1.\\n                    for(int k = 0; k + i < len; k++) { //start point of current substring at s2.\\n                        if(i==0) isScr[i][j][k] = s1.charAt(j)==s2.charAt(k);\\n                        for(int m = 0; m < i; m++) {\\n                            if(isScr[m][j][k] && isScr[i-(m+1)][j+m+1][k+m+1]) isScr[i][j][k] = true;\\n                            else if(isScr[m][j][k+i-m] && isScr[i-(m+1)][j+m+1][k]) isScr[i][j][k] = true;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3358908,
                "title": "c-memoization-map-aaditya-verma-type-solution",
                "content": "````\\n\\nclass Solution {\\npublic:\\n    bool solve(string s1,string s2,unordered_map<string,bool> &mp){\\n        if(s1.length()!=s2.length()){\\n            return false;\\n        }\\n        if(s1.size()==0&&s2.size()==0){\\n            return true;\\n        }\\n        if(s1.compare(s2)==0){\\n            return true;\\n        }\\n        if(s1.length()<=1){\\n            return false;\\n        }\\n        string key = s1+\" \"+s2;\\n        if(mp.find(key)!=mp.end()){\\n            return mp[key];\\n        }\\n        bool ans = false;\\n        int n = s1.length();\\n        for(int i = 1; i <= n-1; i++){\\n            if(solve(s1.substr(0,i),s2.substr(n-i),mp)==true&&solve(s1.substr(i,n-i),s2.substr(0,n-i),mp)==true){\\n                ans = true;\\n            }\\n            if(!ans&&solve(s1.substr(0,i),s2.substr(0,i),mp)==true&&solve(s1.substr(i,n-i),s2.substr(i,n-i),mp)==true){\\n                ans = true;\\n            }\\n        }\\n        return mp[key] = ans;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string,bool> mp;\\n        int n = s1.length();\\n        return solve(s1,s2,mp);\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "````\\n\\nclass Solution {\\npublic:\\n    bool solve(string s1,string s2,unordered_map<string,bool> &mp){\\n        if(s1.length()!=s2.length()){\\n            return false;\\n        }\\n        if(s1.size()==0&&s2.size()==0){\\n            return true;\\n        }\\n        if(s1.compare(s2)==0){\\n            return true;\\n        }\\n        if(s1.length()<=1){\\n            return false;\\n        }\\n        string key = s1+\" \"+s2;\\n        if(mp.find(key)!=mp.end()){\\n            return mp[key];\\n        }\\n        bool ans = false;\\n        int n = s1.length();\\n        for(int i = 1; i <= n-1; i++){\\n            if(solve(s1.substr(0,i),s2.substr(n-i),mp)==true&&solve(s1.substr(i,n-i),s2.substr(0,n-i),mp)==true){\\n                ans = true;\\n            }\\n            if(!ans&&solve(s1.substr(0,i),s2.substr(0,i),mp)==true&&solve(s1.substr(i,n-i),s2.substr(i,n-i),mp)==true){\\n                ans = true;\\n            }\\n        }\\n        return mp[key] = ans;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string,bool> mp;\\n        int n = s1.length();\\n        return solve(s1,s2,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357888,
                "title": "solution-in-cpp-with-all-the-test-cases-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//for storing already solved problems\\n    unordered_map<string,bool> mp;\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        //base cases\\n        \\n        int n = s1.size();\\n        \\n        //if both string are not equal in size\\n        if(s2.size()!=n)\\n            return false;\\n        \\n        //if both string are equal\\n        if(s1==s2)\\n         return true;   \\n        \\n            \\n        \\n        //if code is reached to this condition then following this are sure:\\n        //1. size of both string is equal\\n        //2.  string are not equal\\n        //so size is equal (where size==1) and they are not equal then obviously false\\n        //example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if(n==1)\\n            return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n\\t\\t//check if this problem has already been solved\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        //for every iteration it can two condition \\n        //1.we should proceed without swapping\\n        //2.we should swap before looking next\\n        for(int i=1;i<n;i++)\\n        {\\n\\n            //ex of without swap: gr|eat and rg|eat\\n            bool withoutswap = (\\n                //left part of first and second string\\n                isScramble(s1.substr(0,i),s2.substr(0,i)) \\n                \\n                &&\\n                \\n                //right part of first and second string;\\n                isScramble(s1.substr(i),s2.substr(i))\\n                );\\n            \\n            \\n            \\n            //if without swap give us right answer then we do not need \\n            //to call the recursion withswap\\n            if(withoutswap)\\n                return true;\\n            \\n            //ex of withswap: gr|eat  rge|at\\n\\t\\t\\t//here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            bool withswap = (\\n                //left part of first and right part of second \\n                isScramble(s1.substr(0,i),s2.substr(n-i)) \\n                \\n                &&\\n                \\n                //right part of first and left part of second\\n                isScramble(s1.substr(i),s2.substr(0,n-i)) \\n                );\\n            \\n            \\n            \\n            //if withswap give us right answer then we return true\\n            //otherwise the for loop do it work\\n            if(withswap)\\n                return true;\\n            //we are not returning false in else case \\n            //because we want to check further cases with the for loop\\n        }\\n        \\n        \\n        return mp[key] = false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//for storing already solved problems\\n    unordered_map<string,bool> mp;\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        //base cases\\n        \\n        int n = s1.size();\\n        \\n        //if both string are not equal in size\\n        if(s2.size()!=n)\\n            return false;\\n        \\n        //if both string are equal\\n        if(s1==s2)\\n         return true;   \\n        \\n            \\n        \\n        //if code is reached to this condition then following this are sure:\\n        //1. size of both string is equal\\n        //2.  string are not equal\\n        //so size is equal (where size==1) and they are not equal then obviously false\\n        //example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if(n==1)\\n            return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n\\t\\t//check if this problem has already been solved\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        //for every iteration it can two condition \\n        //1.we should proceed without swapping\\n        //2.we should swap before looking next\\n        for(int i=1;i<n;i++)\\n        {\\n\\n            //ex of without swap: gr|eat and rg|eat\\n            bool withoutswap = (\\n                //left part of first and second string\\n                isScramble(s1.substr(0,i),s2.substr(0,i)) \\n                \\n                &&\\n                \\n                //right part of first and second string;\\n                isScramble(s1.substr(i),s2.substr(i))\\n                );\\n            \\n            \\n            \\n            //if without swap give us right answer then we do not need \\n            //to call the recursion withswap\\n            if(withoutswap)\\n                return true;\\n            \\n            //ex of withswap: gr|eat  rge|at\\n\\t\\t\\t//here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            bool withswap = (\\n                //left part of first and right part of second \\n                isScramble(s1.substr(0,i),s2.substr(n-i)) \\n                \\n                &&\\n                \\n                //right part of first and left part of second\\n                isScramble(s1.substr(i),s2.substr(0,n-i)) \\n                );\\n            \\n            \\n            \\n            //if withswap give us right answer then we return true\\n            //otherwise the for loop do it work\\n            if(withswap)\\n                return true;\\n            //we are not returning false in else case \\n            //because we want to check further cases with the for loop\\n        }\\n        \\n        \\n        return mp[key] = false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357418,
                "title": "daily-leetcoding-challenge-march-day-30",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/scramble-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/scramble-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3185712,
                "title": "scramble-string-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s one approach to solve the problem using Dynamic Programming in Python3:\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2):\\n            return False\\n        if len(s1) == 1:\\n            return s1 == s2\\n        \\n        n = len(s1)\\n        dp = [[[False] * (n + 1) for _ in range(n)] for __ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if s1[i] == s2[j]:\\n                    dp[i][j][1] = True\\n        \\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                for j in range(n - l + 1):\\n                    for k in range(1, l):\\n                        if (dp[i][j][k] and dp[i + k][j + k][l - k]) or (dp[i][j + l - k][k] and dp[i + k][j][l - k]):\\n                            dp[i][j][l] = True\\n                            break\\n        return dp[0][0][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2):\\n            return False\\n        if len(s1) == 1:\\n            return s1 == s2\\n        \\n        n = len(s1)\\n        dp = [[[False] * (n + 1) for _ in range(n)] for __ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if s1[i] == s2[j]:\\n                    dp[i][j][1] = True\\n        \\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                for j in range(n - l + 1):\\n                    for k in range(1, l):\\n                        if (dp[i][j][k] and dp[i + k][j + k][l - k]) or (dp[i][j + l - k][k] and dp[i + k][j][l - k]):\\n                            dp[i][j][l] = True\\n                            break\\n        return dp[0][0][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966518,
                "title": "scramble-string-c-simple-solution-using-unordered-map",
                "content": "# For more solution git repo\\n[https://github.com/Funik69/Leetcode_Solution]()\\n[https://github.com/Funik69/Leetcode-Algorithm-StudyPlan-]()\\n[https://github.com/Funik69/LeetCode-75---Study-Plan]()\\n[https://github.com/Funik69/Programming-Skills-1]()\\n# C++ code\\n```\\nclass Solution {\\npublic:\\n    unordered_map <string,bool> mp;\\n\\nbool solve(string a ,string b){\\n    if(a.length()!=b.length()){\\n        return false;\\n    }\\n    if(a.compare(b)==0){\\n        return true;\\n    }\\n    if(a.length()<=1){\\n        return false;\\n    }\\n    int n= a.length();\\n    bool flag =false;\\n\\n    string key= (a+\" \"+b);\\n    if(mp.find(key)!=mp.end()){\\n        return mp[key];\\n    }\\n\\n    for(int i=1;i<=n-1;i++){\\n        //gr eat   eat gr\\n        if(solve(a.substr(0,i),b.substr(n-i,i)) && solve(a.substr(i,n-i),b.substr(0,n-i)))\\n        {flag = true;\\n        break;}\\n\\n        //gr eat   gr ate \\n        else if(solve(a.substr(0,i),b.substr(0,i)) && solve(a.substr(i,n-i),b.substr(i,n-i)))\\n        {flag= true;\\n        break;}\\n    }\\n    return mp[key]=flag;\\n}\\n    bool isScramble(string s1, string s2) {\\n        string a=s1;\\n        string b=s2;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a!=b) return false;\\n        else return solve(s1,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map <string,bool> mp;\\n\\nbool solve(string a ,string b){\\n    if(a.length()!=b.length()){\\n        return false;\\n    }\\n    if(a.compare(b)==0){\\n        return true;\\n    }\\n    if(a.length()<=1){\\n        return false;\\n    }\\n    int n= a.length();\\n    bool flag =false;\\n\\n    string key= (a+\" \"+b);\\n    if(mp.find(key)!=mp.end()){\\n        return mp[key];\\n    }\\n\\n    for(int i=1;i<=n-1;i++){\\n        //gr eat   eat gr\\n        if(solve(a.substr(0,i),b.substr(n-i,i)) && solve(a.substr(i,n-i),b.substr(0,n-i)))\\n        {flag = true;\\n        break;}\\n\\n        //gr eat   gr ate \\n        else if(solve(a.substr(0,i),b.substr(0,i)) && solve(a.substr(i,n-i),b.substr(i,n-i)))\\n        {flag= true;\\n        break;}\\n    }\\n    return mp[key]=flag;\\n}\\n    bool isScramble(string s1, string s2) {\\n        string a=s1;\\n        string b=s2;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a!=b) return false;\\n        else return solve(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873254,
                "title": "c-dp-using-memoization-and-recursion-faster-than-90",
                "content": "class Solution {\\npublic:int dp[31][31][31][31];\\n    bool solve(int a, int b, int i, int j, string &s1,string &s2){\\n        if(i>j)\\n            return false;\\n        if(i==j)\\n            return s1[a]==s2[i];\\n        if(dp[a][b][i][j]!=-1)\\n            return dp[a][b][i][j];\\n        bool ans=false;\\n        for(int k=0;k<=(j-i-1);k++){\\n            ans=ans||(solve(a,a+k,i,i+k,s1,s2) && solve(a+k+1,b,i+k+1,j,s1,s2));\\n             }\\n                for(int k=0;k<=(j-i-1);k++){\\n            ans=ans||(solve(a,a+k,j-k,j,s1,s2) && solve(a+k+1,b,i,j-k-1,s1,s2));\\n             }\\n        return dp[a][b][i][j]=ans;\\n        }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,s1.length()-1,0,s1.length()-1,s1,s2);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:int dp[31][31][31][31];\\n    bool solve(int a, int b, int i, int j, string &s1,string &s2){\\n        if(i>j)\\n            return false;\\n        if(i==j)\\n            return s1[a]==s2[i];\\n        if(dp[a][b][i][j]!=-1)\\n            return dp[a][b][i][j];\\n        bool ans=false;\\n        for(int k=0;k<=(j-i-1);k++){\\n            ans=ans||(solve(a,a+k,i,i+k,s1,s2) && solve(a+k+1,b,i+k+1,j,s1,s2));\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1760815,
                "title": "c-dp-aditya-verma",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    unordered_map<string,bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n       \\n        \\n        if(s1.compare(s2)==0)\\n            return true;\\n        \\n        string key=s1;\\n        key.append(\" \");\\n        key.append(s2);\\n        \\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        int n=s1.length();\\n        bool flag=false;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n        bool unswap=isScramble(s1.substr(0,i),s2.substr(0,i)) && \\n        isScramble(s1.substr(i,n-i),s2.substr(i,n-i));\\n        bool swapped=isScramble(s1.substr(0,i),s2.substr(n-i,i)) && \\n        isScramble(s1.substr(i,n-i),s2.substr(0,n-i));\\n            \\n        if(unswap || swapped)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        \\n        return mp[key]=flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    unordered_map<string,bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n       \\n        \\n        if(s1.compare(s2)==0)\\n            return true;\\n        \\n        string key=s1;\\n        key.append(\" \");\\n        key.append(s2);\\n        \\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        int n=s1.length();\\n        bool flag=false;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n        bool unswap=isScramble(s1.substr(0,i),s2.substr(0,i)) && \\n        isScramble(s1.substr(i,n-i),s2.substr(i,n-i));\\n        bool swapped=isScramble(s1.substr(0,i),s2.substr(n-i,i)) && \\n        isScramble(s1.substr(i,n-i),s2.substr(0,n-i));\\n            \\n        if(unswap || swapped)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        \\n        return mp[key]=flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601661,
                "title": "python-dp",
                "content": "General idea is to simulate the problem and cache each subproblem.\\n\\n### F(a,b)\\nLet `F(a,b)` be true if we can scramble a to get b. \\n\\n### Base Case\\n1 if `a==b` we return true since theyre already equal\\n2. if len(a) == 1 and a != b, then we cant scramble a to b so we return false.\\n\\n### Recursive step\\nFor every (left_a, right_a) where (left_a + right_a) = a, we can either swap the two or not swap.\\n\\n#### Case 1: dont swap\\n\\nWhen we don\\'t swap, we need to break b into left_b and right_b the same way we broke a  into left_a and left_b.\\nThen, we can scramble a to get b if `f(left_a, left_b)` and `f(right_a, right_b)` are true.\\n\\nCase 2: swap\\n\\nIf we swap, its similar to not swapping, but we simulate the \\'swap\\' by breaking `b` into left_b, right_b such that len(left_a) == len(right_b) and len(right_b) == len(left_a). then we can scramble a to get b again if  `f(left_a, right_b)` and `f(right_a, left_b)` are true.\\n\\nWe cache these results so we dont repeat the same calculations.\\n\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def f(a, b):\\n            if a == b:\\n                return True\\n            assert(len(a) == len(b))\\n            \\n            if len(a) == 1:\\n                return False\\n            \\n            for length in range(1, len(a)):\\n                # no swap\\n                if f(a[:length], b[:length]) and f(a[length:], b[length:]):\\n                    return True\\n                \\n                # swap\\n                if f(a[:length], b[-length:]) and f(a[length:], b[:len(a)-length]):\\n                    return True\\n            return False\\n        \\n        return f(s1, s2)\\n                \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def f(a, b):\\n            if a == b:\\n                return True\\n            assert(len(a) == len(b))\\n            \\n            if len(a) == 1:\\n                return False\\n            \\n            for length in range(1, len(a)):\\n                # no swap\\n                if f(a[:length], b[:length]) and f(a[length:], b[length:]):\\n                    return True\\n                \\n                # swap\\n                if f(a[:length], b[-length:]) and f(a[length:], b[:len(a)-length]):\\n                    return True\\n            return False\\n        \\n        return f(s1, s2)\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599878,
                "title": "c-memoization",
                "content": "```\\nunordered_map<string, int> mp;\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2)\\n            return true;\\n        if(s1.length() <= 1)\\n            return false;\\n        string key = s1 + \" \" + s2;\\n        if(mp.count(key))\\n            return mp[key];\\n        \\n        int n = s1.length();\\n        bool res = false;\\n        for(int i = 1; i < n; i++) {\\n            bool swap = isScramble(s1.substr(0, i), s2.substr(n-i, i)) && \\n                isScramble(s1.substr(i, n-i), s2.substr(0, n-i));\\n            bool noswap = isScramble(s1.substr(0, i), s2.substr(0, i)) && \\n                isScramble(s1.substr(i, n-i), s2.substr(i, n-i));\\n            if(swap || noswap) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        mp[key] = res;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\nunordered_map<string, int> mp;\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2)\\n            return true;\\n        if(s1.length() <= 1)\\n            return false;\\n        string key = s1 + \" \" + s2;\\n        if(mp.count(key))\\n            return mp[key];\\n        \\n        int n = s1.length();\\n        bool res = false;\\n        for(int i = 1; i < n; i++) {\\n            bool swap = isScramble(s1.substr(0, i), s2.substr(n-i, i)) && \\n                isScramble(s1.substr(i, n-i), s2.substr(0, n-i));\\n            bool noswap = isScramble(s1.substr(0, i), s2.substr(0, i)) && \\n                isScramble(s1.substr(i, n-i), s2.substr(i, n-i));\\n            if(swap || noswap) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        mp[key] = res;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1308418,
                "title": "c-dp-o-n-4-complexity-memory-o-n-3",
                "content": "**This problem can be solved if one is able to define a dp state properly**\\n\\n> Q1: Where to Cut:\\n\\nDo not bother about it, as in worst case s1= aaaaa..., s2=aaabaaaaa... we will have to cut at many places.\\n>Q2:  Transition Time\\n\\nSince we will try to cut at various location, will traverse from first letter in a substring, to last letter. Caution: Don\\'t make the substring length 0 both for \\'x\\' and \\'y\\'. Therefore O(n)\\n\\n>Q3:Dp states\\n\\none might think (start1, end1) (start2, end2) which I initially did. so memory would O(n^4) in this case.\\nBut we can come up with better complexity, Note we don\\'t need to define end1, end2 seperately if we have len, ie length of the substring. Since In order match both the substring their length must be equal. \\n\\nSo define a state (start1, start2, len)\\nso memory O(n^3)\\ntime O(n^3) * Transition Time => O(n^4)\\n\\n>Q4 What our dp state Signify\\n\\ndp[start1][start2][len]  means we are trying to see whether part of s1 which is s1.substr(start1, len) is a scramble string of part of s2 which is s2.substr(start2, len).\\nIf it is it will store 1, else 0; If not processed it will have default -1;\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[31][31][31];                                //-1 non processed, 1 matches, 0 not matches\\n    \\n    int fn(int start1, int start2, int len, string&s1, string& s2){\\n        int &res = dp[start1][start2][len];                       //Now res will refer to our current state\\n        \\n        //base case 0\\n        if(len==1){\\n            if(s1[start1]==s2[start2] ) return res = 1;\\n            else return res=0;\\n        }\\n\\t\\t\\n        //base case 1\\n        if(res!=-1) return res;                       //already processed, reuse it\\n\\t\\t\\n        res = 0;\\n        //without swap\\n        for(int i=1; i<len; i++){\\n            int decision = ( fn(start1, start2, i, s1, s2) & fn(start1+i, start2+i, len-i, s1, s2) );     //true only if x and y both matches\\n            res |= decision;\\n        }\\n\\t\\t\\n        //with swap\\n        for(int i=1; i<len; i++){\\n            int decision = fn(start1, start2+len-i, i, s1, s2) & fn(start1+i, start2, len-i, s1, s2);     //true only if y and x matches\\n            res |= decision;\\n        }\\n        return res;\\n\\t\\t\\n    }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp, -1, sizeof(dp) );\\n        return fn(0, 0, s1.size(), s1, s2);\\n    }\\n};\\n```\\n\\nI don\\'t post regularaly; Since I overviewed most voted soln and found it not optimised. So I am posting it.  No need to upvote. ;) Ask issues, I would try to answer.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[31][31][31];                                //-1 non processed, 1 matches, 0 not matches\\n    \\n    int fn(int start1, int start2, int len, string&s1, string& s2){\\n        int &res = dp[start1][start2][len];                       //Now res will refer to our current state\\n        \\n        //base case 0\\n        if(len==1){\\n            if(s1[start1]==s2[start2] ) return res = 1;\\n            else return res=0;\\n        }\\n\\t\\t\\n        //base case 1\\n        if(res!=-1) return res;                       //already processed, reuse it\\n\\t\\t\\n        res = 0;\\n        //without swap\\n        for(int i=1; i<len; i++){\\n            int decision = ( fn(start1, start2, i, s1, s2) & fn(start1+i, start2+i, len-i, s1, s2) );     //true only if x and y both matches\\n            res |= decision;\\n        }\\n\\t\\t\\n        //with swap\\n        for(int i=1; i<len; i++){\\n            int decision = fn(start1, start2+len-i, i, s1, s2) & fn(start1+i, start2, len-i, s1, s2);     //true only if y and x matches\\n            res |= decision;\\n        }\\n        return res;\\n\\t\\t\\n    }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp, -1, sizeof(dp) );\\n        return fn(0, 0, s1.size(), s1, s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301440,
                "title": "java-recursive-progressive-methods",
                "content": "**Method 1:** Brute Force Recursive\\n```\\n/*\\nCondition 1 (original) : (s1 partition 1 is scrambled of s2 partition 1) and (s1 partition 2 is scrambled of s2 partition 2)\\nCondition 2 (flip) : (s1 partition 1 is scrambled of s2 partition 2) and (s1 partition 2 is scrambled of s2 partition 1)\\n */\\npublic boolean isScramble(String s1, String s2) {\\n\\tif (s1.equals(s2))\\n\\t\\treturn true;\\n\\tvar n = s1.length();\\n\\t\\n\\tfor (var i = 1; i < n; i++) {\\n\\t\\tvar original = isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i));\\n\\t\\tif (original)\\n\\t\\t\\treturn true;\\n\\t\\tvar flip = isScramble(s1.substring(0, i), s2.substring(n - i)) && isScramble(s1.substring(i), s2.substring(0, n - i));\\n\\t\\tif (flip)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Method 2:** Inject memoization in Method 1\\n```\\npublic boolean isScramble(String s1, String s2) {\\n\\treturn isScramble(s1, s2, new HashMap<>());\\n}\\n\\nprivate boolean isScramble(String s1, String s2, Map<String, Boolean> map) {\\n\\tif (s1.equals(s2))\\n\\t\\treturn true;\\n\\tvar key = s1 + \",\" + s2;\\n\\tif (map.containsKey(key))\\n\\t\\treturn map.get(key);\\n\\tvar n = s1.length();\\n\\tfor (var i = 1; i < n; i++) {\\n\\t\\t// (s1 partition 1 is scrambled of s2 partition 1) and (s1 partition 2 is scrambled of s2 partition 2)\\n\\t\\tvar original = isScramble(s1.substring(0, i), s2.substring(0, i), map) && isScramble(s1.substring(i), s2.substring(i), map);\\n\\t\\tif (original) {\\n\\t\\t\\tmap.put(key, true);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t// (s1 partition 1 is scrambled of s2 partition 2) and (s1 partition 2 is scrambled of s2 partition 1)\\n\\t\\tvar flipCase = isScramble(s1.substring(0, i), s2.substring(n - i), map) && isScramble(s1.substring(i), s2.substring(0, n - i), map);\\n\\t\\tif (flipCase) {\\n\\t\\t\\tmap.put(key, true);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\tmap.put(key, false);\\n\\treturn false;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/*\\nCondition 1 (original) : (s1 partition 1 is scrambled of s2 partition 1) and (s1 partition 2 is scrambled of s2 partition 2)\\nCondition 2 (flip) : (s1 partition 1 is scrambled of s2 partition 2) and (s1 partition 2 is scrambled of s2 partition 1)\\n */\\npublic boolean isScramble(String s1, String s2) {\\n\\tif (s1.equals(s2))\\n\\t\\treturn true;\\n\\tvar n = s1.length();\\n\\t\\n\\tfor (var i = 1; i < n; i++) {\\n\\t\\tvar original = isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i));\\n\\t\\tif (original)\\n\\t\\t\\treturn true;\\n\\t\\tvar flip = isScramble(s1.substring(0, i), s2.substring(n - i)) && isScramble(s1.substring(i), s2.substring(0, n - i));\\n\\t\\tif (flip)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n```\n```\\npublic boolean isScramble(String s1, String s2) {\\n\\treturn isScramble(s1, s2, new HashMap<>());\\n}\\n\\nprivate boolean isScramble(String s1, String s2, Map<String, Boolean> map) {\\n\\tif (s1.equals(s2))\\n\\t\\treturn true;\\n\\tvar key = s1 + \",\" + s2;\\n\\tif (map.containsKey(key))\\n\\t\\treturn map.get(key);\\n\\tvar n = s1.length();\\n\\tfor (var i = 1; i < n; i++) {\\n\\t\\t// (s1 partition 1 is scrambled of s2 partition 1) and (s1 partition 2 is scrambled of s2 partition 2)\\n\\t\\tvar original = isScramble(s1.substring(0, i), s2.substring(0, i), map) && isScramble(s1.substring(i), s2.substring(i), map);\\n\\t\\tif (original) {\\n\\t\\t\\tmap.put(key, true);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t// (s1 partition 1 is scrambled of s2 partition 2) and (s1 partition 2 is scrambled of s2 partition 1)\\n\\t\\tvar flipCase = isScramble(s1.substring(0, i), s2.substring(n - i), map) && isScramble(s1.substring(i), s2.substring(0, n - i), map);\\n\\t\\tif (flipCase) {\\n\\t\\t\\tmap.put(key, true);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\tmap.put(key, false);\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277442,
                "title": "javascript-easy-explained-solution",
                "content": "Approach: Intuitive, do what the question asks. \\n\\xA0 \\xA0 We will cut the string s1 from every possible point\\n\\t\\n\\xA0 \\xA0 To do this we will run a loop from start to end\\n\\xA0 \\xA0 \\xA0s1FirstPart = chars from 0 till ith char\\n\\xA0 \\xA0 \\xA0s1SecondPart = chars from i+1 till end\\n\\xA0 \\xA0 \\xA0Then we will match these parts with the same range in s2 if it matches, then the result is true and break the loop\\n\\xA0 \\xA0 \\xA0If it doesn\\'t match then we will try to match the parts of s1 with opposite/reversed parts from s2\\n\\xA0 \\xA0 \\xA0For the second match \\n\\xA0 \\xA0 \\xA0s2FirstPart = last i+1 chars\\n\\xA0 \\xA0 \\xA0s2SecondPart = rest of the chars leaving the last i+1 chars\\n\\xA0 \\xA0 \\xA0Now we will check again if this combination is matching if yes, then the result is true and break the loop\\n\\xA0 \\xA0 \\xA0\\n\\xA0 \\xA0 \\xA0If length of s1 and s2 is 1 then we can check if s1==2 then the result is true else the result is false\\n\\xA0 \\xA0 \\xA0\\n\\t We are also using to cache to avoid processing any to string twice\\n\\t In each call to recursive function \\'match\\' length of s1 and s2 will be same.\\n\\n```\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {boolean}\\n */\\nvar isScramble = function(s1, s2) {\\n    let cache={};\\n    \\n    return match(s1,s2);\\n    \\n    function match(s1,s2){\\n        let res = false;\\n        if(cache[s1+s2]!==undefined){\\n            return cache[s1+s2];\\n        }\\n        if(cache[s2+s1]!==undefined){\\n            return cache[s2+s1];\\n        }\\n        if(s1.length===1){\\n            return s1===s2;\\n        }\\n        let s1FirstPart,s1SecondPart,s2FirstPart,s2SecondPart;\\n        for(let i=0;i<s1.length-1;i++){\\n            s1FirstPart = s1.substring(0,i+1);//first i+1 chars\\n            s1SecondPart = s1.substring(i+1);//rest of the chars\\n            s2FirstPart = s2.substring(0,i+1);//first i+1 chars\\n            s2SecondPart = s2.substring(i+1);//rest of the chars\\n            if(match(s1FirstPart,s2FirstPart) && match(s1SecondPart,s2SecondPart)){\\n                res=true;\\n                break;\\n            }\\n            s2FirstPart = s2.substring(s2.length-1-i);//last i+1 chars\\n            s2SecondPart = s2.substring(0,s2.length-1-i);//rest of the chars\\n            if(match(s1FirstPart,s2FirstPart) && match(s1SecondPart,s2SecondPart)){\\n                res=true;\\n                break;\\n            }\\n        }\\n        cache[s1+s2] = res;\\n        cache[s2+s1] = res\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {boolean}\\n */\\nvar isScramble = function(s1, s2) {\\n    let cache={};\\n    \\n    return match(s1,s2);\\n    \\n    function match(s1,s2){\\n        let res = false;\\n        if(cache[s1+s2]!==undefined){\\n            return cache[s1+s2];\\n        }\\n        if(cache[s2+s1]!==undefined){\\n            return cache[s2+s1];\\n        }\\n        if(s1.length===1){\\n            return s1===s2;\\n        }\\n        let s1FirstPart,s1SecondPart,s2FirstPart,s2SecondPart;\\n        for(let i=0;i<s1.length-1;i++){\\n            s1FirstPart = s1.substring(0,i+1);//first i+1 chars\\n            s1SecondPart = s1.substring(i+1);//rest of the chars\\n            s2FirstPart = s2.substring(0,i+1);//first i+1 chars\\n            s2SecondPart = s2.substring(i+1);//rest of the chars\\n            if(match(s1FirstPart,s2FirstPart) && match(s1SecondPart,s2SecondPart)){\\n                res=true;\\n                break;\\n            }\\n            s2FirstPart = s2.substring(s2.length-1-i);//last i+1 chars\\n            s2SecondPart = s2.substring(0,s2.length-1-i);//rest of the chars\\n            if(match(s1FirstPart,s2FirstPart) && match(s1SecondPart,s2SecondPart)){\\n                res=true;\\n                break;\\n            }\\n        }\\n        cache[s1+s2] = res;\\n        cache[s2+s1] = res\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1164271,
                "title": "python-complete-solution-and-some-remarks",
                "content": "**This is a basic recursive solution which focuses on the following points.**\\n\\nIn order to solve this problem, we are using Divide and Conquer approach. \\nGiven two strings of equal length (say n+1), S1[0\\u2026n] and S2[0\\u2026n]. If S2 is a scrambled form of S1, then there must exist an index i such that at least one of the following conditions is true: \\n \\n\\nS2[0\\u2026i] is a scrambled string of S1[0\\u2026i] and S2[i+1\\u2026n] is a scrambled string of S1[i+1\\u2026n].\\nS2[0\\u2026i] is a scrambled string of S1[n-i\\u2026n] and S2[i+1\\u2026n] is a scrambled string of S1[0\\u2026n-i-1].\\n\\nAs well as, we check if the strings are anagrams if not, then they can;t be scrambled form of each other.\\n\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if len(s1) != len(s2):\\n            return False\\n        n = len(s1)\\n        if not n:\\n            return True\\n        \\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2):\\n            return False\\n        for i in range(1, n):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])):\\n                return True\\n            if (self.isScramble(s1[-i:], s2[:i]) and self.isScramble(s1[:-i], s2[i:])):\\n                return True\\n        return False\\n\\t\\t#Dp using map\\n\\t``\\n\\tclass Solution:\\n    def __init__(self):\\n        self.dic = {}\\n        \\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if (s1, s2) in self.dic :\\n            return self.dic[(s1, s2)]\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2):\\n            self.dic[(s1, s2)] = False     \\n            return False\\n        n = len(s1)\\n        if s1 == s2:\\n            self.dic[(s1, s2)] = True\\n            return True\\n        \\n        for i in range(1, n):\\n            if (self.isScramble(s1[i:], s2[i:]) and self.isScramble(s1[:\\ni], s2[:i])):\\n                return True\\n            if (self.isScramble(s1[:-i], s2[i:]) and self.isScramble(s1[-i:], s2[:i])):\\n                return True\\n\\t\\t\\tself.dic[(s1, s2)] = False\\n\\t\\t\\treturn False\\n```\\n\\nIf you expected recursive solution to pass all the test cases then brother, you really need to think twice, this solution will definitely fail for long inputs, because of your recursive calls, this code is calculating the same values again and again, and that;s why this takes more time, and TLE will appear for long inputs, **but it\\'s always very good practice to write recursive solution first, for DP problems, this is the key to move ahead.**\\n\\tSo, Now our task is to optimise our recursive solution. The one and only we can improve is the recursive calls, as i said, the function is calculating same values again and agin and therefore more time. Why can\\'t we just the store the values that we\\'ve already calculated and then before calculating the value, we\\'ll check if we\\'ve done it already or not.\\n\\t\\tIf we\\'ve we\\'ll use the values, if not, we\\'ll call the function, and believe me this extra 2 or 3 lines can do wonders to your code. \\n\\t\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if len(s1) != len(s2):\\n            return False\\n        n = len(s1)\\n        if not n:\\n            return True\\n        \\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2):\\n            return False\\n        for i in range(1, n):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])):\\n                return True\\n            if (self.isScramble(s1[-i:], s2[:i]) and self.isScramble(s1[:-i], s2[i:])):\\n                return True\\n        return False\\n\\t\\t#Dp using map\\n\\t``\\n\\tclass Solution:\\n    def __init__(self):\\n        self.dic = {}\\n        \\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if (s1, s2) in self.dic :\\n            return self.dic[(s1, s2)]\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2):\\n            self.dic[(s1, s2)] = False     \\n            return False\\n        n = len(s1)\\n        if s1 == s2:\\n            self.dic[(s1, s2)] = True\\n            return True\\n        \\n        for i in range(1, n):\\n            if (self.isScramble(s1[i:], s2[i:]) and self.isScramble(s1[:\\ni], s2[:i])):\\n                return True\\n            if (self.isScramble(s1[:-i], s2[i:]) and self.isScramble(s1[-i:], s2[:i])):\\n                return True\\n\\t\\t\\tself.dic[(s1, s2)] = False\\n\\t\\t\\treturn False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920384,
                "title": "c-memoisation-bottom-up-dp-runtime-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> dp;\\n    bool isScramble(string s1, string s2){\\n        string key = s1 + \\'_\\' + s2;\\n\\n        if(s1.length() != s2.length())\\n            return false;\\n\\n        if(s1.length() == 0)\\n            return true;\\n\\n        if(s1 == s2)\\n            return true;\\n\\n        if(dp.count(key))\\n            return dp[key];\\n\\n        int a[28] = {0};\\n        for(auto &i:s1)\\n            a[i-\\'a\\']++;\\n\\n        for(auto &i:s2)\\n            a[i-\\'a\\']--;\\n\\n        for(int i = 0; i < 28; i++)\\n            if(a[i] != 0)\\n                return false;\\n\\n        int n = s1.length();\\n        bool flag = false;\\n        for(int i = 1; i < s1.length(); i++){\\n            bool left = isScramble(s1.substr(0, i), s2.substr(n-i, i)) &&\\n                        isScramble(s1.substr(i, n-i), s2.substr(0, n-i));\\n\\n            bool right = isScramble(s1.substr(0, i), s2.substr(0, i)) &&\\n                         isScramble(s1.substr(i, n-i), s2.substr(i, n-i));\\n\\n            if(left || right){\\n                flag = true;\\n                break;\\n            }\\n\\n        }\\n\\n        dp[key] = flag;\\n        return dp[key];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> dp;\\n    bool isScramble(string s1, string s2){\\n        string key = s1 + \\'_\\' + s2;\\n\\n        if(s1.length() != s2.length())\\n            return false;\\n\\n        if(s1.length() == 0)\\n            return true;\\n\\n        if(s1 == s2)\\n            return true;\\n\\n        if(dp.count(key))\\n            return dp[key];\\n\\n        int a[28] = {0};\\n        for(auto &i:s1)\\n            a[i-\\'a\\']++;\\n\\n        for(auto &i:s2)\\n            a[i-\\'a\\']--;\\n\\n        for(int i = 0; i < 28; i++)\\n            if(a[i] != 0)\\n                return false;\\n\\n        int n = s1.length();\\n        bool flag = false;\\n        for(int i = 1; i < s1.length(); i++){\\n            bool left = isScramble(s1.substr(0, i), s2.substr(n-i, i)) &&\\n                        isScramble(s1.substr(i, n-i), s2.substr(0, n-i));\\n\\n            bool right = isScramble(s1.substr(0, i), s2.substr(0, i)) &&\\n                         isScramble(s1.substr(i, n-i), s2.substr(i, n-i));\\n\\n            if(left || right){\\n                flag = true;\\n                break;\\n            }\\n\\n        }\\n\\n        dp[key] = flag;\\n        return dp[key];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776581,
                "title": "c-dp-solution",
                "content": "```\\nunordered_map<string, bool> mp;\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2){\\n        \\n        if(s1.length()!= s2.length())\\n            return false;\\n        \\n        if(s1.length() && s2.length() == 0)\\n            return true;\\n    \\n        if(s1.compare(s2) == 0)\\n            return true;\\n        \\n        if(s1.length() <= 1 || s2.length()<=1)\\n            return false;\\n        \\n        string key = s1;           // string key=s1+\" \"+s2\\n        key.push_back(\\' \\');\\n        key.append(s2);\\n        \\n        if(mp.find(key) != mp.end())\\n            return mp[key];\\n        \\n        int n = s1.length();\\n        \\n        bool flag = false;\\n    \\n        for(int k = 1; k < n; k++){\\n        \\n            bool c1 = (isScramble(s1.substr(0, k),s2.substr(n - k, k)) && isScramble(s1.substr(k, n-k), s2.substr(0, n - k)));\\n            bool c2 = (isScramble(s1.substr(0, k),s2.substr(0, k)) && isScramble(s1.substr(k, n-k), s2.substr(k,n - k)));                                                     \\n        \\n              if(c1 || c2){\\n                 flag = true;\\n                 break;\\n              }\\n        }\\n         return mp[key] = flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_map<string, bool> mp;\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2){\\n        \\n        if(s1.length()!= s2.length())\\n            return false;\\n        \\n        if(s1.length() && s2.length() == 0)\\n            return true;\\n    \\n        if(s1.compare(s2) == 0)\\n            return true;\\n        \\n        if(s1.length() <= 1 || s2.length()<=1)\\n            return false;\\n        \\n        string key = s1;           // string key=s1+\" \"+s2\\n        key.push_back(\\' \\');\\n        key.append(s2);\\n        \\n        if(mp.find(key) != mp.end())\\n            return mp[key];\\n        \\n        int n = s1.length();\\n        \\n        bool flag = false;\\n    \\n        for(int k = 1; k < n; k++){\\n        \\n            bool c1 = (isScramble(s1.substr(0, k),s2.substr(n - k, k)) && isScramble(s1.substr(k, n-k), s2.substr(0, n - k)));\\n            bool c2 = (isScramble(s1.substr(0, k),s2.substr(0, k)) && isScramble(s1.substr(k, n-k), s2.substr(k,n - k)));                                                     \\n        \\n              if(c1 || c2){\\n                 flag = true;\\n                 break;\\n              }\\n        }\\n         return mp[key] = flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631223,
                "title": "java-recursion-explanation",
                "content": "Intiution: \\nStep 1:\\nlets take a simpler example:  \"abc\" & \"bac\".  \\nStep 2:\\nabc can be split in the following => {a,bc} {ab, c}\\non swapping the values you can also generate reverse of substrings {bc,a} and {c, ab}  \\n\\nStep 3:\\nAll possible combinations of abc from step-2 are {a,bc} {ab, c} & {bc,a} and {c, ab} \\n\\nStep 4:\\nSimilarly \"bac\" becomes {b, ac} {ba, c} {ac, b} {c, ab}\\n\\nStep 5: \\nTake the Step3 and Step4 results and recursively analyze if any of the combination results in to same string, if it does its success. else its not. \\n\\n\\n\\n\\n\\n\\n\\n````\\nclass Solution {\\n    Map<String, Boolean> memo = new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n                \\n        if(s1.equalsIgnoreCase(s2)) return true;\\n        \\n        String key = s1+\"____\"+s2;\\n        \\n        if(memo.containsKey(key))return memo.get(key);\\n        \\n        boolean answer = false;\\n        for(int i=1;i<s2.length();i++){\\n            \\n            String real_prefix = s1.substring(0, s1.length()-i); //(gr, e)\\n            String real_suffix = s1.substring(s1.length()-i);\\n            \\n            String real_prefix_no_echange = s1.substring(0, i); // (g, re)\\n            String real_suffix_no_echange = s1.substring(i);\\n                        \\n            String prefix = s2.substring(0, i);   // (g, re)\\n            String suffix = s2.substring(i);\\n\\n            boolean noExchange = isScramble(real_prefix, suffix) && isScramble(real_suffix, prefix);\\n            boolean exchange = isScramble(real_prefix_no_echange, prefix) && isScramble(real_suffix_no_echange, suffix);\\n            \\n            \\n            answer = answer || exchange || noExchange;\\n        }\\n        \\n        memo.put(key, answer);\\n        return answer;\\n    }\\n}\\n````\\n\\nO(n^4)",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    Map<String, Boolean> memo = new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n                \\n        if(s1.equalsIgnoreCase(s2)) return true;\\n        \\n        String key = s1+\"____\"+s2;\\n        \\n        if(memo.containsKey(key))return memo.get(key);\\n        \\n        boolean answer = false;\\n        for(int i=1;i<s2.length();i++){\\n            \\n            String real_prefix = s1.substring(0, s1.length()-i); //(gr, e)\\n            String real_suffix = s1.substring(s1.length()-i);\\n            \\n            String real_prefix_no_echange = s1.substring(0, i); // (g, re)\\n            String real_suffix_no_echange = s1.substring(i);\\n                        \\n            String prefix = s2.substring(0, i);   // (g, re)\\n            String suffix = s2.substring(i);\\n\\n            boolean noExchange = isScramble(real_prefix, suffix) && isScramble(real_suffix, prefix);\\n            boolean exchange = isScramble(real_prefix_no_echange, prefix) && isScramble(real_suffix_no_echange, suffix);\\n            \\n            \\n            answer = answer || exchange || noExchange;\\n        }\\n        \\n        memo.put(key, answer);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359319,
                "title": "share-my-notes-of-this-problem",
                "content": "I think this problem is much difficult than other difficult problems . I spend almost one day to find the solution to this problem from brute force to dynamic planing .\\nHere are my solutions :\\n\\n## Solution One  \\n  use recrusive brute foce method(this method will get runtime limit error)\\n```\\n public boolean isScramble(String s1, String s2) {\\n        if(s1.equals(s2)){\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        if(!scrambleEqual(s1,s2)){\\n            return false;\\n        }\\n        for(int i=1;i<s1.length();i++){\\n            String s1L = s1.substring(0,i);\\n            String s1R = s1.substring(i,s1.length());\\n            String s2L = s2.substring(0,i);\\n            String s2R = s2.substring(i,s2.length());\\n            if(isScramble(s1L,s2L) && isScramble(s1R,s2R)){\\n                return true;\\n            }\\n            s2L = s2.substring(s2.length()-i,s2.length());\\n            s2R = s2.substring(0,s2.length()-i);\\n\\n            if(isScramble(s1L,s2L) && isScramble(s1R,s2R)){\\n                return true;\\n            }\\n\\n        }\\n        return false;\\n    }\\n\\n    public boolean scrambleEqual(String s1,String s2){\\n        int[] c = new int[26];\\n        for(int i=0;i<s1.length();i++){\\n            c[s1.charAt(i) - \\'a\\']++;\\n            c[s2.charAt(i) - \\'a\\']--;\\n        }\\n        boolean ans = true;\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0){\\n                return false;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n## Solution Two  \\nuse recursive plus memory method(this solution will alose cause time limit exception . the reason of this is that there still have dumplicate calculation)\\n```\\npublic boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int len = s1.length();\\n        boolean[][][] map = new boolean[len + 1][len + 1][len + 1];\\n        return helper(s1, 0, s2, 0, len, map);\\n    }\\n\\n    public boolean helper(String s1, int i, String s2,int j, int len, boolean[][][] map) {\\n        if (len == 0) { return true; }\\n        if (len == 1 && s1.charAt(i) == s2.charAt(j)) {\\n            map[i][j][len] = true;\\n        }\\n        if (map[i][j][len]) {\\n            return true;\\n        }\\n        for (int k = 1; k < len; k++) {\\n            if (helper(s1, i, s2, j, k, map) && helper(s1, i + k, s2, j + k, len - k, map)) {\\n                return map[i][j][len] = true;\\n            }\\n            if (helper(s1, i, s2, j + len - k, k, map) && helper(s1, i + k, s2, j, len - k, map)) {\\n                return map[i][j][len] = true;\\n            }\\n        }\\n        return map[i][j][len] = false;\\n    }\\n```\\n\\n## Solution Three  \\nfix dumplicate calculation of solution two\\n```\\npublic boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int len = s1.length();\\n        int[][][] map = new int[len + 1][len + 1][len + 1];\\n        return helper(s1, 0, s2, 0, len, map);\\n    }\\n\\n    public boolean helper(String s1, int i, String s2,int j, int len, int[][][] map) {\\n        if (len == 0) { return true; }\\n        if (len == 1 && s1.charAt(i) == s2.charAt(j)) {\\n            map[i][j][len] = 1;\\n        }\\n        if (map[i][j][len]!=0) {\\n            return map[i][j][len]==1;\\n        }\\n        for (int k = 1; k < len; k++) {\\n            if (helper(s1, i, s2, j, k, map) && helper(s1, i + k, s2, j + k, len - k, map)) {\\n                map[i][j][len] = 1;\\n                return true;\\n            }\\n            if (helper(s1, i, s2, j + len - k, k, map) && helper(s1, i + k, s2, j, len - k, map)) {\\n                map[i][j][len] = 1;\\n                return true;\\n            }\\n        }\\n        map[i][j][len] = 2;\\n        return false;\\n    }\\n```\\n\\n## Solution four  \\nchange solution three to dynamic planing\\n```\\n  public boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int n = s1.length();\\n        boolean[][][] dp = new boolean[n + 1][n + 1][n + 1];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j][1] = s1.charAt(i) == s2.charAt(j);\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                for (int j = 0; j <= n - len; j++) {\\n                    for (int k = 1; k <= len; k++) {\\n                        boolean left = dp[i][j][k] && dp[i + k][j + k][len - k];\\n                        boolean right = dp[i][j + len - k][k] && dp[i + k][j][len - k];\\n                        if (left || right) {\\n                            dp[i][j][len] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][0][n];\\n    }\\n```\\n\\n## solution five(final solution)\\nan improve solution of solution four\\n```\\npublic boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int len = s1.length();\\n        boolean[][][] dp = new boolean[len][len][len+1];\\n\\t\\tfor (int k = 1; k <= len; ++k)\\n\\t\\t\\tfor (int i = 0; i + k <= len; ++i)\\n\\t\\t\\t\\tfor (int j = 0; j + k <= len; ++j)\\n\\t\\t\\t\\t\\tif (k == 1)\\n\\t\\t\\t\\t\\t\\tdp[i][j][k] = s1.charAt(i) == s2.charAt(j);\\n\\t\\t\\t\\t\\telse for (int q = 1; q < k && !dp[i][j][k]; ++q) {\\n\\t\\t\\t\\t\\t\\tdp[i][j][k] = (dp[i][j][q] && dp[i + q][j + q][k - q]) || (dp[i][j + k - q][q] && dp[i + q][j][k - q]);\\n\\t\\t\\t\\t\\t}\\n        return dp[0][0][len];\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public boolean isScramble(String s1, String s2) {\\n        if(s1.equals(s2)){\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        if(!scrambleEqual(s1,s2)){\\n            return false;\\n        }\\n        for(int i=1;i<s1.length();i++){\\n            String s1L = s1.substring(0,i);\\n            String s1R = s1.substring(i,s1.length());\\n            String s2L = s2.substring(0,i);\\n            String s2R = s2.substring(i,s2.length());\\n            if(isScramble(s1L,s2L) && isScramble(s1R,s2R)){\\n                return true;\\n            }\\n            s2L = s2.substring(s2.length()-i,s2.length());\\n            s2R = s2.substring(0,s2.length()-i);\\n\\n            if(isScramble(s1L,s2L) && isScramble(s1R,s2R)){\\n                return true;\\n            }\\n\\n        }\\n        return false;\\n    }\\n\\n    public boolean scrambleEqual(String s1,String s2){\\n        int[] c = new int[26];\\n        for(int i=0;i<s1.length();i++){\\n            c[s1.charAt(i) - \\'a\\']++;\\n            c[s2.charAt(i) - \\'a\\']--;\\n        }\\n        boolean ans = true;\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0){\\n                return false;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int len = s1.length();\\n        boolean[][][] map = new boolean[len + 1][len + 1][len + 1];\\n        return helper(s1, 0, s2, 0, len, map);\\n    }\\n\\n    public boolean helper(String s1, int i, String s2,int j, int len, boolean[][][] map) {\\n        if (len == 0) { return true; }\\n        if (len == 1 && s1.charAt(i) == s2.charAt(j)) {\\n            map[i][j][len] = true;\\n        }\\n        if (map[i][j][len]) {\\n            return true;\\n        }\\n        for (int k = 1; k < len; k++) {\\n            if (helper(s1, i, s2, j, k, map) && helper(s1, i + k, s2, j + k, len - k, map)) {\\n                return map[i][j][len] = true;\\n            }\\n            if (helper(s1, i, s2, j + len - k, k, map) && helper(s1, i + k, s2, j, len - k, map)) {\\n                return map[i][j][len] = true;\\n            }\\n        }\\n        return map[i][j][len] = false;\\n    }\\n```\n```\\npublic boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int len = s1.length();\\n        int[][][] map = new int[len + 1][len + 1][len + 1];\\n        return helper(s1, 0, s2, 0, len, map);\\n    }\\n\\n    public boolean helper(String s1, int i, String s2,int j, int len, int[][][] map) {\\n        if (len == 0) { return true; }\\n        if (len == 1 && s1.charAt(i) == s2.charAt(j)) {\\n            map[i][j][len] = 1;\\n        }\\n        if (map[i][j][len]!=0) {\\n            return map[i][j][len]==1;\\n        }\\n        for (int k = 1; k < len; k++) {\\n            if (helper(s1, i, s2, j, k, map) && helper(s1, i + k, s2, j + k, len - k, map)) {\\n                map[i][j][len] = 1;\\n                return true;\\n            }\\n            if (helper(s1, i, s2, j + len - k, k, map) && helper(s1, i + k, s2, j, len - k, map)) {\\n                map[i][j][len] = 1;\\n                return true;\\n            }\\n        }\\n        map[i][j][len] = 2;\\n        return false;\\n    }\\n```\n```\\n  public boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int n = s1.length();\\n        boolean[][][] dp = new boolean[n + 1][n + 1][n + 1];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j][1] = s1.charAt(i) == s2.charAt(j);\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                for (int j = 0; j <= n - len; j++) {\\n                    for (int k = 1; k <= len; k++) {\\n                        boolean left = dp[i][j][k] && dp[i + k][j + k][len - k];\\n                        boolean right = dp[i][j + len - k][k] && dp[i + k][j][len - k];\\n                        if (left || right) {\\n                            dp[i][j][len] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][0][n];\\n    }\\n```\n```\\npublic boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int len = s1.length();\\n        boolean[][][] dp = new boolean[len][len][len+1];\\n\\t\\tfor (int k = 1; k <= len; ++k)\\n\\t\\t\\tfor (int i = 0; i + k <= len; ++i)\\n\\t\\t\\t\\tfor (int j = 0; j + k <= len; ++j)\\n\\t\\t\\t\\t\\tif (k == 1)\\n\\t\\t\\t\\t\\t\\tdp[i][j][k] = s1.charAt(i) == s2.charAt(j);\\n\\t\\t\\t\\t\\telse for (int q = 1; q < k && !dp[i][j][k]; ++q) {\\n\\t\\t\\t\\t\\t\\tdp[i][j][k] = (dp[i][j][q] && dp[i + q][j + q][k - q]) || (dp[i][j + k - q][q] && dp[i + q][j][k - q]);\\n\\t\\t\\t\\t\\t}\\n        return dp[0][0][len];\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 302507,
                "title": "32ms-python-recursive-solution-faster-than-100",
                "content": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if s1 == s2:\\n            return True\\n        l, a, b, c = len(s1), [], [], []\\n        for i in range(1, l):\\n            bisect.insort(a, s1[i - 1])\\n            bisect.insort(b, s2[-i])\\n            bisect.insort(c, s2[i - 1])\\n            if a == b and self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[0:-i]):\\n                return True\\n            elif a == c and self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if s1 == s2:\\n            return True\\n        l, a, b, c = len(s1), [], [], []\\n        for i in range(1, l):\\n            bisect.insort(a, s1[i - 1])\\n            bisect.insort(b, s2[-i])\\n            bisect.insort(c, s2[i - 1])\\n            if a == b and self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[0:-i]):\\n                return True\\n            elif a == c and self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284076,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public bool IsScramble(string s1, string s2) {\\n        var n = s1.Length;\\n\\n        if (n != s2.Length) {\\n            return false;\\n        }\\n\\n        // check whether they have same letters\\n        var s1CharArray = s1.ToCharArray();\\n        var s2CharArray = s2.ToCharArray();\\n\\n        Array.Sort(s1CharArray);\\n        Array.Sort(s2CharArray);\\n\\n        for (int i = 0; i < s1CharArray.Length; i++) {\\n            if (s1CharArray[i] != s2CharArray[i]) {\\n                return false;\\n            }\\n        }\\n\\n        // DP: s1[i], s2[j], length\\n        var dp = new bool[n, n, n + 1];\\n\\n        // start with len = 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s1[i] == s2[j]) {\\n                    dp[i, j, 1] = true;\\n                }\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n - len + 1; i++) {\\n                for (int j = 0; j < n - len + 1; j++) {\\n                    for (int k = 1; k < len; k++) {\\n                        // (gr eat) or (eat gr)\\n                        if ((dp[i, j, k] && dp[i + k, j + k, len - k]) ||\\n                            (dp[i, j + len - k, k] && dp[i + k, j, len - k])\\n                        ) {\\n                            dp[i, j, len] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0, 0, n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsScramble(string s1, string s2) {\\n        var n = s1.Length;\\n\\n        if (n != s2.Length) {\\n            return false;\\n        }\\n\\n        // check whether they have same letters\\n        var s1CharArray = s1.ToCharArray();\\n        var s2CharArray = s2.ToCharArray();\\n\\n        Array.Sort(s1CharArray);\\n        Array.Sort(s2CharArray);\\n\\n        for (int i = 0; i < s1CharArray.Length; i++) {\\n            if (s1CharArray[i] != s2CharArray[i]) {\\n                return false;\\n            }\\n        }\\n\\n        // DP: s1[i], s2[j], length\\n        var dp = new bool[n, n, n + 1];\\n\\n        // start with len = 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s1[i] == s2[j]) {\\n                    dp[i, j, 1] = true;\\n                }\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n - len + 1; i++) {\\n                for (int j = 0; j < n - len + 1; j++) {\\n                    for (int k = 1; k < len; k++) {\\n                        // (gr eat) or (eat gr)\\n                        if ((dp[i, j, k] && dp[i + k, j + k, len - k]) ||\\n                            (dp[i, j + len - k, k] && dp[i + k, j, len - k])\\n                        ) {\\n                            dp[i, j, len] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0, 0, n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257185,
                "title": "in-place-implementation-without-creating-new-string-100-in-both-memory-and-speed",
                "content": "Was able to avoid recreate substring during the recurssion. However the memorization seems have a big perf hit. Anyone find the same and have a good understanding on why is that?\\n\\n![image](https://assets.leetcode.com/users/liyun1988/image_1552846961.png)\\n\\n\\nI have tested with memorization. once memorization is added the entire execution time would be degraded. Does anyone experience the same? \\n\\n```\\n public boolean isScramble(String s1, String s2) {\\n        if((s1 == null || s1.length() == 0) && (s2 == null || s2.length() == 0)) {\\n            return true;\\n        }\\n        \\n        if((s1 == null || s1.length() == 0) || (s2 == null || s2.length() == 0)) {\\n            return false;\\n        }\\n        \\n        if(s1.length() != s2.length()) {\\n            return false;\\n        }\\n        \\n        // HashMap<String, Boolean> isScrambles = new HashMap<>();\\n        return isScramble_withoutMemorization(s1, 0, s1.length() - 1, s2, 0, s2.length() - 1);\\n    }\\n    \\n    private boolean isScramble_withoutMemorization(String s1, int left1, int right1, String s2, int left2, int right2) {\\n        if(left1 > right1) {\\n            // same applies to left2 and right2.\\n            return true;\\n        }\\n        \\n        if(left1 == right1) {\\n            // same for left2 and right2.\\n            return s1.charAt(left1) == s2.charAt(left2);\\n        }\\n        \\n        /*\\n        String key = getKey(s1, left1, right1, s2, left2, right2);\\n        if(isScrambles.containsKey(key)) {\\n            return isScrambles.get(key);\\n        }\\n        */\\n        \\n        if(!isPermutation(s1, left1, right1, s2, left2, right2)) {\\n            // permutation is necessary but not sufficient\\n            //isScrambles.put(key, false);\\n            return false;\\n        }\\n        \\n        for(int k = 0; k < right1 - left1; ++k) {\\n            if((isScramble_withoutMemorization(s1, left1, left1 + k, s2, left2, left2 + k) \\n                  && isScramble_withoutMemorization(s1, left1 + k + 1, right1, s2, left2 + k + 1, right2))\\n               || (isScramble_withoutMemorization(s1, left1, left1 + k, s2, right2 - k, right2)\\n                  && isScramble_withoutMemorization(s1,left1 + k + 1, right1, s2, left2, right2 - k - 1))) {\\n                //isScrambles.put(key, true);\\n                return true;\\n            }\\n        }\\n        \\n        //isScrambles.put(key, false);\\n        return false;\\n    }\\n    \\n    private boolean isPermutation(String s1, int left1, int right1, String s2, int left2, int right2) {\\n        int[] counts = new int[26];\\n        for(int i = 0; i <= right1 - left1; ++i) {\\n            ++counts[s1.charAt(left1 + i) - \\'a\\'];\\n            --counts[s2.charAt(left2 + i) -\\'a\\'];\\n        }\\n        \\n        for (int i= 0;i<26;i++) {\\n            if (counts[i] != 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private String getKey(String s1, int left1, int right1, String s2, int left2, int right2) {\\n        StringBuilder sb = new StringBuilder(right1 - left1 + 1 + right2 - left2 + 1);\\n        for(int i = left1; i <= right1; ++i) {\\n            sb.append(s1.charAt(i));\\n        }\\n        \\n        for(int i = left2; i <= right2; ++i) {\\n            sb.append(s2.charAt(i));\\n        }\\n        \\n        return new String(sb);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public boolean isScramble(String s1, String s2) {\\n        if((s1 == null || s1.length() == 0) && (s2 == null || s2.length() == 0)) {\\n            return true;\\n        }\\n        \\n        if((s1 == null || s1.length() == 0) || (s2 == null || s2.length() == 0)) {\\n            return false;\\n        }\\n        \\n        if(s1.length() != s2.length()) {\\n            return false;\\n        }\\n        \\n        // HashMap<String, Boolean> isScrambles = new HashMap<>();\\n        return isScramble_withoutMemorization(s1, 0, s1.length() - 1, s2, 0, s2.length() - 1);\\n    }\\n    \\n    private boolean isScramble_withoutMemorization(String s1, int left1, int right1, String s2, int left2, int right2) {\\n        if(left1 > right1) {\\n            // same applies to left2 and right2.\\n            return true;\\n        }\\n        \\n        if(left1 == right1) {\\n            // same for left2 and right2.\\n            return s1.charAt(left1) == s2.charAt(left2);\\n        }\\n        \\n        /*\\n        String key = getKey(s1, left1, right1, s2, left2, right2);\\n        if(isScrambles.containsKey(key)) {\\n            return isScrambles.get(key);\\n        }\\n        */\\n        \\n        if(!isPermutation(s1, left1, right1, s2, left2, right2)) {\\n            // permutation is necessary but not sufficient\\n            //isScrambles.put(key, false);\\n            return false;\\n        }\\n        \\n        for(int k = 0; k < right1 - left1; ++k) {\\n            if((isScramble_withoutMemorization(s1, left1, left1 + k, s2, left2, left2 + k) \\n                  && isScramble_withoutMemorization(s1, left1 + k + 1, right1, s2, left2 + k + 1, right2))\\n               || (isScramble_withoutMemorization(s1, left1, left1 + k, s2, right2 - k, right2)\\n                  && isScramble_withoutMemorization(s1,left1 + k + 1, right1, s2, left2, right2 - k - 1))) {\\n                //isScrambles.put(key, true);\\n                return true;\\n            }\\n        }\\n        \\n        //isScrambles.put(key, false);\\n        return false;\\n    }\\n    \\n    private boolean isPermutation(String s1, int left1, int right1, String s2, int left2, int right2) {\\n        int[] counts = new int[26];\\n        for(int i = 0; i <= right1 - left1; ++i) {\\n            ++counts[s1.charAt(left1 + i) - \\'a\\'];\\n            --counts[s2.charAt(left2 + i) -\\'a\\'];\\n        }\\n        \\n        for (int i= 0;i<26;i++) {\\n            if (counts[i] != 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private String getKey(String s1, int left1, int right1, String s2, int left2, int right2) {\\n        StringBuilder sb = new StringBuilder(right1 - left1 + 1 + right2 - left2 + 1);\\n        for(int i = left1; i <= right1; ++i) {\\n            sb.append(s1.charAt(i));\\n        }\\n        \\n        for(int i = left2; i <= right2; ++i) {\\n            sb.append(s2.charAt(i));\\n        }\\n        \\n        return new String(sb);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201049,
                "title": "doubt-in-one-of-the-test-cases",
                "content": "Input:\\n\"abb\"\\n\"bab\"\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHow is this a valid case ?\\nShould\\'nt the tree for abb look something like this \\n\\n\\t  abb\\n\\t\\t/\\\\\\n\\t   /  \\\\\\n\\t  a   bb\\n\\t\\t\\t/\\\\\\n\\t\\t   /  \\\\\\n\\t\\t b    b\\n\\t\\t \\nIn such a case we will never have bab as a valid swapped string right ? This is the 93rd test case and I am stuck on it. Can someone please clarify ?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 168869,
                "title": "python-6-lines-short-dfs-and-a-super-slow-dp-solution",
                "content": "Base case: if s1 == s2, then return True, if the s1 is not a permutation of s2, then return False (we can check this by comparing `sorted(s1)` and `sorted(s2)`.\\n\\nOtherwise, we recursively check to see each part of string seperation are scramble or not. Specifically, for `i = 1->len(s1)` we check `isScramble(s1[:i], s2[:i])` and `isScramble(s1[i:], s2[i:])`, if so then return True (e.g, `great`, and `rgeat`). Also we need to check if `isScramble(s1[:i], s2[-i:])` and `isScramble(s1[i:], s2[:-i])` (e.g, `great`, `eatgr`), if so also return True. \\n\\n```python\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if s1 == s2:return True\\n        if sorted(s1) != sorted(s2):return False\\n        for i in range(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                return True\\n        return False\\n```\\n\\nAdding memorization would also speed up the code by a little bit.\\n\\n```python\\nclass Solution(object):\\n    \\n    mem = {}\\n    \\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if (s1, s2) in self.mem:return self.mem[(s1, s2)]\\n        if s1 == s2:return True\\n        if sorted(s1) != sorted(s2):return False\\n        res = False\\n        for i in range(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                res = True\\n                break\\n        self.mem[(s1, s2)] = res\\n        return res\\n```\\n\\nI feel writing code with DFS instead of DP is much easier .. however I do not know how to analyze the time complexity of it. Would appreciate if anyone can give some hint.  \\n\\nJust FYI, here is the standard fill-table DP solution. Super slow though.\\n\\n```python\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if len(s1) != len(s2):\\n            return False\\n        n = len(s1)\\n        dp = [[[False for _ in range(n+1)] for _ in range(n)] for _ in range(n)]\\n        for k in range(n+1):\\n            for i in range(n):\\n                for j in range(n):\\n                    if k == 0:\\n                        dp[i][j][k] = True\\n                        continue\\n                    if k == 1:\\n                        dp[i][j][k] = s1[i] == s2[j]\\n                        continue\\n                    if i + k > n or j + k > n:\\n                        continue\\n                    for p in range(1, k):\\n                        dp[i][j][k] |= dp[i][j][p] and dp[i+p][j+p][k-p]\\n                        dp[i][j][k] |= dp[i][j+p][k-p] and dp[i+k-p][j][p]\\n        return dp[0][0][n]\\n                        \\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if s1 == s2:return True\\n        if sorted(s1) != sorted(s2):return False\\n        for i in range(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                return True\\n        return False\\n```\n```python\\nclass Solution(object):\\n    \\n    mem = {}\\n    \\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if (s1, s2) in self.mem:return self.mem[(s1, s2)]\\n        if s1 == s2:return True\\n        if sorted(s1) != sorted(s2):return False\\n        res = False\\n        for i in range(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                res = True\\n                break\\n        self.mem[(s1, s2)] = res\\n        return res\\n```\n```python\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if len(s1) != len(s2):\\n            return False\\n        n = len(s1)\\n        dp = [[[False for _ in range(n+1)] for _ in range(n)] for _ in range(n)]\\n        for k in range(n+1):\\n            for i in range(n):\\n                for j in range(n):\\n                    if k == 0:\\n                        dp[i][j][k] = True\\n                        continue\\n                    if k == 1:\\n                        dp[i][j][k] = s1[i] == s2[j]\\n                        continue\\n                    if i + k > n or j + k > n:\\n                        continue\\n                    for p in range(1, k):\\n                        dp[i][j][k] |= dp[i][j][p] and dp[i+p][j+p][k-p]\\n                        dp[i][j][k] |= dp[i][j+p][k-p] and dp[i+k-p][j][p]\\n        return dp[0][0][n]\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 29421,
                "title": "1-liner-in-python-88ms-with-an-optimization-note",
                "content": "```\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        return s1==s2 or sorted(s1)==sorted(s2) and any(self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]) or self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]) for i in range(1, len(s1)))\\n```\\n\\nWhich is equivalent to:\\n\\n```\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2):\\n            return False\\n        for i in range(1, len(s1)):\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                return True\\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\\n                return True\\n        return False\\n```\\n\\nI noticed for shorter strings (which is the case here, but not in problem 242 Valid Anagram), sorted(s1) != sorted(s2) is much faster than collections.Counter(s1) != collections.Counter(s2)\\n\\nWhat do you guys think? @StefanPochmann",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        return s1==s2 or sorted(s1)==sorted(s2) and any(self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]) or self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]) for i in range(1, len(s1)))\\n```\n```\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2):\\n            return False\\n        for i in range(1, len(s1)):\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                return True\\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29433,
                "title": "7ms-ac-simple-java-no-dp-no-sort-no-count-no-hashtable-with-a-speed-up-trick",
                "content": "The trick is to do the shorter sub string first, hoping it fails quickly and avoid doing the longer one.\\n\\n    boolean isit(char[] s1, char[] s2, int b1, int e1, int b2, int e2) {\\n        int len = e1-b1;\\n        if (1 == len) return s1[b1] == s2[b2];\\n        for (int n = 1; n <= len/2; ++n) {\\n            if (isit(s1, s2, b1, b1+n, b2, b2+n) && isit(s1, s2, b1+n, e1, b2+n, e2)) return true;\\n            if (isit(s1, s2, b1, b1+n, e2-n, e2) && isit(s1, s2, b1+n, e1, b2, e2-n)) return true;\\n            if (n == len-n) continue;\\n            if (isit(s1, s2, e1-n, e1, b2, b2+n) && isit(s1, s2, b1, e1-n, b2+n, e2)) return true;\\n            if (isit(s1, s2, e1-n, e1, e2-n, e2) && isit(s1, s2, b1, e1-n, b2, e2-n)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean isScramble(String s1, String s2) {\\n        return isit(s1.toCharArray(), s2.toCharArray(), 0, s1.length(), 0, s2.length());\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The trick is to do the shorter sub string first, hoping it fails quickly and avoid doing the longer one.\\n\\n    boolean isit(char[] s1, char[] s2, int b1, int e1, int b2, int e2) {\\n        int len = e1-b1;\\n        if (1 == len) return s1[b1] == s2[b2];\\n        for (int n = 1; n <= len/2; ++n) {\\n            if (isit(s1, s2, b1, b1+n, b2, b2+n) && isit(s1, s2, b1+n, e1, b2+n, e2)) return true;\\n            if (isit(s1, s2, b1, b1+n, e2-n, e2) && isit(s1, s2, b1+n, e1, b2, e2-n)) return true;\\n            if (n == len-n) continue;\\n            if (isit(s1, s2, e1-n, e1, b2, b2+n) && isit(s1, s2, b1, e1-n, b2+n, e2)) return true;\\n            if (isit(s1, s2, e1-n, e1, e2-n, e2) && isit(s1, s2, b1, e1-n, b2, e2-n)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean isScramble(String s1, String s2) {\\n        return isit(s1.toCharArray(), s2.toCharArray(), 0, s1.length(), 0, s2.length());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29468,
                "title": "my-c-accepted-solution-in-6ms-little-change-in-normal-solution",
                "content": "i read some solutions, usually we will check every location [i] in s1 and s2 to see if they are splinted there.\\nIn that case, the process of [0~i] will be done when processing [i+1].\\nOn the other hand(is this sentence implies me Chinese ? 23333), s1 and s2 is scramble only in two ways:\\n\\n1. -----******** and -----********\\n\\n2. -----******** and ********-----\\n\\n so i check this and do recursion and resulting in 6ms\\n\\nhere is the code\\n\\n    bool work(string s1, string s2){\\n            // special case\\n            int len=s1.length();\\n            if(len==0 || s1==s2) return true;\\n            if(len==1 && s1!=s2) return false;\\n            if(len==2 && s1[0]==s2[1] && s1[1]==s2[0]) return true;\\n            \\n            // check for case s1 and s2 are divided as  -----******** and -----********\\n            // cnt stores the number of none zero numbers\\n            int sum[200],cnt=0,i;\\n            memset(sum,0,sizeof(sum));\\n            for(i=0;i<len;i++){\\n                sum[s1[i]]++;\\n                if(sum[s1[i]]==0) cnt--;\\n                else if(sum[s1[i]]==1) cnt++;\\n                \\n                sum[s2[i]]--;\\n                if(sum[s2[i]]==0) cnt--;\\n                else if(sum[s2[i]]==-1) cnt++;\\n                \\n                if(cnt==0) break;\\n            }\\n            \\n            i++;\\n            if(i<len && work(s1.substr(0,i),s2.substr(0,i)) && work(s1.substr(i),s2.substr(i)) ) return true;\\n            \\n            // check for case s1 and s2 are divided as  -----******** and ********_____\\n            memset(sum,0,sizeof(sum));\\n            cnt=0;\\n            for(i=0;i<len;i++){\\n                sum[s1[i]]++;\\n                if(sum[s1[i]]==0) cnt--;\\n                else if(sum[s1[i]]==1) cnt++;\\n                \\n                sum[s2[len-1-i]]--;\\n                if(sum[s2[len-1-i]]==0) cnt--;\\n                else if(sum[s2[len-1-i]]==-1) cnt++;\\n                \\n                if(cnt==0) break;\\n            }\\n            \\n            i++;\\n            if(i<len && work(s1.substr(0,i),s2.substr(len-i)) && work(s1.substr(i),s2.substr(0,len-i))) return true;\\n            \\n            return false;\\n        }\\n        bool isScramble(string s1, string s2) {\\n            int len=s1.length();\\n            int sum[200],i;\\n            memset(sum,0,sizeof(sum));\\n            for(i=0;i<len;i++){\\n                sum[s1[i]]++;\\n                sum[s2[i]]--;\\n            }\\n            for(i=0;i<200;i++)\\n            if(sum[i]!=0) return false;\\n            \\n            return work(s1,s2);\\n        }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "i read some solutions, usually we will check every location [i] in s1 and s2 to see if they are splinted there.\\nIn that case, the process of [0~i] will be done when processing [i+1].\\nOn the other hand(is this sentence implies me Chinese ? 23333), s1 and s2 is scramble only in two ways:\\n\\n1. -----******** and -----********\\n\\n2. -----******** and ********-----\\n\\n so i check this and do recursion and resulting in 6ms\\n\\nhere is the code\\n\\n    bool work(string s1, string s2){\\n            // special case\\n            int len=s1.length();\\n            if(len==0 || s1==s2) return true;\\n            if(len==1 && s1!=s2) return false;\\n            if(len==2 && s1[0]==s2[1] && s1[1]==s2[0]) return true;\\n            \\n            // check for case s1 and s2 are divided as  -----******** and -----********\\n            // cnt stores the number of none zero numbers\\n            int sum[200],cnt=0,i;\\n            memset(sum,0,sizeof(sum));\\n            for(i=0;i<len;i++){\\n                sum[s1[i]]++;\\n                if(sum[s1[i]]==0) cnt--;\\n                else if(sum[s1[i]]==1) cnt++;\\n                \\n                sum[s2[i]]--;\\n                if(sum[s2[i]]==0) cnt--;\\n                else if(sum[s2[i]]==-1) cnt++;\\n                \\n                if(cnt==0) break;\\n            }\\n            \\n            i++;\\n            if(i<len && work(s1.substr(0,i),s2.substr(0,i)) && work(s1.substr(i),s2.substr(i)) ) return true;\\n            \\n            // check for case s1 and s2 are divided as  -----******** and ********_____\\n            memset(sum,0,sizeof(sum));\\n            cnt=0;\\n            for(i=0;i<len;i++){\\n                sum[s1[i]]++;\\n                if(sum[s1[i]]==0) cnt--;\\n                else if(sum[s1[i]]==1) cnt++;\\n                \\n                sum[s2[len-1-i]]--;\\n                if(sum[s2[len-1-i]]==0) cnt--;\\n                else if(sum[s2[len-1-i]]==-1) cnt++;\\n                \\n                if(cnt==0) break;\\n            }\\n            \\n            i++;\\n            if(i<len && work(s1.substr(0,i),s2.substr(len-i)) && work(s1.substr(i),s2.substr(0,len-i))) return true;\\n            \\n            return false;\\n        }\\n        bool isScramble(string s1, string s2) {\\n            int len=s1.length();\\n            int sum[200],i;\\n            memset(sum,0,sizeof(sum));\\n            for(i=0;i<len;i++){\\n                sum[s1[i]]++;\\n                sum[s2[i]]--;\\n            }\\n            for(i=0;i<200;i++)\\n            if(sum[i]!=0) return false;\\n            \\n            return work(s1,s2);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3614569,
                "title": "aditya-verma-approach-recursive-memoization",
                "content": "\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    unordered_map<string, bool> mp;\\n    bool isScramble(string s1, string s2)\\n    {\\n        int n = s1.size();\\n        if (n != s2.size())\\n            return false;\\n        if (s1.compare(s2) == 0)\\n            return true;\\n        if (mp.find(s1 + \" \" + s2) != mp.end())\\n            return mp[s1 + \" \" + s2];\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\\n                return mp[s1 + \" \" + s2] = true;\\n            if (isScramble(s1.substr(0, i), s2.substr(n - i)) && isScramble(s1.substr(i), s2.substr(0, n - i)))\\n                return mp[s1 + \" \" + s2] = true;\\n        }\\n        return mp[s1 + \" \" + s2] = false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    unordered_map<string, bool> mp;\\n    bool isScramble(string s1, string s2)\\n    {\\n        int n = s1.size();\\n        if (n != s2.size())\\n            return false;\\n        if (s1.compare(s2) == 0)\\n            return true;\\n        if (mp.find(s1 + \" \" + s2) != mp.end())\\n            return mp[s1 + \" \" + s2];\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\\n                return mp[s1 + \" \" + s2] = true;\\n            if (isScramble(s1.substr(0, i), s2.substr(n - i)) && isScramble(s1.substr(i), s2.substr(0, n - i)))\\n                return mp[s1 + \" \" + s2] = true;\\n        }\\n        return mp[s1 + \" \" + s2] = false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3360312,
                "title": "python-shortest-2-liner-dp-functional-programming",
                "content": "# Approach\\nTL;DR, Same as [Editorial solution](https://leetcode.com/problems/scramble-string/editorial/) but written in a functional way.\\n\\n# Complexity\\n- Time complexity: $$O(n^4)$$\\n\\n- Space complexity: $$O(n^3)$$\\n\\nwhere, `n is length of s1 or s2`.\\n\\n# Code\\n2-liner (Not readable):\\n```python\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def is_scramble(i: int, j: int, n: int) -> bool: return any((is_scramble(i, j, k) and is_scramble(i + k, j + k, n - k)) or (is_scramble(i, j + n - k, k) and is_scramble(i + k, j, n - k)) for k in range(1, n)) if n > 1 else s1[i] == s2[j]\\n        return is_scramble(0, 0, len(s1))\\n\\n\\n```\\nMulti-liner (More Readable):\\n```python\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def is_scramble(i: int, j: int, n: int) -> bool:            \\n            return any(\\n                (is_scramble(i, j        , k) and is_scramble(i + k, j + k, n - k)) or\\n                (is_scramble(i, j + n - k, k) and is_scramble(i + k, j    , n - k))\\n                for k in range(1, n)\\n            ) if n > 1 else s1[i] == s2[j]\\n        \\n        return is_scramble(0, 0, len(s1))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def is_scramble(i: int, j: int, n: int) -> bool: return any((is_scramble(i, j, k) and is_scramble(i + k, j + k, n - k)) or (is_scramble(i, j + n - k, k) and is_scramble(i + k, j, n - k)) for k in range(1, n)) if n > 1 else s1[i] == s2[j]\\n        return is_scramble(0, 0, len(s1))\\n\\n\\n```\n```python\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def is_scramble(i: int, j: int, n: int) -> bool:            \\n            return any(\\n                (is_scramble(i, j        , k) and is_scramble(i + k, j + k, n - k)) or\\n                (is_scramble(i, j + n - k, k) and is_scramble(i + k, j    , n - k))\\n                for k in range(1, n)\\n            ) if n > 1 else s1[i] == s2[j]\\n        \\n        return is_scramble(0, 0, len(s1))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360256,
                "title": "memoization-dp-c",
                "content": "```\\nclass Solution {\\n    bool dfs(string s, string t, unordered_map<string, bool> &dp) {\\n        if(s == t) return true;\\n        if(dp.find(s + \" \" + t) != dp.end()) return dp[s + \" \" + t];\\n\\n        int n = s.size();\\n        for(int k=1; k<n; k++) {\\n            bool notswap = dfs(s.substr(0, k), t.substr(0, k), dp) && dfs(s.substr(k), t.substr(k), dp);\\n            bool swap = dfs(s.substr(0, k), t.substr(n - k), dp) && dfs(s.substr(k), t.substr(0, n - k), dp);\\n            if(swap || notswap) return dp[s + \" \" + t] = true;\\n        }\\n        return dp[s + \" \" + t] = false;\\n    }\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string, bool> dp;\\n        return dfs(s1, s2, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(string s, string t, unordered_map<string, bool> &dp) {\\n        if(s == t) return true;\\n        if(dp.find(s + \" \" + t) != dp.end()) return dp[s + \" \" + t];\\n\\n        int n = s.size();\\n        for(int k=1; k<n; k++) {\\n            bool notswap = dfs(s.substr(0, k), t.substr(0, k), dp) && dfs(s.substr(k), t.substr(k), dp);\\n            bool swap = dfs(s.substr(0, k), t.substr(n - k), dp) && dfs(s.substr(k), t.substr(0, n - k), dp);\\n            if(swap || notswap) return dp[s + \" \" + t] = true;\\n        }\\n        return dp[s + \" \" + t] = false;\\n    }\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string, bool> dp;\\n        return dfs(s1, s2, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360121,
                "title": "c-solution-using-memoization",
                "content": "\\nclass Solution {\\npublic:\\n\\n    bool isScramblee(string s1, string s2, unordered_map<string,bool>&mpp) {\\n        if(s1.compare(s2)==0){\\n            return true;\\n        }\\n        if(s1.length()<=1){\\n            return false;\\n        }\\n       \\n        string key=s1;\\n        key.push_back(\\' \\');\\n        key.append(s2);\\n        if(mpp.find(key)!=mpp.end()){\\n            return mpp[key];\\n        }\\n        int n=s1.size();\\n         bool flag=false;\\n        for(int i=1; i<=n-1; i++){\\n            bool cond1=isScramblee(s1.substr(0,i), s2.substr(n-i,i), mpp)&& isScramblee(s1.substr(i,n-1), s2.substr(0,n-i), mpp);\\n            bool cond2=isScramblee(s1.substr(0,i), s2.substr(0,i), mpp)&& isScramblee(s1.substr(i,n-i), s2.substr(i,n-i), mpp);\\n            if(cond1||cond2){\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return mpp[key]=flag;\\n    }\\n    bool isScramble(string s1, string s2){\\n        unordered_map<string, bool> mpp;\\n        int n=s1.size();\\n        return isScramblee(s1,s2,mpp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isScramblee(string s1, string s2, unordered_map<string,bool>&mpp) {\\n        if(s1.compare(s2)==0){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3359916,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> mp;\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.size();\\n        if(s1 == s2) return true;   \\n        if(n == 1) return false;\\n        string key = s1+\" \"+s2;\\n        if(mp.find(key)!=mp.end()) return mp[key];\\n        for(int i=1; i<n; i++) {\\n            if(isScramble(s1.substr(0, i), s2.substr(0, i)) and isScramble(s1.substr(i), s2.substr(i)))\\n                return mp[key] = true;\\n            if(isScramble(s1.substr(0, i), s2.substr(n - i)) and isScramble(s1.substr(i), s2.substr(0, n-i)))\\n                return mp[key] = true;\\n        }\\n        return mp[key] = false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> mp;\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.size();\\n        if(s1 == s2) return true;   \\n        if(n == 1) return false;\\n        string key = s1+\" \"+s2;\\n        if(mp.find(key)!=mp.end()) return mp[key];\\n        for(int i=1; i<n; i++) {\\n            if(isScramble(s1.substr(0, i), s2.substr(0, i)) and isScramble(s1.substr(i), s2.substr(i)))\\n                return mp[key] = true;\\n            if(isScramble(s1.substr(0, i), s2.substr(n - i)) and isScramble(s1.substr(i), s2.substr(0, n-i)))\\n                return mp[key] = true;\\n        }\\n        return mp[key] = false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359519,
                "title": "beginner-friendly-easy-recursion-dp-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe will break our main string into all possible outcomes ==>>\\ni.e abc ==>> a bc or ab c\\nthen we will try to swap positions of those parts and check all possible outcomes, hence we will use dp (memoizaiton) for that;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmemoization\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[30][30][30][30];\\n    bool helper(string one, string two, int i1, int j1, int i2, int j2){\\n        if(dp[i1][j1][i2][j2] != -1) return dp[i1][j1][i2][j2];\\n        bool counter = true;\\n        for(int i = i1, j = i2; i <= j1 && j <= j2; i++, j++){\\n            if(one[i] != two[j]) counter = false;\\n        }\\n        if(counter) return dp[i1][j1][i2][j2] = true;\\n        for(int i = i1; i < j1; i++){\\n            if(helper(one, two, i1, i, j2 - (i - i1), j2) && helper(one, two, i + 1, j1, i2, j2 - (i - i1) - 1)) return dp[i1][j1][i2][j2] = true;\\n            if(helper(one, two, i1, i, i2, i2 + (i - i1)) && helper(one, two, i + 1, j1, i2 + (i - i1) + 1, j2)) return dp[i1][j1][i2][j2] = true;\\n        }\\n        return dp[i1][j1][i2][j2] = false;\\n    }\\n\\n    bool isScramble(string s1, string s2) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(s1, s2, 0, s1.size() - 1, 0, s2.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[30][30][30][30];\\n    bool helper(string one, string two, int i1, int j1, int i2, int j2){\\n        if(dp[i1][j1][i2][j2] != -1) return dp[i1][j1][i2][j2];\\n        bool counter = true;\\n        for(int i = i1, j = i2; i <= j1 && j <= j2; i++, j++){\\n            if(one[i] != two[j]) counter = false;\\n        }\\n        if(counter) return dp[i1][j1][i2][j2] = true;\\n        for(int i = i1; i < j1; i++){\\n            if(helper(one, two, i1, i, j2 - (i - i1), j2) && helper(one, two, i + 1, j1, i2, j2 - (i - i1) - 1)) return dp[i1][j1][i2][j2] = true;\\n            if(helper(one, two, i1, i, i2, i2 + (i - i1)) && helper(one, two, i + 1, j1, i2 + (i - i1) + 1, j2)) return dp[i1][j1][i2][j2] = true;\\n        }\\n        return dp[i1][j1][i2][j2] = false;\\n    }\\n\\n    bool isScramble(string s1, string s2) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(s1, s2, 0, s1.size() - 1, 0, s2.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358472,
                "title": "q87-accepted-c-dp-top-down-rec-memoization-simplest",
                "content": "Top-Down Approach (Recursion + Stored Values)\\nCRUX:\\n1) Considering the given Condition to be a Scrambled String.\\n2) Non-empty nodes.\\n3) Swapping Considering.\\n4) Without Swapping\\n```\\nclass Solution {\\npublic:\\n    bool solve(string a, string b,unordered_map <string,bool> &mp){\\n        if(a==b) // Base Condition which are possible\\n            return true;  \\n        int n=a.size();\\n        if(n<=1)\\n            return false;\\n\\t\\n        string s=a;\\n        s+=b;\\n        if(mp.find(s)!=mp.end())\\n            return mp[s]; //If already present then return the previously calculated bool Value\\n        bool flag=false;\\n        for(int i=1;i<=n-1;i++){\\n            bool c1=(solve(a.substr(0,i),b.substr(n-i,i),mp) && \\n                     solve(a.substr(i,n-i),b.substr(0,n-i),mp)); // Considering Swapping\\n            bool c2=(solve(a.substr(0,i),b.substr(0,i),mp) && \\n                     solve(a.substr(i,n-i),b.substr(i,n-i),mp)); // Not considering Swapping\\n            if(c1 || c2){ // If any of the Condition 1 OR 2 is TRUE return TRUE else return FALSE\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return mp[s]=flag; // Storing the value of \"s\" = a+b  \\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1==s2)\\n            return true; //No Need to check\\n        unordered_map <string,bool> mp; // To store the various string\\'s that are generated\\n        return solve(s1,s2,mp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(string a, string b,unordered_map <string,bool> &mp){\\n        if(a==b) // Base Condition which are possible\\n            return true;  \\n        int n=a.size();\\n        if(n<=1)\\n            return false;\\n\\t\\n        string s=a;\\n        s+=b;\\n        if(mp.find(s)!=mp.end())\\n            return mp[s]; //If already present then return the previously calculated bool Value\\n        bool flag=false;\\n        for(int i=1;i<=n-1;i++){\\n            bool c1=(solve(a.substr(0,i),b.substr(n-i,i),mp) && \\n                     solve(a.substr(i,n-i),b.substr(0,n-i),mp)); // Considering Swapping\\n            bool c2=(solve(a.substr(0,i),b.substr(0,i),mp) && \\n                     solve(a.substr(i,n-i),b.substr(i,n-i),mp)); // Not considering Swapping\\n            if(c1 || c2){ // If any of the Condition 1 OR 2 is TRUE return TRUE else return FALSE\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return mp[s]=flag; // Storing the value of \"s\" = a+b  \\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1==s2)\\n            return true; //No Need to check\\n        unordered_map <string,bool> mp; // To store the various string\\'s that are generated\\n        return solve(s1,s2,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358230,
                "title": "ruby-memoization",
                "content": "\\n# Code\\n```\\ndef is_scramble(s1, s2)\\n  memo = {}\\n  memo_is_scramble(s1, s2, memo)\\nend\\n\\ndef memo_is_scramble(s1, s2, memo = {})\\n  return true if s1 == s2\\n  return false if s1.length != s2.length\\n  \\n  return memo[[s1, s2]] if memo.key?([s1, s2])\\n  \\n  count = Array.new(26, 0)\\n  (0...s1.length).each do |i|\\n    count[s1[i].ord - \\'a\\'.ord] += 1\\n    count[s2[i].ord - \\'a\\'.ord] -= 1\\n  end\\n  return false if count.any? { |c| c != 0 }\\n  \\n  (1...s1.length).each do |i|\\n    if (memo_is_scramble(s1[0...i], s2[0...i], memo) && memo_is_scramble(s1[i..-1], s2[i..-1], memo)) ||\\n       (memo_is_scramble(s1[0...i], s2[-i..-1], memo) && memo_is_scramble(s1[i..-1], s2[0...s2.length-i], memo))\\n      memo[[s1, s2]] = true\\n      return true\\n    end\\n  end\\n\\n  memo[[s1, s2]] = false\\n  false\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef is_scramble(s1, s2)\\n  memo = {}\\n  memo_is_scramble(s1, s2, memo)\\nend\\n\\ndef memo_is_scramble(s1, s2, memo = {})\\n  return true if s1 == s2\\n  return false if s1.length != s2.length\\n  \\n  return memo[[s1, s2]] if memo.key?([s1, s2])\\n  \\n  count = Array.new(26, 0)\\n  (0...s1.length).each do |i|\\n    count[s1[i].ord - \\'a\\'.ord] += 1\\n    count[s2[i].ord - \\'a\\'.ord] -= 1\\n  end\\n  return false if count.any? { |c| c != 0 }\\n  \\n  (1...s1.length).each do |i|\\n    if (memo_is_scramble(s1[0...i], s2[0...i], memo) && memo_is_scramble(s1[i..-1], s2[i..-1], memo)) ||\\n       (memo_is_scramble(s1[0...i], s2[-i..-1], memo) && memo_is_scramble(s1[i..-1], s2[0...s2.length-i], memo))\\n      memo[[s1, s2]] = true\\n      return true\\n    end\\n  end\\n\\n  memo[[s1, s2]] = false\\n  false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3358020,
                "title": "explained-through-comments-recursion-memoization",
                "content": "**class Solution {\\npublic:\\n    \\n    map<pair<string,string>,bool> mp;\\n    \\n    bool dos(string s1,string s2){\\n        \\n        if(s1==s2){      //if strings are equal return true;\\n            return 1;\\n        }\\n        if(s1.size()==1){  //this line will be executed when above statement is not true\\n            return 0;       // so if length of s1 and s2 is 1 and they are not equal return false\\n        }\\n        if(mp.find({s1,s2})!=mp.end()){ //map to memoize, stored as pairs, if found no need to go further.\\n            return mp[{s1,s2}];\\n        }\\n        int n=s1.size();\\n        \\n        //Now we will compare by partioning the string at each i,1,2,3,...n-1.\\n        // and check if after flipping or without flipping both strings are equal or not.\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            //when there is no flip left part of first string will be compared by left part of second string\\n            // and right part of first string will be compared by right part of second string\\n            \\n            bool no_flip=dos(s1.substr(0,i),s2.substr(0,i))&&dos(s1.substr(i),s2.substr(i));\\n            \\n            //if it comes out to true store it in map;\\n            if(no_flip){\\n                return mp[{s1,s2}]=1;   \\n            }\\n            \\n            //when there is flip left part of first string will be compared to right part of second string;\\n            //and right part of second string will be compared with left part of second string.\\n            \\n            bool flip=dos(s1.substr(0,i),s2.substr(n-i))&&dos(s1.substr(i),s2.substr(0,n-i));\\n            if(flip){\\n               return mp[{s1,s2}]=1;\\n            }\\n            // NOTE: we are not executing else part as it may happen that after further partioning \\n            //they come out to be equal\\n            \\n           \\n        }\\n        return mp[{s1,s2}]=0;\\n    }\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        return dos(s1,s2);\\n    }\\n};**\\n**UPVOTE IF YOU UNDERSTOOD ,NO MEMER CAT PHOTO AVAILABLE :)**",
                "solutionTags": [
                    "String",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    map<pair<string,string>,bool> mp;\\n    \\n    bool dos(string s1,string s2){\\n        \\n        if(s1==s2){      //if strings are equal return true;\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3357711,
                "title": "java-runtime-3-ms-beats-100-memory-42-5-mb-beats-84-62",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Map<String, Boolean> mem = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        var hash = s1 + s2;\\n        if (!mem.containsKey(hash)) {\\n            mem.put(hash, is(s1, s2));\\n        }\\n        return mem.get(hash);\\n    }\\n\\n    private boolean is(String s1, String s2) {\\n        if (s1.equals(s2))\\n            return true;\\n        int[] count = new int[26];\\n        int[] countF = new int[26];\\n        int[] countB = new int[26];\\n        for (int i = 0; i < s1.length() - 1; i++) {\\n            int j = s2.length() - 1 - i;\\n            count[s1.charAt(i) - \\'a\\'] += 1;\\n            countF[s2.charAt(i) - \\'a\\'] += 1;\\n            countB[s2.charAt(j) - \\'a\\'] += 1;\\n            if (Arrays.equals(count, countF)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(0, i + 1)) && isScramble(s1.substring(i + 1), s2.substring(i + 1)))\\n                    return true;\\n            }\\n            if (Arrays.equals(count, countB)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(j)) && isScramble(s1.substring(i + 1), s2.substring(0, j)))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Boolean> mem = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        var hash = s1 + s2;\\n        if (!mem.containsKey(hash)) {\\n            mem.put(hash, is(s1, s2));\\n        }\\n        return mem.get(hash);\\n    }\\n\\n    private boolean is(String s1, String s2) {\\n        if (s1.equals(s2))\\n            return true;\\n        int[] count = new int[26];\\n        int[] countF = new int[26];\\n        int[] countB = new int[26];\\n        for (int i = 0; i < s1.length() - 1; i++) {\\n            int j = s2.length() - 1 - i;\\n            count[s1.charAt(i) - \\'a\\'] += 1;\\n            countF[s2.charAt(i) - \\'a\\'] += 1;\\n            countB[s2.charAt(j) - \\'a\\'] += 1;\\n            if (Arrays.equals(count, countF)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(0, i + 1)) && isScramble(s1.substring(i + 1), s2.substring(i + 1)))\\n                    return true;\\n            }\\n            if (Arrays.equals(count, countB)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(j)) && isScramble(s1.substring(i + 1), s2.substring(0, j)))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216238,
                "title": "beats-98-java-code",
                "content": "# Java Code\\n```\\nclass Solution {\\n    Map<String, Boolean> mem = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        var hash = s1 + s2;\\n        if (!mem.containsKey(hash)) {\\n            mem.put(hash, is(s1, s2));\\n        }\\n        return mem.get(hash);\\n    }\\n\\n    private boolean is(String s1, String s2) {\\n        if (s1.equals(s2))\\n            return true;\\n        int[] count = new int[26];\\n        int[] countF = new int[26];\\n        int[] countB = new int[26];\\n        for (int i = 0; i < s1.length() - 1; i++) {\\n            int j = s2.length() - 1 - i;\\n            count[s1.charAt(i) - \\'a\\'] += 1;\\n            countF[s2.charAt(i) - \\'a\\'] += 1;\\n            countB[s2.charAt(j) - \\'a\\'] += 1;\\n            if (Arrays.equals(count, countF)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(0, i + 1)) && isScramble(s1.substring(i + 1), s2.substring(i + 1)))\\n                    return true;\\n            }\\n            if (Arrays.equals(count, countB)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(j)) && isScramble(s1.substring(i + 1), s2.substring(0, j)))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Boolean> mem = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        var hash = s1 + s2;\\n        if (!mem.containsKey(hash)) {\\n            mem.put(hash, is(s1, s2));\\n        }\\n        return mem.get(hash);\\n    }\\n\\n    private boolean is(String s1, String s2) {\\n        if (s1.equals(s2))\\n            return true;\\n        int[] count = new int[26];\\n        int[] countF = new int[26];\\n        int[] countB = new int[26];\\n        for (int i = 0; i < s1.length() - 1; i++) {\\n            int j = s2.length() - 1 - i;\\n            count[s1.charAt(i) - \\'a\\'] += 1;\\n            countF[s2.charAt(i) - \\'a\\'] += 1;\\n            countB[s2.charAt(j) - \\'a\\'] += 1;\\n            if (Arrays.equals(count, countF)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(0, i + 1)) && isScramble(s1.substring(i + 1), s2.substring(i + 1)))\\n                    return true;\\n            }\\n            if (Arrays.equals(count, countB)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(j)) && isScramble(s1.substring(i + 1), s2.substring(0, j)))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192690,
                "title": "recursive-top-down",
                "content": "# Intuition\\n```C++ []\\n// recursive approach - gives TLE\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool scramble(string s, string t){\\n        int n= s.size();\\n\\n        if(s==t)\\n            return true;\\n        vector<int> cnt(26,0);\\n        for(int i=0; i<n; i++)\\n            cnt[s[i]-\\'a\\']++, cnt[t[i]-\\'a\\']--;\\n\\n        for(int i=0; i<26; i++)\\n            if( cnt[i] )\\n                return false;\\n\\n        // s=gr|eat  t=gr|eat   (not scrambled)\\n        // s=gr|eat  t=ate|gr   (scrambled)\\n        for(int len=1; len<n; len++){\\n           \\n            if( scramble(s.substr(0,len), t.substr(0,len)) and scramble(s.substr(len), t.substr(len)))\\n                return true;\\n            if( scramble(s.substr(0,len), t.substr(n-len)) and scramble(s.substr(len), t.substr(0,n-len)))\\n                return true;\\n        }        \\n        return false;\\n    }\\n    bool isScramble(string s, string t) {\\n\\n        return scramble(s,t);\\n    }\\n};\\n```\\n```C++ []\\n// recursive approach + dp = top-down \\n// AC cheers\\n\\nclass Solution {\\n   map<pair<string,string>, bool> dp;\\npublic:\\n   \\n    \\n    bool scramble(string s, string t){\\n        int n= s.size();\\n        pair<string , string> combo= make_pair(s,t);\\n\\n        if( dp.count(combo)  != 0)\\n            return dp[combo];\\n        if(s==t)\\n            return true;\\n        vector<int> cnt(26,0);\\n        for(int i=0; i<n; i++)\\n            cnt[s[i]-\\'a\\']++, cnt[t[i]-\\'a\\']--;\\n\\n        for(int i=0; i<26; i++)\\n            if( cnt[i] )\\n                return false;\\n\\n        // s=gr|eat  t=gr|eat   (not scrambled)\\n        // s=gr|eat  t=ate|gr   (scrambled)\\n        \\n        for(int len=1; len<n; len++){\\n           \\n            if( scramble(s.substr(0,len), t.substr(0,len)) and scramble(s.substr(len), t.substr(len))  \\n|| scramble(s.substr(0,len), t.substr(n-len)) and scramble(s.substr(len), t.substr(0,n-len))){\\n                \\n                return dp[combo]=true;\\n            }\\n                \\n        }        \\n        return dp[combo]=false;\\n    }\\n    bool isScramble(string s, string t) {\\n\\n        return scramble(s,t);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\n// recursive approach - gives TLE\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool scramble(string s, string t){\\n        int n= s.size();\\n\\n        if(s==t)\\n            return true;\\n        vector<int> cnt(26,0);\\n        for(int i=0; i<n; i++)\\n            cnt[s[i]-\\'a\\']++, cnt[t[i]-\\'a\\']--;\\n\\n        for(int i=0; i<26; i++)\\n            if( cnt[i] )\\n                return false;\\n\\n        // s=gr|eat  t=gr|eat   (not scrambled)\\n        // s=gr|eat  t=ate|gr   (scrambled)\\n        for(int len=1; len<n; len++){\\n           \\n            if( scramble(s.substr(0,len), t.substr(0,len)) and scramble(s.substr(len), t.substr(len)))\\n                return true;\\n            if( scramble(s.substr(0,len), t.substr(n-len)) and scramble(s.substr(len), t.substr(0,n-len)))\\n                return true;\\n        }        \\n        return false;\\n    }\\n    bool isScramble(string s, string t) {\\n\\n        return scramble(s,t);\\n    }\\n};\\n```\n```C++ []\\n// recursive approach + dp = top-down \\n// AC cheers\\n\\nclass Solution {\\n   map<pair<string,string>, bool> dp;\\npublic:\\n   \\n    \\n    bool scramble(string s, string t){\\n        int n= s.size();\\n        pair<string , string> combo= make_pair(s,t);\\n\\n        if( dp.count(combo)  != 0)\\n            return dp[combo];\\n        if(s==t)\\n            return true;\\n        vector<int> cnt(26,0);\\n        for(int i=0; i<n; i++)\\n            cnt[s[i]-\\'a\\']++, cnt[t[i]-\\'a\\']--;\\n\\n        for(int i=0; i<26; i++)\\n            if( cnt[i] )\\n                return false;\\n\\n        // s=gr|eat  t=gr|eat   (not scrambled)\\n        // s=gr|eat  t=ate|gr   (scrambled)\\n        \\n        for(int len=1; len<n; len++){\\n           \\n            if( scramble(s.substr(0,len), t.substr(0,len)) and scramble(s.substr(len), t.substr(len))  \\n|| scramble(s.substr(0,len), t.substr(n-len)) and scramble(s.substr(len), t.substr(0,n-len))){\\n                \\n                return dp[combo]=true;\\n            }\\n                \\n        }        \\n        return dp[combo]=false;\\n    }\\n    bool isScramble(string s, string t) {\\n\\n        return scramble(s,t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742089,
                "title": "memorized-map-dp-reference-4d-dp-c",
                "content": "**coder , ocder , ocred are scrambled strings**\\n\\ndivide string in two parts , co | der  and oc | der , **der equal so cancel out**\\n\\nc | o , o | c \\n\\nwhile returing , we can swap while combining \\n\\nso c|o becomes , oc  and coder becomes scrambled with\\n\\n**Below are the scrambled strings decomposition**\\n\\n![image.jpg](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/857517ed-ea18-4e05-93c0-8c73d1a973ef/image.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221025%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221025T095829Z&X-Amz-Expires=86400&X-Amz-Signature=ac975287b5f6289c7085d73f3aee0c3623bea59c6ccd073ae16cb535a755165d&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22image.jpg%22&x-id=GetObject)\\n\\n\\nLOGIC : divide string in two parts , \\n\\n1. take L1 from beginning of s1 and s2 , and remaining\\n2. take L1 from beginning of s1 and L1 from end of s2 ( as we can swap values while returing )\\n\\n```cpp\\nunordered_map<string,bool> dp;\\n    bool isScramble(string a, string b) {\\n        if(size(a)!=size(b)) return false;\\n        int n=size(a);\\n        string s=a+\" \"+b;\\n        if(dp.count(s)) return dp[s];\\n        if(a==b) return dp[s]=true;\\n        for(int len=1;len<n;len++){\\n            bool ans=isScramble(a.substr(0,len),b.substr(0,len)) and isScramble(a.substr(len),b.substr(len));\\n            if(ans) return dp[s]=true;\\n            ans=isScramble(a.substr(0,len),b.substr(n-len)) and isScramble(a.substr(len),b.substr(0,n-len));\\n            if(ans) return dp[s]=true;\\n        }\\n        return dp[s]=false;\\n    }\\n```\\n\\nIf take reference of strings and indices\\n\\n```cpp\\nint dp[31][31][31][31];\\n    \\n    // e-s+1=len\\n    // e=len+s-1\\n    // s=e+1-len\\n\\t\\n    bool isScramble(string &a, string &b , int s1 , int e1 , int s2 , int e2) {\\n        int len1=e1-s1+1,len2=e2-s2+1;\\n        if(len1!=len2) return false;\\n        if(dp[s1][e1][s2][e2]!=-1) return dp[s1][e1][s2][e2];\\n        if(a.substr(s1,len1)==b.substr(s2,len2)) return true;\\n        for(int len=1;len<len1;len++){\\n            bool ans=isScramble(a,b,s1,s1+len-1,s2,s2+len-1) and isScramble(a,b,s1+len,e1,s2+len,e2);\\n            if(ans) return dp[s1][e1][s2][e2]=true;\\n            ans=isScramble(a,b,s1,s1+len-1,e2+1-len,e2) and isScramble(a,b,s1+len,e1,s2,e2-len);\\n            if(ans) return dp[s1][e1][s2][e2]=true;\\n        }\\n        return dp[s1][e1][s2][e2]=false;\\n    }\\n    bool isScramble(string s1, string s2){\\n        memset(dp,-1,sizeof dp);\\n        return isScramble(s1,s2,0,size(s1)-1,0,size(s2)-1);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nunordered_map<string,bool> dp;\\n    bool isScramble(string a, string b) {\\n        if(size(a)!=size(b)) return false;\\n        int n=size(a);\\n        string s=a+\" \"+b;\\n        if(dp.count(s)) return dp[s];\\n        if(a==b) return dp[s]=true;\\n        for(int len=1;len<n;len++){\\n            bool ans=isScramble(a.substr(0,len),b.substr(0,len)) and isScramble(a.substr(len),b.substr(len));\\n            if(ans) return dp[s]=true;\\n            ans=isScramble(a.substr(0,len),b.substr(n-len)) and isScramble(a.substr(len),b.substr(0,n-len));\\n            if(ans) return dp[s]=true;\\n        }\\n        return dp[s]=false;\\n    }\\n```\n```cpp\\nint dp[31][31][31][31];\\n    \\n    // e-s+1=len\\n    // e=len+s-1\\n    // s=e+1-len\\n\\t\\n    bool isScramble(string &a, string &b , int s1 , int e1 , int s2 , int e2) {\\n        int len1=e1-s1+1,len2=e2-s2+1;\\n        if(len1!=len2) return false;\\n        if(dp[s1][e1][s2][e2]!=-1) return dp[s1][e1][s2][e2];\\n        if(a.substr(s1,len1)==b.substr(s2,len2)) return true;\\n        for(int len=1;len<len1;len++){\\n            bool ans=isScramble(a,b,s1,s1+len-1,s2,s2+len-1) and isScramble(a,b,s1+len,e1,s2+len,e2);\\n            if(ans) return dp[s1][e1][s2][e2]=true;\\n            ans=isScramble(a,b,s1,s1+len-1,e2+1-len,e2) and isScramble(a,b,s1+len,e1,s2,e2-len);\\n            if(ans) return dp[s1][e1][s2][e2]=true;\\n        }\\n        return dp[s1][e1][s2][e2]=false;\\n    }\\n    bool isScramble(string s1, string s2){\\n        memset(dp,-1,sizeof dp);\\n        return isScramble(s1,s2,0,size(s1)-1,0,size(s2)-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2495569,
                "title": "c-recursion-memoization-map",
                "content": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    \\n    bool solve(string s1, string s2 , unordered_map<string , bool> &mp){\\n        //base case\\n        if( s1.compare(s2) == 0 ) // if strings are same\\n            return true;\\n        \\n        if( s1.size() <= 1 )  \\n            return false;  \\n        \\n        // memoization step\\n        string key = s1 + \\':\\' + s2;\\n        if( mp.find(key) != mp.end() )\\n            return mp[key];\\n        \\n        int n = s1.size();\\n        bool flag = false;\\n        \\n        for( int i=1 ; i<=n-1 ; i++ ){\\n            bool cond1 = solve( s1.substr(0,i) , s2.substr(n-i,i) , mp) == true  &&\\n                         solve( s1.substr(i,n-i) , s2.substr(0,n-i) , mp) == true;\\n             \\n            bool cond2 = solve( s1.substr(0,i) , s2.substr(0,i) , mp) == true  &&\\n                         solve( s1.substr(i,n-i) , s2.substr(i,n-i) , mp) == true;\\n                \\n                \\n            if( cond1 || cond2 ){\\n                flag = true;\\n                break;\\n            }\\n        }\\n        \\n        return mp[key] = flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if( s1.size() != s2.size() )\\n            return false;\\n        \\n        if( s1.empty() && s2.empty() )\\n            return true;\\n                \\n        // using map for memoization\\n        unordered_map<string , bool> mp;\\n        \\n        return solve(s1,s2,mp);\\n    }\\n\\t};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n    bool solve(string s1, string s2 , unordered_map<string , bool> &mp){\\n        //base case\\n        if( s1.compare(s2) == 0 ) // if strings are same\\n            return true;\\n        \\n        if( s1.size() <= 1 )  \\n            return false;  \\n        \\n        // memoization step\\n        string key = s1 + \\':\\' + s2;\\n        if( mp.find(key) != mp.end() )\\n            return mp[key];\\n        \\n        int n = s1.size();\\n        bool flag = false;\\n        \\n        for( int i=1 ; i<=n-1 ; i++ ){\\n            bool cond1 = solve( s1.substr(0,i) , s2.substr(n-i,i) , mp) == true  &&\\n                         solve( s1.substr(i,n-i) , s2.substr(0,n-i) , mp) == true;\\n             \\n            bool cond2 = solve( s1.substr(0,i) , s2.substr(0,i) , mp) == true  &&\\n                         solve( s1.substr(i,n-i) , s2.substr(i,n-i) , mp) == true;\\n                \\n                \\n            if( cond1 || cond2 ){\\n                flag = true;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2416827,
                "title": "c-solution-with-0ms-runtime",
                "content": "# C++ Solution with 0ms runtime\\n## KINDLY UPVOTE IF YOU ATTAINED 0ms RUNTIME\\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        int n = s1.size();\\n        if (n == 1) return s1[0] == s2[0];\\n        int p1 = -1, p2 = -1;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += s1[i] * s1[i] - s2[i] * s2[i];\\n            sum2 += s1[i] * s1[i] - s2[n - 1 - i] * s2[n - 1 - i];\\n            if (sum1 == 0 && i != n-1) p1 = i;\\n            if (sum2 == 0 && i != n-1) p2 = i;\\n\\t\\t\\t//SOLUTION BY Yaduttam95\\n        }\\n        int a = 0, b = 0;\\n        if (p1 != -1) a = isScramble(s1.substr(0, p1 + 1), s2.substr(0, p1 + 1)) && isScramble(s1.substr(p1 + 1, n - p1 - 1 ), s2.substr(p1 + 1, n - p1 - 1));\\n        if (p2 != -1) b = isScramble(s1.substr(0, p2 + 1), s2.substr(n - p2 - 1, p2 + 1)) && isScramble(s1.substr(p2 + 1, n - p2 - 1), s2.substr(0, n - p2 - 1));\\n        return a || b;\\n    }\\n};\\n```\\n\\nSOLUTION BY [Yaduttam95](https://github.com/Yaduttam95)\\n\\n#### IF YOU HAVE READ TILL HERE PLEASE UPVOTE THE SOLUTION",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        int n = s1.size();\\n        if (n == 1) return s1[0] == s2[0];\\n        int p1 = -1, p2 = -1;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += s1[i] * s1[i] - s2[i] * s2[i];\\n            sum2 += s1[i] * s1[i] - s2[n - 1 - i] * s2[n - 1 - i];\\n            if (sum1 == 0 && i != n-1) p1 = i;\\n            if (sum2 == 0 && i != n-1) p2 = i;\\n\\t\\t\\t//SOLUTION BY Yaduttam95\\n        }\\n        int a = 0, b = 0;\\n        if (p1 != -1) a = isScramble(s1.substr(0, p1 + 1), s2.substr(0, p1 + 1)) && isScramble(s1.substr(p1 + 1, n - p1 - 1 ), s2.substr(p1 + 1, n - p1 - 1));\\n        if (p2 != -1) b = isScramble(s1.substr(0, p2 + 1), s2.substr(n - p2 - 1, p2 + 1)) && isScramble(s1.substr(p2 + 1, n - p2 - 1), s2.substr(0, n - p2 - 1));\\n        return a || b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351236,
                "title": "python-3-solution",
                "content": "![image](https://assets.leetcode.com/users/images/4a282e89-ca03-4292-bfb6-95ebbc143249_1659108310.814036.png)\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.map = {}\\n\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if (s1, s2) in self.map:\\n            return self.map[(s1, s2)]\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2):\\n            self.map[(s1, s2)] = False\\n            return False\\n        length = len(s1)\\n        if s1 == s2:\\n            self.map[(s1, s2)] = True\\n            return True\\n        for i in range(1, length):\\n            if self.isScramble(s1[i:], s2[i:]) and self.isScramble(s1[:i], s2[:i]):\\n                return True\\n            if self.isScramble(s1[:-i], s2[i:]) and self.isScramble(s1[-i:], s2[:i]):\\n                return True\\n        self.map[(s1, s2)] = False\\n        return False![image](https://assets.leetcode.com/users/images/9d15aea0-b33e-424d-8e39-a044d6e9b6f5_1659108282.189691.png)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.map = {}\\n\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if (s1, s2) in self.map:\\n            return self.map[(s1, s2)]\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2):\\n            self.map[(s1, s2)] = False\\n            return False\\n        length = len(s1)\\n        if s1 == s2:\\n            self.map[(s1, s2)] = True\\n            return True\\n        for i in range(1, length):\\n            if self.isScramble(s1[i:], s2[i:]) and self.isScramble(s1[:i], s2[:i]):\\n                return True\\n            if self.isScramble(s1[:-i], s2[i:]) and self.isScramble(s1[-i:], s2[:i]):\\n                return True\\n        self.map[(s1, s2)] = False\\n        return False![image](https://assets.leetcode.com/users/images/9d15aea0-b33e-424d-8e39-a044d6e9b6f5_1659108282.189691.png)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284154,
                "title": "bhai-java-m-code-hai-maze-karo",
                "content": "```\\nclass Solution {\\n    public boolean solve(String s1, String s2, HashMap<String, Boolean> map){\\n        \\n        // batawo compareTo use kiya hai (bade log ) : matlab v dekho iska \"compares two strings lexicographically\"\\n        // acche se bole to sort karo aur check karo....\\n        if(s1.compareTo(s2) == 0){\\n            return true;\\n        }\\n        \\n        //idhar v padhoge\\n        int n = s1.length();\\n        \\n        // ab single length ho gya to kaahe ko iterate karna choro ka base base apna y\\n        if(n<=1){\\n            return false;\\n        }\\n        \\n        // ab ynha dono string ko concatenate karo maine to underscore liya hai tumhe jo lena hai le lo\\n        // kya hi farak padne wala hai\\n        // par isiliy liy taaki recursion m same chizze baare baar calculate na ho simple\\n        String key = s1 + \"_\" + s2;\\n        \\n        // agar y already process ho gya to sidha iska value fetch karo aur return karaa do\\n        if(map.containsKey(key)){\\n            return map.get(key);\\n        }\\n        \\n        \\n        //idhar m ek flag liya hai taaki future m isi par khell sko\\n        boolean flag = false;\\n        \\n        // idhar second element se khelna start karo aur last tak khelnaa...\\n        for(int i=1;i<n;i++){\\n            \\n            // y ratt lo easy hai.. bas aage piche, piche aage, aage aage, piche piche compare karna hia bas...\\n            if((solve(s1.substring(0,i), s2.substring(n-i, n), map) && (solve(s1.substring(i, n), s2.substring(0, n-i), map))) || \\n               ((solve(s1.substring(0,i), s2.substring(0,i), map)) && (solve(s1.substring(i, n), s2.substring(i, n), map)))){\\n                // idhar flag true kra aur break kar do agge test hi nhi karna hia\\n                   flag = true;\\n                   break;\\n               }\\n        }\\n        \\n        // suru m bola tha recusion m chize repeat hoti hai to ynha uss repetation ko khtm kar do \\n        map.put(key, flag);\\n        // y rhha final answer...\\n                return flag;\\n    }\\n    \\n    // bas bakchodi karni hai inhe. simple sala sort kar do and match kara lo ki dono match kar rhe hain ya nhi. par nhi inko karni hai bakiti to chalo suru karte hain inke tarike se.\\n    public boolean isScramble(String s1, String s2) {\\n        \\n        // ynha pe length check kar lo, ki same hai ya nhi. means string s1 and s2 dene wala ko bewkuff hoga wrong length dega...\\n        if(s1.length() != s2.length()){return false;}\\n        // phir ynhi check kar lo ki same hain ya nhi : same hain to diya hi kaahe be...\\n        if(s1.equals(s2)) return true;\\n        \\n        //ab hashmap create karo taaki har chota chota part ko match karaa kar k dekhana hia ki same hai ki nhi matalab pura time pass karna hai map ko\\n        HashMap<String, Boolean> map = new HashMap<>();\\n        // ynha se suru hoti hai khichadi par acchi waali... bole to recursion.\\n        return solve(s1, s2, map);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean solve(String s1, String s2, HashMap<String, Boolean> map){\\n        \\n        // batawo compareTo use kiya hai (bade log ) : matlab v dekho iska \"compares two strings lexicographically\"\\n        // acche se bole to sort karo aur check karo....\\n        if(s1.compareTo(s2) == 0){\\n            return true;\\n        }\\n        \\n        //idhar v padhoge\\n        int n = s1.length();\\n        \\n        // ab single length ho gya to kaahe ko iterate karna choro ka base base apna y\\n        if(n<=1){\\n            return false;\\n        }\\n        \\n        // ab ynha dono string ko concatenate karo maine to underscore liya hai tumhe jo lena hai le lo\\n        // kya hi farak padne wala hai\\n        // par isiliy liy taaki recursion m same chizze baare baar calculate na ho simple\\n        String key = s1 + \"_\" + s2;\\n        \\n        // agar y already process ho gya to sidha iska value fetch karo aur return karaa do\\n        if(map.containsKey(key)){\\n            return map.get(key);\\n        }\\n        \\n        \\n        //idhar m ek flag liya hai taaki future m isi par khell sko\\n        boolean flag = false;\\n        \\n        // idhar second element se khelna start karo aur last tak khelnaa...\\n        for(int i=1;i<n;i++){\\n            \\n            // y ratt lo easy hai.. bas aage piche, piche aage, aage aage, piche piche compare karna hia bas...\\n            if((solve(s1.substring(0,i), s2.substring(n-i, n), map) && (solve(s1.substring(i, n), s2.substring(0, n-i), map))) || \\n               ((solve(s1.substring(0,i), s2.substring(0,i), map)) && (solve(s1.substring(i, n), s2.substring(i, n), map)))){\\n                // idhar flag true kra aur break kar do agge test hi nhi karna hia\\n                   flag = true;\\n                   break;\\n               }\\n        }\\n        \\n        // suru m bola tha recusion m chize repeat hoti hai to ynha uss repetation ko khtm kar do \\n        map.put(key, flag);\\n        // y rhha final answer...\\n                return flag;\\n    }\\n    \\n    // bas bakchodi karni hai inhe. simple sala sort kar do and match kara lo ki dono match kar rhe hain ya nhi. par nhi inko karni hai bakiti to chalo suru karte hain inke tarike se.\\n    public boolean isScramble(String s1, String s2) {\\n        \\n        // ynha pe length check kar lo, ki same hai ya nhi. means string s1 and s2 dene wala ko bewkuff hoga wrong length dega...\\n        if(s1.length() != s2.length()){return false;}\\n        // phir ynhi check kar lo ki same hain ya nhi : same hain to diya hi kaahe be...\\n        if(s1.equals(s2)) return true;\\n        \\n        //ab hashmap create karo taaki har chota chota part ko match karaa kar k dekhana hia ki same hai ki nhi matalab pura time pass karna hai map ko\\n        HashMap<String, Boolean> map = new HashMap<>();\\n        // ynha se suru hoti hai khichadi par acchi waali... bole to recursion.\\n        return solve(s1, s2, map);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237199,
                "title": "bottom-up-approach-optimal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    bool isScramble(string s1, string s2) {\\n        if (s1.length() != s2.length()) {  //recursive approach will give TLE\\n        return false;\\n    }\\n \\n    int n = s1.length();\\n \\n    // Empty strings are scramble strings\\n    if (n == 0) {\\n        return true;\\n    }\\n \\n    // Equal strings are scramble strings\\n    if (s1 == s2) {\\n        return true;\\n    }\\n    string key = (s1 + \" \" + s2);\\n    if(mp.find(key)!=mp.end())\\n    return mp[key];\\n    \\n    bool flag=false;\\n    for(int i=1;i<=n-1;i++){      \\n       if (isScramble(s1.substr(0, i), s2.substr(0, i)) //first condition\\n            && isScramble(s1.substr(i, n - i), s2.substr(i, n - i)) || (isScramble(s1.substr(0, i), //second condition\\n                       s2.substr(n - i, i))\\n            && isScramble(s1.substr(i, n - i),\\n                          s2.substr(0, n - i)))) {\\n            flag =true;\\n            return true;\\n        }\\n         \\n    }\\n    mp[key]=flag;\\n    return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    bool isScramble(string s1, string s2) {\\n        if (s1.length() != s2.length()) {  //recursive approach will give TLE\\n        return false;\\n    }\\n \\n    int n = s1.length();\\n \\n    // Empty strings are scramble strings\\n    if (n == 0) {\\n        return true;\\n    }\\n \\n    // Equal strings are scramble strings\\n    if (s1 == s2) {\\n        return true;\\n    }\\n    string key = (s1 + \" \" + s2);\\n    if(mp.find(key)!=mp.end())\\n    return mp[key];\\n    \\n    bool flag=false;\\n    for(int i=1;i<=n-1;i++){      \\n       if (isScramble(s1.substr(0, i), s2.substr(0, i)) //first condition\\n            && isScramble(s1.substr(i, n - i), s2.substr(i, n - i)) || (isScramble(s1.substr(0, i), //second condition\\n                       s2.substr(n - i, i))\\n            && isScramble(s1.substr(i, n - i),\\n                          s2.substr(0, n - i)))) {\\n            flag =true;\\n            return true;\\n        }\\n         \\n    }\\n    mp[key]=flag;\\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217499,
                "title": "c-mcm-aditya-verma-playlist",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool>dp;\\n    bool solve(string s1, string s2)\\n    {\\n        if(s1 == s2)\\n            return true;\\n        if(s1.length() <= 1)\\n            return false;\\n        string temp = s1+\"\"+s2;\\n        if(dp.find(temp) != dp.end())\\n            return dp[temp];\\n        bool flag = false;\\n        int n = s1.length();\\n        bool cond1=false, cond2=false;\\n        for(int k=1; k<=n-1; k++)\\n        {\\n            if(solve(s1.substr(0, k), s2.substr(n-k, k)) && (solve(s1.substr(k, n-k), s2.substr(0, n-k))))\\n                cond1= true;\\n            if(solve(s1.substr(0, k), s2.substr(0, k)) && (solve(s1.substr(k, n-k), s2.substr(k, n-k))))\\n                cond2 = true;\\n            if(cond1 || cond2)\\n            {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        return dp[temp] = flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2)\\n            return true;\\n        if(s1.length() != s2.length())\\n            return false;\\n        if(s1.length() <= 1)\\n            return false;\\n        return solve(s1, s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool>dp;\\n    bool solve(string s1, string s2)\\n    {\\n        if(s1 == s2)\\n            return true;\\n        if(s1.length() <= 1)\\n            return false;\\n        string temp = s1+\"\"+s2;\\n        if(dp.find(temp) != dp.end())\\n            return dp[temp];\\n        bool flag = false;\\n        int n = s1.length();\\n        bool cond1=false, cond2=false;\\n        for(int k=1; k<=n-1; k++)\\n        {\\n            if(solve(s1.substr(0, k), s2.substr(n-k, k)) && (solve(s1.substr(k, n-k), s2.substr(0, n-k))))\\n                cond1= true;\\n            if(solve(s1.substr(0, k), s2.substr(0, k)) && (solve(s1.substr(k, n-k), s2.substr(k, n-k))))\\n                cond2 = true;\\n            if(cond1 || cond2)\\n            {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        return dp[temp] = flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2)\\n            return true;\\n        if(s1.length() != s2.length())\\n            return false;\\n        if(s1.length() <= 1)\\n            return false;\\n        return solve(s1, s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202091,
                "title": "c-mcm-pattern-fully-explained-2-methods-recursion-memorization-dp",
                "content": "* So we have 2 strings s1 and s2 and we need to check if they are scrambled strings are not\\n* For that we can follow the MCM pattern of dividing the string into 2 parts at every possible point\\n* So we can do 2 possible things at a point\\n            1. leave the string as it is\\n            2. swap it!\\n* Let us assume you are at index 1 and you want to leave the string as it is then it would be true if and only if (0,1) of s1 == (0,1) of s2 (AND) (1,n) of s1 == (1,n) of s2 \\n*  Now for swap case let us assume we are at index 1 and now we will check if (0,1) of s1 == (n-1,1) of s2 (AND) (1,n) of s1 == (0,n-1) of s2 \\n*  **(Here \\'s1==s2\\' doesn\\'t mean we are comparing both the string it represent whether s1 and  s2 are scrambled strings or not)**\\n\\n**CODE:**\\n\\n**RECURSION (TLE) :**\\n```\\nclass Solution {\\npublic:\\n    bool rec(string s1,string s2){\\n        int n=s1.size();\\n        if(s1==s2){   //If strings are equal  Eg:s1=ab and s2=ab;\\n            return 1;\\n        }\\n        if(n==1){   //strings are not equal even if the size is 1\\n            return 0;\\n        }\\n        int flag=0;\\n        for(int k=1;k<n;k++){\\n            if(rec(s1.substr(0,k),s2.substr(0,k))&&rec(s1.substr(k),s2.substr(k))){   //leave\\n                flag=1;\\n            }\\n            if(rec(s1.substr(0,k),s2.substr(n-k))&&rec(s1.substr(k),s2.substr(0,n-k))){ //swap\\n                flag=1;\\n            }\\n        }\\n        return flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        return rec(s1,s2);\\n    }\\n};\\n```\\n\\n**DYNAMIC PROGRAMMING (RECURSION + MEMORIZATION) (AC) :**\\n```\\nclass Solution {\\npublic:\\n    bool rec(string s1,string s2,unordered_map<string,int>&um){\\n        int n=s1.size();\\n        if(s1==s2){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 0;\\n        }\\n        int flag=0;\\n        if(um.find(s1+\" \"+s2)!=um.end()){\\n            return um[s1+\" \"+s2];\\n        }\\n        for(int k=1;k<n;k++){\\n            if(rec(s1.substr(0,k),s2.substr(0,k),um)&&rec(s1.substr(k),s2.substr(k),um)){\\n                flag=1;\\n            }\\n            if(flag==1){\\n                return true;\\n            }\\n            if(rec(s1.substr(0,k),s2.substr(n-k),um)&&rec(s1.substr(k),s2.substr(0,n-k),um)){\\n                flag=1;\\n            }\\n            if(flag==1){\\n                return true;\\n            }\\n        }\\n        return um[s1+\" \"+s2]=flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string,int>um;\\n        return rec(s1,s2,um);\\n    }\\n};\\n```\\n\\nPlease **UPVOTE!** if you find this useful and update me in the comments if you have a better optimized solution\\nCheck this [video](https://www.youtube.com/watch?v=SqA0o-DGmEw&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=40&ab_channel=AdityaVerma) for better understanding\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(string s1,string s2){\\n        int n=s1.size();\\n        if(s1==s2){   //If strings are equal  Eg:s1=ab and s2=ab;\\n            return 1;\\n        }\\n        if(n==1){   //strings are not equal even if the size is 1\\n            return 0;\\n        }\\n        int flag=0;\\n        for(int k=1;k<n;k++){\\n            if(rec(s1.substr(0,k),s2.substr(0,k))&&rec(s1.substr(k),s2.substr(k))){   //leave\\n                flag=1;\\n            }\\n            if(rec(s1.substr(0,k),s2.substr(n-k))&&rec(s1.substr(k),s2.substr(0,n-k))){ //swap\\n                flag=1;\\n            }\\n        }\\n        return flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        return rec(s1,s2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool rec(string s1,string s2,unordered_map<string,int>&um){\\n        int n=s1.size();\\n        if(s1==s2){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 0;\\n        }\\n        int flag=0;\\n        if(um.find(s1+\" \"+s2)!=um.end()){\\n            return um[s1+\" \"+s2];\\n        }\\n        for(int k=1;k<n;k++){\\n            if(rec(s1.substr(0,k),s2.substr(0,k),um)&&rec(s1.substr(k),s2.substr(k),um)){\\n                flag=1;\\n            }\\n            if(flag==1){\\n                return true;\\n            }\\n            if(rec(s1.substr(0,k),s2.substr(n-k),um)&&rec(s1.substr(k),s2.substr(0,n-k),um)){\\n                flag=1;\\n            }\\n            if(flag==1){\\n                return true;\\n            }\\n        }\\n        return um[s1+\" \"+s2]=flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string,int>um;\\n        return rec(s1,s2,um);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185858,
                "title": "c-mcm-memorization-dp-easy-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool solve(string s1,string s2){\\n        string s = s1 +\" \"+s2;\\n        if(s1==s2) return mp[s]= true;\\n        if(s1.length()<=1||s2.length()<=1) return false;\\n        if(mp.find(s)!=mp.end()) return mp[s];\\n        bool flag =false;\\n        int j = s1.length();\\n        for(int i=1;i<s1.length();i++){\\n    bool cond1 = solve(s1.substr(0,i),s2.substr(j-i))&&solve(s1.substr(i),s2.substr(0,j-i));\\n    bool cond2 = solve(s1.substr(0,i),s2.substr(0,i))&&solve(s1.substr(i),s2.substr(i));\\n          if(cond1||cond2){\\n              flag = true;\\n              break;\\n          }  \\n        }\\n        \\n     return mp[s]=flag;   \\n    }\\n    bool isScramble(string s1, string s2) {\\n        vector<int> cnt(26,0);\\n        mp = unordered_map<string,bool>(false);\\n        if(s1.length()!=s2.length()) return false;\\n        if(s1==s2)return true;\\n        for(int i=0;i<s1.size();i++){\\n            cnt[s1[i]-\\'a\\']++;\\n            cnt[s2[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]!=0)return false;\\n        }\\n        \\n       return solve(s1,s2); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool solve(string s1,string s2){\\n        string s = s1 +\" \"+s2;\\n        if(s1==s2) return mp[s]= true;\\n        if(s1.length()<=1||s2.length()<=1) return false;\\n        if(mp.find(s)!=mp.end()) return mp[s];\\n        bool flag =false;\\n        int j = s1.length();\\n        for(int i=1;i<s1.length();i++){\\n    bool cond1 = solve(s1.substr(0,i),s2.substr(j-i))&&solve(s1.substr(i),s2.substr(0,j-i));\\n    bool cond2 = solve(s1.substr(0,i),s2.substr(0,i))&&solve(s1.substr(i),s2.substr(i));\\n          if(cond1||cond2){\\n              flag = true;\\n              break;\\n          }  \\n        }\\n        \\n     return mp[s]=flag;   \\n    }\\n    bool isScramble(string s1, string s2) {\\n        vector<int> cnt(26,0);\\n        mp = unordered_map<string,bool>(false);\\n        if(s1.length()!=s2.length()) return false;\\n        if(s1==s2)return true;\\n        for(int i=0;i<s1.size();i++){\\n            cnt[s1[i]-\\'a\\']++;\\n            cnt[s2[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]!=0)return false;\\n        }\\n        \\n       return solve(s1,s2); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029583,
                "title": "bottom-up-approach-simple-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        if (n1 != n2)   return false; // lengths should be the same\\n        if (s1 == \"\" && s2 == \"\")   return true; // empty strings are scramble of each other\\n        // try to write dp state params\\n\\t\\t// an obvious dp state would be dp[start1][end1][start2][end2]\\n        // but as the length of two strings should always be equal we can determine end2 using start1, end1, and start2\\n        // thus, we use dp[start1][start2][len] as our state\\n        bool dp[n1 + 1][n1 + 1][n1 + 1]; // denoting dp[start1][start2][len]\\n        memset(dp, false, sizeof(dp));\\n        // if we have to build a solution from bottom up first try to think how to get the answers for the base cases\\n        // here as our base case we want asnwers for all substrings of s1 * all substrings of s2 of size 1\\n        // that means we already have 3 loops for len, ind_i and ind_2\\n        // now why len loop is outside because we first want to solve all the subproblems of len 1 before moving to a higher len\\n        for(int l = 1; l <= n1; l++){ \\n            for (int i = 0; i + l - 2 < n1; i++) {\\n                for (int j = 0; j + l - 2 < n1; j++) {\\n                    dp[i][j][l] = (s1.substr(i, l) == s2.substr(j, l));\\n                    // transactions are a bit clearer from the question itself\\n                    // we just have to decide the left and right parts for scrambling\\n                    // thus we have dp[i][j][l] |= (dp[i][j][k] && dp[i + k][j + k][l - k]) || (dp[i + l - k][j][k] && dp[i][j + k][l - k]);\\n                    // where k denotes the len of the left part\\n                    for (int k = 1 ; k < l ; k++) {\\n                        dp[i][j][l] |= (dp[i][j][k] && dp[i + k][j + k][l - k]) || (dp[i + l - k][j][k] && dp[i][j + k][l - k]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][n1];\\n        \\n    }\\n};\\n```\\nPlease upvote if it helped !",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        if (n1 != n2)   return false; // lengths should be the same\\n        if (s1 == \"\" && s2 == \"\")   return true; // empty strings are scramble of each other\\n        // try to write dp state params\\n\\t\\t// an obvious dp state would be dp[start1][end1][start2][end2]\\n        // but as the length of two strings should always be equal we can determine end2 using start1, end1, and start2\\n        // thus, we use dp[start1][start2][len] as our state\\n        bool dp[n1 + 1][n1 + 1][n1 + 1]; // denoting dp[start1][start2][len]\\n        memset(dp, false, sizeof(dp));\\n        // if we have to build a solution from bottom up first try to think how to get the answers for the base cases\\n        // here as our base case we want asnwers for all substrings of s1 * all substrings of s2 of size 1\\n        // that means we already have 3 loops for len, ind_i and ind_2\\n        // now why len loop is outside because we first want to solve all the subproblems of len 1 before moving to a higher len\\n        for(int l = 1; l <= n1; l++){ \\n            for (int i = 0; i + l - 2 < n1; i++) {\\n                for (int j = 0; j + l - 2 < n1; j++) {\\n                    dp[i][j][l] = (s1.substr(i, l) == s2.substr(j, l));\\n                    // transactions are a bit clearer from the question itself\\n                    // we just have to decide the left and right parts for scrambling\\n                    // thus we have dp[i][j][l] |= (dp[i][j][k] && dp[i + k][j + k][l - k]) || (dp[i + l - k][j][k] && dp[i][j + k][l - k]);\\n                    // where k denotes the len of the left part\\n                    for (int k = 1 ; k < l ; k++) {\\n                        dp[i][j][l] |= (dp[i][j][k] && dp[i + k][j + k][l - k]) || (dp[i + l - k][j][k] && dp[i][j + k][l - k]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][n1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984464,
                "title": "c-best-solution-using-dp-unique-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<string, int>, bool> mp;\\n    bool solve(string str, string &s2, int start, int end){\\n        if (start == end){\\n            return s2[start] == str[0];\\n        }\\n        if (mp.find({str, start+end}) != mp.end())  return mp[{str, start+end}];\\n        \\n        bool ans = 0;\\n        for (int i = 0;i < end-start;i++){\\n            bool left = solve(str.substr(0, i+1), s2, start, start+i) && solve(str.substr(i+1), s2, start+i+1, end);\\n            bool right = solve(str.substr(i+1), s2, start, end-i-1) && solve(str.substr(0, i+1), s2, end-i, end);\\n            ans = left or right;\\n            if (ans){\\n                mp[{str, start+end}] = ans;\\n                return ans;\\n            }\\n        }\\n        mp[{str, start+end}] = ans;\\n        return ans;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        return solve(s1, s2, 0, s1.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<string, int>, bool> mp;\\n    bool solve(string str, string &s2, int start, int end){\\n        if (start == end){\\n            return s2[start] == str[0];\\n        }\\n        if (mp.find({str, start+end}) != mp.end())  return mp[{str, start+end}];\\n        \\n        bool ans = 0;\\n        for (int i = 0;i < end-start;i++){\\n            bool left = solve(str.substr(0, i+1), s2, start, start+i) && solve(str.substr(i+1), s2, start+i+1, end);\\n            bool right = solve(str.substr(i+1), s2, start, end-i-1) && solve(str.substr(0, i+1), s2, end-i, end);\\n            ans = left or right;\\n            if (ans){\\n                mp[{str, start+end}] = ans;\\n                return ans;\\n            }\\n        }\\n        mp[{str, start+end}] = ans;\\n        return ans;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        return solve(s1, s2, 0, s1.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785831,
                "title": "scramble-string-solution-java",
                "content": "class Solution {\\n  public boolean isScramble(String s1, String s2) {\\n    if (s1.equals(s2))\\n      return true;\\n    if (s1.length() != s2.length())\\n      return false;\\n    final String hashedKey = s1 + \"+\" + s2;\\n    if (memo.containsKey(hashedKey))\\n      return memo.get(hashedKey);\\n\\n    int[] count = new int[128];\\n\\n    for (int i = 0; i < s1.length(); ++i) {\\n      ++count[s1.charAt(i)];\\n      --count[s2.charAt(i)];\\n    }\\n\\n    for (final int c : count)\\n      if (c != 0) {\\n        memo.put(hashedKey, false);\\n        return false;\\n      }\\n\\n    for (int i = 1; i < s1.length(); ++i) {\\n      if (isScramble(s1.substring(0, i), s2.substring(0, i)) &&\\n          isScramble(s1.substring(i), s2.substring(i))) {\\n        memo.put(hashedKey, true);\\n        return true;\\n      }\\n      if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) &&\\n          isScramble(s1.substring(i), s2.substring(0, s2.length() - i))) {\\n        memo.put(hashedKey, true);\\n        return true;\\n      }\\n    }\\n\\n    memo.put(hashedKey, false);\\n    return false;\\n  }\\n\\n  private Map<String, Boolean> memo = new HashMap<>();\\n}\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n  public boolean isScramble(String s1, String s2) {\\n    if (s1.equals(s2))\\n      return true;\\n    if (s1.length() != s2.length())\\n      return false;\\n    final String hashedKey = s1 + \"+\" + s2;\\n    if (memo.containsKey(hashedKey))\\n      return memo.get(hashedKey);\\n\\n    int[] count = new int[128];\\n\\n    for (int i = 0; i < s1.length(); ++i) {\\n      ++count[s1.charAt(i)];\\n      --count[s2.charAt(i)];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1763795,
                "title": "aditya-bhaiya-op-scramble-string",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool>mp;\\n    \\n    bool solve( string a, string b){\\n        \\n        if (a.compare(b) == 0)\\n            return true;\\n        \\n        if (a.size() <=1 )\\n            return false ;\\n        \\n        int n = a.size();\\n        \\n        string key = a+ \" \" + b;\\n        \\n        if (mp.find(key) != mp.end())\\n            return mp[key];\\n        \\n         bool flag = false;\\n        \\n        for (int i=1; i< n; i++){\\n            \\n    \\n            \\n        if ((solve(a.substr(0,i), b.substr(n-i, i))== true  && solve(a.substr(i,n-i), b.substr(0, n-i))== true)|| (solve(a.substr(0,i), b.substr(0, i))== true  && solve(a.substr(i,n-i), b.substr(i, n-i)) == true))\\n        {\\n            flag = true;\\n            break;\\n        }\\n        \\n        \\n        \\n    }\\n    return mp[key] = flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        if (s1.size() != s2.size())\\n            return false ;\\n        \\n        return solve(s1, s2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool>mp;\\n    \\n    bool solve( string a, string b){\\n        \\n        if (a.compare(b) == 0)\\n            return true;\\n        \\n        if (a.size() <=1 )\\n            return false ;\\n        \\n        int n = a.size();\\n        \\n        string key = a+ \" \" + b;\\n        \\n        if (mp.find(key) != mp.end())\\n            return mp[key];\\n        \\n         bool flag = false;\\n        \\n        for (int i=1; i< n; i++){\\n            \\n    \\n            \\n        if ((solve(a.substr(0,i), b.substr(n-i, i))== true  && solve(a.substr(i,n-i), b.substr(0, n-i))== true)|| (solve(a.substr(0,i), b.substr(0, i))== true  && solve(a.substr(i,n-i), b.substr(i, n-i)) == true))\\n        {\\n            flag = true;\\n            break;\\n        }\\n        \\n        \\n        \\n    }\\n    return mp[key] = flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        if (s1.size() != s2.size())\\n            return false ;\\n        \\n        return solve(s1, s2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741245,
                "title": "java-aditya-verma-solution",
                "content": "```\\nclass Solution {\\n    static HashMap<String,Boolean> map=new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        \\n        if(s1.equals(s2))\\n        {\\n            return true;\\n        }\\n             \\n        String key=s1+\"_\"+s2;\\n        if(map.containsKey(key))\\n        {\\n            return map.get(key);\\n        }\\n        boolean flag=false;\\n        int n=s1.length();\\n        for(int i=1;i<n;i++)\\n        {\\n             boolean swap=(isScramble(s1.substring(0, i),s2.substring(n - i,n)) && isScramble(s1.substring(i, n),s2.substring(0, n-i)));\\n         \\n            boolean noswap=(isScramble(s1.substring(0, i),s2.substring(0, i))  && isScramble(s1.substring(i, n),s2.substring(i, n)));\\n            \\n            if(noswap||swap)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        map.put(key,flag);\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    static HashMap<String,Boolean> map=new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        \\n        if(s1.equals(s2))\\n        {\\n            return true;\\n        }\\n             \\n        String key=s1+\"_\"+s2;\\n        if(map.containsKey(key))\\n        {\\n            return map.get(key);\\n        }\\n        boolean flag=false;\\n        int n=s1.length();\\n        for(int i=1;i<n;i++)\\n        {\\n             boolean swap=(isScramble(s1.substring(0, i),s2.substring(n - i,n)) && isScramble(s1.substring(i, n),s2.substring(0, n-i)));\\n         \\n            boolean noswap=(isScramble(s1.substring(0, i),s2.substring(0, i))  && isScramble(s1.substring(i, n),s2.substring(i, n)));\\n            \\n            if(noswap||swap)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        map.put(key,flag);\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713183,
                "title": "c-memoized-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool isScramble(string a, string b) {\\n        \\n        string key=a+b;\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        if(a.compare(b)==0)\\n            return mp[key]=true;\\n        if(a.length()<=1)\\n            return mp[key]=false;\\n        int i,n;\\n        n=a.length();\\n        for(i=1;i<n;i++)\\n        {\\n            if(isScramble(a.substr(0,i),b.substr(0,i)) && isScramble(a.substr(i,n-i),b.substr(i,n-i)))\\n            return mp[key]=true;\\n            if(isScramble(a.substr(0,i),b.substr(n-i,i)) && isScramble(a.substr(i,n-i),b.substr(0,n-i)))\\n            return mp[key]=true;\\n        }\\n        return mp[key]=false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool isScramble(string a, string b) {\\n        \\n        string key=a+b;\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        if(a.compare(b)==0)\\n            return mp[key]=true;\\n        if(a.length()<=1)\\n            return mp[key]=false;\\n        int i,n;\\n        n=a.length();\\n        for(i=1;i<n;i++)\\n        {\\n            if(isScramble(a.substr(0,i),b.substr(0,i)) && isScramble(a.substr(i,n-i),b.substr(i,n-i)))\\n            return mp[key]=true;\\n            if(isScramble(a.substr(0,i),b.substr(n-i,i)) && isScramble(a.substr(i,n-i),b.substr(0,n-i)))\\n            return mp[key]=true;\\n        }\\n        return mp[key]=false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570555,
                "title": "python-c-dfs-memo-and-elegant-negative-index",
                "content": "Approach 1: DFS + memo\\n```\\nclass Solution:\\n    @lru_cache(None)\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if s1 == s2: return True\\n        if Counter(s1) != Counter(s2): return False\\n        N = len(s1)\\n        for i in range(1, N):\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]): return True\\n            if self.isScramble(s1[:i], s2[N - i:]) and self.isScramble(s1[i:], s2[:N-i]): return True\\n        return False                  \\n```\\n\\nApproach 2: Elegant using negative index in Python\\nTrick:\\na=[1,2,3,4,5]\\na[:-2] = [1,2,3]\\na[-2:] = [4,5]\\n```\\nclass Solution: # Appraoch 2, BEST\\n    @cache\\n    def isScramble(self, s1: str, s2: str) -> bool:        \\n        #if sorted(s1)!=sorted(s2): return False #OK, but too expensive\\n        if s1 == s2: return True\\n        if Counter(s1)!=Counter(s2): return False        \\n        n = len(s1)\\n        for i in range(1,n):#OK, sub-problmens must be smaller than original problems.\\n        #for i in range(n-1): #ERR: maximum recursion depth exceeded in comparison\\n        #for i in range(n): # ERR: maximum recursion depth exceeded in comparison\\n            #case1: first i items vs. first i items, where i is [1, n-1]\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                return True\\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\\n                return True\\n        return False\\n\\n```\\n\\nAppraoch 2: C++ version\\n```\\nclass Solution {// C++ version\\npublic: // string can be replace with string_view\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2) return true;\\n        if(Counter(s1) != Counter(s2)) return false;\\n        if(_memo.count(s1) && _memo[s1].count(s2)) return _memo[s1][s2];\\n        for(int i = 1, N = s1.size(); i < N; i++){\\n            if(isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)) ) return _memo[s1][s2]=true;\\n            if(isScramble(s1.substr(0, i), s2.substr(N-i)) && isScramble(s1.substr(i), s2.substr(0, N-i)) ) return _memo[s1][s2]=true;\\n        }\\n        return _memo[s1][s2] = false;\\n    }\\n    \\nprivate:\\n    unordered_map<string, unordered_map<string, bool> > _memo;\\n    vector<int> Counter(string& s){\\n        vector<int> ans(26,0);\\n        for(auto c: s) ++ans[c-\\'a\\'];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    @lru_cache(None)\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if s1 == s2: return True\\n        if Counter(s1) != Counter(s2): return False\\n        N = len(s1)\\n        for i in range(1, N):\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]): return True\\n            if self.isScramble(s1[:i], s2[N - i:]) and self.isScramble(s1[i:], s2[:N-i]): return True\\n        return False                  \\n```\n```\\nclass Solution: # Appraoch 2, BEST\\n    @cache\\n    def isScramble(self, s1: str, s2: str) -> bool:        \\n        #if sorted(s1)!=sorted(s2): return False #OK, but too expensive\\n        if s1 == s2: return True\\n        if Counter(s1)!=Counter(s2): return False        \\n        n = len(s1)\\n        for i in range(1,n):#OK, sub-problmens must be smaller than original problems.\\n        #for i in range(n-1): #ERR: maximum recursion depth exceeded in comparison\\n        #for i in range(n): # ERR: maximum recursion depth exceeded in comparison\\n            #case1: first i items vs. first i items, where i is [1, n-1]\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                return True\\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\\n                return True\\n        return False\\n\\n```\n```\\nclass Solution {// C++ version\\npublic: // string can be replace with string_view\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2) return true;\\n        if(Counter(s1) != Counter(s2)) return false;\\n        if(_memo.count(s1) && _memo[s1].count(s2)) return _memo[s1][s2];\\n        for(int i = 1, N = s1.size(); i < N; i++){\\n            if(isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)) ) return _memo[s1][s2]=true;\\n            if(isScramble(s1.substr(0, i), s2.substr(N-i)) && isScramble(s1.substr(i), s2.substr(0, N-i)) ) return _memo[s1][s2]=true;\\n        }\\n        return _memo[s1][s2] = false;\\n    }\\n    \\nprivate:\\n    unordered_map<string, unordered_map<string, bool> > _memo;\\n    vector<int> Counter(string& s){\\n        vector<int> ans(26,0);\\n        for(auto c: s) ++ans[c-\\'a\\'];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568607,
                "title": "java-code-recursion-memo-mcm-type",
                "content": "class Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length()!=s2.length()){\\n            return false ; \\n        }\\n        \\n        return s(s1,s2);\\n        \\n        \\n    }\\n static HashMap<String,Boolean> map = new HashMap<>();\\n\\n    public boolean s(String s1, String s2){\\n        if(s1.equals(s2)){\\n            return true ;\\n        }\\n        if(s1.length()<=1) return false ;\\n        \\n       String key=s1+\" \"+s2;\\n\\n        if(map.containsKey(key)) {\\n            return map.get(key);\\n        }\\n        \\n       boolean isflag = false ;\\n        for(int k=1;k<s1.length();k++){\\n       boolean a = s(s1.substring(0,k),s2.substring(0,k)) && s(s1.substring(k),s2.substring(k));\\n       boolean b = s(s1.substring(0,k),s2.substring(s1.length()-k)) && s(s1.substring(k),s2.substring(0,s1.length()-k));  \\n          if(a||b){\\n             isflag = true ;\\n          }                                                                   \\n        }\\n         map.put(key, isflag);\\n\\n        return isflag ;\\n    }\\n}\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "class Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length()!=s2.length()){\\n            return false ; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1530280,
                "title": "c-memoization-using-map-o-n-3-time-mcm",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool>m;\\n    bool isScramble(string a, string b){\\n        if(a==b)\\n            return true;\\n        if(a.size()!=b.size())\\n            return false;\\n        if(a.size()==1)\\n            return false; \\n        string key=a+\" \"+b;\\n        if(m.find(key)!=m.end())\\n            return m[key];\\n        bool flag=false;\\n        for(int i=1;i<a.size();i++){\\n            bool cond1=(isScramble(a.substr(0,i), b.substr(a.size()-i, i)) &&  isScramble(a.substr(i,a.size()-i), b.substr(0, a.size()-i)));\\n            bool cond2=(isScramble(a.substr(0,i), b.substr(0,i)) && isScramble(a.substr(i,a.size()-i), b.substr(i,a.size()-i)));\\n\\t\\t\\t\\n            if(cond1 || cond2){\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return m[key]=flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool>m;\\n    bool isScramble(string a, string b){\\n        if(a==b)\\n            return true;\\n        if(a.size()!=b.size())\\n            return false;\\n        if(a.size()==1)\\n            return false; \\n        string key=a+\" \"+b;\\n        if(m.find(key)!=m.end())\\n            return m[key];\\n        bool flag=false;\\n        for(int i=1;i<a.size();i++){\\n            bool cond1=(isScramble(a.substr(0,i), b.substr(a.size()-i, i)) &&  isScramble(a.substr(i,a.size()-i), b.substr(0, a.size()-i)));\\n            bool cond2=(isScramble(a.substr(0,i), b.substr(0,i)) && isScramble(a.substr(i,a.size()-i), b.substr(i,a.size()-i)));\\n\\t\\t\\t\\n            if(cond1 || cond2){\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return m[key]=flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453949,
                "title": "python-solution",
                "content": "class Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        memo={}\\n        \\n        def dfs(s1,s2):\\n            if (s1+s2) in memo:return memo[s1+s2]\\n            if len(s1)==1:\\n                return s1==s2\\n            \\n            if s1==s2:\\n                return True\\n            \\n            n=len(s1)\\n        \\n            for i in range(1,n):\\n                if (dfs(s1[:i],s2[:i]) and dfs(s1[i:],s2[i:])) or (dfs(s1[:i],s2[n-i:]) and dfs(s1[i:],s2[:n-i])):\\n                    memo[s1+s2]=True\\n                    return memo[s1+s2]\\n        \\n            memo[s1+s2]=False\\n            return False\\n    \\n        return dfs(s1,s2)\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        memo={}",
                "codeTag": "Java"
            },
            {
                "id": 1399920,
                "title": "java-easy-memoization-solution",
                "content": "class Solution {\\n\\n    private HashMap<String, Boolean> map;\\n    public boolean isScramble(String s1, String s2) {\\n        this.map = new HashMap<>();\\n        boolean ans = helper(s1, s2);\\n        return ans;\\n    }\\n    private boolean helper(String str1, String str2){\\n        int n = str1.length();\\n        if(str1.equals(str2)){\\n            map.put(str1 + \"&\" + str2, true);\\n            return true;\\n        }\\n        if(n == 1){\\n            map.put(str1 + \"&\" + str2, false);\\n            return false;\\n        }\\n        if(map.containsKey(str1 + \"&\" + str2)){\\n            return map.get(str1 + \"&\" + str2);\\n        }\\n        Boolean ans = false;\\n        for(int i = 1; i < n; i++){\\n            boolean ans1 = helper(str1.substring(0, i), str2.substring(0, i)) \\n                && helper(str1.substring(i), str2.substring(i));\\n            boolean ans2 = helper(str1.substring(0, i), str2.substring(n-i)) \\n                && helper(str1.substring(i), str2.substring(0, n-i));\\n            \\n            if(ans1 || ans2){\\n                ans = true;\\n                break;\\n            }\\n        }\\n        map.put(str1 + \"&\" + str2, ans);\\n        return ans;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\n    private HashMap<String, Boolean> map;\\n    public boolean isScramble(String s1, String s2) {\\n        this.map = new HashMap<>();\\n        boolean ans = helper(s1, s2);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1392093,
                "title": "c-recursive-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    map<string,bool> mp;\\n    bool isScramble(string s1, string s2) {\\n    if(s1==s2) return true;\\n    int cnt[26] ={};\\n    \\n    string s = s1+\\'-\\'+s2;\\n    if(mp.find(s)!=mp.end()) return mp[s];\\n    if(s1.length()!=s2.length()) return false;\\n    for(int i =0; i<s1.length(); i++){\\n        cnt[s1[i]-\\'a\\']++;\\n        cnt[s2[i]-\\'a\\']--;\\n    }\\n        \\n    for(int i=0; i<26; i++)\\n        {\\n            if(cnt[i]!=0)\\n                return false;\\n        }\\n    int len = s1.length();\\n    bool flag = false;\\n    for(int i =1; i<=len-1; i++){\\n        if(isScramble(s1.substr(0,i),s2.substr(0,i))&& isScramble(s1.substr(i),s2.substr(i))) flag =  true; \\n        if(isScramble(s1.substr(0,i),s2.substr(len-i))&& isScramble(s1.substr(i),s2.substr(0,len-i))) flag = true; \\n    }\\n    mp[s] = flag;\\n    return flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    map<string,bool> mp;\\n    bool isScramble(string s1, string s2) {\\n    if(s1==s2) return true;\\n    int cnt[26] ={};\\n    \\n    string s = s1+\\'-\\'+s2;\\n    if(mp.find(s)!=mp.end()) return mp[s];\\n    if(s1.length()!=s2.length()) return false;\\n    for(int i =0; i<s1.length(); i++){\\n        cnt[s1[i]-\\'a\\']++;\\n        cnt[s2[i]-\\'a\\']--;\\n    }\\n        \\n    for(int i=0; i<26; i++)\\n        {\\n            if(cnt[i]!=0)\\n                return false;\\n        }\\n    int len = s1.length();\\n    bool flag = false;\\n    for(int i =1; i<=len-1; i++){\\n        if(isScramble(s1.substr(0,i),s2.substr(0,i))&& isScramble(s1.substr(i),s2.substr(i))) flag =  true; \\n        if(isScramble(s1.substr(0,i),s2.substr(len-i))&& isScramble(s1.substr(i),s2.substr(0,len-i))) flag = true; \\n    }\\n    mp[s] = flag;\\n    return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306162,
                "title": "0ms-c-solution",
                "content": "```\\nstatic char *s_lookup, *s_s1, *s_s2;\\nstatic int s_len;\\n\\nint CheckSramble(char *current, char *target, int len)\\n{\\n    char *flag=s_lookup+((current-s_s1)*s_len+target-s_s2)*s_len+len;\\n    if(*flag!=-1) return *flag;\\n    if(!memcmp(current, target, len)) return *flag=1;\\n    int char_table_s1_head[26]={};\\n    int char_table_s2_head[26]={};\\n    int char_table_s2_tail[26]={};\\n    for(int i=1;i<len;i++)\\n    {\\n        char_table_s1_head[current[i-1]-\\'a\\']++;\\n        char_table_s2_head[target[i-1]-\\'a\\']++;  \\n        if(!memcmp(char_table_s1_head, char_table_s2_head, sizeof(char_table_s1_head)))\\n            if(CheckSramble(current, target, i) && CheckSramble(current+i, target+i, len-i))\\n                return *flag=1;\\n        char_table_s2_tail[target[len-i]-\\'a\\']++;\\n        if(!memcmp(char_table_s1_head, char_table_s2_tail, sizeof(char_table_s1_head)))\\n            if(CheckSramble(current+i, target, len-i) && CheckSramble(current, target+len-i, i))\\n                return *flag=1;\\n    }\\n    return *flag=0;\\n}\\n\\nbool isScramble(char * s1, char * s2){\\n    int len=strlen(s1);\\n    int char_table_s1[26]={};\\n    int char_table_s2[26]={};\\n    for(int i=0;i<len;i++)\\n    {\\n        char_table_s1[s1[i]-\\'a\\']++;\\n        char_table_s2[s2[i]-\\'a\\']++;\\n    }\\n    if(memcmp(char_table_s1, char_table_s2, sizeof(char_table_s1))) return false;\\n    s_len=len+1;\\n    s_lookup=(char*)malloc(s_len*s_len*s_len);\\n    memset(s_lookup, -1, s_len*s_len*s_len);\\n    s_s1=s1, s_s2=s2;\\n    bool ret=CheckSramble(s1, s2, len);\\n    free(s_lookup);\\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstatic char *s_lookup, *s_s1, *s_s2;\\nstatic int s_len;\\n\\nint CheckSramble(char *current, char *target, int len)\\n{\\n    char *flag=s_lookup+((current-s_s1)*s_len+target-s_s2)*s_len+len;\\n    if(*flag!=-1) return *flag;\\n    if(!memcmp(current, target, len)) return *flag=1;\\n    int char_table_s1_head[26]={};\\n    int char_table_s2_head[26]={};\\n    int char_table_s2_tail[26]={};\\n    for(int i=1;i<len;i++)\\n    {\\n        char_table_s1_head[current[i-1]-\\'a\\']++;\\n        char_table_s2_head[target[i-1]-\\'a\\']++;  \\n        if(!memcmp(char_table_s1_head, char_table_s2_head, sizeof(char_table_s1_head)))\\n            if(CheckSramble(current, target, i) && CheckSramble(current+i, target+i, len-i))\\n                return *flag=1;\\n        char_table_s2_tail[target[len-i]-\\'a\\']++;\\n        if(!memcmp(char_table_s1_head, char_table_s2_tail, sizeof(char_table_s1_head)))\\n            if(CheckSramble(current+i, target, len-i) && CheckSramble(current, target+len-i, i))\\n                return *flag=1;\\n    }\\n    return *flag=0;\\n}\\n\\nbool isScramble(char * s1, char * s2){\\n    int len=strlen(s1);\\n    int char_table_s1[26]={};\\n    int char_table_s2[26]={};\\n    for(int i=0;i<len;i++)\\n    {\\n        char_table_s1[s1[i]-\\'a\\']++;\\n        char_table_s2[s2[i]-\\'a\\']++;\\n    }\\n    if(memcmp(char_table_s1, char_table_s2, sizeof(char_table_s1))) return false;\\n    s_len=len+1;\\n    s_lookup=(char*)malloc(s_len*s_len*s_len);\\n    memset(s_lookup, -1, s_len*s_len*s_len);\\n    s_s1=s1, s_s2=s2;\\n    bool ret=CheckSramble(s1, s2, len);\\n    free(s_lookup);\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280605,
                "title": "scramble-string-easy-c",
                "content": "Question :Given two strings S1 and S2 of equal length, the task is to determine if S2 is a scrambled       form of S1.\\n**Scrambled string:** \\n* Given string str, we can represent it as a binary tree by partitioning it to two non-empty substrings recursively.\\n* Note: Srambled string is not same as an Anagram\\nEg Below is one possible representation of str = \\u201Ccoder\\u201D:\\n```\\n    coder\\n   /    \\\\\\n  co    der\\n / \\\\    /  \\\\\\nc   o  d   er\\n           / \\\\\\n          e   r\\n```\\nTo scramble the string, we may choose any non-leaf node and swap its two children. \\nSuppose, we choose the node \\u201Cco\\u201D and swap its two children, it produces a scrambled string \\u201Cocder\\u201D.\\n```\\n  ocder\\n   /    \\\\\\n  oc    der\\n / \\\\    /  \\\\\\no   c  d   er\\n           / \\\\\\n          e   r\\n```\\n**Thus, \\u201Cocder\\u201D is a scrambled string of \\u201Ccoder\\u201D.**\\n* Note : No of swwaps we can do is >=0\\n* Now we can see there are 2 cases possible : \\n* **Case 1 : No swapping** \\nEg \"coder\" & \"coder\" are 2 strambled strings\\n* **Case 2: Swappig**\\nSee the above tree for this case\\n\\n\\n### Recurisve approach\\n* Since there are many possible combinations in which the strings can be scrambled the only way is to use recursion to calculate the answer.\\n* The main idea is to divide the string \\'S\\' into two substrings with length \\u2018i\\u2019 and \\u2018LEN - i\\u2019, where \\u2018LEN\\u2019 is the length of the original string \\'S\\', and check recursively if the two substrings X = S[0\\u2026.i - 1] and Y = S[i\\u2026 LEN - 1] form some scramble to generate \\'R\\'.\\n* So we traverse i (length of the substr) from 1 to LEN-1\\n* Eg i=1 for \"coder\" splits it into \"c\" & \"oder\" and then we can check recursively & swap/not swap to check for scramble condition\\n* i=0 would have spit the string \"coder\" into \"\" & \"coder\" which is not allowed as said in the question ...**we can only swap non leaf nod**es  \\n* Let ISSCRAMBLE(\\'S\\', \\'R\\') be the recursive function that returns true if \\'R\\' is a scramble of \\'S\\' else it returns false.\\n* Now we will generate all the possible substrings of \\'S\\' and check whether they form a scramble or not.\\n* If \\'S\\' is equal to \\'R\\', then return true. It is the base case. Or if the current \\'S\\' has length = 1, then also we need to return true or false depending upon its equality with its counterpart in \\'R\\'.\\n* Let\\u2019s say that we cut the string \\'S\\' at index i. Now there are two options.\\nS[0, i] scrambles into R[0, i] and S[i, N] can scramble into R[i,N].    // No Swapping\\nS[0, i] can scramble into R[i + 1, N] and S[i, N] can scramble into R[0, N - i    // Swapping\\n### Recusrive Code\\n```\\n bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n {\\n// no swap\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) \\nreturn true;\\n\\n// swap\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))\\nreturn true;\\n        }\\n        return false;\\n    }\\n```\\n### Optimized Recursion\\n\\n* An optimization step to consider here is to check beforehand if the two strings are anagrams of each other. If not, it indicates that the strings contain different characters and can\\u2019t be a scrambled form of each other\\n### Code\\n```\\n bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n        \\n\\t\\t// checking for not anagrams \\n          int count[26] = {0};\\n        for(int i=0; i<n; i++){\\n            count[s1[i]-\\'a\\']++;\\n            count[s2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(count[i]!=0)\\n                return false;\\n        }\\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n        {\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) return true;\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))return true;\\n        }\\n        return false;\\n    }\\n```\\n### Memoization (172 ms)\\n* We \\'ll take a map with the concatenation of both strings as key and if both keys were already processed before in the previous recusion calls then no need to call the recusive function for that part , we can simply return from the map itself\\n```\\nunordered_map<string,bool> mp;\\n    bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n       \\n        if(mp.find(s1+s2)!=mp.end())\\n            return mp[s1+s2];\\n        \\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n        {\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) return mp[s1+s2] = true;\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))return mp[s1+s2] = true;\\n        }\\n        return mp[s1+s2]=false;\\n    }\\n```\\n### Memoization with optimization\\n* We can check for the anagram condition too & this will reduce the time complexity significantly\\n* Just add this code \\n```\\n  string temp1 = s1;\\n    string temp2 = s2;\\n    sort(temp1.begin(), temp1.end());\\n    sort(temp2.begin(), temp2.end());\\n     \\n    if(temp1.compare(temp2) != 0) return false;\\n```\\n### OR\\n```\\n int count[26] = {0};\\n        for(int i=0; i<n; i++){\\n            count[s1[i]-\\'a\\']++;\\n            count[s2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(count[i]!=0)\\n                return false;\\n        }\\n```\\n### Therefore Final Memoized Code with Optimization( 8 ms)\\n```\\nunordered_map<string,bool> mp;\\n    bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n        \\n    string temp1 = s1;\\n    string temp2 = s2;\\n    sort(temp1.begin(), temp1.end());\\n    sort(temp2.begin(), temp2.end());\\n     \\n    if(temp1.compare(temp2) != 0) return false;\\n       \\n        if(mp.find(s1+s2)!=mp.end())\\n            return mp[s1+s2];\\n        \\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n        {\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) return mp[s1+s2] = true;\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))return mp[s1+s2] = true;\\n        }\\n        return mp[s1+s2]=false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    coder\\n   /    \\\\\\n  co    der\\n / \\\\    /  \\\\\\nc   o  d   er\\n           / \\\\\\n          e   r\\n```\n```\\n  ocder\\n   /    \\\\\\n  oc    der\\n / \\\\    /  \\\\\\no   c  d   er\\n           / \\\\\\n          e   r\\n```\n```\\n bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n {\\n// no swap\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) \\nreturn true;\\n\\n// swap\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))\\nreturn true;\\n        }\\n        return false;\\n    }\\n```\n```\\n bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n        \\n\\t\\t// checking for not anagrams \\n          int count[26] = {0};\\n        for(int i=0; i<n; i++){\\n            count[s1[i]-\\'a\\']++;\\n            count[s2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(count[i]!=0)\\n                return false;\\n        }\\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n        {\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) return true;\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))return true;\\n        }\\n        return false;\\n    }\\n```\n```\\nunordered_map<string,bool> mp;\\n    bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n       \\n        if(mp.find(s1+s2)!=mp.end())\\n            return mp[s1+s2];\\n        \\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n        {\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) return mp[s1+s2] = true;\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))return mp[s1+s2] = true;\\n        }\\n        return mp[s1+s2]=false;\\n    }\\n```\n```\\n  string temp1 = s1;\\n    string temp2 = s2;\\n    sort(temp1.begin(), temp1.end());\\n    sort(temp2.begin(), temp2.end());\\n     \\n    if(temp1.compare(temp2) != 0) return false;\\n```\n```\\n int count[26] = {0};\\n        for(int i=0; i<n; i++){\\n            count[s1[i]-\\'a\\']++;\\n            count[s2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(count[i]!=0)\\n                return false;\\n        }\\n```\n```\\nunordered_map<string,bool> mp;\\n    bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n        \\n    string temp1 = s1;\\n    string temp2 = s2;\\n    sort(temp1.begin(), temp1.end());\\n    sort(temp2.begin(), temp2.end());\\n     \\n    if(temp1.compare(temp2) != 0) return false;\\n       \\n        if(mp.find(s1+s2)!=mp.end())\\n            return mp[s1+s2];\\n        \\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n        {\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) return mp[s1+s2] = true;\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))return mp[s1+s2] = true;\\n        }\\n        return mp[s1+s2]=false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1161093,
                "title": "real-dynamic-programming-solution",
                "content": "This question is really difficult for DP solution, I\\'m not good as English writing. We need is a 3-D DP matrix `dp[i][j][k]`, ` i, j` is index from s1 and s2 respectively, and k represents length. We will start from k == 1 (length == 1). Thus `dp[i][j][1] = True` if `s1[i] == s2[j]`.\\nThen come to situations that k > 1, use `w: range(1, k)` to \\'cut\\' strings s1 and s2 which start from index i, j and length equals to k into two parts:\\n`s1[i: i+k] -> s1[i: i+w], s1[i+w: i+k]`\\n`s2[j: j+k] -> s2[j: j+w], s2[j+w: j+k]`\\nor\\n`s1[i: i+k] -> s1[i: i+w], s1[i+w: i+k]`\\n`s2[j: j+k] -> s2[j: j+k-w], s2[j+k-w: j+k]`\\n\\n`dp[i][j][k] = True` if `(dp[i][j][w] and dp[i+w][j+w][k-w]) or (dp[i][j+k-w][w] and dp[i+w][j][k-w])` is True.\\n```\\nfrom itertools import product\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        lt = len(s1) # len(s1) == len(s2)\\n        # 3-D DP matrix\\n        dp = [[[False]*(lt + 1) for _ in range(lt)] for _ in range(lt)]\\n\\t\\t# Initialize DP matrix\\n        for i, j in product(range(lt), range(lt)):\\n            dp[i][j][1] = s1[i] == s2[j]\\n\\t\\t\\n        for k in range(2, lt + 1):\\n            for i in range(lt - k + 1):\\n                for j in range(lt - k + 1):\\n                    for w in range(1, k):\\n                        # \\u540E\\u534A\\u6BB5dp[i][j+k-w][w] and dp[i+w][j][k-w]\\u6BD4\\u8F83\\u62BD\\u8C61\\uFF0C\\u5EFA\\u8BAE\\u5728\\u7EB8\\u4E0A\\u753B\\u51FA\\u6765\\n                        if (dp[i][j][w] and dp[i+w][j+w][k-w]) or (dp[i][j+k-w][w] and dp[i+w][j][k-w]):\\n                            dp[i][j][k] = True\\n                            break\\n        return dp[0][0][lt]\\n```\\n\\nIt\\'s much easier to figure a recursion solution:\\n```\\nclass Solution:\\n    @functools.lru_cache(None)\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if sorted(s1) != sorted(s2): return False\\n        l = len(s1)\\n        if l < 4 or s1 == s2: return True\\n        f = self.isScramble\\n        for i in range(1, l):\\n            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\\\\n                f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\\n                return True\\n        return False\\n```\\nor we can use hash map to replace `@functools.lru_cache(None)`\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.dic = {}\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        k = (s1, s2)\\n        if k in self.dic: return self.dic[k]\\n        if sorted(s1) != sorted(s2):\\n            self.dic[k] = False\\n            return False\\n        l = len(s1)\\n        if l < 4 or s1 == s2:\\n            self.dic[k] = True\\n            return True\\n        f = self.isScramble\\n        for i in range(1, l):\\n            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\\\\n                f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\\n                self.dic[k] = True\\n                return True\\n        self.dic[k] = False\\n        return False\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfrom itertools import product\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        lt = len(s1) # len(s1) == len(s2)\\n        # 3-D DP matrix\\n        dp = [[[False]*(lt + 1) for _ in range(lt)] for _ in range(lt)]\\n\\t\\t# Initialize DP matrix\\n        for i, j in product(range(lt), range(lt)):\\n            dp[i][j][1] = s1[i] == s2[j]\\n\\t\\t\\n        for k in range(2, lt + 1):\\n            for i in range(lt - k + 1):\\n                for j in range(lt - k + 1):\\n                    for w in range(1, k):\\n                        # \\u540E\\u534A\\u6BB5dp[i][j+k-w][w] and dp[i+w][j][k-w]\\u6BD4\\u8F83\\u62BD\\u8C61\\uFF0C\\u5EFA\\u8BAE\\u5728\\u7EB8\\u4E0A\\u753B\\u51FA\\u6765\\n                        if (dp[i][j][w] and dp[i+w][j+w][k-w]) or (dp[i][j+k-w][w] and dp[i+w][j][k-w]):\\n                            dp[i][j][k] = True\\n                            break\\n        return dp[0][0][lt]\\n```\n```\\nclass Solution:\\n    @functools.lru_cache(None)\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if sorted(s1) != sorted(s2): return False\\n        l = len(s1)\\n        if l < 4 or s1 == s2: return True\\n        f = self.isScramble\\n        for i in range(1, l):\\n            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\\\\n                f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\\n                return True\\n        return False\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.dic = {}\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        k = (s1, s2)\\n        if k in self.dic: return self.dic[k]\\n        if sorted(s1) != sorted(s2):\\n            self.dic[k] = False\\n            return False\\n        l = len(s1)\\n        if l < 4 or s1 == s2:\\n            self.dic[k] = True\\n            return True\\n        f = self.isScramble\\n        for i in range(1, l):\\n            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\\\\n                f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\\n                self.dic[k] = True\\n                return True\\n        self.dic[k] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030883,
                "title": "java-2ms-recursive-memoization-frequency-check",
                "content": "```\\n    Map<String, Boolean> memo = new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.equals(s2))\\n            return true;\\n        if(!equalByFreq(s1, s2))\\n            return false;\\n        \\n        String key = s1+s2;\\n        if(memo.containsKey(key))\\n            return memo.get(key);\\n        \\n        int len1 = s1.length(), len2 = s2.length();\\n        boolean match = false;\\n        for(int i = 1; i < s1.length(); i++){\\n            String p1 = s1.substring(0,i);\\n            String p2 = s1.substring(i);\\n            \\n            match = isScramble(p1, s2.substring(0, i)) && isScramble(p2, s2.substring(i));\\n            if(match)\\n                break;\\n            match = isScramble(p1, s2.substring(len2-i)) && isScramble(p2, s2.substring(0, len2-i));\\n            if(match)\\n                break;\\n        }\\n        \\n        memo.put(key, match);\\n        return match;\\n    }\\n    \\n    public boolean equalByFreq(String s1, String s2){\\n        int xor = 0;\\n        for(int i= 0; i < s1.length(); i++){\\n            xor ^= (s1.charAt(i)-\\'a\\')^(s2.charAt(i)-\\'a\\');\\n        }\\n        return xor == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Map<String, Boolean> memo = new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.equals(s2))\\n            return true;\\n        if(!equalByFreq(s1, s2))\\n            return false;\\n        \\n        String key = s1+s2;\\n        if(memo.containsKey(key))\\n            return memo.get(key);\\n        \\n        int len1 = s1.length(), len2 = s2.length();\\n        boolean match = false;\\n        for(int i = 1; i < s1.length(); i++){\\n            String p1 = s1.substring(0,i);\\n            String p2 = s1.substring(i);\\n            \\n            match = isScramble(p1, s2.substring(0, i)) && isScramble(p2, s2.substring(i));\\n            if(match)\\n                break;\\n            match = isScramble(p1, s2.substring(len2-i)) && isScramble(p2, s2.substring(0, len2-i));\\n            if(match)\\n                break;\\n        }\\n        \\n        memo.put(key, match);\\n        return match;\\n    }\\n    \\n    public boolean equalByFreq(String s1, String s2){\\n        int xor = 0;\\n        for(int i= 0; i < s1.length(); i++){\\n            xor ^= (s1.charAt(i)-\\'a\\')^(s2.charAt(i)-\\'a\\');\\n        }\\n        return xor == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011971,
                "title": "accepted-python-solution-with-template-method",
                "content": "Despite the misleading word \"randomly\" in the description, this problem is a typical problem that can be solved by **memory+dfs**, in other words, **dynamic programming**.\\n\\nwe use ```memo``` to store the sub-problem already known, and function ```dfs(s1, s2)``` to solve the problem recursively.\\n\\nFor a recursive function, we need to figure out several simple cases that can return the answer directly, and some difficult cases.\\n1. We sort the ```s1``` and ```s2```, if ```s1!=s2```, return ```false``` because in this case, ```s1```miss some letters in ```s2```.\\n2. If ```s1 == s2```, ok they are same so return ```true```.\\n3. Else, we try every possible position to swap or not, to see if we can find a ```true``` case. Note once we find a ```true``` case, we do not need to test anymore, we can return ```true``` immediately.\\n\\nHere is my code:\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        memo = {}\\n        def dfs(s1, s2):\\n            if (s1, s2) not in memo:\\n                if sorted(s1) != sorted(s2):\\n                    flag = False\\n                elif s1 == s2:\\n                    flag = True\\n                else:\\n                    for i in range(1, len(s1)):\\n                        flag = (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) \\\\\\n                                or (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i]))\\n                        if flag:\\n                            break\\n                memo[s1,s2] = flag\\n            return memo[s1,s2]\\n              \\n        return dfs(s1, s2)\\n```\\nAlso, you can solve the [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/) and [Edit Distance](https://leetcode.com/problems/edit-distance/) with the same template method.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```memo```\n```dfs(s1, s2)```\n```s1```\n```s2```\n```s1!=s2```\n```false```\n```s1```\n```s2```\n```s1 == s2```\n```true```\n```true```\n```true```\n```true```\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        memo = {}\\n        def dfs(s1, s2):\\n            if (s1, s2) not in memo:\\n                if sorted(s1) != sorted(s2):\\n                    flag = False\\n                elif s1 == s2:\\n                    flag = True\\n                else:\\n                    for i in range(1, len(s1)):\\n                        flag = (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) \\\\\\n                                or (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i]))\\n                        if flag:\\n                            break\\n                memo[s1,s2] = flag\\n            return memo[s1,s2]\\n              \\n        return dfs(s1, s2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894283,
                "title": "beats-100-time-short-and-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool shouldMatch(string s1,string s2)\\n    {\\n        int arr1[26]={0};\\n        int arr2[26]={0};\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            arr1[s1[i]-\\'a\\']++;\\n            arr2[s2[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr1[i]-arr2[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        if(s1==s2)\\n            return true;\\n        if(!shouldMatch(s1,s2))\\n            return false;\\n        bool b=false;\\n        for(int i=1;i<s1.length();i++)\\n        {\\n            b=b||(isScramble(s1.substr(0,i),s2.substr(0,i))&&(isScramble(s1.substr(i),s2.substr(i)))||(isScramble(s1.substr(0,i),s2.substr(s1.length()-i))&&(isScramble(s1.substr(i),s2.substr(0,s1.length()-i)))));\\n        }\\n        return b;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool shouldMatch(string s1,string s2)\\n    {\\n        int arr1[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 813790,
                "title": "javascript-recursive-with-dp",
                "content": "```\\nvar isScramble = function(s1, s2) {\\n    return helper(s1, s2, {})\\n};\\n\\nvar helper = function(s1, s2, dp) {\\n    if (dp[s1 + s2] != undefined || dp[s2 + s1] != undefined) {\\n        return dp[s1 + s2]\\n    } else if (s1 == s2) {\\n        return true\\n    } else if (s1.length != s2.length) {\\n        return false\\n    } else if (s1.length <= 1) {\\n        return s1 == s2\\n    }\\n    for (let i = 1; i < s1.length; i++) {\\n        if ((helper(s1.slice(0, i), s2.slice(0, i), dp) && helper(s1.slice(i), s2.slice(i), dp)) ||\\n            (helper(s1.slice(0, i), s2.slice(s1.length - i), dp) && helper(s1.slice(i), s2.slice(0, s1.length - i), dp))) {\\n            dp[s1 + s2] = true\\n            return true\\n        }\\n    }\\n    dp[s1 + s2] = false\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isScramble = function(s1, s2) {\\n    return helper(s1, s2, {})\\n};\\n\\nvar helper = function(s1, s2, dp) {\\n    if (dp[s1 + s2] != undefined || dp[s2 + s1] != undefined) {\\n        return dp[s1 + s2]\\n    } else if (s1 == s2) {\\n        return true\\n    } else if (s1.length != s2.length) {\\n        return false\\n    } else if (s1.length <= 1) {\\n        return s1 == s2\\n    }\\n    for (let i = 1; i < s1.length; i++) {\\n        if ((helper(s1.slice(0, i), s2.slice(0, i), dp) && helper(s1.slice(i), s2.slice(i), dp)) ||\\n            (helper(s1.slice(0, i), s2.slice(s1.length - i), dp) && helper(s1.slice(i), s2.slice(0, s1.length - i), dp))) {\\n            dp[s1 + s2] = true\\n            return true\\n        }\\n    }\\n    dp[s1 + s2] = false\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 772077,
                "title": "c-dp-solution",
                "content": "The method \"isomorphic\" tests whether two strings consist of the same set of chars.\\nThen we use three-dimensional dp. The first two dimensions represent the i th and j th position of string s1 and s2, respectively, and the third dimension represents the length of substring starting from i th and j th position. The bool stored in dp represents whether these two substrings is scramble.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isomorphic(string s1, string s2){\\n        int cnt1[26];\\n        int cnt2[26];\\n        memset(cnt1, 0, sizeof(cnt1));\\n        memset(cnt2, 0, sizeof(cnt2));\\n        for (int i=0; i<s1.length(); i++) cnt1[s1[i]-\\'a\\']++;\\n        for (int i=0; i<s2.length(); i++) cnt2[s2[i]-\\'a\\']++;\\n        for (int i=0; i<26; i++){\\n            if (cnt1[i] != cnt2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if (!isomorphic(s1, s2)) return false;\\n        int len = s1.length();\\n        bool dp[len+1][len+1][len+1];  \\n        for (int i=0; i<len; i++){\\n            for (int j=0; j<len; j++){\\n                for (int k=1; k<=len; k++){\\n                    dp[i][j][k] = false;\\n                }\\n            }\\n        }\\n        for (int k=1; k<=len; k++){\\n            for (int i=0; i<len; i++){\\n                for (int j=0; j<len; j++){\\n                    if (k+max(i, j)>len) break;\\n                    if (isomorphic(s1.substr(i, k), s2.substr(j, k))){\\n                        if (k<=3){\\n                            dp[i][j][k] = true;\\n                            continue;\\n                        }\\n                        bool res = false;\\n                        for (int t=1; t<k; t++){\\n                            bool good1 = dp[i][j][t] && dp[i+t][j+t][k-t];\\n                            bool good2 = dp[i][j+k-t][t] && dp[i+t][j][k-t];\\n                            res = res||good1||good2;\\n                            if (res) break;\\n                        }\\n                        dp[i][j][k] = res;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][len];\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isomorphic(string s1, string s2){\\n        int cnt1[26];\\n        int cnt2[26];\\n        memset(cnt1, 0, sizeof(cnt1));\\n        memset(cnt2, 0, sizeof(cnt2));\\n        for (int i=0; i<s1.length(); i++) cnt1[s1[i]-\\'a\\']++;\\n        for (int i=0; i<s2.length(); i++) cnt2[s2[i]-\\'a\\']++;\\n        for (int i=0; i<26; i++){\\n            if (cnt1[i] != cnt2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if (!isomorphic(s1, s2)) return false;\\n        int len = s1.length();\\n        bool dp[len+1][len+1][len+1];  \\n        for (int i=0; i<len; i++){\\n            for (int j=0; j<len; j++){\\n                for (int k=1; k<=len; k++){\\n                    dp[i][j][k] = false;\\n                }\\n            }\\n        }\\n        for (int k=1; k<=len; k++){\\n            for (int i=0; i<len; i++){\\n                for (int j=0; j<len; j++){\\n                    if (k+max(i, j)>len) break;\\n                    if (isomorphic(s1.substr(i, k), s2.substr(j, k))){\\n                        if (k<=3){\\n                            dp[i][j][k] = true;\\n                            continue;\\n                        }\\n                        bool res = false;\\n                        for (int t=1; t<k; t++){\\n                            bool good1 = dp[i][j][t] && dp[i+t][j+t][k-t];\\n                            bool good2 = dp[i][j+k-t][t] && dp[i+t][j][k-t];\\n                            res = res||good1||good2;\\n                            if (res) break;\\n                        }\\n                        dp[i][j][k] = res;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][len];\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725614,
                "title": "87-scramble-string-2-solutions-c-little-tricky-question-only",
                "content": "1: solution with recursion + memoization:\\n\\n```\\nclass Solution {\\npublic:\\n   unordered_map<string,bool>DP;\\n\\nbool solve(string s1,string s2){\\n   \\n    if(s1.compare(s2)==0)return 1;                  \\n    if(s1.size()<=1)return 0; \\n\\t\\n    string key=s1+\" \"+s2;\\n    if(DP.find(key)!=DP.end())\\n        return DP[key];\\n\\t\\n    bool ans=0;\\n    int n=s1.size();\\n    \\n    for(int i=1;i<n;i++)\\n    {\\n        bool temp1=solve(s1.substr(0,i),s2.substr(n-i,i)) && solve(s1.substr(i,n-i),s2.substr(0,n-i));\\n        \\n        bool temp2=solve(s1.substr(0,i),s2.substr(0,i)) && solve(s1.substr(i,n-i),s2.substr(i,n-i));\\n        \\n        ans=temp1||temp2;\\n        \\n        if(ans==1)\\n            break;\\n        \\n    }\\n    \\n    return DP[key]=ans;\\n}\\n\\nbool isScramble(string s1, string s2) \\n{\\n    if(s1.length()!=s2.length())\\n        return 0;\\n    if(s1.length()==0)\\n        return 1;\\n    \\n    return solve(s1,s2);    \\n}\\n};\\n```\\n2: Only recursive :\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool isScramble(string s1, string s2) {\\n        if(s1.length() != s2.length()){\\n            return false;\\n        }\\n        \\n        if(s1 == s2){\\n            return true;\\n        }\\n\\n        string temp1 = s1, temp2 = s2;\\n        sort(temp1.begin(),temp1.end());\\n        sort(temp2.begin(),temp2.end());\\n        if(temp1 != temp2){\\n            return false;\\n        }\\n        \\n        int L = s1.length();\\n        for(int i = 1; i < L; i++){\\n            if((isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,L-i),s2.substr(i,L-i))) ||\\n                (isScramble(s1.substr(0,i),s2.substr(L-i,i)) && isScramble(s1.substr(i,L-i),s2.substr(0,L-i)))){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   unordered_map<string,bool>DP;\\n\\nbool solve(string s1,string s2){\\n   \\n    if(s1.compare(s2)==0)return 1;                  \\n    if(s1.size()<=1)return 0; \\n\\t\\n    string key=s1+\" \"+s2;\\n    if(DP.find(key)!=DP.end())\\n        return DP[key];\\n\\t\\n    bool ans=0;\\n    int n=s1.size();\\n    \\n    for(int i=1;i<n;i++)\\n    {\\n        bool temp1=solve(s1.substr(0,i),s2.substr(n-i,i)) && solve(s1.substr(i,n-i),s2.substr(0,n-i));\\n        \\n        bool temp2=solve(s1.substr(0,i),s2.substr(0,i)) && solve(s1.substr(i,n-i),s2.substr(i,n-i));\\n        \\n        ans=temp1||temp2;\\n        \\n        if(ans==1)\\n            break;\\n        \\n    }\\n    \\n    return DP[key]=ans;\\n}\\n\\nbool isScramble(string s1, string s2) \\n{\\n    if(s1.length()!=s2.length())\\n        return 0;\\n    if(s1.length()==0)\\n        return 1;\\n    \\n    return solve(s1,s2);    \\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool isScramble(string s1, string s2) {\\n        if(s1.length() != s2.length()){\\n            return false;\\n        }\\n        \\n        if(s1 == s2){\\n            return true;\\n        }\\n\\n        string temp1 = s1, temp2 = s2;\\n        sort(temp1.begin(),temp1.end());\\n        sort(temp2.begin(),temp2.end());\\n        if(temp1 != temp2){\\n            return false;\\n        }\\n        \\n        int L = s1.length();\\n        for(int i = 1; i < L; i++){\\n            if((isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,L-i),s2.substr(i,L-i))) ||\\n                (isScramble(s1.substr(0,i),s2.substr(L-i,i)) && isScramble(s1.substr(i,L-i),s2.substr(0,L-i)))){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 700242,
                "title": "98-faster-c-solution-recursion-with-memoization",
                "content": "class Solution {\\npublic:\\n    \\n    unordered_map<string,bool>DP;\\n    \\n    bool solve(string s1,string s2){\\n       \\n        if(s1.compare(s2)==0)return 1;                  \\n        if(s1.size()<=1)return 0; \\n\\t\\t\\n        string key=s1+\" \"+s2;\\n        if(DP.find(key)!=DP.end())\\n            return DP[key];\\n\\t\\t\\n        bool ans=0;\\n        int n=s1.size();\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            bool temp1=solve(s1.substr(0,i),s2.substr(n-i,i)) && solve(s1.substr(i,n-i),s2.substr(0,n-i));\\n            \\n            bool temp2=solve(s1.substr(0,i),s2.substr(0,i)) && solve(s1.substr(i,n-i),s2.substr(i,n-i));\\n            \\n            ans=temp1||temp2;\\n            \\n            if(ans==1)\\n                break;\\n            \\n        }\\n        \\n        return DP[key]=ans;\\n    }\\n\\t\\n    bool isScramble(string s1, string s2) \\n    {\\n        if(s1.length()!=s2.length())\\n            return 0;\\n        if(s1.length()==0)\\n            return 1;\\n        \\n        return solve(s1,s2);    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    unordered_map<string,bool>DP;\\n    \\n    bool solve(string s1,string s2){\\n       \\n        if(s1.compare(s2)==0)return 1;                  \\n        if(s1.size()<=1)return 0; \\n\\t\\t\\n        string key=s1+\" \"+s2;\\n        if(DP.find(key)!=DP.end())\\n            return DP[key];\\n\\t\\t\\n        bool ans=0;\\n        int n=s1.size();\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            bool temp1=solve(s1.substr(0,i),s2.substr(n-i,i)) && solve(s1.substr(i,n-i),s2.substr(0,n-i));\\n            \\n            bool temp2=solve(s1.substr(0,i),s2.substr(0,i)) && solve(s1.substr(i,n-i),s2.substr(i,n-i));\\n            \\n            ans=temp1||temp2;\\n            \\n            if(ans==1)\\n                break;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 676186,
                "title": "javascript-solution",
                "content": "```\\nvar isScramble = function (s1, s2) {\\n  if (s1 === s2) return true;\\n  if (!isAnagram(s1, s2)) return false;\\n\\n  // boundaries are because the substrings being non-empty is a requirement\\n  for (let i = 1; i < s1.length; ++i) {\\n    if (\\n      isScramble(s1.substr(0, i), s2.substr(0, i)) &&\\n      isScramble(s1.substr(i), s2.substr(i))\\n    )\\n      return true;\\n\\n    if (\\n      isScramble(s1.substr(0, i), s2.substr(s1.length - i)) &&\\n      isScramble(s1.substr(i), s2.substr(0, s1.length - i))\\n    )\\n      return true;\\n  }\\n  return false;\\n};\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n  const map = {};\\n\\n  for (let i = 0; i < s.length; ++i) {\\n    map[s[i]] ? map[s[i]]++ : (map[s[i]] = 1);\\n  }\\n\\n  for (let i = 0; i < t.length; ++i) {\\n    if (map[t[i]]) map[t[i]]--;\\n    else return false;\\n  }\\n\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isScramble = function (s1, s2) {\\n  if (s1 === s2) return true;\\n  if (!isAnagram(s1, s2)) return false;\\n\\n  // boundaries are because the substrings being non-empty is a requirement\\n  for (let i = 1; i < s1.length; ++i) {\\n    if (\\n      isScramble(s1.substr(0, i), s2.substr(0, i)) &&\\n      isScramble(s1.substr(i), s2.substr(i))\\n    )\\n      return true;\\n\\n    if (\\n      isScramble(s1.substr(0, i), s2.substr(s1.length - i)) &&\\n      isScramble(s1.substr(i), s2.substr(0, s1.length - i))\\n    )\\n      return true;\\n  }\\n  return false;\\n};\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n  const map = {};\\n\\n  for (let i = 0; i < s.length; ++i) {\\n    map[s[i]] ? map[s[i]]++ : (map[s[i]] = 1);\\n  }\\n\\n  for (let i = 0; i < t.length; ++i) {\\n    if (map[t[i]]) map[t[i]]--;\\n    else return false;\\n  }\\n\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540524,
                "title": "c-8ms-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isScramble(string s1, string s2) {\\n\\t\\t\\tif(s1==s2) return true;\\n\\t\\t\\tvector<int> cnt(26,0);\\n\\t\\t\\tint len1=s1.size(); \\n\\t\\t\\tfor(int i=0;i<len1;i++){\\n\\t\\t\\t\\tcnt[s1[i]-\\'a\\']++;\\n\\t\\t\\t\\tcnt[s2[i]-\\'a\\']--;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<cnt.size();i++){\\n\\t\\t\\t\\tif(cnt[i]!=0) return false;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1;i<len1;i++){\\n\\n\\t\\t\\t\\tif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i),s2.substr(i))){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isScramble(s1.substr(0,i),s2.substr(len1-i)) && isScramble(s1.substr(i),s2.substr(0,len1-i))){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\treturn false; \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isScramble(string s1, string s2) {\\n\\t\\t\\tif(s1==s2) return true;\\n\\t\\t\\tvector<int> cnt(26,0);\\n\\t\\t\\tint len1=s1.size(); \\n\\t\\t\\tfor(int i=0;i<len1;i++){\\n\\t\\t\\t\\tcnt[s1[i]-\\'a\\']++;\\n\\t\\t\\t\\tcnt[s2[i]-\\'a\\']--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 464410,
                "title": "java-recursive-solution",
                "content": "```\\n// The idea is that for s2 to be scramble of s1 we consider the tree\\n// representation of the strings and they will be scramble only if\\n// every subtree in their representations is either same or mirror\\n// Catch is that for node equality, the strings can be equal or anagrams.\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n     int n = s1.length(), m = s2.length();\\n     if(n != m) return false;\\n     if(n == 0) return true;\\n     if(s1.equals(s2)) return true;\\n      \\n     int[] freq = new int[26];\\n     for(int i = 0; i < n; i++){\\n      freq[s1.charAt(i) - 97]++;\\n      freq[s2.charAt(i) - 97]--;   \\n     }\\n     // if freq[i] != 0  => different characters, hence node equality condition is violated.\\n     for(int i = 0; i < n; i++)\\n      if(freq[s1.charAt(i) - 97] != 0) return false;\\n     \\n\\t // The following loop has conditions similar to what we use for mirror trees.\\n     for(int i = 1; i < n; i++){\\n       if(isScramble(s1.substring(0,i),s2.substring(0,i))\\n       && isScramble(s1.substring(i),s2.substring(i)))\\n        return true;\\n       if(isScramble(s1.substring(0,i),s2.substring(n - i))\\n         && isScramble(s1.substring(i),s2.substring(0,n - i)))\\n        return true;   \\n     }\\n     return false;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// The idea is that for s2 to be scramble of s1 we consider the tree\\n// representation of the strings and they will be scramble only if\\n// every subtree in their representations is either same or mirror\\n// Catch is that for node equality, the strings can be equal or anagrams.\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n     int n = s1.length(), m = s2.length();\\n     if(n != m) return false;\\n     if(n == 0) return true;\\n     if(s1.equals(s2)) return true;\\n      \\n     int[] freq = new int[26];\\n     for(int i = 0; i < n; i++){\\n      freq[s1.charAt(i) - 97]++;\\n      freq[s2.charAt(i) - 97]--;   \\n     }\\n     // if freq[i] != 0  => different characters, hence node equality condition is violated.\\n     for(int i = 0; i < n; i++)\\n      if(freq[s1.charAt(i) - 97] != 0) return false;\\n     \\n\\t // The following loop has conditions similar to what we use for mirror trees.\\n     for(int i = 1; i < n; i++){\\n       if(isScramble(s1.substring(0,i),s2.substring(0,i))\\n       && isScramble(s1.substring(i),s2.substring(i)))\\n        return true;\\n       if(isScramble(s1.substring(0,i),s2.substring(n - i))\\n         && isScramble(s1.substring(i),s2.substring(0,n - i)))\\n        return true;   \\n     }\\n     return false;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428968,
                "title": "java-beat-100-o-n-space-o-n-2-time",
                "content": "Some other posts are using the same idea, without any analysis of the time complexity. Beating 100% is not a solid poof that this is a good algorithm. If you know how to analyze the time complexity of this algorithm, could you leave some explanation? Your help is appreciated!\\n\\nYou can also refer to the following links using the same idea:\\nhttps://leetcode.com/problems/scramble-string/discuss/401844/My-C++-Code:-0-ms-Average-Case:-O(nlogn)-Worst-Case:-O(n2)\\nhttps://leetcode.com/problems/scramble-string/discuss/365579/java-100\\n\\n```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1 == null || s2 == null || s1.length() != s2.length()) {return false;}  \\n        int length = s1.length();\\n        if(length == 0) {return true;}\\n        return isScramble(s1, 0, length - 1, s2, 0, length - 1);\\n    }\\n    \\n    private boolean isScramble(String s1, int startIdx1, int endIdx1, String s2, int startIdx2, int endIdx2) {\\n        if(startIdx1 == endIdx1) {return s1.charAt(startIdx1) == s2.charAt(startIdx2);}\\n        \\n        int i = startIdx1, j = startIdx2, count = 0;\\n        int[] counts = new int[128];\\n\\t\\t// find substrings that contain the same characters\\n\\t\\t// you can refer to problem 76. Minimum Window Substring to find out the trick here\\n        do {\\n            if(counts[s1.charAt(i++)]++ >= 0) {count++;}\\n            if(counts[s2.charAt(j++)]-- > 0) {count--;}\\n        } while(i < endIdx1 && count != 0);\\n        if(count == 0 && isScramble(s1, startIdx1, i - 1, s2, startIdx2, j - 1) &&\\n           isScramble(s1, i, endIdx1, s2, j, endIdx2)) {return true;}\\n        \\n        int i2 = startIdx1, j2 = endIdx2, count2 = 0;\\n        Arrays.fill(counts, 0);\\n        do {\\n            if(counts[s1.charAt(i2++)]++ >= 0) {count2++;}\\n            if(counts[s2.charAt(j2--)]-- > 0) {count2--;}\\n        } while(i2 < endIdx1 && count2 != 0);\\n        if(count2 == 0  && isScramble(s1, startIdx1, i2 - 1, s2, j2 + 1, endIdx2) &&\\n           isScramble(s1, i2, endIdx1, s2, startIdx2, j2)) {return true;}\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1 == null || s2 == null || s1.length() != s2.length()) {return false;}  \\n        int length = s1.length();\\n        if(length == 0) {return true;}\\n        return isScramble(s1, 0, length - 1, s2, 0, length - 1);\\n    }\\n    \\n    private boolean isScramble(String s1, int startIdx1, int endIdx1, String s2, int startIdx2, int endIdx2) {\\n        if(startIdx1 == endIdx1) {return s1.charAt(startIdx1) == s2.charAt(startIdx2);}\\n        \\n        int i = startIdx1, j = startIdx2, count = 0;\\n        int[] counts = new int[128];\\n\\t\\t// find substrings that contain the same characters\\n\\t\\t// you can refer to problem 76. Minimum Window Substring to find out the trick here\\n        do {\\n            if(counts[s1.charAt(i++)]++ >= 0) {count++;}\\n            if(counts[s2.charAt(j++)]-- > 0) {count--;}\\n        } while(i < endIdx1 && count != 0);\\n        if(count == 0 && isScramble(s1, startIdx1, i - 1, s2, startIdx2, j - 1) &&\\n           isScramble(s1, i, endIdx1, s2, j, endIdx2)) {return true;}\\n        \\n        int i2 = startIdx1, j2 = endIdx2, count2 = 0;\\n        Arrays.fill(counts, 0);\\n        do {\\n            if(counts[s1.charAt(i2++)]++ >= 0) {count2++;}\\n            if(counts[s2.charAt(j2--)]-- > 0) {count2--;}\\n        } while(i2 < endIdx1 && count2 != 0);\\n        if(count2 == 0  && isScramble(s1, startIdx1, i2 - 1, s2, j2 + 1, endIdx2) &&\\n           isScramble(s1, i2, endIdx1, s2, startIdx2, j2)) {return true;}\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394094,
                "title": "c-recursive-solution",
                "content": "```csharp\\npublic class Solution {\\n    public bool IsScramble(string s1, string s2) {\\n        // To avoid meaningless recursion, if charactors are not match, quit search\\n        var count = new int[26];\\n        foreach (var x in s1)\\n        {\\n            ++count[x - \\'a\\'];\\n        }\\n\\n        foreach (var x in s2)\\n        {\\n            --count[x - \\'a\\'];\\n        }\\n\\n        if (!count.All(x => x == 0))\\n        {\\n            return false;\\n        }\\n        /* End */\\n\\n        if (s1.Length <= 1) return true;\\n\\n        // Enum split points\\n        for (var i = 1; i < s1.Length; ++i)\\n        {\\n            // \\'gr rg\\' or \\'gr at\\'\\n            if (IsScramble(s1.Substring(0, i), s2.Substring(0, i))\\n                && IsScramble(s1.Substring(i), s2.Substring(i))\\n                || IsScramble(s1.Substring(0, i), s2.Substring(s2.Length - i))\\n                && IsScramble(s1.Substring(i), s2.Substring(0, s2.Length - i)))\\n            {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution {\\n    public bool IsScramble(string s1, string s2) {\\n        // To avoid meaningless recursion, if charactors are not match, quit search\\n        var count = new int[26];\\n        foreach (var x in s1)\\n        {\\n            ++count[x - \\'a\\'];\\n        }\\n\\n        foreach (var x in s2)\\n        {\\n            --count[x - \\'a\\'];\\n        }\\n\\n        if (!count.All(x => x == 0))\\n        {\\n            return false;\\n        }\\n        /* End */\\n\\n        if (s1.Length <= 1) return true;\\n\\n        // Enum split points\\n        for (var i = 1; i < s1.Length; ++i)\\n        {\\n            // \\'gr rg\\' or \\'gr at\\'\\n            if (IsScramble(s1.Substring(0, i), s2.Substring(0, i))\\n                && IsScramble(s1.Substring(i), s2.Substring(i))\\n                || IsScramble(s1.Substring(0, i), s2.Substring(s2.Length - i))\\n                && IsScramble(s1.Substring(i), s2.Substring(0, s2.Length - i)))\\n            {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339176,
                "title": "very-short-code-easy-to-understand-java-2ms",
                "content": "\\n```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        int[] check = new int[26];\\n        for(int i = 0; i < s1.length(); i++){\\n            char tmp = s1.charAt(i);\\n            check[tmp-\\'a\\']++;\\n        }\\n        for(int i = 0; i < s2.length(); i++){\\n            char tmp = s2.charAt(i);\\n            check[tmp-\\'a\\']--;\\n        }\\n        for(int val : check){\\n            if(val != 0) return false;\\n        }\\n        \\n        for(int i = 1; i < s1.length(); i++){  // < not <=\\n          \\n            if((isScramble(s1.substring(0, i), s2.substring(0, i)) && \\n                isScramble(s1.substring(i), s2.substring(i)))||\\n               (isScramble(s1.substring(0, i), s2.substring(s2.length()-i)) && \\n                isScramble(s1.substring(i), s2.substring(0,s2.length()-i))))\\n                return true;\\n        }\\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        int[] check = new int[26];\\n        for(int i = 0; i < s1.length(); i++){\\n            char tmp = s1.charAt(i);\\n            check[tmp-\\'a\\']++;\\n        }\\n        for(int i = 0; i < s2.length(); i++){\\n            char tmp = s2.charAt(i);\\n            check[tmp-\\'a\\']--;\\n        }\\n        for(int val : check){\\n            if(val != 0) return false;\\n        }\\n        \\n        for(int i = 1; i < s1.length(); i++){  // < not <=\\n          \\n            if((isScramble(s1.substring(0, i), s2.substring(0, i)) && \\n                isScramble(s1.substring(i), s2.substring(i)))||\\n               (isScramble(s1.substring(0, i), s2.substring(s2.length()-i)) && \\n                isScramble(s1.substring(i), s2.substring(0,s2.length()-i))))\\n                return true;\\n        }\\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327124,
                "title": "c-4ms-beat-96-with-explanation",
                "content": "**idea**\\n1. use a vector : ```s1_v``` to record s1\\'s char count from index ```0``` to ```i```.\\n2. use two vectors : \\n2.a ```s2_front``` to record s2\\'s char count from index ```0``` to ```i```.\\n2.b ```s2_back``` to record s2\\'s char count from index ```length()-i``` to ```end```\\n\\n```\\nif(s1_v == s2_front || s1_v == s2_back) : means scramble might exist when you cut at index-i\\n\\nso let\\'s divide into smaller problems :\\nif(s1_v == s2_front)\\n    isScramble(s1.front.substring,s2.front.substring) & isScramble(s1.back.substring,s2.back.substring)\\nelse if(s1_v == s2_back)\\n    isScramble(s1.front.substring,s2.back.substring) & isScramble(s1.back.substring,s2.front.substring)\\n```\\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2) return true; //ending condition\\n        int head = 0, size = s1.length();\\n        vector<int> s1_v(128,0),s2_front(128,0),s2_back(128,0);\\n        int any = 0;\\n        while(head < size-1){\\n            s1_v[s1[head]]++;\\n            s2_front[s2[head]]++;\\n            head++;\\n            s2_back[s2[size-head]]++;\\n            if(s1_v == s2_front)\\n                any |= isScramble(s1.substr(0,head),s2.substr(0,head)) & isScramble(s1.substr(head),s2.substr(head));\\n            else if(s1_v == s2_back)\\n                any |= isScramble(s1.substr(0,head),s2.substr(size-head)) & isScramble(s1.substr(head),s2.substr(0,size-head));\\n            if(any) //if any == false, this head position cannot make it happen. we need to go ahead to check next cutting index.\\n\\t\\t\\t    return true;\\n        }\\n        return any;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```s1_v```\n```0```\n```i```\n```s2_front```\n```0```\n```i```\n```s2_back```\n```length()-i```\n```end```\n```\\nif(s1_v == s2_front || s1_v == s2_back) : means scramble might exist when you cut at index-i\\n\\nso let\\'s divide into smaller problems :\\nif(s1_v == s2_front)\\n    isScramble(s1.front.substring,s2.front.substring) & isScramble(s1.back.substring,s2.back.substring)\\nelse if(s1_v == s2_back)\\n    isScramble(s1.front.substring,s2.back.substring) & isScramble(s1.back.substring,s2.front.substring)\\n```\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2) return true; //ending condition\\n        int head = 0, size = s1.length();\\n        vector<int> s1_v(128,0),s2_front(128,0),s2_back(128,0);\\n        int any = 0;\\n        while(head < size-1){\\n            s1_v[s1[head]]++;\\n            s2_front[s2[head]]++;\\n            head++;\\n            s2_back[s2[size-head]]++;\\n            if(s1_v == s2_front)\\n                any |= isScramble(s1.substr(0,head),s2.substr(0,head)) & isScramble(s1.substr(head),s2.substr(head));\\n            else if(s1_v == s2_back)\\n                any |= isScramble(s1.substr(0,head),s2.substr(size-head)) & isScramble(s1.substr(head),s2.substr(0,size-head));\\n            if(any) //if any == false, this head position cannot make it happen. we need to go ahead to check next cutting index.\\n\\t\\t\\t    return true;\\n        }\\n        return any;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316768,
                "title": "c-using-smart-slicing",
                "content": "What is the time complexity of this guy?\\n\\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        \\n        if (s1 == s2) { return true; }\\n        if (s1.size() != s2.size()) { return false; }\\n        \\n        string aComp1 = s1;\\n        string aComp2 = s2;\\n        \\n        int aLen = s1.size();\\n        \\n        sort(aComp1.begin(), aComp1.end());\\n        sort(aComp2.begin(), aComp2.end());\\n        if (aComp1 != aComp2) { return false; }\\n        \\n        for (int i=1;i<s1.size();i++) {\\n            \\n            string aComps11 = s1.substr(0, i);\\n            string aComps12 = s1.substr(i);\\n            \\n            string aComp1s21 = s2.substr(0, i);\\n            string aComp1s22 = s2.substr(i);\\n            \\n            string aComp2s21 = s2.substr(aLen - i);\\n            string aComp2s22 = s2.substr(0, aLen - i);\\n            \\n            if (isScramble(aComps11, aComp1s21) && isScramble(aComps12, aComp1s22)) {\\n                return true;\\n            }\\n            \\n            if (isScramble(aComps11, aComp2s21) && isScramble(aComps12, aComp2s22)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        \\n        if (s1 == s2) { return true; }\\n        if (s1.size() != s2.size()) { return false; }\\n        \\n        string aComp1 = s1;\\n        string aComp2 = s2;\\n        \\n        int aLen = s1.size();\\n        \\n        sort(aComp1.begin(), aComp1.end());\\n        sort(aComp2.begin(), aComp2.end());\\n        if (aComp1 != aComp2) { return false; }\\n        \\n        for (int i=1;i<s1.size();i++) {\\n            \\n            string aComps11 = s1.substr(0, i);\\n            string aComps12 = s1.substr(i);\\n            \\n            string aComp1s21 = s2.substr(0, i);\\n            string aComp1s22 = s2.substr(i);\\n            \\n            string aComp2s21 = s2.substr(aLen - i);\\n            string aComp2s22 = s2.substr(0, aLen - i);\\n            \\n            if (isScramble(aComps11, aComp1s21) && isScramble(aComps12, aComp1s22)) {\\n                return true;\\n            }\\n            \\n            if (isScramble(aComps11, aComp2s21) && isScramble(aComps12, aComp2s22)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162771,
                "title": "dp-solution-in-c-o-n-4-time-o-n-3-space",
                "content": "        const int m = s1.length(); \\n        \\n        if (m != s2.length()) {return false;}\\n        if (m == 0) {return true;}\\n        \\n        vector<vector<vector<bool>>> memo(m, vector<vector<bool>>(m, vector<bool>(m, false)));\\n        \\n        for (int i = m-1; i >= 0; i--) {\\n            \\n            // Init table\\n            for (int l = 0; l < m; l++) {\\n                if (s1[i] == s2[l]) {memo[i][i][l] = true;}\\n            }\\n            \\n            // Dynamic programming\\n            for (int j = i+1; j < m; j++) {\\n                for (int l = 0; l < m - (j-i); l++) {        \\n                    for (int k = i; k < j; k++) {\\n                        if (memo[i][k][l] && memo[k+1][j][l+k+1-i]) {memo[i][j][l] = true;}\\n                        if (memo[i][k][l+j-k] && memo[k+1][j][l]) {memo[i][j][l] = true;}\\n                    }                                        \\n                }\\n            } \\n        }\\n        \\n        for (int l = 0; l < m; l++) {\\n            if (memo[0][m-1][l] == true) {return true;}\\n        }\\n        \\n        return false;\\n\\t\\t\\t\\t\\nThe algorithm proceeds bottom up. For each substring of s2 running from index `i` to index `j`, I check whether, for an initial position in string s1 indexed by `l`, there exists an index `k` for which the substrings from `i` to `k` and from `k+1` to `j` can be obtained through scrambling. To perform this check, I consider the two possible cases, e.g. the two substrings appear in the same order in the original string or in an inverted order due to scrambling. The base case occurs for a substring of length 1, in this case it is sufficient to check whether the characters in `s1` and `s2` at indexes `i` and `l` are the same. ",
                "solutionTags": [],
                "code": "        const int m = s1.length(); \\n        \\n        if (m != s2.length()) {return false;}\\n        if (m == 0) {return true;}\\n        \\n        vector<vector<vector<bool>>> memo(m, vector<vector<bool>>(m, vector<bool>(m, false)));\\n        \\n        for (int i = m-1; i >= 0; i--) {\\n            \\n            // Init table\\n            for (int l = 0; l < m; l++) {\\n                if (s1[i] == s2[l]) {memo[i][i][l] = true;}\\n            }\\n            \\n            // Dynamic programming\\n            for (int j = i+1; j < m; j++) {\\n                for (int l = 0; l < m - (j-i); l++) {        \\n                    for (int k = i; k < j; k++) {\\n                        if (memo[i][k][l] && memo[k+1][j][l+k+1-i]) {memo[i][j][l] = true;}\\n                        if (memo[i][k][l+j-k] && memo[k+1][j][l]) {memo[i][j][l] = true;}\\n                    }                                        \\n                }\\n            } \\n        }\\n        \\n        for (int l = 0; l < m; l++) {\\n            if (memo[0][m-1][l] == true) {return true;}\\n        }\\n        \\n        return false;\\n\\t\\t\\t\\t\\nThe algorithm proceeds bottom up. For each substring of s2 running from index `i` to index `j`, I check whether, for an initial position in string s1 indexed by `l`, there exists an index `k` for which the substrings from `i` to `k` and from `k+1` to `j` can be obtained through scrambling. To perform this check, I consider the two possible cases, e.g. the two substrings appear in the same order in the original string or in an inverted order due to scrambling. The base case occurs for a substring of length 1, in this case it is sufficient to check whether the characters in `s1` and `s2` at indexes `i` and `l` are the same. ",
                "codeTag": "Unknown"
            },
            {
                "id": 29429,
                "title": "java-2ms-nlogn-recursive-solution",
                "content": "There are on average logn levels of recursive call, at each level, all together all chars are visit linearly.\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        if (n == 1) return s1.equals(s2);\\n        int[] map1 = new int[128], map2 = new int[128];\\n        for (int i = 0, cnt1 = 0, cnt2 = 0; i < n-1; i++) {\\n            if (map1[s1.charAt(i)]++ < 0) cnt1++;\\n            if (map1[s2.charAt(i)]-- > 0) cnt1++;\\n            if (cnt1 == i+1 &&\\n                isScramble(s1.substring(0, cnt1), s2.substring(0, cnt1)) && \\n                isScramble(s1.substring(cnt1), s2.substring(cnt1))) return true;\\n            if (map2[s1.charAt(i)]++ < 0) cnt2++;\\n            if (map2[s2.charAt(n-1-i)]-- > 0) cnt2++;\\n            if (cnt2 == i+1 &&\\n                isScramble(s1.substring(0, cnt2), s2.substring(n-cnt2)) &&\\n                isScramble(s1.substring(cnt2), s2.substring(0, n-cnt2))) return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "There are on average logn levels of recursive call, at each level, all together all chars are visit linearly.\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        if (n == 1) return s1.equals(s2);\\n        int[] map1 = new int[128], map2 = new int[128];\\n        for (int i = 0, cnt1 = 0, cnt2 = 0; i < n-1; i++) {\\n            if (map1[s1.charAt(i)]++ < 0) cnt1++;\\n            if (map1[s2.charAt(i)]-- > 0) cnt1++;\\n            if (cnt1 == i+1 &&\\n                isScramble(s1.substring(0, cnt1), s2.substring(0, cnt1)) && \\n                isScramble(s1.substring(cnt1), s2.substring(cnt1))) return true;\\n            if (map2[s1.charAt(i)]++ < 0) cnt2++;\\n            if (map2[s2.charAt(n-1-i)]-- > 0) cnt2++;\\n            if (cnt2 == i+1 &&\\n                isScramble(s1.substring(0, cnt2), s2.substring(n-cnt2)) &&\\n                isScramble(s1.substring(cnt2), s2.substring(0, n-cnt2))) return true;\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 29460,
                "title": "straightforward-c-dp-solution-o-n-4-time-o-n-3-space",
                "content": "This solution is based on a previous thread: https://leetcode.com/discuss/13258/my-o-n-4-solution-any-question\\n\\nThe basic idea of this algorithm is to maintain a three-dimension array (henceforth called eq[N][N][N+1]), where (eq[first1][first2][len] == true) if and only if (s1[first1 ... first1+len-1] == s2[first2 ... first2+len-1]). In order to simplify the notation, we discard eq[-][-][0].\\n\\nTime complexity: *O* (*n*^4)\\n\\nSpace complexity: *O* (*n*^3)\\n\\n    class Solution {\\n    public:\\n    \\tbool isScramble(string s1, string s2) {\\n    \\t\\tbool ret = true;\\n    \\t\\tsize_t n = s1.length();\\n    \\t\\tif (n > 0) // if s1 is empty, return true\\n    \\t\\t{\\n    \\t\\t\\t// Dynamic Programming: \\n    \\t\\t\\t// eq[first1][first2][len] == true iff s1[first1 ... first1+len) == s2[first2 ... first2+len)\\n    \\t\\t\\tvector<vector<vector<bool> > > eq\\n    \\t\\t\\t\\t(n, vector<vector<bool>>(n, vector<bool>(n + 1, false))); // initialize: all false\\n    \\n    \\t\\t\\t// initialize: eq[first1][first2][1] = true iff s1[first1] == s2[first2]\\n    \\t\\t    for (int first1 = 0; first1 < n; ++first1)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tfor (int first2 = 0; first2 < n; ++first2)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t    eq[first1][first2][1] = (s1[first1] == s2[first2]);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\t// dp: eq[first1][first2][len] = true iff two substrings are both matched.\\n    \\t\\t\\tfor (size_t len = 2; len <= n; ++len)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tfor (size_t first1 = 0; first1 + len <= n; ++first1)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tfor (size_t first2 = 0; first2 + len <= n; ++first2)\\n    \\t\\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t\\tfor (size_t len1 = 1; len1 < len; ++len1)\\n    \\t\\t\\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t\\t\\tsize_t len2 = len - len1;\\n    \\n    \\t\\t\\t\\t\\t\\t\\t// two substrings are not swapped\\n    \\t\\t\\t\\t\\t\\t\\tif (eq[first1][first2][len1] && eq[first1 + len1][first2 + len1][len2])\\n    \\t\\t\\t\\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t\\t\\t\\teq[first1][first2][len] = true;\\n    \\t\\t\\t\\t\\t\\t\\t}\\n    \\n    \\t\\t\\t\\t\\t\\t\\t// two substrings are swapped\\n    \\t\\t\\t\\t\\t\\t\\tif (eq[first1][first2 + len2][len1] && eq[first1 + len1][first2][len2])\\n    \\t\\t\\t\\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t\\t\\t\\teq[first1][first2][len] = true;\\n    \\t\\t\\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tret = eq[0][0][n];\\n    \\t\\t}\\n    \\t\\treturn ret;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tbool isScramble(string s1, string s2) {\\n    \\t\\tbool ret = true;\\n    \\t\\tsize_t n = s1.length();\\n    \\t\\tif (n > 0) // if s1 is empty, return true\\n    \\t\\t{\\n    \\t\\t\\t// Dynamic Programming: \\n    \\t\\t\\t// eq[first1][first2][len] == true iff s1[first1 ... first1+len) == s2[first2 ... first2+len)\\n    \\t\\t\\tvector<vector<vector<bool> > > eq\\n    \\t\\t\\t\\t(n, vector<vector<bool>>(n, vector<bool>(n + 1, false))); // initialize: all false\\n    \\n    \\t\\t\\t// initialize: eq[first1][first2][1] = true iff s1[first1] == s2[first2]\\n    \\t\\t    for (int first1 = 0; first1 < n; ++first1)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tfor (int first2 = 0; first2 < n; ++first2)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t    eq[first1][first2][1] = (s1[first1] == s2[first2]);\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 29473,
                "title": "share-my-c-recursive-solution",
                "content": "    bool isScramble( string s1, string s2 )\\n    {\\n    \\tif ( s1.length() != s2.length() )\\n    \\t\\treturn false;\\n    \\tint len = s1.length();\\n    \\tif ( s1 == s2 )\\n    \\t\\treturn true;\\n    \\tint table1[ 26 ] = { 0 }, table2[ 26 ] = { 0 };\\n    \\tfor ( int i = 0 ; i < len ; i ++ )\\n    \\t{\\n    \\t\\ttable1[ s1[ i ] - 'a' ] ++;\\n    \\t\\ttable2[ s2[ i ] - 'a' ] ++;\\n    \\t}\\n    \\tif ( memcmp( table1, table2, 26 * sizeof( int ) ) )\\n    \\t\\treturn false;\\n    \\tif ( len <= 3 )\\n    \\t\\treturn true;\\n    \\tfor ( int i = 1 ; i < len ; i ++ )\\n    \\t{\\n    \\t\\tif ( isScramble( s1.substr( 0, i ), s2.substr( 0, i ) ) &&\\n    \\t\\t\\tisScramble( s1.substr( i, len - i ), s2.substr( i, len - i ) ) )\\n    \\t\\t\\treturn true;\\n    \\t\\tif ( isScramble( s1.substr( 0, i ), s2.substr( len - i, i ) ) &&\\n    \\t\\t\\tisScramble( s1.substr( i, len - i), s2.substr( 0, len - i ) ) )\\n    \\t\\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool isScramble( string s1, string s2 )\\n    {\\n    \\tif ( s1.length() != s2.length() )\\n    \\t\\treturn false;\\n    \\tint len = s1.length();\\n    \\tif ( s1 == s2 )\\n    \\t\\treturn true;\\n    \\tint table1[ 26 ] = { 0 }, table2[ 26 ] = { 0 };\\n    \\tfor ( int i = 0 ; i < len ; i ++ )\\n    \\t{\\n    \\t\\ttable1[ s1[ i ] - 'a' ] ++;\\n    \\t\\ttable2[ s2[ i ] - 'a' ] ++;\\n    \\t}\\n    \\tif ( memcmp( table1, table2, 26 * sizeof( int ) ) )\\n    \\t\\treturn false;\\n    \\tif ( len <= 3 )\\n    \\t\\treturn true;\\n    \\tfor ( int i = 1 ; i < len ; i ++ )\\n    \\t{\\n    \\t\\tif ( isScramble( s1.substr( 0, i ), s2.substr( 0, i ) ) &&\\n    \\t\\t\\tisScramble( s1.substr( i, len - i ), s2.substr( i, len - i ) ) )\\n    \\t\\t\\treturn true;\\n    \\t\\tif ( isScramble( s1.substr( 0, i ), s2.substr( len - i, i ) ) &&\\n    \\t\\t\\tisScramble( s1.substr( i, len - i), s2.substr( 0, len - i ) ) )\\n    \\t\\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29480,
                "title": "accepted-python-dp-solution-what-s-the-time-complexity-of-this-solution",
                "content": "class Solution:\\n    # @return a boolean\\n    def __init__(self):\\n        self.cache = {}\\n        \\n    def isScramble(self, s1, s2):\\n        if (s1, s2) in self.cache:\\n            return self.cache[(s1, s2)]\\n            \\n        if len(s1) == 1:\\n            self.cache[(s1,s2)] = (s1 == s2)\\n            return self.cache[(s1,s2)]\\n            \\n        length = len(s2)\\n        for i in range(1, length): #split point 1~len(s2)-1\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) \\\\\\n                or (self.isScramble(s1[length-i:], s2[:i]) and self.isScramble(s1[:length-i], s2[i:])):\\n                self.cache[(s1,s2)] = True\\n                return True\\n        self.cache[(s1,s2)] = False\\n        return False\\n\\nI used Memoization DP. But I don't know if this solution is good enough. I think the time complexity is exponential as O(4^(length of string)), is it?\\nAny way to improve this solution?",
                "solutionTags": [],
                "code": "class Solution:\\n    # @return a boolean\\n    def __init__(self):\\n        self.cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 29464,
                "title": "time-complexity-of-this-code",
                "content": "    bool isScramble(string s1, string s2) {\\n            if(s1.size() != s2.size()) return false;\\n            if(s1 == s2) return true;\\n            int n = s1.size();\\n            vector<int> count(26, 0);\\n            for(int i = 0; i < n; i++) count[s1[i]-'a']++;\\n            for(int i = 0; i < n; i++) count[s2[i]-'a']--;\\n            for(auto i : count){\\n                if(i != 0) return false;\\n            }\\n            for(int i = 1; i < n; i++){\\n                if((isScramble(s1.substr(0, i), s2.substr(n-i, i))&&isScramble(s1.substr(i, n-i), s2.substr(0, n-i)))||\\n                    (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i, n-i), s2.substr(i, n-i))))\\n                    return true;\\n            }\\n            return false;\\n        }\\n\\nfind someone write this code said the time complexity is O(n^6), can someone explain why?",
                "solutionTags": [],
                "code": "    bool isScramble(string s1, string s2) {\\n            if(s1.size() != s2.size()) return false;\\n            if(s1 == s2) return true;\\n            int n = s1.size();\\n            vector<int> count(26, 0);\\n            for(int i = 0; i < n; i++) count[s1[i]-'a']++;\\n            for(int i = 0; i < n; i++) count[s2[i]-'a']--;\\n            for(auto i : count){\\n                if(i != 0) return false;\\n            }\\n            for(int i = 1; i < n; i++){\\n                if((isScramble(s1.substr(0, i), s2.substr(n-i, i))&&isScramble(s1.substr(i, n-i), s2.substr(0, n-i)))||\\n                    (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i, n-i), s2.substr(i, n-i))))\\n                    return true;\\n            }\\n            return false;\\n        }\\n\\nfind someone write this code said the time complexity is O(n^6), can someone explain why?",
                "codeTag": "Unknown"
            },
            {
                "id": 29492,
                "title": "my-o-n-4-solution-for-your-reference",
                "content": "    class Solution:\\n    # @return a boolean\\n    def isScramble(self, s1, s2):\\n        n=len(s1)\\n        if n==0: return True\\n        table=[[[None for i in range(n+1)] for i2 in range(n)] for i1 in range(n)] #table[i1][i2][i] stores if s1[i1:i1+i] is a scramble of s2[i2:i2+i]\\n        \\n        def helper(i1,i2,i):\\n            if table[i1][i2][i]==None:\\n                if i==1: \\n                    table[i1][i2][i]=(s1[i1]==s2[i2])\\n                else:\\n                    result=False\\n                    for partition in range(1,i):\\n                        if helper(i1,i2,partition) and helper(i1+partition,i2+partition,i-partition): result=True\\n                        if helper(i1,i2+i-partition,partition) and helper(i1+partition,i2,i-partition): result=True\\n                    table[i1][i2][i]=result\\n            return table[i1][i2][i]\\n            \\n        return helper(0,0,n)",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @return a boolean\\n    def isScramble(self, s1, s2):\\n        n=len(s1)\\n        if n==0: return True\\n        table=[[[None for i in range(n+1)] for i2 in range(n)] for i1 in range(n)] #table[i1][i2][i] stores if s1[i1:i1+i] is a scramble of s2[i2:i2+i]\\n        \\n        def helper(i1,i2,i):\\n            if table[i1][i2][i]==None:\\n                if i==1: \\n                    table[i1][i2][i]=(s1[i1]==s2[i2])\\n                else:\\n                    result=False\\n                    for partition in range(1,i):\\n                        if helper(i1,i2,partition) and helper(i1+partition,i2+partition,i-partition): result=True\\n                        if helper(i1,i2+i-partition,partition) and helper(i1+partition,i2,i-partition): result=True\\n                    table[i1][i2][i]=result\\n            return table[i1][i2][i]\\n            \\n        return helper(0,0,n)",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1847719,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1564781,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847966,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847961,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847987,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1848193,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847724,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1848001,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1566475,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1569415,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847719,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1564781,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847966,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847961,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847987,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1848193,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847724,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1848001,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1566475,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1569415,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1848439,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1566824,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1567516,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1848587,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1848065,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1847850,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1847742,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1670898,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1575131,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1573158,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1568907,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1567189,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1853628,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1848797,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1848418,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1847965,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1847940,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1847798,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1847757,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1573025,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1569650,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1568908,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1568909,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1744805,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1974184,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1962952,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1872182,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1848795,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1848725,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1848708,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1848676,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848650,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848643,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848542,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848410,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848391,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848360,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848337,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848282,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848236,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848215,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1848182,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1848051,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1848046,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1847998,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1847997,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1847829,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1847813,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1847785,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1847745,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            }
        ]
    }
]