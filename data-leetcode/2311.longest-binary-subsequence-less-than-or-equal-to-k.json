[
    {
        "title": "Longest Binary Subsequence Less Than or Equal to K",
        "question_content": "You are given a binary string s and a positive integer k.\nReturn the length of the longest subsequence of s that makes up a binary number less than or equal to k.\nNote:\n\n\tThe subsequence can contain leading zeroes.\n\tThe empty string is considered to be equal to 0.\n\tA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n\n&nbsp;\nExample 1:\n\nInput: s = \"1001010\", k = 5\nOutput: 5\nExplanation: The longest subsequence of s that makes up a binary number less than or equal to 5 is \"00010\", as this number is equal to 2 in decimal.\nNote that \"00100\" and \"00101\" are also possible, which are equal to 4 and 5 in decimal, respectively.\nThe length of this subsequence is 5, so 5 is returned.\n\nExample 2:\n\nInput: s = \"00101001\", k = 1\nOutput: 6\nExplanation: \"000001\" is the longest subsequence of s that makes up a binary number less than or equal to 1, as this number is equal to 1 in decimal.\nThe length of this subsequence is 6, so 6 is returned.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 1000\n\ts[i] is either '0' or '1'.\n\t1 <= k <= 109",
        "solutions": [
            {
                "id": 2168423,
                "title": "o-n",
                "content": "Such a deceptive problem. The key is to realize that we need to take all zeros.\\n\\nThen, we take as many `1` from the right as we can, before exceeding `k`. It can be shown that greedily using `1` from the right is always better than to skip it.\\n\\n**C++**\\n```cpp\\nint longestSubsequence(string s, int k) {\\n    int val = 0, cnt = 0, pow = 1;\\n    for (int i = s.size() - 1; i >= 0 && val + pow <= k; --i) {\\n        if (s[i] == \\'1\\') {\\n            ++cnt;\\n            val += pow;\\n        }\\n        pow <<= 1;\\n    }\\n    return count(begin(s), end(s), \\'0\\') + cnt;\\n}\\n```\\n**Java**\\n```java\\npublic int longestSubsequence(String s, int k) {\\n    int val = 0, cnt = 0, pow = 1;\\n    for (int i = s.length() - 1; i >= 0 && val + pow <= k; --i) {\\n        if (s.charAt(i) == \\'1\\') {\\n            ++cnt;\\n            val += pow;\\n        }\\n        pow <<= 1;\\n    }\\n    return (int)s.chars().filter(ch -> ch == \\'0\\').count() + cnt;\\n}\\n```\\n\\n#### One-Pass\\n**C++**\\n```cpp\\nint longestSubsequence(string s, int k) {\\n    int cur = 0, pow = 1, i = s.size() - 1;\\n    for (; i >= 0 && cur + pow <= k; --i) {\\n        cur += (s[i] - \\'0\\') * pow;\\n        pow <<= 1;\\n    }\\n    return i < 0 ? s.size() : count(begin(s), begin(s) + i + 1, \\'0\\') + s.size() - i - 1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint longestSubsequence(string s, int k) {\\n    int val = 0, cnt = 0, pow = 1;\\n    for (int i = s.size() - 1; i >= 0 && val + pow <= k; --i) {\\n        if (s[i] == \\'1\\') {\\n            ++cnt;\\n            val += pow;\\n        }\\n        pow <<= 1;\\n    }\\n    return count(begin(s), end(s), \\'0\\') + cnt;\\n}\\n```\n```java\\npublic int longestSubsequence(String s, int k) {\\n    int val = 0, cnt = 0, pow = 1;\\n    for (int i = s.length() - 1; i >= 0 && val + pow <= k; --i) {\\n        if (s.charAt(i) == \\'1\\') {\\n            ++cnt;\\n            val += pow;\\n        }\\n        pow <<= 1;\\n    }\\n    return (int)s.chars().filter(ch -> ch == \\'0\\').count() + cnt;\\n}\\n```\n```cpp\\nint longestSubsequence(string s, int k) {\\n    int cur = 0, pow = 1, i = s.size() - 1;\\n    for (; i >= 0 && cur + pow <= k; --i) {\\n        cur += (s[i] - \\'0\\') * pow;\\n        pow <<= 1;\\n    }\\n    return i < 0 ? s.size() : count(begin(s), begin(s) + i + 1, \\'0\\') + s.size() - i - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168227,
                "title": "java-c-python-one-pass-o-n",
                "content": "# **Solution 1: DP solution**\\n`dp[i]` means the minimum value of subsequence with length `i`\\n\\nTime `O(n^2)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int longestSubsequence(String s, int k) {\\n        int dp[] = new int[s.length() + 1], j = 0;\\n        for (char c : s.toCharArray()) {\\n            if (dp[j] * 2 + c - \\'0\\' <= k) {\\n                dp[j + 1] = dp[j] * 2 + c - \\'0\\';\\n                j++;\\n            }\\n            for (int i = j; i > 0; --i)\\n                dp[i] = Math.min(dp[i], dp[i - 1] * 2 + c - \\'0\\');\\n        }\\n        return j;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int longestSubsequence(string s, int k) {\\n        int dp[1010] = {}, j = 0;\\n        for (char& v : s) {\\n            if (dp[j] * 2 + v - \\'0\\' <= k)\\n                dp[++j] = dp[j] * 2 + v - \\'0\\';\\n            for (int i = j; i > 0; --i)\\n                dp[i] = min(dp[i], dp[i - 1] * 2 + v - \\'0\\');\\n        }\\n        return j;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def longestSubsequence(self, s, k):\\n        dp = [0]\\n        for v in map(int, s):\\n            if dp[-1] * 2 + v <= k:\\n                dp.append(dp[-1] * 2 + v)\\n            for i in range(len(dp) - 1, 0, -1):\\n                dp[i] = min(dp[i], dp[i - 1] * 2 + v)\\n        return len(dp) - 1\\n```\\n<br>\\n\\n# **Solution 2: One Pass**\\nWe greedly take all 0s, and try to take as many 1s as possible.\\nTo take the 1 with smaller cost, we take the 1s from rightmost.\\n\\nTime `O(n)`\\nSpace `O(1)`\\n\\n**Java**\\n```java\\n    public int longestSubsequence(String s, int k) {\\n        int res = 0, cost = 1, n = s.length();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (s.charAt(i) == \\'0\\' || cost <= k) {\\n                k -= cost * (s.charAt(i) - \\'0\\');\\n                res++;\\n            }\\n            if (cost <= k)\\n                cost *= 2;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int longestSubsequence(string s, int k) {\\n        int res = 0, cost = 1, n = s.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (s[i] == \\'0\\' || cost <= k) {\\n                k -= cost * (s[i] - \\'0\\');\\n                res++;\\n            }\\n            if (cost <= k)\\n                cost *= 2;\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\nInspired by @Jiganesh\\n```py\\n    def longestSubsequence(self, s, k):\\n        i = 0\\n        while int(s[-i-1:], 2) <= k and i < 32 and i < len(s):\\n            i += 1\\n        return s[:-i].count(\\'0\\') + i\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int longestSubsequence(String s, int k) {\\n        int dp[] = new int[s.length() + 1], j = 0;\\n        for (char c : s.toCharArray()) {\\n            if (dp[j] * 2 + c - \\'0\\' <= k) {\\n                dp[j + 1] = dp[j] * 2 + c - \\'0\\';\\n                j++;\\n            }\\n            for (int i = j; i > 0; --i)\\n                dp[i] = Math.min(dp[i], dp[i - 1] * 2 + c - \\'0\\');\\n        }\\n        return j;\\n    }\\n```\n```cpp\\n    int longestSubsequence(string s, int k) {\\n        int dp[1010] = {}, j = 0;\\n        for (char& v : s) {\\n            if (dp[j] * 2 + v - \\'0\\' <= k)\\n                dp[++j] = dp[j] * 2 + v - \\'0\\';\\n            for (int i = j; i > 0; --i)\\n                dp[i] = min(dp[i], dp[i - 1] * 2 + v - \\'0\\');\\n        }\\n        return j;\\n    }\\n```\n```py\\n    def longestSubsequence(self, s, k):\\n        dp = [0]\\n        for v in map(int, s):\\n            if dp[-1] * 2 + v <= k:\\n                dp.append(dp[-1] * 2 + v)\\n            for i in range(len(dp) - 1, 0, -1):\\n                dp[i] = min(dp[i], dp[i - 1] * 2 + v)\\n        return len(dp) - 1\\n```\n```java\\n    public int longestSubsequence(String s, int k) {\\n        int res = 0, cost = 1, n = s.length();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (s.charAt(i) == \\'0\\' || cost <= k) {\\n                k -= cost * (s.charAt(i) - \\'0\\');\\n                res++;\\n            }\\n            if (cost <= k)\\n                cost *= 2;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int longestSubsequence(string s, int k) {\\n        int res = 0, cost = 1, n = s.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (s[i] == \\'0\\' || cost <= k) {\\n                k -= cost * (s[i] - \\'0\\');\\n                res++;\\n            }\\n            if (cost <= k)\\n                cost *= 2;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def longestSubsequence(self, s, k):\\n        i = 0\\n        while int(s[-i-1:], 2) <= k and i < 32 and i < len(s):\\n            i += 1\\n        return s[:-i].count(\\'0\\') + i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2168393,
                "title": "simple-o-n-time-o-1-space-w-o-dp-solution-with-comments",
                "content": "**Intuition**: take as many ones from right as possible until they do not make the num>k\\n**Note**: It is to be noted that we have to take all the zeros for max length here.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        int z=0;\\n        //count zero\\n        for(char c:s)if(c==\\'0\\')z++;\\n\\n        int num=0,base=1,len=0;\\n\\t\\t//take as many ones from right as possible until they do not make the num>k\\n        for(int i=s.size()-1;i>=0;i--){    \\n            if(num+base>k)break;\\n            if(s[i]==\\'1\\')num+=base;\\n            else  z--; //already taken zeros should be redued from zeros count\\n            base*=2;\\n            len++;\\n        }\\n        \\n        return len+z;\\n    }\\n};\\n```\\n**Java:**\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int z=0;\\n        //count zero\\n        for(int i=0;i<s.length();i++)if(s.charAt(i)==\\'0\\')z++;\\n\\n        int num=0,base=1,len=0;\\n\\t\\t//take as many ones from right as possible until they do not make the num>k\\n        for(int i=s.length()-1;i>=0;i--){\\n            \\n            if(num+base>k)break;\\n            if(s.charAt(i)==\\'1\\'){\\n               num+=base;\\n            }\\n            else {\\n\\t\\t\\t//remove already taken zeros from zeros count\\n                z--;\\n            }\\n            base*=2;\\n            len++;\\n        }\\n        \\n        return len+z;\\n    }\\n}\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "Java",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        int z=0;\\n        //count zero\\n        for(char c:s)if(c==\\'0\\')z++;\\n\\n        int num=0,base=1,len=0;\\n\\t\\t//take as many ones from right as possible until they do not make the num>k\\n        for(int i=s.size()-1;i>=0;i--){    \\n            if(num+base>k)break;\\n            if(s[i]==\\'1\\')num+=base;\\n            else  z--; //already taken zeros should be redued from zeros count\\n            base*=2;\\n            len++;\\n        }\\n        \\n        return len+z;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int z=0;\\n        //count zero\\n        for(int i=0;i<s.length();i++)if(s.charAt(i)==\\'0\\')z++;\\n\\n        int num=0,base=1,len=0;\\n\\t\\t//take as many ones from right as possible until they do not make the num>k\\n        for(int i=s.length()-1;i>=0;i--){\\n            \\n            if(num+base>k)break;\\n            if(s.charAt(i)==\\'1\\'){\\n               num+=base;\\n            }\\n            else {\\n\\t\\t\\t//remove already taken zeros from zeros count\\n                z--;\\n            }\\n            base*=2;\\n            len++;\\n        }\\n        \\n        return len+z;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168246,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int f(int i,int size, int sum, string &s, vector<vector<int>>&dp){\\n        if(i<0){\\n            return 0;\\n        }\\n        if(dp[i][size] != -1){\\n            return dp[i][size];\\n        }\\n        int no = f(i-1,size,sum,s,dp);\\n        int yes = 0;\\n        if((sum-(s[i]-\\'0\\')*pow(2,size)) >=0){\\n            yes = 1+ f(i-1,size+1,(sum-(s[i]-\\'0\\')*pow(2,size)),s,dp);\\n        }\\n        return dp[i][size]=max(no,yes);\\n    }\\n    int longestSubsequence(string s, int k) {\\n        \\n        int n = s.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return f(n-1,0,k,s,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int f(int i,int size, int sum, string &s, vector<vector<int>>&dp){\\n        if(i<0){\\n            return 0;\\n        }\\n        if(dp[i][size] != -1){\\n            return dp[i][size];\\n        }\\n        int no = f(i-1,size,sum,s,dp);\\n        int yes = 0;\\n        if((sum-(s[i]-\\'0\\')*pow(2,size)) >=0){\\n            yes = 1+ f(i-1,size+1,(sum-(s[i]-\\'0\\')*pow(2,size)),s,dp);\\n        }\\n        return dp[i][size]=max(no,yes);\\n    }\\n    int longestSubsequence(string s, int k) {\\n        \\n        int n = s.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return f(n-1,0,k,s,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168128,
                "title": "4-lines-in-python-o-n-simple-solution",
                "content": "Intuition\\n\\nConsider all the Zeroes\\nConsider all the ones from last which would be considered in subequence which will be less than k\\n\\n\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n    \\n        end, n  = len(s)-1, s.count(\"0\")    \\n        while end >=0 and  int(s[end:], 2)<= k:\\n            end-=1\\n        return n+ s[end+1:].count(\"1\")\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n    \\n        end, n  = len(s)-1, s.count(\"0\")    \\n        while end >=0 and  int(s[end:], 2)<= k:\\n            end-=1\\n        return n+ s[end+1:].count(\"1\")\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168117,
                "title": "java-solution-1-pass-o-n-count-0s-and-1s",
                "content": "```\\nclass Solution {\\n    \\n    // Take all zeros and as many ones as possible from right to left.\\n    public int longestSubsequence(String s, int k) {\\n        int sum = 0;\\n        int numOfOnes = 0;\\n        int numOfZeros = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if (c == \\'0\\') {\\n                numOfZeros++;\\n            }\\n            else {\\n                sum += Math.pow(2, s.length() - 1 - i);\\n                if (sum <= k) {\\n                    numOfOnes++;\\n                }\\n            }\\n        }\\n        return numOfOnes + numOfZeros;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // Take all zeros and as many ones as possible from right to left.\\n    public int longestSubsequence(String s, int k) {\\n        int sum = 0;\\n        int numOfOnes = 0;\\n        int numOfZeros = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if (c == \\'0\\') {\\n                numOfZeros++;\\n            }\\n            else {\\n                sum += Math.pow(2, s.length() - 1 - i);\\n                if (sum <= k) {\\n                    numOfOnes++;\\n                }\\n            }\\n        }\\n        return numOfOnes + numOfZeros;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172211,
                "title": "proof-as-to-why-greedy-works-and-why-the-zeros-towards-the-end-cannot-be-ignored",
                "content": "I spent some time trying to prove the greedy solution for this problem (include 1\\'s and 0\\'s starting from the right until the number becomes higher than `k` and include all zeros to the left of it). I\\'m trying to develop a way to think about such problems where we need to make decisions such as \"Greedy vs DP\". Also, none of the top solutions provide any proof as to why this works.\\n\\n**Statement**\\nWe cannot remove any zero that comes at the end, i.e. it will always be included in the final subsequence. E.g.: s = \"000111010100\", k = 43 (binary = 110101)\\n\\n**Proof by contradiction**\\nIf we ignore two zeros in the end, we should be able to make a **longer** subsequence by replacing those zeros with ones (or some combination of zeros and ones). But that is not possible because zeros at the end signify the smallest addition to the overall value assuming we keep the total subsequence length constant.\\n\\nIf you want to find the smallest 6 digit binary number, it has to be 32 (100000), if you replace zeros with some combination of zeros and ones you get a higher number of the same length = 6. This reasoning can be extended to intermediate zeros that occur between two `1\\'s` that are supposed to be included in the final subsequence.\\n\\nIt is definitely possible to get a combination of zeros and ones that leaves the subsequence value <= k, but we cannot make the subsequence longer than the case where we chose all zeros.\\nE.g.: 000111000, k = 7. We can choose \"000111\" or \"000000\" both have lengths of 6, so if we don\\'t take the zeros at the end, we cannot do better (increase the subsequence length) still, we can, at best, equal the result obtained by taking all zeros.\\n\\nIf we take another example: 0001101000, k = 13, the final subsequence can be \"0001101\" or \"0000000\". **We are trying to take all zeros because they represent the minimum value-add at whatever position they appear. We can equal that result by not taking all zeros but we can NEVER do better.**\\n\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        \\n        end  = len(s)-1                                                     # rightmost index\\n        while end >=0 and  int(s[end:], 2)<= k:                             # check integer value of binary suffix is <= k\\n            end-=1                                                          # check to the left of current position by decreasing the index\\n        end += 1                                                            # compensate for decreasing too much\\n        return s[:end].count(\"0\") + (len(s) - end)                          # return number of zeros in s[:end] plus length of string s[end:]\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        \\n        end  = len(s)-1                                                     # rightmost index\\n        while end >=0 and  int(s[end:], 2)<= k:                             # check integer value of binary suffix is <= k\\n            end-=1                                                          # check to the left of current position by decreasing the index\\n        end += 1                                                            # compensate for decreasing too much\\n        return s[:end].count(\"0\") + (len(s) - end)                          # return number of zeros in s[:end] plus length of string s[end:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170804,
                "title": "c-intuitive-greedy-o-n",
                "content": "### Approach : Greedy(O(N))\\nThis question, at first, looks like a recursive problems, where we make two choice at 1 and include all 0s but, that way, its a bit complex and time taking. Instead with Greedy approach, its kinda simple and straightforward.\\n\\nWe know that if we just take all the 0s in our answer, it will be an answer, because 0 will always be less than k(1<=k<=10<sup>9</sup>). Thus, at first, our answer is count of all 0s. Next, we need to see how many ones we can add in our answer. So, we traverse the string from back, and check if we can include current 1 or not. \\n\\n**How do we check?**\\nWell, we just raise the current i to the power of 2, and check if it less than or equal to k. We do so, because if we include this one and all the 0s that follow it, it will be a set bit. Note that it will added in between the 0s. \\n**NOTE:** We run the loop only 32 times. Why so? Well, 2<sup>31</sup>-1 == INT MAX, which is greater than 10<sup>9</sup>, and 10<sup>9</sup> is the upper value of k. Thus, if we go take 1 any further, it will be greater than k anyways.\\n\\n**Why we start from back?** \\nWell, that is obvious we will have minimum values with 1s in the back, thus we start from back. \\n\\n**What to do with k?**\\nWell, its better to reduce K instead of storing the value, because due to constraints, the value will eventually overflow for large cases. So, we just decrease k, everytime we include a 1. \\n\\nSo basically, we include all the 0s and choose 1s from last 32 digits. \\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int len = 0, n=s.size();\\n        for(auto u : s)\\n            if(u==\\'0\\')  len++;\\n        \\n        long long count = 0, val = 0;\\n        for(int i = 0; i<32 and i<n; i++){\\n            if(s[n-i-1] == \\'1\\'){\\n                long long temp = pow(2, i);\\n                if(temp > k)\\n                    break; \\n                k -= temp;\\n                len++;\\n            }\\n        }\\n        return len;\\n    }\\n};\\n// You can try your code on following test cases. I failed them in contest due to stupid mistakes \\uD83E\\uDD26\\u200D\\u2642\\uFE0F \\n/*\\n\"000101010011011001011101111000111111100001011000000100010000111100000011111001000111100111101001111001011101001011011101001011011001111111010011100011110111010000010000010111001001111101100001111\"\\n300429827\\n\"100110111111000000010011101000111011000001000111010001010111100001111110110010100011100100111000011011000000100001011000000100110110001101011010011\"\\n522399436\\n\"101100011000010101011100011111111001011101000101000010001100101110010010011000100010001110011111000100100101110000100010010010100010\"\\n978095074\\n\"001010101011010100010101101010010\"\\n93951055\\n\"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\\n1\\n\"000101010011011001011101111000111111100001011000000100010000111100000011111001000111100111101001111001011101001011011101001011011001111111010011100011110111010000010000010111001001111101100001111\"\\n300429827\\n\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int len = 0, n=s.size();\\n        for(auto u : s)\\n            if(u==\\'0\\')  len++;\\n        \\n        long long count = 0, val = 0;\\n        for(int i = 0; i<32 and i<n; i++){\\n            if(s[n-i-1] == \\'1\\'){\\n                long long temp = pow(2, i);\\n                if(temp > k)\\n                    break; \\n                k -= temp;\\n                len++;\\n            }\\n        }\\n        return len;\\n    }\\n};\\n// You can try your code on following test cases. I failed them in contest due to stupid mistakes \\uD83E\\uDD26\\u200D\\u2642\\uFE0F \\n/*\\n\"000101010011011001011101111000111111100001011000000100010000111100000011111001000111100111101001111001011101001011011101001011011001111111010011100011110111010000010000010111001001111101100001111\"\\n300429827\\n\"100110111111000000010011101000111011000001000111010001010111100001111110110010100011100100111000011011000000100001011000000100110110001101011010011\"\\n522399436\\n\"101100011000010101011100011111111001011101000101000010001100101110010010011000100010001110011111000100100101110000100010010010100010\"\\n978095074\\n\"001010101011010100010101101010010\"\\n93951055\\n\"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\\n1\\n\"000101010011011001011101111000111111100001011000000100010000111100000011111001000111100111101001111001011101001011011101001011011001111111010011100011110111010000010000010111001001111101100001111\"\\n300429827\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168288,
                "title": "longest-binary-subsequence-less-than-or-equal-to-k-dp-memoization-easy-solution",
                "content": "We will proceed with approach of dynamic programming because for every index we have a option to include it or not include it.\\n\\nNow with this approach we have to cases whether to include a character or not including it.\\nIts Implementation can be better seen in code.\\n\\nNote: subsequences are different from subarrays\\n```\\nclass Solution {\\npublic:\\n    int solve(string &s,int index,int power,long long score,int& k,vector<int>& dp){\\n        if(index<0)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n        \\n        int include=0;\\n        if(s[index]==\\'1\\'){\\n            if(score+pow(2,power)<=k){\\n                include=1+solve(s,index-1,power+1,score+ pow(2,power),k,dp);\\n            }\\n        }else{\\n            include=1+solve(s,index-1,power+1,score,k,dp);\\n        }\\n        int notinclude=solve(s,index-1,power,score,k,dp);\\n        return dp[index]=max(include,notinclude);\\n    }\\n    int longestSubsequence(string s, int k) {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        int power=0;\\n        long long score=0;\\n        return solve(s,n-1,power,score,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string &s,int index,int power,long long score,int& k,vector<int>& dp){\\n        if(index<0)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n        \\n        int include=0;\\n        if(s[index]==\\'1\\'){\\n            if(score+pow(2,power)<=k){\\n                include=1+solve(s,index-1,power+1,score+ pow(2,power),k,dp);\\n            }\\n        }else{\\n            include=1+solve(s,index-1,power+1,score,k,dp);\\n        }\\n        int notinclude=solve(s,index-1,power,score,k,dp);\\n        return dp[index]=max(include,notinclude);\\n    }\\n    int longestSubsequence(string s, int k) {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        int power=0;\\n        long long score=0;\\n        return solve(s,n-1,power,score,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168203,
                "title": "lis-longest-increasing-subsequence-logic",
                "content": "The logic here is that we first visit the previous string indexes to check that if they are making a binary string less than k. Now we will check if I add my current element to that subsequence, will it make a value less than k, if yes, then we will add this current element to that subsequence, now we keep on doing this for every previous element and will store the max length.\\n\\nAlso here, in order to compute the value of our binary string, in O(1) time, we need to reverse our string. This is because :\\n\\nLet\\'s say we have a string \"1001010\", and we apply the same logic right away on this, then suppose that I\\'m on index 3 and let\\'s say I\\'m checking that what if I add this \"1\", to the previous subsequence \"100\", then I need to compute the value of \"1001\" all over again.\\n\\nBut let\\'s say we reverse this string to \"0101001\", then the situation will completely change because here we can use our previous computations,\\n\\n\\t\"100\" + \"1\" -> \"1001\" // previous case\\n\\t\"001\" + \"1\" -> \"0011\" (in reverse string)\\nbut if we see, it will be \"1100\" in our answer which is equivalent to adding the value of \"001\" to the value of 2 ^ (len(\"001\")) -> i.e. 8.\\n\\nI wasn\\'t able to submit this one. It got accepted at exactly 9 : 30. ;(\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        reverse(s.begin(), s.end());\\n        \\n        int n = s.size();\\n        \\n        vector<pair<int, int>> dp(n);\\n        //len, value pair\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            if(s[i] == \\'0\\') {\\n                dp[i] = {1, 0};\\n            }\\n            else {\\n                dp[i] = {1, 1};\\n            }\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int i = 1 ; i < n ; i++) {\\n            for(int j = i - 1 ; j >= 0 ; j--) {\\n                int currLen = dp[j].first;\\n                int currVal = dp[j].second;\\n                \\n                if( s[i] == \\'1\\' && (currVal + pow(2, currLen)) <= k) {\\n                    if((currLen + 1) > dp[i].first) {\\n                        dp[i].first = currLen + 1;\\n                        dp[i].second = (currVal + pow(2, currLen));    \\n                    }   \\n                }\\n                else if(s[i] == \\'0\\' && currVal <= k){\\n                    if((currLen + 1) > dp[i].first) {\\n                        dp[i].first = currLen + 1;\\n                        dp[i].second = (currVal);    \\n                    }   \\n                }\\n            }\\n            \\n            res = max(res, dp[i].first);\\n        }\\n        \\n        if(s.size() == 1)\\n            return 1;\\n        \\n        return res;    \\n    }\\n    \\n};\\n```\\n\\nPlease upvote if you gt some help :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        reverse(s.begin(), s.end());\\n        \\n        int n = s.size();\\n        \\n        vector<pair<int, int>> dp(n);\\n        //len, value pair\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            if(s[i] == \\'0\\') {\\n                dp[i] = {1, 0};\\n            }\\n            else {\\n                dp[i] = {1, 1};\\n            }\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int i = 1 ; i < n ; i++) {\\n            for(int j = i - 1 ; j >= 0 ; j--) {\\n                int currLen = dp[j].first;\\n                int currVal = dp[j].second;\\n                \\n                if( s[i] == \\'1\\' && (currVal + pow(2, currLen)) <= k) {\\n                    if((currLen + 1) > dp[i].first) {\\n                        dp[i].first = currLen + 1;\\n                        dp[i].second = (currVal + pow(2, currLen));    \\n                    }   \\n                }\\n                else if(s[i] == \\'0\\' && currVal <= k){\\n                    if((currLen + 1) > dp[i].first) {\\n                        dp[i].first = currLen + 1;\\n                        dp[i].second = (currVal);    \\n                    }   \\n                }\\n            }\\n            \\n            res = max(res, dp[i].first);\\n        }\\n        \\n        if(s.size() == 1)\\n            return 1;\\n        \\n        return res;    \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168190,
                "title": "python-6-lines-easy-understanding-explained",
                "content": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        nums = \\'\\'\\n        for i in range(len(s) - 1, -1, -1): # read from right \\n            nums = s[i] + nums \\n            if int(nums, base = 2) > k: # until it makes larger k\\n\\t\\t\\t\\t# Add all zeros as leading zeros and add the size of the current valid nums\\n                return s[:i].count(\\'0\\') + len(nums) - 1 # we added the digit that makes it > k, - 1 to remove such digit.\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        nums = \\'\\'\\n        for i in range(len(s) - 1, -1, -1): # read from right \\n            nums = s[i] + nums \\n            if int(nums, base = 2) > k: # until it makes larger k\\n\\t\\t\\t\\t# Add all zeros as leading zeros and add the size of the current valid nums\\n                return s[:i].count(\\'0\\') + len(nums) - 1 # we added the digit that makes it > k, - 1 to remove such digit.\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168283,
                "title": "c-greedy-time-o-n-steps-explained-faster-than-100",
                "content": "**Steps-**\\n* Reverse the given binary string.\\n* Select every \\'0\\'.\\n* Select the \\'1\\' from beginning till it gives val>k (We know \\'1\\' in the string will only contribute in increasing the value).\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int n=s.size();\\n        reverse(s.begin(),s.end());\\n        int cnt=0;//count will maintain our answer and will also help in calculating what next value we will add in our val when next \\'1\\' comes because we also want index.\\n        long long val=0;\\n        for(int i=0;i<n;i++){\\n            long long num=s[i]-\\'0\\';\\n            if((num*pow(2,cnt)+val)<=k){\\n                val=val+num*pow(2,cnt);\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int n=s.size();\\n        reverse(s.begin(),s.end());\\n        int cnt=0;//count will maintain our answer and will also help in calculating what next value we will add in our val when next \\'1\\' comes because we also want index.\\n        long long val=0;\\n        for(int i=0;i<n;i++){\\n            long long num=s[i]-\\'0\\';\\n            if((num*pow(2,cnt)+val)<=k){\\n                val=val+num*pow(2,cnt);\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168140,
                "title": "c-calculate-from-right-o-n",
                "content": "```\\nint longestSubsequence(string s, int k) {\\n        int n=s.size();\\n        int ans=0;\\n        int cnt=0;\\n        int j=n-1;\\n        for(int i=0;i<31&&j>=0;i++,j--){\\n            int num=ans;\\n            if(s[j]==\\'1\\') num|=(1<<i);\\n            if(num>k) break;\\n            cnt++;\\n            ans=num;\\n        }\\n        while(j>=0){\\n            if(s[j]==\\'0\\') cnt++;          // count all the remaining zeros\\n            j--;\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestSubsequence(string s, int k) {\\n        int n=s.size();\\n        int ans=0;\\n        int cnt=0;\\n        int j=n-1;\\n        for(int i=0;i<31&&j>=0;i++,j--){\\n            int num=ans;\\n            if(s[j]==\\'1\\') num|=(1<<i);\\n            if(num>k) break;\\n            cnt++;\\n            ans=num;\\n        }\\n        while(j>=0){\\n            if(s[j]==\\'0\\') cnt++;          // count all the remaining zeros\\n            j--;\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2168578,
                "title": "o-n-very-easy-approach-naive",
                "content": "Since subsequence, therefore consider all zero.\\nand from right take those one which make pow(2,i) less than k.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        reverse(s.begin(),s.end());\\n        int n= s.size();\\n        int ans=0;\\n        for(int i=0 ; i<n ; i++){\\n            if(s[i]==\\'0\\')ans++;\\n            else{\\n                if(k>=pow(2,i)){\\n                    k-=pow(2,i);\\n                    ans++;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        reverse(s.begin(),s.end());\\n        int n= s.size();\\n        int ans=0;\\n        for(int i=0 ; i<n ; i++){\\n            if(s[i]==\\'0\\')ans++;\\n            else{\\n                if(k>=pow(2,i)){\\n                    k-=pow(2,i);\\n                    ans++;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170229,
                "title": "single-loop-100-fast-c-short-code",
                "content": "```\\n    int longestSubsequence(string s, int k) {\\n      reverse(s.begin(), s.end());\\n        int ans=0;\\n        for (int i=0; i<s.size(); ++i) {\\n            if (s[i]==\\'0\\')\\n                ans++;\\n            else if (i<30 and k>=(1<<i)) {\\n                    ans++;\\n                    k-=(1<<i);\\n                }\\n            }\\n        return ans;\\n    }\\n\\t```\\n**Please upvote the solution. If you find it helpful.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int longestSubsequence(string s, int k) {\\n      reverse(s.begin(), s.end());\\n        int ans=0;\\n        for (int i=0; i<s.size(); ++i) {\\n            if (s[i]==\\'0\\')\\n                ans++;\\n            else if (i<30 and k>=(1<<i)) {\\n                    ans++;\\n                    k-=(1<<i);\\n                }\\n            }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168527,
                "title": "python-greedy-fast-easy-to-undestand-with-explanations",
                "content": "1. As the answer is a **subsequence** then we understand that we MUST get ALL zeroes from string to maximize the answer(it depends on length)\\n2. Another greedy thing to consider is position of 1 in a binary representation and the greedy thing -> we must decrease the k starting by least position of 1\\n\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        n = len(s)\\n        ones = []\\n\\t\\t# Notice how I reversed the string,\\n\\t\\t# because the binary representation is written from greatest value of 2**n\\n        for i, val in enumerate(s[::-1]):\\n            if val == \\'1\\':\\n                ones.append(i)\\n\\t\\t# Initialize ans, there are already number of zeroes (num_of_zeroes = len(nums) - len(ones)\\n        ans = n - len(ones)\\n        i = 0\\n\\t\\t# imagine k == 5 and binary string 001011\\n\\t\\t# ones = [0, 1, 3]\\n\\t\\t# first loop: 5 - 2**0 -> 4, ans += 1\\n\\t\\t# second loop: 4 - 2**1 -> 2, ans +=1\\n\\t\\t# Third loop does not occur because 2 - 2**3 -> -6 which is less than zero\\n\\t\\t# So the ans is 3 + 2 = 5\\n        while i < len(ones) and k - 2 ** ones[i] >= 0:\\n            ans += 1\\n            k -= 2 ** ones[i]\\n            i += 1\\n\\t\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        n = len(s)\\n        ones = []\\n\\t\\t# Notice how I reversed the string,\\n\\t\\t# because the binary representation is written from greatest value of 2**n\\n        for i, val in enumerate(s[::-1]):\\n            if val == \\'1\\':\\n                ones.append(i)\\n\\t\\t# Initialize ans, there are already number of zeroes (num_of_zeroes = len(nums) - len(ones)\\n        ans = n - len(ones)\\n        i = 0\\n\\t\\t# imagine k == 5 and binary string 001011\\n\\t\\t# ones = [0, 1, 3]\\n\\t\\t# first loop: 5 - 2**0 -> 4, ans += 1\\n\\t\\t# second loop: 4 - 2**1 -> 2, ans +=1\\n\\t\\t# Third loop does not occur because 2 - 2**3 -> -6 which is less than zero\\n\\t\\t# So the ans is 3 + 2 = 5\\n        while i < len(ones) and k - 2 ** ones[i] >= 0:\\n            ans += 1\\n            k -= 2 ** ones[i]\\n            i += 1\\n\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187266,
                "title": "o-n-solution-very-easy-explanation",
                "content": "**Solution: Longest Binary Subsequence less than or equal to k.**\\n\\nTo solve this question, I have broken down the problem in 3 simple cases as follows:\\n\\nBefore that Just Convert \"K\" into its Binary String Using *Integer.toBinaryString(k)*, cpp coders can make a function for the same. I will be using k and it\\'s binary string interchangebly.\\n\\n***Note that, the Leading Bit of Binary \\'K\\' will always be 1.***\\n\\n*  **Case 1 : The length of given string is less than that of k.**\\n![image](https://assets.leetcode.com/users/images/f0a2ad2b-cb00-4f2d-bd83-9a4414ef58fd_1656051575.05363.jpeg)\\n\\n\\nIn this case, return the length of string itself because it will be surely less than \\'k\\'.\\n*Return s.length()*\\n\\n*  **Case 2 : The length of given string is greater than/equal to that of k and the end substring is less than equal to k.**\\n![image](https://assets.leetcode.com/users/images/489777d1-f503-44f7-8d7c-81772be3f826_1656051649.7569838.jpeg)\\n\\nIn this case, we partition the string in two parts one of length, s.length()-k.length() and other of k.length(), We can include all zeroes from the first part, say n and if the end subtring is less than or equal to binary of k, we can add k to n.\\n*Return n+k;*\\n\\n*  **Case 3 : The length of given string is greater than/equal to that of k and the end substring is greater than that of k.**\\n![image](https://assets.leetcode.com/users/images/e5e000f1-64f4-4506-a5a9-1027a11f2881_1656051994.8738637.jpeg)\\n\\n\\nIn this case too, we partition the string in two parts one of length, s.length()-k.length() and other of k.length(), we again include all zeroes from the first part, say n and if the end subtring is greater than or equal to binary of k, we can add k-1 to n. ( just removing leading 1 from end substring, the second part.)\\n*Return n+k-1;*\\n\\n**Code In Java**\\n```\\nclass Solution {\\n    \\n    public int longestSubsequence(String s, int k) {\\n        \\n        String s1= Integer.toBinaryString(k);\\n        \\n        if(s1.length()>s.length()) return s.length();\\n        \\n        int num=0;\\n        \\n        for(int i=0; i<s.length()-s1.length(); i++){\\n            if(s.charAt(i)==\\'0\\') num++;\\n        }  \\n        \\n        int x=s1.compareTo(s.substring(s.length()-s1.length(),s.length()));\\n        \\n        if(x>=0) return num+s1.length();\\n        \\n        else return num+s1.length()-1;  \\n    }\\n    \\n}\\n```\\n*Hope you liked it!*",
                "solutionTags": [
                    "Java",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int longestSubsequence(String s, int k) {\\n        \\n        String s1= Integer.toBinaryString(k);\\n        \\n        if(s1.length()>s.length()) return s.length();\\n        \\n        int num=0;\\n        \\n        for(int i=0; i<s.length()-s1.length(); i++){\\n            if(s.charAt(i)==\\'0\\') num++;\\n        }  \\n        \\n        int x=s1.compareTo(s.substring(s.length()-s1.length(),s.length()));\\n        \\n        if(x>=0) return num+s1.length();\\n        \\n        else return num+s1.length()-1;  \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168723,
                "title": "time-o-n-space-o-1-explained-no-dp-count-all-0s-count-only-valid-1s",
                "content": "We have to find longest subsequence and value have to <=k . \\n\\nTraversing from **right to left.**\\n- *count* is size of current subsequence\\n- *val* is value of current subsequence. \\n\\nCASE 1 : If current character is zero , take it , increase count.\\nCASE 2: If current character is one,  it will add  Power(2,count) to existing val .\\nSo we can take current one only if val+Math.pow(2,count)) <= k . So if we decide to take this one, we increase val by Power(2,count) and increase count by 1. \\n\\nIn the end return count. \\n\\n**Example :**\\ns = \"1001010\", k = 5\\nsize of string = 7 , traverse from index 6 to 0, val=0, count=0 (initially)\\nindex 6 : 0 ( take it) , count=1, val=0\\nindex 5 : 1 it will add Power(2,1) = 2  ; 2<=5 , we can take it; count = 2, val = 2\\nindex 4 : 0 (take it), count=3, val=2\\nindex 3 : 1 , it will add Power(2,3) = 8 ; 8+2 > 5 ( can\\'t take), no change in count and val\\nindex 2 : 0 (take it ) count=4, val=2\\nindex 1: 0 (take it) count = 5, val=2\\nindex 0 : 1 , it will add Power(2,5)= 32  , not possible to take \\n\\nResult : count=5 (Answer)\\n\\n-----------------------------------------------------\\n**CODE**\\n```\\npublic int longestSubsequence(String s, int k) {\\n        int n = s.length(), val=0 , count=0;\\n        for(int i=n-1; i>=0; i--){\\n            if(s.charAt(i)==\\'1\\'){\\n                if( (val+Math.pow(2,count)) <= k){\\n                    val += Math.pow(2,count);\\n                    count++;\\n                }\\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic int longestSubsequence(String s, int k) {\\n        int n = s.length(), val=0 , count=0;\\n        for(int i=n-1; i>=0; i--){\\n            if(s.charAt(i)==\\'1\\'){\\n                if( (val+Math.pow(2,count)) <= k){\\n                    val += Math.pow(2,count);\\n                    count++;\\n                }\\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168357,
                "title": "c-dp-memoization",
                "content": "Time Complexity - O(n\\\\*n) \\nSpace Complexity - O(n\\\\*n)\\nwhere n=size of the string\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(int it,int cnt,string &s,int k,vector<vector<int>>&dp)\\n    {\\n        if(s.size()<=it)\\n        {\\n            return 0;\\n        }\\n        if(dp[it][cnt]!=-1)return dp[it][cnt];\\n        if(s[it]==\\'0\\')\\n        {\\n            return dp[it][cnt]=max(helper(it+1,cnt+1,s,k,dp)+1,helper(it+1,cnt,s,k,dp));\\n        }\\n        else\\n        {\\n            int tmp=0;\\n            if(cnt<31&&k-(1<<cnt)>=0)\\n            {\\n                tmp=helper(it+1,cnt+1,s,k-(1<<cnt),dp)+1;\\n            }\\n            return dp[it][cnt]=max(tmp,helper(it+1,cnt,s,k,dp));\\n        }\\n    }\\n    \\n    int longestSubsequence(string s, int k) {\\n        reverse(s.begin(),s.end());\\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\\n        int ans=helper(0,0,s,k,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(int it,int cnt,string &s,int k,vector<vector<int>>&dp)\\n    {\\n        if(s.size()<=it)\\n        {\\n            return 0;\\n        }\\n        if(dp[it][cnt]!=-1)return dp[it][cnt];\\n        if(s[it]==\\'0\\')\\n        {\\n            return dp[it][cnt]=max(helper(it+1,cnt+1,s,k,dp)+1,helper(it+1,cnt,s,k,dp));\\n        }\\n        else\\n        {\\n            int tmp=0;\\n            if(cnt<31&&k-(1<<cnt)>=0)\\n            {\\n                tmp=helper(it+1,cnt+1,s,k-(1<<cnt),dp)+1;\\n            }\\n            return dp[it][cnt]=max(tmp,helper(it+1,cnt,s,k,dp));\\n        }\\n    }\\n    \\n    int longestSubsequence(string s, int k) {\\n        reverse(s.begin(),s.end());\\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\\n        int ans=helper(0,0,s,k,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168193,
                "title": "4-solutions-dp-greedy-and-explaination-of-heap-solution-in-c",
                "content": "PLEASE UPVOTE\\n```\\nint longestSubsequence(string s, int k) {\\n      reverse(s.begin(), s.end());\\n        int ans=0;\\n        for (int i=0; i<s.size(); ++i) {\\n            if (s[i]==\\'0\\')\\n                ans++;\\n            else if (i<30 and k>=(1<<i)) {\\n                    ans++;\\n                    k-=(1<<i);\\n                }\\n            }\\n        return ans;\\n    }\\n```\\n\\n```\\nint longestSubsequence(string s, int k) {\\n        int dp[1010] = {}, j = 0;\\n        for (char& v : s) {\\n            if (dp[j] * 2 + v - \\'0\\' <= k)\\n                dp[++j] = dp[j] * 2 + v - \\'0\\';\\n            for (int i = j; i > 0; --i)\\n                dp[i] = min(dp[i], dp[i - 1] * 2 + v - \\'0\\');\\n        }\\n        return j;\\n    }\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        long long z=0,n=s.length();\\n        for(char c:s) z+=c==\\'0\\';\\n        reverse(s.begin(),s.end());\\n        long long ans=z;\\n        for(long long i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                if(i>31)return ans;\\n                long long p=(long long)pow(2,i);\\n                if(p>k) return ans;\\n                k-=p,ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\nstring s = \"00001110\"\\nint k = 2\\nbinary representation of k = \"10\"\\nfind count and last index of zero upto n-m index\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n\\t// ofk is bianry representation of k\\n        string ofk = \"\" ;\\n        while(k){\\n            ofk.push_back(char(k%2+\\'0\\')) ;\\n            k/=2 ;\\n        }\\n        reverse(ofk.begin(),ofk.end());\\n        int n = s.length();\\n        int m = ofk.length();\\n        priority_queue<string> pq ;\\n        pq.push(ofk);\\n\\t\\t// i is last index of zero upto n-m index and count is count of zeros\\n        int i = -1 ,count = 0;\\n        for(int j = 0; j<n-m;j++){\\n            if(s[j] == \\'0\\')\\n            {   \\n                i=j;\\n                count ++; \\n            }\\n        }\\n        // cout<<count<<i<<endl;\\n        // if(i == n-m-1){\\n        //     return min(n,count+m-1) ;\\n        // }\\n        // cout<<\"Hello\";\\n        \\n        for(int j = n-m ;j>i;j--){\\n            string temp = s.substr(n-m,m);\\n            // cout<<temp<<endl;\\n            pq.push(temp);\\n            // cout<<temp<<\" \"<<ofk<<endl;\\n            if(pq.top() != ofk)\\n                pq.pop();\\n            else \\n                return min(n,count + m) ;\\n        }\\n        cout<<\"Hello\";\\n        return min(count+m-1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint longestSubsequence(string s, int k) {\\n      reverse(s.begin(), s.end());\\n        int ans=0;\\n        for (int i=0; i<s.size(); ++i) {\\n            if (s[i]==\\'0\\')\\n                ans++;\\n            else if (i<30 and k>=(1<<i)) {\\n                    ans++;\\n                    k-=(1<<i);\\n                }\\n            }\\n        return ans;\\n    }\\n```\n```\\nint longestSubsequence(string s, int k) {\\n        int dp[1010] = {}, j = 0;\\n        for (char& v : s) {\\n            if (dp[j] * 2 + v - \\'0\\' <= k)\\n                dp[++j] = dp[j] * 2 + v - \\'0\\';\\n            for (int i = j; i > 0; --i)\\n                dp[i] = min(dp[i], dp[i - 1] * 2 + v - \\'0\\');\\n        }\\n        return j;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        long long z=0,n=s.length();\\n        for(char c:s) z+=c==\\'0\\';\\n        reverse(s.begin(),s.end());\\n        long long ans=z;\\n        for(long long i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                if(i>31)return ans;\\n                long long p=(long long)pow(2,i);\\n                if(p>k) return ans;\\n                k-=p,ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n\\t// ofk is bianry representation of k\\n        string ofk = \"\" ;\\n        while(k){\\n            ofk.push_back(char(k%2+\\'0\\')) ;\\n            k/=2 ;\\n        }\\n        reverse(ofk.begin(),ofk.end());\\n        int n = s.length();\\n        int m = ofk.length();\\n        priority_queue<string> pq ;\\n        pq.push(ofk);\\n\\t\\t// i is last index of zero upto n-m index and count is count of zeros\\n        int i = -1 ,count = 0;\\n        for(int j = 0; j<n-m;j++){\\n            if(s[j] == \\'0\\')\\n            {   \\n                i=j;\\n                count ++; \\n            }\\n        }\\n        // cout<<count<<i<<endl;\\n        // if(i == n-m-1){\\n        //     return min(n,count+m-1) ;\\n        // }\\n        // cout<<\"Hello\";\\n        \\n        for(int j = n-m ;j>i;j--){\\n            string temp = s.substr(n-m,m);\\n            // cout<<temp<<endl;\\n            pq.push(temp);\\n            // cout<<temp<<\" \"<<ofk<<endl;\\n            if(pq.top() != ofk)\\n                pq.pop();\\n            else \\n                return min(n,count + m) ;\\n        }\\n        cout<<\"Hello\";\\n        return min(count+m-1,n);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2857486,
                "title": "python3-o-n-simple-solution",
                "content": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n\\n        start = \"\"\\n        res = 0\\n        for letter in reversed(s):\\n            start = letter + start\\n            if int(start,2) <= k:\\n                res+=1\\n            elif letter == \\'0\\':\\n                res+=1\\n        \\n        return res\\n  ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n\\n        start = \"\"\\n        res = 0\\n        for letter in reversed(s):\\n            start = letter + start\\n            if int(start,2) <= k:\\n                res+=1\\n            elif letter == \\'0\\':\\n                res+=1\\n        \\n        return res\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2180604,
                "title": "simple-fast-kotlin-solution-faster-than-100",
                "content": "Kotlin code:\\n```\\n    fun longestSubsequence(s: String, k: Int): Int {\\n        var sum = 0L\\n        var z = 0\\n        for (i in s) {\\n            if(i==\\'0\\') {\\n                z++\\n            }\\n        }\\n        var i = s.length-1\\n        while (i>=0 && sum<k) {\\n            if(s[i]==\\'1\\') {\\n                sum+=Math.pow(2.0, (s.length-i-1).toDouble()).toInt()\\n                z++\\n            }\\n            i--\\n        }\\n        if(sum>k) {\\n            z--\\n        }\\n        return z\\n    }\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Greedy"
                ],
                "code": "```\\n    fun longestSubsequence(s: String, k: Int): Int {\\n        var sum = 0L\\n        var z = 0\\n        for (i in s) {\\n            if(i==\\'0\\') {\\n                z++\\n            }\\n        }\\n        var i = s.length-1\\n        while (i>=0 && sum<k) {\\n            if(s[i]==\\'1\\') {\\n                sum+=Math.pow(2.0, (s.length-i-1).toDouble()).toInt()\\n                z++\\n            }\\n            i--\\n        }\\n        if(sum>k) {\\n            z--\\n        }\\n        return z\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2169491,
                "title": "simple-c-o-n-time-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int count0=0;\\n        for(char c:s){\\n            if(c==\\'0\\')\\n                count0++;  // count the total number of zeros present in the string s\\n        }\\n        long long int val=0;  // for storing the value of decimal value converted from binary\\n        reverse(s.begin(),s.end()); // instead of traversing from back reverse the string for easy traversal\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                if(pow(2,i)<=k)    \\n                {\\n                    val+=pow(2,i);   // calulate the value whenenever 1 occurs \\n                    if(val<=k){\\n                      count0= count0+1; //increase the counter if the value is less than k\\n                    }\\n                }\\n                else break;\\n            }\\n        }\\n        \\n        return count0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int count0=0;\\n        for(char c:s){\\n            if(c==\\'0\\')\\n                count0++;  // count the total number of zeros present in the string s\\n        }\\n        long long int val=0;  // for storing the value of decimal value converted from binary\\n        reverse(s.begin(),s.end()); // instead of traversing from back reverse the string for easy traversal\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                if(pow(2,i)<=k)    \\n                {\\n                    val+=pow(2,i);   // calulate the value whenenever 1 occurs \\n                    if(val<=k){\\n                      count0= count0+1; //increase the counter if the value is less than k\\n                    }\\n                }\\n                else break;\\n            }\\n        }\\n        \\n        return count0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169433,
                "title": "c-hashmap-recursion",
                "content": "class Solution {\\npublic:\\n\\n    int fun(string &s , int k ,int i,  int cnt,int num,map<pair<int,int>,int>& fre)\\n    {\\n        if(num>k)\\n            return -1e9 ; \\n        if(i>=s.size())\\n            return cnt ; \\n        //if we have already answer then we return that\\n        if(fre.find({i,cnt})!=fre.end())\\n            return fre[{i,cnt}];\\n        char c =s[i] ; \\n        if(c==\\'0\\')\\n            return fun(s, k ,i+1,cnt+1, num,fre) ; \\n        \\n        //to avoid overflow we put cnt<30\\n        else if(c==\\'1\\' and  cnt<30)\\n        {\\n            int op1 = fun(s , k , i+1,cnt+1, num|(1<<cnt),fre) ; \\n            int op2 = fun(s, k, i+1,cnt, num,fre); \\n            fre[{i,cnt}]=max(op1,op2);\\n                return max(op1,op2) ; \\n        }\\n        //if s[i] is not 1 and cnt>30 then we search for the remaining zeros in the string\\n        return fun(s,k,i+1,cnt,num,fre);\\n    }\\n    int longestSubsequence(string s, int k) {\\n        //here we reverse the string bez in num addition of zero not effect the num\\n        reverse(s.begin(),s.end() ); \\n        map<pair<int,int>,int> fre;\\n        int ans = fun(s, k, 0 , 0 , 0,fre) ; \\n        return ans ; \\n    }\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int fun(string &s , int k ,int i,  int cnt,int num,map<pair<int,int>,int>& fre)\\n    {\\n        if(num>k)\\n            return -1e9 ; \\n        if(i>=s.size())\\n            return cnt ; \\n        //if we have already answer then we return that\\n        if(fre.find({i,cnt}",
                "codeTag": "Java"
            },
            {
                "id": 2168480,
                "title": "binary-search-prefix-sum-easy-to-understand-approach",
                "content": "If there is an answer with the number of bits x, then there will be an answer for x-1, x-2, and so on.\\nThe task now comes down to determining whether or not an answer with p bits exists.\\nCreate a minimal number of p bits from s and compare it to k, if less than k possible otherwise not .\\n```\\nclass Solution {\\npublic:\\n    bool valid(int mid , string &s , int k)\\n    {\\n        int sum = 0 ;\\n        int n = s.size();\\n        vector<int> prefix(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\') sum++;\\n            prefix[i]= sum;\\n        }\\n        int sz = 0 ;\\n        string res = \"\";\\n        for(int i=n-1;i>=0 && sz < mid ;i--)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                if(sz < mid)\\n                {\\n                    sz++;\\n                    res.push_back(\\'0\\');\\n                }\\n            }\\n            else\\n            {\\n                if(i)\\n                {\\n                    if(prefix[i-1] >= mid-sz)\\n                    {\\n                         continue;\\n                    }\\n                    else\\n                    {\\n                         res.push_back(\\'1\\');\\n                         sz++;\\n                    }\\n                }\\n                else\\n                {\\n                    res.push_back(\\'1\\');\\n                    sz++;\\n                    break;\\n                }\\n            }\\n        }\\n        reverse(res.begin(),res.end());\\n        long long int ans = 0 ;\\n        long long int mx_p = -1 ;\\n        for(int i=0;i<res.size();i++)\\n        {\\n            int value = res[i]-\\'0\\';\\n            if(value) mx_p = i ;\\n        }\\n        if(mx_p > log2(k)+1) return false;\\n        for(int i=0;i<res.size();i++)\\n        {\\n            int value = res[i]-\\'0\\';\\n            ans = ans + value*pow(2,i);\\n            if(ans  > k) return false;\\n        }\\n        return true;\\n    }\\n    int longestSubsequence(string s, int k)\\n    {\\n        int mn = 0 , mx = s.size() , ans = 0 ;\\n        while(mn <= mx)\\n        {\\n            int mid = mn + (mx-mn)/2;\\n            if(valid(mid,s,k))\\n            {\\n                mn = mid + 1;\\n                ans = max(ans,mid);\\n            }\\n            else\\n            {\\n                mx = mid - 1 ;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int mid , string &s , int k)\\n    {\\n        int sum = 0 ;\\n        int n = s.size();\\n        vector<int> prefix(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\') sum++;\\n            prefix[i]= sum;\\n        }\\n        int sz = 0 ;\\n        string res = \"\";\\n        for(int i=n-1;i>=0 && sz < mid ;i--)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                if(sz < mid)\\n                {\\n                    sz++;\\n                    res.push_back(\\'0\\');\\n                }\\n            }\\n            else\\n            {\\n                if(i)\\n                {\\n                    if(prefix[i-1] >= mid-sz)\\n                    {\\n                         continue;\\n                    }\\n                    else\\n                    {\\n                         res.push_back(\\'1\\');\\n                         sz++;\\n                    }\\n                }\\n                else\\n                {\\n                    res.push_back(\\'1\\');\\n                    sz++;\\n                    break;\\n                }\\n            }\\n        }\\n        reverse(res.begin(),res.end());\\n        long long int ans = 0 ;\\n        long long int mx_p = -1 ;\\n        for(int i=0;i<res.size();i++)\\n        {\\n            int value = res[i]-\\'0\\';\\n            if(value) mx_p = i ;\\n        }\\n        if(mx_p > log2(k)+1) return false;\\n        for(int i=0;i<res.size();i++)\\n        {\\n            int value = res[i]-\\'0\\';\\n            ans = ans + value*pow(2,i);\\n            if(ans  > k) return false;\\n        }\\n        return true;\\n    }\\n    int longestSubsequence(string s, int k)\\n    {\\n        int mn = 0 , mx = s.size() , ans = 0 ;\\n        while(mn <= mx)\\n        {\\n            int mid = mn + (mx-mn)/2;\\n            if(valid(mid,s,k))\\n            {\\n                mn = mid + 1;\\n                ans = max(ans,mid);\\n            }\\n            else\\n            {\\n                mx = mid - 1 ;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168390,
                "title": "simplest-intuitive-o-n-time-o-1-space-java-solution",
                "content": "The singular goal is to make result LONGEST. 0 is our best choise since it adds no value, choose 1 to make the result longer if and only if it adds LEAST value, hence start choosing from right and adhere to the constraint `<=k`. \\n\\nThe index `i` gives positional value. \\n`long` is used to avoid overflow.\\nReturn of Math.Pow is `double` hence typecasting.\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int cnt =0; long val=0; double pow=0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s.charAt(i)==\\'0\\') cnt++;\\n            else{\\n                pow = Math.pow(2,(s.length()-1)-i);\\n                if(val+pow<=k) {\\n                    cnt++;\\n                    val+=pow;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int cnt =0; long val=0; double pow=0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s.charAt(i)==\\'0\\') cnt++;\\n            else{\\n                pow = Math.pow(2,(s.length()-1)-i);\\n                if(val+pow<=k) {\\n                    cnt++;\\n                    val+=pow;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168150,
                "title": "javascript-solution-easy-to-understand-liner-o-n",
                "content": "Reminder for binary number counting.\\n![image](https://assets.leetcode.com/users/images/20ba622d-eaa0-4ce3-a4f4-bd63845ffb73_1655612371.1663253.png)\\n\\nStarting from the last position. Each time when the accumulated number is smaller than the number count++;\\n\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\n\\nvar longestSubsequence = function(s, k) {\\n    let count = 0;\\n    let j = s.length - 1; // starting from the last digit\\n    let i = 0; // binary number position\\n    let acc = 0;\\n    \\n    while(j >= 0){\\n        let positionNumber = Number(s[j]) * Math.pow(2, i);\\n        j--;\\n        i++;\\n        if(acc + positionNumber > k) continue;\\n\\n\\t\\tacc += positionNumber;\\n\\t\\tcount++;\\n    }\\n\\n    return count;\\n};\\n\\n\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\n\\nvar longestSubsequence = function(s, k) {\\n    let count = 0;\\n    let j = s.length - 1; // starting from the last digit\\n    let i = 0; // binary number position\\n    let acc = 0;\\n    \\n    while(j >= 0){\\n        let positionNumber = Number(s[j]) * Math.pow(2, i);\\n        j--;\\n        i++;\\n        if(acc + positionNumber > k) continue;\\n\\n\\t\\tacc += positionNumber;\\n\\t\\tcount++;\\n    }\\n\\n    return count;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2367754,
                "title": "o-n-solution-with-explanation",
                "content": "**Approach: (Linear)**\\n\\nTraverse the string from n-1 to 0. Note that we are asked to make any number <= k, such that, it contains the maximum number of digits. Note that, number 0 (comprising of all 0 bits) is also allowed!\\n\\nThus, our aim would be to accomodate the maximum no.of 0s and would accomodate the 1s, till the number we are getting <= k. But there is no such restrictions for 0.\\n\\n**Java Solution:**\\n\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int n=s.length(), pos=0; boolean noMoreOnes = false; long val=0;\\n        \\n        for(int i=n-1; i>=0; --i) {\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'0\\') {\\n                ++pos;\\n            }\\n            else if(!noMoreOnes){\\n                long p = (long)Math.pow(2, pos);\\n                \\n                if(p <= (long)k && val+p <= (long)k) {\\n                    ++pos;\\n                    val += p;\\n                }\\n                else {\\n                    noMoreOnes = true;\\n                }\\n            }\\n        }\\n        \\n        return pos;\\n    }\\n}\\n```\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n\\n**Execution:** 2ms\\n\\nPlz upvote if u hv liked! Thanks!",
                "solutionTags": [
                    "Greedy",
                    "Bit Manipulation",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int n=s.length(), pos=0; boolean noMoreOnes = false; long val=0;\\n        \\n        for(int i=n-1; i>=0; --i) {\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'0\\') {\\n                ++pos;\\n            }\\n            else if(!noMoreOnes){\\n                long p = (long)Math.pow(2, pos);\\n                \\n                if(p <= (long)k && val+p <= (long)k) {\\n                    ++pos;\\n                    val += p;\\n                }\\n                else {\\n                    noMoreOnes = true;\\n                }\\n            }\\n        }\\n        \\n        return pos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170292,
                "title": "0ms-100-faster-solution-c",
                "content": "int longestSubsequence(string s, int k) {\\n        //take all the zeros in the string  for making the length of string max \\n        int len=0;\\n        bool stop=false;\\n        int n=s.length()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(s[i]==\\'0\\') len++;\\n            else if(n-i<31 && stop==false)\\n            {\\n\\t\\t\\t\\t\\tint num=pow(2,n-i);\\n\\t\\t\\t\\t\\tif(k-num>=0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tk-=num;\\n\\t\\t\\t\\t\\t\\tlen++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstop=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n        }\\n        return len;\\n    }\\n};",
                "solutionTags": [],
                "code": "int longestSubsequence(string s, int k) {\\n        //take all the zeros in the string  for making the length of string max \\n        int len=0;\\n        bool stop=false;\\n        int n=s.length()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(s[i]==\\'0\\') len++;\\n            else if(n-i<31 && stop==false)\\n            {\\n\\t\\t\\t\\t\\tint num=pow(2,n-i);\\n\\t\\t\\t\\t\\tif(k-num>=0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tk-=num;\\n\\t\\t\\t\\t\\t\\tlen++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tstop=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n        }\\n        return len;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2170215,
                "title": "c-simple-o-n-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k)\\n    {\\n        int n=s.size();\\n        vector<int> pref(n,0); \\n        if(s[0]==\\'0\\')\\n        {\\n            pref[0]=1;\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n              pref[i]=pref[i-1]+1;\\n            else\\n                pref[i]=pref[i-1];\\n        }\\n        \\n      long long num=0;\\n        int ans=0;\\n        if(s[n-1]==\\'0\\')\\n        {\\n            ans=pref[n-1];\\n        }\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int rp=n-1-i;\\n            if(rp>30)\\n            {\\n                break;\\n            }\\n            long long curr= pow(2,rp)  * (s[i]-\\'0\\');\\n           \\n           \\n            if(s[i]==\\'1\\')\\n            {\\n                 if(curr<=k)\\n                {\\n                    int nn=1+pref[n-1];\\n                    ans=max (ans,nn) ; \\n                }\\n                 num+=curr;\\n                if(num<=k)\\n                {\\n                    int nn=(n-1)-i+1+pref[i];\\n                    ans=max(ans,nn); \\n                }\\n            }\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k)\\n    {\\n        int n=s.size();\\n        vector<int> pref(n,0); \\n        if(s[0]==\\'0\\')\\n        {\\n            pref[0]=1;\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n              pref[i]=pref[i-1]+1;\\n            else\\n                pref[i]=pref[i-1];\\n        }\\n        \\n      long long num=0;\\n        int ans=0;\\n        if(s[n-1]==\\'0\\')\\n        {\\n            ans=pref[n-1];\\n        }\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int rp=n-1-i;\\n            if(rp>30)\\n            {\\n                break;\\n            }\\n            long long curr= pow(2,rp)  * (s[i]-\\'0\\');\\n           \\n           \\n            if(s[i]==\\'1\\')\\n            {\\n                 if(curr<=k)\\n                {\\n                    int nn=1+pref[n-1];\\n                    ans=max (ans,nn) ; \\n                }\\n                 num+=curr;\\n                if(num<=k)\\n                {\\n                    int nn=(n-1)-i+1+pref[i];\\n                    ans=max(ans,nn); \\n                }\\n            }\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169962,
                "title": "easy-o-n-with-comments",
                "content": "* Include all zeroes as they contribute nothing to the decimal value.\\n* Include only those ones which when included give the decimal value of string less than equal to k.\\n* Our goal is to include as many ones as possible and their inclusion depends on the position they are present at.\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        int cnt=0;\\n        int i=0,n=s.length();\\n        for(int i=n-1;i>=0;i--){ //Traverse the string right to left\\n            if(s[i]==\\'0\\')   cnt++; // If its zero, directly include it\\n            else if(n-i-1<30){\\n                int val=pow(2,(n-i-1)); //Contribution to value of decimal number\\n                if(k-val>=0){ // Inlcude only if k is still greater than the decimal number\\n                    k-=val; //Subtract the contribution if included\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        int cnt=0;\\n        int i=0,n=s.length();\\n        for(int i=n-1;i>=0;i--){ //Traverse the string right to left\\n            if(s[i]==\\'0\\')   cnt++; // If its zero, directly include it\\n            else if(n-i-1<30){\\n                int val=pow(2,(n-i-1)); //Contribution to value of decimal number\\n                if(k-val>=0){ // Inlcude only if k is still greater than the decimal number\\n                    k-=val; //Subtract the contribution if included\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169336,
                "title": "c-use-greedy-approach-o-n-solution-explained",
                "content": "**Approach:** string has 0 and 1 only\\n\\n1) **for 0\\'s:** We will take all number of 0\\'s in binary number because by doing so our number still be 0 and this will help in maximizing subsequence length. \\n\\n**we have to keep binary number <= k. all 0\\'s have been taken now it\\'s time for 1\\'s**\\n\\n2) **for 1\\'s:** we will start taking 1 from the most right side since its a binary number and we want to maximize subsequence length. check every time by taking this 1 is our number still less or equal to k and keep on taking 1 and increase length.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int mxLen = 0;\\n        int n = s.size();\\n        \\n        //take all 0s to maximize length\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'0\\')\\n                mxLen++;\\n        }\\n        \\n        //start taking 1 from the end(binary number) till sum<=k\\n        int sum = 0; //since we have 0s only in the subsequence\\n        int j= 0;\\n        for(int i= n-1; i>=0; i--){\\n            if(s[i]== \\'1\\' && j<31){\\n                sum += pow(2, j);\\n                // cout<< sum<<\" \";\\n                if(sum <= k)\\n                    mxLen++;\\n                else\\n                    break;\\n            }\\n            j++;\\n        }\\n        \\n        return mxLen;\\n    }\\n};\\n```\\n\\n**Please do upvote if you like the solution:)**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int mxLen = 0;\\n        int n = s.size();\\n        \\n        //take all 0s to maximize length\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'0\\')\\n                mxLen++;\\n        }\\n        \\n        //start taking 1 from the end(binary number) till sum<=k\\n        int sum = 0; //since we have 0s only in the subsequence\\n        int j= 0;\\n        for(int i= n-1; i>=0; i--){\\n            if(s[i]== \\'1\\' && j<31){\\n                sum += pow(2, j);\\n                // cout<< sum<<\" \";\\n                if(sum <= k)\\n                    mxLen++;\\n                else\\n                    break;\\n            }\\n            j++;\\n        }\\n        \\n        return mxLen;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2169170,
                "title": "c-recurrence-memoization-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestBinarySubsequence(int i,int size, int sum, int k, string &s, vector<vector<int>>& dp){\\n        if(i<0)\\n            return 0;\\n        if(dp[i][size] != -1) \\n            return dp[i][size];\\n        int notTake = longestBinarySubsequence(i-1,size,sum,k,s,dp);\\n        int take = 0;\\n        if((sum + (s[i]-\\'0\\')* pow(2,size)) <= k) {\\n            take = 1+longestBinarySubsequence(i-1, size+1, (sum + (s[i]-\\'0\\')*pow(2,size)), k, s, dp);\\n        }\\n        return dp[i][size] = max(notTake, take);\\n    }\\n    int longestSubsequence(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>>dp(n,vector<int>(n, -1));\\n        return longestBinarySubsequence(n-1, 0, 0, k, s, dp);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestBinarySubsequence(int i,int size, int sum, int k, string &s, vector<vector<int>>& dp){\\n        if(i<0)\\n            return 0;\\n        if(dp[i][size] != -1) \\n            return dp[i][size];\\n        int notTake = longestBinarySubsequence(i-1,size,sum,k,s,dp);\\n        int take = 0;\\n        if((sum + (s[i]-\\'0\\')* pow(2,size)) <= k) {\\n            take = 1+longestBinarySubsequence(i-1, size+1, (sum + (s[i]-\\'0\\')*pow(2,size)), k, s, dp);\\n        }\\n        return dp[i][size] = max(notTake, take);\\n    }\\n    int longestSubsequence(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>>dp(n,vector<int>(n, -1));\\n        return longestBinarySubsequence(n-1, 0, 0, k, s, dp);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168570,
                "title": "python-greedy-o-n-time-o-1-space",
                "content": "The intuition  is always take the nearest possible character to maximize the number of possible choices for sequence.\\n```python\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        # greedy: always take the first char right.\\n\\n        @lru_cache(maxsize=None)\\n        def backtrack(end, rem):\\n            if end == -1:\\n                return 0\\n            nonlocal s\\n            ans = 0\\n            for i in range(end, -1, -1):\\n                if rem - int(s[i]) >= 0:\\n                    ans = max(1 + backtrack(i-1, (rem - int(s[i])) >> 1), ans)\\n                    break\\n            return ans\\n        return backtrack(len(s)-1, k)\\n\\t```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        # greedy: always take the first char right.\\n\\n        @lru_cache(maxsize=None)\\n        def backtrack(end, rem):\\n            if end == -1:\\n                return 0\\n            nonlocal s\\n            ans = 0\\n            for i in range(end, -1, -1):\\n                if rem - int(s[i]) >= 0:\\n                    ans = max(1 + backtrack(i-1, (rem - int(s[i])) >> 1), ans)\\n                    break\\n            return ans\\n        return backtrack(len(s)-1, k)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2168557,
                "title": "python-easy-approach-beats-90-00-runtime",
                "content": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        \\n        ans = 0\\n        n = len(s)\\n        \\n        if k > int(s, 2):\\n            return n\\n        \\n        for i in range(n):\\n            if int(s[n - 1 - i:], 2) > k:\\n                curr = i\\n                break\\n                \\n        if i == n - 1:\\n            return n\\n\\n        ans = i + s[:n - i].count(\"0\")\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        \\n        ans = 0\\n        n = len(s)\\n        \\n        if k > int(s, 2):\\n            return n\\n        \\n        for i in range(n):\\n            if int(s[n - 1 - i:], 2) > k:\\n                curr = i\\n                break\\n                \\n        if i == n - 1:\\n            return n\\n\\n        ans = i + s[:n - i].count(\"0\")\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168538,
                "title": "c-dp-only",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string &s,int n,int sum,int cnt,vector<vector<int>>&dp){\\n        if(n<0) return 0;\\n        if(dp[n][cnt]!=-1) return dp[n][cnt];\\n        int c1 = solve(s,n-1,sum,cnt,dp);\\n        int c2 = 0;\\n\\n        if(sum-((s[n]-\\'0\\')*pow(2,cnt))>=0){\\n            c2 = 1+solve(s,n-1,sum-((s[n]-\\'0\\')*pow(2,cnt)),cnt+1,dp);\\n        }\\n        return dp[n][cnt] = max(c1,c2);\\n    }\\n    int longestSubsequence(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return solve(s,s.size()-1,k,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string &s,int n,int sum,int cnt,vector<vector<int>>&dp){\\n        if(n<0) return 0;\\n        if(dp[n][cnt]!=-1) return dp[n][cnt];\\n        int c1 = solve(s,n-1,sum,cnt,dp);\\n        int c2 = 0;\\n\\n        if(sum-((s[n]-\\'0\\')*pow(2,cnt))>=0){\\n            c2 = 1+solve(s,n-1,sum-((s[n]-\\'0\\')*pow(2,cnt)),cnt+1,dp);\\n        }\\n        return dp[n][cnt] = max(c1,c2);\\n    }\\n    int longestSubsequence(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return solve(s,s.size()-1,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168493,
                "title": "c-optimized-approach-using-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        reverse(begin(s), end(s));\\n        int ans = 0;\\n        for (int i = 0; i < s.length() ; ++i) {\\n            if (s[i] == \\'0\\')\\n                ++ans;\\n            else if (i<30) {\\n                if (k >= (1<<i)) {\\n                    ++ans;\\n                    k -= (1<<i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        reverse(begin(s), end(s));\\n        int ans = 0;\\n        for (int i = 0; i < s.length() ; ++i) {\\n            if (s[i] == \\'0\\')\\n                ++ans;\\n            else if (i<30) {\\n                if (k >= (1<<i)) {\\n                    ++ans;\\n                    k -= (1<<i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168425,
                "title": "python-3-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        if int(s, 2) <= k:\\n            return len(s)\\n        s = list(s)\\n        i = 0\\n        retLen = len(s)\\n        while int(\\'\\'.join(s), 2) > k:\\n            if \\'1\\' == s[i]:\\n                retLen -= 1\\n                s[i] = \\'0\\'\\n            i += 1\\n        if int(\\'\\'.join(s), 2) > k:\\n            return 0\\n        return retLen\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        if int(s, 2) <= k:\\n            return len(s)\\n        s = list(s)\\n        i = 0\\n        retLen = len(s)\\n        while int(\\'\\'.join(s), 2) > k:\\n            if \\'1\\' == s[i]:\\n                retLen -= 1\\n                s[i] = \\'0\\'\\n            i += 1\\n        if int(\\'\\'.join(s), 2) > k:\\n            return 0\\n        return retLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168424,
                "title": "c-easy-solution",
                "content": "Approach: We have to maximise the length while keeping the number less than equal to k. That means we should try to have as many leading 0\\'s as possible to increase the lenght. I start from the right end, and start adding all the numbers until the value is less than k. After that, I consider only all the 0s, to the left of it. \\n\\nNow, why this works, \\nLet\\'s understand with an example.\\n\"1000110\" k=4\\n\\nit doesn\\'t matter if I take 00010 or 00011, the part that matters is getting as many prefixed 0s as possible and crossing the threshold of k as late as possible, now when we take everything, we have two choices, either we take a 1 or 0, taking a 1 increases the value of k,  but if we surpass the value of k we are automatically using all the 0\\'s on the left. So it doesn\\'t make sense if we don\\'t take 0s. And we take 1 as and when we get to maximise the number of 0s in the subsequence.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int n= s.size();\\n        long long power=1;\\n        long long num=0;\\n        int i=n-1;\\n        int count=0;\\n        for(; i>=0; i--){\\n            num+=(s[i]-\\'0\\')*power;\\n            \\n            if(num>k){\\n                while(i>=0){\\n                    if(s[i]==\\'0\\')\\n                        count++;\\n                    i--;\\n                }\\n            }\\n            \\n            else count++;\\n            if(power<INT_MAX)\\n            power*=2;\\n            \\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int n= s.size();\\n        long long power=1;\\n        long long num=0;\\n        int i=n-1;\\n        int count=0;\\n        for(; i>=0; i--){\\n            num+=(s[i]-\\'0\\')*power;\\n            \\n            if(num>k){\\n                while(i>=0){\\n                    if(s[i]==\\'0\\')\\n                        count++;\\n                    i--;\\n                }\\n            }\\n            \\n            else count++;\\n            if(power<INT_MAX)\\n            power*=2;\\n            \\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168380,
                "title": "c-solution-dp-solution-1-d-dp",
                "content": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    int longestSubsequence(string s, int k) {\\n        \\n        int n=s.size();\\n        vector<pair<int,ll>>dp(s.size());\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i==n-1)\\n            {\\n                if(s[i]==\\'1\\')\\n                {\\n                    dp[i]={1,1};\\n                }\\n                else{\\n                    dp[i]={1,0};\\n                }\\n            }\\n            else{\\n                if(s[i]==\\'0\\')\\n                {\\n                    dp[i]={dp[i+1].first+1,dp[i+1].second};\\n                }\\n                else{\\n                    ll temp=0;\\n                    int templen=0;\\n                    for(int j=i+1;j<n;j++)\\n                    {\\n                        ll val=dp[j].second;\\n                        int len=dp[j].first;\\n                        if(len>=33)\\n                        {\\n                            continue;\\n                        }\\n                        ll totalval=(1LL<<len)+val;\\n                        if(totalval<=k)\\n                        {\\n                            if(len+1>templen)\\n                            {\\n                                templen=len+1;\\n                                temp=totalval;\\n                            }\\n                        }\\n                    }\\n                    if(dp[i+1].first>templen)\\n                    {\\n                        dp[i]={dp[i+1].first,dp[i+1].second};\\n                    }\\n                    else{\\n                        dp[i]={templen,temp};\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     cout<<dp[i].first<<\" \"<<dp[i].second<<endl;\\n        // }\\n        // cout<<endl;\\n        return dp[0].first;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    int longestSubsequence(string s, int k) {\\n        \\n        int n=s.size();\\n        vector<pair<int,ll>>dp(s.size());\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i==n-1)\\n            {\\n                if(s[i]==\\'1\\')\\n                {\\n                    dp[i]={1,1};\\n                }\\n                else{\\n                    dp[i]={1,0};\\n                }\\n            }\\n            else{\\n                if(s[i]==\\'0\\')\\n                {\\n                    dp[i]={dp[i+1].first+1,dp[i+1].second};\\n                }\\n                else{\\n                    ll temp=0;\\n                    int templen=0;\\n                    for(int j=i+1;j<n;j++)\\n                    {\\n                        ll val=dp[j].second;\\n                        int len=dp[j].first;\\n                        if(len>=33)\\n                        {\\n                            continue;\\n                        }\\n                        ll totalval=(1LL<<len)+val;\\n                        if(totalval<=k)\\n                        {\\n                            if(len+1>templen)\\n                            {\\n                                templen=len+1;\\n                                temp=totalval;\\n                            }\\n                        }\\n                    }\\n                    if(dp[i+1].first>templen)\\n                    {\\n                        dp[i]={dp[i+1].first,dp[i+1].second};\\n                    }\\n                    else{\\n                        dp[i]={templen,temp};\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     cout<<dp[i].first<<\" \"<<dp[i].second<<endl;\\n        // }\\n        // cout<<endl;\\n        return dp[0].first;\\n    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2168264,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int mx=0;\\n        for(int i=0;i<s.size();++i){\\n            long long cur=0;\\n            int cnt=0;\\n            for(int j=i;j<s.size();++j){\\n                if(s[j]==\\'1\\')\\n                    ++cur;\\n                if(cur<=k){\\n                    mx=max(mx,j-i+1-cnt);\\n                }\\n                else{\\n                    turn_of(cur);\\n                    ++cnt;\\n                }\\n                cur<<=1;\\n            }\\n        }\\n        return mx;\\n    }\\n    void turn_of(long long &num){\\n        for(int bt=62;bt>=0;--bt){\\n            if((1LL<<bt)&num){\\n                num&=~(1<<bt);\\n                return;\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int mx=0;\\n        for(int i=0;i<s.size();++i){\\n            long long cur=0;\\n            int cnt=0;\\n            for(int j=i;j<s.size();++j){\\n                if(s[j]==\\'1\\')\\n                    ++cur;\\n                if(cur<=k){\\n                    mx=max(mx,j-i+1-cnt);\\n                }\\n                else{\\n                    turn_of(cur);\\n                    ++cnt;\\n                }\\n                cur<<=1;\\n            }\\n        }\\n        return mx;\\n    }\\n    void turn_of(long long &num){\\n        for(int bt=62;bt>=0;--bt){\\n            if((1LL<<bt)&num){\\n                num&=~(1<<bt);\\n                return;\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168204,
                "title": "c-greedy-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        long long z=0,n=s.length();\\n        for(char c:s) z+=c==\\'0\\';\\n        reverse(s.begin(),s.end());\\n        long long ans=z;\\n        for(long long i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                if(i>31)return ans;\\n                long long p=(long long)pow(2,i);\\n                if(p>k) return ans;\\n                k-=p,ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        long long z=0,n=s.length();\\n        for(char c:s) z+=c==\\'0\\';\\n        reverse(s.begin(),s.end());\\n        long long ans=z;\\n        for(long long i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                if(i>31)return ans;\\n                long long p=(long long)pow(2,i);\\n                if(p>k) return ans;\\n                k-=p,ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168181,
                "title": "c-greedy-over-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int longestSubsequence(string s, int k) {\\n        int n=s.size();\\n        \\n        int res=0;\\n        \\n        vector<int> z(n,0);// count number of zeros till index i\\n        \\n        if(s[0]==\\'0\\')z[0]=1;\\n        if(s[0]==\\'1\\')z[0]=0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            z[i]=z[i-1];\\n            if(s[i]==\\'0\\') z[i]++;\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            long long curr=0;\\n            int len=0;\\n            \\n            for(int j=i;j<n;j++)\\n            {\\n                \\n                curr*=1LL*2;\\n                if(s[j]==\\'1\\')\\n                {\\n                    curr++;\\n                }\\n            \\n                if(curr>k)\\n                {\\n                    break;\\n                }\\n                len++;\\n            }\\n            \\n            if(i-1>=0)\\n                res=max(res,len+z[i-1]);\\n            else\\n                res=max(res,len);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int longestSubsequence(string s, int k) {\\n        int n=s.size();\\n        \\n        int res=0;\\n        \\n        vector<int> z(n,0);// count number of zeros till index i\\n        \\n        if(s[0]==\\'0\\')z[0]=1;\\n        if(s[0]==\\'1\\')z[0]=0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            z[i]=z[i-1];\\n            if(s[i]==\\'0\\') z[i]++;\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            long long curr=0;\\n            int len=0;\\n            \\n            for(int j=i;j<n;j++)\\n            {\\n                \\n                curr*=1LL*2;\\n                if(s[j]==\\'1\\')\\n                {\\n                    curr++;\\n                }\\n            \\n                if(curr>k)\\n                {\\n                    break;\\n                }\\n                len++;\\n            }\\n            \\n            if(i-1>=0)\\n                res=max(res,len+z[i-1]);\\n            else\\n                res=max(res,len);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168155,
                "title": "straight-forword-cpp-solution",
                "content": "For the maximum length we have to include all the zero so we will include all zero .But we have to think about the ones which one we have to select for that we select the one from the last position in given string which will have less value to that position as below\\n\\n\\n**s = \"00010100\" k=4\\nwe have to include all zeros but if take the one at 4th position then string will look like this 0001000 which will exceed value so we will select the one at 6th position which will give lagest subsequence with length 7 and having value <= k i.e 0000100**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int ans=0;\\n        long long int sum = 0, power = 1;\\n        int traverse= s.size() - 1;\\n     \\n        while(traverse >= 0){\\n\\t\\t\\n            if(s[traverse--] == \\'1\\'){\\n                if(sum+power <= k){\\n                    sum+=power;\\n                    //sometimes it exceeds the limit so we will assign it k+1 value to avoid it\\n                    if(power * 2 <= k)\\n                        power*=2;\\n                    else{\\n                        power = k+1;\\n                    }\\n                    ans++;\\n                }                \\n            }else{\\n                ans++;\\n                //sometimes it exceeds the limit so we will assign it k+1 value to avoid it\\n                if(power*2 <= k)\\n                    power*=2;\\n                else{\\n                    power = k+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int ans=0;\\n        long long int sum = 0, power = 1;\\n        int traverse= s.size() - 1;\\n     \\n        while(traverse >= 0){\\n\\t\\t\\n            if(s[traverse--] == \\'1\\'){\\n                if(sum+power <= k){\\n                    sum+=power;\\n                    //sometimes it exceeds the limit so we will assign it k+1 value to avoid it\\n                    if(power * 2 <= k)\\n                        power*=2;\\n                    else{\\n                        power = k+1;\\n                    }\\n                    ans++;\\n                }                \\n            }else{\\n                ans++;\\n                //sometimes it exceeds the limit so we will assign it k+1 value to avoid it\\n                if(power*2 <= k)\\n                    power*=2;\\n                else{\\n                    power = k+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513680,
                "title": "2311-python",
                "content": "\\tclass Solution:\\n\\t\\tdef longestSubsequence(self, s: str, k: int) -> int:\\n\\t\\t\\tif int(s,2) <= k:\\n\\t\\t\\t\\treturn len(s)\\n\\n\\t\\t\\tt = bin(k)[2:]\\n\\n\\t\\t\\tpre = s[:len(s)-len(t)]\\n\\t\\t\\tprefix = Counter(pre)[\"0\"]\\n\\t\\t\\tout = prefix+len(t)\\n\\t\\t\\tif int(s[len(s)-len(t):],2) > k:\\n\\t\\t\\t\\tout -= 1\\n\\n\\t\\t\\treturn out",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef longestSubsequence(self, s: str, k: int) -> int:\\n\\t\\t\\tif int(s,2) <= k:\\n\\t\\t\\t\\treturn len(s)\\n\\n\\t\\t\\tt = bin(k)[2:]\\n\\n\\t\\t\\tpre = s[:len(s)-len(t)]\\n\\t\\t\\tprefix = Counter(pre)[\"0\"]\\n\\t\\t\\tout = prefix+len(t)\\n\\t\\t\\tif int(s[len(s)-len(t):],2) > k:\\n\\t\\t\\t\\tout -= 1\\n\\n\\t\\t\\treturn out",
                "codeTag": "Java"
            },
            {
                "id": 2483037,
                "title": "c",
                "content": "first of all we will count the number of  \\'0\\'   in string s and store the count in variable cnt;\\nwe will include all these \\'0\\'  in our subsequence b/c  they are only incresing the length of the subsequence not the value ( value that we will get after binary represntation of subsequence ) of subsequence.\\nNow we will start from rightmost setbit of the string, we will incorporate the  set bit in our ans at the same position  it is present in string s and we will check if our ans is less than our equal to k\\n  if yes\\n  -> we will incorporate this set bit in our ans and increse the count of cnt by 1 and go for the next set bit which is present in the left of the   current set bit\\n   if No \\n   --> we  will return cnt as we can\\'t further incorporate any set bit in ans;\\n   \\n  ********** facts--->>*********\\n  1<=k<=10^9;\\n  since k is in the range of integer so we should look for the set bit whose position is <= 31;\\n  \\n  \\n```\\n  class Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n      int n=s.length();\\n      int cnt=0;\\n      \\n      for(auto u:s)\\n        if(u==\\'0\\')\\n            cnt++;\\n      \\n      reverse(s.begin(),s.end());\\n      long long sum=0;\\n   \\n      int i=0;\\n      \\n    while(i<n&&i<=30){\\n      \\n       while(i<n&&i<30&&s[i]!=\\'1\\')\\n                                 i++;\\n      \\n      \\n      \\n     if(s[i]==\\'1\\'){\\n             sum=sum+(long long )(1<<i);\\n      \\n      if(sum<=k)\\n           cnt++;\\n       \\n      else\\n        return cnt;\\n     \\n                  }\\n      \\n      \\n       \\n       i++;\\n                 }\\n        \\n      return  cnt;\\n    }\\n};\\n```\\n  \\n",
                "solutionTags": [],
                "code": "```\\n  class Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n      int n=s.length();\\n      int cnt=0;\\n      \\n      for(auto u:s)\\n        if(u==\\'0\\')\\n            cnt++;\\n      \\n      reverse(s.begin(),s.end());\\n      long long sum=0;\\n   \\n      int i=0;\\n      \\n    while(i<n&&i<=30){\\n      \\n       while(i<n&&i<30&&s[i]!=\\'1\\')\\n                                 i++;\\n      \\n      \\n      \\n     if(s[i]==\\'1\\'){\\n             sum=sum+(long long )(1<<i);\\n      \\n      if(sum<=k)\\n           cnt++;\\n       \\n      else\\n        return cnt;\\n     \\n                  }\\n      \\n      \\n       \\n       i++;\\n                 }\\n        \\n      return  cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362079,
                "title": "java-dfs-memo-o-64n",
                "content": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) { \\n        String K = Integer.toBinaryString(k);\\n        int lenS = s.length(), lenK = K.length();\\n        int[][][] memo = new int[lenS][lenK][2];\\n        \\n        return helper(1, 0, 0, lenS, lenK, s, K, memo);\\n    }\\n    \\n    int helper(int isBounded, int idS, int idK, int lenS, int lenK, String S, String K, int[][][] memo) {\\n        if(idK == lenK || idS == lenS) return 0;\\n        if(isBounded == 0) return Math.min(lenS - idS, lenK - idK);\\n        if(memo[idS][idK][isBounded] != 0) {\\n            return memo[idS][idK][isBounded] - 1;\\n        }\\n        int ret = Math.min(lenS - idS, lenK - idK) - 1;\\n        if(idK == 0) {\\n            if(S.charAt(idS) == \\'0\\') {\\n                ret = Math.max(ret, 1 + helper(isBounded, idS + 1, idK, lenS, lenK, S, K, memo));\\n            }\\n            else {\\n                ret = Math.max(ret, 1 + helper(isBounded, idS + 1, idK + 1, lenS, lenK, S, K, memo));\\n                ret = Math.max(ret, helper(isBounded, idS + 1, idK, lenS, lenK, S, K, memo));\\n            }\\n        }\\n        else {\\n            ret = Math.max(ret, helper(isBounded, idS + 1, idK, lenS, lenK, S, K, memo));\\n            if(K.charAt(idK) == S.charAt(idS)) {\\n                ret = Math.max(ret, 1 + helper(isBounded, idS + 1, idK + 1, lenS, lenK, S, K, memo));\\n            }\\n            if(K.charAt(idK) == \\'1\\' && S.charAt(idS) == \\'0\\') {\\n                ret = Math.max(ret, 1 + helper(0, idS + 1, idK + 1, lenS, lenK, S, K, memo));\\n            }\\n            ret = Math.max(ret, ((lenS - idS >= lenK - idK)? lenK - idK - 1: lenS - idS));\\n        }\\n        \\n        memo[idS][idK][isBounded] = ret + 1;\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) { \\n        String K = Integer.toBinaryString(k);\\n        int lenS = s.length(), lenK = K.length();\\n        int[][][] memo = new int[lenS][lenK][2];\\n        \\n        return helper(1, 0, 0, lenS, lenK, s, K, memo);\\n    }\\n    \\n    int helper(int isBounded, int idS, int idK, int lenS, int lenK, String S, String K, int[][][] memo) {\\n        if(idK == lenK || idS == lenS) return 0;\\n        if(isBounded == 0) return Math.min(lenS - idS, lenK - idK);\\n        if(memo[idS][idK][isBounded] != 0) {\\n            return memo[idS][idK][isBounded] - 1;\\n        }\\n        int ret = Math.min(lenS - idS, lenK - idK) - 1;\\n        if(idK == 0) {\\n            if(S.charAt(idS) == \\'0\\') {\\n                ret = Math.max(ret, 1 + helper(isBounded, idS + 1, idK, lenS, lenK, S, K, memo));\\n            }\\n            else {\\n                ret = Math.max(ret, 1 + helper(isBounded, idS + 1, idK + 1, lenS, lenK, S, K, memo));\\n                ret = Math.max(ret, helper(isBounded, idS + 1, idK, lenS, lenK, S, K, memo));\\n            }\\n        }\\n        else {\\n            ret = Math.max(ret, helper(isBounded, idS + 1, idK, lenS, lenK, S, K, memo));\\n            if(K.charAt(idK) == S.charAt(idS)) {\\n                ret = Math.max(ret, 1 + helper(isBounded, idS + 1, idK + 1, lenS, lenK, S, K, memo));\\n            }\\n            if(K.charAt(idK) == \\'1\\' && S.charAt(idS) == \\'0\\') {\\n                ret = Math.max(ret, 1 + helper(0, idS + 1, idK + 1, lenS, lenK, S, K, memo));\\n            }\\n            ret = Math.max(ret, ((lenS - idS >= lenK - idK)? lenK - idK - 1: lenS - idS));\\n        }\\n        \\n        memo[idS][idK][isBounded] = ret + 1;\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339292,
                "title": "java-o-n-2-dp-memo-to-o-n-greedy-solution",
                "content": "O(n^2) DP solution using memorization\\n```\\nclass Solution {\\n    int n;\\n    int dp[][];\\n    public int longestSubsequence(String s, int k) {\\n        n = s.length();\\n        dp = new int[n][n];\\n        for(int i = 0; i < n; i++){\\n            Arrays.fill(dp[i] , -1);\\n        }\\n        return f(n - 1 , 0 , 0 , s , k);\\n    }\\n    int f(int i , int size , int sum , String s , int k){\\n        if(i < 0) return 0;\\n        \\n        if(dp[i][size] != -1) return dp[i][size];\\n        \\n        int no = f(i - 1 , size , sum , s , k);\\n        int yes = 0;\\n        if(sum + (s.charAt(i) - \\'0\\') * Math.pow(2 , size) <= k)\\n            yes = f(i - 1 , size + 1 , sum + (s.charAt(i) - \\'0\\') * (int)Math.pow(2 , size) , s , k) + 1;\\n        \\n        return dp[i][size] = Math.max(no , yes);\\n    }\\n}\\n```\\n---------------------------------------------------------------------------\\nO(n) greedy, picking as many 1s from the right and all the zeroes.\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int n = s.length();\\n        int cost = 1;\\n        int res = 0;\\n        for(int i = n - 1; i >= 0; i--){\\n            if(s.charAt(i) == \\'0\\' || cost <= k){\\n                k -= cost * (s.charAt(i) - \\'0\\');\\n                res++;\\n            }\\n            if(cost <= k){\\n                cost *= 2;\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    int dp[][];\\n    public int longestSubsequence(String s, int k) {\\n        n = s.length();\\n        dp = new int[n][n];\\n        for(int i = 0; i < n; i++){\\n            Arrays.fill(dp[i] , -1);\\n        }\\n        return f(n - 1 , 0 , 0 , s , k);\\n    }\\n    int f(int i , int size , int sum , String s , int k){\\n        if(i < 0) return 0;\\n        \\n        if(dp[i][size] != -1) return dp[i][size];\\n        \\n        int no = f(i - 1 , size , sum , s , k);\\n        int yes = 0;\\n        if(sum + (s.charAt(i) - \\'0\\') * Math.pow(2 , size) <= k)\\n            yes = f(i - 1 , size + 1 , sum + (s.charAt(i) - \\'0\\') * (int)Math.pow(2 , size) , s , k) + 1;\\n        \\n        return dp[i][size] = Math.max(no , yes);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296687,
                "title": "easy-to-understand-code-using-slidinng-window",
                "content": "class Solution {\\npublic:\\n    \\n    int longestSubsequence(string s, int k) {\\n        int ans = 0;\\n        int n = s.size();\\n        int m = 0;\\n        int cnt = 0;\\n        queue<int> q;\\n        \\n        for(int i =0; i<n; i++){\\n            m = m*2 + (s[i]-\\'0\\');\\n            if(s[i] == \\'1\\') q.push(i);\\n            cnt++;\\n            while(m>k){\\n                int l = q.front();\\n                // cout<<l<<endl;\\n                q.pop();\\n                m = m-(pow(2,i-l)*(s[l]-\\'0\\'));\\n                cnt--;\\n            }\\n            // cout<<cnt<<endl;\\n            ans = max(cnt,ans);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int longestSubsequence(string s, int k) {\\n        int ans = 0;\\n        int n = s.size();\\n        int m = 0;\\n        int cnt = 0;\\n        queue<int> q;\\n        \\n        for(int i =0; i<n; i++){\\n            m = m*2 + (s[i]-\\'0\\');\\n            if(s[i] == \\'1\\') q.push(i);\\n            cnt++;\\n            while(m>k){\\n                int l = q.front();\\n                // cout<<l<<endl;\\n                q.pop();\\n                m = m-(pow(2,i-l)*(s[l]-\\'0\\'));\\n                cnt--;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 2287547,
                "title": "easy-to-understand-well-explained-requires-a-bit-of-critical-thinking",
                "content": "so when we get the string s we need to reverse it to convert it into binary on the fly and see whether it is getting greater than K or not, once it is greater than K we can only take 0\\'s  and make sure your pow fun should not return more than 10^9 as it is the k limit so since i is raise to the power of 2 so it\\'ll be somewhere around 2^30 , i made it 40 just to be sure.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        \\n        int n = s.length();\\n        reverse(s.begin(),s.end());\\n        int ans = 0;\\n        \\n        unsigned long long int t = 0;\\n        bool f = false;\\n        for(int i=0;i<n;i++)\\n        {\\n            int v = 0;\\n            if(s[i] == \\'1\\')\\n                v = 1;\\n            \\n            if(t<=k && i<40){\\n                t+=(pow(2,i)*v);\\n            }\\n            if(t<=k &&  i<40)\\n                ans++;\\n            else{\\n                f=true;\\n            }\\n            \\n            if(f && s[i] == \\'0\\')\\n                ans++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        \\n        int n = s.length();\\n        reverse(s.begin(),s.end());\\n        int ans = 0;\\n        \\n        unsigned long long int t = 0;\\n        bool f = false;\\n        for(int i=0;i<n;i++)\\n        {\\n            int v = 0;\\n            if(s[i] == \\'1\\')\\n                v = 1;\\n            \\n            if(t<=k && i<40){\\n                t+=(pow(2,i)*v);\\n            }\\n            if(t<=k &&  i<40)\\n                ans++;\\n            else{\\n                f=true;\\n            }\\n            \\n            if(f && s[i] == \\'0\\')\\n                ans++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286918,
                "title": "c-greedy-clean-code",
                "content": "We have to take all zeroes and rightmost ones for which the values are less than equal to k.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k)\\n    {\\n        int sum = 0,n = s.length(),p = 0, len = 0;\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            if(s[i] == \\'0\\')\\n                len++;\\n            else\\n            {\\n                if(sum + pow(2,p) <= k)\\n                {\\n                    sum += pow(2,p);\\n                    len++;\\n                }\\n            }\\n            p++;\\n        }\\n        return len;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k)\\n    {\\n        int sum = 0,n = s.length(),p = 0, len = 0;\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            if(s[i] == \\'0\\')\\n                len++;\\n            else\\n            {\\n                if(sum + pow(2,p) <= k)\\n                {\\n                    sum += pow(2,p);\\n                    len++;\\n                }\\n            }\\n            p++;\\n        }\\n        return len;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282073,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int l=s.length(),cnt=0,ans=0;\\n        for(int i=0;i<l;i++){\\n            if(s[i]==\\'0\\') cnt++;\\n            else{\\n                int num=1,len=cnt+1, j=i+1;\\n                while(j<l){\\n                    num=(num<<1)+s[j++]-48;\\n                    if(num>k) break;\\n                    len++;\\n                }\\n                ans=max(ans,len);\\n            }\\n        }\\n        return max(cnt,ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int l=s.length(),cnt=0,ans=0;\\n        for(int i=0;i<l;i++){\\n            if(s[i]==\\'0\\') cnt++;\\n            else{\\n                int num=1,len=cnt+1, j=i+1;\\n                while(j<l){\\n                    num=(num<<1)+s[j++]-48;\\n                    if(num>k) break;\\n                    len++;\\n                }\\n                ans=max(ans,len);\\n            }\\n        }\\n        return max(cnt,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280567,
                "title": "2-lines-python-simple-solution",
                "content": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        while int(s, 2) > k: s = s.replace(\\'1\\', \\'\\', 1)\\n        return len(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        while int(s, 2) > k: s = s.replace(\\'1\\', \\'\\', 1)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238782,
                "title": "c-o-n-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int ans = 0, cur = 0;\\n        for (int i = s.length() - 1; i >= 0; i--)    \\n        {\\n            if (s[i] == \\'0\\')\\n                ans++;\\n            else if (ans < 30 && cur + (1LL << ans) <= k)\\n            {\\n                cur += (1LL << ans);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int ans = 0, cur = 0;\\n        for (int i = s.length() - 1; i >= 0; i--)    \\n        {\\n            if (s[i] == \\'0\\')\\n                ans++;\\n            else if (ans < 30 && cur + (1LL << ans) <= k)\\n            {\\n                cur += (1LL << ans);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238093,
                "title": "cpp-dp-o-n-both-recursive-and-table-approach-explained",
                "content": "I have shown here both recursive and table approach for this question. \\nRecursive code is O(n^2) and space is also O(n^2) while table approach is O(n) in time and O(1) and space complexity.\\n\\nWe basically need to find the recursive relation. We can see that if a number is `1`, we need to decide whether to include or not, but we can include `0` as it wont add any value but will increase the length. Also, one more important thing is to trvaerse from last to start of string as it happens in a binary number.\\n\\nThus for recursive \\n\\n```\\nclass Solution {\\npublic:\\nint recur(string s,int n,int ti,int le,int k,int &ans){\\n        ans = max(ans,le); // storing maximum length reached\\n        if(n<0){\\n            return 0; // if we have reached the start we need to return 0\\n        }\\n        if(s[n]==\\'1\\'){\\n             if(ti+pow(2,le)>k){\\n                return recur(s,n-1,ti,le,k,ans); // if the current number `ti` + 2^(lenth of string) is greater than our K, we dont want to include this, therfore, we dont increament, `le` or `ti` and just decraese `n` for further processing\\n            }\\n            else{\\n                return max(recur(s,n-1,ti,le,k,ans),1+recur(s,n-1,ti+pow(2,le),le+1,k,ans)); // now here we have the option to include or not include, so we take max of both cases.\\n            }\\n        }\\n        else{\\n            return 1+recur(s,n-1,ti,le+1,k,ans); // if s[n] is 0 we just include it by increasing our length and keeping our `ti` as same.\\n        }\\n        \\n    }\\n\\t\\n\\t    int longestSubsequence(string s, int k) {\\n        int ti = 0; //var to keep track of value till now\\n        int le = 0; // var to keep track of length till now\\n        int ans = 0; // var to keep track of ans\\n        recur(s,s.size()-1,ti,le,k,ans);\\n        return ans;\\n\\t\\t}\\n\\t}\\n        \\n```\\nAbove coe needs to be memozised to pass the test cases as it will give TLE.\\n\\nNow coming to iterative approach, as discussed earlier, we just want to know what was our `value  and length` when\\n* we included he last element\\n* excluded the last element\\n\\nand based on the if are including current element, we have two choices\\n* append to the value when we didnt include last value\\n* append to the value where we included last value\\n\\nand if are excluding the element, we again have two choices.\\n\\nNow, these choices are only when current elemnt is `1`,\\nif our current element is `0`, we will always include it, therefore for `0` , value will be max of previous length+1 and last value.\\n\\nthings will clear out if you see the code below and understand the comments.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int ans;\\n        vector<pair<int,int>> vec(2);\\n        // [ [len if taken , value], [length if not taken , value] ]\\n        vec[0] = {0,0}; // initially take and not taken value and length is 0\\n        vec[1] = {0,0};\\n        int n = s.size()-1;\\n        for(int i=n;i>=0;i--){\\n            vector<pair<int,int>> temp(2);\\n            temp[0] = {1,1}; // even if i dont append to any of last value, i can still include this number  as least possible value of k is 1, this value will be atleats 1 and length will be atleast 1 \\n            if(s[i]==\\'1\\'){\\n                int l1,l2,v1,v2;\\n                l1=l2=v1=v2=1;\\n                if(vec[0].second+pow(2,vec[0].first)<=k){ // comparing value if appending to last included element\\n                    l1 = vec[0].first+1;\\n                    v1 = vec[0].second+pow(2,vec[0].first);\\n                }\\n                if(vec[1].second+pow(2,vec[1].first)<=k){ // comparing value if appending to last included element\\n                    l2 = vec[1].first+1;\\n                    v2 = vec[1].second+pow(2,vec[1].first);\\n                }\\n                if(l1>l2){\\n                    temp[0] = {l1,v1}; // took whichever gave max ength\\n                }\\n                else{\\n                    temp[0] = {l2,v2};\\n                }\\n                \\n                if(vec[0].first>vec[1].first){\\n                    temp[1] = {vec[0].first,vec[0].second};\\n                }\\n                else{\\n                    temp[1] = {vec[1].first,vec[1].second};\\n                }\\n                \\n            }\\n            else{ // case for zero, take always the max giving length for both inclusion and exclusion of `0`\\n                if(vec[0].first>vec[1].first){\\n                    temp[1] = {vec[0].first+1,vec[0].second};\\n                    temp[0] = {vec[0].first+1,vec[0].second};\\n                }\\n                else{\\n                    temp[1] = {vec[1].first+1,vec[1].second};\\n                    temp[0] = {vec[1].first+1,vec[1].second};\\n                }\\n            }\\n            vec= temp;\\n        }\\n        ans = max(vec[0].first,vec[1].first); \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint recur(string s,int n,int ti,int le,int k,int &ans){\\n        ans = max(ans,le); // storing maximum length reached\\n        if(n<0){\\n            return 0; // if we have reached the start we need to return 0\\n        }\\n        if(s[n]==\\'1\\'){\\n             if(ti+pow(2,le)>k){\\n                return recur(s,n-1,ti,le,k,ans); // if the current number `ti` + 2^(lenth of string) is greater than our K, we dont want to include this, therfore, we dont increament, `le` or `ti` and just decraese `n` for further processing\\n            }\\n            else{\\n                return max(recur(s,n-1,ti,le,k,ans),1+recur(s,n-1,ti+pow(2,le),le+1,k,ans)); // now here we have the option to include or not include, so we take max of both cases.\\n            }\\n        }\\n        else{\\n            return 1+recur(s,n-1,ti,le+1,k,ans); // if s[n] is 0 we just include it by increasing our length and keeping our `ti` as same.\\n        }\\n        \\n    }\\n\\t\\n\\t    int longestSubsequence(string s, int k) {\\n        int ti = 0; //var to keep track of value till now\\n        int le = 0; // var to keep track of length till now\\n        int ans = 0; // var to keep track of ans\\n        recur(s,s.size()-1,ti,le,k,ans);\\n        return ans;\\n\\t\\t}\\n\\t}\\n        \\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int ans;\\n        vector<pair<int,int>> vec(2);\\n        // [ [len if taken , value], [length if not taken , value] ]\\n        vec[0] = {0,0}; // initially take and not taken value and length is 0\\n        vec[1] = {0,0};\\n        int n = s.size()-1;\\n        for(int i=n;i>=0;i--){\\n            vector<pair<int,int>> temp(2);\\n            temp[0] = {1,1}; // even if i dont append to any of last value, i can still include this number  as least possible value of k is 1, this value will be atleats 1 and length will be atleast 1 \\n            if(s[i]==\\'1\\'){\\n                int l1,l2,v1,v2;\\n                l1=l2=v1=v2=1;\\n                if(vec[0].second+pow(2,vec[0].first)<=k){ // comparing value if appending to last included element\\n                    l1 = vec[0].first+1;\\n                    v1 = vec[0].second+pow(2,vec[0].first);\\n                }\\n                if(vec[1].second+pow(2,vec[1].first)<=k){ // comparing value if appending to last included element\\n                    l2 = vec[1].first+1;\\n                    v2 = vec[1].second+pow(2,vec[1].first);\\n                }\\n                if(l1>l2){\\n                    temp[0] = {l1,v1}; // took whichever gave max ength\\n                }\\n                else{\\n                    temp[0] = {l2,v2};\\n                }\\n                \\n                if(vec[0].first>vec[1].first){\\n                    temp[1] = {vec[0].first,vec[0].second};\\n                }\\n                else{\\n                    temp[1] = {vec[1].first,vec[1].second};\\n                }\\n                \\n            }\\n            else{ // case for zero, take always the max giving length for both inclusion and exclusion of `0`\\n                if(vec[0].first>vec[1].first){\\n                    temp[1] = {vec[0].first+1,vec[0].second};\\n                    temp[0] = {vec[0].first+1,vec[0].second};\\n                }\\n                else{\\n                    temp[1] = {vec[1].first+1,vec[1].second};\\n                    temp[0] = {vec[1].first+1,vec[1].second};\\n                }\\n            }\\n            vec= temp;\\n        }\\n        ans = max(vec[0].first,vec[1].first); \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195720,
                "title": "longest-binary-subseqences-less-than-of-equal-to-k-2ms",
                "content": "\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int numOfZeros = 0;\\n        int numOfOnes = 0;\\n        int sum = 0;\\n        \\n        for(char ch : s.toCharArray())\\n            if(ch == \\'0\\') numOfZeros++;\\n        \\n        for(int i = s.length() - 1; i >= 0 && sum <= k; i--) {\\n            \\n            if(s.charAt(i) == \\'1\\') {\\n                sum += Math.pow(2, s.length() - 1 - i);\\n                if(sum <= k) {\\n                    numOfOnes++;\\n                }\\n            }\\n        }\\n        return numOfZeros + numOfOnes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int numOfZeros = 0;\\n        int numOfOnes = 0;\\n        int sum = 0;\\n        \\n        for(char ch : s.toCharArray())\\n            if(ch == \\'0\\') numOfZeros++;\\n        \\n        for(int i = s.length() - 1; i >= 0 && sum <= k; i--) {\\n            \\n            if(s.charAt(i) == \\'1\\') {\\n                sum += Math.pow(2, s.length() - 1 - i);\\n                if(sum <= k) {\\n                    numOfOnes++;\\n                }\\n            }\\n        }\\n        return numOfZeros + numOfOnes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194429,
                "title": "c-solution-dp",
                "content": "The idea is to include all 0\\'s if it appears, and only evaluate 1\\'s if the value is smaller than k. \\nWe store the value into DP array. \\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        int size = s.size();\\n        int dp[size];\\n        memset(&dp, 0, sizeof(dp));\\n        \\n        dp[size-1] = (s[size-1] == \\'0\\') ? 0 : 1;\\n        int cnt = 1;\\n        \\n        for (int i = size-2; i >= 0; --i)\\n        {\\n            dp[i] = dp[i+1];\\n            if (s[i] == \\'0\\')\\n            {\\n                ++cnt;\\n            }\\n            else\\n            {\\n                if (dp[i] + pow(2, cnt) <= k)\\n                {\\n                    dp[i] += pow(2, cnt);\\n                    ++cnt;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        int size = s.size();\\n        int dp[size];\\n        memset(&dp, 0, sizeof(dp));\\n        \\n        dp[size-1] = (s[size-1] == \\'0\\') ? 0 : 1;\\n        int cnt = 1;\\n        \\n        for (int i = size-2; i >= 0; --i)\\n        {\\n            dp[i] = dp[i+1];\\n            if (s[i] == \\'0\\')\\n            {\\n                ++cnt;\\n            }\\n            else\\n            {\\n                if (dp[i] + pow(2, cnt) <= k)\\n                {\\n                    dp[i] += pow(2, cnt);\\n                    ++cnt;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181139,
                "title": "easy-to-understand-dp-problem",
                "content": "# Think Recursion Slution First and then DP\\n**Recursion**\\n1. We will iterate from the end index, as we will be able to calculate the value at position n i.e. 2^n.\\n2. The problem can be converted in two sub problems. First, we include the digit on index i then we have to check if the value is 1, if yes, we will subtract the value of 1 at that position. Second, we will not include that particular digit.\\n3. We have to return the max result of the two sub-problems.\\n\\n**Memoization**\\n1. We include a dp array which will store intermediate results from solving the subproblems.\\n2. We return num where index reaches less than 0 and include other base cases as well.\\n3. We will early return if answer of that subproblem is already calculated.\\n\\n**Solution**\\n```\\nclass Solution {\\n    \\n    int toInc;\\n    public int longestSubsequence(String s, int k) {\\n        \\n        char[] charArr = s.toCharArray();\\n        int[] dp = new int[charArr.length];\\n        Arrays.fill(dp, -1);\\n        return recurse(charArr, charArr.length - 1, 0, k, dp);\\n        \\n    }\\n    \\n    private int recurse(char[] charArr, int idx, int num, int val, int[] dp) {\\n        // System.out.println(\"val \"+ val);\\n        if (val < 0) {\\n            return 0;\\n        }\\n        if (idx == -1) {\\n            return num;\\n        }\\n        if (dp[idx] != -1) {\\n            // System.out.println(\"new max \"+ num);\\n            return dp[idx];\\n        }\\n\\n        toInc = 0;\\n        if (charArr[idx] == \\'1\\') {\\n            toInc = (int)Math.pow(2, num);\\n        }\\n        \\n        \\n        dp[idx] = Math.max(recurse(charArr, idx - 1, num + 1, val - toInc, dp), recurse(charArr, idx - 1, num, val, dp));\\n        \\n        return dp[idx];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int toInc;\\n    public int longestSubsequence(String s, int k) {\\n        \\n        char[] charArr = s.toCharArray();\\n        int[] dp = new int[charArr.length];\\n        Arrays.fill(dp, -1);\\n        return recurse(charArr, charArr.length - 1, 0, k, dp);\\n        \\n    }\\n    \\n    private int recurse(char[] charArr, int idx, int num, int val, int[] dp) {\\n        // System.out.println(\"val \"+ val);\\n        if (val < 0) {\\n            return 0;\\n        }\\n        if (idx == -1) {\\n            return num;\\n        }\\n        if (dp[idx] != -1) {\\n            // System.out.println(\"new max \"+ num);\\n            return dp[idx];\\n        }\\n\\n        toInc = 0;\\n        if (charArr[idx] == \\'1\\') {\\n            toInc = (int)Math.pow(2, num);\\n        }\\n        \\n        \\n        dp[idx] = Math.max(recurse(charArr, idx - 1, num + 1, val - toInc, dp), recurse(charArr, idx - 1, num, val, dp));\\n        \\n        return dp[idx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180435,
                "title": "python-greedy-o-n",
                "content": "Idea is to go through the string from right to left (least significant bit towards higher significant bit) and consider the \\'1\\'s if considering it doesnt exceed the value of number we have so far beyond k.\\n\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        s = s[::-1]\\n        cur_val = 0\\n        ans = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                if cur_val + 2**i <= k:\\n                    ans += 1\\n                    cur_val += 2**i\\n                    \\n            elif s[i] == \\'0\\':\\n                ans += 1\\n                \\n        return ans\\n                \\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "Idea is to go through the string from right to left (least significant bit towards higher significant bit) and consider the \\'1\\'s if considering it doesnt exceed the value of number we have so far beyond k.\\n\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        s = s[::-1]\\n        cur_val = 0\\n        ans = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                if cur_val + 2**i <= k:\\n                    ans += 1\\n                    cur_val += 2**i\\n                    \\n            elif s[i] == \\'0\\':\\n                ans += 1\\n                \\n        return ans\\n                \\n\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2176055,
                "title": "simple-c",
                "content": "```\\nclass Solution {\\n    int preZero(string &s,int j){\\n        int res=0;\\n        for(int i=0;i<j;++i) res+=s[i]==\\'0\\';\\n        return res;\\n    }\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int cnt=1,n=s.size();\\n        // cnt will have no of bits required to represent k\\n        while(k>=(1<<cnt)) cnt++;\\n        //if string has less no of bits as compared to cnt return its length\\n        if(n-cnt<0) return n;\\n        //num will have integer value of last cnt bits\\n        int num=stoi(s.substr(n-cnt), 0, 2);\\n        // res will have no of 0\\'s before last cnt chars in s\\n        int res=preZero(s,n-cnt);\\n\\n        if(num<=k){\\n            return res+cnt;\\n        } else{\\n            if(res==0) return cnt-1;\\n            else return res+cnt-1;//as we will make an 0 MSB to make num<k\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    int preZero(string &s,int j){\\n        int res=0;\\n        for(int i=0;i<j;++i) res+=s[i]==\\'0\\';\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2173625,
                "title": "c-o-n-solution",
                "content": "class Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        int n = s.size();\\n        int sum =0;\\n        int tot =0;\\n        \\n        for(int i = s.size()-1;i >= 0;i--){\\n            if(s[i] == \\'1\\') tot++;\\n            \\n            if(s[i] == \\'1\\' && sum + pow(2,n-1-i) <= k){\\n                tot--;\\n                sum += pow(2,n-1-i);\\n            }\\n        }\\n        \\n        \\n        return n - tot;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        int n = s.size();\\n        int sum =0;\\n        int tot =0;\\n        \\n        for(int i = s.size()-1;i >= 0;i--){\\n            if(s[i] == \\'1\\') tot++;\\n            \\n            if(s[i] == \\'1\\' && sum + pow(2,n-1-i) <= k){\\n                tot--;\\n                sum += pow(2,n-1-i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2171371,
                "title": "faster-than-100-simple-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int n=s.length();\\n        if(n==0)\\n            return 0;\\n        int mul=1,sum=0,i=n-1,cnt=0;\\n        while(i>=0 && sum<=k){\\n           if((sum+((s[i]-\\'0\\')*mul))<=k){\\n               cnt++;\\n               sum+=((s[i]-\\'0\\')*mul);\\n           }\\n            mul*=2;\\n            i--;\\n        }\\n        return cnt;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int n=s.length();\\n        if(n==0)\\n            return 0;\\n        int mul=1,sum=0,i=n-1,cnt=0;\\n        while(i>=0 && sum<=k){\\n           if((sum+((s[i]-\\'0\\')*mul))<=k){\\n               cnt++;\\n               sum+=((s[i]-\\'0\\')*mul);\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2170752,
                "title": "greedy-and-smart-optimisations-o-n-c-javascript-typescript",
                "content": "Please read the question properly before searching for its solution. \\nYou should know the difference between **Subsequence** & **Subbarray** and knowledge of binary numbers\\n\\n## Approach : \\nGreedily get maximum 1s possible and use all the zeroes\\n\\n## Algorithm :\\n- We traverse from right of the binary string.\\n- We keep track of the power of 2 from the right of the string\\n- We also keep track of sum which the sum of binary sequence traversed till now and number of 1s traversed.  \\n- As soon sum hits greater than k we break from loop.\\n- We then add the total number of zeros and number of 1 traversed which results in the length of the longest substring\\n\\n## Visualisation\\n```\\n    100010100 [some binary sequence]\\n        ^\\n ```\\n The point where sum exceds the k\\n Wouldn\\'t the largest subsequence length would be :\\n = [number of zeroes in left] + [number of digits in right]  *since zero doesn\\'t add value we can take all the zero from left*\\n = [total number of zeroes] + [total number of 1s covered in right]\\n \\n Rest is the implementation in CPP and TS\\n\\t\\t\\t \\n```cpp\\nclass Solution {\\npublic:\\n   int longestSubsequence(string s, int k) {\\n       int ones = 0;\\n       for(int i = s.size() - 1 , sum = 0 , pw = 1; i >= 0; i-- , pw <<= 1) {\\n               if(sum + pw  > k)\\n                    break;\\n                if(s[i] == \\'1\\')\\n                    ones++ , sum += pw ;\\n       }\\n       return ones + count(s.begin() , s.end() , \\'0\\');\\n   }\\n};\\n```\\n```typescript\\nfunction longestSubsequence(s: string, k: number): number {\\n       let ones = 0;\\n       for(let i = s.length - 1 , sum = 0 , pw = 1; i >= 0 ; i-- , pw <<= 1 ) {\\n           if(sum + pw  > k)\\n               break;\\n          if(s[i] === \\'1\\') \\n              ones++ , sum += pw ;\\n       }\\n       return ones + s.split(\"\").filter(_ => _ === \\'0\\').length;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "JavaScript",
                    "TypeScript",
                    "Greedy"
                ],
                "code": "```\\n    100010100 [some binary sequence]\\n        ^\\n ```\n```cpp\\nclass Solution {\\npublic:\\n   int longestSubsequence(string s, int k) {\\n       int ones = 0;\\n       for(int i = s.size() - 1 , sum = 0 , pw = 1; i >= 0; i-- , pw <<= 1) {\\n               if(sum + pw  > k)\\n                    break;\\n                if(s[i] == \\'1\\')\\n                    ones++ , sum += pw ;\\n       }\\n       return ones + count(s.begin() , s.end() , \\'0\\');\\n   }\\n};\\n```\n```typescript\\nfunction longestSubsequence(s: string, k: number): number {\\n       let ones = 0;\\n       for(let i = s.length - 1 , sum = 0 , pw = 1; i >= 0 ; i-- , pw <<= 1 ) {\\n           if(sum + pw  > k)\\n               break;\\n          if(s[i] === \\'1\\') \\n              ones++ , sum += pw ;\\n       }\\n       return ones + s.split(\"\").filter(_ => _ === \\'0\\').length;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170602,
                "title": "python-simple-loop-with-stack-5-lines",
                "content": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        s, result = list(s), \\'\\'        \\n        while s:\\n            c = s.pop() + result\\n            if int(c, 2) <= k: result = c                        \\n        return len(result)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        s, result = list(s), \\'\\'        \\n        while s:\\n            c = s.pop() + result\\n            if int(c, 2) <= k: result = c                        \\n        return len(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170435,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Greedy Approach***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nWe will take all the zeros to maximize the length of subsequence, and will delete the ones depending on the position of the ones.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string str, int k) {\\n        \\n        int n = str.size();\\n        \\n        // del_count store the no of deleted characters\\n        \\n        int del_count = 0;\\n        \\n        // pos store the position of character from the right\\n        \\n        int pos = 0;\\n        \\n        // curr_number store the decimal number till ith index from right side\\n        \\n        int curr_number = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(pos < 31)   // if the number is in range of integer\\n            {\\n                if(str[i] == \\'1\\')\\n                {\\n                    if(curr_number + (1 << pos) <= k)\\n                    {\\n                        curr_number += (str[i] - \\'0\\') * (1 << pos);\\n                    }\\n                    else\\n                    {\\n                        del_count++;\\n                    }\\n                }\\n            }\\n            else  // number is out of range of integer\\n            {\\n                if(str[i] == \\'1\\')\\n                {\\n                    del_count++;\\n                }\\n            }\\n            \\n            pos++;\\n        }\\n        \\n        return n - del_count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nWe will take all the zeros to maximize the length of subsequence, and will delete the ones depending on the position of the ones.\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string str, int k) {\\n        \\n        int n = str.size();\\n        \\n        // del_count store the no of deleted characters\\n        \\n        int del_count = 0;\\n        \\n        // pos store the position of character from the right\\n        \\n        int pos = 0;\\n        \\n        // curr_number store the decimal number till ith index from right side\\n        \\n        int curr_number = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(pos < 31)   // if the number is in range of integer\\n            {\\n                if(str[i] == \\'1\\')\\n                {\\n                    if(curr_number + (1 << pos) <= k)\\n                    {\\n                        curr_number += (str[i] - \\'0\\') * (1 << pos);\\n                    }\\n                    else\\n                    {\\n                        del_count++;\\n                    }\\n                }\\n            }\\n            else  // number is out of range of integer\\n            {\\n                if(str[i] == \\'1\\')\\n                {\\n                    del_count++;\\n                }\\n            }\\n            \\n            pos++;\\n        }\\n        \\n        return n - del_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170257,
                "title": "simple-approach-taking-care-of-int-overflow-o-n-tc-o-1-space-c",
                "content": "```\\n int longestSubsequence(string s, int k) {\\n\\t int n= s.size(); int ans=-1,p=0;\\n        int t =0;\\n\\n        for(int j=n-1;j>=0;j--){         \\n            if(s[j]-\\'0\\' == 1 ){\\n                if(p>30)continue;\\n                else t += pow(2,p);\\n            }\\n\\n            if(t>k){t-= pow(2,p); }\\n            else p++;\\n        } \\n \\n        return p;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int longestSubsequence(string s, int k) {\\n\\t int n= s.size(); int ans=-1,p=0;\\n        int t =0;\\n\\n        for(int j=n-1;j>=0;j--){         \\n            if(s[j]-\\'0\\' == 1 ){\\n                if(p>30)continue;\\n                else t += pow(2,p);\\n            }\\n\\n            if(t>k){t-= pow(2,p); }\\n            else p++;\\n        } \\n \\n        return p;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2169997,
                "title": "detailed-explanation-on-why-we-need-all-0s-and-1s-from-the-end",
                "content": "The main key to understanding the solution to this problem is realizing that we need to take as many leading 0s as possible (as they add to the length of the subsequence but not the total value of the binary). Now the problem becomes optimizing the solution so as to end up with maximum number of leading 0s. This translates to hitting the number (<=k) from the end as fast as possible.  (Think of it this way - had you chosen a subsequence which just hits <=k in the middle, you would wound up losing out on leading 0s). \\n\\nNow the next step is to realize that to hit number just <=k from the end as fast as possible, you need to take ALL 0s from the end and ALL 1s. \\n\\nWhy do we need to take ALL 0s from the end? \\na. Because 0s from the end don\\'t add to the value of the subsequence (thus increasing the len of the subsequence taken)\\nb. Considering that 0 in the subsequence will increase the value of first 1 you see (and consequently the following 1s from the right) by a factor of 2- thus allowing you to hit value of subseq just <= k as fast as possible\\n\\nWhy do we need to take ALL 1s from the end (till we hit val > k )? \\nThis is pretty obvious as we need to hit the val of the subsequence just <=k as fast as possible. Considering that 1 will increase the val by 2^(len from the end as we are considering all 0s and 1s).\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        //take as many 0s from the beginning\\n        //so make sure we hit <=k from right as soon as possible \\n        //this can be done by taking ALL 0s from the end - add no value but power of first one will increase by *2\\n        // and all 1s from the end\\n        int currsum = 0, len = 0; int i ;\\n        for(i = s.length()-1; i>=0 && currsum<=k;i--){\\n            if(s[i]==\\'0\\')\\n                len++;\\n            if(s[i]==\\'1\\' && currsum + pow(2, len)<=k){\\n                currsum += pow(2, len);\\n                len++;\\n            }\\n        }\\n        return len;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        //take as many 0s from the beginning\\n        //so make sure we hit <=k from right as soon as possible \\n        //this can be done by taking ALL 0s from the end - add no value but power of first one will increase by *2\\n        // and all 1s from the end\\n        int currsum = 0, len = 0; int i ;\\n        for(i = s.length()-1; i>=0 && currsum<=k;i--){\\n            if(s[i]==\\'0\\')\\n                len++;\\n            if(s[i]==\\'1\\' && currsum + pow(2, len)<=k){\\n                currsum += pow(2, len);\\n                len++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2169883,
                "title": "o-n-simple-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int i =s.size()-1, ans = 0, ind = 0;\\n        string str = \"\";\\n        for(; i >= 0;--i)\\n        {\\n            if(ind > 31)\\n                break;\\n            if(s[i] == \\'0\\')\\n                str.push_back(s[i]);\\n            else\\n            {\\n                long long int k1 = 1LL* 1<<ind;\\n                if(1LL *(ans + k1) > k)\\n                    break;\\n                else\\n                {\\n                    ans+=k1;\\n                    str.push_back(s[i]);\\n                }\\n            }\\n            ind++;\\n        }\\n        for(; i>=0;--i)\\n        {\\n            if(s[i] == \\'0\\')\\n                str.push_back(s[i]);\\n            \\n        }\\n        return str.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int i =s.size()-1, ans = 0, ind = 0;\\n        string str = \"\";\\n        for(; i >= 0;--i)\\n        {\\n            if(ind > 31)\\n                break;\\n            if(s[i] == \\'0\\')\\n                str.push_back(s[i]);\\n            else\\n            {\\n                long long int k1 = 1LL* 1<<ind;\\n                if(1LL *(ans + k1) > k)\\n                    break;\\n                else\\n                {\\n                    ans+=k1;\\n                    str.push_back(s[i]);\\n                }\\n            }\\n            ind++;\\n        }\\n        for(; i>=0;--i)\\n        {\\n            if(s[i] == \\'0\\')\\n                str.push_back(s[i]);\\n            \\n        }\\n        return str.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169849,
                "title": "simple-c-solution-100-faster-time-complexity-100-faster-space-complexity",
                "content": "Approach -:\\n\\n          Index-: 0123456\\n  Now as eg. \"1001010\" \\n1) First a fall we count all the 0s in array because if we combine all the zeros and then check its decimal value which is always 0 and k>=1.\\n2) Our curr count is 5.\\n3) Now we have sum as a variable which compare with k.\\n4)  we add 1 from right side of string  and update the value of sum  and compare with k if its sum<=k count++ else break.\\n5)  Here you have a doubt of if(power>32) break. This is because of overflow ( sum+=pow(2,power);  6) In constraint if we see k<=10^9. (2^32> 10^9) \\n7) So if power >32 we break because sum> k which is against our conditions.\\n\\nPlease -: If u can understand so please upvote \\n\\n~~~\\n int longestSubsequence(string s, int k) {\\n        int n=s.length();\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            count++;\\n        }\\n        \\n        long long int sum=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                int power=n-i-1;\\n                if(power>32)\\n                break;\\n                \\n                sum+=pow(2,power);\\n                \\n                if(sum<=(long long)k)\\n                count++;\\n                else\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "Approach -:\\n\\n          Index-: 0123456\\n  Now as eg. \"1001010\" \\n1) First a fall we count all the 0s in array because if we combine all the zeros and then check its decimal value which is always 0 and k>=1.\\n2) Our curr count is 5.\\n3) Now we have sum as a variable which compare with k.\\n4)  we add 1 from right side of string  and update the value of sum  and compare with k if its sum<=k count++ else break.\\n5)  Here you have a doubt of if(power>32) break. This is because of overflow ( sum+=pow(2,power);  6) In constraint if we see k<=10^9. (2^32> 10^9) \\n7) So if power >32 we break because sum> k which is against our conditions.\\n\\nPlease -: If u can understand so please upvote \\n\\n~~~\\n int longestSubsequence(string s, int k) {\\n        int n=s.length();\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            count++;\\n        }\\n        \\n        long long int sum=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                int power=n-i-1;\\n                if(power>32)\\n                break;\\n                \\n                sum+=pow(2,power);\\n                \\n                if(sum<=(long long)k)\\n                count++;\\n                else\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2169320,
                "title": "c-simple-0-1-knapsack-similar-to-coin-change-detailed-explaination",
                "content": "**NOTE**: Always pass string by reference or else it would give memory limit exceeded error.\\n\\nOur basic idea would be to travel along the string, checkout each character, then either pick the element or not pick it. If you pick it, then k would be reduced by **(s[i]-\\'0\\')pow(2,x**)(this x is the lencount).its a string not array, so keep s[i]-\\'0\\' thing in mind.  If k<0 we return a large negative number so that this combination is not included latter on.\\nstep:1 reverse the string so that you could work from index 0.\\n\\nstep2:have a lencount which has the count of the included characters. It is used in pow(2,lencount).\\n\\nstep3: simple 0-1 knapsack with k as the weight. if a particular (long long)(s[i]-\\'0\\')pow(2,lencount)<=k we can either pick or not pick it,if  (long long)(s[i]-\\'0\\')pow(2,lencount)>k we cannot include it\\n\\n\\n```\\nint solve(long long i,string&s,long long k,long long lencount,long long t[1001][1001]){\\n        int n=s.size();\\n        if(i==n) return 0;\\n        if(k<0) return INT_MIN-1;\\n        \\n        if(t[i][lencount]!=-1) return t[i][lencount];\\n        \\n        if((long long)(s[i]-\\'0\\')*pow(2,lencount)<=k){\\n\\t\\tint pick=1+solve(i+1,s , k-(long long)(s[i]-\\'0\\')*pow(2,lencount), lencount+1, t);\\n        int notpick=solve(i+1,s,k,lencount,t);\\n\\t\\treturn t[i][lencount]=max(pick,notpick);\\n\\t\\t}\\n        else return t[i][lencount]=solve(i+1,s,k,lencount,t);\\n    \\n    }\\n    int longestSubsequence(string s, int k) {\\n        int n=s.size();\\n        reverse(s.begin(),s.end());\\n        long long t[1001][1001];\\n        memset(t,-1,sizeof(t));\\n        return solve(0,s,k,0,t);\\n        \\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint solve(long long i,string&s,long long k,long long lencount,long long t[1001][1001]){\\n        int n=s.size();\\n        if(i==n) return 0;\\n        if(k<0) return INT_MIN-1;\\n        \\n        if(t[i][lencount]!=-1) return t[i][lencount];\\n        \\n        if((long long)(s[i]-\\'0\\')*pow(2,lencount)<=k){\\n\\t\\tint pick=1+solve(i+1,s , k-(long long)(s[i]-\\'0\\')*pow(2,lencount), lencount+1, t);\\n        int notpick=solve(i+1,s,k,lencount,t);\\n\\t\\treturn t[i][lencount]=max(pick,notpick);\\n\\t\\t}\\n        else return t[i][lencount]=solve(i+1,s,k,lencount,t);\\n    \\n    }\\n    int longestSubsequence(string s, int k) {\\n        int n=s.size();\\n        reverse(s.begin(),s.end());\\n        long long t[1001][1001];\\n        memset(t,-1,sizeof(t));\\n        return solve(0,s,k,0,t);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168879,
                "title": "cpp-100-fast-bit-dry-run-image-explanation",
                "content": "**INTUTION:** \\n1. **BRUTE FORCE**: My initial though was to generate all possible subsequence, filter our the subsequences whose decimal equivalent is less than equal to K, and find the maximum length among them. **But**, this will not work as ```1 <= s.length <= 1000```, so generating all sub-sequence cost me O(2^1000) which is **HUGE**. So, **TLE**\\n2. **MOST OPTIMIZED**: See, we can not blindly generate all sub-sequences, so we need to find some other way out. \\n![image](https://assets.leetcode.com/users/images/d2e63714-6d82-4bce-915b-41cf0538967a_1655617229.576759.jpeg)\\n\\n* \\tFor generating sub-sequences we first include ith index, and then not include  ith index, right ? So, we will apply similar approach. But we need to find a way out in order to decide wheather to take ith bit or not.\\n\\n* \\tNow, we know, that only \\'1\\' will contribute to increase value of number, and \\'0\\' will not increase the value but help us in achieving maximum length, so, we will `INCLUDE all \\'0\\'s`. And we `will INCLUDE only those \\'1\\'s whose decimal equivalent will not exceeds our target \\'k\\', and EXCLUDE \\'1\\' otherwise`\\n\\n**DRY RUN:**\\n![image](https://assets.leetcode.com/users/images/26054351-eacc-4b4f-b971-7cdb8e6d952f_1655617390.1909792.jpeg)\\n\\n**CODE**\\n```\\n\\tint longestSubsequence(string s, int k) {\\n        reverse(s.begin(), s.end());\\n        int cnt=0;  long long num=0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            int bit= s[i]-\\'0\\'; // ith bit\\n            \\n            if(bit==0){ // always include\\n                cnt++;\\n            }\\n            else if(bit==1){\\n                if( pow(2,cnt)*bit + num <= k ){ // include\\n                    num=num+pow(2,cnt)*bit;\\n                    cnt++;\\n                }\\n                //else---> exclude\\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n```\\nTime Complexity: O(N)\\nThanking You !",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```1 <= s.length <= 1000```\n```\\n\\tint longestSubsequence(string s, int k) {\\n        reverse(s.begin(), s.end());\\n        int cnt=0;  long long num=0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            int bit= s[i]-\\'0\\'; // ith bit\\n            \\n            if(bit==0){ // always include\\n                cnt++;\\n            }\\n            else if(bit==1){\\n                if( pow(2,cnt)*bit + num <= k ){ // include\\n                    num=num+pow(2,cnt)*bit;\\n                    cnt++;\\n                }\\n                //else---> exclude\\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168616,
                "title": "ez-c-solution-0ms-100-lesser-memory-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    string toBinary(int c){\\n        string ans=\"\";\\n        while(c!=0){\\n            if(c%2==1)\\n                ans.push_back(\\'1\\');\\n            else\\n                ans.push_back(\\'0\\');\\n            c/=2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    int longestSubsequence(string s, int k) {\\n        \\n        string ans=toBinary(k); \\n        if(ans.size()>=s.size())//If the length of our given \\'k\\' in binary is greater than the given binary string then longest subsequence is equal to the length of the given string\\n            return s.size();      \\n       \\n        int i=s.length()-ans.length();//to find a substring which iis smaller than our \\'k\\' (in binary) we are using the slidng window technique and moving in a reverse order of our binary string \\'s\\'\\n        while(i>=0){\\n            string tmp=s.substr(i,ans.length());\\n            if(tmp<=ans)//given substring is smaller             \\n                break;            \\n            i--;\\n        }\\n        if(i==-1)///If no substring is found then longest subsequence is the length of binary representation of \\'k\\'\\n            return ans.length()-1;\\n       int start=ans.length();\\n        //We are now moving from the beginning of the string \\'s\\' and as soon as we encounter a \\'0\\' we increment our \\'start\\' to calculate the longest subsequence\\n       for(int  j=0;j<i;j++) \\n           if(s[j]==\\'0\\')\\n               start++;\\n        cout<<ans;\\n        return (start);            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string toBinary(int c){\\n        string ans=\"\";\\n        while(c!=0){\\n            if(c%2==1)\\n                ans.push_back(\\'1\\');\\n            else\\n                ans.push_back(\\'0\\');\\n            c/=2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    int longestSubsequence(string s, int k) {\\n        \\n        string ans=toBinary(k); \\n        if(ans.size()>=s.size())//If the length of our given \\'k\\' in binary is greater than the given binary string then longest subsequence is equal to the length of the given string\\n            return s.size();      \\n       \\n        int i=s.length()-ans.length();//to find a substring which iis smaller than our \\'k\\' (in binary) we are using the slidng window technique and moving in a reverse order of our binary string \\'s\\'\\n        while(i>=0){\\n            string tmp=s.substr(i,ans.length());\\n            if(tmp<=ans)//given substring is smaller             \\n                break;            \\n            i--;\\n        }\\n        if(i==-1)///If no substring is found then longest subsequence is the length of binary representation of \\'k\\'\\n            return ans.length()-1;\\n       int start=ans.length();\\n        //We are now moving from the beginning of the string \\'s\\' and as soon as we encounter a \\'0\\' we increment our \\'start\\' to calculate the longest subsequence\\n       for(int  j=0;j<i;j++) \\n           if(s[j]==\\'0\\')\\n               start++;\\n        cout<<ans;\\n        return (start);            \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2168600,
                "title": "easy-c-solution-using-one-pass-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int n = s.size();\\n        long long sum = 0; // sum to check whether it is less than k or not\\n        string res = \"\"; // string to store the result\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            int power = res.size();\\n            if(s[i] == \\'0\\') // if it is zero add it to the res\\n                res += s[i];\\n            else\\n            {\\n                if(power > 59) // checking if the condition is out of bounds or not\\n                    continue;\\n                sum += pow(2, power);\\n                if(sum <= k)\\n                    res += \\'1\\';\\n            }\\n        }\\n        return res.size(); // finally return the size of resultant string\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int n = s.size();\\n        long long sum = 0; // sum to check whether it is less than k or not\\n        string res = \"\"; // string to store the result\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            int power = res.size();\\n            if(s[i] == \\'0\\') // if it is zero add it to the res\\n                res += s[i];\\n            else\\n            {\\n                if(power > 59) // checking if the condition is out of bounds or not\\n                    continue;\\n                sum += pow(2, power);\\n                if(sum <= k)\\n                    res += \\'1\\';\\n            }\\n        }\\n        return res.size(); // finally return the size of resultant string\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168574,
                "title": "what-s-wrong-with-this-recursive-code",
                "content": "Can someone please tell what is wrong with this code, why does this give a wrong answer? :(\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int n = s.length();\\n        int m1 = func(s, k, 0, n-1, new StringBuilder());\\n        return m1;\\n    }\\n    \\n    public int func(String s, int k, int si, int ei, StringBuilder sb){\\n        if(ei<0) return 0;\\n        int val=0;\\n        char ch = s.charAt(ei);\\n        if(sb.length()>0){\\n            val=value(sb.toString(), k);\\n        }\\n        if(val>k) return 0;\\n        int take = 1 + func(s,k,si,ei-1,sb.insert(0, ch));\\n        int notTake = func(s,k,si,ei-1,sb);\\n        \\n        return Math.max(take, notTake);\\n    }\\n    \\n    public int value(String s,int k){\\n        System.out.println(s);\\n        int n = s.length();\\n        int mul=1;\\n        int ans=0;\\n        for(int i=n-1; i>=0; i--){\\n            if(s.charAt(i)==\\'1\\') ans+=mul;\\n            mul*=2;\\n        }\\n      \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int n = s.length();\\n        int m1 = func(s, k, 0, n-1, new StringBuilder());\\n        return m1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2168490,
                "title": "c-dp-keep-track-of-number-of-bits-and-knapsack-dp",
                "content": "```\\n/* \\n    Time: O(n^2)\\n    Space: O(n^2)\\n    Tag: DP, Memoization, Bit Manipulation\\n    Difficulty: MH\\n*/\\n\\ntypedef long long ll;\\n\\nclass Solution {\\n\\n    vector<vector<ll>> t;\\n\\n    ll solve(string &s, ll k, ll cur, int idx, ll count) {\\n        if (cur > k) return LLONG_MIN - 1;\\n        if (idx >= s.length()) return 0;\\n        if (t[idx][count] != -1) return t[idx][count];\\n\\n        int res = 0;\\n        if (count < 32) {\\n            ll temp = cur + (((ll)(s[idx] - \\'0\\')) << (count));\\n            if (temp <= k)\\n                res = max(solve(s, k, cur, idx + 1, count), 1 + solve(s, k, temp, idx + 1, count + 1));\\n            else {\\n                res = solve(s, k, cur, idx + 1, count);\\n            }\\n        } else if (s[idx] == \\'0\\') {\\n            res = max(solve(s, k, cur, idx + 1, count), 1 + solve(s, k, cur, idx + 1, count + 1));\\n        } else\\n            res = solve(s, k, cur, idx + 1, count);\\n        return t[idx][count] = res;\\n    }\\n\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        t.resize(s.length() + 1, vector<ll>(s.length() + 1, -1));\\n        reverse(s.begin(), s.end());\\n        return solve(s, k, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/* \\n    Time: O(n^2)\\n    Space: O(n^2)\\n    Tag: DP, Memoization, Bit Manipulation\\n    Difficulty: MH\\n*/\\n\\ntypedef long long ll;\\n\\nclass Solution {\\n\\n    vector<vector<ll>> t;\\n\\n    ll solve(string &s, ll k, ll cur, int idx, ll count) {\\n        if (cur > k) return LLONG_MIN - 1;\\n        if (idx >= s.length()) return 0;\\n        if (t[idx][count] != -1) return t[idx][count];\\n\\n        int res = 0;\\n        if (count < 32) {\\n            ll temp = cur + (((ll)(s[idx] - \\'0\\')) << (count));\\n            if (temp <= k)\\n                res = max(solve(s, k, cur, idx + 1, count), 1 + solve(s, k, temp, idx + 1, count + 1));\\n            else {\\n                res = solve(s, k, cur, idx + 1, count);\\n            }\\n        } else if (s[idx] == \\'0\\') {\\n            res = max(solve(s, k, cur, idx + 1, count), 1 + solve(s, k, cur, idx + 1, count + 1));\\n        } else\\n            res = solve(s, k, cur, idx + 1, count);\\n        return t[idx][count] = res;\\n    }\\n\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        t.resize(s.length() + 1, vector<ll>(s.length() + 1, -1));\\n        reverse(s.begin(), s.end());\\n        return solve(s, k, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168473,
                "title": "well-explained-code-c-easy-greedy-approach",
                "content": "INTUTION :-\\nin the binary string \\nex => 101010011100\\nyou have to find subsequence which has longest length \\n1. you can take all the zeros because it have no contribution in the subsequence\\n\\t\\t\\teach s[i] contribution is equal to = s[i]*pow   \\n\\t\\t\\ts[i] == 0 so contribution is zero for all zeros in the string.\\n2. if you want to take any of the one in the string so choose the one which have smallest contribution in the subsequence so the question is what it will be ? \\n\\t\\t\\tso let\\'s discuss --\\n\\t\\t\\t1     0         1          1             0          0            1          0           1\\n\\t\\t\\t2^8\\t\\t2^7\\t\\t2^6\\t\\t\\t2^5\\t\\t\\t\\t2^4\\t\\t\\t2^3\\t\\t\\t\\t2^2\\t\\t\\t2^1\\t\\t\\t2^0\\n\\t\\t\\t\\n\\t\\t\\tso choose one from the ending of the string becuase it has lesser contribution than starting and when we add it\\'s contribution to the sum it must not cross tha k \\n\\t\\t\\tsum <= k always\\n\\t\\t\\tans pow won\\'t exceed 10^9  if it will do so than we have added more elememts than required.\\n\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int ans = 0, n = s.size();\\n        long long pow = 1, sum = 0;\\n        for(int i = n-1; i>= 0; i--) {\\n            long long temp = pow*(s[i]-\\'0\\');\\n            if(temp+sum <= k) {\\n                 ans++;\\n                sum += temp;\\n                if(pow < 1e9)pow *= 2;\\n            }\\n           else continue;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int ans = 0, n = s.size();\\n        long long pow = 1, sum = 0;\\n        for(int i = n-1; i>= 0; i--) {\\n            long long temp = pow*(s[i]-\\'0\\');\\n            if(temp+sum <= k) {\\n                 ans++;\\n                sum += temp;\\n                if(pow < 1e9)pow *= 2;\\n            }\\n           else continue;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168460,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        zc = 0\\n        for i in range(len(s)):\\n            if int(s[i:], 2) <= k:\\n                return len(s)-i+zc\\n            zc += 1 if s[i] == \\'0\\' else 0\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        zc = 0\\n        for i in range(len(s)):\\n            if int(s[i:], 2) <= k:\\n                return len(s)-i+zc\\n            zc += 1 if s[i] == \\'0\\' else 0\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168392,
                "title": "c-simple-brute-force-solution",
                "content": "```\\n// count number of 0\\'s\\n// then make the number from \\n// right to left if number is less than or equal to target\\n// the length will be number of 0\\'s on left + length(number)\\n\\n    bool islessequal(string bs,int k)\\n    {\\n        long long int num=0,t=k;\\n\\n        for(auto c:bs)\\n        {\\n            num = num*2+(c-\\'0\\');\\n            if(num>t) return false;\\n        }\\n        return num<=t;\\n    }\\n\\n    int longestSubsequence(string s, int k)\\n    {\\n        int c=0;\\n        for(auto x:s) if(x==\\'0\\') c++;\\n\\n        int n = s.size();\\n        long long int num=0,t = k;\\n        string bs=\"\";\\n        int ans = 0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            bs = s[i]+bs;\\n            if(s[i]==\\'0\\') c--;\\n\\n            if(islessequal(bs,k))\\n            {\\n                int size = bs.size()+c;\\n                ans = max(ans,size);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// count number of 0\\'s\\n// then make the number from \\n// right to left if number is less than or equal to target\\n// the length will be number of 0\\'s on left + length(number)\\n\\n    bool islessequal(string bs,int k)\\n    {\\n        long long int num=0,t=k;\\n\\n        for(auto c:bs)\\n        {\\n            num = num*2+(c-\\'0\\');\\n            if(num>t) return false;\\n        }\\n        return num<=t;\\n    }\\n\\n    int longestSubsequence(string s, int k)\\n    {\\n        int c=0;\\n        for(auto x:s) if(x==\\'0\\') c++;\\n\\n        int n = s.size();\\n        long long int num=0,t = k;\\n        string bs=\"\";\\n        int ans = 0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            bs = s[i]+bs;\\n            if(s[i]==\\'0\\') c--;\\n\\n            if(islessequal(bs,k))\\n            {\\n                int size = bs.size()+c;\\n                ans = max(ans,size);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168371,
                "title": "c-easy-solution",
                "content": "```\\nint longestSubsequence(string s, int k) {\\n        vector<int> dp(32,0);\\n        int j=0;\\n        for(int i=0;i<31;i++){\\n            int p=(1<<i);\\n            if(p & k) dp[i]+=1,j=i;\\n        }\\n        int n=s.length(),count=0,res=0,ans=0,var=j;\\n        if(n<=var) res=max(res,n);\\n        for(int i=0;i<n;i++){\\n          j=var-1;\\n          if(s[i]==\\'0\\'){\\n            count++;\\n            res=max(res,min(count+var,n-i-1+count));\\n          }\\n          else{\\n             ans=0;\\n             ans+=(count+1);\\n             for(int temp=i+1;temp<n && j>=0;temp++){\\n               if(s[temp]==\\'1\\' && dp[j]==1){\\n                 ans++,j--;\\n               }\\n               else if(s[temp]==\\'0\\' && dp[j]==1){\\n                 ans+=min(j+1,n-temp);\\n                 break;\\n               }\\n               else if(s[temp]==\\'0\\' && dp[j]==0){\\n                 ans++,j--;\\n               }\\n             }\\n             res=max(ans,res);\\n          }\\n        }\\n        res=max(res,min(var,n));\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint longestSubsequence(string s, int k) {\\n        vector<int> dp(32,0);\\n        int j=0;\\n        for(int i=0;i<31;i++){\\n            int p=(1<<i);\\n            if(p & k) dp[i]+=1,j=i;\\n        }\\n        int n=s.length(),count=0,res=0,ans=0,var=j;\\n        if(n<=var) res=max(res,n);\\n        for(int i=0;i<n;i++){\\n          j=var-1;\\n          if(s[i]==\\'0\\'){\\n            count++;\\n            res=max(res,min(count+var,n-i-1+count));\\n          }\\n          else{\\n             ans=0;\\n             ans+=(count+1);\\n             for(int temp=i+1;temp<n && j>=0;temp++){\\n               if(s[temp]==\\'1\\' && dp[j]==1){\\n                 ans++,j--;\\n               }\\n               else if(s[temp]==\\'0\\' && dp[j]==1){\\n                 ans+=min(j+1,n-temp);\\n                 break;\\n               }\\n               else if(s[temp]==\\'0\\' && dp[j]==0){\\n                 ans++,j--;\\n               }\\n             }\\n             res=max(ans,res);\\n          }\\n        }\\n        res=max(res,min(var,n));\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2168356,
                "title": "c-greedy-easy-to-understand",
                "content": "Intuition:\\n\\n1.We can select all \\'0\\'s;\\n2.Select \\'1\\' as many as possile from tail to head; \\n\\n```\\n        public int LongestSubsequence(string s, int k)\\n        {\\n            int totalZeros = s.Count(x => x == \\'0\\');\\n            int ones = 0;//count of \\'1\\' from tail to head\\n            int zeros = 0;//count of \\'0\\' from tail to head\\n            long curr = 0;//must long type to avoid overflow\\n            for(int i = s.Length - 1; i >= 0; i--)\\n            {\\n                if (s[i] == \\'0\\')\\n                {\\n                    zeros++;\\n                }\\n                else\\n                {\\n                    long val = (long)1 << (zeros + ones);//value of curr \\'1\\'\\n                    if(curr+val> k)//exceed\\n                    {\\n                        break;\\n                    }\\n                    else if (curr + val == k)\\n                    {\\n                        ones++;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        ones++;\\n                        curr += val;\\n                    }\\n                }\\n            }\\n            return totalZeros + ones;\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public int LongestSubsequence(string s, int k)\\n        {\\n            int totalZeros = s.Count(x => x == \\'0\\');\\n            int ones = 0;//count of \\'1\\' from tail to head\\n            int zeros = 0;//count of \\'0\\' from tail to head\\n            long curr = 0;//must long type to avoid overflow\\n            for(int i = s.Length - 1; i >= 0; i--)\\n            {\\n                if (s[i] == \\'0\\')\\n                {\\n                    zeros++;\\n                }\\n                else\\n                {\\n                    long val = (long)1 << (zeros + ones);//value of curr \\'1\\'\\n                    if(curr+val> k)//exceed\\n                    {\\n                        break;\\n                    }\\n                    else if (curr + val == k)\\n                    {\\n                        ones++;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        ones++;\\n                        curr += val;\\n                    }\\n                }\\n            }\\n            return totalZeros + ones;\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168319,
                "title": "simple-logic",
                "content": "*  start traversal from last keep adding 0 and if encounter 1 check ,it can be addable or not.\\n\\n```\\n int longestSubsequence(string s, int k) {\\n        long long i= 0 , j= s.length()-1 ,counter=0;\\n        long long num = 0;\\n        \\n        while(j >= 0)\\n        {\\n            if(s[j] == \\'1\\' && i<32){\\n                num |= (1ll<<i);\\n                if(num <= k){\\n                    counter++;\\n                }\\n                else{\\n                    num ^= (1<<i);\\n                }\\n            }\\n            else if(s[j] == \\'0\\'){\\n                counter++;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return counter;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int longestSubsequence(string s, int k) {\\n        long long i= 0 , j= s.length()-1 ,counter=0;\\n        long long num = 0;\\n        \\n        while(j >= 0)\\n        {\\n            if(s[j] == \\'1\\' && i<32){\\n                num |= (1ll<<i);\\n                if(num <= k){\\n                    counter++;\\n                }\\n                else{\\n                    num ^= (1<<i);\\n                }\\n            }\\n            else if(s[j] == \\'0\\'){\\n                counter++;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return counter;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168303,
                "title": "python-o-n-solution-count-0-and-working-backwards",
                "content": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        n = len(s)\\n        total0 = 0\\n        for char in s:\\n            if char == \\'0\\':\\n                total0 += 1\\n        if total0 == n:\\n            return n\\n        curr, temp, total1 = 0, 1, 0\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == \\'1\\':\\n                curr += temp\\n                if curr > k:\\n                    return total0 + total1\\n                total1 += 1\\n            temp *= 2\\n        return n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        n = len(s)\\n        total0 = 0\\n        for char in s:\\n            if char == \\'0\\':\\n                total0 += 1\\n        if total0 == n:\\n            return n\\n        curr, temp, total1 = 0, 1, 0\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == \\'1\\':\\n                curr += temp\\n                if curr > k:\\n                    return total0 + total1\\n                total1 += 1\\n            temp *= 2\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168267,
                "title": "c-solution-greedy-algorithm-with-explaination",
                "content": "Take a suufix of given string of maximum length such that it\\'s decimal representation is less than k. Then add all the count of zeroes that are left of that suffix. Because zeroes on left side of will have no effect on decimal representation.\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) \\n    {\\n        int i,j,idx=-1,ans=0,n=s.size(),len;\\n        long long temp=0,d=1;\\n        \\n        //len  is the number of bits in binary represntation of k\\n        // It will be helpfulll in avoid runtime error\\n        len=log2(k)+1;\\n        for(i=n-1;i>=0 && (n-i-1)<=len;i--)\\n        {\\n            j=n-1-i;\\n            // calculatin decimal value from index i to n-1\\n            temp=temp+d*1ll*(s[i]-\\'0\\');\\n            d*=2;\\n            if(temp>k)\\n            {\\n                break;\\n            }\\n            ans++;\\n            idx=i;\\n        }\\n        //add all the zeroes that are left to the idx;\\n        for(i=0;i<idx;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) \\n    {\\n        int i,j,idx=-1,ans=0,n=s.size(),len;\\n        long long temp=0,d=1;\\n        \\n        //len  is the number of bits in binary represntation of k\\n        // It will be helpfulll in avoid runtime error\\n        len=log2(k)+1;\\n        for(i=n-1;i>=0 && (n-i-1)<=len;i--)\\n        {\\n            j=n-1-i;\\n            // calculatin decimal value from index i to n-1\\n            temp=temp+d*1ll*(s[i]-\\'0\\');\\n            d*=2;\\n            if(temp>k)\\n            {\\n                break;\\n            }\\n            ans++;\\n            idx=i;\\n        }\\n        //add all the zeroes that are left to the idx;\\n        for(i=0;i<idx;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168248,
                "title": "backtracking-gave-tle-help-required",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(string a, string b){\\n        return a.size()<b.size();\\n    }\\n    int maxi = INT_MIN;\\n    vector<string>v;\\n    void printSubSeqRec(string str, int n,int k ,int index = -1,\\n                    string curr = \"\")\\n{\\n  \\n    if (index == n)\\n        return;\\n \\n    if (!curr.empty()) {\\n        \\n        v.push_back(curr);\\n    }\\n \\n    for (int i = index + 1; i < n; i++) {\\n \\n        curr += str[i];\\n        printSubSeqRec(str, n, k,i, curr);\\n        curr = curr.erase(curr.size() - 1);\\n    }\\n    return;\\n}\\n    int longestSubsequence(string s, int k) {\\n        if(s.size()==0) return 0;\\n        int x=0;\\n        printSubSeqRec(s, s.size(),k);\\n        sort(v.begin(), v.end(), cmp);\\n        for(int i=v.size()-1; i>=0; i--){\\n            int p=stoi(v[i],nullptr,2);\\n            if(p<=k){\\n                x=v[i].size();\\n                break;\\n            }\\n        }\\n        return x;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    static bool cmp(string a, string b){\\n        return a.size()<b.size();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2168238,
                "title": "python-sliding-windows",
                "content": "idea: sliding window to find string contain any subs <k , plus all the zeros infront of the window. \\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        \\n        \\n        curr = \\'\\'\\n\\n        ans = 0\\n        zeros = 0\\n        for i in range(len(s)):\\n            curr += s[i]\\n            while int(curr, 2) > k:\\n                zeros += curr[0] == \\'0\\'\\n                curr = curr[1:]\\n                \\n            # print(curr)\\n            ans = max(ans, len(curr) + zeros)\\n            \\n        return ans\\n                \\n``",
                "solutionTags": [],
                "code": "idea: sliding window to find string contain any subs <k , plus all the zeros infront of the window. \\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        \\n        \\n        curr = \\'\\'\\n\\n        ans = 0\\n        zeros = 0\\n        for i in range(len(s)):\\n            curr += s[i]\\n            while int(curr, 2) > k:\\n                zeros += curr[0] == \\'0\\'\\n                curr = curr[1:]\\n                \\n            # print(curr)\\n            ans = max(ans, len(curr) + zeros)\\n            \\n        return ans\\n                \\n``",
                "codeTag": "Java"
            },
            {
                "id": 2168224,
                "title": "python-intuitive-linear-solution-o-n",
                "content": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        b = bin(k)[2:]\\n        print(b)\\n        ind = []\\n        for i in range(len(b)):\\n            if b[i] == \\'1\\':\\n                ind.append(len(b)-i-1)\\n        flag = True\\n        l = 0\\n        for i in s[::-1]:\\n            if i == \\'0\\':\\n                l += 1\\n            else:\\n                while ind and l > ind[-1]:\\n                    ind.pop()\\n                    flag = True\\n                if ind and ind[-1] == l and not flag:\\n                    ind.pop()\\n                if ind:\\n                    l += 1\\n                    flag = False\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        b = bin(k)[2:]\\n        print(b)\\n        ind = []\\n        for i in range(len(b)):\\n            if b[i] == \\'1\\':\\n                ind.append(len(b)-i-1)\\n        flag = True\\n        l = 0\\n        for i in s[::-1]:\\n            if i == \\'0\\':\\n                l += 1\\n            else:\\n                while ind and l > ind[-1]:\\n                    ind.pop()\\n                    flag = True\\n                if ind and ind[-1] == l and not flag:\\n                    ind.pop()\\n                if ind:\\n                    l += 1\\n                    flag = False\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168191,
                "title": "java",
                "content": "public int longestSubsequence(String s, int k) {\\n\\n        int t=1;\\n        int num;\\n        int ln = Integer.toString(1000000001,2).length();\\n    ln = ln>s.length()? s.length():ln;\\n        while(t<=ln)\\n        {\\n        \\tnum=Integer.parseInt(s.substring(s.length()-t), 2);\\n        \\t\\n        \\tif(num>k)\\n        \\t{\\n        \\t\\tbreak;\\n        \\t}\\n        \\tt++;\\n        }\\n        int oc=0;\\n        for(int i=s.length()-1; i>s.length()-t;i--)\\n        {\\n        if(s.charAt(i)==\\'1\\')\\n        {\\n        \\toc++;\\n        }\\n        }\\n        int zc =0;\\n        for(char c: s.toCharArray())\\n        {\\n        \\tif(c==\\'0\\')\\n        \\t{\\n        \\t\\tzc++;\\n        \\t}\\n        }\\n        \\n        \\n        return oc+zc;\\n    }",
                "solutionTags": [],
                "code": "public int longestSubsequence(String s, int k) {\\n\\n        int t=1;\\n        int num;\\n        int ln = Integer.toString(1000000001,2).length();\\n    ln = ln>s.length()? s.length():ln;\\n        while(t<=ln)\\n        {\\n        \\tnum=Integer.parseInt(s.substring(s.length()-t), 2);\\n        \\t\\n        \\tif(num>k)\\n        \\t{\\n        \\t\\tbreak;\\n        \\t}\\n        \\tt++;\\n        }\\n        int oc=0;\\n        for(int i=s.length()-1; i>s.length()-t;i--)\\n        {\\n        if(s.charAt(i)==\\'1\\')\\n        {\\n        \\toc++;\\n        }\\n        }\\n        int zc =0;\\n        for(char c: s.toCharArray())\\n        {\\n        \\tif(c==\\'0\\')\\n        \\t{\\n        \\t\\tzc++;\\n        \\t}\\n        }\\n        \\n        \\n        return oc+zc;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2168157,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int x = 0;\\n        long long int sum=0;\\n        int c=0;\\n        int i=s.size()-1;\\n        while(x <= s.size()-1){\\n            if(pow(2,x) > k)\\n                break;\\n            sum = sum + pow(2,x) * (s[i--]-\\'0\\');\\n            if(sum <= k){\\n                c++;\\n                x++;\\n            }\\n            else if(sum > k){\\n                break;\\n            }\\n        }\\n        for(int i=0;i<(s.size()-x);i++){\\n            if(s[i]==\\'0\\')\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int x = 0;\\n        long long int sum=0;\\n        int c=0;\\n        int i=s.size()-1;\\n        while(x <= s.size()-1){\\n            if(pow(2,x) > k)\\n                break;\\n            sum = sum + pow(2,x) * (s[i--]-\\'0\\');\\n            if(sum <= k){\\n                c++;\\n                x++;\\n            }\\n            else if(sum > k){\\n                break;\\n            }\\n        }\\n        for(int i=0;i<(s.size()-x);i++){\\n            if(s[i]==\\'0\\')\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168154,
                "title": "consider-only-last-30-bits-delete-all-the-1s-after-that",
                "content": "k is less than 10^9 , so considering only last 30 bits should be enough.\\n\\nDelete all the 1s after 1st 30 bits.\\ntake sum of first 30 bits and delete one by one till you get it less than k\\n\\nSpace : O(1)\\nTime: O(n)\\n\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int[] arr = new int[32];\\n        int deletedChar = 0;\\n        int sumOfLast30 = 0 ;\\n\\n        \\n        for(int i = 0 ; i < s.length() ; i++) {\\n            int po = s.length() - i -  1;\\n            if( po <= 30)  {\\n                if(s.charAt(i) == \\'1\\') {\\n                    arr[po] = getPowerof2(po);\\n                    sumOfLast30 += getPowerof2(po);\\n                }\\n\\n            } else {\\n                if(s.charAt(i) == \\'1\\') {\\n                    deletedChar++;\\n                }\\n            }\\n        }\\n        \\n        int inx = arr.length-1;\\n        \\n        while(k < sumOfLast30 && inx >= 0) {\\n            \\n            if(arr[inx] != 0) {\\n                sumOfLast30 -= arr[inx];\\n                deletedChar++;\\n            }\\n            \\n            \\n            inx--;\\n        }\\n        \\n        \\n        return  s.length() - deletedChar ;\\n    }\\n    \\n    private int getPowerof2(int n) {\\n        int x = 1;\\n        x = x << n;\\n        return x ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int[] arr = new int[32];\\n        int deletedChar = 0;\\n        int sumOfLast30 = 0 ;\\n\\n        \\n        for(int i = 0 ; i < s.length() ; i++) {\\n            int po = s.length() - i -  1;\\n            if( po <= 30)  {\\n                if(s.charAt(i) == \\'1\\') {\\n                    arr[po] = getPowerof2(po);\\n                    sumOfLast30 += getPowerof2(po);\\n                }\\n\\n            } else {\\n                if(s.charAt(i) == \\'1\\') {\\n                    deletedChar++;\\n                }\\n            }\\n        }\\n        \\n        int inx = arr.length-1;\\n        \\n        while(k < sumOfLast30 && inx >= 0) {\\n            \\n            if(arr[inx] != 0) {\\n                sumOfLast30 -= arr[inx];\\n                deletedChar++;\\n            }\\n            \\n            \\n            inx--;\\n        }\\n        \\n        \\n        return  s.length() - deletedChar ;\\n    }\\n    \\n    private int getPowerof2(int n) {\\n        int x = 1;\\n        x = x << n;\\n        return x ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062055,
                "title": "java-fastest-solution",
                "content": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        long check = 0;\\n        long temp = 1;\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            if(s.charAt(i) == \\'1\\' && check + temp <= k && ans <= 40){\\n                ans++;\\n                check += temp;\\n                temp *= 2;\\n            }else if(s.charAt(i) == \\'0\\'){\\n                ans++;\\n                temp *= 2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Please UpVote, if found useful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        long check = 0;\\n        long temp = 1;\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            if(s.charAt(i) == \\'1\\' && check + temp <= k && ans <= 40){\\n                ans++;\\n                check += temp;\\n                temp *= 2;\\n            }else if(s.charAt(i) == \\'0\\'){\\n                ans++;\\n                temp *= 2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062047,
                "title": "java-o-n-2-solution",
                "content": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int n = s.length();\\n        long temp = 1;\\n        long check = 0;\\n        int ans = 0;\\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            int len = 0;\\n            check = 0;\\n            temp = 1;\\n            for(int j = i ; j >= 0 ; j--){\\n                if(s.charAt(j) == \\'1\\' && (check + temp) <= k && temp <= k && len <= 40){\\n                    check += temp;\\n                    temp *= 2;\\n                    len++;\\n                }else if(s.charAt(j) == \\'0\\'){\\n                    temp *= 2;\\n                    len++;\\n                }\\n                ans = Math.max(ans , len);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n}\\n```\\n**Please UpVote, if found useful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int n = s.length();\\n        long temp = 1;\\n        long check = 0;\\n        int ans = 0;\\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            int len = 0;\\n            check = 0;\\n            temp = 1;\\n            for(int j = i ; j >= 0 ; j--){\\n                if(s.charAt(j) == \\'1\\' && (check + temp) <= k && temp <= k && len <= 40){\\n                    check += temp;\\n                    temp *= 2;\\n                    len++;\\n                }else if(s.charAt(j) == \\'0\\'){\\n                    temp *= 2;\\n                    len++;\\n                }\\n                ans = Math.max(ans , len);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009706,
                "title": "simple-c-solution",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n      \\n        int n=s.size();\\n        int mask=0,ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            \\n            if(s[i]==\\'1\\'){//take 1 as possible as utill sum gets exeed to k .....when sum >k no further 1 will be taken only 0 will be taken further.\\n                int l=ans;\\n                if(l>30) continue;\\n                int currno=(1<<l);\\n                if(k>=mask+currno)mask|=(1<<l),ans++;//increasing the bits of mask;\\n            }else ans++;\\n        }return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n      \\n        int n=s.size();\\n        int mask=0,ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            \\n            if(s[i]==\\'1\\'){//take 1 as possible as utill sum gets exeed to k .....when sum >k no further 1 will be taken only 0 will be taken further.\\n                int l=ans;\\n                if(l>30) continue;\\n                int currno=(1<<l);\\n                if(k>=mask+currno)mask|=(1<<l),ans++;//increasing the bits of mask;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3971824,
                "title": "golang-100-solution",
                "content": "# Code\\n```go\\nfunc longestSubsequence(s string, k int) int {\\n\\tcurShift := 0\\n\\tcurValue := 0\\n\\tcurSize := 0\\n\\tfor i := len(s)-1; i >= 0; i-- {\\n\\t\\tif s[i] == \\'0\\' {\\n\\t\\t\\tcurSize++\\n\\t\\t\\tcurShift++\\n\\t\\t} else {\\n\\t\\t\\tif curShift > 30 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tvalue := 1<<curShift\\n\\t\\t\\tif curValue + value <= k {\\n\\t\\t\\t\\tcurSize++\\n\\t\\t\\t\\tcurShift++\\n\\t\\t\\t\\tcurValue += value\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn curSize\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc longestSubsequence(s string, k int) int {\\n\\tcurShift := 0\\n\\tcurValue := 0\\n\\tcurSize := 0\\n\\tfor i := len(s)-1; i >= 0; i-- {\\n\\t\\tif s[i] == \\'0\\' {\\n\\t\\t\\tcurSize++\\n\\t\\t\\tcurShift++\\n\\t\\t} else {\\n\\t\\t\\tif curShift > 30 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tvalue := 1<<curShift\\n\\t\\t\\tif curValue + value <= k {\\n\\t\\t\\t\\tcurSize++\\n\\t\\t\\t\\tcurShift++\\n\\t\\t\\t\\tcurValue += value\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn curSize\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895017,
                "title": "recursion-greedy",
                "content": "\\n\\n# Recursion Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(string& s, int k, int idx, int len, long long score) {\\n        \\n        if(idx < 0) return 0;\\n        if(len >= 31) return 0;\\n\\n\\n        int include =  0;\\n\\n        if(s[idx] == \\'1\\') {\\n            long long curr_score = score + pow(2, len);\\n            if(curr_score <= k) {\\n                include = 1 + f(s, k, idx - 1, len + 1, curr_score);\\n            }\\n        } else {\\n            include = 1 + f(s, k, idx - 1, len + 1, score);\\n        }\\n\\n\\n        int not_include = f(s, k, idx - 1, len, score);\\n\\n\\n        return max(include, not_include);\\n\\n    }\\n\\n    int longestSubsequence(string s, int k) {\\n        \\n        int n = s.size();\\n        return f(s, k, n - 1, 0, 0);      \\n\\n    }\\n};\\n\\n\\n\\n\\n\\n```\\n\\n# Greedy Code\\n\\nwe are going to iterate from the last if at any point we find zero then we are going to take this and we don\\'t have to update the score for zero because they are not contributing in the overall answer. but if we have one then it is going to contribute so we have to consider it.\\n```\\n\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        int n = s.size();\\n\\n        int count = 0;\\n        long long score = 0;\\n\\n        for(int i = n - 1; i >= 0; i--) {\\n            if(s[i] == \\'0\\') {\\n                count++;\\n            } else {\\n                long long curr_score = INT_MAX;\\n                if(count <= 30) {\\n                    curr_score = score + pow(2, count);\\n                } \\n                if(curr_score <= k) {\\n                    count++;\\n                    score = curr_score;\\n                }\\n            }\\n        }\\n\\n\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(string& s, int k, int idx, int len, long long score) {\\n        \\n        if(idx < 0) return 0;\\n        if(len >= 31) return 0;\\n\\n\\n        int include =  0;\\n\\n        if(s[idx] == \\'1\\') {\\n            long long curr_score = score + pow(2, len);\\n            if(curr_score <= k) {\\n                include = 1 + f(s, k, idx - 1, len + 1, curr_score);\\n            }\\n        } else {\\n            include = 1 + f(s, k, idx - 1, len + 1, score);\\n        }\\n\\n\\n        int not_include = f(s, k, idx - 1, len, score);\\n\\n\\n        return max(include, not_include);\\n\\n    }\\n\\n    int longestSubsequence(string s, int k) {\\n        \\n        int n = s.size();\\n        return f(s, k, n - 1, 0, 0);      \\n\\n    }\\n};\\n\\n\\n\\n\\n\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        int n = s.size();\\n\\n        int count = 0;\\n        long long score = 0;\\n\\n        for(int i = n - 1; i >= 0; i--) {\\n            if(s[i] == \\'0\\') {\\n                count++;\\n            } else {\\n                long long curr_score = INT_MAX;\\n                if(count <= 30) {\\n                    curr_score = score + pow(2, count);\\n                } \\n                if(curr_score <= k) {\\n                    count++;\\n                    score = curr_score;\\n                }\\n            }\\n        }\\n\\n\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738833,
                "title": "c-simple-solution-0ms-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n    // 1001010\\n    // 00122334\\n    int longestSubsequence(string s, int k) {\\n      int ans = 0, n = s.size(), zero = 0, value = 0, c = 0;\\n      vector<int> prefix(n, 0);\\n      for (int i = 0; i < n; i++) {\\n       prefix[i] = zero;\\n        if (s[i] == \\'0\\')\\n          zero++;\\n      }\\n      ans = zero;\\n      for (int i = 0; i < n; i++) {\\n        if (s[i] == \\'1\\' && (zero-prefix[i]) <= 30) {\\n          // add one bit to value\\n          value = (value<<1) + (1<<(zero-prefix[i]));\\n          if (value <= k) {\\n            c++;\\n            ans = max(ans, zero+c);\\n            continue;\\n          }\\n          // clear most significant bit, replace it with current bit 1\\n          int j = sizeof(int)*8-1;\\n          for (; j >= 0 && !(value&(1<<j)); j--);\\n          value &= (1<<j)-1;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    // 1001010\\n    // 00122334\\n    int longestSubsequence(string s, int k) {\\n      int ans = 0, n = s.size(), zero = 0, value = 0, c = 0;\\n      vector<int> prefix(n, 0);\\n      for (int i = 0; i < n; i++) {\\n       prefix[i] = zero;\\n        if (s[i] == \\'0\\')\\n          zero++;\\n      }\\n      ans = zero;\\n      for (int i = 0; i < n; i++) {\\n        if (s[i] == \\'1\\' && (zero-prefix[i]) <= 30) {\\n          // add one bit to value\\n          value = (value<<1) + (1<<(zero-prefix[i]));\\n          if (value <= k) {\\n            c++;\\n            ans = max(ans, zero+c);\\n            continue;\\n          }\\n          // clear most significant bit, replace it with current bit 1\\n          int j = sizeof(int)*8-1;\\n          for (; j >= 0 && !(value&(1<<j)); j--);\\n          value &= (1<<j)-1;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688805,
                "title": "c-python-solution-with-explanation",
                "content": "First, calculate how many bits ```k``` has = n,\\nuse last n number to construct a number <= k, if last n number > k, use last n- 1 number.\\nand remove all of 1 before the number.\\ntc is O(n), sc is O(1)\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int size = s.size();\\n        int n = 0, c = k;\\n        while (c) {\\n            n += 1;\\n            c >>= 1;\\n        }\\n        if (n > size) return size;\\n        int cnt = stoi(s.substr(size - n), nullptr, 2) <= k ? n: n-1;\\n        return cnt + count(s.begin(), s.end() - n, \\'0\\');\\n    }\\n};\\n```\\n### python\\n```python\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        size, n = len(s), k.bit_length()\\n        if n > size: return size\\n        cnt = n if int(s[-n:], 2) <= k else n-1\\n        return cnt + s[:-n].count(\\'0\\')\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```k```\n```cpp\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int size = s.size();\\n        int n = 0, c = k;\\n        while (c) {\\n            n += 1;\\n            c >>= 1;\\n        }\\n        if (n > size) return size;\\n        int cnt = stoi(s.substr(size - n), nullptr, 2) <= k ? n: n-1;\\n        return cnt + count(s.begin(), s.end() - n, \\'0\\');\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        size, n = len(s), k.bit_length()\\n        if n > size: return size\\n        cnt = n if int(s[-n:], 2) <= k else n-1\\n        return cnt + s[:-n].count(\\'0\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648832,
                "title": "python-easy-solution-o-n",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        res = 0\\n        cur = \\'\\'\\n        for i in s[::-1]:\\n            if int(i + cur, 2) <= k:\\n                cur = i + cur\\n                res = max(res, len(cur))\\n            else:\\n                if int(i + cur[:-1], 2) < int(cur, 2):\\n                    cur = i + cur[:-1]\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        res = 0\\n        cur = \\'\\'\\n        for i in s[::-1]:\\n            if int(i + cur, 2) <= k:\\n                cur = i + cur\\n                res = max(res, len(cur))\\n            else:\\n                if int(i + cur[:-1], 2) < int(cur, 2):\\n                    cur = i + cur[:-1]\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609281,
                "title": "solution-for-bignnrs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst count number of zeros in the array than count number of ones we can take from right with value less than k.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int z=0;\\n        //count zero\\n        for(int i=0;i<s.length();i++)if(s.charAt(i)==\\'0\\')z++;\\n\\n        int num=0,base=1,len=0;\\n\\t\\t//take as many ones from right as possible until they do not make the num>k\\n        for(int i=s.length()-1;i>=0;i--){\\n            \\n            if(num+base>k)break;\\n            if(s.charAt(i)==\\'1\\'){\\n               num+=base;\\n            }\\n            else {\\n\\t\\t\\t//remove already taken zeros from zeros count\\n                z--;\\n            }\\n            base*=2;\\n            len++;\\n        }\\n        \\n        return len+z;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int z=0;\\n        //count zero\\n        for(int i=0;i<s.length();i++)if(s.charAt(i)==\\'0\\')z++;\\n\\n        int num=0,base=1,len=0;\\n\\t\\t//take as many ones from right as possible until they do not make the num>k\\n        for(int i=s.length()-1;i>=0;i--){\\n            \\n            if(num+base>k)break;\\n            if(s.charAt(i)==\\'1\\'){\\n               num+=base;\\n            }\\n            else {\\n\\t\\t\\t//remove already taken zeros from zeros count\\n                z--;\\n            }\\n            base*=2;\\n            len++;\\n        }\\n        \\n        return len+z;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575853,
                "title": "python-greedy",
                "content": "# Intuition\\n\\nin order to reduce value of `binary_value(s)`, the best way we can do is to remove most significant bit (MSB) greedily\\n\\nthus, we just remove MSB until `binary(s[i:]) <= k`.\\n\\nsince leading zeros are valid, only check if `s[i] == 1`:\\n\\n- if `len(s[i:]) > len(binary_string(k))`, `s[i:]` must be greater than k\\n    - `delete_msb += 1`\\n- if `len(s[i:]) == len(binary_string(k))`, check`int(s[i:])` `>=` or `<` `int(binary_string(k))`\\n    - `if int(s[i:]) <= int(binary_string(k))`, found answer\\n    - else we should remove this MSB. `delete_msb += 1`\\n- if `len(s[i:]) < len(binary_string(k))`, binary(s[i:]) msut less than k:\\n    - found answer\\n\\n**final answer = len(s) - deleted_ones**\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        binK = bin(k)[2:]\\n        currLen = n = len(s)\\n        for i in range(n):\\n            if s[i] == \"1\":\\n                if n-i > len(binK) or (n-i == len(binK) and int(s[i:]) > int(binK)):\\n                    currLen -= 1\\n                else:\\n                    return currLen\\n\\n        return currLen\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        binK = bin(k)[2:]\\n        currLen = n = len(s)\\n        for i in range(n):\\n            if s[i] == \"1\":\\n                if n-i > len(binK) or (n-i == len(binK) and int(s[i:]) > int(binK)):\\n                    currLen -= 1\\n                else:\\n                    return currLen\\n\\n        return currLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447849,
                "title": "o-n-single-pass",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int num = 0;\\n        int ans = 0;\\n        for(int i=s.length()-1;i>=0;i--) {\\n            char ch = s.charAt(i);\\n            if(ch==\\'0\\')\\n            ans++;\\n            else {\\n                if(ans>=31)\\n                continue;\\n                int val = (int)(Math.pow(2,ans));\\n                if(num+val<=k) {\\n                    ans++;\\n                    num += val;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int num = 0;\\n        int ans = 0;\\n        for(int i=s.length()-1;i>=0;i--) {\\n            char ch = s.charAt(i);\\n            if(ch==\\'0\\')\\n            ans++;\\n            else {\\n                if(ans>=31)\\n                continue;\\n                int val = (int)(Math.pow(2,ans));\\n                if(num+val<=k) {\\n                    ans++;\\n                    num += val;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442419,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        string t ;\\n        \\n        while(k){\\n            t.push_back(k%2 + \\'0\\') ;\\n            k /= 2 ;\\n        }        \\n        reverse(t.begin(), t.end()) ;\\n        int n = s.size() ;\\n        if(n < t.size())\\n            return n ;\\n      \\n        int countZero = 0 ;\\n        for(int i = 0; i < n-t.size(); i++)\\n            if(s[i] == \\'0\\')\\n                countZero++ ;\\n        int ret = t.size() - 1 + countZero ;\\n        \\n        if(s.substr(n-t.size()) <= t)\\n            ret = t.size()  + countZero ;\\n            \\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        string t ;\\n        \\n        while(k){\\n            t.push_back(k%2 + \\'0\\') ;\\n            k /= 2 ;\\n        }        \\n        reverse(t.begin(), t.end()) ;\\n        int n = s.size() ;\\n        if(n < t.size())\\n            return n ;\\n      \\n        int countZero = 0 ;\\n        for(int i = 0; i < n-t.size(); i++)\\n            if(s[i] == \\'0\\')\\n                countZero++ ;\\n        int ret = t.size() - 1 + countZero ;\\n        \\n        if(s.substr(n-t.size()) <= t)\\n            ret = t.size()  + countZero ;\\n            \\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440152,
                "title": "2311-longest-binary-subsequence-less-than-or-equal-to-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestSubsequence(string inputStr, int k) {\\n            int countZero = 0;\\n            int countOne = 0;\\n            BigInteger Sum = 0;\\n\\n            foreach (char C in inputStr)\\n            {\\n                if (C == \\'0\\')\\n                    countZero++;\\n            }\\n\\n            for (int i = inputStr.Length - 1; i >= 0; i--)\\n            {\\n                if (inputStr[i] == \\'1\\')\\n                {\\n                    long pow = inputStr.Length - 1 - i;\\n                    Sum = Sum + (BigInteger)Math.Pow(2, pow);\\n                    if (Sum <= k)\\n                        countOne++;\\n                    if (Sum > k)\\n                        break;\\n                }\\n            }\\n\\n            return countZero + countOne;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestSubsequence(string inputStr, int k) {\\n            int countZero = 0;\\n            int countOne = 0;\\n            BigInteger Sum = 0;\\n\\n            foreach (char C in inputStr)\\n            {\\n                if (C == \\'0\\')\\n                    countZero++;\\n            }\\n\\n            for (int i = inputStr.Length - 1; i >= 0; i--)\\n            {\\n                if (inputStr[i] == \\'1\\')\\n                {\\n                    long pow = inputStr.Length - 1 - i;\\n                    Sum = Sum + (BigInteger)Math.Pow(2, pow);\\n                    if (Sum <= k)\\n                        countOne++;\\n                    if (Sum > k)\\n                        break;\\n                }\\n            }\\n\\n            return countZero + countOne;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417784,
                "title": "c-dp-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        reverse(s.begin(),s.end());\\n        int n=s.size();\\n        vector<pair<int,int>> dp(n);\\n        for(int i=0;i<n;i++){\\n            dp[i]={1,s[i]-\\'0\\'};\\n        }\\n        dp[0]={1,s[0]-\\'0\\'};\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                \\n                int len=dp[j].first;\\n                int value=dp[j].second;\\n                if(len+1>dp[i].first && (value+(s[i]-\\'0\\')*pow(2,len))<=k){\\n                    dp[i].first=len+1;\\n                    dp[i].second=value+(s[i]-\\'0\\')*pow(2,len);\\n                }\\n            }\\n        }\\n        int maxi=-1e9;\\n        for(int i=0;i<n;i++){\\n            cout<<dp[i].first<<\" \"<<dp[i].second<<endl;\\n            maxi=max(maxi,dp[i].first);\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        reverse(s.begin(),s.end());\\n        int n=s.size();\\n        vector<pair<int,int>> dp(n);\\n        for(int i=0;i<n;i++){\\n            dp[i]={1,s[i]-\\'0\\'}",
                "codeTag": "Java"
            },
            {
                "id": 3266882,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn longest_subsequence(s: String, k: i32) -> i32 {\\n        let mut res = 0;\\n        let mut cur = 0;\\n        let mut exp = 0;\\n        for c in s.chars().rev() {\\n            if c == \\'1\\' && (exp >= 32 || 2i64.pow(exp) > k as i64 - cur) {\\n                continue;\\n            }  \\n            cur += 2i64.pow(exp) * (c == \\'1\\') as i64;\\n            res += 1;\\n            exp += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_subsequence(s: String, k: i32) -> i32 {\\n        let mut res = 0;\\n        let mut cur = 0;\\n        let mut exp = 0;\\n        for c in s.chars().rev() {\\n            if c == \\'1\\' && (exp >= 32 || 2i64.pow(exp) > k as i64 - cur) {\\n                continue;\\n            }  \\n            cur += 2i64.pow(exp) * (c == \\'1\\') as i64;\\n            res += 1;\\n            exp += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3245456,
                "title": "c-dp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        const int n = s.size();\\n        vector<int> dp(n+1, k+1);  //dp[i] is the smallest sequence with length i\\n        dp[0] = 0;\\n        for(auto c:s) for(int i=n;i>0;i--)\\n            dp[i] = min(dp[i], dp[i-1] * 2 + (c-\\'0\\'));\\n        for(int i=n;i>0;i--)\\n            if(dp[i] <= k) return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        const int n = s.size();\\n        vector<int> dp(n+1, k+1);  //dp[i] is the smallest sequence with length i\\n        dp[0] = 0;\\n        for(auto c:s) for(int i=n;i>0;i--)\\n            dp[i] = min(dp[i], dp[i-1] * 2 + (c-\\'0\\'));\\n        for(int i=n;i>0;i--)\\n            if(dp[i] <= k) return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223443,
                "title": "c-o-n-iterate-from-back",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        long cur = 1, sum = 0, ans = 0;\\n        for (int i = s.size() - 1; i > -1; --i){\\n            if (s[i] == \\'1\\'){\\n                if (sum + cur <= k){\\n                    sum += cur;\\n                    ++ans;\\n                    if (cur <= k) cur *= 2;\\n                }\\n            }\\n            else{\\n                if (cur <= k) cur *= 2;\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        long cur = 1, sum = 0, ans = 0;\\n        for (int i = s.size() - 1; i > -1; --i){\\n            if (s[i] == \\'1\\'){\\n                if (sum + cur <= k){\\n                    sum += cur;\\n                    ++ans;\\n                    if (cur <= k) cur *= 2;\\n                }\\n            }\\n            else{\\n                if (cur <= k) cur *= 2;\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209118,
                "title": "o-n-o-1-with-super-detailed-explanation",
                "content": "A lot of posts don\\'t tell you why, no worry, I\\'ll let you know.\\n\\nThe key here is, **all zeros are needed.** \\nBut why? \\n\\nLet\\'s assume the best solution does not include all \"0\"s, in other words, at least one \"0\" is not included.\\n\\nThere\\'ll be 2 cases under this assumption:\\n- case1: the not used \"0\" is to the left of the left most \"1\" -> add this \"0\" does not increase the value, so we must add it for longer solution.\\n- case2: the not used \"0\" is to the right of the left most \"1\" -> we can alwasy add this \"0\" and delete a \"1\" from that \"0\"\\'s left side.\\n\\nSo now we know, all \"0\"s are needed.\\n\\nNow the answer to the question becomes:\\n - count of all \"0\" + number of \"1\" we used.\\n\\nSo we want to use as many \"1\" as possible to make the subsequence longer.\\n\\nSince we also want to make the value <= k, so the greedy idea is that we only need to add \"1\" from right to left until <= k.\\n\\nBut you may ask **why from right to left?**\\n\\nBecause if from left to right, when we meet a \"1\", you don\\'t know whether this \"1\" is needed or not, so you can not take the risk of not adding this \"1\". But, after several iterations, if a new \"1\" is coming, and after adding this \"1\", the value > k, then we need to remove the left most \"1\"(to make the value as small as possible by only removing single digit). So we need to know where this \"1\" is, which means we need extra space.\\n\\nBy contrast, from right to left, if meet \"1\", we can easily decide whether add this \"1\" or not. If we can still add this \"1\", then value += base\\n\\nAlgorithm: from right to left, \\n- case1: base > k, stop adding \"1\" and only add \"0\" (avoid base overflow)\\n- case2: current char is \"0\", totalZero++\\n- case3: current char is \"1\", if remaining value k >= base, usedOne++, update k.\\n     \\nExample:                         \\n                             \\n         s                 1 0 0 1 0 1 0         k=5\\n         totalZero         4 4 3 2 2 1 1\\n         usedOne           2 2 2 2 1 1 0\\n         k                 0 0 0 0 3 3 5\\n         base              4 4 4 4 4 2 1\\n        \\nThe result = totalZero + usedOne\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int totalZero = 0;\\n        int usedOne = 0;\\n        int base = 1;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (base > k) {\\n                if (s.charAt(i) == \\'0\\') {\\n                    totalZero++;\\n                }\\n                continue;\\n            }\\n            if (s.charAt(i) == \\'0\\') {\\n                totalZero++;\\n                base *= 2;\\n            } else {\\n                // == \\'1\\'\\n                if (k >= base) {\\n                    k -= base;\\n                    usedOne++;\\n                    base *= 2;\\n                }\\n            }\\n        }\\n        return totalZero + usedOne;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int totalZero = 0;\\n        int usedOne = 0;\\n        int base = 1;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (base > k) {\\n                if (s.charAt(i) == \\'0\\') {\\n                    totalZero++;\\n                }\\n                continue;\\n            }\\n            if (s.charAt(i) == \\'0\\') {\\n                totalZero++;\\n                base *= 2;\\n            } else {\\n                // == \\'1\\'\\n                if (k >= base) {\\n                    k -= base;\\n                    usedOne++;\\n                    base *= 2;\\n                }\\n            }\\n        }\\n        return totalZero + usedOne;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205657,
                "title": "c-greedy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        reverse(s.begin(), s.end());\\n        int i, len = log2(k) + 1, ans = 0, val = 0;\\n        for(i = 0; i < len && i < s.length(); i++) {\\n            val = ((s[i] - \\'0\\') << i) + val;\\n            ans++;\\n        }\\n        if(val > k) ans--;\\n        for(int i = len; i < s.length(); i++) {\\n            if(s[i] == \\'0\\')\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        reverse(s.begin(), s.end());\\n        int i, len = log2(k) + 1, ans = 0, val = 0;\\n        for(i = 0; i < len && i < s.length(); i++) {\\n            val = ((s[i] - \\'0\\') << i) + val;\\n            ans++;\\n        }\\n        if(val > k) ans--;\\n        for(int i = len; i < s.length(); i++) {\\n            if(s[i] == \\'0\\')\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202805,
                "title": "explanation",
                "content": "# Explanation\\n\\nAssume that `k` consists of `N` bits. Obviously, any number consisting of `N - 1` bits will be less than `k`. Assume that we have selected `N - 1` right-most bits of `s`. If we want to add one more bit on the left, there are options:\\n\\n1. We add `1` and the number remains less than or equal to `k`. In this case, all we can do after that is add leading zeros (if we add at least one more `1`, the number will consist of more than `N` bits and thus will be greater than `k`).\\n2. If we add `1`, the number becomes greater than `k`. In this case, we can only add leading zeros.\\n\\nObviously, the more leading zeros the better, therefore it makes sense to select `N - 1` *right-most* bits first, otherwise we risk loosing some leading zeros (an example can be constructed easily).\\n\\nThis leads us to the following algorithm:\\n\\n1. Select `N - 1` right-most bits of `s`. (If `s` is shorter, just select the whole `s` and that\\'s it).\\n2. Consider selecting the next bit of `s`:\\n    * If the next bit is `1`, check if the number remains less than or equal to `k`. If it does, add the `1` and then add all zeros that are on the left. Otherwise, simply add all zeros that are on the left.\\n    * If the next bit is `0`, simply add all zeros that are on the left. Even if we can add `1` and keep the number less than or equal to `k`, it doesn\\'t matter if we add `1` and then zeros that are on the left or if we add `0` and then the same number of zeros.\\n    \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        auto it = s.rbegin();\\n        int cnt = 0, val = 0, pow = 1;\\n        for (int t = k; it != s.rend() && t; pow <<= 1, ++it) {\\n            ++cnt;\\n            t >>= 1;\\n            val += (*it - \\'0\\') * pow;\\n        }\\n        return (cnt - 1) + (val <= k) + count(s.rbegin() + cnt, s.rend(), \\'0\\' );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        auto it = s.rbegin();\\n        int cnt = 0, val = 0, pow = 1;\\n        for (int t = k; it != s.rend() && t; pow <<= 1, ++it) {\\n            ++cnt;\\n            t >>= 1;\\n            val += (*it - \\'0\\') * pow;\\n        }\\n        return (cnt - 1) + (val <= k) + count(s.rbegin() + cnt, s.rend(), \\'0\\' );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153540,
                "title": "simple-python-o-n-greedy-method",
                "content": "# Intuition\\nfrom right to the left, if \\'0\\' we add it, if it is \\'1\\', we see if it is larger than k, if not we let the k minus it. if it is, we continue\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n$O(1)$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        res = 0\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'0\\':\\n                res+=1\\n            else:\\n                if k-2**(len(s)-i-1)>=0:\\n                    res+=1\\n                    k-=2**(len(s)-i-1)\\n                else:\\n                    continue\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        res = 0\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'0\\':\\n                res+=1\\n            else:\\n                if k-2**(len(s)-i-1)>=0:\\n                    res+=1\\n                    k-=2**(len(s)-i-1)\\n                else:\\n                    continue\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145396,
                "title": "best-simple-solution-explained",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n    int val = 0, cnt = 0, pow = 1;\\n    for (int i = s.size() - 1; i >= 0 && val + pow <= k; --i) {\\n        if (s[i] == \\'1\\') {\\n            ++cnt;\\n            val += pow;\\n        }\\n        pow <<= 1;\\n    }\\n    return count(begin(s), end(s), \\'0\\') + cnt;\\n}\\n};\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bash",
                    "Swift",
                    "Go",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n    int val = 0, cnt = 0, pow = 1;\\n    for (int i = s.size() - 1; i >= 0 && val + pow <= k; --i) {\\n        if (s[i] == \\'1\\') {\\n            ++cnt;\\n            val += pow;\\n        }\\n        pow <<= 1;\\n    }\\n    return count(begin(s), end(s), \\'0\\') + cnt;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138973,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int base=0;\\n        int n=s.length();\\n        int val=0,cnt=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\' and val+pow(2,base)<=k)\\n            {\\n                val=val+pow(2,base);\\n                cnt++;\\n            }\\n            else if(s[i]==\\'0\\')\\n            cnt++;\\n            base++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int base=0;\\n        int n=s.length();\\n        int val=0,cnt=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\' and val+pow(2,base)<=k)\\n            {\\n                val=val+pow(2,base);\\n                cnt++;\\n            }\\n            else if(s[i]==\\'0\\')\\n            cnt++;\\n            base++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122234,
                "title": "go-o-n-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nfunc longestSubsequence(s string, k int) int {\\n    l := 0\\n    sum := 0.0\\n    reachedK := false\\n\\n    for i := len(s) - 1; i >= 0; i--{\\n        if rune(s[i]) == \\'0\\'{\\n            l++\\n        } else if !reachedK {\\n            sum += math.Pow(float64(2), float64(l))\\n            if sum > float64(k) {\\n                reachedK = true\\n            } else {\\n                l++\\n            }\\n        }\\n    }\\n\\n    return l\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\nfunc longestSubsequence(s string, k int) int {\\n    l := 0\\n    sum := 0.0\\n    reachedK := false\\n\\n    for i := len(s) - 1; i >= 0; i--{\\n        if rune(s[i]) == \\'0\\'{\\n            l++\\n        } else if !reachedK {\\n            sum += math.Pow(float64(2), float64(l))\\n            if sum > float64(k) {\\n                reachedK = true\\n            } else {\\n                l++\\n            }\\n        }\\n    }\\n\\n    return l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3108651,
                "title": "python3-greedy-removal",
                "content": "# Intuition\\nalways greedily remove the first apperance of the \\'1\\' bit until the coonditions are satisfied\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\nthe algorithm takes a lot of memory because of the slicing operation in each iteration\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        arr = []\\n        for idx, c in enumerate(s):\\n            if c == \\'1\\':\\n                arr += [idx]\\n        cnt = 0\\n        while arr and int(s, 2) > k:\\n            idx = arr.pop(0) - cnt\\n            s = s[:idx] + s[idx+1:]\\n            cnt += 1\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        arr = []\\n        for idx, c in enumerate(s):\\n            if c == \\'1\\':\\n                arr += [idx]\\n        cnt = 0\\n        while arr and int(s, 2) > k:\\n            idx = arr.pop(0) - cnt\\n            s = s[:idx] + s[idx+1:]\\n            cnt += 1\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090432,
                "title": "easy-greedy-5-lines-cpp-stoi-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        int len = floor((float)log2(k))+1;\\n\\n        if(s.length()<len) return s.length();\\n\\n        string str = s.substr(s.length()-len);\\n       \\n        long long num = stoi(str,nullptr,2);\\n\\n        return count(s.begin() , s.begin()+s.length()-len ,\\'0\\') + len - (num>k);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        \\n        int len = floor((float)log2(k))+1;\\n\\n        if(s.length()<len) return s.length();\\n\\n        string str = s.substr(s.length()-len);\\n       \\n        long long num = stoi(str,nullptr,2);\\n\\n        return count(s.begin() , s.begin()+s.length()-len ,\\'0\\') + len - (num>k);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081305,
                "title": "python-one-pass-deque-o-n",
                "content": "# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        leadingZeros = 0\\n        que = deque()\\n        for c in s:\\n            que.append(c)\\n            while que and que[0] == \\'0\\':\\n                leadingZeros += 1\\n                que.popleft()\\n            if que and int(\"\".join(que), 2) > k:\\n                que.popleft()\\n        return leadingZeros + len(que)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        leadingZeros = 0\\n        que = deque()\\n        for c in s:\\n            que.append(c)\\n            while que and que[0] == \\'0\\':\\n                leadingZeros += 1\\n                que.popleft()\\n            if que and int(\"\".join(que), 2) > k:\\n                que.popleft()\\n        return leadingZeros + len(que)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061090,
                "title": "o-n-o-n-2-o-n-3",
                "content": "This problem was very deceptive.\\n\\n- Time complexity: $$O(n)$$  Accepted (Optimal)\\n- Space complexity: $$O(1)$$\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int pow = 1, cnt=0, val=0;\\n\\n        for(int i = s.size()-1; i>-1 && val+pow<=k; i--){\\n            if(s[i] == \\'1\\') val+= pow, cnt++;\\n            pow<<=1;\\n        }\\n        return count(begin(s),end(s),\\'0\\')+cnt;\\n    }        \\n};\\n\\n```\\n\\n- Time complexity: $$O(n^2)$$  Accepted\\n- Space complexity: $$O(n)$$\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        vector<int>dp(s.size(),1);\\n        vector<int>seqLen(s.size(),-1);        \\n        int max_num = 1;\\n                \\n\\n        int p = s.length();\\n        for(int i = p-2; i >-1; i--){\\n            for(int j=i+1; j<s.length(); j++){\\n                if(seqLen[j] == -1) seqLen[j] = s[j]-\\'0\\';\\n                try{                    \\n                    if(dp[i] < (1+dp[j]) &&  ((int(s[i]-\\'0\\') * pow(2,dp[j]))+seqLen[j]) <= k ){\\n                        dp[i] = 1+dp[j];\\n                        seqLen[i] = (int(s[i]-\\'0\\') * pow(2,dp[j]))+seqLen[j];                        \\n                        max_num = max(max_num, dp[i]);                        \\n                    }\\n                }catch(...){}\\n            }\\n        }\\n\\n        return max_num;\\n    }        \\n};\\n```\\n\\n\\n- Time complexity: $$O(n^3)$$  TLE\\n- Space complexity: $$O(n)$$\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        vector<int>dp(s.size(),1);\\n        vector<string>seqLen(s.size(),\"\");\\n        int ans = 0;\\n        int max_num = 1;\\n        string ks=\"\";\\n                \\n            int cpk = k;            \\n            while(cpk!=0){\\n                if(cpk%2) ks = \"1\" + ks;\\n                else ks = \"0\" + ks;\\n                cpk/=2;\\n            }    \\n\\n        // cout<< ks<<\"\\\\n\";\\n        int p = s.length();\\n        for(int i = p-2; i >-1; i--){\\n            for(int j=i+1; j<s.length(); j++){\\n                if(seqLen[j] == \"\") seqLen[j] = s[j];\\n                if(dp[i] < (1+dp[j]) &&  isValid(i, j , ks, seqLen, s) ){\\n                    dp[i] = 1+dp[j];\\n                    seqLen[i] = s[i]+seqLen[j];\\n                    max_num = max(max_num, (int)seqLen[i].length());\\n                }\\n            }\\n        }\\n\\n        return max_num;\\n    }\\n\\n    bool isValid(int i, int j, string ks, vector<string>& seqLen, string s){\\n        string temp = s[i]+seqLen[j];\\n        if(temp.length() < ks.length()) return true;\\n\\n        if(temp.length() == ks.length()){\\n            for(int i=0; i< temp.length(); i++){\\n                if(ks[i] == \\'1\\' && temp[i] == \\'0\\') break;\\n                if(ks[i] == \\'0\\' && temp[i] == \\'1\\') return false;\\n            }\\n            return true;\\n        }else{\\n            int d = temp.length();\\n            d -= ks.length();\\n\\n            for(int i=0; i < temp.length(); i++){\\n                if(i<d){\\n                    if(temp[i] != \\'0\\') return false;\\n                }else{\\n                    if(ks[i-d] == \\'1\\' && temp[i] == \\'0\\') break;\\n                    if(ks[i-d] == \\'0\\' && temp[i] == \\'1\\') return false;\\n                }\\n            }\\n\\n            return true;\\n        }\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int pow = 1, cnt=0, val=0;\\n\\n        for(int i = s.size()-1; i>-1 && val+pow<=k; i--){\\n            if(s[i] == \\'1\\') val+= pow, cnt++;\\n            pow<<=1;\\n        }\\n        return count(begin(s),end(s),\\'0\\')+cnt;\\n    }        \\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        vector<int>dp(s.size(),1);\\n        vector<int>seqLen(s.size(),-1);        \\n        int max_num = 1;\\n                \\n\\n        int p = s.length();\\n        for(int i = p-2; i >-1; i--){\\n            for(int j=i+1; j<s.length(); j++){\\n                if(seqLen[j] == -1) seqLen[j] = s[j]-\\'0\\';\\n                try{                    \\n                    if(dp[i] < (1+dp[j]) &&  ((int(s[i]-\\'0\\') * pow(2,dp[j]))+seqLen[j]) <= k ){\\n                        dp[i] = 1+dp[j];\\n                        seqLen[i] = (int(s[i]-\\'0\\') * pow(2,dp[j]))+seqLen[j];                        \\n                        max_num = max(max_num, dp[i]);                        \\n                    }\\n                }catch(...){}\\n            }\\n        }\\n\\n        return max_num;\\n    }        \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        vector<int>dp(s.size(),1);\\n        vector<string>seqLen(s.size(),\"\");\\n        int ans = 0;\\n        int max_num = 1;\\n        string ks=\"\";\\n                \\n            int cpk = k;            \\n            while(cpk!=0){\\n                if(cpk%2) ks = \"1\" + ks;\\n                else ks = \"0\" + ks;\\n                cpk/=2;\\n            }    \\n\\n        // cout<< ks<<\"\\\\n\";\\n        int p = s.length();\\n        for(int i = p-2; i >-1; i--){\\n            for(int j=i+1; j<s.length(); j++){\\n                if(seqLen[j] == \"\") seqLen[j] = s[j];\\n                if(dp[i] < (1+dp[j]) &&  isValid(i, j , ks, seqLen, s) ){\\n                    dp[i] = 1+dp[j];\\n                    seqLen[i] = s[i]+seqLen[j];\\n                    max_num = max(max_num, (int)seqLen[i].length());\\n                }\\n            }\\n        }\\n\\n        return max_num;\\n    }\\n\\n    bool isValid(int i, int j, string ks, vector<string>& seqLen, string s){\\n        string temp = s[i]+seqLen[j];\\n        if(temp.length() < ks.length()) return true;\\n\\n        if(temp.length() == ks.length()){\\n            for(int i=0; i< temp.length(); i++){\\n                if(ks[i] == \\'1\\' && temp[i] == \\'0\\') break;\\n                if(ks[i] == \\'0\\' && temp[i] == \\'1\\') return false;\\n            }\\n            return true;\\n        }else{\\n            int d = temp.length();\\n            d -= ks.length();\\n\\n            for(int i=0; i < temp.length(); i++){\\n                if(i<d){\\n                    if(temp[i] != \\'0\\') return false;\\n                }else{\\n                    if(ks[i-d] == \\'1\\' && temp[i] == \\'0\\') break;\\n                    if(ks[i-d] == \\'0\\' && temp[i] == \\'1\\') return false;\\n                }\\n            }\\n\\n            return true;\\n        }\\n    }\\n\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3059273,
                "title": "c-inspiration-from-longest-increasing-subsequence-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int n = s.size();\\n        int dp[n + 1]; // dp[i] = min value for length i\\n        dp[0] = 0; // val = 0 for length 0\\n        int len = 0;\\n        for(int i = 0; i < n; i++) {\\n            int bit = s[i] - \\'0\\'; // trying to include this bit with other formations\\n            if(dp[len] * 2 + bit <= k) {\\n                dp[len + 1] = dp[len] * 2 + bit;\\n                len++;\\n            }\\n            // update dp at previous indexes j using current bit\\n            for(int j = len; j > 0; j--) {\\n                dp[j] = min(dp[j], dp[j - 1] * 2 + bit);\\n            } \\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int n = s.size();\\n        int dp[n + 1]; // dp[i] = min value for length i\\n        dp[0] = 0; // val = 0 for length 0\\n        int len = 0;\\n        for(int i = 0; i < n; i++) {\\n            int bit = s[i] - \\'0\\'; // trying to include this bit with other formations\\n            if(dp[len] * 2 + bit <= k) {\\n                dp[len + 1] = dp[len] * 2 + bit;\\n                len++;\\n            }\\n            // update dp at previous indexes j using current bit\\n            for(int j = len; j > 0; j--) {\\n                dp[j] = min(dp[j], dp[j - 1] * 2 + bit);\\n            } \\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001358,
                "title": "100-beats-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int ans=0;\\n        long long int num = 0;\\n        long long int position = 1;\\n        int index = s.length()-1;\\n        while(index>=0)\\n        {\\n            if(s[index]==\\'0\\')\\n            {\\n                ans++;\\n            }\\n            else\\n            {\\n                if(num+position<=k)\\n                {\\n                    ans++;\\n                    num+=position;\\n                }\\n            }\\n            index--;\\n            position*=2;\\n            if(position>k)\\n            {\\n                break;\\n            }\\n        }\\n        while(index>=0)\\n        {\\n            if(s[index]==\\'0\\')\\n            {\\n                ans++;\\n            }\\n            index--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int ans=0;\\n        long long int num = 0;\\n        long long int position = 1;\\n        int index = s.length()-1;\\n        while(index>=0)\\n        {\\n            if(s[index]==\\'0\\')\\n            {\\n                ans++;\\n            }\\n            else\\n            {\\n                if(num+position<=k)\\n                {\\n                    ans++;\\n                    num+=position;\\n                }\\n            }\\n            index--;\\n            position*=2;\\n            if(position>k)\\n            {\\n                break;\\n            }\\n        }\\n        while(index>=0)\\n        {\\n            if(s[index]==\\'0\\')\\n            {\\n                ans++;\\n            }\\n            index--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970817,
                "title": "java-solution-linear-time-complexity",
                "content": "# Intuition if this solution was helpful like+=count; \\uD83D\\uDE1C\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- this problem makes a deception \\n- we greedly take all 0s from the string  and try to take as many 1s as possible,we take the 1s from rightmost side as this makes  the value smaller than or equal to k.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n       int i,n=s.length();\\n       int count=0,cost=1;\\n       for(i=n-1;i>=0;i--)\\n       {\\n           if(s.charAt(i)==\\'0\\' || cost<=k)\\n           {\\n               count++;\\n               if(s.charAt(i)==\\'1\\')\\n               k-=cost;\\n           }\\n           if(cost<=k)\\n           cost=cost<<1;\\n       }\\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n       int i,n=s.length();\\n       int count=0,cost=1;\\n       for(i=n-1;i>=0;i--)\\n       {\\n           if(s.charAt(i)==\\'0\\' || cost<=k)\\n           {\\n               count++;\\n               if(s.charAt(i)==\\'1\\')\\n               k-=cost;\\n           }\\n           if(cost<=k)\\n           cost=cost<<1;\\n       }\\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970138,
                "title": "simple-o-n-python",
                "content": "# Intuition\\nTraverse the reversed string s, if adding new character to the resulting binary string does not exceed k, add it to the res string from left.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        res = \"\"\\n        for char in reversed(s):\\n            if int(char+res,2)<=k:\\n                res = char + res\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        res = \"\"\\n        for char in reversed(s):\\n            if int(char+res,2)<=k:\\n                res = char + res\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893438,
                "title": "python-solution-using-bitwise-operation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet _res_ be the length of _s_, change the most significant \\'1\\' of _s_ to \\'0\\' until it is less than or equal to _K_, and subtract 1 from _res_ each time we do that.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(len(s))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n      res = len(s)\\n      n = int(s, 2)\\n      mask = 1 << len(s) - 1\\n      while n > k and mask > 0:\\n        if n & mask == mask:\\n          n ^= mask\\n          res -= 1\\n        mask >>= 1\\n      return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n      res = len(s)\\n      n = int(s, 2)\\n      mask = 1 << len(s) - 1\\n      while n > k and mask > 0:\\n        if n & mask == mask:\\n          n ^= mask\\n          res -= 1\\n        mask >>= 1\\n      return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829384,
                "title": "rust-solution-using-dynamic-programing",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn longest_subsequence(s: String, k: i32) -> i32 {\\n    let k = k as usize;\\n\\n    let n = s.len();\\n    let s = s.chars().collect::<Vec<char>>();\\n    let inf = 1_000_000_000_000;\\n    let mut memo = vec![inf;n+1];\\n    memo[0] = 0;\\n\\n    for i in 0..n {\\n      let mut new_memo = memo.clone();\\n      if s[i] == \\'1\\' {\\n        for j in 0..=i {\\n          new_memo[j+1] = new_memo[j+1].min(memo[j]*2+1);\\n          if new_memo[j+1] > k {\\n            new_memo[j+1] = k+1;\\n          }\\n        }\\n      } else {\\n        for j in 0..=i {\\n          new_memo[j+1] = new_memo[j+1].min(memo[j]*2);\\n          if new_memo[j+1] > k {\\n            new_memo[j+1] = k+1;\\n          }\\n        }\\n      }\\n      memo = new_memo;\\n    }\\n\\n    for i in (0..=n).rev() {\\n      if memo[i] <= k {\\n        return i as i32\\n      }\\n    }\\n    0\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn longest_subsequence(s: String, k: i32) -> i32 {\\n    let k = k as usize;\\n\\n    let n = s.len();\\n    let s = s.chars().collect::<Vec<char>>();\\n    let inf = 1_000_000_000_000;\\n    let mut memo = vec![inf;n+1];\\n    memo[0] = 0;\\n\\n    for i in 0..n {\\n      let mut new_memo = memo.clone();\\n      if s[i] == \\'1\\' {\\n        for j in 0..=i {\\n          new_memo[j+1] = new_memo[j+1].min(memo[j]*2+1);\\n          if new_memo[j+1] > k {\\n            new_memo[j+1] = k+1;\\n          }\\n        }\\n      } else {\\n        for j in 0..=i {\\n          new_memo[j+1] = new_memo[j+1].min(memo[j]*2);\\n          if new_memo[j+1] > k {\\n            new_memo[j+1] = k+1;\\n          }\\n        }\\n      }\\n      memo = new_memo;\\n    }\\n\\n    for i in (0..=n).rev() {\\n      if memo[i] <= k {\\n        return i as i32\\n      }\\n    }\\n    0\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2802001,
                "title": "c-scan-and-keep-0-discard-1-until-no-more-larger",
                "content": "https://github.com/lambdacode-dev/leetcode/blob/main/2311.Longest-Binary-Subsequence-Less-Than-or-Equal-to-K.cpp\\n```\\nclass Solution {\\n    //[scan and choose]: always choose 0, and 1 can be skipped (if > k) without impacting the final solution\\n    //(time, space) = O(N) O(N)\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int len = 0, i = 0;\\n        for(; i <= int(s.size()) - 32; ++i)\\n            if(s[i] == \\'0\\') ++len;\\n        \\n        s = s.substr(i);\\n        int n = stoi(s, nullptr, 2);\\n        \\n        for(int i = s.size() - 1, set = 0b01 << i; i >= 0; --i, set = set >> 1) {\\n            if(n <= k)\\n                return len + i + 1;\\n            \\n            if(n & set)\\n                n &= ~set;\\n            else\\n                ++len;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //[scan and choose]: always choose 0, and 1 can be skipped (if > k) without impacting the final solution\\n    //(time, space) = O(N) O(N)\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int len = 0, i = 0;\\n        for(; i <= int(s.size()) - 32; ++i)\\n            if(s[i] == \\'0\\') ++len;\\n        \\n        s = s.substr(i);\\n        int n = stoi(s, nullptr, 2);\\n        \\n        for(int i = s.size() - 1, set = 0b01 << i; i >= 0; --i, set = set >> 1) {\\n            if(n <= k)\\n                return len + i + 1;\\n            \\n            if(n & set)\\n                n &= ~set;\\n            else\\n                ++len;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800542,
                "title": "simple-o-n-solution-explained-python",
                "content": "**Intuition**\\nsince we can have leading zeros, that means ans >= number of zeros in s. \\n**Solution**\\nThe only thing we need to figure out is, whats the max number of 1s we can have?\\nStart from the right most 1 bit, add its value, keep adding them until the value > k. And thats the maximum number of 1 bits you can have.\\n**Time: O(n)\\nSpace: O(1)**\\n```\\ndef longestSubsequence(self, s: str, k: int) -> int:\\n    n = len(s)\\n    val = ones = zeros = 0\\n    i = 0\\n    while i < n:\\n        if s[-i-1] == \"1\":\\n            val += 2**(i)\\n            if val <= k:\\n                ones += 1\\n            else:\\n                break\\n        else:\\n            zeros += 1\\n        i += 1\\n    while i < n:\\n        if s[-i-1] == \"0\":\\n            zeros += 1\\n        i += 1\\n    \\n    return zeros + ones\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndef longestSubsequence(self, s: str, k: int) -> int:\\n    n = len(s)\\n    val = ones = zeros = 0\\n    i = 0\\n    while i < n:\\n        if s[-i-1] == \"1\":\\n            val += 2**(i)\\n            if val <= k:\\n                ones += 1\\n            else:\\n                break\\n        else:\\n            zeros += 1\\n        i += 1\\n    while i < n:\\n        if s[-i-1] == \"0\":\\n            zeros += 1\\n        i += 1\\n    \\n    return zeros + ones\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2772137,
                "title": "java-time-o-n-space-o-1-string-manipulation-greedy",
                "content": "```\\n//some points :\\n\\n// 1. calcuate the bit string of the integer k, denote it as string ks\\n// 2. if its ks.length() > s.length(), we pick everything from s, return s.length() at once.\\n// 3. if ks.length() <= s.length(), what will happen?\\n// example\\n\\n// s = 001010101011010100010101101010010   length = 33\\n//              ^\\n\\n//truncated s \\n// truc_s =  101011010100010101101010010   length = 27\\n//              ^\\n\\n//ks =       101100110011001010001001111   lenght = 27\\n//              ^\\n\\n//we can see that if we truncate s from back to get a string of length ks.length()\\n//we can compare which one is larger by checking the first character they differ\\n//in this example, we can see that ks is larger than truncated s!, so we include the whole\\n//truncated substring.\\n\\n//if in any case, we can not include the whole truncated string, we will instead delete the\\n//last character of trunc_s, and this can be easily proven to be the best strategy.\\n\\n//so ... we get a subsequence of s of length ks.length() already... and this is the largest\\n//we can get that is smaller than k\\n\\n//4. Since we can include more 0\\'s in front of the above mentioned sequence.. we include\\n//all 0\\'s in the rest of string s, which is 4 in this case, so we get the final result => 27+4 = 31\\n\\n//I admit this approach is slightly more difficult to visualize and harder to code, but you will\\n//understand the problem from a micro perspective.\\n\\n\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        String ks = Integer.toBinaryString(k);\\n        if(ks.length()>s.length())\\n            return s.length();\\n        \\n        int i = 0, j = s.length() - ks.length();\\n        while(i<ks.length()&&j<s.length()&&ks.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n      \\n        int cnt = 0;\\n        if(i<ks.length()&&ks.charAt(i)<s.charAt(j))\\n            cnt+=ks.length()-1;\\n        else\\n            cnt+=ks.length();\\n        \\n        int tmp = s.length()-ks.length()-1;\\n        while(tmp>=0){\\n            if(s.charAt(tmp)==\\'0\\')\\n                cnt++;\\n            tmp--;\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n//some points :\\n\\n// 1. calcuate the bit string of the integer k, denote it as string ks\\n// 2. if its ks.length() > s.length(), we pick everything from s, return s.length() at once.\\n// 3. if ks.length() <= s.length(), what will happen?\\n// example\\n\\n// s = 001010101011010100010101101010010   length = 33\\n//              ^\\n\\n//truncated s \\n// truc_s =  101011010100010101101010010   length = 27\\n//              ^\\n\\n//ks =       101100110011001010001001111   lenght = 27\\n//              ^\\n\\n//we can see that if we truncate s from back to get a string of length ks.length()\\n//we can compare which one is larger by checking the first character they differ\\n//in this example, we can see that ks is larger than truncated s!, so we include the whole\\n//truncated substring.\\n\\n//if in any case, we can not include the whole truncated string, we will instead delete the\\n//last character of trunc_s, and this can be easily proven to be the best strategy.\\n\\n//so ... we get a subsequence of s of length ks.length() already... and this is the largest\\n//we can get that is smaller than k\\n\\n//4. Since we can include more 0\\'s in front of the above mentioned sequence.. we include\\n//all 0\\'s in the rest of string s, which is 4 in this case, so we get the final result => 27+4 = 31\\n\\n//I admit this approach is slightly more difficult to visualize and harder to code, but you will\\n//understand the problem from a micro perspective.\\n\\n\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        String ks = Integer.toBinaryString(k);\\n        if(ks.length()>s.length())\\n            return s.length();\\n        \\n        int i = 0, j = s.length() - ks.length();\\n        while(i<ks.length()&&j<s.length()&&ks.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n      \\n        int cnt = 0;\\n        if(i<ks.length()&&ks.charAt(i)<s.charAt(j))\\n            cnt+=ks.length()-1;\\n        else\\n            cnt+=ks.length();\\n        \\n        int tmp = s.length()-ks.length()-1;\\n        while(tmp>=0){\\n            if(s.charAt(tmp)==\\'0\\')\\n                cnt++;\\n            tmp--;\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764458,
                "title": "greedy-with-exp-2-dp-bottom-up-dfs-memo-python-easy-to-understand",
                "content": "Top-down DFS/recursion Memo\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        if not s.count(\\'1\\'):\\n            return len(s)\\n        \\n        \\n        \\n        ret = 0\\n        \\n        def dfs(remain, idx):\\n            if idx < 0:\\n                return 0\\n            \\n            if s[idx] == \\'1\\' and pow(2, len(s) - idx - 1) > remain:\\n                return 0\\n            \\n            if s[idx] == \\'0\\':\\n                return dfs(remain, idx - 1)\\n        \\n            if s[idx] == \\'1\\':\\n                return max(dfs(remain, idx - 1), dfs(remain - 2 ** (len(s) - idx - 1), idx - 1) + 1)\\n        \\n        return dfs(k, len(s) - 1) + s.count(\\'0\\')\\n                \\n```\\n\\nGreedy one-pass / DP bottom-up\\n```\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        if not s.count(\\'1\\'):\\n            return len(s)\\n        \\n        one_map = [len(s) - idx - 1 for idx, val in enumerate(s) if val == \\'1\\']\\n        \\n        ret = 0\\n        for i in reversed(range(len(one_map))):\\n            if k >= pow(2, one_map[i]):\\n                k -= pow(2, one_map[i])\\n                ret += 1\\n        \\n        return ret + s.count(\\'0\\')\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        if not s.count(\\'1\\'):\\n            return len(s)\\n        \\n        \\n        \\n        ret = 0\\n        \\n        def dfs(remain, idx):\\n            if idx < 0:\\n                return 0\\n            \\n            if s[idx] == \\'1\\' and pow(2, len(s) - idx - 1) > remain:\\n                return 0\\n            \\n            if s[idx] == \\'0\\':\\n                return dfs(remain, idx - 1)\\n        \\n            if s[idx] == \\'1\\':\\n                return max(dfs(remain, idx - 1), dfs(remain - 2 ** (len(s) - idx - 1), idx - 1) + 1)\\n        \\n        return dfs(k, len(s) - 1) + s.count(\\'0\\')\\n                \\n```\n```\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        if not s.count(\\'1\\'):\\n            return len(s)\\n        \\n        one_map = [len(s) - idx - 1 for idx, val in enumerate(s) if val == \\'1\\']\\n        \\n        ret = 0\\n        for i in reversed(range(len(one_map))):\\n            if k >= pow(2, one_map[i]):\\n                k -= pow(2, one_map[i])\\n                ret += 1\\n        \\n        return ret + s.count(\\'0\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751492,
                "title": "python-one-pass-o-n-super-straightforward-and-easy",
                "content": "Say the binary of number K is D digits.\\nAll you need to do is compare the last D digits of S with K.\\n\\nWhy?\\nCase 1. the last D digits of S is smaller or equal to K:\\nyou have found the optimal selection. Now lets add all the 0s before the last D digits.\\nWhy this is optimal?\\nBecause the longest sequence you can get must be in the format of: **leading 0s | 1 | at most (D - 1) digits.**\\n\\nCase 2. the last D digits of S is greater than K:\\nIt means, S[len(S) - D] must be 1, otherwise the last D digits of S cannot be greater.\\nWe just discard this 1, then we are all good to go.\\n\\n\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        k = bin(k)[2:]\\n        \\n        if len(s) < len(k):\\n            return len(s)\\n        \\n        possible = s[:-len(k)].count(\\'0\\') + len(k)\\n        if s[-len(k):] <= k:\\n            return possible\\n        else:\\n            return possible - 1",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "Say the binary of number K is D digits.\\nAll you need to do is compare the last D digits of S with K.\\n\\nWhy?\\nCase 1. the last D digits of S is smaller or equal to K:\\nyou have found the optimal selection. Now lets add all the 0s before the last D digits.\\nWhy this is optimal?\\nBecause the longest sequence you can get must be in the format of: **leading 0s | 1 | at most (D - 1) digits.**\\n\\nCase 2. the last D digits of S is greater than K:\\nIt means, S[len(S) - D] must be 1, otherwise the last D digits of S cannot be greater.\\nWe just discard this 1, then we are all good to go.\\n\\n\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        k = bin(k)[2:]\\n        \\n        if len(s) < len(k):\\n            return len(s)\\n        \\n        possible = s[:-len(k)].count(\\'0\\') + len(k)\\n        if s[-len(k):] <= k:\\n            return possible\\n        else:\\n            return possible - 1",
                "codeTag": "Java"
            },
            {
                "id": 2745650,
                "title": "o-min-31-n-solution-10-lines-cpp",
                "content": "```\\nint longestSubsequence(string s, int k) {\\n    int n=s.size(), temp=1;\\n    int len=count(begin(s), end(s), \\'0\\');\\n\\n    for (int i=0; i<min(31, n); i++){\\n        if(s[n-i-1] == \\'1\\'){\\n            k -= temp;\\n            if (k < 0) break; \\n            len++;\\n        }\\n        temp<<=1;\\n    }\\n    return len;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint longestSubsequence(string s, int k) {\\n    int n=s.size(), temp=1;\\n    int len=count(begin(s), end(s), \\'0\\');\\n\\n    for (int i=0; i<min(31, n); i++){\\n        if(s[n-i-1] == \\'1\\'){\\n            k -= temp;\\n            if (k < 0) break; \\n            len++;\\n        }\\n        temp<<=1;\\n    }\\n    return len;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724115,
                "title": "1d-dp-easy-take-not-take-from-right",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[1001];\\n    int f(string &s, int k, int i) {\\n        if(i == 0)\\n            return 0;\\n        if(dp[i] != -1)\\n            return dp[i];\\n        // take\\n        int x = 0;\\n        if((s[i-1]-\\'0\\')*pow(2, n-i) <= k)\\n            x = 1 + f(s, k-(s[i-1]-\\'0\\')*pow(2, n-i), i-1);\\n        // not take\\n        int y = f(s, k, i-1);\\n        return dp[i] = max(x, y);\\n    }\\n    int longestSubsequence(string &s, int k) {\\n        n = s.length();\\n        memset(dp, -1, sizeof(dp));\\n        return f(s, k, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[1001];\\n    int f(string &s, int k, int i) {\\n        if(i == 0)\\n            return 0;\\n        if(dp[i] != -1)\\n            return dp[i];\\n        // take\\n        int x = 0;\\n        if((s[i-1]-\\'0\\')*pow(2, n-i) <= k)\\n            x = 1 + f(s, k-(s[i-1]-\\'0\\')*pow(2, n-i), i-1);\\n        // not take\\n        int y = f(s, k, i-1);\\n        return dp[i] = max(x, y);\\n    }\\n    int longestSubsequence(string &s, int k) {\\n        n = s.length();\\n        memset(dp, -1, sizeof(dp));\\n        return f(s, k, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704410,
                "title": "c-o-n-simple-solution",
                "content": "All we need to do is return countOfZeros + countOfOnesFromRight;\\n\\nThe way we perform counting of `1` from right, is by checking if decimal equivalent of number formed is less than equal to `k`.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int countOfZeros = std::count(s.begin(), s.end(), \\'0\\'),\\n        countOfOnesFromRight = 0, num = 0, pow = 1, n = s.length();\\n        for (int i = n-1; i >=0 && (pow+num <= k); --i) {\\n            if (s[i] == \\'1\\') {\\n                countOfOnesFromRight ++;\\n                num += pow;\\n            }\\n            pow *= 2;\\n        }\\n        return countOfZeros + countOfOnesFromRight;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int countOfZeros = std::count(s.begin(), s.end(), \\'0\\'),\\n        countOfOnesFromRight = 0, num = 0, pow = 1, n = s.length();\\n        for (int i = n-1; i >=0 && (pow+num <= k); --i) {\\n            if (s[i] == \\'1\\') {\\n                countOfOnesFromRight ++;\\n                num += pow;\\n            }\\n            pow *= 2;\\n        }\\n        return countOfZeros + countOfOnesFromRight;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697626,
                "title": "o-n-simple-and-fast",
                "content": "\\n\\n\\n```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        \\n        t = f\"{k:b}\"\\n        if len(t) > len(s):\\n            return len(s)\\n        \\n        out = s[:-len(t)].count(\\'0\\')\\n        remove = 0\\n        \\n        for i in range(len(t)):\\n            c1, c2 = t[i], s[-len(t) + i]\\n            if c1 == \\'1\\' and c2 == \\'0\\': # s[:-len(t)] smaller than t\\n                break\\n            if c1 == \\'0\\' and c2 == \\'1\\':  # s[:-len(t) - 1]  <  t  <  s[:-len(t)] \\n                remove = 1\\n                break\\n                \\n        return out + len(t) - remove\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        \\n        t = f\"{k:b}\"\\n        if len(t) > len(s):\\n            return len(s)\\n        \\n        out = s[:-len(t)].count(\\'0\\')\\n        remove = 0\\n        \\n        for i in range(len(t)):\\n            c1, c2 = t[i], s[-len(t) + i]\\n            if c1 == \\'1\\' and c2 == \\'0\\': # s[:-len(t)] smaller than t\\n                break\\n            if c1 == \\'0\\' and c2 == \\'1\\':  # s[:-len(t) - 1]  <  t  <  s[:-len(t)] \\n                remove = 1\\n                break\\n                \\n        return out + len(t) - remove\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696091,
                "title": "greedy-top-down-and-bottom-up-solution-java",
                "content": "Greedy Approach:-\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int ans = 0;\\n        int currLength = 0;\\n        int currSum = 0;\\n        Deque<Integer> q = new LinkedList<>();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            currSum *= 2;\\n\\n            if (s.charAt(i) == \\'1\\') {\\n                currSum += 1;\\n                q.offerLast(i);\\n            }\\n            currLength++;\\n\\n            if (currSum > k) {\\n                int index = q.pollFirst();\\n                int calculation = (int)Math.pow(2, i - index);\\n                currSum -= calculation;\\n                currLength--;\\n            }\\n            ans = Math.max(ans, currLength);\\n        }\\n        return ans;\\n    }\\n```\\n\\nTop Down Approach:-\\n\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n\\n        if (s.length() == 1) {\\n\\n            if (s.charAt(0) == \\'0\\') {\\n                return 1;\\n            }\\n        }\\n        double[][] memo = new double[s.length()][2];\\n        int firstPass = (int)recur(s, k, 0, memo)[1];\\n        //int secondPass = (int)recur(s, k, 1, memo)[1];\\n        return firstPass;//Math.max(firstPass, secondPass);\\n    }\\n\\n    private double[] recur(String s, int k, int index, double[][] memo) {\\n        \\n        if (index >= s.length()) {\\n            return new double[] {0, 0};\\n        }\\n\\n       if (memo[index][1] > 0) {\\n            return memo[index];\\n        }\\n        double[] include = recur(s, k, index + 1, memo);\\n        double[] ignore = recur(s, k, index + 2, memo);\\n\\n        double calculationInc = 0;\\n        double calculationIgn = 0;\\n        \\n        if (s.charAt(index) == \\'1\\') {\\n            calculationInc = Math.pow(2, include[1]);\\n            calculationIgn = Math.pow(2, ignore[1]);\\n        }\\n        double[] ans = {0, 1};\\n\\n        if (include[0] + calculationInc <= k) {            \\n            ans[0] = include[0] + calculationInc;\\n            ans[1] += include[1];\\n        } else {\\n            ans[0] = include[0];\\n            ans[1] = include[1];\\n        }\\n        \\n        if (ignore[0] + calculationIgn <= k && ignore[1] + 1 > ans[1]) {\\n            ans[0] = ignore[0] + calculationIgn;\\n            ans[1] = ignore[1] + 1;  \\n        }\\n        return memo[index] = ans;\\n    }\\n}\\n```\\n\\n\\nBottom up approach:-\\n\\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n\\n        double[][] memo = new double[s.length() + 2][2];\\n\\n        for (int index = s.length() - 1; index >= 0; index--) {\\n            double[] include = memo[index + 1];\\n            double[] ignore = memo[index + 2];\\n\\n            double calculationInc = 0;\\n            double calculationIgn = 0;\\n            \\n            if (s.charAt(index) == \\'1\\') {\\n                calculationInc = Math.pow(2, include[1]);\\n                calculationIgn = Math.pow(2, ignore[1]);\\n            }\\n            double[] ans = {0, 1};\\n\\n            if (include[0] + calculationInc <= k) {            \\n                ans[0] = include[0] + calculationInc;\\n                ans[1] += include[1];\\n            } else {\\n                ans[0] = include[0];\\n                ans[1] = include[1];\\n            }\\n            \\n            if (ignore[0] + calculationIgn <= k && ignore[1] + 1 > ans[1]) {\\n                ans[0] = ignore[0] + calculationIgn;\\n                ans[1] = ignore[1] + 1;  \\n            }\\n            memo[index] = ans;\\n        }\\n        int firstPass = (int)memo[0][1];\\n        //int secondPass = (int)recur(s, k, 1, memo)[1];\\n        return firstPass;//Math.max(firstPass, secondPass);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int ans = 0;\\n        int currLength = 0;\\n        int currSum = 0;\\n        Deque<Integer> q = new LinkedList<>();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            currSum *= 2;\\n\\n            if (s.charAt(i) == \\'1\\') {\\n                currSum += 1;\\n                q.offerLast(i);\\n            }\\n            currLength++;\\n\\n            if (currSum > k) {\\n                int index = q.pollFirst();\\n                int calculation = (int)Math.pow(2, i - index);\\n                currSum -= calculation;\\n                currLength--;\\n            }\\n            ans = Math.max(ans, currLength);\\n        }\\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n\\n        if (s.length() == 1) {\\n\\n            if (s.charAt(0) == \\'0\\') {\\n                return 1;\\n            }\\n        }\\n        double[][] memo = new double[s.length()][2];\\n        int firstPass = (int)recur(s, k, 0, memo)[1];\\n        //int secondPass = (int)recur(s, k, 1, memo)[1];\\n        return firstPass;//Math.max(firstPass, secondPass);\\n    }\\n\\n    private double[] recur(String s, int k, int index, double[][] memo) {\\n        \\n        if (index >= s.length()) {\\n            return new double[] {0, 0};\\n        }\\n\\n       if (memo[index][1] > 0) {\\n            return memo[index];\\n        }\\n        double[] include = recur(s, k, index + 1, memo);\\n        double[] ignore = recur(s, k, index + 2, memo);\\n\\n        double calculationInc = 0;\\n        double calculationIgn = 0;\\n        \\n        if (s.charAt(index) == \\'1\\') {\\n            calculationInc = Math.pow(2, include[1]);\\n            calculationIgn = Math.pow(2, ignore[1]);\\n        }\\n        double[] ans = {0, 1};\\n\\n        if (include[0] + calculationInc <= k) {            \\n            ans[0] = include[0] + calculationInc;\\n            ans[1] += include[1];\\n        } else {\\n            ans[0] = include[0];\\n            ans[1] = include[1];\\n        }\\n        \\n        if (ignore[0] + calculationIgn <= k && ignore[1] + 1 > ans[1]) {\\n            ans[0] = ignore[0] + calculationIgn;\\n            ans[1] = ignore[1] + 1;  \\n        }\\n        return memo[index] = ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n\\n        double[][] memo = new double[s.length() + 2][2];\\n\\n        for (int index = s.length() - 1; index >= 0; index--) {\\n            double[] include = memo[index + 1];\\n            double[] ignore = memo[index + 2];\\n\\n            double calculationInc = 0;\\n            double calculationIgn = 0;\\n            \\n            if (s.charAt(index) == \\'1\\') {\\n                calculationInc = Math.pow(2, include[1]);\\n                calculationIgn = Math.pow(2, ignore[1]);\\n            }\\n            double[] ans = {0, 1};\\n\\n            if (include[0] + calculationInc <= k) {            \\n                ans[0] = include[0] + calculationInc;\\n                ans[1] += include[1];\\n            } else {\\n                ans[0] = include[0];\\n                ans[1] = include[1];\\n            }\\n            \\n            if (ignore[0] + calculationIgn <= k && ignore[1] + 1 > ans[1]) {\\n                ans[0] = ignore[0] + calculationIgn;\\n                ans[1] = ignore[1] + 1;  \\n            }\\n            memo[index] = ans;\\n        }\\n        int firstPass = (int)memo[0][1];\\n        //int secondPass = (int)recur(s, k, 1, memo)[1];\\n        return firstPass;//Math.max(firstPass, secondPass);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683602,
                "title": "python-faster-than-a-lot-clear-easy-to-understand-explanation",
                "content": "```\\ndef longestSubsequence(self, s: str, k: int) -> int:\\n\\t\\t\"\"\"\\n\\t\\t\\tImportant to notice that, the answer to this problem will include all zeroes in the given\\n\\t\\t\\tbit string, but not all ones.\\n\\t\\t\"\"\"\\n\\t\\t\\n\\t\\t\\n\\t\\t\"\"\"\\n\\t\\t\\tFirst For-loop purpose:\\n\\t\\t\\t\\tCreate an array with len(s) entries, where each entry is either:\\n\\t\\t\\t\\t\\t> True - the corresponding index position is a \"1\"\\n\\t\\t\\t\\t\\t> False - the corresponding index position is a \"0\"\\n\\t\\t\\t\\tIf a character in the string is a zero, add to the zero count\\n\\t\\t\"\"\"\\n        isOne = [] \\n        zeroCount = 0\\n        for i in s:\\n            if i == \"0\":\\n                zeroCount += 1\\n                isOne.append(False)\\n            else:\\n                isOne.append(True)\\n        \\n\\t\\t\"\"\"\\n\\t\\t\\tThe purpose of this for loop is to iterate over the string backwards. \\n\\t\\t\\t\\t\\t> If the indexed character is a \"1\", then add 1 to the resulting count and add it to the beginning \\n\\t\\t\\t\\t\\t   of the stored string.\\n\\t\\t\\t\\t\\t> If the indexed character is a \"0\", then add it to the beginning of the string (we already have \\n\\t\\t\\t\\t\\t   the zeroes counted).\\n\\t\\t\\tIf at any point the current string converted to integer is greater than the k number given, then we\\n\\t\\t\\tknow we have the max length number (most ones we can add) to the string. Return the result\\n\\t\\t\\tafter subtracting one (not inclusive of the one we just iterated over)\\n\\t\\t\\t\\n\\t\\t\\tOtherwise, return the result which should be the len(s)\\n\\t\\t\"\"\"\\n        result = zeroCount\\n        string = \"\"\\n        for i in range(len(s) - 1, -1, -1):\\n            if isOne[i]:\\n                string = \"1\" + string\\n                result += 1\\n            else:\\n                string = \"0\" + string\\n            if int(string, 2) > k:\\n                return result - 1\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef longestSubsequence(self, s: str, k: int) -> int:\\n\\t\\t\"\"\"\\n\\t\\t\\tImportant to notice that, the answer to this problem will include all zeroes in the given\\n\\t\\t\\tbit string, but not all ones.\\n\\t\\t\"\"\"\\n\\t\\t\\n\\t\\t\\n\\t\\t\"\"\"\\n\\t\\t\\tFirst For-loop purpose:\\n\\t\\t\\t\\tCreate an array with len(s) entries, where each entry is either:\\n\\t\\t\\t\\t\\t> True - the corresponding index position is a \"1\"\\n\\t\\t\\t\\t\\t> False - the corresponding index position is a \"0\"\\n\\t\\t\\t\\tIf a character in the string is a zero, add to the zero count\\n\\t\\t\"\"\"\\n        isOne = [] \\n        zeroCount = 0\\n        for i in s:\\n            if i == \"0\":\\n                zeroCount += 1\\n                isOne.append(False)\\n            else:\\n                isOne.append(True)\\n        \\n\\t\\t\"\"\"\\n\\t\\t\\tThe purpose of this for loop is to iterate over the string backwards. \\n\\t\\t\\t\\t\\t> If the indexed character is a \"1\", then add 1 to the resulting count and add it to the beginning \\n\\t\\t\\t\\t\\t   of the stored string.\\n\\t\\t\\t\\t\\t> If the indexed character is a \"0\", then add it to the beginning of the string (we already have \\n\\t\\t\\t\\t\\t   the zeroes counted).\\n\\t\\t\\tIf at any point the current string converted to integer is greater than the k number given, then we\\n\\t\\t\\tknow we have the max length number (most ones we can add) to the string. Return the result\\n\\t\\t\\tafter subtracting one (not inclusive of the one we just iterated over)\\n\\t\\t\\t\\n\\t\\t\\tOtherwise, return the result which should be the len(s)\\n\\t\\t\"\"\"\\n        result = zeroCount\\n        string = \"\"\\n        for i in range(len(s) - 1, -1, -1):\\n            if isOne[i]:\\n                string = \"1\" + string\\n                result += 1\\n            else:\\n                string = \"0\" + string\\n            if int(string, 2) > k:\\n                return result - 1\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2677171,
                "title": "java-greedy-time-o-n-space-o-1-super-easy-just-remove-the-leftmost-1",
                "content": "```Java\\nclass Solution {\\n    /*\\n        \"10001010\"  5\\n        add the cur digit from left to right, if > k, remove the leftmost 1\\n        1 -> ok\\n        10 -> ok\\n        100 -> ok\\n        1000 > 5 -> remove the leftmost 1 -> 000 -> ok\\n        0001 -> ok\\n        00010 -> ok\\n        000101 -> ok\\n        0001010 > 5 - > remove the leftmost 1 -> 000010 - > ok\\n    \\n    */\\n    public int longestSubsequence(String s, int k) {\\n        int res = 0;\\n        int cur = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            int ch = s.charAt(i) - \\'0\\';\\n            if ( (cur << 1) + ch > k) {\\n                cur = cur & ~(helper(cur));   // remove the leftmost 1\\n                cur = (cur << 1) + ch;\\n            } else {\\n                cur = (cur << 1) + ch;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int helper(int x) {\\n        for (int i = 31; i >= 0; i--) {\\n            int mask = 1 << i;\\n            if ((mask & x) == mask) return mask;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    /*\\n        \"10001010\"  5\\n        add the cur digit from left to right, if > k, remove the leftmost 1\\n        1 -> ok\\n        10 -> ok\\n        100 -> ok\\n        1000 > 5 -> remove the leftmost 1 -> 000 -> ok\\n        0001 -> ok\\n        00010 -> ok\\n        000101 -> ok\\n        0001010 > 5 - > remove the leftmost 1 -> 000010 - > ok\\n    \\n    */\\n    public int longestSubsequence(String s, int k) {\\n        int res = 0;\\n        int cur = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            int ch = s.charAt(i) - \\'0\\';\\n            if ( (cur << 1) + ch > k) {\\n                cur = cur & ~(helper(cur));   // remove the leftmost 1\\n                cur = (cur << 1) + ch;\\n            } else {\\n                cur = (cur << 1) + ch;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int helper(int x) {\\n        for (int i = 31; i >= 0; i--) {\\n            int mask = 1 << i;\\n            if ((mask & x) == mask) return mask;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661021,
                "title": "my-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int ans=0,n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')   ans++;\\n        }\\n        long long int  temp=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                if(n-1-i>31)    return ans;\\n                else \\n                {\\n                    if(temp+pow(2,n-1-i)<=k)    \\n                    {\\n                        ans++;\\n                        temp+=pow(2,n-1-i);\\n                    }\\n                    else                        return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int ans=0,n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')   ans++;\\n        }\\n        long long int  temp=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                if(n-1-i>31)    return ans;\\n                else \\n                {\\n                    if(temp+pow(2,n-1-i)<=k)    \\n                    {\\n                        ans++;\\n                        temp+=pow(2,n-1-i);\\n                    }\\n                    else                        return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656979,
                "title": "add-all-0s-first-then-add-1s-from-right-before-exceeding-k",
                "content": "some observations here:\\n- we should take all 0s\\n- then we should scan from right and try to add as many as possible 1s. i take a short-cut to break the loop when k limit is reached so as not to run into long parsing issue\\n```\\n\\n    public int longestSubsequence(String s, int k) {\\n        if (null==s||s.length()==0||k<0) {\\n            return -1;\\n        }\\n        int[] count=new int[s.length()];\\n        Arrays.fill(count,0);\\n        int index=0;\\n        int sum=0;\\n        for (char ch:s.toCharArray()) {\\n            if (ch==\\'0\\') {\\n                ++sum;\\n            }\\n            count[index++]=sum;\\n        }\\n        for (int i=s.length()-1;i>=0;--i) {\\n            if (s.charAt(i)==\\'1\\') {\\n                if (s.length()-i+1<33&&Long.parseLong(s.substring(i),2)<=k) {\\n                    ++sum;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        return sum;        \\n    }```",
                "solutionTags": [],
                "code": "```\\n\\n    public int longestSubsequence(String s, int k) {\\n        if (null==s||s.length()==0||k<0) {\\n            return -1;\\n        }\\n        int[] count=new int[s.length()];\\n        Arrays.fill(count,0);\\n        int index=0;\\n        int sum=0;\\n        for (char ch:s.toCharArray()) {\\n            if (ch==\\'0\\') {\\n                ++sum;\\n            }\\n            count[index++]=sum;\\n        }\\n        for (int i=s.length()-1;i>=0;--i) {\\n            if (s.charAt(i)==\\'1\\') {\\n                if (s.length()-i+1<33&&Long.parseLong(s.substring(i),2)<=k) {\\n                    ++sum;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        return sum;        \\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647183,
                "title": "python-solution-faster-90",
                "content": "\\tclass Solution:\\n\\t\\tdef longestSubsequence(self, s, k):\\n\\t\\t\\tdp = [0]\\n\\t\\t\\tfor v in map(int, s):\\n\\t\\t\\t\\tif dp[-1] * 2 + v <= k:\\n\\t\\t\\t\\t\\tdp.append(dp[-1] * 2 + v)\\n\\t\\t\\t\\tfor i in range(len(dp) - 1, 0, -1):\\n\\t\\t\\t\\t\\tdp[i] = min(dp[i], dp[i - 1] * 2 + v)\\n\\t\\t\\treturn len(dp) - 1",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef longestSubsequence(self, s, k):\\n\\t\\t\\tdp = [0]\\n\\t\\t\\tfor v in map(int, s):\\n\\t\\t\\t\\tif dp[-1] * 2 + v <= k:\\n\\t\\t\\t\\t\\tdp.append(dp[-1] * 2 + v)\\n\\t\\t\\t\\tfor i in range(len(dp) - 1, 0, -1):\\n\\t\\t\\t\\t\\tdp[i] = min(dp[i], dp[i - 1] * 2 + v)\\n\\t\\t\\treturn len(dp) - 1",
                "codeTag": "Java"
            },
            {
                "id": 2641542,
                "title": "java-o-n-simple-logic",
                "content": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int one=0,zero=0;\\n        double val = 0;\\n        for(int i=s.length()-1;i>=0;--i){\\n            if(s.charAt(i)==\\'0\\')    zero++;\\n            else{\\n                val += Math.pow(2, s.length()-i-1);\\n                if(val<=k)  one++;\\n            }\\n        }\\n        return zero+one;\\n    }\\n}\\n```\\nKindly upvote if you find helpful",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int one=0,zero=0;\\n        double val = 0;\\n        for(int i=s.length()-1;i>=0;--i){\\n            if(s.charAt(i)==\\'0\\')    zero++;\\n            else{\\n                val += Math.pow(2, s.length()-i-1);\\n                if(val<=k)  one++;\\n            }\\n        }\\n        return zero+one;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634618,
                "title": "my-prove-of-why-greedy-works-in-this-problem",
                "content": "the reason greedy algorithm works is that we can prove that \"prefer deleting ones over zeros. If there are multiple ones, delete the one from left\" is the best strategy. \\n\\nHere are 3 scenarios\\n\\nscenario 1:\\nleft one VS right one\\n\\nin this case, WLOG, we can assume the string look like \"1xyz1\", where xyz is the number in between. \\nIf we delete the left one, we end up with xyz1, lose 10000\\nif we delete the right one, we end up with 1xyz, lose 1 + 1xyz0 / 2\\nwe can see that the maximum value of 1 + 1xyz0 / 2 is 10000 (when x, y, z all eqaul to 1)\\ntherefore, we lose more when we delete the left one\\n\\nscenario 2:\\nleft one VS right zero\\nagain, we can assume the string looks like 1xyz0\\nif we delete left one, we end up with xyz0, lose 10000\\nif we delete right zero, we end up with 1xyz, lose 1xyz0 / 2\\n10000 is definitely greater than 1xyz0 / 2\\ntherefore, we lose more when we delete the left one\\n\\nscenario 3:\\nleft zero VS right one\\nagain, we can assume the string looks like 0xyz1\\nif we delete right one, we end up with 0xyz, lose xyz / 2\\nif we delete left zero, we end up with xyz1, lose nothing\\ntherefore, we lose more when we delete the left one\\n\\nsince we lose more in all 3 cases, we can safely say that we always lose more when we delete the one, and if there are multiple ones, we should delete from the left. \\n\\nLemme know if there are any questions",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "the reason greedy algorithm works is that we can prove that \"prefer deleting ones over zeros. If there are multiple ones, delete the one from left\" is the best strategy. \\n\\nHere are 3 scenarios\\n\\nscenario 1:\\nleft one VS right one\\n\\nin this case, WLOG, we can assume the string look like \"1xyz1\", where xyz is the number in between. \\nIf we delete the left one, we end up with xyz1, lose 10000\\nif we delete the right one, we end up with 1xyz, lose 1 + 1xyz0 / 2\\nwe can see that the maximum value of 1 + 1xyz0 / 2 is 10000 (when x, y, z all eqaul to 1)\\ntherefore, we lose more when we delete the left one\\n\\nscenario 2:\\nleft one VS right zero\\nagain, we can assume the string looks like 1xyz0\\nif we delete left one, we end up with xyz0, lose 10000\\nif we delete right zero, we end up with 1xyz, lose 1xyz0 / 2\\n10000 is definitely greater than 1xyz0 / 2\\ntherefore, we lose more when we delete the left one\\n\\nscenario 3:\\nleft zero VS right one\\nagain, we can assume the string looks like 0xyz1\\nif we delete right one, we end up with 0xyz, lose xyz / 2\\nif we delete left zero, we end up with xyz1, lose nothing\\ntherefore, we lose more when we delete the left one\\n\\nsince we lose more in all 3 cases, we can safely say that we always lose more when we delete the one, and if there are multiple ones, we should delete from the left. \\n\\nLemme know if there are any questions",
                "codeTag": "Unknown"
            },
            {
                "id": 2630872,
                "title": "java-easy-solution",
                "content": "```\\n\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int n = s.length();\\n        int zeros = 0,ones=0,sum=0;\\n        for(int i =n-1;i>=0;i--){\\n            if(s.charAt(i)==\\'0\\') zeros++;\\n            else{\\n                sum+=Math.pow(2,(n-1)-i);\\n                if(sum<=k) ones++;\\n            }\\n        }\\n        return zeros+ones;\\n    }  \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestSubsequence(String s, int k) {\\n        int n = s.length();\\n        int zeros = 0,ones=0,sum=0;\\n        for(int i =n-1;i>=0;i--){\\n            if(s.charAt(i)==\\'0\\') zeros++;\\n            else{\\n                sum+=Math.pow(2,(n-1)-i);\\n                if(sum<=k) ones++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2613353,
                "title": "can-someone-help-memoize-below-recursive-code",
                "content": "class Solution {\\n    int max=0;\\n    public int longestSubsequence(String s, int k) {\\n        getMax(s,k,0,\"\");\\n        return max;\\n    }\\n\\t\\n    void getMax(String s,int k,int ind,String temp){\\n        if(ind==s.length()){\\n            if(temp.length()>0 && Integer.parseInt(temp, 2)<=k)\\n                max=Math.max(temp.length(),max);\\n            return;\\n        }\\n        //System.out.println(temp);\\n        if(temp.length()>0 && Integer.parseInt(temp, 2)<=k){\\n            max=Math.max(temp.length(),max);\\n        }\\n        getMax(s,k,ind+1,temp+s.charAt(ind));\\n        getMax(s,k,ind+1,temp);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int max=0;\\n    public int longestSubsequence(String s, int k) {\\n        getMax(s,k,0,\"\");\\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2588933,
                "title": "c-solution-o-n-time-o-1-space-bit-manilulation",
                "content": "```\\nclass Solution {\\npublic:\\n    static int longestSubsequence(const string& s, int k) {\\n        const int n = size(s);\\n        int ret = 0;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (s[i] == \\'0\\') {\\n                k >>= 1;\\n                ++ret;\\n                continue;\\n            }\\n            if (k <= 0)\\n                continue;\\n            --k;\\n            k >>= 1;\\n            ++ret;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int longestSubsequence(const string& s, int k) {\\n        const int n = size(s);\\n        int ret = 0;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (s[i] == \\'0\\') {\\n                k >>= 1;\\n                ++ret;\\n                continue;\\n            }\\n            if (k <= 0)\\n                continue;\\n            --k;\\n            k >>= 1;\\n            ++ret;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576104,
                "title": "cpp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint longestSubsequence(string s, int k) {\\n\\t\\t\\tint j = 0,c = 0;\\n\\t\\t\\tint ans = INT_MIN;\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tfor(int i = 0; i < s.length() ; i++){\\n\\t\\t\\t\\tj = j*2 + (s[i]-\\'0\\');\\n\\t\\t\\t\\tif(s[i] == \\'1\\') q.push(i);\\n\\t\\t\\t\\tif(j>k){\\n\\t\\t\\t\\t\\tj = j%(1<<(i-q.front()));\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = max(ans,i+1-c);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint longestSubsequence(string s, int k) {\\n\\t\\t\\tint j = 0,c = 0;\\n\\t\\t\\tint ans = INT_MIN;\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tfor(int i = 0; i < s.length() ; i++){\\n\\t\\t\\t\\tj = j*2 + (s[i]-\\'0\\');\\n\\t\\t\\t\\tif(s[i] == \\'1\\') q.push(i);\\n\\t\\t\\t\\tif(j>k){\\n\\t\\t\\t\\t\\tj = j%(1<<(i-q.front()));\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2535417,
                "title": "python-easy-bit-manipulation",
                "content": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        d = 0\\n        num = 0\\n        res = 0\\n        for v in s[::-1]:\\n            v = int(v)\\n            t = v<<d | num\\n            if t<=k:\\n                num = t\\n                d += 1\\n                res += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubsequence(self, s: str, k: int) -> int:\\n        d = 0\\n        num = 0\\n        res = 0\\n        for v in s[::-1]:\\n            v = int(v)\\n            t = v<<d | num\\n            if t<=k:\\n                num = t\\n                d += 1\\n                res += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528936,
                "title": "python-greedy-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef longestSubsequence(self, s: str, k: int) -> int:\\n\\t\\t\\t\\n\\t\\t\\ts = s[::-1]\\n\\t\\t\\tsum_ = 0\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif sum_ + ((2**i) * int(s[i])) > k:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tsum_ += (2**i) * int(s[i])\\n\\t\\t\\t\\t\\n\\t\\t\\treturn count",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef longestSubsequence(self, s: str, k: int) -> int:\\n\\t\\t\\t\\n\\t\\t\\ts = s[::-1]\\n\\t\\t\\tsum_ = 0\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif sum_ + ((2**i) * int(s[i])) > k:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tsum_ += (2**i) * int(s[i])\\n\\t\\t\\t\\t\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 2526759,
                "title": "python-simple-maths",
                "content": "\\n    def longestSubsequence(self, s, k):\\n        total, n, count = 0, len(s), 0\\n        \\n        for i in range(n-1,-1,-1):\\n            if s[i] == \"1\" and total < k:\\n                total += 2**(n-1-i)\\n                count += 1\\n            elif s[i] == \"0\":\\n                count += 1\\n                \\n        if total > k:\\n            return count - 1\\n        else:\\n            return count\\n",
                "solutionTags": [],
                "code": "\\n    def longestSubsequence(self, s, k):\\n        total, n, count = 0, len(s), 0\\n        \\n        for i in range(n-1,-1,-1):\\n            if s[i] == \"1\" and total < k:\\n                total += 2**(n-1-i)\\n                count += 1\\n            elif s[i] == \"0\":\\n                count += 1\\n                \\n        if total > k:\\n            return count - 1\\n        else:\\n            return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2517518,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int maxl = 0;\\n        int pow = 1;\\n        int ans= 0;\\n        reverse(s.begin(),s.end());\\n        for(auto c : s){\\n            int temp = ans+(c-\\'0\\')*pow;\\n            if(temp<=k && pow <= k){\\n                maxl++;\\n                pow*=2;\\n                ans = temp;\\n            }\\n            else if(c == \\'0\\'){\\n                maxl++;\\n            }\\n        }\\n        return maxl;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestSubsequence(string s, int k) {\\n        int maxl = 0;\\n        int pow = 1;\\n        int ans= 0;\\n        reverse(s.begin(),s.end());\\n        for(auto c : s){\\n            int temp = ans+(c-\\'0\\')*pow;\\n            if(temp<=k && pow <= k){\\n                maxl++;\\n                pow*=2;\\n                ans = temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2517368,
                "title": "lcs-memoization-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int lcs(int i, int currSize, int currSum, vector<vector<int>> &dp, string &s, int k)\\n    {\\n            if (i<0)    return 0;\\n            \\n            if (dp[i][currSize] != -1)  return dp[i][currSize];    \\n\\n            //  not take\\n            int c1 = lcs(i - 1, currSize, currSum, dp, s, k) + 0;\\n            int c2 = 0;\\n            if (currSum + (s[i]-\\'0\\')* pow(2,currSize) <= k)\\n                c2 = lcs(i - 1, currSize + 1, currSum + (s[i]-\\'0\\')* pow(2,currSize), dp, s, k) + 1;\\n                    \\n            return dp[i][currSize] = max(c1, c2);\\n        \\n    }        \\n        \\n        \\n        \\n    int longestSubsequence(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>>dp(n,vector<int>(n, -1));\\n        return lcs(n - 1, 0, 0, dp, s, k);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int lcs(int i, int currSize, int currSum, vector<vector<int>> &dp, string &s, int k)\\n    {\\n            if (i<0)    return 0;\\n            \\n            if (dp[i][currSize] != -1)  return dp[i][currSize];    \\n\\n            //  not take\\n            int c1 = lcs(i - 1, currSize, currSum, dp, s, k) + 0;\\n            int c2 = 0;\\n            if (currSum + (s[i]-\\'0\\')* pow(2,currSize) <= k)\\n                c2 = lcs(i - 1, currSize + 1, currSum + (s[i]-\\'0\\')* pow(2,currSize), dp, s, k) + 1;\\n                    \\n            return dp[i][currSize] = max(c1, c2);\\n        \\n    }        \\n        \\n        \\n        \\n    int longestSubsequence(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>>dp(n,vector<int>(n, -1));\\n        return lcs(n - 1, 0, 0, dp, s, k);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489178,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        //The basic logic is to traverse from end of the string and include as many as zeroes we can as it doesn\\'t contribute to the k value\\n        //Next, if we encounter one, we simply find the value and keep adding till it exceeds k and finally return the length of the string .\\n        boolean crossedKValue = false;\\n        int len = 0;\\n        int sumTillK = 0;\\n        int posOne = 0;\\n        for(int i = s.length()-1;i>=0;i--){\\n            char ch = s.charAt(i);\\n            if(ch == \\'0\\'){\\n                //If we find 0, then it won\\'t contribute to the sum but it will help us to increase length\\n                len++;\\n            }\\n            else if(!crossedKValue){\\n                sumTillK += Math.pow(2, posOne);\\n                if(sumTillK > k){\\n                    sumTillK -= Math.pow(2, posOne);\\n                    crossedKValue = true;\\n                }\\n                else{\\n                    len++;\\n                }\\n            }\\n            posOne++;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubsequence(String s, int k) {\\n        //The basic logic is to traverse from end of the string and include as many as zeroes we can as it doesn\\'t contribute to the k value\\n        //Next, if we encounter one, we simply find the value and keep adding till it exceeds k and finally return the length of the string .\\n        boolean crossedKValue = false;\\n        int len = 0;\\n        int sumTillK = 0;\\n        int posOne = 0;\\n        for(int i = s.length()-1;i>=0;i--){\\n            char ch = s.charAt(i);\\n            if(ch == \\'0\\'){\\n                //If we find 0, then it won\\'t contribute to the sum but it will help us to increase length\\n                len++;\\n            }\\n            else if(!crossedKValue){\\n                sumTillK += Math.pow(2, posOne);\\n                if(sumTillK > k){\\n                    sumTillK -= Math.pow(2, posOne);\\n                    crossedKValue = true;\\n                }\\n                else{\\n                    len++;\\n                }\\n            }\\n            posOne++;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576949,
                "content": [
                    {
                        "username": "rauschaj",
                        "content": "Many solutions claim that a greedy approach which takes the longest contiguous suffix of the array that satisfies the problem conditions, along with all 0s to the left of this suffix, achieves an optimal solution to this problem. Here is a proof of this approach.\\n\\n**Lemma**. WLOG, the optimal subsequence uses all 0s.\\n\\n**Proof**. Consider any solution to the problem. While there exists any unused 0, we can swap it with a 1 to its right (if a 1 exists) or simply add it to our subsequence (if no 1 exists) while maintaining or decreasing the number represented by our subsequence. Iterating this procedure, we can convert any solution to one of equal or greater length that uses all the 0s in the array.\\n\\nNow for the claim:\\n\\n**Claim**. WLOG, the optimal subsequence is a contiguous suffix of the original array, along with all 0s to the left of the leftmost included 1.\\n\\n**Proof**. Let O be the subsequence generated by the greedy approach and S be any other subsequence that satisfies the problem conditions. It suffices to show that |O| >= |S|.\\n\\nUsing our Lemma, we may assume that S uses all 0s. If S has fewer 0s to the right of its leftmost 1 than O, it is impossible for it to be greater than S in length (as in this case O would already contain every digit in S). The same holds if S has the same number of 0s to the right of its leftmost 1 than O: suppose the contrary, then we can show that 1O would work, which contradicts the fact that O was generated by the greedy algorithm.\\n\\nFinally, suppose S has more zeros to its right than O. Assume for a contradiction that |S| > |O|. Then S must have more 1s than O. Take away 1s from S until it has exactly one more 1 than O (hence still |S| > |O|). At this point the subsequence S must have come from 1{ ... section with at least one zero ... }O. Observing that it always makes sense to push the 1s to the right as far as possible, this implies that 1{zeros in section}O works. But then {first 1 in section}{everything else in section}O works too, and as this is a suffix of the array this contradicts the fact that O was chosen using the greedy algorithm. Hence we must have |O| >= |S| and so the greedy algorithm works.\\n"
                    },
                    {
                        "username": "__declspec",
                        "content": "why 1: 1<=n<=1000 \\nwhy 2: O(26n^2) didn\\'t pass\\nwhy 3: i can\\'t debug"
                    },
                    {
                        "username": "Limon020",
                        "content": "for Python users, int(s, 2) will convert a binary string to an integer. The 2 indicates to treat s as a binary representation of an integer.\\ns = \"1001010\"\\nval= int(s, 2) = 74\\ns = \"00001\"\\nval= int(s, 2) = 1"
                    }
                ]
            },
            {
                "id": 1570922,
                "content": [
                    {
                        "username": "rauschaj",
                        "content": "Many solutions claim that a greedy approach which takes the longest contiguous suffix of the array that satisfies the problem conditions, along with all 0s to the left of this suffix, achieves an optimal solution to this problem. Here is a proof of this approach.\\n\\n**Lemma**. WLOG, the optimal subsequence uses all 0s.\\n\\n**Proof**. Consider any solution to the problem. While there exists any unused 0, we can swap it with a 1 to its right (if a 1 exists) or simply add it to our subsequence (if no 1 exists) while maintaining or decreasing the number represented by our subsequence. Iterating this procedure, we can convert any solution to one of equal or greater length that uses all the 0s in the array.\\n\\nNow for the claim:\\n\\n**Claim**. WLOG, the optimal subsequence is a contiguous suffix of the original array, along with all 0s to the left of the leftmost included 1.\\n\\n**Proof**. Let O be the subsequence generated by the greedy approach and S be any other subsequence that satisfies the problem conditions. It suffices to show that |O| >= |S|.\\n\\nUsing our Lemma, we may assume that S uses all 0s. If S has fewer 0s to the right of its leftmost 1 than O, it is impossible for it to be greater than S in length (as in this case O would already contain every digit in S). The same holds if S has the same number of 0s to the right of its leftmost 1 than O: suppose the contrary, then we can show that 1O would work, which contradicts the fact that O was generated by the greedy algorithm.\\n\\nFinally, suppose S has more zeros to its right than O. Assume for a contradiction that |S| > |O|. Then S must have more 1s than O. Take away 1s from S until it has exactly one more 1 than O (hence still |S| > |O|). At this point the subsequence S must have come from 1{ ... section with at least one zero ... }O. Observing that it always makes sense to push the 1s to the right as far as possible, this implies that 1{zeros in section}O works. But then {first 1 in section}{everything else in section}O works too, and as this is a suffix of the array this contradicts the fact that O was chosen using the greedy algorithm. Hence we must have |O| >= |S| and so the greedy algorithm works.\\n"
                    },
                    {
                        "username": "__declspec",
                        "content": "why 1: 1<=n<=1000 \\nwhy 2: O(26n^2) didn\\'t pass\\nwhy 3: i can\\'t debug"
                    },
                    {
                        "username": "Limon020",
                        "content": "for Python users, int(s, 2) will convert a binary string to an integer. The 2 indicates to treat s as a binary representation of an integer.\\ns = \"1001010\"\\nval= int(s, 2) = 74\\ns = \"00001\"\\nval= int(s, 2) = 1"
                    }
                ]
            },
            {
                "id": 2068908,
                "content": [
                    {
                        "username": "rauschaj",
                        "content": "Many solutions claim that a greedy approach which takes the longest contiguous suffix of the array that satisfies the problem conditions, along with all 0s to the left of this suffix, achieves an optimal solution to this problem. Here is a proof of this approach.\\n\\n**Lemma**. WLOG, the optimal subsequence uses all 0s.\\n\\n**Proof**. Consider any solution to the problem. While there exists any unused 0, we can swap it with a 1 to its right (if a 1 exists) or simply add it to our subsequence (if no 1 exists) while maintaining or decreasing the number represented by our subsequence. Iterating this procedure, we can convert any solution to one of equal or greater length that uses all the 0s in the array.\\n\\nNow for the claim:\\n\\n**Claim**. WLOG, the optimal subsequence is a contiguous suffix of the original array, along with all 0s to the left of the leftmost included 1.\\n\\n**Proof**. Let O be the subsequence generated by the greedy approach and S be any other subsequence that satisfies the problem conditions. It suffices to show that |O| >= |S|.\\n\\nUsing our Lemma, we may assume that S uses all 0s. If S has fewer 0s to the right of its leftmost 1 than O, it is impossible for it to be greater than S in length (as in this case O would already contain every digit in S). The same holds if S has the same number of 0s to the right of its leftmost 1 than O: suppose the contrary, then we can show that 1O would work, which contradicts the fact that O was generated by the greedy algorithm.\\n\\nFinally, suppose S has more zeros to its right than O. Assume for a contradiction that |S| > |O|. Then S must have more 1s than O. Take away 1s from S until it has exactly one more 1 than O (hence still |S| > |O|). At this point the subsequence S must have come from 1{ ... section with at least one zero ... }O. Observing that it always makes sense to push the 1s to the right as far as possible, this implies that 1{zeros in section}O works. But then {first 1 in section}{everything else in section}O works too, and as this is a suffix of the array this contradicts the fact that O was chosen using the greedy algorithm. Hence we must have |O| >= |S| and so the greedy algorithm works.\\n"
                    },
                    {
                        "username": "__declspec",
                        "content": "why 1: 1<=n<=1000 \\nwhy 2: O(26n^2) didn\\'t pass\\nwhy 3: i can\\'t debug"
                    },
                    {
                        "username": "Limon020",
                        "content": "for Python users, int(s, 2) will convert a binary string to an integer. The 2 indicates to treat s as a binary representation of an integer.\\ns = \"1001010\"\\nval= int(s, 2) = 74\\ns = \"00001\"\\nval= int(s, 2) = 1"
                    }
                ]
            }
        ]
    }
]