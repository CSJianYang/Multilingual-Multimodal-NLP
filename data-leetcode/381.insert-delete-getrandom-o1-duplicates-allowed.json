[
    {
        "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
        "question_content": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.\nImplement the RandomizedCollection class:\n\n\tRandomizedCollection() Initializes the empty RandomizedCollection object.\n\tbool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.\n\tbool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.\n\tint getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of the same values the multiset contains.\n\nYou must implement the functions of the class such that each function works on average O(1) time complexity.\nNote: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection.\n&nbsp;\nExample 1:\n\nInput\n[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"]\n[[], [1], [1], [2], [], [1], []]\nOutput\n[null, true, false, true, 2, true, 1]\nExplanation\nRandomizedCollection randomizedCollection = new RandomizedCollection();\nrandomizedCollection.insert(1);   // return true since the collection does not contain 1.\n                                  // Inserts 1 into the collection.\nrandomizedCollection.insert(1);   // return false since the collection contains 1.\n                                  // Inserts another 1 into the collection. Collection now contains [1,1].\nrandomizedCollection.insert(2);   // return true since the collection does not contain 2.\n                                  // Inserts 2 into the collection. Collection now contains [1,1,2].\nrandomizedCollection.getRandom(); // getRandom should:\n                                  // - return 1 with probability 2/3, or\n                                  // - return 2 with probability 1/3.\nrandomizedCollection.remove(1);   // return true since the collection contains 1.\n                                  // Removes 1 from the collection. Collection now contains [1,2].\nrandomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.\n\n&nbsp;\nConstraints:\n\n\t-231 <= val <= 231 - 1\n\tAt most 2 * 105 calls in total will be made to insert, remove, and getRandom.\n\tThere will be at least one element in the data structure when getRandom is called.",
        "solutions": [
            {
                "id": 85541,
                "title": "c-128ms-solution-real-o-1-solution",
                "content": "There are two data member in the solution\\n1. a vector **nums**\\n2. an unordered_map **m**\\n\\nThe **key** of **m** is the **val**, the **value** of **m** is a vector contains indices where the **val** appears in **nums**.\\nEach element of **nums** is a pair, the first element of the pair is **val** itself, the second element of the pair is an index into **m[val]**.\\nThere is a relationship between **nums** and **m**:\\n\\n**m[nums[i].first][nums[i].second] == i;**\\n\\n```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        auto result = m.find(val) == m.end();\\n        \\n        m[val].push_back(nums.size());\\n        nums.push_back(pair<int, int>(val, m[val].size() - 1));\\n        \\n        return result;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        auto result = m.find(val) != m.end();\\n        if(result)\\n        {\\n            auto last = nums.back();\\n            m[last.first][last.second] = m[val].back();\\n            nums[m[val].back()] = last;\\n            m[val].pop_back();\\n            if(m[val].empty()) m.erase(val);\\n            nums.pop_back();\\n        }\\n        return result;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()].first;\\n    }\\nprivate:\\n    vector<pair<int, int>> nums;\\n    unordered_map<int, vector<int>> m;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        auto result = m.find(val) == m.end();\\n        \\n        m[val].push_back(nums.size());\\n        nums.push_back(pair<int, int>(val, m[val].size() - 1));\\n        \\n        return result;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        auto result = m.find(val) != m.end();\\n        if(result)\\n        {\\n            auto last = nums.back();\\n            m[last.first][last.second] = m[val].back();\\n            nums[m[val].back()] = last;\\n            m[val].pop_back();\\n            if(m[val].empty()) m.erase(val);\\n            nums.pop_back();\\n        }\\n        return result;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()].first;\\n    }\\nprivate:\\n    vector<pair<int, int>> nums;\\n    unordered_map<int, vector<int>> m;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85540,
                "title": "java-haspmap-linkedhashset-arraylist-155-ms",
                "content": "See my previous post [here](https://discuss.leetcode.com/topic/53216/java-solution-using-a-hashmap-and-an-arraylist-along-with-a-follow-up-131-ms/4).\\nI modified the code by replacing HashSet with LinkedHashSet because the set.iterator() might be costly when a number has too many duplicates. Using LinkedHashSet can be considered as O(1) if we only get the first element to remove. \\n```\\npublic class RandomizedCollection {\\n    ArrayList<Integer> nums;\\n\\tHashMap<Integer, Set<Integer>> locs;\\n\\tjava.util.Random rand = new java.util.Random();\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        nums = new ArrayList<Integer>();\\n\\t    locs = new HashMap<Integer, Set<Integer>>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean contain = locs.containsKey(val);\\n\\t    if ( ! contain ) locs.put( val, new LinkedHashSet<Integer>() ); \\n\\t    locs.get(val).add(nums.size());        \\n\\t    nums.add(val);\\n\\t    return ! contain ;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        boolean contain = locs.containsKey(val);\\n\\t    if ( ! contain ) return false;\\n\\t    int loc = locs.get(val).iterator().next();\\n\\t    locs.get(val).remove(loc);\\n\\t    if (loc < nums.size() - 1 ) {\\n\\t       int lastone = nums.get( nums.size()-1 );\\n\\t       nums.set( loc , lastone );\\n\\t       locs.get(lastone).remove( nums.size()-1);\\n\\t       locs.get(lastone).add(loc);\\n\\t    }\\n\\t    nums.remove(nums.size() - 1);\\n\\t   \\n\\t    if (locs.get(val).isEmpty()) locs.remove(val);\\n\\t    return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return nums.get( rand.nextInt(nums.size()) );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedCollection {\\n    ArrayList<Integer> nums;\\n\\tHashMap<Integer, Set<Integer>> locs;\\n\\tjava.util.Random rand = new java.util.Random();\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        nums = new ArrayList<Integer>();\\n\\t    locs = new HashMap<Integer, Set<Integer>>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean contain = locs.containsKey(val);\\n\\t    if ( ! contain ) locs.put( val, new LinkedHashSet<Integer>() ); \\n\\t    locs.get(val).add(nums.size());        \\n\\t    nums.add(val);\\n\\t    return ! contain ;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        boolean contain = locs.containsKey(val);\\n\\t    if ( ! contain ) return false;\\n\\t    int loc = locs.get(val).iterator().next();\\n\\t    locs.get(val).remove(loc);\\n\\t    if (loc < nums.size() - 1 ) {\\n\\t       int lastone = nums.get( nums.size()-1 );\\n\\t       nums.set( loc , lastone );\\n\\t       locs.get(lastone).remove( nums.size()-1);\\n\\t       locs.get(lastone).add(loc);\\n\\t    }\\n\\t    nums.remove(nums.size() - 1);\\n\\t   \\n\\t    if (locs.get(val).isEmpty()) locs.remove(val);\\n\\t    return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return nums.get( rand.nextInt(nums.size()) );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85556,
                "title": "frugal-python-code",
                "content": "```\\nimport random\\n\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        self.vals, self.idxs = [], collections.defaultdict(set)\\n        \\n\\n    def insert(self, val):\\n        self.vals.append(val)\\n        self.idxs[val].add(len(self.vals) - 1)\\n        return len(self.idxs[val]) == 1\\n        \\n\\n    def remove(self, val):\\n        if self.idxs[val]:\\n            out, ins = self.idxs[val].pop(), self.vals[-1]\\n            self.vals[out] = ins\\n            if self.idxs[ins]:\\n                self.idxs[ins].add(out)\\n                self.idxs[ins].discard(len(self.vals) - 1)\\n            self.vals.pop()\\n            return True\\n        return False \\n\\n    def getRandom(self):\\n        return random.choice(self.vals)",
                "solutionTags": [],
                "code": "```\\nimport random\\n\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        self.vals, self.idxs = [], collections.defaultdict(set)\\n        \\n\\n    def insert(self, val):\\n        self.vals.append(val)\\n        self.idxs[val].add(len(self.vals) - 1)\\n        return len(self.idxs[val]) == 1\\n        \\n\\n    def remove(self, val):\\n        if self.idxs[val]:\\n            out, ins = self.idxs[val].pop(), self.vals[-1]\\n            self.vals[out] = ins\\n            if self.idxs[ins]:\\n                self.idxs[ins].add(out)\\n                self.idxs[ins].discard(len(self.vals) - 1)\\n            self.vals.pop()\\n            return True\\n        return False \\n\\n    def getRandom(self):\\n        return random.choice(self.vals)",
                "codeTag": "Java"
            },
            {
                "id": 197641,
                "title": "c-30-ms-hashmap-hashset-and-vector",
                "content": "Like in the previous problem, [Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/description/), the solution is to maintain a vector with all elements to get the random number in O(1).\\nWith duplicates allowed, instead of just one index, we now need to store indexes of all elements of the same value in our vector. The ```remove``` method becomes a bit more complicated therefore, as we need to:\\n- Remove any index of the element being removed\\n- Swap the last element in the vector with the element being removed (same as in the previous problem)\\n- Remove old and add new index for the swapped (last) element\\n```\\n  vector<int> v;\\n  unordered_map<int, unordered_set<int>> m;\\n  bool insert(int val) {\\n    v.push_back(val);\\n    m[val].insert(v.size() - 1);\\n    return m[val].size() == 1;\\n  }\\n  bool remove(int val) {\\n    auto it = m.find(val);\\n    if (it != end(m)) {\\n      auto free_pos = *it->second.begin();\\n      it->second.erase(it->second.begin());\\n      v[free_pos] = v.back();\\n      m[v.back()].insert(free_pos);\\n      m[v.back()].erase(v.size() - 1);\\n      v.pop_back();\\n      if (it->second.size() == 0) m.erase(it);\\n      return true;\\n    }\\n    return false;\\n  }\\n  int getRandom() { return v[rand() % v.size()]; }\\n  ```",
                "solutionTags": [],
                "code": "```remove```\n```\\n  vector<int> v;\\n  unordered_map<int, unordered_set<int>> m;\\n  bool insert(int val) {\\n    v.push_back(val);\\n    m[val].insert(v.size() - 1);\\n    return m[val].size() == 1;\\n  }\\n  bool remove(int val) {\\n    auto it = m.find(val);\\n    if (it != end(m)) {\\n      auto free_pos = *it->second.begin();\\n      it->second.erase(it->second.begin());\\n      v[free_pos] = v.back();\\n      m[v.back()].insert(free_pos);\\n      m[v.back()].erase(v.size() - 1);\\n      v.pop_back();\\n      if (it->second.size() == 0) m.erase(it);\\n      return true;\\n    }\\n    return false;\\n  }\\n  int getRandom() { return v[rand() % v.size()]; }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 85555,
                "title": "clean-o-1-java-solution-with-hashmap-and-set",
                "content": "The problem is a simple extension of the previous problem that did not have duplicates. Instead of storing a single index like in the previous problem, we simply store a collection of indices for all the times that a number appears in the array.\\n\\nInsert() and random() are quite straightforward. For remove(), we take advantage of the fact that adding/removing from a HashSet is O(1) average time. The logic is otherwise similar - swap the index of any one instance of the item to be removed with the item in the very last place of the array. Update the sets after doing so, and then remove the last item.\\n\\nThanks to @yubad2000 for the wonderful idea of using a LinkedHashSet for O(1) iteration over large items. An iterator over a normal HashSet is actually O(h/n), where h is table capacity. So it is not a solution to our problem requiring O(1) time. Nor does an ArrayList instead of a HashSet work (I wasted some time on that for a while...).\\n\\n```\\npublic class RandomizedCollection {\\n\\n    ArrayList<Integer> result;\\n    HashMap<Integer, LinkedHashSet<Integer>> map;\\n    \\n    public RandomizedCollection() {\\n        result = new ArrayList<Integer>();\\n        map = new HashMap<Integer, LinkedHashSet<Integer>>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        // Add item to map if it doesn't already exist.\\n        boolean alreadyExists = map.containsKey(val);\\n        if(!alreadyExists) {\\n            map.put(val, new LinkedHashSet<Integer>());\\n        }\\n        map.get(val).add(result.size());\\n        result.add(val);\\n        return !alreadyExists;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) {\\n            return false;\\n        }\\n        // Get arbitary index of the ArrayList that contains val\\n        LinkedHashSet<Integer> valSet = map.get(val);\\n        int indexToReplace = valSet.iterator().next();\\n        \\n        // Obtain the set of the number in the last place of the ArrayList\\n        int numAtLastPlace = result.get(result.size() - 1);\\n        LinkedHashSet<Integer> replaceWith = map.get(numAtLastPlace);\\n        \\n        // Replace val at arbitary index with very last number\\n        result.set(indexToReplace, numAtLastPlace);\\n        \\n        // Remove appropriate index\\n        valSet.remove(indexToReplace);\\n        \\n        // Don't change set if we were replacing the removed item with the same number\\n        if(indexToReplace != result.size() - 1) {\\n            replaceWith.remove(result.size() - 1);\\n            replaceWith.add(indexToReplace);\\n        }\\n        result.remove(result.size() - 1);\\n        \\n        // Remove map entry if set is now empty, then return\\n        if(valSet.isEmpty()) {\\n            map.remove(val);\\n        }\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        // Get linearly random item\\n        return result.get((int)(Math.random() * result.size()));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedCollection {\\n\\n    ArrayList<Integer> result;\\n    HashMap<Integer, LinkedHashSet<Integer>> map;\\n    \\n    public RandomizedCollection() {\\n        result = new ArrayList<Integer>();\\n        map = new HashMap<Integer, LinkedHashSet<Integer>>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        // Add item to map if it doesn't already exist.\\n        boolean alreadyExists = map.containsKey(val);\\n        if(!alreadyExists) {\\n            map.put(val, new LinkedHashSet<Integer>());\\n        }\\n        map.get(val).add(result.size());\\n        result.add(val);\\n        return !alreadyExists;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) {\\n            return false;\\n        }\\n        // Get arbitary index of the ArrayList that contains val\\n        LinkedHashSet<Integer> valSet = map.get(val);\\n        int indexToReplace = valSet.iterator().next();\\n        \\n        // Obtain the set of the number in the last place of the ArrayList\\n        int numAtLastPlace = result.get(result.size() - 1);\\n        LinkedHashSet<Integer> replaceWith = map.get(numAtLastPlace);\\n        \\n        // Replace val at arbitary index with very last number\\n        result.set(indexToReplace, numAtLastPlace);\\n        \\n        // Remove appropriate index\\n        valSet.remove(indexToReplace);\\n        \\n        // Don't change set if we were replacing the removed item with the same number\\n        if(indexToReplace != result.size() - 1) {\\n            replaceWith.remove(result.size() - 1);\\n            replaceWith.add(indexToReplace);\\n        }\\n        result.remove(result.size() - 1);\\n        \\n        // Remove map entry if set is now empty, then return\\n        if(valSet.isEmpty()) {\\n            map.remove(val);\\n        }\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        // Get linearly random item\\n        return result.get((int)(Math.random() * result.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495123,
                "title": "java-tc-o-1-sc-o-n-using-arraylist-hashmap",
                "content": "```java\\n/**\\n * Using ArrayList & HashMap.\\n *\\n * Time Complexity: All function have average O(1)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Number of values currently stored in the data structure.\\n */\\nclass RandomizedCollection {\\n\\n    List<Integer> nums;\\n    Map<Integer, Set<Integer>> idxMap;\\n    Random random;\\n\\n    public RandomizedCollection() {\\n        nums = new ArrayList<>();\\n        idxMap = new HashMap<>();\\n        random = new Random();\\n    }\\n\\n    public boolean insert(int val) {\\n        boolean response = !idxMap.containsKey(val);\\n\\n        if (response) {\\n            idxMap.put(val, new HashSet<>());\\n        }\\n        idxMap.get(val).add(nums.size());\\n        nums.add(val);\\n\\n        return response;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!idxMap.containsKey(val)) {\\n            return false;\\n        }\\n\\n        Set<Integer> idxSet = idxMap.get(val);\\n        int idxToBeRemoved = idxSet.iterator().next();\\n        if (idxSet.size() == 1) {\\n            idxMap.remove(val);\\n        } else {\\n            idxSet.remove(idxToBeRemoved);\\n        }\\n\\n        int lastIdx = nums.size() - 1;\\n        if (idxToBeRemoved != lastIdx) {\\n            int lastVal = nums.get(lastIdx);\\n            Set<Integer> lastIdxSet = idxMap.get(lastVal);\\n            lastIdxSet.add(idxToBeRemoved);\\n            lastIdxSet.remove(lastIdx);\\n            nums.set(idxToBeRemoved, lastVal);\\n        }\\n\\n        nums.remove(lastIdx);\\n\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        return nums.get(random.nextInt(nums.size()));\\n    }\\n}\\n```\\n\\nSolution for Part I: [380. Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/discuss/1495119/Java-or-TC:-O(1)-or-SC:-O(N)-or-Using-ArrayList-and-HashMap)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```java\\n/**\\n * Using ArrayList & HashMap.\\n *\\n * Time Complexity: All function have average O(1)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Number of values currently stored in the data structure.\\n */\\nclass RandomizedCollection {\\n\\n    List<Integer> nums;\\n    Map<Integer, Set<Integer>> idxMap;\\n    Random random;\\n\\n    public RandomizedCollection() {\\n        nums = new ArrayList<>();\\n        idxMap = new HashMap<>();\\n        random = new Random();\\n    }\\n\\n    public boolean insert(int val) {\\n        boolean response = !idxMap.containsKey(val);\\n\\n        if (response) {\\n            idxMap.put(val, new HashSet<>());\\n        }\\n        idxMap.get(val).add(nums.size());\\n        nums.add(val);\\n\\n        return response;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!idxMap.containsKey(val)) {\\n            return false;\\n        }\\n\\n        Set<Integer> idxSet = idxMap.get(val);\\n        int idxToBeRemoved = idxSet.iterator().next();\\n        if (idxSet.size() == 1) {\\n            idxMap.remove(val);\\n        } else {\\n            idxSet.remove(idxToBeRemoved);\\n        }\\n\\n        int lastIdx = nums.size() - 1;\\n        if (idxToBeRemoved != lastIdx) {\\n            int lastVal = nums.get(lastIdx);\\n            Set<Integer> lastIdxSet = idxMap.get(lastVal);\\n            lastIdxSet.add(idxToBeRemoved);\\n            lastIdxSet.remove(lastIdx);\\n            nums.set(idxToBeRemoved, lastVal);\\n        }\\n\\n        nums.remove(lastIdx);\\n\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        return nums.get(random.nextInt(nums.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85591,
                "title": "easy-understanding-java-solution-using-hashset",
                "content": "```\\npublic class RandomizedCollection {\\n\\n    List<Integer> nums;\\n    Map<Integer, Set<Integer>> map;\\n    java.util.Random random;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        nums = new ArrayList<>();\\n        map = new HashMap<>();\\n        random = new java.util.Random();\\n    }\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean doesContain = map.containsKey(val);\\n        if(!doesContain) map.put(val, new HashSet<>());\\n        map.get(val).add(nums.size());\\n        nums.add(val);\\n        return !doesContain;\\n    }\\n\\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) return false;\\n        if(!map.get(val).contains(nums.size()-1)) {\\n            int currPos = map.get(val).iterator().next();\\n            int lastVal = nums.get(nums.size() - 1);\\n            map.get(lastVal).remove(nums.size() - 1);\\n            map.get(lastVal).add(currPos);\\n            map.get(val).remove(currPos);\\n            map.get(val).add(nums.size() - 1);\\n            nums.set(currPos, lastVal);\\n        }\\n        map.get(val).remove(nums.size()-1);\\n        if(map.get(val).isEmpty()) map.remove(val);\\n        nums.remove(nums.size()-1);\\n        return true;\\n    }\\n\\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return nums.get(random.nextInt(nums.size()));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedCollection {\\n\\n    List<Integer> nums;\\n    Map<Integer, Set<Integer>> map;\\n    java.util.Random random;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        nums = new ArrayList<>();\\n        map = new HashMap<>();\\n        random = new java.util.Random();\\n    }\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean doesContain = map.containsKey(val);\\n        if(!doesContain) map.put(val, new HashSet<>());\\n        map.get(val).add(nums.size());\\n        nums.add(val);\\n        return !doesContain;\\n    }\\n\\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) return false;\\n        if(!map.get(val).contains(nums.size()-1)) {\\n            int currPos = map.get(val).iterator().next();\\n            int lastVal = nums.get(nums.size() - 1);\\n            map.get(lastVal).remove(nums.size() - 1);\\n            map.get(lastVal).add(currPos);\\n            map.get(val).remove(currPos);\\n            map.get(val).add(nums.size() - 1);\\n            nums.set(currPos, lastVal);\\n        }\\n        map.get(val).remove(nums.size()-1);\\n        if(map.get(val).isEmpty()) map.remove(val);\\n        nums.remove(nums.size()-1);\\n        return true;\\n    }\\n\\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return nums.get(random.nextInt(nums.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290000,
                "title": "javascript-real-o-1-solution",
                "content": "\\t/**\\n\\t * Initialize your data structure here.\\n\\t */\\n\\n\\tvar RandomizedCollection = function() {\\n\\t\\tthis.map = {};  //val: [idx1, idx2]\\n\\t\\tthis.array = []; //[[val,0],[val,1] ...]\\n\\t};\\n\\n\\t/**\\n\\t * Inserts a value to the collection. Returns true if the collection did not already contain the specified element. \\n\\t * @param {number} val\\n\\t * @return {boolean}\\n\\t */\\n\\tRandomizedCollection.prototype.insert = function(val) {\\n\\t\\tlet res = true;\\n\\t\\tif (this.map[val] !== undefined) res = false;\\n\\t\\tthis.map[val] = this.map[val] || [];\\n\\t\\tthis.map[val].push(this.array.length);\\n\\t\\tthis.array.push([val, this.map[val].length-1]);\\n\\n\\t\\treturn res;\\n\\t};\\n\\n\\t/**\\n\\t * Removes a value from the collection. Returns true if the collection contained the specified element. \\n\\t * @param {number} val\\n\\t * @return {boolean}\\n\\t */\\n\\tRandomizedCollection.prototype.remove = function(val) {\\n\\t\\tif (this.map[val] === undefined) return false;\\n\\n\\t\\tlet valIdx = this.map[val].pop();\\n\\t\\tif (this.map[val].length === 0) delete(this.map[val]);\\n\\t\\tlet lastIdx = this.array.length-1;\\n\\t\\tif (valIdx === lastIdx) {\\n\\t\\t\\tthis.array.pop();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t[this.array[valIdx], this.array[lastIdx]] = [this.array[lastIdx], this.array[valIdx]];\\n\\t\\tthis.array.pop();\\n\\n\\t\\tlet key = this.array[valIdx][0];\\n\\t\\tlet idx = this.array[valIdx][1];\\n\\t\\tthis.map[key][idx] = valIdx;\\n\\n\\t\\treturn true;\\n\\t};\\n\\n\\t/**\\n\\t * Get a random element from the collection.\\n\\t * @return {number}\\n\\t */\\n\\tRandomizedCollection.prototype.getRandom = function() {\\n\\t\\t return this.array[Math.floor(Math.random() * this.array.length)][0];\\n\\t};",
                "solutionTags": [],
                "code": "\\t/**\\n\\t * Initialize your data structure here.\\n\\t */\\n\\n\\tvar RandomizedCollection = function() {\\n\\t\\tthis.map = {};  //val: [idx1, idx2]\\n\\t\\tthis.array = []; //[[val,0],[val,1] ...]\\n\\t};\\n\\n\\t/**\\n\\t * Inserts a value to the collection. Returns true if the collection did not already contain the specified element. \\n\\t * @param {number} val\\n\\t * @return {boolean}\\n\\t */\\n\\tRandomizedCollection.prototype.insert = function(val) {\\n\\t\\tlet res = true;\\n\\t\\tif (this.map[val] !== undefined) res = false;\\n\\t\\tthis.map[val] = this.map[val] || [];\\n\\t\\tthis.map[val].push(this.array.length);\\n\\t\\tthis.array.push([val, this.map[val].length-1]);\\n\\n\\t\\treturn res;\\n\\t};\\n\\n\\t/**\\n\\t * Removes a value from the collection. Returns true if the collection contained the specified element. \\n\\t * @param {number} val\\n\\t * @return {boolean}\\n\\t */\\n\\tRandomizedCollection.prototype.remove = function(val) {\\n\\t\\tif (this.map[val] === undefined) return false;\\n\\n\\t\\tlet valIdx = this.map[val].pop();\\n\\t\\tif (this.map[val].length === 0) delete(this.map[val]);\\n\\t\\tlet lastIdx = this.array.length-1;\\n\\t\\tif (valIdx === lastIdx) {\\n\\t\\t\\tthis.array.pop();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t[this.array[valIdx], this.array[lastIdx]] = [this.array[lastIdx], this.array[valIdx]];\\n\\t\\tthis.array.pop();\\n\\n\\t\\tlet key = this.array[valIdx][0];\\n\\t\\tlet idx = this.array[valIdx][1];\\n\\t\\tthis.map[key][idx] = valIdx;\\n\\n\\t\\treturn true;\\n\\t};\\n\\n\\t/**\\n\\t * Get a random element from the collection.\\n\\t * @return {number}\\n\\t */\\n\\tRandomizedCollection.prototype.getRandom = function() {\\n\\t\\t return this.array[Math.floor(Math.random() * this.array.length)][0];\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1708946,
                "title": "c-solution-using-vector-unordered-map",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We\\u2019ll be using two data structures:\\n    1. **`unordered_map<int, vector<int>>`** to store indexes.\\n    2. **`vector<pair<int, int>>`** to store elements.\\n- **insert():**\\n    - First, we\\u2019ll find the element using the map.\\n    - If not present then first we\\u2019ll update it on map with **`mp[val].push_back(a.size())`** here **a.size()** because we still haven\\'t push the element to vector, so index will be exact size.\\n    - Next, simply push_back to vector with it\\u2019s index value **`a.push_back(make_pair(val, mp[val].size()-1))`** & return ***true***.\\n    - Else we\\u2019ll return ***false*** & do the same steps, as we need to insert even the element is present.\\n- **remove():**\\n    - Store the last element value in last **`auto last = a.back()`**\\n    - Find the element to be removed & change the index value with the last element in the map **`mp[last.first][last.second] = mp[val].back()`**\\n    - Then pop out the last element from vector map **`mp[val].pop_back()`**\\n    - Also erase the value from the vector **`a.pop_back()`**\\n- **getRandom():**\\n    - The rand() function is used in C/C++ to generate random numbers in the range [0, RAND_MAX).\\n- **Time complexity:** O(1).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class RandomizedCollection {\\npublic:\\n    \\n    vector<pair<int, int>>a;\\n    unordered_map<int, vector<int>> mp;\\n    \\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        auto it=mp.find(val);\\n        if(it == mp.end())\\n        {\\n            mp[val].push_back(a.size());\\n            a.push_back(make_pair(val, mp[val].size()-1));\\n            return true;\\n        }\\n        else{\\n            mp[val].push_back(a.size());\\n            a.push_back(make_pair(val, mp[val].size()-1));\\n            return false;\\n        }\\n    }\\n    \\n    bool remove(int val) {\\n        auto it=mp.find(val);\\n        if(it != mp.end()){\\n            auto last = a.back();\\n            mp[last.first][last.second] = mp[val].back();\\n            a[mp[val].back()] = last;\\n            mp[val].pop_back();\\n            if(mp[val].empty())\\n                mp.erase(val);\\n            a.pop_back();\\n            return true;\\n        }\\n        return false;\\n         \\n    }\\n    \\n    int getRandom() {\\n        return a[rand()%a.size()].first;\\n    }\\n};\\n\\n/* * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class RandomizedCollection {\\npublic:\\n    \\n    vector<pair<int, int>>a;\\n    unordered_map<int, vector<int>> mp;\\n    \\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        auto it=mp.find(val);\\n        if(it == mp.end())\\n        {\\n            mp[val].push_back(a.size());\\n            a.push_back(make_pair(val, mp[val].size()-1));\\n            return true;\\n        }\\n        else{\\n            mp[val].push_back(a.size());\\n            a.push_back(make_pair(val, mp[val].size()-1));\\n            return false;\\n        }\\n    }\\n    \\n    bool remove(int val) {\\n        auto it=mp.find(val);\\n        if(it != mp.end()){\\n            auto last = a.back();\\n            mp[last.first][last.second] = mp[val].back();\\n            a[mp[val].back()] = last;\\n            mp[val].pop_back();\\n            if(mp[val].empty())\\n                mp.erase(val);\\n            a.pop_back();\\n            return true;\\n        }\\n        return false;\\n         \\n    }\\n    \\n    int getRandom() {\\n        return a[rand()%a.size()].first;\\n    }\\n};\\n\\n/* * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 235295,
                "title": "c-simple-unordered-set-and-clever-vector",
                "content": "As in [Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/), we record the values in a vector and the indices in a hash map. Since duplicates are allowed, the value of the hash map (indices) need to be a container. A simple solution is to use an `unordered_set` as the container since it allows average O(1) insertion/removal/check.\\n\\n```cpp\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ans = indices.find(val) == indices.end();\\n        indices[val].insert(values.size());\\n        values.push_back(val);\\n        return ans;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (indices.find(val) != indices.end()) {\\n            int i = *indices[val].begin();\\n            if (indices[val].size() == 1) {\\n                indices.erase(val);\\n            } else {\\n                indices[val].erase(indices[val].begin());\\n            }\\n            if (i < values.size() - 1) {\\n                values[i] = values.back();\\n                indices[values[i]].erase(values.size() - 1);\\n                indices[values[i]].insert(i);\\n            }\\n            values.pop_back();\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return values[rand() % values.size()];\\n    }\\nprivate:\\n    unordered_map<int, unordered_set<int>> indices;\\n    vector<int> values;\\n};\\n```\\n\\nYou may also try to use `vector` as the container, which is a bit tricky. [This post](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/discuss/85541/C%2B%2B-128m-Solution-Real-O(1)-Solution) shares a clever solution for this. Rewrote below.\\n\\n```cpp\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ans = indices.find(val) == indices.end();\\n        indices[val].push_back(values.size());\\n        values.push_back({val, indices[val].size() - 1});\\n        return ans;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (indices.find(val) != indices.end()) {\\n            pair<int, int> p = values.back();\\n            int i = indices[val].back();\\n            indices[p.first][p.second] = i;\\n            if (indices[val].size() == 1) {\\n                indices.erase(val);\\n            } else {\\n                indices[val].pop_back();\\n            }\\n            values[i] = p;\\n            values.pop_back();\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return values[rand() % values.size()].first;\\n    }\\nprivate:\\n    unordered_map<int, vector<int>> indices;\\n    vector<pair<int, int>> values;\\n};\\n ```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ans = indices.find(val) == indices.end();\\n        indices[val].insert(values.size());\\n        values.push_back(val);\\n        return ans;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (indices.find(val) != indices.end()) {\\n            int i = *indices[val].begin();\\n            if (indices[val].size() == 1) {\\n                indices.erase(val);\\n            } else {\\n                indices[val].erase(indices[val].begin());\\n            }\\n            if (i < values.size() - 1) {\\n                values[i] = values.back();\\n                indices[values[i]].erase(values.size() - 1);\\n                indices[values[i]].insert(i);\\n            }\\n            values.pop_back();\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return values[rand() % values.size()];\\n    }\\nprivate:\\n    unordered_map<int, unordered_set<int>> indices;\\n    vector<int> values;\\n};\\n```\n```cpp\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ans = indices.find(val) == indices.end();\\n        indices[val].push_back(values.size());\\n        values.push_back({val, indices[val].size() - 1});\\n        return ans;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (indices.find(val) != indices.end()) {\\n            pair<int, int> p = values.back();\\n            int i = indices[val].back();\\n            indices[p.first][p.second] = i;\\n            if (indices[val].size() == 1) {\\n                indices.erase(val);\\n            } else {\\n                indices[val].pop_back();\\n            }\\n            values[i] = p;\\n            values.pop_back();\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return values[rand() % values.size()].first;\\n    }\\nprivate:\\n    unordered_map<int, vector<int>> indices;\\n    vector<pair<int, int>> values;\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1586322,
                "title": "python-99-61-with-comments-use-dict-hash-and-a-list",
                "content": "This problem is about chosing the data structure.\\n\\n1. The main data will be in a list called \"nums\".\\n2. The positions for each number would be store in a dictionary. The key would be the number and the values will be the positions stored in a set.\\n\\n```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.nums = []\\n        self.d = defaultdict(set)\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.d and len(self.d[val]) > 0:\\n            res = False\\n        else:\\n            res = True\\n        self.nums.append(val)\\n        # store element positions\\n        self.d[val].add(len(self.nums)-1)\\n        return res\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.d and len(self.d[val]) > 0:\\n            pos = self.d[val].pop() # element to remove position            \\n            lpos = len(self.nums)-1 # last position\\n            lval = self.nums[lpos] # last val\\n            \\n            # add lval pos first .. then remove .. so when last == val .. it will take care auto\\n            self.d[lval].add(pos)            \\n            self.d[lval].remove(lpos)\\n            \\n            # swap with last\\n            self.nums[pos], self.nums[lpos] = self.nums[lpos], self.nums[pos]                        \\n            \\n            # remove element\\n            self.nums.pop()\\n            return True\\n        return False\\n        \\n\\n    def getRandom(self) -> int:\\n        size = len(self.nums)\\n        i = int(random.random()*size)\\n        return self.nums[i]\\n        \\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.nums = []\\n        self.d = defaultdict(set)\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.d and len(self.d[val]) > 0:\\n            res = False\\n        else:\\n            res = True\\n        self.nums.append(val)\\n        # store element positions\\n        self.d[val].add(len(self.nums)-1)\\n        return res\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.d and len(self.d[val]) > 0:\\n            pos = self.d[val].pop() # element to remove position            \\n            lpos = len(self.nums)-1 # last position\\n            lval = self.nums[lpos] # last val\\n            \\n            # add lval pos first .. then remove .. so when last == val .. it will take care auto\\n            self.d[lval].add(pos)            \\n            self.d[lval].remove(lpos)\\n            \\n            # swap with last\\n            self.nums[pos], self.nums[lpos] = self.nums[lpos], self.nums[pos]                        \\n            \\n            # remove element\\n            self.nums.pop()\\n            return True\\n        return False\\n        \\n\\n    def getRandom(self) -> int:\\n        size = len(self.nums)\\n        i = int(random.random()*size)\\n        return self.nums[i]\\n        \\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091464,
                "title": "easy-c-solution-map-and-set-approach-explained",
                "content": "```\\nclass RandomizedCollection {\\npublic:\\n    map <int, set<int>> m;                          //used to map element with the indices where it is present in vector v\\n    vector <int> v;                                 //used to store all the elements (contains duplicate as well)\\n    RandomizedCollection() {}                       //constructor (no such initialisation needed)\\n    \\n    bool insert(int val) {\\n        v.push_back(val);                           //inserting element into vector\\n        m[val].insert(v.size()-1);                  //insering the index of newly inserted element into map \\n        return m[val].size() == 1;                  \\n    }\\n    \\n    bool remove(int val) {\\n        auto it = m.find(val);                      //used to find if element is present in map\\n        if(it != m.end()){                          //if it is present,\\n            auto pos = *it->second.begin();         //pos is an integer and not pointer\\n            it->second.erase(it->second.begin());   //erases integer from the set stored in map corresponding to the element val\\n            v[pos] = v.back();                      //element from the back is brought at the index pos\\n            m[v.back()].insert(pos);                //new index of that element is stored in map\\n            m[v.back()].erase(v.size()-1);          //erasing the old index from the map\\n            v.pop_back();                           //erasing the element from vector \\n            if (it->second.size() == 0)             //if no indices are present in map corresponding to val in map, it means it was present only once \\n                m.erase(it);                        //so erase from map itself\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand() % v.size()];                //rand() is used to get a random number and it is % by v.size() so that the result is within the size of vector v\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    map <int, set<int>> m;                          //used to map element with the indices where it is present in vector v\\n    vector <int> v;                                 //used to store all the elements (contains duplicate as well)\\n    RandomizedCollection() {}                       //constructor (no such initialisation needed)\\n    \\n    bool insert(int val) {\\n        v.push_back(val);                           //inserting element into vector\\n        m[val].insert(v.size()-1);                  //insering the index of newly inserted element into map \\n        return m[val].size() == 1;                  \\n    }\\n    \\n    bool remove(int val) {\\n        auto it = m.find(val);                      //used to find if element is present in map\\n        if(it != m.end()){                          //if it is present,\\n            auto pos = *it->second.begin();         //pos is an integer and not pointer\\n            it->second.erase(it->second.begin());   //erases integer from the set stored in map corresponding to the element val\\n            v[pos] = v.back();                      //element from the back is brought at the index pos\\n            m[v.back()].insert(pos);                //new index of that element is stored in map\\n            m[v.back()].erase(v.size()-1);          //erasing the old index from the map\\n            v.pop_back();                           //erasing the element from vector \\n            if (it->second.size() == 0)             //if no indices are present in map corresponding to val in map, it means it was present only once \\n                m.erase(it);                        //so erase from map itself\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand() % v.size()];                //rand() is used to get a random number and it is % by v.size() so that the result is within the size of vector v\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876246,
                "title": "java-hashmap-list-10-ms-faster-than-95-solutions",
                "content": "**Upvote if you find the solution useful.**\\n```\\npublic class RandomizedCollection {\\n    private Map<Integer, List<Integer>> hashmap;\\n    private List<Integer> list;\\n    private Random random;\\n\\n    /**\\n     * Initialize your data structure here.\\n     */\\n    public RandomizedCollection() {\\n        hashmap = new HashMap<>();\\n        list = new ArrayList<>();\\n        random = new Random();\\n    }\\n\\n    /**\\n     * Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n     */\\n    public boolean insert(int val) {\\n        if (hashmap.containsKey(val)) {\\n            hashmap.get(val).add(list.size());\\n            list.add(val);\\n            return false;\\n        }\\n        hashmap.put(val, new ArrayList<>());\\n        hashmap.get(val).add(list.size());\\n        list.add(val);\\n        return true;\\n    }\\n\\n    /**\\n     * Removes a value from the set. Returns true if the set contained the specified element.\\n     */\\n    public boolean remove(int val) {\\n        if (hashmap.containsKey(val)) {\\n            int loc = hashmap.get(val).get(0);\\n            if (loc < list.size() - 1) {\\n                int lastElement = list.get(list.size() - 1);\\n                list.set(loc, lastElement);\\n                hashmap.get(lastElement).remove(hashmap.get(lastElement).size() - 1);\\n                hashmap.get(lastElement).add(loc);\\n                Collections.sort(hashmap.get(lastElement));\\n            }\\n            list.remove(list.size() - 1);\\n            if (hashmap.get(val).size() == 1)\\n                hashmap.remove(val);\\n            else hashmap.get(val).remove(0);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * Get a random element from the set.\\n     */\\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "**Upvote if you find the solution useful.**\\n```\\npublic class RandomizedCollection {\\n    private Map<Integer, List<Integer>> hashmap;\\n    private List<Integer> list;\\n    private Random random;\\n\\n    /**\\n     * Initialize your data structure here.\\n     */\\n    public RandomizedCollection() {\\n        hashmap = new HashMap<>();\\n        list = new ArrayList<>();\\n        random = new Random();\\n    }\\n\\n    /**\\n     * Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n     */\\n    public boolean insert(int val) {\\n        if (hashmap.containsKey(val)) {\\n            hashmap.get(val).add(list.size());\\n            list.add(val);\\n            return false;\\n        }\\n        hashmap.put(val, new ArrayList<>());\\n        hashmap.get(val).add(list.size());\\n        list.add(val);\\n        return true;\\n    }\\n\\n    /**\\n     * Removes a value from the set. Returns true if the set contained the specified element.\\n     */\\n    public boolean remove(int val) {\\n        if (hashmap.containsKey(val)) {\\n            int loc = hashmap.get(val).get(0);\\n            if (loc < list.size() - 1) {\\n                int lastElement = list.get(list.size() - 1);\\n                list.set(loc, lastElement);\\n                hashmap.get(lastElement).remove(hashmap.get(lastElement).size() - 1);\\n                hashmap.get(lastElement).add(loc);\\n                Collections.sort(hashmap.get(lastElement));\\n            }\\n            list.remove(list.size() - 1);\\n            if (hashmap.get(val).size() == 1)\\n                hashmap.remove(val);\\n            else hashmap.get(val).remove(0);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * Get a random element from the set.\\n     */\\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 586453,
                "title": "java-easy-solution",
                "content": "```\\nclass RandomizedCollection {\\n\\n    List<Integer> list;\\n    Map<Integer, Set<Integer>> map;\\n    java.util.Random rand = new java.util.Random();\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        list = new ArrayList<>();\\n        map = new HashMap<Integer, Set<Integer>>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(! map.containsKey(val)){\\n            map.put(val, new HashSet<>());\\n        }\\n        \\n        //\\u5C06\\u6B64\\u5143\\u7D20\\u52A0\\u5165\\u5230list\\u4E2D,index\\u52A0\\u5165\\u5230map\\u7684value\\u4E2D\\n        map.get(val).add(list.size());\\n        list.add(val);\\n        return map.get(val).size() == 1;\\n            \\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(! map.containsKey(val) || map.get(val).size() == 0)\\n            return false;\\n        //\\u8981remove\\u7684index\\n        int index = map.get(val).iterator().next();\\n        \\n        map.get(val).remove(index);\\n        \\n        int last_element = list.get(list.size() - 1);\\n        //\\u5C06\\u6700\\u540E\\u4E00\\u4E2A\\u4E8C\\u5143\\u7D20\\u79FB\\u5230\\u76F8\\u5E94\\u7684\\u4F4D\\u7F6E\\n        list.set(index, last_element);\\n        \\n        map.get(last_element).add(index);\\n        map.get(last_element).remove(list.size() - 1);\\n        \\n        list.remove(list.size() - 1);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\n\\n    List<Integer> list;\\n    Map<Integer, Set<Integer>> map;\\n    java.util.Random rand = new java.util.Random();\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        list = new ArrayList<>();\\n        map = new HashMap<Integer, Set<Integer>>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(! map.containsKey(val)){\\n            map.put(val, new HashSet<>());\\n        }\\n        \\n        //\\u5C06\\u6B64\\u5143\\u7D20\\u52A0\\u5165\\u5230list\\u4E2D,index\\u52A0\\u5165\\u5230map\\u7684value\\u4E2D\\n        map.get(val).add(list.size());\\n        list.add(val);\\n        return map.get(val).size() == 1;\\n            \\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(! map.containsKey(val) || map.get(val).size() == 0)\\n            return false;\\n        //\\u8981remove\\u7684index\\n        int index = map.get(val).iterator().next();\\n        \\n        map.get(val).remove(index);\\n        \\n        int last_element = list.get(list.size() - 1);\\n        //\\u5C06\\u6700\\u540E\\u4E00\\u4E2A\\u4E8C\\u5143\\u7D20\\u79FB\\u5230\\u76F8\\u5E94\\u7684\\u4F4D\\u7F6E\\n        list.set(index, last_element);\\n        \\n        map.get(last_element).add(index);\\n        map.get(last_element).remove(list.size() - 1);\\n        \\n        list.remove(list.size() - 1);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 150148,
                "title": "python-solution-using-dictionary-and-set-beat-94",
                "content": "```\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dic = {}\\n        self.dic_2 = {}\\n        self.n = 0\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        flag = not val in self.dic\\n        if flag:self.dic[val] = set()\\n        self.dic[val].add(self.n)\\n        self.dic_2[self.n] = val\\n        self.n += 1\\n        return flag\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if not val in self.dic:return False\\n        val_index = self.dic[val].pop()\\n        if not self.dic[val]:self.dic.pop(val)\\n        last_val = self.dic_2.pop(self.n-1)\\n        if val_index != self.n-1:\\n            self.dic[last_val].remove(self.n-1)\\n            self.dic[last_val].add(val_index)\\n            self.dic_2[val_index] = last_val\\n        self.n -= 1\\n        return True\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the collection.\\n        :rtype: int\\n        \"\"\"\\n        return self.dic_2[random.randint(0,self.n-1)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dic = {}\\n        self.dic_2 = {}\\n        self.n = 0\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        flag = not val in self.dic\\n        if flag:self.dic[val] = set()\\n        self.dic[val].add(self.n)\\n        self.dic_2[self.n] = val\\n        self.n += 1\\n        return flag\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if not val in self.dic:return False\\n        val_index = self.dic[val].pop()\\n        if not self.dic[val]:self.dic.pop(val)\\n        last_val = self.dic_2.pop(self.n-1)\\n        if val_index != self.n-1:\\n            self.dic[last_val].remove(self.n-1)\\n            self.dic[last_val].add(val_index)\\n            self.dic_2[val_index] = last_val\\n        self.n -= 1\\n        return True\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the collection.\\n        :rtype: int\\n        \"\"\"\\n        return self.dic_2[random.randint(0,self.n-1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85596,
                "title": "java-solution-beats-97-totally-based-on-the-previous-question",
                "content": "It is almost the same as the previous question, the only difference is now we use a Map<Integer,Set> to store the indexes of the numbers in the array list. We can take advantage of the O(1) add and delete of Set, but we can't realize a get in O(1). So this is the trick of the solution. I just use the previous solution -- RandomizedSet again to make sure all operations are O(1). ---> Map<Integer, RandomizedSet> the key represents the element,  value represents all indexes of the key.\\n\\n/**/\\nclass RandomizedSet {\\n\\n\\t\\tprivate List<Integer> list;\\n\\t\\tprivate Map<Integer, Integer> position;\\n\\t\\tprivate static Random random = new Random();\\n\\t\\t\\n\\t\\t/* initialzie */\\n\\t\\tpublic RandomizedSet() {\\n\\t\\t\\tlist = new ArrayList<Integer>();\\n\\t\\t\\tposition = new HashMap<Integer, Integer>();\\n\\t\\t}\\n\\t\\t\\n\\t\\t/* Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n\\t\\tpublic boolean insert(int val) {\\n\\t\\t\\tif (position.containsKey(val))\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tlist.add(val);\\n\\t\\t\\tposition.put(val, list.size() - 1);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t\\n\\t\\t/* Removes a value from the set. Returns true if the set contained the specified element. */\\n\\t\\tpublic boolean remove(int val) {\\n\\t\\t\\tif (!position.containsKey(val))\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tint p = position.get(val);\\n\\t\\t\\tint lastVal = list.get(list.size() - 1);\\n\\t\\t\\tlist.set(p, lastVal);\\n\\t\\t\\tlist.remove(list.size() - 1);\\n\\t\\t\\tposition.put(lastVal, p);\\n\\t\\t\\tposition.remove(val);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t\\n\\t\\t/* Get a random element from the set. */\\n\\t\\tpublic int getRandom() {\\n\\t\\t\\treturn list.get(random.nextInt(list.size()));\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int size() {\\n\\t\\t\\treturn list.size();\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\npublic class RandomizedCollection {\\n\\n    private static Random random = new Random();\\n\\tprivate List<Integer> list;\\n\\tprivate Map<Integer, RandomizedSet> positions;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        list = new ArrayList<Integer>();\\n\\t\\tpositions = new HashMap<Integer, RandomizedSet>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (positions.containsKey(val)) {\\n\\t\\t\\tlist.add(val);\\n\\t\\t\\tRandomizedSet pVal = positions.get(val);\\n\\t\\t\\tpVal.insert(list.size() - 1);\\n            return false;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tRandomizedSet pVal = new RandomizedSet();\\n\\t\\t\\tlist.add(val);\\n\\t\\t\\tpVal.insert(list.size() - 1);\\n            positions.put(val, pVal);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!positions.containsKey(val))\\n\\t\\t\\treturn false;\\n\\t\\tif (val == list.get(list.size() - 1)) {\\n\\t\\t\\tRandomizedSet s = positions.get(val);\\n\\t\\t\\ts.remove(list.size() - 1);\\n\\t\\t\\tif (s.size() == 0)\\n                positions.remove(val);\\n\\t\\t\\tlist.remove(list.size() - 1);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\tRandomizedSet pVal = positions.get(val);\\n        int pDel = pVal.getRandom();\\n\\t\\tint lastVal = list.get(list.size() - 1);\\n\\t    RandomizedSet pLast = positions.get(lastVal);\\n\\t\\tpLast.remove(list.size() - 1);\\n\\t    pLast.insert(pDel);\\t\\t\\t\\n\\t\\tpVal.remove(pDel);\\n        if (pVal.size() == 0)\\n\\t\\t\\tpositions.remove(val);\\n\\t\\tlist.set(pDel, list.get(list.size() - 1));\\n\\t\\tlist.remove(list.size() - 1);\\n\\t\\treturn true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}",
                "solutionTags": [],
                "code": "It is almost the same as the previous question, the only difference is now we use a Map<Integer,Set> to store the indexes of the numbers in the array list. We can take advantage of the O(1) add and delete of Set, but we can't realize a get in O(1). So this is the trick of the solution. I just use the previous solution -- RandomizedSet again to make sure all operations are O(1). ---> Map<Integer, RandomizedSet> the key represents the element,  value represents all indexes of the key.\\n\\n/**/\\nclass RandomizedSet {\\n\\n\\t\\tprivate List<Integer> list;\\n\\t\\tprivate Map<Integer, Integer> position;\\n\\t\\tprivate static Random random = new Random();\\n\\t\\t\\n\\t\\t/* initialzie */\\n\\t\\tpublic RandomizedSet() {\\n\\t\\t\\tlist = new ArrayList<Integer>();\\n\\t\\t\\tposition = new HashMap<Integer, Integer>();\\n\\t\\t}\\n\\t\\t\\n\\t\\t/* Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n\\t\\tpublic boolean insert(int val) {\\n\\t\\t\\tif (position.containsKey(val))\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tlist.add(val);\\n\\t\\t\\tposition.put(val, list.size() - 1);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t\\n\\t\\t/* Removes a value from the set. Returns true if the set contained the specified element. */\\n\\t\\tpublic boolean remove(int val) {\\n\\t\\t\\tif (!position.containsKey(val))\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tint p = position.get(val);\\n\\t\\t\\tint lastVal = list.get(list.size() - 1);\\n\\t\\t\\tlist.set(p, lastVal);\\n\\t\\t\\tlist.remove(list.size() - 1);\\n\\t\\t\\tposition.put(lastVal, p);\\n\\t\\t\\tposition.remove(val);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t\\n\\t\\t/* Get a random element from the set. */\\n\\t\\tpublic int getRandom() {\\n\\t\\t\\treturn list.get(random.nextInt(list.size()));\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int size() {\\n\\t\\t\\treturn list.size();\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\npublic class RandomizedCollection {\\n\\n    private static Random random = new Random();\\n\\tprivate List<Integer> list;\\n\\tprivate Map<Integer, RandomizedSet> positions;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        list = new ArrayList<Integer>();\\n\\t\\tpositions = new HashMap<Integer, RandomizedSet>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (positions.containsKey(val)) {\\n\\t\\t\\tlist.add(val);\\n\\t\\t\\tRandomizedSet pVal = positions.get(val);\\n\\t\\t\\tpVal.insert(list.size() - 1);\\n            return false;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tRandomizedSet pVal = new RandomizedSet();\\n\\t\\t\\tlist.add(val);\\n\\t\\t\\tpVal.insert(list.size() - 1);\\n            positions.put(val, pVal);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!positions.containsKey(val))\\n\\t\\t\\treturn false;\\n\\t\\tif (val == list.get(list.size() - 1)) {\\n\\t\\t\\tRandomizedSet s = positions.get(val);\\n\\t\\t\\ts.remove(list.size() - 1);\\n\\t\\t\\tif (s.size() == 0)\\n                positions.remove(val);\\n\\t\\t\\tlist.remove(list.size() - 1);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\tRandomizedSet pVal = positions.get(val);\\n        int pDel = pVal.getRandom();\\n\\t\\tint lastVal = list.get(list.size() - 1);\\n\\t    RandomizedSet pLast = positions.get(lastVal);\\n\\t\\tpLast.remove(list.size() - 1);\\n\\t    pLast.insert(pDel);\\t\\t\\t\\n\\t\\tpVal.remove(pDel);\\n        if (pVal.size() == 0)\\n\\t\\t\\tpositions.remove(val);\\n\\t\\tlist.set(pDel, list.get(list.size() - 1));\\n\\t\\tlist.remove(list.size() - 1);\\n\\t\\treturn true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3253045,
                "title": "381-time-92-67-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis is an implementation of the Randomized Collection data structure in Python, which supports the following operations:\\n\\n1. insert(val: int) -> bool: Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n\\n2. remove(val: int) -> bool: Removes a value from the collection. Returns true if the collection contained the specified element.\\n\\n3. getRandom() -> int: Get a random element from the collection.\\n\\nThe implementation uses a list to store the values and a hash map to store the indices of each value in the list. The hash map is implemented using a dictionary data structure in Python.\\n\\n```\\nimport random\\n\\nclass RandomizedCollection:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.vals = [] # list to store values\\n        self.indices = {} # hash map to store indices of each value\\n```\\nThe __init__ method initializes the two data structures used by the RandomizedCollection class.\\n\\n```\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        self.vals.append(val) # add value to end of list\\n        if val in self.indices: # if value already exists in hash map\\n            self.indices[val].add(len(self.vals)-1) # add index to set of indices\\n            return False\\n        else:\\n            self.indices[val] = {len(self.vals)-1} # create new set with index\\n            return True\\n```\\nThe insert method adds a value to the end of the vals list, and if the value already exists in the indices hash map, it adds the index of the new value to the set of indices for that value. If the value does not exist in the hash map, it creates a new set with the index of the new value and adds it to the hash map. It returns true if the collection did not already contain the specified element.\\n\\n```\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        if val not in self.indices: # if value doesn\\'t exist in hash map\\n            return False\\n        \\n        index = self.indices[val].pop() # get an index of the value and remove it from set\\n        last_val = self.vals[-1] # get the last value in list\\n        if index != len(self.vals)-1: # if index is not the last index\\n            self.vals[index] = last_val # replace value at index with last value\\n            self.indices[last_val].discard(len(self.vals)-1) # remove last index from set\\n            self.indices[last_val].add(index) # add index to set of last value\\n        \\n        self.vals.pop() # remove last value from list\\n        if not self.indices[val]: # if set of indices is empty\\n            del self.indices[val] # remove key from hash map\\n        \\n        return True\\n```\\nThe remove method removes a value from the collection. If the value does not exist in the indices hash map, it returns false. Otherwise, it gets an index of the value from the set of indices for that value and removes it from the set. It also gets the last value in the vals list and replaces the value at the given index with the last value if the index is not the last index in the list. It then removes the last value from the list and removes the key from the\\n\\n# Complexity\\n- Time complexity:\\n92.67%\\n\\n- Space complexity:\\n13.13%\\n\\n# Code\\n```\\nclass RandomizedCollection:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.vals = [] # list to store values\\n        self.indices = {} # hash map to store indices of each value\\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        self.vals.append(val) # add value to end of list\\n        if val in self.indices: # if value already exists in hash map\\n            self.indices[val].add(len(self.vals)-1) # add index to set of indices\\n            return False\\n        else:\\n            self.indices[val] = {len(self.vals)-1} # create new set with index\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        if val not in self.indices: # if value doesn\\'t exist in hash map\\n            return False\\n        \\n        index = self.indices[val].pop() # get an index of the value and remove it from set\\n        last_val = self.vals[-1] # get the last value in list\\n        if index != len(self.vals)-1: # if index is not the last index\\n            self.vals[index] = last_val # replace value at index with last value\\n            self.indices[last_val].discard(len(self.vals)-1) # remove last index from set\\n            self.indices[last_val].add(index) # add index to set of last value\\n        \\n        self.vals.pop() # remove last value from list\\n        if not self.indices[val]: # if set of indices is empty\\n            del self.indices[val] # remove key from hash map\\n        \\n        return True\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the collection.\\n        \"\"\"\\n        return random.choice(self.vals) # return a random value from the list\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nimport random\\n\\nclass RandomizedCollection:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.vals = [] # list to store values\\n        self.indices = {} # hash map to store indices of each value\\n```\n```\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        self.vals.append(val) # add value to end of list\\n        if val in self.indices: # if value already exists in hash map\\n            self.indices[val].add(len(self.vals)-1) # add index to set of indices\\n            return False\\n        else:\\n            self.indices[val] = {len(self.vals)-1} # create new set with index\\n            return True\\n```\n```\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        if val not in self.indices: # if value doesn\\'t exist in hash map\\n            return False\\n        \\n        index = self.indices[val].pop() # get an index of the value and remove it from set\\n        last_val = self.vals[-1] # get the last value in list\\n        if index != len(self.vals)-1: # if index is not the last index\\n            self.vals[index] = last_val # replace value at index with last value\\n            self.indices[last_val].discard(len(self.vals)-1) # remove last index from set\\n            self.indices[last_val].add(index) # add index to set of last value\\n        \\n        self.vals.pop() # remove last value from list\\n        if not self.indices[val]: # if set of indices is empty\\n            del self.indices[val] # remove key from hash map\\n        \\n        return True\\n```\n```\\nclass RandomizedCollection:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.vals = [] # list to store values\\n        self.indices = {} # hash map to store indices of each value\\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        self.vals.append(val) # add value to end of list\\n        if val in self.indices: # if value already exists in hash map\\n            self.indices[val].add(len(self.vals)-1) # add index to set of indices\\n            return False\\n        else:\\n            self.indices[val] = {len(self.vals)-1} # create new set with index\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        if val not in self.indices: # if value doesn\\'t exist in hash map\\n            return False\\n        \\n        index = self.indices[val].pop() # get an index of the value and remove it from set\\n        last_val = self.vals[-1] # get the last value in list\\n        if index != len(self.vals)-1: # if index is not the last index\\n            self.vals[index] = last_val # replace value at index with last value\\n            self.indices[last_val].discard(len(self.vals)-1) # remove last index from set\\n            self.indices[last_val].add(index) # add index to set of last value\\n        \\n        self.vals.pop() # remove last value from list\\n        if not self.indices[val]: # if set of indices is empty\\n            del self.indices[val] # remove key from hash map\\n        \\n        return True\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the collection.\\n        \"\"\"\\n        return random.choice(self.vals) # return a random value from the list\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365770,
                "title": "easy-python-solution",
                "content": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.items = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.items.append(val)\\n        if self.items.count(val) > 1:\\n            return False\\n        else:\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.items:\\n            flag = True\\n            self.items.remove(val)\\n        else:\\n            flag = False\\n        \\n        return flag\\n\\n    def getRandom(self) -> int:\\n        return choice(self.items)\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.items = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.items.append(val)\\n        if self.items.count(val) > 1:\\n            return False\\n        else:\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.items:\\n            flag = True\\n            self.items.remove(val)\\n        else:\\n            flag = False\\n        \\n        return flag\\n\\n    def getRandom(self) -> int:\\n        return choice(self.items)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959350,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass RandomizedCollection {\\n    \\n    Random r;\\n    HashMap<Integer , HashSet<Integer>> map;\\n    ArrayList<Integer> list;\\n\\n    public RandomizedCollection() {\\n        list= new ArrayList<>();\\n        map= new HashMap<>();\\n        r= new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        list.add(val);\\n        if(map.containsKey(val)){\\n            \\n            HashSet<Integer>set = map.get(val);\\n            set.add(list.size()-1);\\n            \\n            return false;\\n        }else{\\n            HashSet<Integer> set = new HashSet<>();\\n            set.add(list.size()-1);\\n            map.put(val , set);\\n            return true;\\n        }\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)){\\n            \\n            int vidx = map.get(val).iterator().next(); \\n            int lidx = list.size()-1;\\n            int lval = list.get(lidx);\\n            \\n            list.set(lidx , val);\\n            list.set(vidx, lval);\\n            \\n            list.remove(lidx);\\n            map.get(val).remove(vidx);\\n            \\n            if(map.get(val).size()==0){\\n                map.remove(val);\\n            }\\n            \\n            if(map.containsKey(lval)){\\n                map.get(lval).remove(lidx);\\n                map.get(lval).add(vidx);\\n            }\\n            \\n            return true;\\n        }else{\\n            \\n            \\n            return false;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int idx= r.nextInt(list.size());\\n        return list.get(idx);\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\tclass RandomizedCollection {\\n    \\n    Random r;\\n    HashMap<Integer , HashSet<Integer>> map;\\n    ArrayList<Integer> list;\\n\\n    public RandomizedCollection() {\\n        list= new ArrayList<>();\\n        map= new HashMap<>();\\n        r= new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        list.add(val);\\n        if(map.containsKey(val)){\\n            \\n            HashSet<Integer>set = map.get(val);\\n            set.add(list.size()-1);\\n            \\n            return false;\\n        }else{\\n            HashSet<Integer> set = new HashSet<>();\\n            set.add(list.size()-1);\\n            map.put(val , set);\\n            return true;\\n        }\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)){\\n            \\n            int vidx = map.get(val).iterator().next(); \\n            int lidx = list.size()-1;\\n            int lval = list.get(lidx);\\n            \\n            list.set(lidx , val);\\n            list.set(vidx, lval);\\n            \\n            list.remove(lidx);\\n            map.get(val).remove(vidx);\\n            \\n            if(map.get(val).size()==0){\\n                map.remove(val);\\n            }\\n            \\n            if(map.containsKey(lval)){\\n                map.get(lval).remove(lidx);\\n                map.get(lval).add(vidx);\\n            }\\n            \\n            return true;\\n        }else{\\n            \\n            \\n            return false;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int idx= r.nextInt(list.size());\\n        return list.get(idx);\\n    }\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1485292,
                "title": "js-using-hashmap-and-arraylist-o-1-average-time",
                "content": "```\\nclass RandomizedCollection {\\n    constructor() {\\n        this.nums = [];\\n        this.valIdxs = new Map();\\n    }\\n    insert(val) {\\n        this.nums.push(val);\\n        const isNewVal = !this.valIdxs.has(val) || this.valIdxs.get(val).size === 0;\\n        const idxSet = isNewVal ? new Set() : this.valIdxs.get(val);\\n        idxSet.add(this.nums.length - 1);\\n        this.valIdxs.set(val, idxSet);\\n        return isNewVal;\\n    }\\n    remove(val) {\\n        if(!this.valIdxs.has(val) || this.valIdxs.get(val).size === 0) {\\n            return false;\\n        }\\n        const valIdxSet = this.valIdxs.get(val);\\n        let removeIdx = this.nums.length - 1;\\n        if(!valIdxSet.has(removeIdx)) {\\n            const replaceVal = this.nums[this.nums.length - 1];\\n            removeIdx = valIdxSet.values().next().value;\\n            \\n            [this.nums[removeIdx], this.nums[this.nums.length - 1]] = [this.nums[this.nums.length - 1], this.nums[removeIdx]]\\n            \\n            this.valIdxs.get(replaceVal).delete(this.nums.length - 1);\\n            this.valIdxs.get(replaceVal).add(removeIdx);\\n        }\\n        this.valIdxs.get(val).delete(removeIdx);\\n        this.nums.pop();\\n        return true;\\n    }\\n    getRandom() {\\n        const randomIdx = Math.floor(Math.random() * this.nums.length);\\n        return this.nums[randomIdx];\\n    }\\n}\\n```\\nTime Complexity = O(1) average time for each operation\\nSpace Complexity = O(n) [arrayList and hashMap]",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    constructor() {\\n        this.nums = [];\\n        this.valIdxs = new Map();\\n    }\\n    insert(val) {\\n        this.nums.push(val);\\n        const isNewVal = !this.valIdxs.has(val) || this.valIdxs.get(val).size === 0;\\n        const idxSet = isNewVal ? new Set() : this.valIdxs.get(val);\\n        idxSet.add(this.nums.length - 1);\\n        this.valIdxs.set(val, idxSet);\\n        return isNewVal;\\n    }\\n    remove(val) {\\n        if(!this.valIdxs.has(val) || this.valIdxs.get(val).size === 0) {\\n            return false;\\n        }\\n        const valIdxSet = this.valIdxs.get(val);\\n        let removeIdx = this.nums.length - 1;\\n        if(!valIdxSet.has(removeIdx)) {\\n            const replaceVal = this.nums[this.nums.length - 1];\\n            removeIdx = valIdxSet.values().next().value;\\n            \\n            [this.nums[removeIdx], this.nums[this.nums.length - 1]] = [this.nums[this.nums.length - 1], this.nums[removeIdx]]\\n            \\n            this.valIdxs.get(replaceVal).delete(this.nums.length - 1);\\n            this.valIdxs.get(replaceVal).add(removeIdx);\\n        }\\n        this.valIdxs.get(val).delete(removeIdx);\\n        this.nums.pop();\\n        return true;\\n    }\\n    getRandom() {\\n        const randomIdx = Math.floor(Math.random() * this.nums.length);\\n        return this.nums[randomIdx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85622,
                "title": "c-updated-solution-with-unordered-map-and-set",
                "content": "```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        m[val].insert(v.size());\\n        v.push_back(val);\\n        return m[val].size() == 1;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (!m.count(val)) {\\n            return false;\\n        }\\n        int last = v.back();\\n        int pos = *(m[val].rbegin());\\n        m[last].erase(*(m[last].rbegin()));\\n        m[last].insert(pos);\\n        v[pos] = last;\\n        v.pop_back();\\n        if (m[val].size() > 1) {\\n            m[val].erase(*(m[val].rbegin()));\\n        } else {\\n            m.erase(val);\\n        }\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return v[rand() % v.size()];\\n    }\\n    \\nprivate:\\n    vector<int> v;\\n    unordered_map<int, set<int>> m;\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.insert(val);\\n * bool param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        m[val].insert(v.size());\\n        v.push_back(val);\\n        return m[val].size() == 1;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (!m.count(val)) {\\n            return false;\\n        }\\n        int last = v.back();\\n        int pos = *(m[val].rbegin());\\n        m[last].erase(*(m[last].rbegin()));\\n        m[last].insert(pos);\\n        v[pos] = last;\\n        v.pop_back();\\n        if (m[val].size() > 1) {\\n            m[val].erase(*(m[val].rbegin()));\\n        } else {\\n            m.erase(val);\\n        }\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return v[rand() % v.size()];\\n    }\\n    \\nprivate:\\n    vector<int> v;\\n    unordered_map<int, set<int>> m;\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.insert(val);\\n * bool param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85599,
                "title": "c-solution-with-unordered-multimap",
                "content": "```\\n\\nclass RandomizedCollection {\\n    unordered_multimap<int, int> Map;\\n    typedef unordered_multimap<int,int>::iterator Itr;\\n    vector<Itr> Vec;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        std::srand(std::time(0));\\n        std::srand(std::time(0));\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ret = Map.count(val) == 0;\\n        auto it = Map.insert({val,-1});\\n        it->second = Vec.size();  //change the -1 to the index in the vector\\n        Vec.push_back(it);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(Vec.empty()) return false;\\n        auto it = Map.find(val); if(it == Map.end() ) return false;\\n        int index = it->second;\\n        (Vec.back())->second = index;  //change the object inside the Map\\n        swap(Vec[Vec.size()-1], Vec[index]);  //move the object to be removed to the back of vector\\n        Vec.pop_back();\\n        Map.erase(it);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int random = std::rand();\\n        random %= Vec.size();\\n        return Vec[random]->first; //First is the value! Don't be careless!\\n    }\\n};\\n\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.insert(val);\\n * bool param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */",
                "solutionTags": [],
                "code": "```\\n\\nclass RandomizedCollection {\\n    unordered_multimap<int, int> Map;\\n    typedef unordered_multimap<int,int>::iterator Itr;\\n    vector<Itr> Vec;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        std::srand(std::time(0));\\n        std::srand(std::time(0));\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ret = Map.count(val) == 0;\\n        auto it = Map.insert({val,-1});\\n        it->second = Vec.size();  //change the -1 to the index in the vector\\n        Vec.push_back(it);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(Vec.empty()) return false;\\n        auto it = Map.find(val); if(it == Map.end() ) return false;\\n        int index = it->second;\\n        (Vec.back())->second = index;  //change the object inside the Map\\n        swap(Vec[Vec.size()-1], Vec[index]);  //move the object to be removed to the back of vector\\n        Vec.pop_back();\\n        Map.erase(it);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int random = std::rand();\\n        random %= Vec.size();\\n        return Vec[random]->first; //First is the value! Don't be careless!\\n    }\\n};\\n\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.insert(val);\\n * bool param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 85542,
                "title": "c-solution-using-map-and-vector-with-detailed-explanation",
                "content": "It is obvious that we should use hash map to achieve O(1) insert and remove.\\nBut how to achieve O(1) getRandom() remains a problem.\\nHere is what I think:\\nwe use vector *arr* to store all the elements in this collection, so that \\n```\\narr[rand()%arr.size()]\\n```\\nwill help to realize getRandom() in O(1).\\nEvery time we want to remove an element, we swap this element with the last element in *arr* and then pop back the last element.\\n\\nAnd in hash map, the element value is the key, and its index in the *arr* is the value.\\nEvery time we remove an element A, we should remove A both from map and *arr*. \\n```\\nclass RandomizedCollection {\\nprivate:\\n    map<int, vector<int>> dic;\\n    vector<int> arr;\\n    \\npublic:\\n    RandomizedCollection() {\\n    }\\n\\n    bool insert(int val) {\\n        arr.push_back(val);//add val in arr\\n        dic[val].push_back(arr.size() - 1);//add its index in dic[val]\\n        return dic[val].size() == 1;\\n    }\\n    \\n    bool remove(int val) {\\n        if(dic[val].size() == 0)\\n        {\\n            return false;\\n        }\\n        int idx = dic[val].back();//arr[idx] = val\\n        dic[val].pop_back();\\n       //swap arr[idx] and arr[arr.size()-1] if idx != arr.size()-1\\n       //modify the dic at the same time.\\n        if(arr.size() - 1 != idx);\\n        {\\n            int tmp = arr.back();\\n            arr[idx] = tmp;\\n     //the new index of tmp is now idx, so modify the dic accordingly.\\n            dic[tmp].pop_back();\\n            dic[tmp].push_back(idx);\\n        }\\n       //remove the last element in arr\\n        arr.pop_back();\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return arr[rand()%arr.size()];\\n    }\\n};\\n```\\nComments are welcomed!",
                "solutionTags": [],
                "code": "```\\narr[rand()%arr.size()]\\n```\n```\\nclass RandomizedCollection {\\nprivate:\\n    map<int, vector<int>> dic;\\n    vector<int> arr;\\n    \\npublic:\\n    RandomizedCollection() {\\n    }\\n\\n    bool insert(int val) {\\n        arr.push_back(val);//add val in arr\\n        dic[val].push_back(arr.size() - 1);//add its index in dic[val]\\n        return dic[val].size() == 1;\\n    }\\n    \\n    bool remove(int val) {\\n        if(dic[val].size() == 0)\\n        {\\n            return false;\\n        }\\n        int idx = dic[val].back();//arr[idx] = val\\n        dic[val].pop_back();\\n       //swap arr[idx] and arr[arr.size()-1] if idx != arr.size()-1\\n       //modify the dic at the same time.\\n        if(arr.size() - 1 != idx);\\n        {\\n            int tmp = arr.back();\\n            arr[idx] = tmp;\\n     //the new index of tmp is now idx, so modify the dic accordingly.\\n            dic[tmp].pop_back();\\n            dic[tmp].push_back(idx);\\n        }\\n       //remove the last element in arr\\n        arr.pop_back();\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return arr[rand()%arr.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820976,
                "title": "java-hashmap-arraylist",
                "content": "### **Please Upvote** :D\\n```\\nclass RandomizedCollection {\\n    List<Integer> list;\\n    Map<Integer, Set<Integer>> map;\\n\\n    public RandomizedCollection() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (!map.containsKey(val)) {\\n            map.put(val, new HashSet<>());\\n        }\\n\\n        map.get(val).add(list.size());\\n        list.add(val);\\n\\n        return map.get(val).size() == 1;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val) || map.get(val).isEmpty()) return false;\\n\\n        int removeIdx = map.get(val).iterator().next();\\n        map.get(val).remove(removeIdx);\\n\\n        int lastElement = list.get(list.size() - 1);\\n        list.set(removeIdx, lastElement);\\n\\n        map.get(lastElement).add(removeIdx);\\n        map.get(lastElement).remove(list.size() - 1);\\n\\n        list.remove(list.size() - 1);\\n\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        int randomIdx = (int) (Math.random() * list.size());\\n        return list.get(randomIdx);\\n    }\\n}\\n\\n// TC: O(1) - O(1) - O(1)\\n// SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    List<Integer> list;\\n    Map<Integer, Set<Integer>> map;\\n\\n    public RandomizedCollection() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (!map.containsKey(val)) {\\n            map.put(val, new HashSet<>());\\n        }\\n\\n        map.get(val).add(list.size());\\n        list.add(val);\\n\\n        return map.get(val).size() == 1;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val) || map.get(val).isEmpty()) return false;\\n\\n        int removeIdx = map.get(val).iterator().next();\\n        map.get(val).remove(removeIdx);\\n\\n        int lastElement = list.get(list.size() - 1);\\n        list.set(removeIdx, lastElement);\\n\\n        map.get(lastElement).add(removeIdx);\\n        map.get(lastElement).remove(list.size() - 1);\\n\\n        list.remove(list.size() - 1);\\n\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        int randomIdx = (int) (Math.random() * list.size());\\n        return list.get(randomIdx);\\n    }\\n}\\n\\n// TC: O(1) - O(1) - O(1)\\n// SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672220,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass RandomizedCollection {\\npublic:\\n    vector<int>v;\\n    unordered_map<int,int>mp;\\n    RandomizedCollection() \\n    {\\n       \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp[val] == 0)  \\n        {\\n            v.push_back(val);\\n            mp[val]++;   \\n            return true;\\n        }\\n        else if(mp[val] > 0)   \\n        {\\n            v.push_back(val);\\n            mp[val]++;\\n            return false;\\n        }\\n        return false;   \\n    }\\n    \\n    bool remove(int val) \\n    {\\n         if(mp[val] > 0) \\n         {\\n             auto it = find(v.begin(),v.end(),val);\\n             v.erase(it);\\n             mp[val]--;\\n             return true;\\n         }\\n         return false;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    vector<int>v;\\n    unordered_map<int,int>mp;\\n    RandomizedCollection() \\n    {\\n       \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp[val] == 0)  \\n        {\\n            v.push_back(val);\\n            mp[val]++;   \\n            return true;\\n        }\\n        else if(mp[val] > 0)   \\n        {\\n            v.push_back(val);\\n            mp[val]++;\\n            return false;\\n        }\\n        return false;   \\n    }\\n    \\n    bool remove(int val) \\n    {\\n         if(mp[val] > 0) \\n         {\\n             auto it = find(v.begin(),v.end(),val);\\n             v.erase(it);\\n             mp[val]--;\\n             return true;\\n         }\\n         return false;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651537,
                "title": "c-must-look-faster-than-88-91",
                "content": "```\\nclass RandomizedCollection {\\npublic:\\n    vector<int>v;\\n    unordered_map<int,int>mp;\\n    RandomizedCollection() \\n    {\\n        //no code\\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp[val] == 0)  //the element is not present yet in the vector or map\\n        {\\n            v.push_back(val);\\n            mp[val]++;   //due to the reazon of duplicate \\n            return true;\\n        }\\n        else if(mp[val] > 0)   //it is present in the vector or mp\\n        {\\n            v.push_back(val);\\n            mp[val]++;\\n            return false;\\n        }\\n        return false;    //this will not get encounterd\\n    }\\n    \\n    bool remove(int val) \\n    {\\n         if(mp[val] > 0)  //the element is present\\n         {\\n             auto it = find(v.begin(),v.end(),val);\\n             v.erase(it);\\n             mp[val]--;\\n             return true;\\n         }\\n         return false;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    vector<int>v;\\n    unordered_map<int,int>mp;\\n    RandomizedCollection() \\n    {\\n        //no code\\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp[val] == 0)  //the element is not present yet in the vector or map\\n        {\\n            v.push_back(val);\\n            mp[val]++;   //due to the reazon of duplicate \\n            return true;\\n        }\\n        else if(mp[val] > 0)   //it is present in the vector or mp\\n        {\\n            v.push_back(val);\\n            mp[val]++;\\n            return false;\\n        }\\n        return false;    //this will not get encounterd\\n    }\\n    \\n    bool remove(int val) \\n    {\\n         if(mp[val] > 0)  //the element is present\\n         {\\n             auto it = find(v.begin(),v.end(),val);\\n             v.erase(it);\\n             mp[val]--;\\n             return true;\\n         }\\n         return false;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890814,
                "title": "c-solution-using-vector-and-unordered-map",
                "content": "Here the Data Structure used is  `vector<int>` of int and `unordered_map<int,set<int>>`.\\n* In `vector<int>` we will store the elements inserted and in `unordered_map<int,set<int>>` , key is the number in the array and in set we will store  the indices of the vector where the key has been kept.\\n\\n\\nGo Through logic:\\n1. \\tFor Insertion we need to insert the element in the vector(array) and unordered_map[key]. And we need to increase the size of the array.\\n2. \\tFor Deletion we need to delete any occurance from the array so here we will delete the last occurance of the number but now as we have an empty place in the array we need to fill it so here we will fill it with the last inserted element of the array. And we will change the Mapping in the unordered map accordingly that is we will remove last occurance of the element to be deleted and we will delete the last occurance of the last inserted element in the array and insert the index where we have deleted the current element.\\n3. \\tFor getRandom we have used the inbuilt function rand() in c++\\n\\nImplementation :-\\n\\n```\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int,set<int>> um;\\n    vector<int> v;\\n    int size;\\n    RandomizedCollection() {\\n        v.resize(100005,-1);\\n        size=0;\\n    }\\n    \\n    bool insert(int val) {\\n        bool flag;\\n        if(um.count(val))\\n            flag=false;\\n        else\\n            flag=true;\\n        um[val].insert(size);\\n        v[size] = val;\\n        size++;\\n        return flag;\\n    }\\n    \\n    bool remove(int val) {\\n        if(um.count(val) == 0)\\n            return false;\\n        auto it = um[val].end();\\n        --it;\\n        int x = *it;\\n        um[val].erase(it);\\n        if(um[val].size() == 0)\\n            um.erase(val);\\n        if(size == 1 || x == size-1)\\n        {\\n            size--;\\n            v[x] = -1;\\n            return true;\\n        }\\n        v[x] = v[size-1];\\n        it = um[v[size-1]].end();\\n        --it;\\n        um[v[size-1]].erase(it);\\n        um[v[size-1]].insert(x);\\n        v[size-1]=-1;\\n        size--;\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand()%size];\\n    }\\n};\\n```\\nPlease Upvote if you like :).",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int,set<int>> um;\\n    vector<int> v;\\n    int size;\\n    RandomizedCollection() {\\n        v.resize(100005,-1);\\n        size=0;\\n    }\\n    \\n    bool insert(int val) {\\n        bool flag;\\n        if(um.count(val))\\n            flag=false;\\n        else\\n            flag=true;\\n        um[val].insert(size);\\n        v[size] = val;\\n        size++;\\n        return flag;\\n    }\\n    \\n    bool remove(int val) {\\n        if(um.count(val) == 0)\\n            return false;\\n        auto it = um[val].end();\\n        --it;\\n        int x = *it;\\n        um[val].erase(it);\\n        if(um[val].size() == 0)\\n            um.erase(val);\\n        if(size == 1 || x == size-1)\\n        {\\n            size--;\\n            v[x] = -1;\\n            return true;\\n        }\\n        v[x] = v[size-1];\\n        it = um[v[size-1]].end();\\n        --it;\\n        um[v[size-1]].erase(it);\\n        um[v[size-1]].insert(x);\\n        v[size-1]=-1;\\n        size--;\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand()%size];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214992,
                "title": "c-constant-time-operations-array-hashset-hashmap",
                "content": "This solution relies on taking advantage of the speed of an `unordered_set` for its constant time lookup, addition, and removal operations, while using a `vector` as a storage container which supports constant time addition and removal (from the end), while also having the added benefit of having constant time random access.\\n\\nTo start, we declare `indices` and `store`:\\n- `store` is a container where we push and pop elements that are being added to our data structure. We will only be manipulating the end of this structure, so we can be confident that all these operations will take constant time\\n- `indices` is a structure we will use to track the indexes *within `store`* that are occupied by a particular value (i.e. if `store` is `[1, 1, 2, 3]`) the indices will have 3 unique entries: `{[1: (0, 1)], [2: (2)], [3: (3)]}`, one for each unique value in store containing a set of all indices at which that element occurs. We are using a set because it conveniently supports constant time lookup operations\\n\\nGoing from here, we will define our operations. To insert a value into the structure, we simply append it to the end of `store` and then add the newly-created index to the corresponding `hashset` for that key in the hashmap. This can be done in constant time since we are appending to the end of a `vector` and are updating a `hashmap`, and then we return in the size of the `hashset` inserted into is 1, since this means that this is the only value inside it and therefore the value was not present in the structure prior. \\n\\nTo remove a value in the structure, we first check if it was in the structure to begin with. If it isn\\'t we return `false`, otherwise we continue. Using a random access iterator, which operates in constant time, we choose the \"first\" element in the hashset (the first one outputted by the iterator). This gives us an index where our desired value occurs. Then, we swap this value with the first value in the `store` list (which can be done in constant time, since `vector` supports constant time swap operations), and then we continue on to removing it from the `vector`. From there, we can remove the index where the target value occurs from its `hashset`, and update the swapped value\\'s location in its own `hashset`. We must take care to only do this when the two indices differ, because otherwise we will have data inconsistency in our table.\\n\\nFinally, retrieving a random value is as simple as just selecting a random position in the array and returning the value there. Each index is equiprobable, so the probability of a given value is just the frequency at which it occurs * `1 / len(store)`, fulfilling the linear scaling requirement.\\n\\nAs we can see, all these operations can be done in constant time, leaving us with the desired data structure.\\n\\n```\\n/** Initialize your data structure here. */\\nunordered_map<int, unordered_set<int>> indices;\\nvector<int> store;\\nRandomizedCollection() {\\n\\n}\\n\\n/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\nbool insert(int val) {\\n\\tindices[val].insert(store.size());\\n\\tstore.push_back(val);\\n\\treturn indices[val].size() == 1 ? true : false;\\n}\\n\\n/** Removes a value from the collection. Returns true if the collection contained the specified element. */\\nbool remove(int val) {\\n\\tif (!indices[val].size()) {\\n\\t\\treturn false;\\n\\t}\\n\\tauto it = indices[val].begin();\\n\\tint targetind = *it, swapind = store.size() - 1, swapval = store.back();\\n\\tswap(store[swapind], store[targetind]);\\n\\tstore.pop_back();\\n\\tindices[val].erase(targetind);\\n\\tif (swapind != targetind) {\\n\\t\\tindices[swapval].erase(swapind);\\n\\t\\tindices[swapval].insert(targetind); \\n\\t}\\n\\treturn true;\\n}\\n\\n/** Get a random element from the collection. */\\nint getRandom() {\\n\\treturn store[rand() % store.size()];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/** Initialize your data structure here. */\\nunordered_map<int, unordered_set<int>> indices;\\nvector<int> store;\\nRandomizedCollection() {\\n\\n}\\n\\n/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\nbool insert(int val) {\\n\\tindices[val].insert(store.size());\\n\\tstore.push_back(val);\\n\\treturn indices[val].size() == 1 ? true : false;\\n}\\n\\n/** Removes a value from the collection. Returns true if the collection contained the specified element. */\\nbool remove(int val) {\\n\\tif (!indices[val].size()) {\\n\\t\\treturn false;\\n\\t}\\n\\tauto it = indices[val].begin();\\n\\tint targetind = *it, swapind = store.size() - 1, swapval = store.back();\\n\\tswap(store[swapind], store[targetind]);\\n\\tstore.pop_back();\\n\\tindices[val].erase(targetind);\\n\\tif (swapind != targetind) {\\n\\t\\tindices[swapval].erase(swapind);\\n\\t\\tindices[swapval].insert(targetind); \\n\\t}\\n\\treturn true;\\n}\\n\\n/** Get a random element from the collection. */\\nint getRandom() {\\n\\treturn store[rand() % store.size()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 956270,
                "title": "kotlin-c-o-1-time-and-o-n-space-with-hashmap-hashset-and-vector",
                "content": "````\\n// Kotlin\\n\\nclass RandomizedCollection() {\\n\\n    /** Initialize your data structure here. */\\n    val map = HashMap<Int, HashSet<Int>>()\\n    val arr = ArrayList<Int>()\\n    val rand = Random()\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    fun insert(`val`: Int): Boolean {\\n        arr.add(`val`)\\n        map.getOrPut(`val`, { HashSet() }).add(arr.size - 1)\\n        return true\\n    }\\n\\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    fun remove(`val`: Int): Boolean {\\n        if (!map.contains(`val`)) return false\\n\\n        val index = map[`val`]!!.iterator().next()\\n        map[`val`]!!.remove(index)\\n\\n        arr[index] = arr[arr.size - 1]\\n        map[arr[index]]!!.add(index)\\n\\n        map[arr[index]]!!.remove(arr.size - 1)\\n        arr.removeAt(arr.size - 1)\\n        if (map[`val`]!!.isEmpty()) map.remove(`val`)\\n        return true\\n    }\\n\\n    /** Get a random element from the collection. */\\n    fun getRandom(): Int {\\n        return arr[rand.nextInt(arr.size)]\\n    }\\n}\\n\\n// C++\\n\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        arr.push_back(val);\\n        map[val].insert(arr.size() - 1);\\n        return true;    \\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (!map.count(val)) return false;\\n\\n        int index = *begin(map[val]);\\n        map[val].erase(index);\\n\\n        int last = arr.back();\\n        arr[index] = last;\\n\\n        map[last].insert(index);\\n        map[last].erase(arr.size() - 1);\\n        arr.pop_back();\\n\\n        if (map[val].empty()) map.erase(val);\\n\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        int index = rand() % arr.size();\\n        return arr[index];\\n    }\\nprivate:\\n    unordered_map<int, unordered_set<int>> map;\\n    vector<int> arr;\\n};\\n",
                "solutionTags": [],
                "code": "````\\n// Kotlin\\n\\nclass RandomizedCollection() {\\n\\n    /** Initialize your data structure here. */\\n    val map = HashMap<Int, HashSet<Int>>()\\n    val arr = ArrayList<Int>()\\n    val rand = Random()\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    fun insert(`val`: Int): Boolean {\\n        arr.add(`val`)\\n        map.getOrPut(`val`, { HashSet() }).add(arr.size - 1)\\n        return true\\n    }\\n\\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    fun remove(`val`: Int): Boolean {\\n        if (!map.contains(`val`)) return false\\n\\n        val index = map[`val`]!!.iterator().next()\\n        map[`val`]!!.remove(index)\\n\\n        arr[index] = arr[arr.size - 1]\\n        map[arr[index]]!!.add(index)\\n\\n        map[arr[index]]!!.remove(arr.size - 1)\\n        arr.removeAt(arr.size - 1)\\n        if (map[`val`]!!.isEmpty()) map.remove(`val`)\\n        return true\\n    }\\n\\n    /** Get a random element from the collection. */\\n    fun getRandom(): Int {\\n        return arr[rand.nextInt(arr.size)]\\n    }\\n}\\n\\n// C++\\n\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        arr.push_back(val);\\n        map[val].insert(arr.size() - 1);\\n        return true;    \\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (!map.count(val)) return false;\\n\\n        int index = *begin(map[val]);\\n        map[val].erase(index);\\n\\n        int last = arr.back();\\n        arr[index] = last;\\n\\n        map[last].insert(index);\\n        map[last].erase(arr.size() - 1);\\n        arr.pop_back();\\n\\n        if (map[val].empty()) map.erase(val);\\n\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        int index = rand() % arr.size();\\n        return arr[index];\\n    }\\nprivate:\\n    unordered_map<int, unordered_set<int>> map;\\n    vector<int> arr;\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 583955,
                "title": "easy-java-solution",
                "content": "```\\nclass RandomizedCollection {\\n    static class Node {\\n        int index, value;\\n        public Node(int i, int v) {\\n            index = i;\\n            value = v;\\n        }\\n    }\\n\\n    HashMap<Integer, LinkedList<Node>> valueToNodes = new HashMap<Integer, LinkedList<Node>>();\\n    ArrayList<Node> arr = new ArrayList<Node>();\\n    Random rand = new Random();\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        LinkedList<Node> nodes = valueToNodes.get(val);\\n        boolean res = false;\\n        if (nodes == null) {\\n            nodes = new LinkedList<Node>();\\n            valueToNodes.put(val, nodes);\\n            res = true;\\n        }\\n        Node node = new Node(arr.size(), val);\\n        arr.add(node);\\n        nodes.add(node);\\n        return res;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        LinkedList<Node> nodes = valueToNodes.get(val);\\n        if (nodes == null) {\\n            return false;\\n        }\\n        Node nodeToRemove = nodes.removeFirst();\\n        if (nodes.isEmpty()) {\\n            valueToNodes.remove(val);\\n        }\\n        int lastIndexInArr = arr.size() - 1;\\n        if (nodeToRemove.index == lastIndexInArr) {\\n            arr.remove(lastIndexInArr);\\n        } else {\\n            Node lastNode = arr.get(lastIndexInArr);\\n            lastNode.index = nodeToRemove.index;\\n            arr.set(lastNode.index, lastNode);\\n            arr.remove(lastIndexInArr);                \\n        }\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return arr.get(rand.nextInt(arr.size())).value;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    static class Node {\\n        int index, value;\\n        public Node(int i, int v) {\\n            index = i;\\n            value = v;\\n        }\\n    }\\n\\n    HashMap<Integer, LinkedList<Node>> valueToNodes = new HashMap<Integer, LinkedList<Node>>();\\n    ArrayList<Node> arr = new ArrayList<Node>();\\n    Random rand = new Random();\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        LinkedList<Node> nodes = valueToNodes.get(val);\\n        boolean res = false;\\n        if (nodes == null) {\\n            nodes = new LinkedList<Node>();\\n            valueToNodes.put(val, nodes);\\n            res = true;\\n        }\\n        Node node = new Node(arr.size(), val);\\n        arr.add(node);\\n        nodes.add(node);\\n        return res;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        LinkedList<Node> nodes = valueToNodes.get(val);\\n        if (nodes == null) {\\n            return false;\\n        }\\n        Node nodeToRemove = nodes.removeFirst();\\n        if (nodes.isEmpty()) {\\n            valueToNodes.remove(val);\\n        }\\n        int lastIndexInArr = arr.size() - 1;\\n        if (nodeToRemove.index == lastIndexInArr) {\\n            arr.remove(lastIndexInArr);\\n        } else {\\n            Node lastNode = arr.get(lastIndexInArr);\\n            lastNode.index = nodeToRemove.index;\\n            arr.set(lastNode.index, lastNode);\\n            arr.remove(lastIndexInArr);                \\n        }\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return arr.get(rand.nextInt(arr.size())).value;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316981,
                "title": "c-numberandindexset-and-numberlist",
                "content": "```\\npublic class RandomizedCollection\\n{\\n    Random random = new Random();\\n    Dictionary<int, HashSet<int>> numberAndIndexSet = new Dictionary<int, HashSet<int>>();\\n    IList<int> numberList = new List<int>();\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection()\\n    {\\n         \\n    }\\n     \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public bool Insert(int val)\\n    {\\n        if (numberAndIndexSet.ContainsKey(val))\\n        {\\n            numberList.Add(val);\\n            numberAndIndexSet[val].Add(numberList.Count - 1);\\n            return false;\\n        }\\n        else\\n        {\\n            numberList.Add(val);\\n            numberAndIndexSet[val] = new HashSet<int>(){numberList.Count - 1};\\n            return true;\\n        }\\n    }\\n     \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public bool Remove(int val)\\n    {\\n        if (!numberAndIndexSet.ContainsKey(val)) return false;\\n \\n        var curIndex = numberAndIndexSet[val].First();\\n         \\n        numberAndIndexSet[val].Remove(curIndex);\\n        if (!numberAndIndexSet[val].Any())  numberAndIndexSet.Remove(val);\\n \\n        if (curIndex == numberList.Count - 1)\\n        {\\n            numberList.RemoveAt(numberList.Count - 1);\\n        }\\n        else\\n        {\\n            var needToModifiedNumber = numberList[numberList.Count - 1];\\n            numberList[curIndex] = needToModifiedNumber;\\n            numberList.RemoveAt(numberList.Count - 1);\\n \\n            numberAndIndexSet[needToModifiedNumber].Remove(numberList.Count);\\n            numberAndIndexSet[needToModifiedNumber].Add(curIndex);           \\n        }\\n \\n        return true;\\n    }\\n     \\n    /** Get a random element from the collection. */\\n    public int GetRandom()\\n    {\\n        var randomIndex = random.Next(numberList.Count);\\n \\n        return numberList[randomIndex];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedCollection\\n{\\n    Random random = new Random();\\n    Dictionary<int, HashSet<int>> numberAndIndexSet = new Dictionary<int, HashSet<int>>();\\n    IList<int> numberList = new List<int>();\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection()\\n    {\\n         \\n    }\\n     \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public bool Insert(int val)\\n    {\\n        if (numberAndIndexSet.ContainsKey(val))\\n        {\\n            numberList.Add(val);\\n            numberAndIndexSet[val].Add(numberList.Count - 1);\\n            return false;\\n        }\\n        else\\n        {\\n            numberList.Add(val);\\n            numberAndIndexSet[val] = new HashSet<int>(){numberList.Count - 1};\\n            return true;\\n        }\\n    }\\n     \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public bool Remove(int val)\\n    {\\n        if (!numberAndIndexSet.ContainsKey(val)) return false;\\n \\n        var curIndex = numberAndIndexSet[val].First();\\n         \\n        numberAndIndexSet[val].Remove(curIndex);\\n        if (!numberAndIndexSet[val].Any())  numberAndIndexSet.Remove(val);\\n \\n        if (curIndex == numberList.Count - 1)\\n        {\\n            numberList.RemoveAt(numberList.Count - 1);\\n        }\\n        else\\n        {\\n            var needToModifiedNumber = numberList[numberList.Count - 1];\\n            numberList[curIndex] = needToModifiedNumber;\\n            numberList.RemoveAt(numberList.Count - 1);\\n \\n            numberAndIndexSet[needToModifiedNumber].Remove(numberList.Count);\\n            numberAndIndexSet[needToModifiedNumber].Add(curIndex);           \\n        }\\n \\n        return true;\\n    }\\n     \\n    /** Get a random element from the collection. */\\n    public int GetRandom()\\n    {\\n        var randomIndex = random.Next(numberList.Count);\\n \\n        return numberList[randomIndex];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254900,
                "title": "clean-java-code-beats-99-just-use-hashmap-and-linkedlist",
                "content": "Here we just need HashMap and LinkedList\\n\\n1. we create a node class\\n\\n```\\n\\tclass Node {\\n\\t\\tint val;     // store the value\\n\\t\\tint index     // store the index\\n\\t\\tNode(int val, int index) {\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.index = index;\\n\\t\\t}\\n\\t}\\n```\\n\\n2. create a HashMap used to store all the nodes with the same value\\n```\\n\\tHashMap<Integer, LinkedList<Node>> nums = new HashMap<>();\\n```\\n\\n3. create a HashMap to store the index and its corresbonding node\\n\\n```\\n\\tHashMap<Integer, Node> indexs = new HashMap<>();\\n```\\n\\nThen, we can start to finish all functions with the data structure:\\n\\n1. insert: We just need to create a node with value and current index, insert it into nums and indexs\\n\\n```\\n\\tNode node = new Node(val, index.size());\\n\\tnums.get(val).addFirst(node);\\n\\tindex.put(index.size(), node);\\n```\\n\\n2. remove: more complicated, we need to get a random node in the nums with the giving value, and exchange this node and the last node in the index map. Then delete the last node. ( Exchange is important because we need to make sure other indexes will not be changed and utilize all indexes in the range)\\n```\\n\\tint size = nums.get(val).size();\\n\\tNode node = nums.get(val).getFirst();\\n\\tif (size == 1) {\\n\\t\\tnums.remove(val);\\n\\t} else {\\n\\t\\tnums.get(val).removeFirst();\\n\\t}\\n\\tint idx = node.index;\\n\\tNode last = index.get(index.size() - 1);\\n\\tlast.index = idx;\\n\\tindex.put(idx, last);\\n\\tindex.remove(index.size() - 1);\\n```\\n\\n3. getRandom: much easier because we can use index here\\n\\n```\\n\\tint random = (int)(Math.random() * index.size());\\n\\treturn index.get(random).val;\\n```\\n\\n\\nBelow is the code:\\n```\\nclass RandomizedCollection {\\n\\n    class Node {\\n        int val;\\n        int index;\\n        Node (int x, int y) {\\n            val = x;\\n            index = y;\\n        }\\n    }\\n\\n    private HashMap<Integer, LinkedList<Node>> nums;\\n    private HashMap<Integer, Node> index;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        nums = new HashMap<>();\\n        index = new HashMap<>();\\n    }\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean res = !nums.containsKey(val);\\n        if (res) nums.put(val, new LinkedList<>());\\n        Node node = new Node(val, index.size());\\n        nums.get(val).addFirst(node);\\n        index.put(index.size(), node);\\n        return res;\\n    }\\n\\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        boolean res = nums.containsKey(val);\\n        if (res) {\\n            int size = nums.get(val).size();\\n            Node node = nums.get(val).getFirst();\\n            if (size == 1) {\\n                nums.remove(val);\\n            } else {\\n                nums.get(val).removeFirst();\\n            }\\n            int idx = node.index;\\n            Node last = index.get(index.size() - 1);\\n            last.index = idx;\\n            index.put(idx, last);\\n            index.remove(index.size() - 1);\\n        }\\n\\n        return res;\\n    }\\n\\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        int random = (int)(Math.random() * index.size());\\n        return index.get(random).val;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\tclass Node {\\n\\t\\tint val;     // store the value\\n\\t\\tint index     // store the index\\n\\t\\tNode(int val, int index) {\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.index = index;\\n\\t\\t}\\n\\t}\\n```\n```\\n\\tHashMap<Integer, LinkedList<Node>> nums = new HashMap<>();\\n```\n```\\n\\tHashMap<Integer, Node> indexs = new HashMap<>();\\n```\n```\\n\\tNode node = new Node(val, index.size());\\n\\tnums.get(val).addFirst(node);\\n\\tindex.put(index.size(), node);\\n```\n```\\n\\tint size = nums.get(val).size();\\n\\tNode node = nums.get(val).getFirst();\\n\\tif (size == 1) {\\n\\t\\tnums.remove(val);\\n\\t} else {\\n\\t\\tnums.get(val).removeFirst();\\n\\t}\\n\\tint idx = node.index;\\n\\tNode last = index.get(index.size() - 1);\\n\\tlast.index = idx;\\n\\tindex.put(idx, last);\\n\\tindex.remove(index.size() - 1);\\n```\n```\\n\\tint random = (int)(Math.random() * index.size());\\n\\treturn index.get(random).val;\\n```\n```\\nclass RandomizedCollection {\\n\\n    class Node {\\n        int val;\\n        int index;\\n        Node (int x, int y) {\\n            val = x;\\n            index = y;\\n        }\\n    }\\n\\n    private HashMap<Integer, LinkedList<Node>> nums;\\n    private HashMap<Integer, Node> index;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        nums = new HashMap<>();\\n        index = new HashMap<>();\\n    }\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean res = !nums.containsKey(val);\\n        if (res) nums.put(val, new LinkedList<>());\\n        Node node = new Node(val, index.size());\\n        nums.get(val).addFirst(node);\\n        index.put(index.size(), node);\\n        return res;\\n    }\\n\\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        boolean res = nums.containsKey(val);\\n        if (res) {\\n            int size = nums.get(val).size();\\n            Node node = nums.get(val).getFirst();\\n            if (size == 1) {\\n                nums.remove(val);\\n            } else {\\n                nums.get(val).removeFirst();\\n            }\\n            int idx = node.index;\\n            Node last = index.get(index.size() - 1);\\n            last.index = idx;\\n            index.put(idx, last);\\n            index.remove(index.size() - 1);\\n        }\\n\\n        return res;\\n    }\\n\\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        int random = (int)(Math.random() * index.size());\\n        return index.get(random).val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190834,
                "title": "c-solution-keep-track-of-indexes",
                "content": "```\\nclass RandomizedCollection {\\npublic:\\n    vector<int> arr;\\n    unordered_map<int, unordered_set<int>> map; //val: {index in arr}\\n    \\n    RandomizedCollection() {}\\n    \\n    bool insert(int val) {\\n        arr.push_back(val);\\n        map[val].insert(arr.size()-1);\\n        return map[val].size() <= 1;\\n    }\\n    \\n    bool remove(int val) {\\n        if(map[val].size()==0) return false;\\n        int ind= *map[val].begin();\\n        map[val].erase(ind);\\n        \\n        int num= arr.back();\\n        swap(arr[ind], arr[arr.size()-1]);\\n        map[num].insert(ind);\\n        map[num].erase(arr.size()-1);\\n        arr.pop_back();\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return arr[rand()%arr.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    vector<int> arr;\\n    unordered_map<int, unordered_set<int>> map; //val: {index in arr}\\n    \\n    RandomizedCollection() {}\\n    \\n    bool insert(int val) {\\n        arr.push_back(val);\\n        map[val].insert(arr.size()-1);\\n        return map[val].size() <= 1;\\n    }\\n    \\n    bool remove(int val) {\\n        if(map[val].size()==0) return false;\\n        int ind= *map[val].begin();\\n        map[val].erase(ind);\\n        \\n        int num= arr.back();\\n        swap(arr[ind], arr[arr.size()-1]);\\n        map[num].insert(ind);\\n        map[num].erase(arr.size()-1);\\n        arr.pop_back();\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return arr[rand()%arr.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858485,
                "title": "in-log-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nimport random\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.arr=SortedList([])\\n        self.dc=defaultdict(lambda:0)\\n\\n    def insert(self, val: int) -> bool:\\n        self.arr.add(val)\\n        self.dc[val]+=1\\n        return self.dc[val]==1\\n    def remove(self, val: int) -> bool:\\n        if(self.dc[val]>0):\\n            self.arr.discard(val)\\n            self.dc[val]-=1\\n            return True\\n        return False\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.arr)\\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nimport random\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.arr=SortedList([])\\n        self.dc=defaultdict(lambda:0)\\n\\n    def insert(self, val: int) -> bool:\\n        self.arr.add(val)\\n        self.dc[val]+=1\\n        return self.dc[val]==1\\n    def remove(self, val: int) -> bool:\\n        if(self.dc[val]>0):\\n            self.arr.discard(val)\\n            self.dc[val]-=1\\n            return True\\n        return False\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.arr)\\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462206,
                "title": "easy-cpp-solution",
                "content": "```\\nclass RandomizedCollection {\\npublic:\\n    \\n    vector<int>v;\\n    unordered_map<int,vector<int>>m;\\n    \\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        m[val].push_back(v.size());\\n        v.push_back(val);\\n        \\n        return m[val].size()==1;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(m[val].size()==0)return false;\\n        \\n        int idx=m[val].back();\\n        \\n        v[idx]=v.back();\\n        int ele=v[idx];\\n        \\n        \\n        for(int i=0;i<m[ele].size();i++){\\n            if(m[ele][i]==v.size()-1){\\n                m[ele][i] = idx;\\n                break;\\n            } \\n        }\\n        \\n        v.pop_back();\\n        \\n        m[val].pop_back();\\n        return true;\\n        \\n        \\n    }\\n    \\n    int getRandom() {\\n       \\n        int n=rand()%v.size();\\n        return v[n];\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    \\n    vector<int>v;\\n    unordered_map<int,vector<int>>m;\\n    \\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        m[val].push_back(v.size());\\n        v.push_back(val);\\n        \\n        return m[val].size()==1;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(m[val].size()==0)return false;\\n        \\n        int idx=m[val].back();\\n        \\n        v[idx]=v.back();\\n        int ele=v[idx];\\n        \\n        \\n        for(int i=0;i<m[ele].size();i++){\\n            if(m[ele][i]==v.size()-1){\\n                m[ele][i] = idx;\\n                break;\\n            } \\n        }\\n        \\n        v.pop_back();\\n        \\n        m[val].pop_back();\\n        return true;\\n        \\n        \\n    }\\n    \\n    int getRandom() {\\n       \\n        int n=rand()%v.size();\\n        return v[n];\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2309963,
                "title": "simple-solution-using-set-map-and-vectors-c",
                "content": "Please upvote if you like my solution .\\n```\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int,set<int>> m;\\n    vector<int> v;\\n    int size;\\n    RandomizedCollection() {\\n        size = 0;\\n    }\\n    \\n    bool insert(int val) {\\n        bool ans = false;\\n        if(m.find(val) == m.end()) ans = true;\\n        m[val].insert(size);\\n        v.push_back(val);\\n        size++;\\n        return ans;\\n    }\\n    \\n    bool remove(int val) {\\n        if(m.find(val) != m.end()){\\n            if(v[size-1] == val){\\n                m[val].erase(size-1); v.pop_back(); if(m[val].size() == 0) m.erase(val); size--; return true;\\n            }\\n            int ind = *(m[val].begin());\\n            v[ind] = v[size-1];\\n            m[v[size-1]].erase(size-1);\\n            v.pop_back();\\n            m[v[ind]].insert(ind);\\n            m[val].erase(ind);\\n            if(m[val].size() == 0){ m.erase(val);}\\n            size--;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int ans = rand()%size;\\n        return v[ans];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int,set<int>> m;\\n    vector<int> v;\\n    int size;\\n    RandomizedCollection() {\\n        size = 0;\\n    }\\n    \\n    bool insert(int val) {\\n        bool ans = false;\\n        if(m.find(val) == m.end()) ans = true;\\n        m[val].insert(size);\\n        v.push_back(val);\\n        size++;\\n        return ans;\\n    }\\n    \\n    bool remove(int val) {\\n        if(m.find(val) != m.end()){\\n            if(v[size-1] == val){\\n                m[val].erase(size-1); v.pop_back(); if(m[val].size() == 0) m.erase(val); size--; return true;\\n            }\\n            int ind = *(m[val].begin());\\n            v[ind] = v[size-1];\\n            m[v[size-1]].erase(size-1);\\n            v.pop_back();\\n            m[v[ind]].insert(ind);\\n            m[val].erase(ind);\\n            if(m[val].size() == 0){ m.erase(val);}\\n            size--;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int ans = rand()%size;\\n        return v[ans];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191498,
                "title": "javascript-solution-hashmap-set",
                "content": "```\\n\\nvar RandomizedCollection = function() {\\n    //create a lookup table to keep track indices of inserted items\\n    this.map = new Map();\\n    // create arr to store inserted items\\n    this.arr = [];\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedCollection.prototype.insert = function(val) {\\n    // push item in arr\\n   this.arr.push(val);\\n    // ckeck if the cut val already in map or not\\n    // if doesent appear store it as key and create a set for store the indices\\n        if(!this.map.has(val)){\\n            this.map.set(val, new Set());\\n            this.map.get(val).add(this.arr.length - 1);\\n            return true;\\n        }else{\\n            // if appear just add cut index of val in set\\n            this.map.get(val).add(this.arr.length - 1);\\n            return false;\\n        }\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedCollection.prototype.remove = function(val) {\\n    // if val doesent appear in map just return false\\n       if(!this.map.has(val)){\\n            return false;\\n        }\\n    // else create arr to store all indexes of val in it\\n        let indexes = Array.from(this.map.get(val));\\n    // get first index from indexes arr\\n        let idx = indexes[0];\\n        var n = this.arr.length;\\n        let last = this.arr[n - 1];\\n    // swap the target val with last val in arr\\n        [this.arr[idx], this.arr[n -1]] = [this.arr[n - 1], this.arr[idx]];\\n    // clear up\\n        this.arr.pop();\\n        this.map.get(val).delete(idx);\\n    // when we swap items also the indices changed so we need to modify idex \\n    // of last swapped item\\n    if(idx !== n - 1){\\n        this.map.get(last).delete(n - 1);\\n        this.map.get(last).add(idx);\\n    }\\n    \\n    if(this.map.get(val).size === 0){\\n            this.map.delete(val);\\n        }\\n    \\n        return true;\\n};\\n\\n/**\\n * @return {number}\\n */\\nRandomizedCollection.prototype.getRandom = function() {\\n        let random = Math.floor(Math.random() * this.arr.length);\\n        return this.arr[random];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar RandomizedCollection = function() {\\n    //create a lookup table to keep track indices of inserted items\\n    this.map = new Map();\\n    // create arr to store inserted items\\n    this.arr = [];\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedCollection.prototype.insert = function(val) {\\n    // push item in arr\\n   this.arr.push(val);\\n    // ckeck if the cut val already in map or not\\n    // if doesent appear store it as key and create a set for store the indices\\n        if(!this.map.has(val)){\\n            this.map.set(val, new Set());\\n            this.map.get(val).add(this.arr.length - 1);\\n            return true;\\n        }else{\\n            // if appear just add cut index of val in set\\n            this.map.get(val).add(this.arr.length - 1);\\n            return false;\\n        }\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedCollection.prototype.remove = function(val) {\\n    // if val doesent appear in map just return false\\n       if(!this.map.has(val)){\\n            return false;\\n        }\\n    // else create arr to store all indexes of val in it\\n        let indexes = Array.from(this.map.get(val));\\n    // get first index from indexes arr\\n        let idx = indexes[0];\\n        var n = this.arr.length;\\n        let last = this.arr[n - 1];\\n    // swap the target val with last val in arr\\n        [this.arr[idx], this.arr[n -1]] = [this.arr[n - 1], this.arr[idx]];\\n    // clear up\\n        this.arr.pop();\\n        this.map.get(val).delete(idx);\\n    // when we swap items also the indices changed so we need to modify idex \\n    // of last swapped item\\n    if(idx !== n - 1){\\n        this.map.get(last).delete(n - 1);\\n        this.map.get(last).add(idx);\\n    }\\n    \\n    if(this.map.get(val).size === 0){\\n            this.map.delete(val);\\n        }\\n    \\n        return true;\\n};\\n\\n/**\\n * @return {number}\\n */\\nRandomizedCollection.prototype.getRandom = function() {\\n        let random = Math.floor(Math.random() * this.arr.length);\\n        return this.arr[random];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2076532,
                "title": "c-map-set-and-vector",
                "content": "\\n\\n    class RandomizedCollection {\\n     public:\\n\\t \\n    vector<int>v;\\n    int n=0;\\n    map<int,set<int>>mp;\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        bool x=false;\\n        if(mp.find(val)==mp.end()){\\n            x=true;\\n        }\\n        v.push_back(val);\\n        mp[val].insert(n);\\n        n++;\\n        return x;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val)== mp.end()){\\n            return false;\\n        }\\n        auto it = mp[val].begin();\\n        int idx = *it;\\n        mp[val].erase(idx);\\n        if(mp[val].size()==0){\\n            mp.erase(val);\\n        }\\n          if(idx==(n-1))\\n        {\\n            v.pop_back();\\n            n--;\\n        }\\n         else{   \\n        int temp = v[n-1];\\n        mp[temp].erase(n-1);\\n        mp[temp].insert(idx);\\n        v[idx]=temp;\\n        v.pop_back();\\n        n--;\\n         }\\n        return true;\\n        \\n    }\\n    \\n    int getRandom() {\\n        int idx=0;\\n        if(n>0){\\n            idx = rand()%n;\\n        }\\n        return v[idx];\\n    }\\n\\n\\n};",
                "solutionTags": [],
                "code": "\\n\\n    class RandomizedCollection {\\n     public:\\n\\t \\n    vector<int>v;\\n    int n=0;\\n    map<int,set<int>>mp;\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        bool x=false;\\n        if(mp.find(val)==mp.end()){\\n            x=true;\\n        }\\n        v.push_back(val);\\n        mp[val].insert(n);\\n        n++;\\n        return x;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val)== mp.end()){\\n            return false;\\n        }\\n        auto it = mp[val].begin();\\n        int idx = *it;\\n        mp[val].erase(idx);\\n        if(mp[val].size()==0){\\n            mp.erase(val);\\n        }\\n          if(idx==(n-1))\\n        {\\n            v.pop_back();\\n            n--;\\n        }\\n         else{   \\n        int temp = v[n-1];\\n        mp[temp].erase(n-1);\\n        mp[temp].insert(idx);\\n        v[idx]=temp;\\n        v.pop_back();\\n        n--;\\n         }\\n        return true;\\n        \\n    }\\n    \\n    int getRandom() {\\n        int idx=0;\\n        if(n>0){\\n            idx = rand()%n;\\n        }\\n        return v[idx];\\n    }\\n\\n\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1901843,
                "title": "python-using-just-list-dictionary-and-set-very-simple",
                "content": "```\\nfrom collections import defaultdict\\nfrom random import choice\\n\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.items, self.idxs = [], defaultdict(set) \\n\\n    def insert(self, val: int) -> bool:\\n        self.items.append(val)\\n        self.idxs[val].add(len(self.items)-1)\\n        return len(self.idxs[val]) == 1\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if not self.idxs[val]:\\n            return False\\n        #we also need to cosider the case when the removed element is the last element of self.items\\n        out_idx, in_item = self.idxs[val].pop(), self.items[-1]\\n        self.items[out_idx] = in_item\\n        self.idxs[in_item].add(out_idx)\\n        self.idxs[in_item].discard(len(self.items)-1)\\n        self.items.pop()\\n        return True\\n\\n    def getRandom(self) -> int:\\n        return choice(self.items)\\n",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom random import choice\\n\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.items, self.idxs = [], defaultdict(set) \\n\\n    def insert(self, val: int) -> bool:\\n        self.items.append(val)\\n        self.idxs[val].add(len(self.items)-1)\\n        return len(self.idxs[val]) == 1\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if not self.idxs[val]:\\n            return False\\n        #we also need to cosider the case when the removed element is the last element of self.items\\n        out_idx, in_item = self.idxs[val].pop(), self.items[-1]\\n        self.items[out_idx] = in_item\\n        self.idxs[in_item].add(out_idx)\\n        self.idxs[in_item].discard(len(self.items)-1)\\n        self.items.pop()\\n        return True\\n\\n    def getRandom(self) -> int:\\n        return choice(self.items)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1533815,
                "title": "c-concise-o-1",
                "content": "```\\npublic class RandomizedCollection {\\n    Dictionary<int, HashSet<int>> idx = new Dictionary<int, HashSet<int>>();\\n    List<int> list = new List<int>();\\n    Random rand = new Random();\\n\\n    public bool Insert(int val) {\\n        if (!idx.TryGetValue(val, out var indices))\\n            idx[val] = indices = new HashSet<int>();\\n        indices.Add(list.Count);\\n        list.Add(val);\\n        return indices.Count == 1;\\n    }\\n\\n    public bool Remove(int val) {\\n        if (!idx.TryGetValue(val, out var indices) || indices.Count == 0)\\n            return false;\\n        int indexToRemove = indices.Last();\\n        list[indexToRemove] = list.Last();\\n        indices.Remove(indexToRemove);\\n        idx[list.Last()].Add(indexToRemove);\\n        idx[list.Last()].Remove(list.Count - 1);\\n        list.RemoveAt(list.Count - 1);\\n        return true;\\n    }\\n\\n    public int GetRandom() => list[rand.Next(list.Count)];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedCollection {\\n    Dictionary<int, HashSet<int>> idx = new Dictionary<int, HashSet<int>>();\\n    List<int> list = new List<int>();\\n    Random rand = new Random();\\n\\n    public bool Insert(int val) {\\n        if (!idx.TryGetValue(val, out var indices))\\n            idx[val] = indices = new HashSet<int>();\\n        indices.Add(list.Count);\\n        list.Add(val);\\n        return indices.Count == 1;\\n    }\\n\\n    public bool Remove(int val) {\\n        if (!idx.TryGetValue(val, out var indices) || indices.Count == 0)\\n            return false;\\n        int indexToRemove = indices.Last();\\n        list[indexToRemove] = list.Last();\\n        indices.Remove(indexToRemove);\\n        idx[list.Last()].Add(indexToRemove);\\n        idx[list.Last()].Remove(list.Count - 1);\\n        list.RemoveAt(list.Count - 1);\\n        return true;\\n    }\\n\\n    public int GetRandom() => list[rand.Next(list.Count)];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822583,
                "title": "python-with-fix-of-solution-104ms-o-1",
                "content": "```\\nfrom collections import defaultdict\\nimport random\\n\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.lst = []\\n        self.d = defaultdict(set)  #{val: set of indexs}\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        self.d[val].add(len(self.lst))\\n        self.lst.append(val)\\n        return len(self.d[val]) == 1\\n        \\n        \\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        if val not in self.d or len(self.d[val]) == 0:\\n            return False\\n        idx, last = self.d[val].pop(), self.lst[-1] # cannot use pop for lst directly, can cause idx out of range issue later on if it\\'s the last one or already empty list\\n        self.d[last].add(idx)\\n        self.lst[idx] = last\\n        self.d[last].remove(len(self.lst) -1)\\n        \\n        self.lst.pop()\\n        return True\\n        \\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the collection.\\n        \"\"\"\\n        return random.choice(self.lst)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport random\\n\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.lst = []\\n        self.d = defaultdict(set)  #{val: set of indexs}\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        self.d[val].add(len(self.lst))\\n        self.lst.append(val)\\n        return len(self.d[val]) == 1\\n        \\n        \\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        if val not in self.d or len(self.d[val]) == 0:\\n            return False\\n        idx, last = self.d[val].pop(), self.lst[-1] # cannot use pop for lst directly, can cause idx out of range issue later on if it\\'s the last one or already empty list\\n        self.d[last].add(idx)\\n        self.lst[idx] = last\\n        self.d[last].remove(len(self.lst) -1)\\n        \\n        self.lst.pop()\\n        return True\\n        \\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the collection.\\n        \"\"\"\\n        return random.choice(self.lst)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 685571,
                "title": "c-o-1-solution-using-dictionary-and-hashset",
                "content": "```\\npublic class RandomizedCollection {\\n    private Dictionary<int,HashSet<int>> _dict;\\n    private List<int> _list;\\n    private Random _rand;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        _dict = new Dictionary<int,HashSet<int>>();\\n        _list = new List<int>(); \\n        _rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public bool Insert(int val) {\\n        bool result = false;\\n        if (!_dict.ContainsKey(val)) {\\n            _dict[val] = new HashSet<int>();\\n            result = true;\\n        }\\n        _list.Add(val);\\n        int index = _list.Count-1;\\n        _dict[val].Add(index);\\n        return result;        \\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public bool Remove(int val) {\\n        if (!_dict.ContainsKey(val))\\n            return false;\\n        int indexToRemove = _dict[val].First();\\n        _dict[val].Remove(indexToRemove);\\n        if (indexToRemove != _list.Count-1) {\\n            _dict[_list[^1]].Remove(_list.Count-1);\\n            _list[indexToRemove] = _list[^1];\\n            _dict[_list[indexToRemove]].Add(indexToRemove);            \\n        }\\n        _list.RemoveAt(_list.Count-1);\\n        if (_dict[val].Count == 0)\\n            _dict.Remove(val);\\n        return true;       \\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int GetRandom() {\\n        int index = _rand.Next(_list.Count);\\n        return _list[index];        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class RandomizedCollection {\\n    private Dictionary<int,HashSet<int>> _dict;\\n    private List<int> _list;\\n    private Random _rand;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        _dict = new Dictionary<int,HashSet<int>>();\\n        _list = new List<int>(); \\n        _rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public bool Insert(int val) {\\n        bool result = false;\\n        if (!_dict.ContainsKey(val)) {\\n            _dict[val] = new HashSet<int>();\\n            result = true;\\n        }\\n        _list.Add(val);\\n        int index = _list.Count-1;\\n        _dict[val].Add(index);\\n        return result;        \\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public bool Remove(int val) {\\n        if (!_dict.ContainsKey(val))\\n            return false;\\n        int indexToRemove = _dict[val].First();\\n        _dict[val].Remove(indexToRemove);\\n        if (indexToRemove != _list.Count-1) {\\n            _dict[_list[^1]].Remove(_list.Count-1);\\n            _list[indexToRemove] = _list[^1];\\n            _dict[_list[indexToRemove]].Add(indexToRemove);            \\n        }\\n        _list.RemoveAt(_list.Count-1);\\n        if (_dict[val].Count == 0)\\n            _dict.Remove(val);\\n        return true;       \\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int GetRandom() {\\n        int index = _rand.Next(_list.Count);\\n        return _list[index];        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683861,
                "title": "i-am-not-able-to-submit-it-due-to-random-numbers-not-matching-in-test-cases",
                "content": "\\'\\'\\'#include<bits/stdc++.h> \\nusing namespace std; \\n  \\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    //vector <int> arr; \\n      \\n    // A hash where keys are array elements and vlaues are \\n    // indexes in arr[] \\n    //map <int, int> Map; \\n    \\n//unordered_multimap<int,int> m1;\\n//vector<unordered_multimap<int,int> :: iterator> v;\\n//unordered_map<int, int> m;\\n    //int tot = 0;    \\n// int tot = 0;  \\nunordered_map<int,int> hashmap; \\n    vector<int> nums;\\n    RandomizedSet() {\\n     // A resizable array \\n     \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n       \\n       bool result = true;\\n        if(find(nums.begin(), nums.end(), val) != nums.end()) result = false;\\n        nums.push_back(val);\\n        hashmap[nums.size()-1] = val; // curr index->num\\n        return result; \\n        \\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n     if(find(nums.begin(), nums.end(), val) == nums.end()) return false;\\n        int last = nums.back();\\n        int valpos = find(nums.begin(), nums.end(), val) - nums.begin();\\n        int lastpos = nums.size()-1;\\n        hashmap[valpos] = last;  //store last value at val\\'s index\\n        hashmap.erase(lastpos); //delete the last index from hashmap\\n        nums[valpos] = last; //store the last value at val\\'s index\\n        nums.pop_back(); //delete the last index from nums \\n\\t\\t//basically we just swapped the last element with val to be removed and deleted the last index of both nums & hashmap\\n        return true;  \\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        \\n        return nums[rand() % nums.size()];\\n         \\n    }\\n    \\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\' \\' \\'",
                "solutionTags": [],
                "code": "\\'\\'\\'#include<bits/stdc++.h> \\nusing namespace std; \\n  \\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    //vector <int> arr; \\n      \\n    // A hash where keys are array elements and vlaues are \\n    // indexes in arr[] \\n    //map <int, int> Map; \\n    \\n//unordered_multimap<int,int> m1;\\n//vector<unordered_multimap<int,int> :: iterator> v;\\n//unordered_map<int, int> m;\\n    //int tot = 0;    \\n// int tot = 0;  \\nunordered_map<int,int> hashmap; \\n    vector<int> nums;\\n    RandomizedSet() {\\n     // A resizable array \\n     \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n       \\n       bool result = true;\\n        if(find(nums.begin(), nums.end(), val) != nums.end()) result = false;\\n        nums.push_back(val);\\n        hashmap[nums.size()-1] = val; // curr index->num\\n        return result; \\n        \\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n     if(find(nums.begin(), nums.end(), val) == nums.end()) return false;\\n        int last = nums.back();\\n        int valpos = find(nums.begin(), nums.end(), val) - nums.begin();\\n        int lastpos = nums.size()-1;\\n        hashmap[valpos] = last;  //store last value at val\\'s index\\n        hashmap.erase(lastpos); //delete the last index from hashmap\\n        nums[valpos] = last; //store the last value at val\\'s index\\n        nums.pop_back(); //delete the last index from nums \\n\\t\\t//basically we just swapped the last element with val to be removed and deleted the last index of both nums & hashmap\\n        return true;  \\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        \\n        return nums[rand() % nums.size()];\\n         \\n    }\\n    \\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\' \\' \\'",
                "codeTag": "C++"
            },
            {
                "id": 650673,
                "title": "java-worst-case-time-is-o-1-not-average-with-explanation",
                "content": "The problem is if we delete elements from the ArrayList, it will rearrange the the array again. The idea is doing soft deletetion instead of it.\\nThe solution is maintaining index of the ArrayList yourself. Swap the deleting element with the last index of the element. \\n\\nLets say there are elements already inserted. Inserting is pretty simple.\\nelement:............3 5 4 2 7 8 9\\nindex of list:......0 1 2 3 4 5 6 7\\ncurrent index : (7)...................^\\n\\nNow we wants to delete \\'7\\'. Then we swap the element with the last element, and decrement current index by one. After deletion it looks like this:\\nelement:............3 5 4 2 9 8 7\\nindex of list:......0 1 2 3 4 5 6 7\\ncurrent index : (6)................^\\n\\nNow lets insert \\'1\\' into collection.\\nelement:............3 5 4 2 9 8 1\\nindex of list:......0 1 2 3 4 5 6 7\\ncurrent index : (7)....................^\\n\\n```\\n    class Node {\\n        int val;\\n        int index;\\n\\n\\t\\t// handling duplications\\n        LinkedList<Node> nodes;\\n\\n        public Node(int val, int index) {\\n            this.nodes = new LinkedList<>();\\n            this.val = val;\\n            this.index = index;\\n        }\\n    }\\n\\n    Map<Integer, Node> map;\\n    List<Node> list;\\n    Random random;\\n    int currentIdx;\\n\\n    public RandomizedCollection() {\\n        this.map = new HashMap<>();\\n        this.list = new ArrayList<>();\\n        this.random = new Random();\\n        this.currentIdx = 0;\\n    }\\n\\n    public boolean insert(int val) {\\n        Node newNode = new Node(val, list.size());\\n        if (currentIdx == list.size()) {\\n            list.add(newNode);\\n        } else {\\n            list.set(currentIdx, newNode);\\n        }\\n        currentIdx++;\\n        Node node = map.get(val);\\n        if (node == null) {\\n            map.put(val, newNode);\\n            return true;\\n        } else {\\n            node.nodes.add(newNode);\\n            return false;\\n        }\\n    }\\n\\n    public boolean remove(int val) {\\n        Node node = map.get(val);\\n        if (node == null) {\\n            return false;\\n        } else {\\n            Node removeNode = null;\\n            if (node.nodes.isEmpty()) {\\n                removeNode = node;\\n                map.remove(removeNode.val);\\n            } else {\\n                removeNode = node.nodes.removeLast();\\n            }\\n            Node lastNode = list.get(currentIdx - 1);\\n            if (removeNode.index != lastNode.index) { // swapping the element with the last element\\n                lastNode.index = removeNode.index;\\n                list.set(removeNode.index, lastNode);\\n            }\\n            currentIdx--;\\n            return true;\\n        }\\n    }\\n\\n    public int getRandom() {\\n        int randomIdx = random.nextInt(currentIdx);\\n        return list.get(randomIdx).val;\\n    }\\n```\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    class Node {\\n        int val;\\n        int index;\\n\\n\\t\\t// handling duplications\\n        LinkedList<Node> nodes;\\n\\n        public Node(int val, int index) {\\n            this.nodes = new LinkedList<>();\\n            this.val = val;\\n            this.index = index;\\n        }\\n    }\\n\\n    Map<Integer, Node> map;\\n    List<Node> list;\\n    Random random;\\n    int currentIdx;\\n\\n    public RandomizedCollection() {\\n        this.map = new HashMap<>();\\n        this.list = new ArrayList<>();\\n        this.random = new Random();\\n        this.currentIdx = 0;\\n    }\\n\\n    public boolean insert(int val) {\\n        Node newNode = new Node(val, list.size());\\n        if (currentIdx == list.size()) {\\n            list.add(newNode);\\n        } else {\\n            list.set(currentIdx, newNode);\\n        }\\n        currentIdx++;\\n        Node node = map.get(val);\\n        if (node == null) {\\n            map.put(val, newNode);\\n            return true;\\n        } else {\\n            node.nodes.add(newNode);\\n            return false;\\n        }\\n    }\\n\\n    public boolean remove(int val) {\\n        Node node = map.get(val);\\n        if (node == null) {\\n            return false;\\n        } else {\\n            Node removeNode = null;\\n            if (node.nodes.isEmpty()) {\\n                removeNode = node;\\n                map.remove(removeNode.val);\\n            } else {\\n                removeNode = node.nodes.removeLast();\\n            }\\n            Node lastNode = list.get(currentIdx - 1);\\n            if (removeNode.index != lastNode.index) { // swapping the element with the last element\\n                lastNode.index = removeNode.index;\\n                list.set(removeNode.index, lastNode);\\n            }\\n            currentIdx--;\\n            return true;\\n        }\\n    }\\n\\n    public int getRandom() {\\n        int randomIdx = random.nextInt(currentIdx);\\n        return list.get(randomIdx).val;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294463,
                "title": "swift-solution",
                "content": "```swift\\nclass RandomizedCollection {\\n    private var map = [Int: Set<Int>]()\\n    private var list = [Int]()\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    func insert(_ val: Int) -> Bool {\\n        let newInsert = (map[val] == nil)\\n        map[val, default: []].insert(list.count)\\n        list.append(val)\\n        return newInsert\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    func remove(_ val: Int) -> Bool {\\n        if map[val] != nil {\\n            let idx = map[val]!.first!\\n            map[val]!.remove(idx)\\n            if map[val]!.isEmpty {\\n                map[val] = nil\\n            }\\n\\n            let last = list.removeLast()\\n            let lastIdx = list.count\\n            if lastIdx != idx {\\n                list[idx] = last\\n                map[last]!.remove(lastIdx)\\n                map[last]!.insert(idx)\\n            }\\n            return true\\n        }\\n        return false\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    func getRandom() -> Int {\\n        return list.randomElement()!\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass RandomizedCollection {\\n    private var map = [Int: Set<Int>]()\\n    private var list = [Int]()\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    func insert(_ val: Int) -> Bool {\\n        let newInsert = (map[val] == nil)\\n        map[val, default: []].insert(list.count)\\n        list.append(val)\\n        return newInsert\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    func remove(_ val: Int) -> Bool {\\n        if map[val] != nil {\\n            let idx = map[val]!.first!\\n            map[val]!.remove(idx)\\n            if map[val]!.isEmpty {\\n                map[val] = nil\\n            }\\n\\n            let last = list.removeLast()\\n            let lastIdx = list.count\\n            if lastIdx != idx {\\n                list[idx] = last\\n                map[last]!.remove(lastIdx)\\n                map[last]!.insert(idx)\\n            }\\n            return true\\n        }\\n        return false\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    func getRandom() -> Int {\\n        return list.randomElement()!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265870,
                "title": "c-56ms-speed-memory-beat-99-unordered-multimap-vector-easy-to-understand",
                "content": "So we want duplicate values and to support O(1) time. My remove has to walk the iterator of multimap values (similar to a hash collision). I think this meets the def of \"average linear time\" since this is essentially what a hash table does.\\n\\nBasic idea:\\n1. vector stores all inserted \\'values\\'\\n2. multimap maps all inserted values to their index in the vector\\n\\nThe only tricky part is the **remove**, where we need to:\\n1. find any element in the mulitmap with a key of val, store in iterator \\n2. delete the element at the index in the vector we got from the map\\n3. ensure the map and vector are up to date at the end by swapping vector element to the end, popping back of vector, and linerally searching all elements with key of val in the map for the index we swapped forward in the vector\\n\\n```\\n    /** Initialize your data structure here. */\\n    unordered_multimap<int, int> m;\\n    vector<int> v;\\n    RandomizedCollection() {\\n        srand(time(NULL));\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ret = false;\\n        if (!m.count(val)) ret = true;\\n        m.insert({val, v.size()});\\n        v.push_back(val);\\n        return ret;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (!m.count(val)) return false;\\n        \\n        auto it = m.find(val);\\n        auto it_last_elem = m.find(v.back());\\n        for (; it_last_elem != m.end(); it_last_elem++) {\\n            if ((*it_last_elem).second == v.size()-1) break;\\n        }\\n        \\n        swap(v.back(), v[(*it).second]);\\n        v.pop_back();\\n        \\n        (*it_last_elem).second = (*it).second;\\n        m.erase(it);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return v[rand() % v.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    /** Initialize your data structure here. */\\n    unordered_multimap<int, int> m;\\n    vector<int> v;\\n    RandomizedCollection() {\\n        srand(time(NULL));\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ret = false;\\n        if (!m.count(val)) ret = true;\\n        m.insert({val, v.size()});\\n        v.push_back(val);\\n        return ret;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (!m.count(val)) return false;\\n        \\n        auto it = m.find(val);\\n        auto it_last_elem = m.find(v.back());\\n        for (; it_last_elem != m.end(); it_last_elem++) {\\n            if ((*it_last_elem).second == v.size()-1) break;\\n        }\\n        \\n        swap(v.back(), v[(*it).second]);\\n        v.pop_back();\\n        \\n        (*it_last_elem).second = (*it).second;\\n        m.erase(it);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return v[rand() % v.size()];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163054,
                "title": "python-heap-solution-beats-96",
                "content": "```\\nimport random, heapq\\n\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dic = {}\\n        self.lis = []\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element. Otherwise return False\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        dic = self.dic\\n        lis = self.lis\\n        \\n        ans = False\\n    \\n        if val not in dic:\\n            ans = True\\n            dic[val] = []\\n            \\n        heapq.heappush(dic[val], -len(lis))\\n        lis.append(val)\\n        \\n        return ans\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element. Otherwise return False.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        dic = self.dic\\n        lis = self.lis\\n        \\n        if val not in dic:\\n            return False\\n        \\n        last_val = lis.pop()\\n        heapq.heappop(dic[last_val])\\n\\n        if last_val == val:\\n            if not dic[val]:\\n                del dic[val]          \\n            return True\\n\\n        index = -heapq.heappop(dic[val])\\n        heapq.heappush(dic[last_val], -index)\\n        \\n        lis[index] = last_val\\n        \\n        if not dic[val]:\\n            del dic[val]        \\n        return True\\n        \\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the collection.\\n        :rtype: int\\n        \"\"\"\\n        return random.choice(self.lis)\\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [],
                "code": "```\\nimport random, heapq\\n\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dic = {}\\n        self.lis = []\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element. Otherwise return False\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        dic = self.dic\\n        lis = self.lis\\n        \\n        ans = False\\n    \\n        if val not in dic:\\n            ans = True\\n            dic[val] = []\\n            \\n        heapq.heappush(dic[val], -len(lis))\\n        lis.append(val)\\n        \\n        return ans\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element. Otherwise return False.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        dic = self.dic\\n        lis = self.lis\\n        \\n        if val not in dic:\\n            return False\\n        \\n        last_val = lis.pop()\\n        heapq.heappop(dic[last_val])\\n\\n        if last_val == val:\\n            if not dic[val]:\\n                del dic[val]          \\n            return True\\n\\n        index = -heapq.heappop(dic[val])\\n        heapq.heappush(dic[last_val], -index)\\n        \\n        lis[index] = last_val\\n        \\n        if not dic[val]:\\n            del dic[val]        \\n        return True\\n        \\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the collection.\\n        :rtype: int\\n        \"\"\"\\n        return random.choice(self.lis)\\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85543,
                "title": "c-solution-using-dictionary-and-hashset-298ms",
                "content": "This solution also uses the magic of LINQ's `first()` function to basically get a random value from the HashSet\\n\\n```cs\\n        public class RandomizedCollection {\\n\\n            Dictionary<int, int> _randomSet;\\n            Dictionary<int, HashSet<int>> _inverseRandomSet;\\n            int _counter;\\n            Random _random;\\n            /** Initialize your data structure here. */\\n            public RandomizedCollection() {\\n                _randomSet = new Dictionary<int, int>();\\n                _inverseRandomSet = new Dictionary<int, HashSet<int>>();\\n                _random = new Random();\\n                _counter = 0;\\n            }\\n\\n            /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n            public bool Insert(int val) {\\n                if (_inverseRandomSet.ContainsKey(val)) {\\n                    _inverseRandomSet[val].Add(_counter);\\n                    _randomSet.Add(_counter, val);\\n                    _counter++;\\n                    return false;\\n                }\\n                _randomSet.Add(_counter, val);\\n                _inverseRandomSet.Add(val, new HashSet<int>());\\n                _inverseRandomSet[val].Add(_counter);\\n                _counter++;\\n                return true;\\n            }\\n\\n            /** Removes a value from the set. Returns true if the set contained the specified element. */\\n            public bool Remove(int val) {\\n                if (!_inverseRandomSet.ContainsKey(val)) {\\n                    return false;\\n                }\\n                var randomSetIndex = _inverseRandomSet[val].First();\\n                _inverseRandomSet[val].Remove(randomSetIndex);\\n                if (_inverseRandomSet[val].Count == 0) {\\n                    _inverseRandomSet.Remove(val);\\n                }\\n                _randomSet.Remove(randomSetIndex);\\n                if (_counter - 1 != randomSetIndex) {\\n                    MoveIndex(_counter - 1, randomSetIndex);\\n                }\\n                _counter--;\\n                return true;\\n            }\\n\\n            /** Get a random element from the set. */\\n            public int GetRandom() {\\n                var index = _random.Next(_counter);\\n                return _randomSet[index];\\n            }\\n\\n            private void MoveIndex(int from, int to) {\\n                var val = _randomSet[from];\\n                _randomSet.Remove(from);\\n                _randomSet.Add(to, val);\\n                _inverseRandomSet[val].Remove(from);\\n                _inverseRandomSet[val].Add(to);\\n            }\\n        }\\n```\\n\\nExplanation is that basically, the `_randomSet` contains all the counter to values for taking a random entry while `_inverseRandomSet` contains values mapping to where it is in the `_randomSet` Dictionary.",
                "solutionTags": [],
                "code": "```cs\\n        public class RandomizedCollection {\\n\\n            Dictionary<int, int> _randomSet;\\n            Dictionary<int, HashSet<int>> _inverseRandomSet;\\n            int _counter;\\n            Random _random;\\n            /** Initialize your data structure here. */\\n            public RandomizedCollection() {\\n                _randomSet = new Dictionary<int, int>();\\n                _inverseRandomSet = new Dictionary<int, HashSet<int>>();\\n                _random = new Random();\\n                _counter = 0;\\n            }\\n\\n            /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n            public bool Insert(int val) {\\n                if (_inverseRandomSet.ContainsKey(val)) {\\n                    _inverseRandomSet[val].Add(_counter);\\n                    _randomSet.Add(_counter, val);\\n                    _counter++;\\n                    return false;\\n                }\\n                _randomSet.Add(_counter, val);\\n                _inverseRandomSet.Add(val, new HashSet<int>());\\n                _inverseRandomSet[val].Add(_counter);\\n                _counter++;\\n                return true;\\n            }\\n\\n            /** Removes a value from the set. Returns true if the set contained the specified element. */\\n            public bool Remove(int val) {\\n                if (!_inverseRandomSet.ContainsKey(val)) {\\n                    return false;\\n                }\\n                var randomSetIndex = _inverseRandomSet[val].First();\\n                _inverseRandomSet[val].Remove(randomSetIndex);\\n                if (_inverseRandomSet[val].Count == 0) {\\n                    _inverseRandomSet.Remove(val);\\n                }\\n                _randomSet.Remove(randomSetIndex);\\n                if (_counter - 1 != randomSetIndex) {\\n                    MoveIndex(_counter - 1, randomSetIndex);\\n                }\\n                _counter--;\\n                return true;\\n            }\\n\\n            /** Get a random element from the set. */\\n            public int GetRandom() {\\n                var index = _random.Next(_counter);\\n                return _randomSet[index];\\n            }\\n\\n            private void MoveIndex(int from, int to) {\\n                var val = _randomSet[from];\\n                _randomSet.Remove(from);\\n                _randomSet.Add(to, val);\\n                _inverseRandomSet[val].Remove(from);\\n                _inverseRandomSet[val].Add(to);\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85618,
                "title": "java-arraylist-and-two-maps-solution",
                "content": "I haven't seen this one yet (maybe I overlooked?). I admit, the previous problem completely puzzled me, but once I knew the solution for it, this one was a breeze.\\n\\nThe idea came to me at once: if I need a linear distribution, I need to keep all duplicates in a single array. But how do I map values to indexes if values may contain duplicates? Keeping only the last one obviously won't do the trick because deletion will be impossible. So what do I do? And the next thought was: well, if I need values to be different to map them to indexes, let's *make* them different!\\n\\nSo I introduced a simple structure to store values. Each value is accompanied by the sequence number, which is unique among all duplicated values. This allows me to map freely and basically to solve the problem in exactly the same way as the previous one. The only place where I really needed the auxiliary data structure is the map, but I also kept value instances in the array to make code cleaner. Note that it probably doesn't cost me any additional memory since I have to keep those instances in the map anyway, and a reference to a structure is probably consuming even *less* memory than a boxed integer (screw Java generics!).\\n```\\n    private final List<Value> values = new ArrayList<>();\\n    private final Map<Value, Integer> indexes = new HashMap<>();\\n    private final Map<Integer, Integer> counts = new HashMap<>();\\n    private final Random random = new Random();\\n    \\n    public boolean insert(int val) {\\n        return appendNewValue(val).wasAddedFirst();\\n    }\\n\\n    private Value appendNewValue(int val) {\\n        Value newValue = new Value(val, counts.getOrDefault(val, 0));\\n        values.add(newValue);\\n        indexes.put(newValue, values.size() - 1);\\n        counts.put(val, newValue.number + 1);\\n        return newValue;\\n    }\\n    \\n    public boolean remove(int val) {\\n        int count = counts.getOrDefault(val, 0);\\n        if (count == 0)\\n            return false;\\n        int index = indexes.get(new Value(val, count - 1));\\n        swapWithLastValue(index);\\n        removeLastValue();\\n        return true;\\n    }\\n\\n    private void swapWithLastValue(int index) {\\n        int lastIndex = values.size() - 1;\\n        Value temp = values.get(index);\\n        Value last = values.get(lastIndex);\\n        values.set(index, last);\\n        values.set(lastIndex, temp);\\n        indexes.put(last, index);\\n        indexes.put(temp, lastIndex);\\n    }\\n\\n    private void removeLastValue() {\\n        int lastIndex = values.size() - 1;\\n        Value value = values.get(lastIndex);\\n        values.remove(lastIndex);\\n        indexes.remove(value);\\n        if (value.wasAddedFirst())\\n            counts.remove(value.value);\\n        else\\n            counts.put(value.value, value.number);\\n    }\\n    \\n    public int getRandom() {\\n        return values.get(random.nextInt(values.size())).value;\\n    }\\n    \\n    private static class Value {\\n        private final int value;\\n        private final int number;\\n\\n        public Value(int value, int number) {\\n            this.value = value;\\n            this.number = number;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            int hash = 3;\\n            hash = 13 * hash + this.value;\\n            hash = 13 * hash + this.number;\\n            return hash;\\n        }\\n\\n        @Override\\n        public boolean equals(Object obj) {\\n            if (this == obj)\\n                return true;\\n            if (obj == null || getClass() != obj.getClass())\\n                return false;\\n            final Value other = (Value) obj;\\n            return this.value == other.value\\n                    && this.number == other.number;\\n        }\\n\\n        boolean wasAddedFirst() {\\n            return number == 0;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private final List<Value> values = new ArrayList<>();\\n    private final Map<Value, Integer> indexes = new HashMap<>();\\n    private final Map<Integer, Integer> counts = new HashMap<>();\\n    private final Random random = new Random();\\n    \\n    public boolean insert(int val) {\\n        return appendNewValue(val).wasAddedFirst();\\n    }\\n\\n    private Value appendNewValue(int val) {\\n        Value newValue = new Value(val, counts.getOrDefault(val, 0));\\n        values.add(newValue);\\n        indexes.put(newValue, values.size() - 1);\\n        counts.put(val, newValue.number + 1);\\n        return newValue;\\n    }\\n    \\n    public boolean remove(int val) {\\n        int count = counts.getOrDefault(val, 0);\\n        if (count == 0)\\n            return false;\\n        int index = indexes.get(new Value(val, count - 1));\\n        swapWithLastValue(index);\\n        removeLastValue();\\n        return true;\\n    }\\n\\n    private void swapWithLastValue(int index) {\\n        int lastIndex = values.size() - 1;\\n        Value temp = values.get(index);\\n        Value last = values.get(lastIndex);\\n        values.set(index, last);\\n        values.set(lastIndex, temp);\\n        indexes.put(last, index);\\n        indexes.put(temp, lastIndex);\\n    }\\n\\n    private void removeLastValue() {\\n        int lastIndex = values.size() - 1;\\n        Value value = values.get(lastIndex);\\n        values.remove(lastIndex);\\n        indexes.remove(value);\\n        if (value.wasAddedFirst())\\n            counts.remove(value.value);\\n        else\\n            counts.put(value.value, value.number);\\n    }\\n    \\n    public int getRandom() {\\n        return values.get(random.nextInt(values.size())).value;\\n    }\\n    \\n    private static class Value {\\n        private final int value;\\n        private final int number;\\n\\n        public Value(int value, int number) {\\n            this.value = value;\\n            this.number = number;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            int hash = 3;\\n            hash = 13 * hash + this.value;\\n            hash = 13 * hash + this.number;\\n            return hash;\\n        }\\n\\n        @Override\\n        public boolean equals(Object obj) {\\n            if (this == obj)\\n                return true;\\n            if (obj == null || getClass() != obj.getClass())\\n                return false;\\n            final Value other = (Value) obj;\\n            return this.value == other.value\\n                    && this.number == other.number;\\n        }\\n\\n        boolean wasAddedFirst() {\\n            return number == 0;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85636,
                "title": "c-solution-using-a-map-of-vectors-to-handle-duplicates",
                "content": "```\\nclass RandomizedCollection {\\n    vector<pair<int, int>> buffer; // pair.first: the actual value stored; pair.second: the index of the pointer in the idx_map[pair.first]; so idx_map[pair.first][pair.second] is the index of the value in the buffer.\\n    unordered_map<int, vector<int>> idx_map; // duplicates are stacked into vector<int>\\n    default_random_engine rng;\\npublic:\\n    bool insert(int val) {\\n        auto is_exist = idx_map.find(val) == idx_map.end() ;\\n        idx_map[val].push_back(buffer.size()); \\n        buffer.emplace_back(val, idx_map[val].size() - 1);\\n        return is_exist;\\n    }\\n    bool remove(int val) {\\n        if (idx_map.find(val) == idx_map.end())\\n            return false;\\n        int idx = idx_map[val].back();\\n        buffer[idx] = buffer.back();\\n        idx_map[buffer.back().first][buffer.back().second] = idx;\\n        idx_map[val].pop_back();\\n        if (idx_map[val].empty())\\n            idx_map.erase(val);\\n        buffer.pop_back();\\n        return true;\\n    }\\n    int getRandom() {\\n        uniform_int_distribution<int> distribution(0, buffer.size() - 1);\\n        int idx = distribution(rng);\\n        return buffer[idx].first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\n    vector<pair<int, int>> buffer; // pair.first: the actual value stored; pair.second: the index of the pointer in the idx_map[pair.first]; so idx_map[pair.first][pair.second] is the index of the value in the buffer.\\n    unordered_map<int, vector<int>> idx_map; // duplicates are stacked into vector<int>\\n    default_random_engine rng;\\npublic:\\n    bool insert(int val) {\\n        auto is_exist = idx_map.find(val) == idx_map.end() ;\\n        idx_map[val].push_back(buffer.size()); \\n        buffer.emplace_back(val, idx_map[val].size() - 1);\\n        return is_exist;\\n    }\\n    bool remove(int val) {\\n        if (idx_map.find(val) == idx_map.end())\\n            return false;\\n        int idx = idx_map[val].back();\\n        buffer[idx] = buffer.back();\\n        idx_map[buffer.back().first][buffer.back().second] = idx;\\n        idx_map[val].pop_back();\\n        if (idx_map[val].empty())\\n            idx_map.erase(val);\\n        buffer.pop_back();\\n        return true;\\n    }\\n    int getRandom() {\\n        uniform_int_distribution<int> distribution(0, buffer.size() - 1);\\n        int idx = distribution(rng);\\n        return buffer[idx].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85593,
                "title": "c-ac-solution-with-unordered-map-and-vector-104ms",
                "content": "The main idea is use unordered_map<int, vector<int>> to record multiple location of numbers, and use vector<int> to store all numbers. The main different with problem [Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/) is :\\n1. [insert] We should always push number, no matter the number is existing or not.\\n2. [delete] We can erase the number from hashmap only when all the number are removed. (we can get this info by checking the length hashmap[val])\\n\\nBesides, the if statement in delete() can reduce redundant access to unordered_map and vector, which can slightly improve its performance.\\n\\nIf you have any suggestion, please leave the comment. Thanks. :)\\n```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {}\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        nums.push_back(val);\\n        m[val].push_back(nums.size() - 1);\\n        return m[val].size() == 1;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if(m.find(val) == m.end())  return false;\\n        int last = nums.back();\\n        if(val != last) {   // Reduce redundant access.\\n            nums[m[val].back()] = last;\\n            m[last].back() = m[val].back();\\n        }\\n        m[val].pop_back();\\n        nums.pop_back();\\n        if(m[val].size() == 0)\\n            m.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n\\nprivate:\\n    unordered_map<int, vector<int>> m;\\n    vector<int> nums;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {}\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        nums.push_back(val);\\n        m[val].push_back(nums.size() - 1);\\n        return m[val].size() == 1;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if(m.find(val) == m.end())  return false;\\n        int last = nums.back();\\n        if(val != last) {   // Reduce redundant access.\\n            nums[m[val].back()] = last;\\n            m[last].back() = m[val].back();\\n        }\\n        m[val].pop_back();\\n        nums.pop_back();\\n        if(m[val].size() == 0)\\n            m.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n\\nprivate:\\n    unordered_map<int, vector<int>> m;\\n    vector<int> nums;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85611,
                "title": "concise-python-solution-with-list-dict-and-set",
                "content": "This solution assumes there is not ordering requirement for ```remove```. ```remove``` will randomly remove an element among duplicates.\\n\\nSimilar to Problem 380 without duplicates, we use a list to contain all elements and use a dict to keep track of their indices. This time, we use a ```set``` to keep track of all indices for a value.\\n\\nJust like Problem 380, when we remove a value, we randomly pop an index for that value from the set, swap the value with the last element of the list, and update the indices for the new value.\\n\\n```\\nimport random\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        self.l, self.d = [], collections.defaultdict(set)\\n\\n    def insert(self, val):\\n        self.d[val].add(len(self.l))\\n        self.l.append(val)\\n        return len(self.d[val])==1\\n\\n    def remove(self, val):\\n        if val not in self.d:\\n            return False\\n        i, newVal = self.d[val].pop(), self.l[-1]\\n        len(self.d[val]) > 0 or self.d.pop(val, None)\\n        if newVal in self.d:\\n            self.d[newVal] = (self.d[newVal] | {i}) - {len(self.l)-1}\\n        self.l[i] = newVal\\n        self.l.pop()\\n        return True\\n\\n    def getRandom(self):\\n        return random.choice(self.l)\\n```\\nLonger but clearer version:\\n\\n```\\nimport random\\nclass RandomizedCollection(object):\\n    def __init__(self):\\n        self.l = []\\n        self.d = collections.defaultdict(set)\\n\\n    def insert(self, val):\\n        b = val not in self.d\\n        self.d[val].add(len(self.l))\\n        self.l.append(val)\\n        return b\\n\\n    def remove(self, val):\\n        if val not in self.d:\\n            return False\\n        i, newVal = self.d[val].pop(), self.l[-1]\\n        if len(self.d[val]) == 0:\\n            del self.d[val]\\n        self.l[i] = newVal\\n        if newVal in self.d:\\n            self.d[newVal].add(i)\\n            self.d[newVal].discard(len(self.l)-1)\\n        self.l.pop()\\n        return True\\n\\n    def getRandom(self):\\n        return random.choice(self.l)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```remove```\n```remove```\n```set```\n```\\nimport random\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        self.l, self.d = [], collections.defaultdict(set)\\n\\n    def insert(self, val):\\n        self.d[val].add(len(self.l))\\n        self.l.append(val)\\n        return len(self.d[val])==1\\n\\n    def remove(self, val):\\n        if val not in self.d:\\n            return False\\n        i, newVal = self.d[val].pop(), self.l[-1]\\n        len(self.d[val]) > 0 or self.d.pop(val, None)\\n        if newVal in self.d:\\n            self.d[newVal] = (self.d[newVal] | {i}) - {len(self.l)-1}\\n        self.l[i] = newVal\\n        self.l.pop()\\n        return True\\n\\n    def getRandom(self):\\n        return random.choice(self.l)\\n```\n```\\nimport random\\nclass RandomizedCollection(object):\\n    def __init__(self):\\n        self.l = []\\n        self.d = collections.defaultdict(set)\\n\\n    def insert(self, val):\\n        b = val not in self.d\\n        self.d[val].add(len(self.l))\\n        self.l.append(val)\\n        return b\\n\\n    def remove(self, val):\\n        if val not in self.d:\\n            return False\\n        i, newVal = self.d[val].pop(), self.l[-1]\\n        if len(self.d[val]) == 0:\\n            del self.d[val]\\n        self.l[i] = newVal\\n        if newVal in self.d:\\n            self.d[newVal].add(i)\\n            self.d[newVal].discard(len(self.l)-1)\\n        self.l.pop()\\n        return True\\n\\n    def getRandom(self):\\n        return random.choice(self.l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85646,
                "title": "short-ac-c-solution-with-vector-unordered-map-unordered-set",
                "content": "```\\nclass RandomizedCollection {\\nprivate:\\n    unordered_map<int, unordered_set<int>> map;\\n    vector<int> vec;\\n\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() { }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        map[val].insert(vec.size());\\n        vec.emplace_back(val);\\n        return map[val].size() == 1;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (map.find(val) == map.end()) return false;\\n        map[vec.back()].erase(vec.size() - 1);\\n        if (val != vec.back()) {\\n            int indx = *map[val].begin();             \\n            vec[indx] = vec.back();\\n            map[vec.back()].insert(indx);\\n            map[val].erase(indx);\\n        }\\n        vec.pop_back();\\n        if (map[val].size() == 0) map.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return vec[rand() % vec.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\nprivate:\\n    unordered_map<int, unordered_set<int>> map;\\n    vector<int> vec;\\n\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() { }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        map[val].insert(vec.size());\\n        vec.emplace_back(val);\\n        return map[val].size() == 1;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (map.find(val) == map.end()) return false;\\n        map[vec.back()].erase(vec.size() - 1);\\n        if (val != vec.back()) {\\n            int indx = *map[val].begin();             \\n            vec[indx] = vec.back();\\n            map[vec.back()].insert(indx);\\n            map[val].erase(indx);\\n        }\\n        vec.pop_back();\\n        if (map[val].size() == 0) map.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return vec[rand() % vec.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012320,
                "title": "simple-cpp-solution-using-map-and-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedCollection {\\npublic:\\n    int n;\\n    vector<int> v;\\n    unordered_map<int, vector<int> > mp;\\n    RandomizedCollection() {\\n        n=0;\\n        v.clear();\\n        mp.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        v.push_back(val);\\n        mp[val].push_back(n++);\\n        return mp[val].size()<2;\\n        \\n    }\\n    \\n    bool remove(int val) {\\n        if(mp[val].size()==0)return false;\\n        int index = mp[val][mp[val].size()-1];\\n        mp[val].pop_back();\\n        v[index]=v[n-1];\\n        v.pop_back();\\n        n--;\\n        if(n>index){ mp[v[index]][mp[v[index]].size()-1]=index;sort(mp[v[index]].begin(), mp[v[index]].end());}\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        int index = rand()%n;\\n        return v[index];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    int n;\\n    vector<int> v;\\n    unordered_map<int, vector<int> > mp;\\n    RandomizedCollection() {\\n        n=0;\\n        v.clear();\\n        mp.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        v.push_back(val);\\n        mp[val].push_back(n++);\\n        return mp[val].size()<2;\\n        \\n    }\\n    \\n    bool remove(int val) {\\n        if(mp[val].size()==0)return false;\\n        int index = mp[val][mp[val].size()-1];\\n        mp[val].pop_back();\\n        v[index]=v[n-1];\\n        v.pop_back();\\n        n--;\\n        if(n>index){ mp[v[index]][mp[v[index]].size()-1]=index;sort(mp[v[index]].begin(), mp[v[index]].end());}\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        int index = rand()%n;\\n        return v[index];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293021,
                "title": "python-3-simple-solution",
                "content": "\\n```\\nimport random\\nfrom collections import defaultdict\\n\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.vals = []\\n        self.locs = defaultdict(set)\\n\\n    def insert(self, val: int) -> bool:\\n        self.vals.append(val)\\n        self.locs[val].add(len(self.vals) - 1)\\n        return len(self.locs[val]) == 1\\n\\n    def remove(self, val: int) -> bool:\\n        if not self.locs[val]:\\n            return False\\n\\n        loc = self.locs[val].pop()\\n        last = self.vals[-1]\\n\\n        self.vals[loc] = last\\n        self.locs[last].add(loc)\\n        self.locs[last].discard(len(self.vals) - 1)\\n        self.vals.pop()\\n\\n        return True\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.vals)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport random\\nfrom collections import defaultdict\\n\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.vals = []\\n        self.locs = defaultdict(set)\\n\\n    def insert(self, val: int) -> bool:\\n        self.vals.append(val)\\n        self.locs[val].add(len(self.vals) - 1)\\n        return len(self.locs[val]) == 1\\n\\n    def remove(self, val: int) -> bool:\\n        if not self.locs[val]:\\n            return False\\n\\n        loc = self.locs[val].pop()\\n        last = self.vals[-1]\\n\\n        self.vals[loc] = last\\n        self.locs[last].add(loc)\\n        self.locs[last].discard(len(self.vals) - 1)\\n        self.vals.pop()\\n\\n        return True\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.vals)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860512,
                "title": "o-1-get-random-priority-queue-unordered-map",
                "content": "# Intuition\\nHuge thanks to [stanislav-iablokov](https://leetcode.com/stanislav-iablokov/) for this amazing [post](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2858200/python-c-hashmap-array-explained/) which made me able to implement this solution.\\n\\nFirst read that post then read further ,\\n\\nBasic idea is same ... but instead of saving element->index in map , we are storing indexes in priority queue , so that we get the last index of the element each time we pop out of priority queue...\\n\\n### Time complexity : \\n**insert -> O(log(E))  , E is number of times the element getting inserted is present in the multiset**\\n\\n**remove -> O( log(max(E1,E2) )) E1 frequency of val to remove in multiset , E2 is frequency of val that was inserted before it**\\n\\n**getRandom -> O(1)**\\n\\n# Code\\n```\\nclass RandomizedCollection {\\nprivate : \\n    unordered_map<int,priority_queue<int>> m ;\\n    vector<int> v ;\\npublic:\\n    RandomizedCollection() {\\n        srand(time(0)) ;\\n    }\\n\\n    bool insert(int val) {\\n        bool ret = false ;\\n        if( m.count(val) == 0 ) ret = true ;\\n\\n        v.push_back(val) ;\\n        m[val].push(v.size()-1) ;\\n        \\n        return ret ;\\n    }\\n    \\n    bool remove(int val) {\\n        if( m.count(val) == 1){\\n            int i = m[val].top() ;\\n            int s = v[i] = v[v.size()-1] ;\\n            \\n            m[s].pop();\\n            m[s].push(i) ;\\n\\n            m[val].pop() ;\\n            v.pop_back() ;\\n            \\n            if(m[val].size() == 0 ) m.erase(val) ;\\n\\n            return true ;\\n        }\\n\\n        return false ;\\n    }\\n    \\n    int getRandom() {\\n        int r = rand() % v.size() ;\\n        return v[r] ;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\nHuge thanks to [stanislav-iablokov](https://leetcode.com/stanislav-iablokov/) for this amazing [post](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2858200/python-c-hashmap-array-explained/) which made me able to implement this solution.\\n\\nFirst read that post then read further ,\\n\\nBasic idea is same ... but instead of saving element->index in map , we are storing indexes in priority queue , so that we get the last index of the element each time we pop out of priority queue...\\n\\n### Time complexity : \\n**insert -> O(log(E))  , E is number of times the element getting inserted is present in the multiset**\\n\\n**remove -> O( log(max(E1,E2) )) E1 frequency of val to remove in multiset , E2 is frequency of val that was inserted before it**\\n\\n**getRandom -> O(1)**\\n\\n# Code\\n```\\nclass RandomizedCollection {\\nprivate : \\n    unordered_map<int,priority_queue<int>> m ;\\n    vector<int> v ;\\npublic:\\n    RandomizedCollection() {\\n        srand(time(0)) ;\\n    }\\n\\n    bool insert(int val) {\\n        bool ret = false ;\\n        if( m.count(val) == 0 ) ret = true ;\\n\\n        v.push_back(val) ;\\n        m[val].push(v.size()-1) ;\\n        \\n        return ret ;\\n    }\\n    \\n    bool remove(int val) {\\n        if( m.count(val) == 1){\\n            int i = m[val].top() ;\\n            int s = v[i] = v[v.size()-1] ;\\n            \\n            m[s].pop();\\n            m[s].push(i) ;\\n\\n            m[val].pop() ;\\n            v.pop_back() ;\\n            \\n            if(m[val].size() == 0 ) m.erase(val) ;\\n\\n            return true ;\\n        }\\n\\n        return false ;\\n    }\\n    \\n    int getRandom() {\\n        int r = rand() % v.size() ;\\n        return v[r] ;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2859745,
                "title": "c-260ms-o-1",
                "content": "```c++\\n// index\\nunordered_map<int /* value */, vector<int> /* indices to storage */ >; \\n// storage\\nvector<pair<int /* value which will return. */, int /* inv-index of vector of hashmap */>>;\\n```\\n\\n```\\nclass RandomizedCollection {\\n    unordered_map<int, vector<int>> mark;\\n    vector<pair<int, int>> v;\\n    mt19937 rand;\\npublic:\\n    RandomizedCollection() {\\n        random_device seed;\\n        rand = mt19937(seed());\\n    }\\n    \\n    bool insert(int val) {\\n        bool ret{false};\\n        if (mark.find(val) == mark.end()) {\\n            ret = true;\\n            mark[val] = vector<int>();\\n        }\\n        mark[val].push_back(v.size());\\n        v.emplace_back(val, mark[val].size()-1);\\n        return ret;\\n    }\\n    \\n    bool remove(int val) {\\n        auto it = mark.find(val);\\n        if (it == mark.end()) return false;\\n        int del_idx = it->second.back();\\n        v[del_idx] = v.back();\\n        auto [mov_val, mov_idx] = v.back();\\n        mark[mov_val][mov_idx] = del_idx;\\n        \\n        v.pop_back();\\n        it->second.pop_back();\\n        if (it->second.empty())\\n            mark.erase(it);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand() % v.size()].first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\n// index\\nunordered_map<int /* value */, vector<int> /* indices to storage */ >; \\n// storage\\nvector<pair<int /* value which will return. */, int /* inv-index of vector of hashmap */>>;\\n```\n```\\nclass RandomizedCollection {\\n    unordered_map<int, vector<int>> mark;\\n    vector<pair<int, int>> v;\\n    mt19937 rand;\\npublic:\\n    RandomizedCollection() {\\n        random_device seed;\\n        rand = mt19937(seed());\\n    }\\n    \\n    bool insert(int val) {\\n        bool ret{false};\\n        if (mark.find(val) == mark.end()) {\\n            ret = true;\\n            mark[val] = vector<int>();\\n        }\\n        mark[val].push_back(v.size());\\n        v.emplace_back(val, mark[val].size()-1);\\n        return ret;\\n    }\\n    \\n    bool remove(int val) {\\n        auto it = mark.find(val);\\n        if (it == mark.end()) return false;\\n        int del_idx = it->second.back();\\n        v[del_idx] = v.back();\\n        auto [mov_val, mov_idx] = v.back();\\n        mark[mov_val][mov_idx] = del_idx;\\n        \\n        v.pop_back();\\n        it->second.pop_back();\\n        if (it->second.empty())\\n            mark.erase(it);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand() % v.size()].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783698,
                "title": "rust-hashmap-hashset",
                "content": "In order to make get random O(1) we maintain a vector with duplicates of all values allowed.  To make remove O(1) we maintain a a Hashmap that points to a set of indicies with the value in question in the universe.  When we remove a value from the middle of the universe we swap it for the last value and update the Hashmap accordingly.\\n```\\nuse std::collections::{HashMap,HashSet};\\nuse rand::{thread_rng, Rng};\\n\\nstruct RandomizedCollection {\\n    inds: HashMap<i32,HashSet<usize>>,\\n    universe: Vec<i32>,\\n}\\n\\nimpl RandomizedCollection {\\n\\n    fn new() -> Self {\\n        RandomizedCollection{inds: HashMap::new(), universe: Vec::new()}\\n    }\\n    \\n    fn insert(&mut self, val: i32) -> bool {\\n        let last = self.universe.len();\\n        self.universe.push(val);\\n        if let Some(ind) = self.inds.get_mut(&val) {\\n            (*ind).insert(last);\\n            ind.len() == 1\\n        } else {\\n            self.inds.insert(val,HashSet::from([last]));\\n            true\\n        }\\n    }\\n    \\n    fn remove(&mut self, val: i32) -> bool {\\n        if self.universe.is_empty() {\\n            return false\\n        }\\n        let last_ind = self.universe.len() - 1;\\n        let last_val = self.universe[last_ind].clone();\\n        if last_val == val {\\n            self.universe.pop();\\n            self.inds.entry(val).and_modify(|v| {(*v).remove(&last_ind);});\\n            true\\n        } else if let Some(ind) = self.inds.get_mut(&val) {\\n            if ind.is_empty() {\\n                return false\\n            } else {\\n                let xind = ind.iter().next().unwrap().clone();\\n                ind.remove(&xind);\\n                self.universe.swap(xind,last_ind);\\n                self.universe.pop();\\n                self.inds.entry(last_val).and_modify(|v| {(*v).remove(&last_ind); (*v).insert(xind);});\\n                true\\n            }\\n        } else {\\n            false\\n        }\\n        \\n    }\\n    \\n    fn get_random(&self) -> i32 {\\n        let mut rng = thread_rng();\\n        self.universe[rng.gen_range(0,self.universe.len())]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::{HashMap,HashSet};\\nuse rand::{thread_rng, Rng};\\n\\nstruct RandomizedCollection {\\n    inds: HashMap<i32,HashSet<usize>>,\\n    universe: Vec<i32>,\\n}\\n\\nimpl RandomizedCollection {\\n\\n    fn new() -> Self {\\n        RandomizedCollection{inds: HashMap::new(), universe: Vec::new()}\\n    }\\n    \\n    fn insert(&mut self, val: i32) -> bool {\\n        let last = self.universe.len();\\n        self.universe.push(val);\\n        if let Some(ind) = self.inds.get_mut(&val) {\\n            (*ind).insert(last);\\n            ind.len() == 1\\n        } else {\\n            self.inds.insert(val,HashSet::from([last]));\\n            true\\n        }\\n    }\\n    \\n    fn remove(&mut self, val: i32) -> bool {\\n        if self.universe.is_empty() {\\n            return false\\n        }\\n        let last_ind = self.universe.len() - 1;\\n        let last_val = self.universe[last_ind].clone();\\n        if last_val == val {\\n            self.universe.pop();\\n            self.inds.entry(val).and_modify(|v| {(*v).remove(&last_ind);});\\n            true\\n        } else if let Some(ind) = self.inds.get_mut(&val) {\\n            if ind.is_empty() {\\n                return false\\n            } else {\\n                let xind = ind.iter().next().unwrap().clone();\\n                ind.remove(&xind);\\n                self.universe.swap(xind,last_ind);\\n                self.universe.pop();\\n                self.inds.entry(last_val).and_modify(|v| {(*v).remove(&last_ind); (*v).insert(xind);});\\n                true\\n            }\\n        } else {\\n            false\\n        }\\n        \\n    }\\n    \\n    fn get_random(&self) -> i32 {\\n        let mut rng = thread_rng();\\n        self.universe[rng.gen_range(0,self.universe.len())]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329227,
                "title": "python-amortized-o-1-rejection-sampling",
                "content": "This is only a tad different than the other solutions. The idea here is that we will use getRandom() to do the work incurred by and remove() calls. Specifically, when sampling a random value, we will reject it with a probability that increases with how over-represented the value currently is in the sampling list. If the value is rejected, we also remove it from the sampling list (replacing it with the last element in the list).\\n\\nWe keep track of three data structures:\\n\\n**CollectionFrequency**: A hashmap that maps keys to the # of times they are supposed to appear in the randomized collection\\n**SamplingList**: A list of keys (with repeats allowed), where the frequency of each key is >= the frequency that they are supposed to appear in the collection\\n**ListFrequency**: A hashmap that maps keys to the # of times they currently appear in the sampling list\\n\\nWith those three data structures, here is how we implement the interface:\\n\\n**Insert(val)**: Increment CollectionFrequency[val]. If this results in CollectionFrequency[val]>ListFrequency[val], we add another instance of val to the sampling list, and increment ListFrequency[val].\\n\\n**Remove(val)**: Decrement CollectionFrequency[val]. That\\'s it. The actual work of removing an instance of val from the list will be performed during calls to getRandom()\\n\\n**getRandom()** We begin by choosing a value from SamplingList at random. We then roll to either accept or reject the sample, with the acceptance probability being CollectionFrequency[val]/ListFrequency[val]. If we accept, we return the value. If we reject, we remove val from SamplingList by popping off the last element of SamplingList and placing it where val currently is. We repeat this process until we accept a value.\\n\\n**Computational complexity of getRandom()**: In a single call to getRandom(), it is indeed possible to reject the sample several times. However, since we remove that value from the list each time we reject that value, the total number of rejections across all calls to getRandom() is bounded above by the total number of calls to remove(). Since each rejection takes O(1) time,  we have just deferred the cost of each remove() call to the getRandom() calls. With this amortization, it becomes O(1)\\n\\n**Probability of accepting a value**: I\\'m going to describe a different process for executing getRandom, and  then use this to show that probabilities used in our implementation of rejection sampling are correct. \\n\\nAt the start of our getRandom(), we\\'ll paint each element of SamplingList with accept or reject.  Specifically, for each possible value, we\\'ll paint CollectionFrequency(val) instances of value as accept, and the remaining ListFrequency(val)-CollectionFrequency(val) with reject. We then choose an element of SamplingList at random. If the element is painted accept, we return that element. If the element is painted reject, we delete the element from the list, and then try choosing another element, repeating until we accept an element. The probability of returning any given value is equal to: \\n\\n(#instances of val painted accept/#elements of SamplingList painted accept)=(CollectionFrequency[val]/Sum of CollectionFrequency[i])\\n\\nwhich is the probability we are looking for. If we were to first reveal val before revealing accept/reject, then the probability of accept/reject conditioned on val is equal to:\\n\\n(#instances of val painted accept/#instances of val in sampling list) = (CollectionFrequency[val]/ListFrequency[val])\\n\\nwhich is identical to the accept probability we use in the original implementation of getRandom(). This demonstrates that the accept probabilities in our original implementation of getRandom() will result in getRandom() returning each value with the correct probability.\\n\\n```\\nfrom random import randint\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        #number of times each value shows up in the randomized collection\\n        self.freq_in_collection = {}\\n        \\n        #number of times each value shows up in the list used for random sampling\\n        self.freq_in_list = {}\\n        \\n        #the list used for random sampling\\n        self.val_list = []\\n        \\n        #length of the list used for sampling\\n        #if we need to pop of the end of the list, we just decrease list_len by 1\\n        #instead of performing an actual pop\\n        self.list_len = 0\\n\\n    def insert(self, val):\\n        \\n        \\n        return_val = None\\n        \\n        if val in self.freq_in_collection:\\n            return_val = self.freq_in_collection[val]==0\\n            \\n            #update the number of times val shows up in the collection\\n            self.freq_in_collection[val]+=1\\n            \\n            #if the number of times val shows up in the sampling list is less than\\n            #its frequency in the collection, we add another instance of val to the sampling list\\n            #and update the frequency it appears in the sampling list\\n            if self.freq_in_collection[val]>self.freq_in_list[val]:\\n                self.freq_in_list[val]+=1\\n                if self.list_len<len(self.val_list):\\n                    self.val_list[self.list_len]=val\\n                else:\\n                    self.val_list.append(val)\\n                self.list_len+=1\\n        else:\\n            return_val = True\\n            self.freq_in_collection[val]=1\\n            self.freq_in_list[val]=1\\n            if self.list_len<len(self.val_list): self.val_list[self.list_len]=val\\n            else: self.val_list.append(val)\\n            self.list_len+=1\\n\\n        return return_val\\n    \\n    def remove(self, val):\\n        \\n        #update the collection frequency of the value\\n        if val in self.freq_in_collection and self.freq_in_collection[val]>0: \\n            self.freq_in_collection[val]-=1\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self):\\n                \\n        while True:\\n            #Choose a random sample from the list\\n            sample_index = randint(0,self.list_len-1)\\n            sample_val = self.val_list[sample_index]\\n\\n            #Reject the sample with probability  1-(List_Frequency/Collection Frequency)\\n            if randint(1,self.freq_in_list[sample_val])>self.freq_in_collection[sample_val]:\\n                #Rejecting the sample means that the sample corresponded to a value that was removed\\n                #In this case, we replace it with the last element of the list (which we have popped off)\\n                self.val_list[sample_index]=self.val_list[self.list_len-1]\\n                self.list_len-=1\\n                \\n                #and then we update the list frequency of the sample we have just removed\\n                self.freq_in_list[sample_val]-=1\\n                \\n                #every rejection takes O(1) time, and we will only ever reject at most N samples, \\n                #where N is the number of times that remove() was called (after which, all samples are a guaranteed accept)\\n                #So, amortized by our remove() calls, this is O(1), it\\'s just that we have deferred the cost of a removal\\n                #up until the point that we reject a sample\\n            else:        \\n                return sample_val\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "This is only a tad different than the other solutions. The idea here is that we will use getRandom() to do the work incurred by and remove() calls. Specifically, when sampling a random value, we will reject it with a probability that increases with how over-represented the value currently is in the sampling list. If the value is rejected, we also remove it from the sampling list (replacing it with the last element in the list).\\n\\nWe keep track of three data structures:\\n\\n**CollectionFrequency**: A hashmap that maps keys to the # of times they are supposed to appear in the randomized collection\\n**SamplingList**: A list of keys (with repeats allowed), where the frequency of each key is >= the frequency that they are supposed to appear in the collection\\n**ListFrequency**: A hashmap that maps keys to the # of times they currently appear in the sampling list\\n\\nWith those three data structures, here is how we implement the interface:\\n\\n**Insert(val)**: Increment CollectionFrequency[val]. If this results in CollectionFrequency[val]>ListFrequency[val], we add another instance of val to the sampling list, and increment ListFrequency[val].\\n\\n**Remove(val)**: Decrement CollectionFrequency[val]. That\\'s it. The actual work of removing an instance of val from the list will be performed during calls to getRandom()\\n\\n**getRandom()** We begin by choosing a value from SamplingList at random. We then roll to either accept or reject the sample, with the acceptance probability being CollectionFrequency[val]/ListFrequency[val]. If we accept, we return the value. If we reject, we remove val from SamplingList by popping off the last element of SamplingList and placing it where val currently is. We repeat this process until we accept a value.\\n\\n**Computational complexity of getRandom()**: In a single call to getRandom(), it is indeed possible to reject the sample several times. However, since we remove that value from the list each time we reject that value, the total number of rejections across all calls to getRandom() is bounded above by the total number of calls to remove(). Since each rejection takes O(1) time,  we have just deferred the cost of each remove() call to the getRandom() calls. With this amortization, it becomes O(1)\\n\\n**Probability of accepting a value**: I\\'m going to describe a different process for executing getRandom, and  then use this to show that probabilities used in our implementation of rejection sampling are correct. \\n\\nAt the start of our getRandom(), we\\'ll paint each element of SamplingList with accept or reject.  Specifically, for each possible value, we\\'ll paint CollectionFrequency(val) instances of value as accept, and the remaining ListFrequency(val)-CollectionFrequency(val) with reject. We then choose an element of SamplingList at random. If the element is painted accept, we return that element. If the element is painted reject, we delete the element from the list, and then try choosing another element, repeating until we accept an element. The probability of returning any given value is equal to: \\n\\n(#instances of val painted accept/#elements of SamplingList painted accept)=(CollectionFrequency[val]/Sum of CollectionFrequency[i])\\n\\nwhich is the probability we are looking for. If we were to first reveal val before revealing accept/reject, then the probability of accept/reject conditioned on val is equal to:\\n\\n(#instances of val painted accept/#instances of val in sampling list) = (CollectionFrequency[val]/ListFrequency[val])\\n\\nwhich is identical to the accept probability we use in the original implementation of getRandom(). This demonstrates that the accept probabilities in our original implementation of getRandom() will result in getRandom() returning each value with the correct probability.\\n\\n```\\nfrom random import randint\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        #number of times each value shows up in the randomized collection\\n        self.freq_in_collection = {}\\n        \\n        #number of times each value shows up in the list used for random sampling\\n        self.freq_in_list = {}\\n        \\n        #the list used for random sampling\\n        self.val_list = []\\n        \\n        #length of the list used for sampling\\n        #if we need to pop of the end of the list, we just decrease list_len by 1\\n        #instead of performing an actual pop\\n        self.list_len = 0\\n\\n    def insert(self, val):\\n        \\n        \\n        return_val = None\\n        \\n        if val in self.freq_in_collection:\\n            return_val = self.freq_in_collection[val]==0\\n            \\n            #update the number of times val shows up in the collection\\n            self.freq_in_collection[val]+=1\\n            \\n            #if the number of times val shows up in the sampling list is less than\\n            #its frequency in the collection, we add another instance of val to the sampling list\\n            #and update the frequency it appears in the sampling list\\n            if self.freq_in_collection[val]>self.freq_in_list[val]:\\n                self.freq_in_list[val]+=1\\n                if self.list_len<len(self.val_list):\\n                    self.val_list[self.list_len]=val\\n                else:\\n                    self.val_list.append(val)\\n                self.list_len+=1\\n        else:\\n            return_val = True\\n            self.freq_in_collection[val]=1\\n            self.freq_in_list[val]=1\\n            if self.list_len<len(self.val_list): self.val_list[self.list_len]=val\\n            else: self.val_list.append(val)\\n            self.list_len+=1\\n\\n        return return_val\\n    \\n    def remove(self, val):\\n        \\n        #update the collection frequency of the value\\n        if val in self.freq_in_collection and self.freq_in_collection[val]>0: \\n            self.freq_in_collection[val]-=1\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self):\\n                \\n        while True:\\n            #Choose a random sample from the list\\n            sample_index = randint(0,self.list_len-1)\\n            sample_val = self.val_list[sample_index]\\n\\n            #Reject the sample with probability  1-(List_Frequency/Collection Frequency)\\n            if randint(1,self.freq_in_list[sample_val])>self.freq_in_collection[sample_val]:\\n                #Rejecting the sample means that the sample corresponded to a value that was removed\\n                #In this case, we replace it with the last element of the list (which we have popped off)\\n                self.val_list[sample_index]=self.val_list[self.list_len-1]\\n                self.list_len-=1\\n                \\n                #and then we update the list frequency of the sample we have just removed\\n                self.freq_in_list[sample_val]-=1\\n                \\n                #every rejection takes O(1) time, and we will only ever reject at most N samples, \\n                #where N is the number of times that remove() was called (after which, all samples are a guaranteed accept)\\n                #So, amortized by our remove() calls, this is O(1), it\\'s just that we have deferred the cost of a removal\\n                #up until the point that we reject a sample\\n            else:        \\n                return sample_val\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2321396,
                "title": "using-two-hashmaps-and-an-array",
                "content": "### Idea\\n\\nThe basic idea is to delay removal of elements. We keep two hashMaps `realCnt` & `cnt` and `arr` for this. `arr` is a list which stores all inserted `val`s. When a `val` is inserted, we push the `val` to `arr`. The keys of both `realCnt` and `cnt` are `val`s. The value of `realCnt` is the actual number of each `val` that would have been in the collection if we removed `val`s without any delay. The value of `cnt` is the number of each `val` in `arr`. In other words, `cnt` always has an equal or greater number than `realCnt`. When we do `remove` of `val`, we do not modify `arr` (which we should have) to reduce time complexity, but we just modify `realCnt` for the `val`. \\n\\nThe actual removal happens during `getRandom`. When we picked a random element in `arr` and if the value of its `realCnt` and `cnt` does not match, we remove the element from `arr` and we try again. Delayed removal helps reducing time complexity because it avoids searching of elements to remove in `arr`. Although delayed removal may make a single `getRandom` call be `O(n)` in the worst case, the average of all calls will be still  `O(1)`.\\n\\n### Complexity\\n\\nTime: `O(n)` hence, `O(1)` in average\\nSpace:  `O(i)`\\n\\nwhere `n` is the number of `insert`, `remove`, `getRandom` calls and `i` is the number of `insert` calls\\n\\n\\n```typescript\\nclass RandomizedCollection {\\n    arr = []\\n    realCnt = new Map<number, number>()\\n    cnt = new Map<number, number>()\\n    \\n    constructor() {}\\n\\n    insert(val: number): boolean {\\n        const rc = this.realCnt.get(val) ?? 0\\n        const c = this.cnt.get(val) ?? 0\\n        const res = rc === 0\\n        if (rc === c) {\\n            this.realCnt.set(val, rc+1)\\n            this.cnt.set(val, c+1)\\n            this.arr.push(val)\\n        } else if (rc < c) {\\n            this.realCnt.set(val, rc+1)\\n        }\\n        return res\\n    }\\n\\n    remove(val: number): boolean {\\n        const rc = this.realCnt.get(val) ?? 0\\n        const res = 0 < rc\\n        this.realCnt.set(val, Math.max(rc-1, 0))\\n        return res\\n    }\\n\\n    getRandom(): number {\\n        while (true) {\\n            const rand = _.random(0, this.arr.length-1)\\n            const rc = this.realCnt.get(this.arr[rand]) ?? 0\\n            const c = this.cnt.get(this.arr[rand]) ?? 0\\n            if (rc < c) {\\n                this.cnt.set(this.arr[rand], c-1)\\n                this.arr.splice(rand, 1)\\n            } else if (rc === c) {\\n                return this.arr[rand]\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nclass RandomizedCollection {\\n    arr = []\\n    realCnt = new Map<number, number>()\\n    cnt = new Map<number, number>()\\n    \\n    constructor() {}\\n\\n    insert(val: number): boolean {\\n        const rc = this.realCnt.get(val) ?? 0\\n        const c = this.cnt.get(val) ?? 0\\n        const res = rc === 0\\n        if (rc === c) {\\n            this.realCnt.set(val, rc+1)\\n            this.cnt.set(val, c+1)\\n            this.arr.push(val)\\n        } else if (rc < c) {\\n            this.realCnt.set(val, rc+1)\\n        }\\n        return res\\n    }\\n\\n    remove(val: number): boolean {\\n        const rc = this.realCnt.get(val) ?? 0\\n        const res = 0 < rc\\n        this.realCnt.set(val, Math.max(rc-1, 0))\\n        return res\\n    }\\n\\n    getRandom(): number {\\n        while (true) {\\n            const rand = _.random(0, this.arr.length-1)\\n            const rc = this.realCnt.get(this.arr[rand]) ?? 0\\n            const c = this.cnt.get(this.arr[rand]) ?? 0\\n            if (rc < c) {\\n                this.cnt.set(this.arr[rand], c-1)\\n                this.arr.splice(rand, 1)\\n            } else if (rc === c) {\\n                return this.arr[rand]\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271606,
                "title": "java-map-list",
                "content": "```\\nclass RandomizedCollection {\\n    private Map<Integer,List<Integer>> map;\\n    private List<Integer> list;\\n    private int pos;\\n    \\n    public RandomizedCollection() {\\n        this.map = new HashMap<>();\\n        this.list = new ArrayList<>();\\n        this.pos = -1;\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(map.get(val) == null) {\\n            pos++;\\n            list.add(pos,val);\\n            List<Integer> lst = new ArrayList<>();\\n            lst.add(pos);\\n            map.put(val, lst);\\n            return true;\\n        } else {\\n            pos++;\\n            list.add(pos,val);\\n            map.get(val).add(pos);\\n            return false;\\n        }\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.get(val) == null) {\\n            return false;\\n        } else {\\n            List<Integer> lst = map.get(val);\\n            //get first indx of th val to be removed\\n            int idx = lst.remove(0);\\n            if(map.get(val).size() == 0)\\n                map.remove(val);\\n            \\n            //get last element to be swaped with element to be deleted\\n            int last = list.get(pos);\\n            //get pos list of last element and updte it\\n            if(idx != pos) {\\n                List<Integer> last_element_list = map.get(last);\\n                last_element_list.remove(new Integer(pos));\\n                last_element_list.add(idx);\\n                //overrrite the element to be deleted by last element\\n                list.set(idx, list.get(pos));\\n            }\\n            pos--;\\n            return true;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        Random rdm = new Random();\\n        return list.get(rdm.nextInt(this.pos+1));\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    private Map<Integer,List<Integer>> map;\\n    private List<Integer> list;\\n    private int pos;\\n    \\n    public RandomizedCollection() {\\n        this.map = new HashMap<>();\\n        this.list = new ArrayList<>();\\n        this.pos = -1;\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(map.get(val) == null) {\\n            pos++;\\n            list.add(pos,val);\\n            List<Integer> lst = new ArrayList<>();\\n            lst.add(pos);\\n            map.put(val, lst);\\n            return true;\\n        } else {\\n            pos++;\\n            list.add(pos,val);\\n            map.get(val).add(pos);\\n            return false;\\n        }\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.get(val) == null) {\\n            return false;\\n        } else {\\n            List<Integer> lst = map.get(val);\\n            //get first indx of th val to be removed\\n            int idx = lst.remove(0);\\n            if(map.get(val).size() == 0)\\n                map.remove(val);\\n            \\n            //get last element to be swaped with element to be deleted\\n            int last = list.get(pos);\\n            //get pos list of last element and updte it\\n            if(idx != pos) {\\n                List<Integer> last_element_list = map.get(last);\\n                last_element_list.remove(new Integer(pos));\\n                last_element_list.add(idx);\\n                //overrrite the element to be deleted by last element\\n                list.set(idx, list.get(pos));\\n            }\\n            pos--;\\n            return true;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        Random rdm = new Random();\\n        return list.get(rdm.nextInt(this.pos+1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191595,
                "title": "python-list-and-dict-set-of-indices-real-o-1-solution-without-list-remove-function",
                "content": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.result = []\\n        # Additional memory - Map between value and SET of indices \\n        self.element_to_indices = {}\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        val_idx = len(self.result)\\n        self.result.append(val)\\n        \\n        if val in self.element_to_indices:\\n            self.element_to_indices[val].add(val_idx)\\n            return False\\n        else:\\n            self.element_to_indices[val] = set([val_idx])\\n            return True\\n\\n    # Objective here is to use array.pop() as its O(1)\\n    def remove(self, val: int) -> bool:\\n        \\n        if val not in self.element_to_indices:\\n            return False\\n        \\n        last_idx = len(self.result) - 1\\n        idx_to_pop = self.element_to_indices[val].pop()\\n            \\n        if not self.element_to_indices[val]:\\n            del self.element_to_indices[val]\\n            \\n        # Swapping val with element in last position \\n        # And updating the indices SET accordingly\\n        if last_idx != idx_to_pop:\\n            last_ele = self.result[last_idx]\\n                \\n            # Indices are stored in SET O(1) add and remove here\\n            self.element_to_indices[last_ele].remove(last_idx)\\n            self.element_to_indices[last_ele].add(idx_to_pop)\\n                \\n            self.result[idx_to_pop], self.result[last_idx] = self.result[last_idx], self.result[idx_to_pop]\\n                \\n        self.result.pop()\\n        return True       \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.result)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.result = []\\n        # Additional memory - Map between value and SET of indices \\n        self.element_to_indices = {}\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        val_idx = len(self.result)\\n        self.result.append(val)\\n        \\n        if val in self.element_to_indices:\\n            self.element_to_indices[val].add(val_idx)\\n            return False\\n        else:\\n            self.element_to_indices[val] = set([val_idx])\\n            return True\\n\\n    # Objective here is to use array.pop() as its O(1)\\n    def remove(self, val: int) -> bool:\\n        \\n        if val not in self.element_to_indices:\\n            return False\\n        \\n        last_idx = len(self.result) - 1\\n        idx_to_pop = self.element_to_indices[val].pop()\\n            \\n        if not self.element_to_indices[val]:\\n            del self.element_to_indices[val]\\n            \\n        # Swapping val with element in last position \\n        # And updating the indices SET accordingly\\n        if last_idx != idx_to_pop:\\n            last_ele = self.result[last_idx]\\n                \\n            # Indices are stored in SET O(1) add and remove here\\n            self.element_to_indices[last_ele].remove(last_idx)\\n            self.element_to_indices[last_ele].add(idx_to_pop)\\n                \\n            self.result[idx_to_pop], self.result[last_idx] = self.result[last_idx], self.result[idx_to_pop]\\n                \\n        self.result.pop()\\n        return True       \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167409,
                "title": "c",
                "content": "(```)  class RandomizedCollection {\\npublic:\\n    \\n    unordered_map<int,vector<int>> mp;\\n    vector<pair<int,int>> nums;\\n        \\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        \\n     bool it = mp.find(val) == mp.end();\\n        \\n     mp[val].push_back(nums.size());\\n     nums.push_back({val,mp[val].size()-1});\\n    \\n     return it;\\n        \\n    }\\n    \\n    bool remove(int val) {\\n        \\n     bool it = mp.find(val) != mp.end();\\n    \\n        if(it)\\n        {\\n            auto last = nums.back();\\n            mp[last.first][last.second] = mp[val].back();\\n            nums[mp[val].back()] = last;\\n            mp[val].pop_back();\\n            \\n            if(mp[val].size() == 0)\\n            {\\n                mp.erase(val);\\n            }\\n            \\n            nums.pop_back();\\n        }\\n        \\n        return it;\\n     \\n        \\n    }\\n    \\n    int getRandom() {\\n        \\n        return nums[rand()%nums.size()].first;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "(```)  class RandomizedCollection {\\npublic:\\n    \\n    unordered_map<int,vector<int>> mp;\\n    vector<pair<int,int>> nums;\\n        \\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        \\n     bool it = mp.find(val) == mp.end();\\n        \\n     mp[val].push_back(nums.size());\\n     nums.push_back({val,mp[val].size()-1});\\n    \\n     return it;\\n        \\n    }\\n    \\n    bool remove(int val) {\\n        \\n     bool it = mp.find(val) != mp.end();\\n    \\n        if(it)\\n        {\\n            auto last = nums.back();\\n            mp[last.first][last.second] = mp[val].back();\\n            nums[mp[val].back()] = last;\\n            mp[val].pop_back();\\n            \\n            if(mp[val].size() == 0)\\n            {\\n                mp.erase(val);\\n            }\\n            \\n            nums.pop_back();\\n        }\\n        \\n        return it;\\n     \\n        \\n    }\\n    \\n    int getRandom() {\\n        \\n        return nums[rand()%nums.size()].first;\\n        \\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2155871,
                "title": "python-hashmap-with-clear-cut-code-and-explanation",
                "content": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.freq = {}  # if ans contains 2,2,3, count of same elements present in ans, so freq[::] = 0, 2, 1\\n        self.ans = []  \\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.freq:\\n            self.freq[val] = 1\\n            self.ans.append(val)\\n            return True\\n        else:\\n            self.freq[val] += 1\\n            self.ans.append(val)\\n            return False\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.freq:  \\n            if self.freq[val] > 1:   # when the element occurs more than one time in the array\\n                self.freq[val] -= 1\\n                self.ans.remove(val)\\n            else:                    # occurs 1 time\\n                self.freq.pop(val)   \\n                self.ans.remove(val)\\n            return True\\n        else:                        # is not present\\n            return False\\n\\n    def getRandom(self) -> int:\\n        n = len(self.ans)  \\n        rand = randint(0, n - 1)  # doing all this so index does not go out of range\\n        return self.ans[rand]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.freq = {}  # if ans contains 2,2,3, count of same elements present in ans, so freq[::] = 0, 2, 1\\n        self.ans = []  \\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.freq:\\n            self.freq[val] = 1\\n            self.ans.append(val)\\n            return True\\n        else:\\n            self.freq[val] += 1\\n            self.ans.append(val)\\n            return False\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.freq:  \\n            if self.freq[val] > 1:   # when the element occurs more than one time in the array\\n                self.freq[val] -= 1\\n                self.ans.remove(val)\\n            else:                    # occurs 1 time\\n                self.freq.pop(val)   \\n                self.ans.remove(val)\\n            return True\\n        else:                        # is not present\\n            return False\\n\\n    def getRandom(self) -> int:\\n        n = len(self.ans)  \\n        rand = randint(0, n - 1)  # doing all this so index does not go out of range\\n        return self.ans[rand]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080649,
                "title": "easy-implementation-using-only-single-arraylist",
                "content": "class RandomizedCollection {\\n    List<Integer> list;\\n    Random random;\\n\\n    public RandomizedCollection() {\\n        list=new ArrayList<>();\\n        random=new Random();\\n        \\n    }\\n    \\n    public boolean insert(int val) \\n    {\\n        if(list.contains(val)==false)\\n        {\\n            list.add(val);\\n            return true;\\n        }\\n        list.add(val);\\n        return false;\\n        \\n    }\\n    \\n    public boolean remove(int val) \\n    {\\n        if(list.contains(val)==true)\\n        {\\n            list.remove(new Integer(val));\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom()\\n    {\\n        if(list.size()==0)\\n        {\\n            return 1;\\n        }\\n        \\n        int ind=random.nextInt(list.size());\\n        return list.get(ind);\\n        \\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class RandomizedCollection {\\n    List<Integer> list;\\n    Random random;\\n\\n    public RandomizedCollection() {\\n        list=new ArrayList<>();\\n        random=new Random();\\n        \\n    }\\n    \\n    public boolean insert(int val) \\n    {\\n        if(list.contains(val)==false)\\n        {\\n            list.add(val);\\n            return true;\\n        }\\n        list.add(val);\\n        return false;\\n        \\n    }\\n    \\n    public boolean remove(int val) \\n    {\\n        if(list.contains(val)==true)\\n        {\\n            list.remove(new Integer(val));\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom()\\n    {\\n        if(list.size()==0)\\n        {\\n            return 1;\\n        }\\n        \\n        int ind=random.nextInt(list.size());\\n        return list.get(ind);\\n        \\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2020744,
                "title": "python-solution",
                "content": "The main idea is that there should be two background data-structures: list and dict. dict has to be a map of value in the list to max-heap (max-priority-queue) of indexes in the list. Why max-priority-queue is because you always want to pop the latest index for a given value and when you swap or add new value - you want all the values to be sorted so that next pop gives you the latest index again.\\n\\n```\\nimport random\\nfrom heapq import heappush, heappop\\n\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.h = {}\\n        self.arr = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.arr.append(val)\\n        if val in self.h:\\n            heap = self.h[val]\\n            heappush(heap, -(len(self.arr) - 1))\\n            self.h[val] = heap\\n            return False\\n        else:\\n            heap = []\\n            heappush(heap, -(len(self.arr) - 1))\\n            self.h[val] = heap\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.h:\\n            indexes_heap = self.h[val]\\n            last_index = -heappop(indexes_heap)\\n            \\n            if last_index == len(self.arr) - 1:\\n                self.arr.pop()\\n            else:\\n                last_val = self.arr[-1]\\n                \\n                self.arr[last_index] = last_val\\n                self.arr.pop()\\n                \\n                heappop(self.h[last_val])\\n                heappush(self.h[last_val], -last_index)\\n                \\n            if len(indexes_heap) == 0:\\n                self.h.pop(val)\\n            \\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        r = random.randint(0, len(self.arr)-1)\\n        return self.arr[r]\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\nfrom heapq import heappush, heappop\\n\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.h = {}\\n        self.arr = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.arr.append(val)\\n        if val in self.h:\\n            heap = self.h[val]\\n            heappush(heap, -(len(self.arr) - 1))\\n            self.h[val] = heap\\n            return False\\n        else:\\n            heap = []\\n            heappush(heap, -(len(self.arr) - 1))\\n            self.h[val] = heap\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.h:\\n            indexes_heap = self.h[val]\\n            last_index = -heappop(indexes_heap)\\n            \\n            if last_index == len(self.arr) - 1:\\n                self.arr.pop()\\n            else:\\n                last_val = self.arr[-1]\\n                \\n                self.arr[last_index] = last_val\\n                self.arr.pop()\\n                \\n                heappop(self.h[last_val])\\n                heappush(self.h[last_val], -last_index)\\n                \\n            if len(indexes_heap) == 0:\\n                self.h.pop(val)\\n            \\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        r = random.randint(0, len(self.arr)-1)\\n        return self.arr[r]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009753,
                "title": "easy-java-implementation",
                "content": "```\\nclass RandomizedCollection {\\n    \\n    private  HashMap<Integer, Integer> map;\\n    private ArrayList<Integer> list ;\\n    public RandomizedCollection() {\\n        map = new HashMap<>();\\n        list = new ArrayList<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        list.add(val);\\n        if(!map.containsKey(val)){\\n            map.put(val,1);\\n            return true;\\n        }else{\\n            map.put(val, map.get(val) + 1);\\n            return false;\\n        }\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) return false;\\n        else{\\n            \\n            int index = list.indexOf(val);\\n            list.remove(index);\\n            \\n            if(map.get(val) == 1) map.remove(val);\\n            else map.put(val, map.get(val)-1);\\n            return true;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        \\n        int rand_int = (int)Math.floor(Math.random()*(list.size()));\\n         return list.get(rand_int);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    \\n    private  HashMap<Integer, Integer> map;\\n    private ArrayList<Integer> list ;\\n    public RandomizedCollection() {\\n        map = new HashMap<>();\\n        list = new ArrayList<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        list.add(val);\\n        if(!map.containsKey(val)){\\n            map.put(val,1);\\n            return true;\\n        }else{\\n            map.put(val, map.get(val) + 1);\\n            return false;\\n        }\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) return false;\\n        else{\\n            \\n            int index = list.indexOf(val);\\n            list.remove(index);\\n            \\n            if(map.get(val) == 1) map.remove(val);\\n            else map.put(val, map.get(val)-1);\\n            return true;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        \\n        int rand_int = (int)Math.floor(Math.random()*(list.size()));\\n         return list.get(rand_int);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962700,
                "title": "clean-solution-java-with-comments",
                "content": "```\\nclass RandomizedCollection {\\n    List<Integer> nums;\\n\\tMap<Integer,Set<Integer>> maps; // it will store the value and its indexes in the map so that it will be easy to delete in remove method\\n\\n    public RandomizedCollection() {\\n         nums = new ArrayList<>();\\n        maps = new HashMap<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        boolean check = !maps.containsKey(val); //Check if the map contains the val to be inserted\\n        if(check){// if val does not exist , insert in map with a new hashSet initialized \\n            maps.put(val, new HashSet<>());\\n        }\\n        maps.get(val).add(nums.size());// Add index of the val to the hashset with nums.size() which will be 0 here since we are yet to add values in nums array.\\n        nums.add(val);// add value to nums array\\n        return check; // return \\n        \\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!maps.containsKey(val)){ //if val is not present in map return false\\n    \\t\\treturn false;\\n    \\t}\\n    \\tSet<Integer> indexSets = maps.get(val); // if val is present , get all the indexes of val in a set\\n        int indexToBeRemoved = indexSets.iterator().next(); // get the first index from the set of indexes\\n        if(indexSets.size()==1){ // check if the size of set is 1 then we can directly remove from map\\n            maps.remove(val);\\n        }else{\\n            indexSets.remove(indexToBeRemoved); // if size is more then 1 then we have to remove from set of indexes\\n        } \\n        \\n        int lastIndex = nums.size()-1; // get the last index since we will swap with last index and delete last index in o(1)\\n        if(indexToBeRemoved !=lastIndex){ // if the index to remove is not last index that means we have more than one value and we need to swap\\n            int lastVal = nums.get(lastIndex); // get the last value from nums array\\n            \\n            Set<Integer> allIndexesOfLastVal = maps.get(lastVal); // get all the indexes of last value\\n            allIndexesOfLastVal.add(indexToBeRemoved); // add the new index of last value \\n            allIndexesOfLastVal.remove(lastIndex);// remove the last index since now we have duplicate \\n            nums.set(indexToBeRemoved,lastVal);// set the new index with the last value now we have removed the value from array\\n        }\\n        nums.remove(lastIndex);// remove the duplicate last element of array. \\n        \\n    \\n    return true;\\n    }\\n    \\n    public int getRandom() {\\n        Random r = new Random();\\n    \\treturn nums.get(r.nextInt(nums.size())); \\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\n    List<Integer> nums;\\n\\tMap<Integer,Set<Integer>> maps; // it will store the value and its indexes in the map so that it will be easy to delete in remove method\\n\\n    public RandomizedCollection() {\\n         nums = new ArrayList<>();\\n        maps = new HashMap<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        boolean check = !maps.containsKey(val); //Check if the map contains the val to be inserted\\n        if(check){// if val does not exist , insert in map with a new hashSet initialized \\n            maps.put(val, new HashSet<>());\\n        }\\n        maps.get(val).add(nums.size());// Add index of the val to the hashset with nums.size() which will be 0 here since we are yet to add values in nums array.\\n        nums.add(val);// add value to nums array\\n        return check; // return \\n        \\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!maps.containsKey(val)){ //if val is not present in map return false\\n    \\t\\treturn false;\\n    \\t}\\n    \\tSet<Integer> indexSets = maps.get(val); // if val is present , get all the indexes of val in a set\\n        int indexToBeRemoved = indexSets.iterator().next(); // get the first index from the set of indexes\\n        if(indexSets.size()==1){ // check if the size of set is 1 then we can directly remove from map\\n            maps.remove(val);\\n        }else{\\n            indexSets.remove(indexToBeRemoved); // if size is more then 1 then we have to remove from set of indexes\\n        } \\n        \\n        int lastIndex = nums.size()-1; // get the last index since we will swap with last index and delete last index in o(1)\\n        if(indexToBeRemoved !=lastIndex){ // if the index to remove is not last index that means we have more than one value and we need to swap\\n            int lastVal = nums.get(lastIndex); // get the last value from nums array\\n            \\n            Set<Integer> allIndexesOfLastVal = maps.get(lastVal); // get all the indexes of last value\\n            allIndexesOfLastVal.add(indexToBeRemoved); // add the new index of last value \\n            allIndexesOfLastVal.remove(lastIndex);// remove the last index since now we have duplicate \\n            nums.set(indexToBeRemoved,lastVal);// set the new index with the last value now we have removed the value from array\\n        }\\n        nums.remove(lastIndex);// remove the duplicate last element of array. \\n        \\n    \\n    return true;\\n    }\\n    \\n    public int getRandom() {\\n        Random r = new Random();\\n    \\treturn nums.get(r.nextInt(nums.size())); \\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1897915,
                "title": "java-solution-using-hashmap-and-arraylist",
                "content": "class RandomizedCollection {\\n    Random r;\\n    HashMap<Integer,HashSet<Integer>> map;\\n    ArrayList<Integer> list;\\n\\n    public RandomizedCollection() {\\n        r=new Random();\\n        map=new HashMap<>();\\n        list=new ArrayList<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        list.add(val);\\n        if(map.containsKey(val)){\\n            HashSet<Integer> set=map.get(val);\\n            set.add(list.size()-1);\\n           return false; \\n        }else{\\n            HashSet<Integer> set=new HashSet<>();\\n            set.add(list.size()-1);\\n            map.put(val,set);\\n            return true;\\n        }\\n        \\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)==false){\\n            return false;\\n        }\\n        int vidx=map.get(val).iterator().next();\\n        int lidx=list.size()-1;\\n        int lval=list.get(lidx);\\n        //swap in ArrayList\\n        list.set(lidx,val);\\n        list.set(vidx,lval);\\n        list.remove(lidx);\\n        //swap in map\\n        map.get(val).remove(vidx);\\n        if(map.get(val).size()==0){\\n            map.remove(val);\\n        }\\n        if(map.containsKey(lval)){\\n        map.get(lval).remove(lidx);\\n        map.get(lval).add(vidx);\\n        }\\n        \\n        \\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        int idx=r.nextInt(list.size());\\n        return list.get(idx);\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */",
                "solutionTags": [],
                "code": "class RandomizedCollection {\\n    Random r;\\n    HashMap<Integer,HashSet<Integer>> map;\\n    ArrayList<Integer> list;\\n\\n    public RandomizedCollection() {\\n        r=new Random();\\n        map=new HashMap<>();\\n        list=new ArrayList<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        list.add(val);\\n        if(map.containsKey(val)){\\n            HashSet<Integer> set=map.get(val);\\n            set.add(list.size()-1);\\n           return false; \\n        }else{\\n            HashSet<Integer> set=new HashSet<>();\\n            set.add(list.size()-1);\\n            map.put(val,set);\\n            return true;\\n        }\\n        \\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)==false){\\n            return false;\\n        }\\n        int vidx=map.get(val).iterator().next();\\n        int lidx=list.size()-1;\\n        int lval=list.get(lidx);\\n        //swap in ArrayList\\n        list.set(lidx,val);\\n        list.set(vidx,lval);\\n        list.remove(lidx);\\n        //swap in map\\n        map.get(val).remove(vidx);\\n        if(map.get(val).size()==0){\\n            map.remove(val);\\n        }\\n        if(map.containsKey(lval)){\\n        map.get(lval).remove(lidx);\\n        map.get(lval).add(vidx);\\n        }\\n        \\n        \\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        int idx=r.nextInt(list.size());\\n        return list.get(idx);\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1893929,
                "title": "simplest-java-solution-in-0ms-with-100-faster-than-java-solutions",
                "content": "```\\nclass RandomizedCollection {\\n    \\n    Random r;\\n    HashMap<Integer , HashSet<Integer>> map;\\n    ArrayList<Integer> list;\\n\\n    public RandomizedCollection() {\\n        list= new ArrayList<>();\\n        map= new HashMap<>();\\n        r= new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        list.add(val);\\n        if(map.containsKey(val)){\\n            \\n            HashSet<Integer>set = map.get(val);\\n            set.add(list.size()-1);\\n            \\n            return false;\\n        }else{\\n            HashSet<Integer> set = new HashSet<>();\\n            set.add(list.size()-1);\\n            map.put(val , set);\\n            return true;\\n        }\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)){\\n            \\n            int vidx = map.get(val).iterator().next(); \\n            int lidx = list.size()-1;\\n            int lval = list.get(lidx);\\n            \\n            list.set(lidx , val);\\n            list.set(vidx, lval);\\n            \\n            list.remove(lidx);\\n            map.get(val).remove(vidx);\\n            \\n            if(map.get(val).size()==0){\\n                map.remove(val);\\n            }\\n            \\n            if(map.containsKey(lval)){\\n                map.get(lval).remove(lidx);\\n                map.get(lval).add(vidx);\\n            }\\n            \\n            return true;\\n        }else{\\n            \\n            \\n            return false;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int idx= r.nextInt(list.size());\\n        return list.get(idx);\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    \\n    Random r;\\n    HashMap<Integer , HashSet<Integer>> map;\\n    ArrayList<Integer> list;\\n\\n    public RandomizedCollection() {\\n        list= new ArrayList<>();\\n        map= new HashMap<>();\\n        r= new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        list.add(val);\\n        if(map.containsKey(val)){\\n            \\n            HashSet<Integer>set = map.get(val);\\n            set.add(list.size()-1);\\n            \\n            return false;\\n        }else{\\n            HashSet<Integer> set = new HashSet<>();\\n            set.add(list.size()-1);\\n            map.put(val , set);\\n            return true;\\n        }\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)){\\n            \\n            int vidx = map.get(val).iterator().next(); \\n            int lidx = list.size()-1;\\n            int lval = list.get(lidx);\\n            \\n            list.set(lidx , val);\\n            list.set(vidx, lval);\\n            \\n            list.remove(lidx);\\n            map.get(val).remove(vidx);\\n            \\n            if(map.get(val).size()==0){\\n                map.remove(val);\\n            }\\n            \\n            if(map.containsKey(lval)){\\n                map.get(lval).remove(lidx);\\n                map.get(lval).add(vidx);\\n            }\\n            \\n            return true;\\n        }else{\\n            \\n            \\n            return false;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n        int idx= r.nextInt(list.size());\\n        return list.get(idx);\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853967,
                "title": "faster-than-99-of-submission-using-unordered-map-and-vector",
                "content": "\\n```\\nclass RandomizedCollection {\\npublic:\\n    RandomizedCollection() {\\n    }\\n    unordered_map<int, vector<int>> mp;\\n    vector<long long> v;\\n\\tlong long temp = (long long)pow(2, 31);\\n    \\n    bool insert(int val) {\\n        auto it = mp.find(val);\\n        v.push_back((long long)val);\\n        if(it == mp.end() || it->second.size() == 0){\\n            \\n            mp[val].push_back(v.size()-1);\\n            return true;\\n        }\\n        else{\\n            mp[val].push_back(v.size()-1);\\n            return false;\\n        }\\n    }\\n    \\n    bool remove(int val) {\\n        auto it = mp.find(val);\\n        if(it == mp.end() || it->second.size() == 0){\\n            return false;\\n        }\\n        else{\\n            v[mp[val][mp[val].size()-1]] = temp;\\n            mp[val].pop_back();\\n            return true;\\n        }\\n    }\\n    \\n    int getRandom() { \\n        long long random = v[rand()%v.size()];\\n        while(random == temp){\\n            random = v[rand()%v.size()];\\n        }\\n        return random;\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n \\n ```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    RandomizedCollection() {\\n    }\\n    unordered_map<int, vector<int>> mp;\\n    vector<long long> v;\\n\\tlong long temp = (long long)pow(2, 31);\\n    \\n    bool insert(int val) {\\n        auto it = mp.find(val);\\n        v.push_back((long long)val);\\n        if(it == mp.end() || it->second.size() == 0){\\n            \\n            mp[val].push_back(v.size()-1);\\n            return true;\\n        }\\n        else{\\n            mp[val].push_back(v.size()-1);\\n            return false;\\n        }\\n    }\\n    \\n    bool remove(int val) {\\n        auto it = mp.find(val);\\n        if(it == mp.end() || it->second.size() == 0){\\n            return false;\\n        }\\n        else{\\n            v[mp[val][mp[val].size()-1]] = temp;\\n            mp[val].pop_back();\\n            return true;\\n        }\\n    }\\n    \\n    int getRandom() { \\n        long long random = v[rand()%v.size()];\\n        while(random == temp){\\n            random = v[rand()%v.size()];\\n        }\\n        return random;\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1815912,
                "title": "c-real-o-1-solution-unordered-set-and-vector",
                "content": "```\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int,unordered_set<int>>mp;\\n    vector<int>v;\\n    \\n    \\n    RandomizedCollection() {\\n       mp.clear();   \\n       v.clear();\\n    }\\n    \\n    \\n    bool insert(int val) {\\n \\n        bool flag=0;\\n        if(!mp[val].size())\\n            flag=1;\\n\\n        mp[val].insert(v.size());\\n        v.push_back(val);\\n        \\n        return flag;\\n    }\\n    \\n    \\n    \\n    \\n    bool remove(int val) {\\n        \\n        if(!mp[val].size())\\n            return 0;\\n        \\n        int k=*mp[val].begin();\\n        mp[val].erase(k);\\n        \\n     if(mp[v[v.size()-1]].size())\\n     {  \\n         int l=v[v.size()-1];\\n         mp[l].erase(v.size()-1);\\n         mp[l].insert(k);\\n         swap(v[k],v[v.size()-1]);\\n     }\\n        \\n        v.pop_back();\\n        return 1;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    int getRandom() {\\n      return v[rand()%v.size()];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int,unordered_set<int>>mp;\\n    vector<int>v;\\n    \\n    \\n    RandomizedCollection() {\\n       mp.clear();   \\n       v.clear();\\n    }\\n    \\n    \\n    bool insert(int val) {\\n \\n        bool flag=0;\\n        if(!mp[val].size())\\n            flag=1;\\n\\n        mp[val].insert(v.size());\\n        v.push_back(val);\\n        \\n        return flag;\\n    }\\n    \\n    \\n    \\n    \\n    bool remove(int val) {\\n        \\n        if(!mp[val].size())\\n            return 0;\\n        \\n        int k=*mp[val].begin();\\n        mp[val].erase(k);\\n        \\n     if(mp[v[v.size()-1]].size())\\n     {  \\n         int l=v[v.size()-1];\\n         mp[l].erase(v.size()-1);\\n         mp[l].insert(k);\\n         swap(v[k],v[v.size()-1]);\\n     }\\n        \\n        v.pop_back();\\n        return 1;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    int getRandom() {\\n      return v[rand()%v.size()];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813967,
                "title": "c-unordered-map-unordered-set-and-vector",
                "content": "```\\nclass RandomizedCollection \\n{\\nprivate:\\n    unordered_map<int, unordered_set<int>> mp;\\n    vector<int> nums;\\n    \\npublic:\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) \\n    {        \\n        mp[val].insert(nums.size());\\n        nums.push_back(val);\\n        \\n        return mp[val].size() == 1;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        auto it = mp.find(val);\\n        if(it == mp.end())\\n            return false;\\n        int indexToRemove = *(mp[val].begin());  // find the index of any of the occurance of val to be removed\\n        mp[val].erase(indexToRemove);   // remove that index of val from map\\n        int lastElem = nums.back();\\n        nums[indexToRemove] = lastElem; // replace that occurance val with the last element\\n        \\n        mp[lastElem].insert(indexToRemove);    // insert new index for last element of nums\\n        mp[lastElem].erase(nums.size() - 1);  // remove old index of last element\\n        nums.pop_back();    // remove the last element\\n        \\n        // if size of set becomes 0 at mp[val] i.e. val was unique\\n        if(mp[val].empty())\\n            mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedCollection \\n{\\nprivate:\\n    unordered_map<int, unordered_set<int>> mp;\\n    vector<int> nums;\\n    \\npublic:\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) \\n    {        \\n        mp[val].insert(nums.size());\\n        nums.push_back(val);\\n        \\n        return mp[val].size() == 1;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        auto it = mp.find(val);\\n        if(it == mp.end())\\n            return false;\\n        int indexToRemove = *(mp[val].begin());  // find the index of any of the occurance of val to be removed\\n        mp[val].erase(indexToRemove);   // remove that index of val from map\\n        int lastElem = nums.back();\\n        nums[indexToRemove] = lastElem; // replace that occurance val with the last element\\n        \\n        mp[lastElem].insert(indexToRemove);    // insert new index for last element of nums\\n        mp[lastElem].erase(nums.size() - 1);  // remove old index of last element\\n        nums.pop_back();    // remove the last element\\n        \\n        // if size of set becomes 0 at mp[val] i.e. val was unique\\n        if(mp[val].empty())\\n            mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743756,
                "title": "python-solution-with-comments-easy-to-understand",
                "content": "Added Few Comments\\n\\n```\\n\\ndef __init__(self):\\n\\n    self.lst = []\\n    self.idx = defaultdict(set)\\n\\n\\ndef insert(self, val: int) -> bool:\\n\\n    # Stores the indexes of the \"val\" inserted in the dictionary and also append this val randomly to the lst \\n    self.idx[val].add(len(self.lst))\\n    self.lst.append(val)\\n    return len(self.idx[val]) == 1\\n\\n\\ndef remove(self, val: int) -> bool:\\n\\n    # remove \"val\" from the postions or indexes by virtual swapping i.e. the index to be removed is placed with the \"last \" element  value and the popped index is then use to add to\\n    # \"last\" elemnt in dict to occupy the postition of \"deleted \\'val\\'\" and and \"last\" element postion in self.lst is removed from dict and lst subsequntly\\n    if not self.idx[val]: return False\\n    remove, last = self.idx[val].pop(), self.lst[-1]\\n    self.lst[remove] = last\\n    self.idx[last].add(remove)\\n    self.idx[last].discard(len(self.lst) - 1)\\n\\n    self.lst.pop()\\n    return True\\n\\n\\ndef getRandom(self) -> int:\\n\\n\\treturn choice(self.lst)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\ndef __init__(self):\\n\\n    self.lst = []\\n    self.idx = defaultdict(set)\\n\\n\\ndef insert(self, val: int) -> bool:\\n\\n    # Stores the indexes of the \"val\" inserted in the dictionary and also append this val randomly to the lst \\n    self.idx[val].add(len(self.lst))\\n    self.lst.append(val)\\n    return len(self.idx[val]) == 1\\n\\n\\ndef remove(self, val: int) -> bool:\\n\\n    # remove \"val\" from the postions or indexes by virtual swapping i.e. the index to be removed is placed with the \"last \" element  value and the popped index is then use to add to\\n    # \"last\" elemnt in dict to occupy the postition of \"deleted \\'val\\'\" and and \"last\" element postion in self.lst is removed from dict and lst subsequntly\\n    if not self.idx[val]: return False\\n    remove, last = self.idx[val].pop(), self.lst[-1]\\n    self.lst[remove] = last\\n    self.idx[last].add(remove)\\n    self.idx[last].discard(len(self.lst) - 1)\\n\\n    self.lst.pop()\\n    return True\\n\\n\\ndef getRandom(self) -> int:\\n\\n\\treturn choice(self.lst)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1743364,
                "title": "my-java-solution",
                "content": "Similar to other ones here:\\n\\n```\\nclass RandomizedCollection {\\n\\n    Random random = new Random();\\n    Map<Integer, Set<Integer>> map = new HashMap<>();\\n    List<Integer> list = new ArrayList<>();\\n\\n    public boolean insert(int val) {\\n      Set<Integer> valSet = map.computeIfAbsent(val, k -> new HashSet<>());\\n      boolean isNew = valSet.isEmpty();\\n      valSet.add(list.size());\\n      list.add(val);\\n      return isNew;\\n    }\\n\\n    public boolean remove(int val) {\\n      Set<Integer> valSet = map.get(val);\\n      if (valSet == null) {\\n        return false;\\n      }\\n\\n      int i = valSet.iterator().next();\\n\\n      valSet.remove(i);\\n      if (valSet.isEmpty()) {\\n        map.remove(val);\\n      }\\n\\n      int n = list.size() - 1;\\n      int last = list.remove(n);\\n\\n      if (i != n) {\\n        list.set(i, last);\\n        valSet = map.get(last);\\n        valSet.remove(n);\\n        valSet.add(i);\\n      }\\n\\n      return true;\\n    }\\n\\n    public int getRandom() {\\n      return list.get(random.nextInt(list.size()));\\n    }\\n}",
                "solutionTags": [],
                "code": "Similar to other ones here:\\n\\n```\\nclass RandomizedCollection {\\n\\n    Random random = new Random();\\n    Map<Integer, Set<Integer>> map = new HashMap<>();\\n    List<Integer> list = new ArrayList<>();\\n\\n    public boolean insert(int val) {\\n      Set<Integer> valSet = map.computeIfAbsent(val, k -> new HashSet<>());\\n      boolean isNew = valSet.isEmpty();\\n      valSet.add(list.size());\\n      list.add(val);\\n      return isNew;\\n    }\\n\\n    public boolean remove(int val) {\\n      Set<Integer> valSet = map.get(val);\\n      if (valSet == null) {\\n        return false;\\n      }\\n\\n      int i = valSet.iterator().next();\\n\\n      valSet.remove(i);\\n      if (valSet.isEmpty()) {\\n        map.remove(val);\\n      }\\n\\n      int n = list.size() - 1;\\n      int last = list.remove(n);\\n\\n      if (i != n) {\\n        list.set(i, last);\\n        valSet = map.get(last);\\n        valSet.remove(n);\\n        valSet.add(i);\\n      }\\n\\n      return true;\\n    }\\n\\n    public int getRandom() {\\n      return list.get(random.nextInt(list.size()));\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1741568,
                "title": "why-wrong-answer-30-31-test-cases-passed",
                "content": "```\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int,int>mp;\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(mp.find(val)!=mp.end()){\\n            mp[val]++;\\n            return false;\\n        }else{\\n            mp[val]++;\\n        }\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val) != mp.end()){\\n            mp[val]--;\\n            if(mp[val] == 0){\\n                mp.erase(val);\\n            }\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    int getRandom() {\\n        int random = rand()%(mp.size());\\n        auto it = mp.begin();\\n        advance(it,random);\\n        return it->first;\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int,int>mp;\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(mp.find(val)!=mp.end()){\\n            mp[val]++;\\n            return false;\\n        }else{\\n            mp[val]++;\\n        }\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val) != mp.end()){\\n            mp[val]--;\\n            if(mp[val] == 0){\\n                mp.erase(val);\\n            }\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    int getRandom() {\\n        int random = rand()%(mp.size());\\n        auto it = mp.begin();\\n        advance(it,random);\\n        return it->first;\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572855,
                "title": "c-solution",
                "content": "```class RandomizedCollection {\\npublic:\\n    unordered_map<int,vector<int>> list;\\n    vector<int> set;\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        bool res = false;\\n        if(list.find(val) == list.end()){\\n            res = true;\\n        }\\n        list[val].push_back(set.size());\\n        set.push_back(val);\\n        return res;\\n    }\\n    \\n    bool remove(int val) {\\n        if(list.find(val) == list.end()){\\n            return false;\\n        }\\n        \\n        int t_index = list[val][list[val].size() - 1];\\n        list[val].pop_back();\\n        \\n        int replaced_val = set[set.size() - 1];\\n        set[t_index] = replaced_val;\\n        set.pop_back();\\n        \\n        for(int i = 0; i < list[replaced_val].size(); i++){\\n            if(list[replaced_val][i] == set.size()){\\n                list[replaced_val][i] = t_index;\\n            }\\n        }\\n        \\n        if(list[val].size() == 0){\\n            list.erase(val);\\n        }\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        int n = rand()%(set.size());\\n        return set[n];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */",
                "solutionTags": [],
                "code": "```class RandomizedCollection {\\npublic:\\n    unordered_map<int,vector<int>> list;\\n    vector<int> set;\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        bool res = false;\\n        if(list.find(val) == list.end()){\\n            res = true;\\n        }\\n        list[val].push_back(set.size());\\n        set.push_back(val);\\n        return res;\\n    }\\n    \\n    bool remove(int val) {\\n        if(list.find(val) == list.end()){\\n            return false;\\n        }\\n        \\n        int t_index = list[val][list[val].size() - 1];\\n        list[val].pop_back();\\n        \\n        int replaced_val = set[set.size() - 1];\\n        set[t_index] = replaced_val;\\n        set.pop_back();\\n        \\n        for(int i = 0; i < list[replaced_val].size(); i++){\\n            if(list[replaced_val][i] == set.size()){\\n                list[replaced_val][i] = t_index;\\n            }\\n        }\\n        \\n        if(list[val].size() == 0){\\n            list.erase(val);\\n        }\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        int n = rand()%(set.size());\\n        return set[n];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1547879,
                "title": "time-limit-exceeded-python-dict-solution",
                "content": "So I have the following simple solution on Python:\\n\\n```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.mSet = dict()\\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.mSet:\\n            cnt = self.mSet[val]\\n            self.mSet[val] = cnt + 1\\n            return False\\n        else:\\n            self.mSet[val] = 1\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val not in self.mSet:\\n            return False\\n        elif self.mSet[val] == 1:\\n            del self.mSet[val]\\n            return True\\n        else:\\n            cnt = self.mSet[val]\\n            self.mSet[val] = cnt - 1\\n            return True\\n\\n    def getRandom(self) -> int:\\n        return random.choices(list(self.mSet.keys()), list(self.mSet.values()))[0]\\n```\\n\\nThis produces time limit exceeded error. To me the above solution is O(1), am I missing something?\\n",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.mSet = dict()\\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.mSet:\\n            cnt = self.mSet[val]\\n            self.mSet[val] = cnt + 1\\n            return False\\n        else:\\n            self.mSet[val] = 1\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val not in self.mSet:\\n            return False\\n        elif self.mSet[val] == 1:\\n            del self.mSet[val]\\n            return True\\n        else:\\n            cnt = self.mSet[val]\\n            self.mSet[val] = cnt - 1\\n            return True\\n\\n    def getRandom(self) -> int:\\n        return random.choices(list(self.mSet.keys()), list(self.mSet.values()))[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535357,
                "title": "c-multimap-and-vector-of-iterators",
                "content": "```\\nclass RandomizedCollection {\\n    unordered_multimap<int,int> m;\\n    vector<unordered_multimap<int,int>::iterator> v;\\n    \\npublic:\\n    RandomizedCollection() {}\\n    \\n    bool insert(int val) {\\n        bool b = !m.count(val);\\n        v.push_back(m.insert({val, v.size()}));\\n        return b;\\n    }\\n    \\n    bool remove(int val) {\\n        if (m.count(val)) {\\n            unordered_multimap<int,int>::iterator it = m.find(val);\\n            v.back()->second = it->second;\\n            swap(v[it->second], v.back());\\n            m.erase(it);\\n            v.pop_back();\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return v[rand() % v.size()]->first;\\n    }\\n};\\n```\\n\\nThis solution is optimal, and it guarantees the linear probability property of additional items of same keys, as per question statement.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    unordered_multimap<int,int> m;\\n    vector<unordered_multimap<int,int>::iterator> v;\\n    \\npublic:\\n    RandomizedCollection() {}\\n    \\n    bool insert(int val) {\\n        bool b = !m.count(val);\\n        v.push_back(m.insert({val, v.size()}));\\n        return b;\\n    }\\n    \\n    bool remove(int val) {\\n        if (m.count(val)) {\\n            unordered_multimap<int,int>::iterator it = m.find(val);\\n            v.back()->second = it->second;\\n            swap(v[it->second], v.back());\\n            m.erase(it);\\n            v.pop_back();\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return v[rand() % v.size()]->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506896,
                "title": "c-220ms-87-simple-easy-small-and-clean",
                "content": "Runtime: 220 ms, faster than 87.44% of C++ online submissions for Insert Delete GetRandom O(1) - Duplicates allowed.\\nMemory Usage: 107.7 MB, less than 49.30% of C++ online submissions for Insert Delete GetRandom O(1) - Duplicates allowed.\\n**ALL FUNCTIONS WITH TIME O1**\\n```\\nclass RandomizedCollection {\\npublic:\\n  unordered_map<int,unordered_set<int>> table;\\n  vector<int>v;\\n  \\n  bool insert(int val) {\\n    bool flag = true;\\n    if(table.count(val)) flag = false; \\n    table[val].insert(v.size());\\n    v.push_back(val);\\n    \\n    return flag;\\n  }\\n    \\n  bool remove(int val) {\\n    if(!table.count(val)) return false;\\n    \\n    if(val != v.back()){\\n      int index = *(table[val].begin());\\n      v[index] = v.back();\\n      table[v.back()].erase(v.size()-1);\\n      table[v.back()].insert(index);\\n      table[val].erase(index);\\n    }\\n    else table[val].erase(v.size()-1);\\n    \\n    v.pop_back();\\n    if(table[val].empty()) table.erase(val);\\n    \\n    return true;\\n  }\\n    \\n  int getRandom() {\\n     return v[rand()%v.size()];   \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n  unordered_map<int,unordered_set<int>> table;\\n  vector<int>v;\\n  \\n  bool insert(int val) {\\n    bool flag = true;\\n    if(table.count(val)) flag = false; \\n    table[val].insert(v.size());\\n    v.push_back(val);\\n    \\n    return flag;\\n  }\\n    \\n  bool remove(int val) {\\n    if(!table.count(val)) return false;\\n    \\n    if(val != v.back()){\\n      int index = *(table[val].begin());\\n      v[index] = v.back();\\n      table[v.back()].erase(v.size()-1);\\n      table[v.back()].insert(index);\\n      table[val].erase(index);\\n    }\\n    else table[val].erase(v.size()-1);\\n    \\n    v.pop_back();\\n    if(table[val].empty()) table.erase(val);\\n    \\n    return true;\\n  }\\n    \\n  int getRandom() {\\n     return v[rand()%v.size()];   \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433497,
                "title": "javascript-map-and-set",
                "content": "**Note:**\\n- use `Set()` to record the duplicated indexes for the same value,\\n- use `Map()` to record: `< value, set<index> >`\\n\\n```js\\nvar RandomizedCollection = function () {\\n  this.arr = [];\\n  this.map = new Map(); // < val, set<index> >\\n};\\n\\nRandomizedCollection.prototype.insert = function (val) {\\n  this.arr.push(val);\\n  if (!this.map.has(val)) {\\n    this.map.set(val, new Set());\\n    this.map.get(val).add(this.arr.length - 1);\\n    return true;\\n  } else {\\n    this.map.get(val).add(this.arr.length - 1);\\n    return false;\\n  }\\n};\\n\\nRandomizedCollection.prototype.remove = function (val) {\\n  if (!this.map.has(val)) {\\n    return false;\\n  }\\n\\n  // find one index to remove\\n  var indexes = Array.from(this.map.get(val));\\n  var idx = indexes[0];\\n  var n = this.arr.length;\\n  var last = this.arr[n - 1];\\n\\n  // swap with current last element in array\\n  [this.arr[idx], this.arr[n - 1]] = [this.arr[n - 1], this.arr[idx]];\\n\\n  // clean up\\n  this.arr.pop();\\n  this.map.get(val).delete(idx);\\n  if (idx !== n - 1) {\\n    // Bug: update swapped index if needed\\n    this.map.get(last).delete(n - 1);\\n    this.map.get(last).add(idx);\\n  }\\n  if (this.map.get(val).size === 0) {\\n    this.map.delete(val);\\n  }\\n\\n  return true;\\n};\\n\\nRandomizedCollection.prototype.getRandom = function () {\\n  var n = this.arr.length;\\n  var idx = Math.floor(Math.random() * n);\\n  return this.arr[idx];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar RandomizedCollection = function () {\\n  this.arr = [];\\n  this.map = new Map(); // < val, set<index> >\\n};\\n\\nRandomizedCollection.prototype.insert = function (val) {\\n  this.arr.push(val);\\n  if (!this.map.has(val)) {\\n    this.map.set(val, new Set());\\n    this.map.get(val).add(this.arr.length - 1);\\n    return true;\\n  } else {\\n    this.map.get(val).add(this.arr.length - 1);\\n    return false;\\n  }\\n};\\n\\nRandomizedCollection.prototype.remove = function (val) {\\n  if (!this.map.has(val)) {\\n    return false;\\n  }\\n\\n  // find one index to remove\\n  var indexes = Array.from(this.map.get(val));\\n  var idx = indexes[0];\\n  var n = this.arr.length;\\n  var last = this.arr[n - 1];\\n\\n  // swap with current last element in array\\n  [this.arr[idx], this.arr[n - 1]] = [this.arr[n - 1], this.arr[idx]];\\n\\n  // clean up\\n  this.arr.pop();\\n  this.map.get(val).delete(idx);\\n  if (idx !== n - 1) {\\n    // Bug: update swapped index if needed\\n    this.map.get(last).delete(n - 1);\\n    this.map.get(last).add(idx);\\n  }\\n  if (this.map.get(val).size === 0) {\\n    this.map.delete(val);\\n  }\\n\\n  return true;\\n};\\n\\nRandomizedCollection.prototype.getRandom = function () {\\n  var n = this.arr.length;\\n  var idx = Math.floor(Math.random() * n);\\n  return this.arr[idx];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122652,
                "title": "java-all-o-1-east-to-understand",
                "content": "```\\nclass RandomizedCollection {\\n    List<Integer> list;\\n    Map<Integer, Set<Integer>> map;\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean contains = map.containsKey(val);\\n        map.putIfAbsent(val, new HashSet<>());\\n        map.get(val).add(list.size());\\n        list.add(val);\\n        return contains;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n        if (list.get(list.size() - 1) == val) {\\n            // remove last one\\n            map.get(val).remove(list.size() - 1);\\n            if (map.get(val).size() == 0) {\\n                map.remove(val);\\n            }\\n            list.remove(list.size() - 1);\\n        } else {\\n            // remove middle, need to replace with last one\\n            Set<Integer> set = map.get(val);\\n            int randomIndex = set.iterator().next();\\n            set.remove(randomIndex);\\n            if (set.size() == 0) {\\n                map.remove(val);\\n            }\\n            int lastVal = list.get(list.size() - 1);\\n            int lastIndex = list.size() - 1;\\n            map.get(lastVal).remove(lastIndex);\\n            map.get(lastVal).add(randomIndex);\\n            list.set(randomIndex, lastVal);\\n            list.remove(list.size() - 1);\\n        }\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        int index = new Random().nextInt(list.size());\\n        return list.get(index);\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\n    List<Integer> list;\\n    Map<Integer, Set<Integer>> map;\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean contains = map.containsKey(val);\\n        map.putIfAbsent(val, new HashSet<>());\\n        map.get(val).add(list.size());\\n        list.add(val);\\n        return contains;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n        if (list.get(list.size() - 1) == val) {\\n            // remove last one\\n            map.get(val).remove(list.size() - 1);\\n            if (map.get(val).size() == 0) {\\n                map.remove(val);\\n            }\\n            list.remove(list.size() - 1);\\n        } else {\\n            // remove middle, need to replace with last one\\n            Set<Integer> set = map.get(val);\\n            int randomIndex = set.iterator().next();\\n            set.remove(randomIndex);\\n            if (set.size() == 0) {\\n                map.remove(val);\\n            }\\n            int lastVal = list.get(list.size() - 1);\\n            int lastIndex = list.size() - 1;\\n            map.get(lastVal).remove(lastIndex);\\n            map.get(lastVal).add(randomIndex);\\n            list.set(randomIndex, lastVal);\\n            list.remove(list.size() - 1);\\n        }\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        int index = new Random().nextInt(list.size());\\n        return list.get(index);\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088683,
                "title": "swift-solution-136-ms",
                "content": "```\\nclass RandomizedCollection {\\n    var array = [Int]()\\n    var map = [Int: Set<Int>]()\\n    /** Initialize your data structure here. */\\n    init() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    func insert(_ val: Int) -> Bool {\\n        let result = map[val, default: Set<Int>()].count == 0 ? true: false\\n        map[val, default: Set<Int>()].insert(array.count)\\n        array.append(val)\\n        return result\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    func remove(_ val: Int) -> Bool {\\n        if map[val, default: Set<Int>()].count == 0 { return false }\\n        let indexToRemove = map[val]!.first!\\n        map[val]!.remove(indexToRemove)\\n        if indexToRemove < array.count - 1 {\\n            array.swapAt(indexToRemove, array.count - 1)\\n            map[array[indexToRemove]]!.remove(array.count - 1)\\n            map[array[indexToRemove]]!.insert(indexToRemove)\\n        }\\n        \\n        array.removeLast()\\n        return true\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    func getRandom() -> Int {\\n        let index = Int.random(in: 0..<array.count)\\n        return array[index]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    var array = [Int]()\\n    var map = [Int: Set<Int>]()\\n    /** Initialize your data structure here. */\\n    init() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    func insert(_ val: Int) -> Bool {\\n        let result = map[val, default: Set<Int>()].count == 0 ? true: false\\n        map[val, default: Set<Int>()].insert(array.count)\\n        array.append(val)\\n        return result\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    func remove(_ val: Int) -> Bool {\\n        if map[val, default: Set<Int>()].count == 0 { return false }\\n        let indexToRemove = map[val]!.first!\\n        map[val]!.remove(indexToRemove)\\n        if indexToRemove < array.count - 1 {\\n            array.swapAt(indexToRemove, array.count - 1)\\n            map[array[indexToRemove]]!.remove(array.count - 1)\\n            map[array[indexToRemove]]!.insert(indexToRemove)\\n        }\\n        \\n        array.removeLast()\\n        return true\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    func getRandom() -> Int {\\n        let index = Int.random(in: 0..<array.count)\\n        return array[index]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832003,
                "title": "accepted-java-if-you-implemented-lru-cache-you-can-understand-this-soln",
                "content": "Recently I studied how to implement LRU cache, based on the same soln we can extend it solve this problem.\\nThis can be further optimised to store only count of value in HashMap and decrease it when removing: \\n\\n```\\nclass RandomizedCollection {\\n    \\n    private class Node{\\n        int val;\\n        Node next;\\n        Node prev;\\n        Node(int val){\\n            this.val=val;\\n        }\\n    }\\n    java.util.Random rand = new java.util.Random();\\n    int size = 0;\\n    Node head=null,tail=null;\\n    Map<Integer,List<Node>> mp = new HashMap<Integer,List<Node>>();\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        head = new Node(Integer.MIN_VALUE);\\n        tail = new Node(Integer.MIN_VALUE);\\n        head.next=tail;\\n        tail.prev=head;\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        Node newNode = new Node(val);\\n     //   System.out.println(\"Adding \"+val);\\n        newNode.prev=head;\\n        newNode.next=head.next;\\n        head.next.prev=newNode;\\n        head.next= newNode;\\n        boolean alreadyPresent=false;\\n        if(mp.containsKey(val)){\\n            mp.get(val).add(newNode);\\n            alreadyPresent=true;\\n        }\\n        else{\\n            List<Node> li = new ArrayList<Node>();\\n            li.add(newNode);\\n            mp.put(val,li);\\n        }\\n        size++;\\n        return alreadyPresent;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        List<Node> remNode= mp.get(val);\\n     //   System.out.println(\"Removing \"+val);\\n        if(null==remNode)return false;\\n        Node n = null;\\n        if(remNode.size()==1){\\n            mp.remove(val);\\n        }\\n        n=remNode.get(0);\\n        remNode.remove(0);\\n        Node prev = n.prev;\\n        Node next = n.next;\\n        \\n        prev.next = next;\\n        next.prev = prev;\\n        size--;\\n        return true;\\n        \\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        \\n    //    System.out.print(size);\\n        int n = rand.nextInt(size);\\n        Node curr = head.next;\\n        for(int i=0;i<n;i++){\\n            curr=curr.next;\\n        }\\n    //    System.out.print(curr.val);\\n        return curr.val;\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\n    \\n    private class Node{\\n        int val;\\n        Node next;\\n        Node prev;\\n        Node(int val){\\n            this.val=val;\\n        }\\n    }\\n    java.util.Random rand = new java.util.Random();\\n    int size = 0;\\n    Node head=null,tail=null;\\n    Map<Integer,List<Node>> mp = new HashMap<Integer,List<Node>>();\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        head = new Node(Integer.MIN_VALUE);\\n        tail = new Node(Integer.MIN_VALUE);\\n        head.next=tail;\\n        tail.prev=head;\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        Node newNode = new Node(val);\\n     //   System.out.println(\"Adding \"+val);\\n        newNode.prev=head;\\n        newNode.next=head.next;\\n        head.next.prev=newNode;\\n        head.next= newNode;\\n        boolean alreadyPresent=false;\\n        if(mp.containsKey(val)){\\n            mp.get(val).add(newNode);\\n            alreadyPresent=true;\\n        }\\n        else{\\n            List<Node> li = new ArrayList<Node>();\\n            li.add(newNode);\\n            mp.put(val,li);\\n        }\\n        size++;\\n        return alreadyPresent;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        List<Node> remNode= mp.get(val);\\n     //   System.out.println(\"Removing \"+val);\\n        if(null==remNode)return false;\\n        Node n = null;\\n        if(remNode.size()==1){\\n            mp.remove(val);\\n        }\\n        n=remNode.get(0);\\n        remNode.remove(0);\\n        Node prev = n.prev;\\n        Node next = n.next;\\n        \\n        prev.next = next;\\n        next.prev = prev;\\n        size--;\\n        return true;\\n        \\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        \\n    //    System.out.print(size);\\n        int n = rand.nextInt(size);\\n        Node curr = head.next;\\n        for(int i=0;i<n;i++){\\n            curr=curr.next;\\n        }\\n    //    System.out.print(curr.val);\\n        return curr.val;\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813464,
                "title": "python3-list-dict-of-sets",
                "content": "This is similar to the solution of [380. Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/discuss/684335/Python3-a-self-explained-implementation) with simple dictionary replaced by a dictionary of sets. \\n```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.val = [] # val \\n        self.mpp = {} # val to set of indices \\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        self.mpp.setdefault(val, set()).add(len(self.val))\\n        self.val.append(val)\\n        return len(self.mpp[val]) == 1\\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        if val not in self.mpp or not self.mpp[val]: return False  # flag \\n        i = self.mpp[val].pop()\\n        self.mpp[self.val[-1]].add(i)\\n        self.mpp[self.val[-1]].remove(len(self.val)-1)\\n        self.val[i] = self.val[-1]\\n        self.val.pop()\\n        return True\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the collection.\\n        \"\"\"\\n        return choice(self.val)\\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.val = [] # val \\n        self.mpp = {} # val to set of indices \\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        self.mpp.setdefault(val, set()).add(len(self.val))\\n        self.val.append(val)\\n        return len(self.mpp[val]) == 1\\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        if val not in self.mpp or not self.mpp[val]: return False  # flag \\n        i = self.mpp[val].pop()\\n        self.mpp[self.val[-1]].add(i)\\n        self.mpp[self.val[-1]].remove(len(self.val)-1)\\n        self.val[i] = self.val[-1]\\n        self.val.pop()\\n        return True\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the collection.\\n        \"\"\"\\n        return choice(self.val)\\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759596,
                "title": "ruby-real-o-1-solution",
                "content": "```\\nclass RandomizedCollection\\n=begin\\n    Initialize your data structure here.\\n=end\\n    def initialize()\\n      @arr, @hash = [], {}\\n    end\\n\\n=begin\\n    Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n    :type val: Integer\\n    :rtype: Boolean\\n=end\\n    def insert(val)\\n      (@hash[val] ||= Set.new).add(@arr.size)\\n      @arr << val\\n      @hash[val].size == 1\\n    end\\n\\n=begin\\n    Removes a value from the collection. Returns true if the collection contained the specified element.\\n    :type val: Integer\\n    :rtype: Boolean\\n=end\\n    def remove(val)\\n      return false if (@hash[val] || Set.new).empty?\\n      \\n      index, last = @hash[val].first, @arr.last\\n      @arr[index] = last\\n      @arr.pop\\n      @hash[val].delete(index)\\n      @hash[last].add(index)\\n      @hash[last].delete(@arr.size)\\n      true\\n    end\\n\\n=begin\\n    Get a random element from the collection.\\n    :rtype: Integer\\n=end\\n    def get_random()\\n      @arr[rand(@arr.size)] \\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass RandomizedCollection\\n=begin\\n    Initialize your data structure here.\\n=end\\n    def initialize()\\n      @arr, @hash = [], {}\\n    end\\n\\n=begin\\n    Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n    :type val: Integer\\n    :rtype: Boolean\\n=end\\n    def insert(val)\\n      (@hash[val] ||= Set.new).add(@arr.size)\\n      @arr << val\\n      @hash[val].size == 1\\n    end\\n\\n=begin\\n    Removes a value from the collection. Returns true if the collection contained the specified element.\\n    :type val: Integer\\n    :rtype: Boolean\\n=end\\n    def remove(val)\\n      return false if (@hash[val] || Set.new).empty?\\n      \\n      index, last = @hash[val].first, @arr.last\\n      @arr[index] = last\\n      @arr.pop\\n      @hash[val].delete(index)\\n      @hash[last].add(index)\\n      @hash[last].delete(@arr.size)\\n      true\\n    end\\n\\n=begin\\n    Get a random element from the collection.\\n    :rtype: Integer\\n=end\\n    def get_random()\\n      @arr[rand(@arr.size)] \\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719672,
                "title": "my-o-1-python-solution-with-comments",
                "content": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.vals = []\\n        self.idxs = defaultdict(set)\\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        return_val = val not in self.idxs\\n\\n        self.vals.append(val)\\n        self.idxs[val].add(len(self.vals) - 1)\\n        return return_val\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        if val not in self.idxs:\\n            return False\\n        \\n        # Cache the last value\\n        last_val = self.vals[-1]\\n        \\n        # Permanently remove a random index of val.\\n        insert_idx = self.idxs[val].pop()\\n        \\n        # If the val is unique get rid of it in the dict\\n        if not self.idxs[val]:\\n            del self.idxs[val]\\n            \\n        if last_val in self.idxs:\\n            # Remove the location of the last value\\n            self.idxs[last_val].discard(len(self.vals) - 1)\\n\\n            self.vals[insert_idx] = last_val\\n            \\n            # Add back the new location of last value\\n            self.idxs[last_val].add(insert_idx)\\n\\n        self.vals.pop()\\n        return True\\n        \\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the collection.\\n        \"\"\"\\n        return self.vals[randint(0, len(self.vals) - 1)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.vals = []\\n        self.idxs = defaultdict(set)\\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        return_val = val not in self.idxs\\n\\n        self.vals.append(val)\\n        self.idxs[val].add(len(self.vals) - 1)\\n        return return_val\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        if val not in self.idxs:\\n            return False\\n        \\n        # Cache the last value\\n        last_val = self.vals[-1]\\n        \\n        # Permanently remove a random index of val.\\n        insert_idx = self.idxs[val].pop()\\n        \\n        # If the val is unique get rid of it in the dict\\n        if not self.idxs[val]:\\n            del self.idxs[val]\\n            \\n        if last_val in self.idxs:\\n            # Remove the location of the last value\\n            self.idxs[last_val].discard(len(self.vals) - 1)\\n\\n            self.vals[insert_idx] = last_val\\n            \\n            # Add back the new location of last value\\n            self.idxs[last_val].add(insert_idx)\\n\\n        self.vals.pop()\\n        return True\\n        \\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the collection.\\n        \"\"\"\\n        return self.vals[randint(0, len(self.vals) - 1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684346,
                "title": "c-multimap-and-vector",
                "content": "```\\nclass RandomizedCollection {\\n    unordered_multimap<int, int> hash;                      //value=>index\\n    vector<unordered_multimap<int, int>::iterator> vec;     //index=>hashmap iterator\\n\\npublic:\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        \\n        auto it = hash.insert({val,vec.size()});\\n        vec.push_back(it);\\n        \\n        return hash.count(val)==1;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(hash.count(val)==0) \\n            return false;\\n        \\n        auto it = hash.find(val);\\n        \\n        swap(vec[it->second], vec.back());\\n        vec[it->second]->second = it->second;\\n        vec.pop_back();\\n        hash.erase(it);\\n        \\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        \\n        return vec[rand()%vec.size()]->first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\n    unordered_multimap<int, int> hash;                      //value=>index\\n    vector<unordered_multimap<int, int>::iterator> vec;     //index=>hashmap iterator\\n\\npublic:\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        \\n        auto it = hash.insert({val,vec.size()});\\n        vec.push_back(it);\\n        \\n        return hash.count(val)==1;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(hash.count(val)==0) \\n            return false;\\n        \\n        auto it = hash.find(val);\\n        \\n        swap(vec[it->second], vec.back());\\n        vec[it->second]->second = it->second;\\n        vec.pop_back();\\n        hash.erase(it);\\n        \\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        \\n        return vec[rand()%vec.size()]->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683547,
                "title": "rust-code",
                "content": "```rust\\nuse rand::prelude::*;\\nuse std::collections::{HashMap, HashSet};\\n\\n#[derive(Debug)]\\nstruct RandomizedCollection {\\n    rng: ThreadRng,\\n    numbers: Vec<i32>,\\n    map: HashMap<i32, HashSet<i32>>,\\n}\\n\\nimpl RandomizedCollection {\\n    /** Initialize your data structure here. */\\n    fn new() -> Self {\\n        RandomizedCollection {\\n            rng: Default::default(),\\n            numbers: vec![],\\n            map: Default::default(),\\n        }\\n    }\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    fn insert(&mut self, val: i32) -> bool {\\n        let contained = self.map.contains_key(&val);\\n        if !contained {\\n            self.map.insert(val, Default::default());\\n        }\\n        self.map.get_mut(&val).unwrap().insert(self.numbers.len() as i32);\\n        self.numbers.push(val);\\n\\n        !contained\\n    }\\n\\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    fn remove(&mut self, val: i32) -> bool {\\n        return match self.map.get_mut(&val) {\\n            None => { false }\\n            Some(x) => {\\n                let i = x.iter().next();\\n                match i {\\n                    None => { return false; }\\n                    Some(&z) => {\\n                        x.remove(&z);\\n                        let len = self.numbers.len();\\n                        if z < (len - 1) as i32 {\\n                            let last_one = self.numbers[len - 1];\\n                            self.numbers[z as usize] = last_one;\\n                            match self.map.get_mut(&last_one) {\\n                                Some(s) => {\\n                                    s.remove(&((len - 1) as i32));\\n                                    s.insert(z);\\n                                },\\n                                None => { return false; }\\n                            }\\n                        }\\n                    }\\n                }\\n                self.numbers.pop();\\n                if let Some(x) = self.map.get(&val) {\\n                    if x.is_empty() { self.map.remove(&val); }\\n                };\\n                true\\n            }\\n        };\\n    }\\n\\n    /** Get a random element from the collection. */\\n    fn get_random(&mut self) -> i32 {\\n        self.numbers[self.rng.gen_range(0, self.numbers.len())]\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse rand::prelude::*;\\nuse std::collections::{HashMap, HashSet};\\n\\n#[derive(Debug)]\\nstruct RandomizedCollection {\\n    rng: ThreadRng,\\n    numbers: Vec<i32>,\\n    map: HashMap<i32, HashSet<i32>>,\\n}\\n\\nimpl RandomizedCollection {\\n    /** Initialize your data structure here. */\\n    fn new() -> Self {\\n        RandomizedCollection {\\n            rng: Default::default(),\\n            numbers: vec![],\\n            map: Default::default(),\\n        }\\n    }\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    fn insert(&mut self, val: i32) -> bool {\\n        let contained = self.map.contains_key(&val);\\n        if !contained {\\n            self.map.insert(val, Default::default());\\n        }\\n        self.map.get_mut(&val).unwrap().insert(self.numbers.len() as i32);\\n        self.numbers.push(val);\\n\\n        !contained\\n    }\\n\\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    fn remove(&mut self, val: i32) -> bool {\\n        return match self.map.get_mut(&val) {\\n            None => { false }\\n            Some(x) => {\\n                let i = x.iter().next();\\n                match i {\\n                    None => { return false; }\\n                    Some(&z) => {\\n                        x.remove(&z);\\n                        let len = self.numbers.len();\\n                        if z < (len - 1) as i32 {\\n                            let last_one = self.numbers[len - 1];\\n                            self.numbers[z as usize] = last_one;\\n                            match self.map.get_mut(&last_one) {\\n                                Some(s) => {\\n                                    s.remove(&((len - 1) as i32));\\n                                    s.insert(z);\\n                                },\\n                                None => { return false; }\\n                            }\\n                        }\\n                    }\\n                }\\n                self.numbers.pop();\\n                if let Some(x) = self.map.get(&val) {\\n                    if x.is_empty() { self.map.remove(&val); }\\n                };\\n                true\\n            }\\n        };\\n    }\\n\\n    /** Get a random element from the collection. */\\n    fn get_random(&mut self) -> i32 {\\n        self.numbers[self.rng.gen_range(0, self.numbers.len())]\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594706,
                "title": "python-3-hashmap",
                "content": "```\\nimport collections\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.dic = collections.defaultdict(set)\\n        self.nums = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.nums.append(val)\\n        self.dic[val].add(len(self.nums)-1)\\n        return len(self.dic[val]) == 1\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if not self.dic[val]:\\n            return False\\n        idx_to_remove = self.dic[val].pop()\\n        last = self.nums[-1]\\n        self.nums[idx_to_remove] = last\\n        self.dic[last].add(idx_to_remove)\\n        self.dic[last].remove(len(self.nums)-1)\\n        self.nums.pop()\\n        return True\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport collections\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.dic = collections.defaultdict(set)\\n        self.nums = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.nums.append(val)\\n        self.dic[val].add(len(self.nums)-1)\\n        return len(self.dic[val]) == 1\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if not self.dic[val]:\\n            return False\\n        idx_to_remove = self.dic[val].pop()\\n        last = self.nums[-1]\\n        self.nums[idx_to_remove] = last\\n        self.dic[last].add(idx_to_remove)\\n        self.dic[last].remove(len(self.nums)-1)\\n        self.nums.pop()\\n        return True\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584731,
                "title": "c-clean-code",
                "content": "```c++\\nclass RandomizedCollection {\\n    unordered_map<int, unordered_set<int>> m;\\n    vector<int> nums;\\n    \\npublic:\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool result = m.count(val) == 0;\\n        \\n        m[val].insert(nums.size());\\n        nums.push_back(val);\\n        \\n        return result;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        auto it = m.find(val);\\n        if (it == m.end()) return false;\\n        \\n        // first pos in set\\n        auto& positions = it->second;\\n        auto free_pos = *positions.begin();\\n        positions.erase(positions.begin());\\n        \\n        // Do the last num trick to erase in O(1)\\n        int lastVal = nums.back();\\n        nums[free_pos] = lastVal;\\n        m[lastVal].insert(free_pos);\\n        \\n        // Now the lastVal doesn\\'t have the last idx assigned anymore!\\n        m[lastVal].erase(nums.size() - 1);\\n        \\n        // Finally remove the redundant back\\n        nums.pop_back();\\n        \\n        // Delete from hashmap if there no more positions for this val\\n        if (positions.empty()) {\\n            m.erase(it);\\n        }\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass RandomizedCollection {\\n    unordered_map<int, unordered_set<int>> m;\\n    vector<int> nums;\\n    \\npublic:\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool result = m.count(val) == 0;\\n        \\n        m[val].insert(nums.size());\\n        nums.push_back(val);\\n        \\n        return result;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        auto it = m.find(val);\\n        if (it == m.end()) return false;\\n        \\n        // first pos in set\\n        auto& positions = it->second;\\n        auto free_pos = *positions.begin();\\n        positions.erase(positions.begin());\\n        \\n        // Do the last num trick to erase in O(1)\\n        int lastVal = nums.back();\\n        nums[free_pos] = lastVal;\\n        m[lastVal].insert(free_pos);\\n        \\n        // Now the lastVal doesn\\'t have the last idx assigned anymore!\\n        m[lastVal].erase(nums.size() - 1);\\n        \\n        // Finally remove the redundant back\\n        nums.pop_back();\\n        \\n        // Delete from hashmap if there no more positions for this val\\n        if (positions.empty()) {\\n            m.erase(it);\\n        }\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582281,
                "title": "java-simple-set-arraylist",
                "content": "```\\nclass RandomizedCollection {\\n\\n    /** Initialize your data structure here. */\\n    Random r = new Random();\\n    List<Integer>list=new ArrayList<>();\\n    Map<Integer,Set<Integer>>map=new HashMap<>();\\n    public RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)){\\n            map.get(val).add(list.size());\\n            list.add(val);\\n            return false;\\n        }else{ \\n            Set<Integer>set=new HashSet<>();\\n            set.add(list.size());\\n            list.add(val);\\n            map.put(val,set);\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!map.containsKey(val))return false;\\n        Set<Integer>l=map.get(val);\\n        int removeIndex=0;\\n        for(Integer key:l){\\n            removeIndex=key;break;\\n        }\\n        l.remove(removeIndex);\\n        if(l.size()==0)map.remove(val);\\n        if(removeIndex==list.size()-1){\\n            list.remove(list.size()-1);\\n            return true;\\n        }\\n        int lastval=list.get(list.size()-1);\\n        Set<Integer>l1=map.get(lastval);\\n        l1.remove(list.size()-1);\\n        l1.add(removeIndex);\\n        list.remove(list.size()-1);\\n        list.set(removeIndex,lastval);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return list.get(r.nextInt(list.size()));\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\n\\n    /** Initialize your data structure here. */\\n    Random r = new Random();\\n    List<Integer>list=new ArrayList<>();\\n    Map<Integer,Set<Integer>>map=new HashMap<>();\\n    public RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)){\\n            map.get(val).add(list.size());\\n            list.add(val);\\n            return false;\\n        }else{ \\n            Set<Integer>set=new HashSet<>();\\n            set.add(list.size());\\n            list.add(val);\\n            map.put(val,set);\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!map.containsKey(val))return false;\\n        Set<Integer>l=map.get(val);\\n        int removeIndex=0;\\n        for(Integer key:l){\\n            removeIndex=key;break;\\n        }\\n        l.remove(removeIndex);\\n        if(l.size()==0)map.remove(val);\\n        if(removeIndex==list.size()-1){\\n            list.remove(list.size()-1);\\n            return true;\\n        }\\n        int lastval=list.get(list.size()-1);\\n        Set<Integer>l1=map.get(lastval);\\n        l1.remove(list.size()-1);\\n        l1.add(removeIndex);\\n        list.remove(list.size()-1);\\n        list.set(removeIndex,lastval);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return list.get(r.nextInt(list.size()));\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526548,
                "title": "accepted-c-dictionary-list-solution-easy-to-understand",
                "content": "```\\npublic class RandomizedCollection\\n{\\n    private Dictionary<int, int> map;\\n    private List<int> values;\\n    private Random r;\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        map = new Dictionary<int, int>();\\n        values = new List<int>();\\n        r = new Random();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public bool Insert(int val)\\n    {\\n        bool contained = false;\\n        if (!map.ContainsKey(val))\\n        {\\n            contained = true;\\n            map.Add(val, 0);\\n        }\\n        \\n        map[val]++;\\n        values.Add(val);\\n        return contained;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public bool Remove(int val)\\n    {\\n        if (map.ContainsKey(val))\\n        {\\n            map[val]--;\\n            values.Remove(val);\\n            if (map[val] == 0)\\n                map.Remove(val);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int GetRandom()\\n    {\\n        int index = r.Next(values.Count);\\n        return values[index];\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.Insert(val);\\n * bool param_2 = obj.Remove(val);\\n * int param_3 = obj.GetRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedCollection\\n{\\n    private Dictionary<int, int> map;\\n    private List<int> values;\\n    private Random r;\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        map = new Dictionary<int, int>();\\n        values = new List<int>();\\n        r = new Random();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public bool Insert(int val)\\n    {\\n        bool contained = false;\\n        if (!map.ContainsKey(val))\\n        {\\n            contained = true;\\n            map.Add(val, 0);\\n        }\\n        \\n        map[val]++;\\n        values.Add(val);\\n        return contained;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public bool Remove(int val)\\n    {\\n        if (map.ContainsKey(val))\\n        {\\n            map[val]--;\\n            values.Remove(val);\\n            if (map[val] == 0)\\n                map.Remove(val);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int GetRandom()\\n    {\\n        int index = r.Next(values.Count);\\n        return values[index];\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.Insert(val);\\n * bool param_2 = obj.Remove(val);\\n * int param_3 = obj.GetRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522404,
                "title": "c-easy-112-ms-hashmap-and-vector-solution",
                "content": "```\\nclass RandomizedCollection {\\nprivate:\\n    unordered_map<int,int> hashmap; // maps index->num\\n    vector<int> nums;\\npublic:\\n    RandomizedCollection() {}\\n    \\n    bool insert(int val) {\\n        bool result = true;\\n        if(find(nums.begin(), nums.end(), val) != nums.end()) result = false;\\n        nums.push_back(val);\\n        hashmap[nums.size()-1] = val; // curr index->num\\n        return result;\\n    }\\n    \\n    bool remove(int val) {\\n        if(find(nums.begin(), nums.end(), val) == nums.end()) return false;\\n        int last = nums.back();\\n        int valpos = find(nums.begin(), nums.end(), val) - nums.begin();\\n        int lastpos = nums.size()-1;\\n        hashmap[valpos] = last;  //store last value at val\\'s index\\n        hashmap.erase(lastpos); //delete the last index from hashmap\\n        nums[valpos] = last; //store the last value at val\\'s index\\n        nums.pop_back(); //delete the last index from nums \\n\\t\\t//basically we just swapped the last element with val to be removed and deleted the last index of both nums & hashmap\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedCollection {\\nprivate:\\n    unordered_map<int,int> hashmap; // maps index->num\\n    vector<int> nums;\\npublic:\\n    RandomizedCollection() {}\\n    \\n    bool insert(int val) {\\n        bool result = true;\\n        if(find(nums.begin(), nums.end(), val) != nums.end()) result = false;\\n        nums.push_back(val);\\n        hashmap[nums.size()-1] = val; // curr index->num\\n        return result;\\n    }\\n    \\n    bool remove(int val) {\\n        if(find(nums.begin(), nums.end(), val) == nums.end()) return false;\\n        int last = nums.back();\\n        int valpos = find(nums.begin(), nums.end(), val) - nums.begin();\\n        int lastpos = nums.size()-1;\\n        hashmap[valpos] = last;  //store last value at val\\'s index\\n        hashmap.erase(lastpos); //delete the last index from hashmap\\n        nums[valpos] = last; //store the last value at val\\'s index\\n        nums.pop_back(); //delete the last index from nums \\n\\t\\t//basically we just swapped the last element with val to be removed and deleted the last index of both nums & hashmap\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504680,
                "title": "c-with-explanation",
                "content": "Credit of solution goes to https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/discuss/316981/C-numberAndIndexSet-and-numberList\\n\\nIdea is extension of this question https://leetcode.com/problems/insert-delete-getrandom-o1/\\n\\nExplanation: We are storing index of each number in dictionary, but as numbers are repeating (Save all the index for that number in HashSet as Value with key as that number -- for Dictionary )   \\n\\n```\\npublic class RandomizedCollection {\\n    \\n    Random random;\\n    Dictionary<int, HashSet<int>> numberAndIndexSet;\\n    IList<int> numberList ;\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection()\\n    {\\n        random = new Random();\\n         numberAndIndexSet = new Dictionary<int, HashSet<int>>();\\n         numberList = new List<int>();\\n    }\\n     \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public bool Insert(int val)\\n    {\\n        // if number is present we need to return false and add the location to HashSet\\n        if (numberAndIndexSet.ContainsKey(val))\\n        {\\n            numberList.Add(val);\\n            numberAndIndexSet[val].Add(numberList.Count - 1);\\n            return false;\\n        }\\n        else\\n        {\\n            // if number is not present we need to return true and add value to dict\\n            numberList.Add(val);\\n            numberAndIndexSet[val] = new HashSet<int>(){numberList.Count - 1};\\n            return true;\\n        }\\n    }\\n     \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public bool Remove(int val)\\n    {\\n        // if number not present in dict \\n        if (!numberAndIndexSet.ContainsKey(val)) \\n            return false;\\n \\n        // first index from HashSet\\n        int curIndex = numberAndIndexSet[val].First();\\n         // removing it from HashSet\\n        numberAndIndexSet[val].Remove(curIndex);\\n        // Checking if HashSet at that position just contained on value \\n        if (!numberAndIndexSet[val].Any())  numberAndIndexSet.Remove(val);\\n        // In order to remove in O(1) time complexity we need to remove from last location \\n        // bcoz time complexity of removal from list is O(n - index) \\n        // n are number of elements and index if is last will bring complexity to O(1)\\n        if (curIndex == numberList.Count - 1)\\n        {\\n            numberList.RemoveAt(numberList.Count - 1);\\n        }\\n        else\\n        {\\n            // get last number \\n            int needToModifiedNumber = numberList[numberList.Count - 1];\\n            // push last number to this numbers (to be deleted number) position \\n            numberList[curIndex] = needToModifiedNumber;\\n            // remove last index in O(1)\\n            numberList.RemoveAt(numberList.Count - 1);\\n            // add the new index for last number in dictionary\\n            numberAndIndexSet[needToModifiedNumber].Remove(numberList.Count);\\n            numberAndIndexSet[needToModifiedNumber].Add(curIndex);           \\n        }\\n \\n        return true;\\n    }\\n     \\n    /** Get a random element from the collection. */\\n    public int GetRandom()\\n    {\\n        int randomIndex = random.Next(numberList.Count);\\n \\n        return numberList[randomIndex];\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.Insert(val);\\n * bool param_2 = obj.Remove(val);\\n * int param_3 = obj.GetRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedCollection {\\n    \\n    Random random;\\n    Dictionary<int, HashSet<int>> numberAndIndexSet;\\n    IList<int> numberList ;\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection()\\n    {\\n        random = new Random();\\n         numberAndIndexSet = new Dictionary<int, HashSet<int>>();\\n         numberList = new List<int>();\\n    }\\n     \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public bool Insert(int val)\\n    {\\n        // if number is present we need to return false and add the location to HashSet\\n        if (numberAndIndexSet.ContainsKey(val))\\n        {\\n            numberList.Add(val);\\n            numberAndIndexSet[val].Add(numberList.Count - 1);\\n            return false;\\n        }\\n        else\\n        {\\n            // if number is not present we need to return true and add value to dict\\n            numberList.Add(val);\\n            numberAndIndexSet[val] = new HashSet<int>(){numberList.Count - 1};\\n            return true;\\n        }\\n    }\\n     \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public bool Remove(int val)\\n    {\\n        // if number not present in dict \\n        if (!numberAndIndexSet.ContainsKey(val)) \\n            return false;\\n \\n        // first index from HashSet\\n        int curIndex = numberAndIndexSet[val].First();\\n         // removing it from HashSet\\n        numberAndIndexSet[val].Remove(curIndex);\\n        // Checking if HashSet at that position just contained on value \\n        if (!numberAndIndexSet[val].Any())  numberAndIndexSet.Remove(val);\\n        // In order to remove in O(1) time complexity we need to remove from last location \\n        // bcoz time complexity of removal from list is O(n - index) \\n        // n are number of elements and index if is last will bring complexity to O(1)\\n        if (curIndex == numberList.Count - 1)\\n        {\\n            numberList.RemoveAt(numberList.Count - 1);\\n        }\\n        else\\n        {\\n            // get last number \\n            int needToModifiedNumber = numberList[numberList.Count - 1];\\n            // push last number to this numbers (to be deleted number) position \\n            numberList[curIndex] = needToModifiedNumber;\\n            // remove last index in O(1)\\n            numberList.RemoveAt(numberList.Count - 1);\\n            // add the new index for last number in dictionary\\n            numberAndIndexSet[needToModifiedNumber].Remove(numberList.Count);\\n            numberAndIndexSet[needToModifiedNumber].Add(curIndex);           \\n        }\\n \\n        return true;\\n    }\\n     \\n    /** Get a random element from the collection. */\\n    public int GetRandom()\\n    {\\n        int randomIndex = random.Next(numberList.Count);\\n \\n        return numberList[randomIndex];\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.Insert(val);\\n * bool param_2 = obj.Remove(val);\\n * int param_3 = obj.GetRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490767,
                "title": "c-solution-with-unordered-multiset",
                "content": "```\\nclass RandomizedCollection {\\nprivate:\\n    std::unordered_multiset<int> collection;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool notExists = (collection.find(val) == collection.end()) ? true : false;\\n\\n        collection.insert(val);\\n        return notExists;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        auto it = collection.find(val);\\n        \\n        if(it == collection.end()){\\n            return false;\\n        }\\n        \\n        collection.erase(it);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        int random = rand() % collection.size();\\n        std::unordered_multiset<int>::iterator it = std::next(std::begin(collection), random);\\n        return *it;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\nprivate:\\n    std::unordered_multiset<int> collection;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool notExists = (collection.find(val) == collection.end()) ? true : false;\\n\\n        collection.insert(val);\\n        return notExists;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        auto it = collection.find(val);\\n        \\n        if(it == collection.end()){\\n            return false;\\n        }\\n        \\n        collection.erase(it);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        int random = rand() % collection.size();\\n        std::unordered_multiset<int>::iterator it = std::next(std::begin(collection), random);\\n        return *it;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480249,
                "title": "can-someone-tell-me-why-this-is-not-working-for-the-last-test-case",
                "content": "```\\nimport random\\nclass Node:\\n\\tdef __init__(self,value):\\n\\t\\tself.count=1\\n\\t\\tself.val=value\\n\\t\\tself.next=None\\n\\t\\tself.prev=None\\n\\n\\n\\n\\nclass DLLNode:\\n\\tdef __init__(self):\\n\\t\\tself.head=Node(None)\\n\\t\\tself.tail=Node(None)\\n\\t\\tself.head.next=self.tail\\n\\t\\tself.tail.prev=self.head\\n\\n\\tdef moveToHead(self,node):\\n\\t\\tif node.next or node.prev:\\n\\t\\t\\tnode=self.removeNode(node)\\n\\t\\tnode.prev=self.head\\n\\t\\tnode.next=self.head.next\\n\\t\\tself.head.next=node\\n\\t\\tnode.next.prev=node\\n\\t\\tpass\\n\\tdef removeNode(self,node):\\n\\t\\tif node:\\n\\t\\t\\tnode.next.prev=node.prev\\n\\t\\t\\tnode.prev.next=node.next\\n\\t\\t\\tnode.next=node.prev=None\\n\\t\\t\\treturn node\\n\\t\\traise Exception(\"invalid node\")\\n        \\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.cache={}\\n        self.data=DLLNode()\\n    def insert(self, val: int) -> bool:\\n        if val in self.cache:\\n            self.cache[val].count+=1\\n            return False\\n        self.cache[val]=Node(val)\\n        self.data.moveToHead(self.cache[val])\\n        return True\\n \\n    def remove(self, val: int) -> bool:\\n        if val not in self.cache:\\n            return False\\n        if self.cache[val].count>1:\\n            self.cache[val].count-=1\\n            return True\\n            \\n        else:\\n            node = self.data.removeNode(self.cache[val])\\n            del node\\n            del self.cache[val]\\n            return True\\n        \\n        \\n\\n    def getRandom(self) -> int:\\n        key=list(self.cache.keys())\\n        return random.choice(key)\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass Node:\\n\\tdef __init__(self,value):\\n\\t\\tself.count=1\\n\\t\\tself.val=value\\n\\t\\tself.next=None\\n\\t\\tself.prev=None\\n\\n\\n\\n\\nclass DLLNode:\\n\\tdef __init__(self):\\n\\t\\tself.head=Node(None)\\n\\t\\tself.tail=Node(None)\\n\\t\\tself.head.next=self.tail\\n\\t\\tself.tail.prev=self.head\\n\\n\\tdef moveToHead(self,node):\\n\\t\\tif node.next or node.prev:\\n\\t\\t\\tnode=self.removeNode(node)\\n\\t\\tnode.prev=self.head\\n\\t\\tnode.next=self.head.next\\n\\t\\tself.head.next=node\\n\\t\\tnode.next.prev=node\\n\\t\\tpass\\n\\tdef removeNode(self,node):\\n\\t\\tif node:\\n\\t\\t\\tnode.next.prev=node.prev\\n\\t\\t\\tnode.prev.next=node.next\\n\\t\\t\\tnode.next=node.prev=None\\n\\t\\t\\treturn node\\n\\t\\traise Exception(\"invalid node\")\\n        \\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.cache={}\\n        self.data=DLLNode()\\n    def insert(self, val: int) -> bool:\\n        if val in self.cache:\\n            self.cache[val].count+=1\\n            return False\\n        self.cache[val]=Node(val)\\n        self.data.moveToHead(self.cache[val])\\n        return True\\n \\n    def remove(self, val: int) -> bool:\\n        if val not in self.cache:\\n            return False\\n        if self.cache[val].count>1:\\n            self.cache[val].count-=1\\n            return True\\n            \\n        else:\\n            node = self.data.removeNode(self.cache[val])\\n            del node\\n            del self.cache[val]\\n            return True\\n        \\n        \\n\\n    def getRandom(self) -> int:\\n        key=list(self.cache.keys())\\n        return random.choice(key)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458286,
                "title": "c-40ms-beat-99-72-python-88ms-beat-99-89",
                "content": "C++ solution,\\n```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (myMap.count(val) == 0)\\n            myMap[val] = {nums.size()};\\n        else\\n            myMap[val].insert(nums.size());\\n        \\n        nums.push_back(val);\\n        return myMap[val].size() == 1;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        bool res = false;\\n        if (myMap.count(val) != 0) {\\n            res = true;\\n\\n            int i = nums.size()-1;\\n            if (myMap[val].count(i) != 0)\\n                myMap[val].erase(i);\\n            else {\\n                int lastValue = nums[i];\\n                int tempIndex = *(myMap[val].begin());\\n                myMap[val].erase(myMap[val].begin());\\n                int tempValue = nums[tempIndex];\\n                swap(nums[i], nums[tempIndex]);\\n                myMap[lastValue].erase(i);\\n                myMap[lastValue].insert(tempIndex);\\n            }\\n\\n            nums.pop_back();\\n            if (myMap[val].size() == 0)\\n                myMap.erase(val);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n\\nprivate:\\n    vector<int> nums;\\n    unordered_map<int, unordered_set<int>> myMap;\\n};\\n```\\n\\nPython solution,\\n```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.mylist = []\\n        self.mydict = {}\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        if val not in self.mydict:\\n            self.mydict[val] = {len(self.mylist)}\\n        else:\\n            self.mydict[val].add(len(self.mylist))\\n        \\n        self.mylist.append(val)\\n        return len(self.mydict[val]) == 1\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        res = False\\n        if val in self.mydict:\\n            res = True\\n\\n            i = len(self.mylist)-1\\n            if i in self.mydict[val]:\\n                self.mydict[val].discard(i)\\n            else:\\n                lastValue = self.mylist[i]\\n                tempIndex = self.mydict[val].pop()\\n                tempValue = self.mylist[tempIndex]\\n                self.mylist[i], self.mylist[tempIndex] = self.mylist[tempIndex], self.mylist[i]\\n                self.mydict[lastValue].discard(i)\\n                self.mydict[lastValue].add(tempIndex)\\n        \\n            self.mylist.pop()\\n            if len(self.mydict[val]) == 0:\\n                del self.mydict[val]\\n        \\n        return res\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the collection.\\n        \"\"\"\\n        return random.choice(self.mylist)\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (myMap.count(val) == 0)\\n            myMap[val] = {nums.size()};\\n        else\\n            myMap[val].insert(nums.size());\\n        \\n        nums.push_back(val);\\n        return myMap[val].size() == 1;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        bool res = false;\\n        if (myMap.count(val) != 0) {\\n            res = true;\\n\\n            int i = nums.size()-1;\\n            if (myMap[val].count(i) != 0)\\n                myMap[val].erase(i);\\n            else {\\n                int lastValue = nums[i];\\n                int tempIndex = *(myMap[val].begin());\\n                myMap[val].erase(myMap[val].begin());\\n                int tempValue = nums[tempIndex];\\n                swap(nums[i], nums[tempIndex]);\\n                myMap[lastValue].erase(i);\\n                myMap[lastValue].insert(tempIndex);\\n            }\\n\\n            nums.pop_back();\\n            if (myMap[val].size() == 0)\\n                myMap.erase(val);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n\\nprivate:\\n    vector<int> nums;\\n    unordered_map<int, unordered_set<int>> myMap;\\n};\\n```\n```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.mylist = []\\n        self.mydict = {}\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        if val not in self.mydict:\\n            self.mydict[val] = {len(self.mylist)}\\n        else:\\n            self.mydict[val].add(len(self.mylist))\\n        \\n        self.mylist.append(val)\\n        return len(self.mydict[val]) == 1\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        res = False\\n        if val in self.mydict:\\n            res = True\\n\\n            i = len(self.mylist)-1\\n            if i in self.mydict[val]:\\n                self.mydict[val].discard(i)\\n            else:\\n                lastValue = self.mylist[i]\\n                tempIndex = self.mydict[val].pop()\\n                tempValue = self.mylist[tempIndex]\\n                self.mylist[i], self.mylist[tempIndex] = self.mylist[tempIndex], self.mylist[i]\\n                self.mydict[lastValue].discard(i)\\n                self.mydict[lastValue].add(tempIndex)\\n        \\n            self.mylist.pop()\\n            if len(self.mydict[val]) == 0:\\n                del self.mydict[val]\\n        \\n        return res\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the collection.\\n        \"\"\"\\n        return random.choice(self.mylist)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434888,
                "title": "javascript-array-map-val-set",
                "content": "## Data Structure\\n1. `getRandom()` O(1) -- means we need an Array to store all numbers;\\n2. `remove()` O(1) -- means we also need a Map, and since there may be duplicate numbers, we need a Set inside the Map to make O(1) possible.\\n\\nIn all, the data structure should be \\n1. Array\\n2. Map\\n3. a Set inside the Map\\n\\n------------------\\n\\n## Code\\n```\\nvar RandomizedCollection = function() {\\n    this.nums = [];\\n    this.map = new Map();\\n};\\n\\nRandomizedCollection.prototype.insert = function(val) {\\n    this.nums.push(val);\\n    let existed = false;\\n    if(!this.map.has(val)) this.map.set(val, new Set());\\n    else existed = true;\\n    this.map.get(val).add(this.nums.length-1);\\n    \\n    if(existed) return false;\\n    else return true;\\n};\\n\\nRandomizedCollection.prototype.remove = function(val) {\\n    if(!this.map.has(val)) return false;\\n    \\n    if(this.nums[this.nums.length-1] === val){\\n        this.map.get(val).delete(this.nums.length-1);\\n        this.nums.pop();\\n    }\\n    else{\\n        let indexToRemove = [...this.map.get(val).keys()][0],\\n            swapIndex = this.nums.length-1,\\n            swapVal = this.nums[swapIndex];\\n        this.map.get(swapVal).add(indexToRemove);\\n        this.map.get(swapVal).delete(swapIndex);\\n        this.map.get(val).delete(indexToRemove);\\n        this.nums[indexToRemove] = swapVal;\\n        this.nums.pop();\\n    }\\n    if(this.map.get(val).size === 0) this.map.delete(val);\\n    return true;\\n};\\n\\nRandomizedCollection.prototype.getRandom = function() {\\n    return this.nums[Math.floor(Math.random() * this.nums.length)];\\n};\\n ```\\n \\n ------\\n \\n ## Map and Set\\n Each time I use Map or Set I have to refer to some reference site, so I put the used methods and properties for your reference:\\n Map:\\n 1. `has(key)`;\\n 2. `set(key, value)`;\\n 3. `get(key)`;\\n 4. `delete(key)`.\\n\\nSet:\\n1. `add(val)`;\\n2. `delete(val)`;\\n3. `keys()` -> return an iterable object, not an array;\\n4. `size`.",
                "solutionTags": [],
                "code": "```\\nvar RandomizedCollection = function() {\\n    this.nums = [];\\n    this.map = new Map();\\n};\\n\\nRandomizedCollection.prototype.insert = function(val) {\\n    this.nums.push(val);\\n    let existed = false;\\n    if(!this.map.has(val)) this.map.set(val, new Set());\\n    else existed = true;\\n    this.map.get(val).add(this.nums.length-1);\\n    \\n    if(existed) return false;\\n    else return true;\\n};\\n\\nRandomizedCollection.prototype.remove = function(val) {\\n    if(!this.map.has(val)) return false;\\n    \\n    if(this.nums[this.nums.length-1] === val){\\n        this.map.get(val).delete(this.nums.length-1);\\n        this.nums.pop();\\n    }\\n    else{\\n        let indexToRemove = [...this.map.get(val).keys()][0],\\n            swapIndex = this.nums.length-1,\\n            swapVal = this.nums[swapIndex];\\n        this.map.get(swapVal).add(indexToRemove);\\n        this.map.get(swapVal).delete(swapIndex);\\n        this.map.get(val).delete(indexToRemove);\\n        this.nums[indexToRemove] = swapVal;\\n        this.nums.pop();\\n    }\\n    if(this.map.get(val).size === 0) this.map.delete(val);\\n    return true;\\n};\\n\\nRandomizedCollection.prototype.getRandom = function() {\\n    return this.nums[Math.floor(Math.random() * this.nums.length)];\\n};\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 389403,
                "title": "javascript-solution-beats-60-42",
                "content": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar RandomizedCollection = function() {\\n    this.map = new Map;\\n    this.arr = new Array;\\n};\\n\\n/**\\n * Inserts a value to the collection. Returns true if the collection did not already contain the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedCollection.prototype.insert = function(val) {\\n    let indexes = this.map.get(val);\\n    let flag = false;\\n    \\n    if (indexes === undefined) {\\n        flag = true;\\n        indexes = new Set;\\n    }\\n    \\n    indexes.add(this.arr.length);\\n    this.map.set(val, indexes);\\n    this.arr.push(val);\\n    return flag;\\n};\\n\\n/**\\n * Removes a value from the collection. Returns true if the collection contained the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedCollection.prototype.remove = function(val) {\\n    let indexes = this.map.get(val);\\n    if (indexes === undefined) {\\n        return false;\\n    }\\n    \\n    let index = indexes.values().next().value;\\n    \\n    if (this.arr[index] !== this.arr[this.arr.length - 1]) {\\n        indexes.delete(index);\\n        swap(this.arr, index, this.arr.length - 1);\\n        let lastElIdxes = this.map.get(this.arr[index]);\\n        lastElIdxes.delete(this.arr.length - 1);\\n        lastElIdxes.add(index);\\n        \\n        this.map.set(this.arr[index], lastElIdxes);\\n    } else {\\n        indexes.delete(this.arr.length - 1);\\n    }\\n    \\n    this.arr.pop();\\n    if (!indexes.size) {\\n        this.map.delete(val);\\n    } else {\\n        this.map.set(val, indexes);\\n    }\\n    \\n    function swap(arr, i, j) {\\n        let t = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = t;\\n    }\\n    \\n    return true;\\n};\\n\\n/**\\n * Get a random element from the collection.\\n * @return {number}\\n */\\nRandomizedCollection.prototype.getRandom = function() {\\n    let random = Math.floor(Math.random() * this.arr.length);\\n    \\n    return this.arr[random];\\n};\\n\\n/** \\n * Your RandomizedCollection object will be instantiated and called as such:\\n * var obj = new RandomizedCollection()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar RandomizedCollection = function() {\\n    this.map = new Map;\\n    this.arr = new Array;\\n};\\n\\n/**\\n * Inserts a value to the collection. Returns true if the collection did not already contain the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedCollection.prototype.insert = function(val) {\\n    let indexes = this.map.get(val);\\n    let flag = false;\\n    \\n    if (indexes === undefined) {\\n        flag = true;\\n        indexes = new Set;\\n    }\\n    \\n    indexes.add(this.arr.length);\\n    this.map.set(val, indexes);\\n    this.arr.push(val);\\n    return flag;\\n};\\n\\n/**\\n * Removes a value from the collection. Returns true if the collection contained the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedCollection.prototype.remove = function(val) {\\n    let indexes = this.map.get(val);\\n    if (indexes === undefined) {\\n        return false;\\n    }\\n    \\n    let index = indexes.values().next().value;\\n    \\n    if (this.arr[index] !== this.arr[this.arr.length - 1]) {\\n        indexes.delete(index);\\n        swap(this.arr, index, this.arr.length - 1);\\n        let lastElIdxes = this.map.get(this.arr[index]);\\n        lastElIdxes.delete(this.arr.length - 1);\\n        lastElIdxes.add(index);\\n        \\n        this.map.set(this.arr[index], lastElIdxes);\\n    } else {\\n        indexes.delete(this.arr.length - 1);\\n    }\\n    \\n    this.arr.pop();\\n    if (!indexes.size) {\\n        this.map.delete(val);\\n    } else {\\n        this.map.set(val, indexes);\\n    }\\n    \\n    function swap(arr, i, j) {\\n        let t = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = t;\\n    }\\n    \\n    return true;\\n};\\n\\n/**\\n * Get a random element from the collection.\\n * @return {number}\\n */\\nRandomizedCollection.prototype.getRandom = function() {\\n    let random = Math.floor(Math.random() * this.arr.length);\\n    \\n    return this.arr[random];\\n};\\n\\n/** \\n * Your RandomizedCollection object will be instantiated and called as such:\\n * var obj = new RandomizedCollection()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 367952,
                "title": "c-easy-multiset-o-1-solution",
                "content": "```class RandomizedCollection {\\n    multiset<int> s;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        auto find = s.find(val);\\n        if(find == s.end())\\n        {\\n            s.insert(val);\\n            return true;\\n        }\\n        else{\\n            s.insert(val);\\n            return false;\\n        }\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        auto find = s.find(val);\\n        if(find == s.end())\\n            return false;\\n        else\\n        {\\n            s.erase(find);\\n            return true;\\n        }\\n        \\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        int size = rand() % s.size();\\n        auto iter = s.begin();\\n        while(iter != s.end())\\n        {\\n            if(size == 0)\\n                return *iter;\\n            iter++;\\n            size--;\\n        }\\n        return INT_MIN;\\n    }\\n};```\\n",
                "solutionTags": [],
                "code": "```class RandomizedCollection {\\n    multiset<int> s;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        auto find = s.find(val);\\n        if(find == s.end())\\n        {\\n            s.insert(val);\\n            return true;\\n        }\\n        else{\\n            s.insert(val);\\n            return false;\\n        }\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        auto find = s.find(val);\\n        if(find == s.end())\\n            return false;\\n        else\\n        {\\n            s.erase(find);\\n            return true;\\n        }\\n        \\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        int size = rand() % s.size();\\n        auto iter = s.begin();\\n        while(iter != s.end())\\n        {\\n            if(size == 0)\\n                return *iter;\\n            iter++;\\n            size--;\\n        }\\n        return INT_MIN;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 358250,
                "title": "python-solution",
                "content": "```\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.itemArray = []\\n        self.itemMap = collections.defaultdict(set)\\n        \\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        self.itemArray.append(val) # [a,b,c] <- a => [a,b,c,a]\\n        self.itemMap[val].add(len(self.itemArray)-1) # {a:[0,3], b: [1], c:[2]}\\n             \\n                \\n        if len(self.itemMap[val]) == 1:\\n            return True\\n        return False\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n#         print self.itemArray\\n#         print self.itemMap\\n        \\n        if len(self.itemMap[val]) != 0:\\n            indexToRemove = self.itemMap[val].pop()\\n            lastVal = self.itemArray[-1]\\n            self.itemArray[indexToRemove] = lastVal\\n            self.itemMap[lastVal].add(indexToRemove)\\n            self.itemMap[lastVal].remove(len(self.itemArray)-1)\\n            \\n            self.itemArray.pop()\\n            \\n            return True\\n        \\n        return False\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the collection.\\n        :rtype: int\\n        \"\"\"\\n        index = random.randrange(0, len(self.itemArray)) \\n        # Return element at randomly picked index  \\n        return self.itemArray[index] \\n        \\n        \\n        \\n        \\n        \\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.itemArray = []\\n        self.itemMap = collections.defaultdict(set)\\n        \\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        self.itemArray.append(val) # [a,b,c] <- a => [a,b,c,a]\\n        self.itemMap[val].add(len(self.itemArray)-1) # {a:[0,3], b: [1], c:[2]}\\n             \\n                \\n        if len(self.itemMap[val]) == 1:\\n            return True\\n        return False\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n#         print self.itemArray\\n#         print self.itemMap\\n        \\n        if len(self.itemMap[val]) != 0:\\n            indexToRemove = self.itemMap[val].pop()\\n            lastVal = self.itemArray[-1]\\n            self.itemArray[indexToRemove] = lastVal\\n            self.itemMap[lastVal].add(indexToRemove)\\n            self.itemMap[lastVal].remove(len(self.itemArray)-1)\\n            \\n            self.itemArray.pop()\\n            \\n            return True\\n        \\n        return False\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the collection.\\n        :rtype: int\\n        \"\"\"\\n        index = random.randrange(0, len(self.itemArray)) \\n        # Return element at randomly picked index  \\n        return self.itemArray[index] \\n        \\n        \\n        \\n        \\n        \\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346937,
                "title": "python-simple-solution",
                "content": "Similar to the Insert Delete GetRandom O(1) - No Duplicates solution.  Maintain a map of the values and the ids.  When inserting an element append the index to the map in the val key.  When removing switch places with the end element and update the map.  \\n\\nGetRandom just returns a random number proportional to the number of duplicate elements, respectively.\\n\\n```\\nimport collections\\nimport random\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.idx_map = collections.defaultdict(list)\\n        self.items = []\\n        \\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        seen = True\\n        if val in self.idx_map:\\n            seen = False\\n        self.idx_map[val].append(len(self.items))\\n        self.items.append(val)\\n        \\n        return seen\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val not in self.idx_map:\\n            return False\\n        \\n        # get index of one of the indexes of val\\n        # if it\\'s the last one then remove\\n        idx = self.idx_map[val].pop()\\n        if len(self.idx_map[val]) == 0:\\n            del self.idx_map[val]\\n            \\n        # last item, just pop it\\n        if idx == len(self.items)-1:\\n            self.items.pop()\\n            return True\\n        \\n        end = self.items.pop()\\n        self.items[idx] = end\\n        \\n        # remove old index \\n        self.idx_map[end].remove(len(self.items))\\n        \\n        # add new index\\n        self.idx_map[end].append(idx)\\n        return True\\n        \\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the collection.\\n        :rtype: int\\n        \"\"\"\\n        return self.items[random.randint(0, len(self.items)-1)]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nimport random\\nclass RandomizedCollection(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.idx_map = collections.defaultdict(list)\\n        self.items = []\\n        \\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        seen = True\\n        if val in self.idx_map:\\n            seen = False\\n        self.idx_map[val].append(len(self.items))\\n        self.items.append(val)\\n        \\n        return seen\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val not in self.idx_map:\\n            return False\\n        \\n        # get index of one of the indexes of val\\n        # if it\\'s the last one then remove\\n        idx = self.idx_map[val].pop()\\n        if len(self.idx_map[val]) == 0:\\n            del self.idx_map[val]\\n            \\n        # last item, just pop it\\n        if idx == len(self.items)-1:\\n            self.items.pop()\\n            return True\\n        \\n        end = self.items.pop()\\n        self.items[idx] = end\\n        \\n        # remove old index \\n        self.idx_map[end].remove(len(self.items))\\n        \\n        # add new index\\n        self.idx_map[end].append(idx)\\n        return True\\n        \\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the collection.\\n        :rtype: int\\n        \"\"\"\\n        return self.items[random.randint(0, len(self.items)-1)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326503,
                "title": "python-solution-similar-idea-as-operating-the-hash-map",
                "content": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.num_list = []\\n        self.loc = collections.defaultdict(list)\\n        self.empty = []\\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        if len(self.empty)>0:\\n            idx = self.empty.pop()\\n            self.num_list[idx] = val\\n            self.loc[val] += [idx]\\n        else:\\n            idx = len(self.num_list)\\n            self.num_list += [val]\\n            self.loc[val] += [idx]\\n        if len(self.loc[val]) > 1:\\n            return False\\n        return True\\n    \\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        if len(self.loc[val]) > 0:\\n            idx = self.loc[val].pop()\\n            self.num_list[idx] = None\\n            self.empty += [idx]\\n            return True\\n        if len(self.empty) >= len(self.num_list)//2:\\n            self.num_list = []\\n            for key in self.loc:\\n                for i in self.loc[key]:\\n                    self.num_list += [key]\\n                self.loc[key] = []\\n            for i in range(len(self.num_list)):\\n                self.loc[self.num_list[i]] += [i]\\n            self.empty = []\\n        return False\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the collection.\\n        \"\"\"\\n        if len(self.num_list) == len(self.empty):\\n            return False\\n        res = None\\n        while res == None:\\n            res = self.num_list[random.randint(1,len(self.num_list))-1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.num_list = []\\n        self.loc = collections.defaultdict(list)\\n        self.empty = []\\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\\n        \"\"\"\\n        if len(self.empty)>0:\\n            idx = self.empty.pop()\\n            self.num_list[idx] = val\\n            self.loc[val] += [idx]\\n        else:\\n            idx = len(self.num_list)\\n            self.num_list += [val]\\n            self.loc[val] += [idx]\\n        if len(self.loc[val]) > 1:\\n            return False\\n        return True\\n    \\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the collection. Returns true if the collection contained the specified element.\\n        \"\"\"\\n        if len(self.loc[val]) > 0:\\n            idx = self.loc[val].pop()\\n            self.num_list[idx] = None\\n            self.empty += [idx]\\n            return True\\n        if len(self.empty) >= len(self.num_list)//2:\\n            self.num_list = []\\n            for key in self.loc:\\n                for i in self.loc[key]:\\n                    self.num_list += [key]\\n                self.loc[key] = []\\n            for i in range(len(self.num_list)):\\n                self.loc[self.num_list[i]] += [i]\\n            self.empty = []\\n        return False\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the collection.\\n        \"\"\"\\n        if len(self.num_list) == len(self.empty):\\n            return False\\n        res = None\\n        while res == None:\\n            res = self.num_list[random.randint(1,len(self.num_list))-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 220652,
                "title": "c-48ms-unordered-multimap-and-vector-of-iterators-uniform-distribution",
                "content": "```\\nclass RandomizedCollection {\\n\\tstd::unordered_multimap<int, size_t> m_coll;\\n\\tstd::vector<std::unordered_multimap<int, size_t>::iterator> m_index;\\n\\tstd::mt19937_64 m_rand;\\n\\tstd::uniform_int_distribution<size_t> m_dist;\\n\\npublic:\\n\\t/** Initialize your data structure here. */\\n\\tRandomizedCollection() : m_coll(), m_index(), m_rand(), m_dist() {}\\n\\n\\t/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n\\tbool insert(int val) {\\n\\t\\tauto not_found = m_coll.find(val) == m_coll.end();\\n\\t\\tm_index.push_back(m_coll.emplace(val, m_index.size()));\\n\\t\\treturn not_found;\\n\\t}\\n\\n\\t/** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n\\tbool remove(int val) {\\n\\t\\tauto it = m_coll.find(val);\\n\\t\\tif (it != m_coll.end()) {\\n\\t\\t\\tassert(it->second < m_index.size());\\n\\t\\t\\tswap(m_index[it->second], m_index.back());\\n\\t\\t\\tm_index[it->second]->second = m_index.back()->second;\\n\\t\\t\\tm_index.pop_back();\\n\\t\\t\\tm_coll.erase(it);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\t/** Get a random element from the collection. */\\n\\tint getRandom() {\\n\\t\\tauto param = uniform_int_distribution<size_t>::param_type(0, m_index.size()-1);\\n\\t\\tauto index = m_dist(m_rand, param);\\n\\t\\tassert(index < m_index.size());\\n\\t\\treturn m_index[index]->first;\\n\\t}\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.insert(val);\\n * bool param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\n\\tstd::unordered_multimap<int, size_t> m_coll;\\n\\tstd::vector<std::unordered_multimap<int, size_t>::iterator> m_index;\\n\\tstd::mt19937_64 m_rand;\\n\\tstd::uniform_int_distribution<size_t> m_dist;\\n\\npublic:\\n\\t/** Initialize your data structure here. */\\n\\tRandomizedCollection() : m_coll(), m_index(), m_rand(), m_dist() {}\\n\\n\\t/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n\\tbool insert(int val) {\\n\\t\\tauto not_found = m_coll.find(val) == m_coll.end();\\n\\t\\tm_index.push_back(m_coll.emplace(val, m_index.size()));\\n\\t\\treturn not_found;\\n\\t}\\n\\n\\t/** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n\\tbool remove(int val) {\\n\\t\\tauto it = m_coll.find(val);\\n\\t\\tif (it != m_coll.end()) {\\n\\t\\t\\tassert(it->second < m_index.size());\\n\\t\\t\\tswap(m_index[it->second], m_index.back());\\n\\t\\t\\tm_index[it->second]->second = m_index.back()->second;\\n\\t\\t\\tm_index.pop_back();\\n\\t\\t\\tm_coll.erase(it);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\t/** Get a random element from the collection. */\\n\\tint getRandom() {\\n\\t\\tauto param = uniform_int_distribution<size_t>::param_type(0, m_index.size()-1);\\n\\t\\tauto index = m_dist(m_rand, param);\\n\\t\\tassert(index < m_index.size());\\n\\t\\treturn m_index[index]->first;\\n\\t}\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.insert(val);\\n * bool param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202069,
                "title": "my-72ms-java-solution-with-hashmap-hashset-and-arraylist-beats-95",
                "content": "```\\nclass RandomizedCollection {\\n    Map<Integer, Set<Integer>> indexes; // a map between value and all of its indexes\\n    List<Integer> list;\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        indexes = new HashMap<>();\\n        list = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean result = !indexes.containsKey(val);\\n        indexes.putIfAbsent(val, new HashSet());\\n        indexes.get(val).add(list.size());\\n        list.add(val);\\n        return result;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        boolean result = indexes.containsKey(val);\\n        if (result) {\\n            int last = list.get(list.size() - 1); // last value in the list\\n            if (last == val) { // last and val are same, just get one index-set and remove the last index in it\\n                Set<Integer> set = indexes.get(val);\\n                set.remove(list.size() - 1);\\n                list.remove(list.size() - 1); // remove last element in the list \\n                if (set.isEmpty()) { // remove the key in the map if set is empty\\n                    indexes.remove(val);\\n                }\\n            } else { // last and val are diffent\\n                Set<Integer> valSet = indexes.get(val);\\n                Set<Integer> lastSet = indexes.get(last);\\n                lastSet.remove(list.size() - 1); // remove last element\\n                int index = valSet.iterator().next(); // get a index of val\\n                valSet.remove(index); // swap the value with last element\\n                lastSet.add(index);\\n                list.set(index, last);\\n                list.remove(list.size() - 1); // remove val at the end of the list\\n                if (valSet.isEmpty()) {\\n                    indexes.remove(val);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        int index = (int) (Math.random() * list.size());\\n        return list.get(index);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\n    Map<Integer, Set<Integer>> indexes; // a map between value and all of its indexes\\n    List<Integer> list;\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        indexes = new HashMap<>();\\n        list = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean result = !indexes.containsKey(val);\\n        indexes.putIfAbsent(val, new HashSet());\\n        indexes.get(val).add(list.size());\\n        list.add(val);\\n        return result;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        boolean result = indexes.containsKey(val);\\n        if (result) {\\n            int last = list.get(list.size() - 1); // last value in the list\\n            if (last == val) { // last and val are same, just get one index-set and remove the last index in it\\n                Set<Integer> set = indexes.get(val);\\n                set.remove(list.size() - 1);\\n                list.remove(list.size() - 1); // remove last element in the list \\n                if (set.isEmpty()) { // remove the key in the map if set is empty\\n                    indexes.remove(val);\\n                }\\n            } else { // last and val are diffent\\n                Set<Integer> valSet = indexes.get(val);\\n                Set<Integer> lastSet = indexes.get(last);\\n                lastSet.remove(list.size() - 1); // remove last element\\n                int index = valSet.iterator().next(); // get a index of val\\n                valSet.remove(index); // swap the value with last element\\n                lastSet.add(index);\\n                list.set(index, last);\\n                list.remove(list.size() - 1); // remove val at the end of the list\\n                if (valSet.isEmpty()) {\\n                    indexes.remove(val);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        int index = (int) (Math.random() * list.size());\\n        return list.get(index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187301,
                "title": "set-map-list-clean-and-simple-java-solution-with-detailed-comment-beats-99-32",
                "content": "Key idea is how to manipulate duplicate number's indexes in O(1) time, Set is a great choice.\n```java\nclass RandomizedCollection {\n    HashMap<Integer, Set<Integer>> map;\n    List<Integer> list;\n    \n    /** Initialize your data structure here. */\n    public RandomizedCollection() {\n        map = new HashMap<>();\n        list = new ArrayList<>();\n    }\n    \n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\n    public boolean insert(int val) {\n        Set<Integer> indexes = map.get(val);\n        // create indexes list if neccessary\n        boolean flag = indexes == null || indexes.size() == 0;\n        if(indexes == null){\n            indexes = new HashSet<>();\n            map.put(val, indexes);\n        }\n        // add new index of val to its indexes set\n        indexes.add(list.size());\n        // update list\n        list.add(val);\n        return flag;\n    }\n    \n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\n    public boolean remove(int val) {\n        Set<Integer> indexes = map.get(val);\n        if(indexes ==  null || indexes.size() == 0){\n            // no such element\n            return false;\n        }else{\n            // get one index of val\n            int index = indexes.iterator().next();\n            // remove it\n            indexes.remove(index);\n            // if index is already the last index, do nothing but delete it\n            if(index != list.size() - 1){\n                int last = list.get(list.size() - 1);\n                Set<Integer> indexesOfLast = map.get(last);\n                // replace val with last number\n                list.set(index, last);\n                // remove the last index\n                indexesOfLast.remove(list.size() - 1);\n                // add new index\n                indexesOfLast.add(index);\n            }\n            // remove the last one\n            list.remove(list.size() - 1);\n            return true;\n        }\n    }\n    \n    /** Get a random element from the collection. */\n    public int getRandom() {\n        // assume no call when collection is empty\n        return list.get((int)(Math.random() * list.size()));\n    }\n}\n```",
                "solutionTags": [],
                "code": "```java\nclass RandomizedCollection {\n    HashMap<Integer, Set<Integer>> map;\n    List<Integer> list;\n    \n    /** Initialize your data structure here. */\n    public RandomizedCollection() {\n        map = new HashMap<>();\n        list = new ArrayList<>();\n    }\n    \n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\n    public boolean insert(int val) {\n        Set<Integer> indexes = map.get(val);\n        // create indexes list if neccessary\n        boolean flag = indexes == null || indexes.size() == 0;\n        if(indexes == null){\n            indexes = new HashSet<>();\n            map.put(val, indexes);\n        }\n        // add new index of val to its indexes set\n        indexes.add(list.size());\n        // update list\n        list.add(val);\n        return flag;\n    }\n    \n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\n    public boolean remove(int val) {\n        Set<Integer> indexes = map.get(val);\n        if(indexes ==  null || indexes.size() == 0){\n            // no such element\n            return false;\n        }else{\n            // get one index of val\n            int index = indexes.iterator().next();\n            // remove it\n            indexes.remove(index);\n            // if index is already the last index, do nothing but delete it\n            if(index != list.size() - 1){\n                int last = list.get(list.size() - 1);\n                Set<Integer> indexesOfLast = map.get(last);\n                // replace val with last number\n                list.set(index, last);\n                // remove the last index\n                indexesOfLast.remove(list.size() - 1);\n                // add new index\n                indexesOfLast.add(index);\n            }\n            // remove the last one\n            list.remove(list.size() - 1);\n            return true;\n        }\n    }\n    \n    /** Get a random element from the collection. */\n    public int getRandom() {\n        // assume no call when collection is empty\n        return list.get((int)(Math.random() * list.size()));\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 179173,
                "title": "ac-with-c-11-random-function-easy-to-explain-and-impl-in-10mins-cheers",
                "content": "```\\n#include <vector>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <random>\\n\\nusing namespace std;\\n\\nstatic random_device rd;\\nstatic default_random_engine e(rd());\\n\\nclass RandomizedCollection {\\nprivate:\\n    vector<int> buf;\\n    unordered_map<int, unordered_set<int>> pos;\\n\\n    int randomInt(int low, int high) {\\n        return uniform_int_distribution<int>(low, high)(e);\\n    }\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool res = pos.find(val) == pos.end() ? true : false;\\n\\n        buf.push_back(val);\\n        pos[val].insert(buf.size() - 1);\\n\\n        return res;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (pos.find(val) == pos.end()) {\\n            return false;\\n        }\\n\\n        int index = *(pos[val].begin());\\n        pos[val].erase(index);\\n        if (pos[val].empty()) {\\n            pos.erase(val);\\n        }\\n\\n        // [note]: cornor case here, if index is already pointing the last element, do nothing. otherwise there may be RE\\n        int sz = buf.size();\\n        if (index != sz - 1) {\\n            int end = sz - 1;\\n            pos[buf[end]].erase(end);\\n            pos[buf[end]].insert(index);\\n            buf[index] = buf[end];\\n        }\\n        buf.pop_back();\\n\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return buf[randomInt(0, buf.size() - 1)];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.insert(val);\\n * bool param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <random>\\n\\nusing namespace std;\\n\\nstatic random_device rd;\\nstatic default_random_engine e(rd());\\n\\nclass RandomizedCollection {\\nprivate:\\n    vector<int> buf;\\n    unordered_map<int, unordered_set<int>> pos;\\n\\n    int randomInt(int low, int high) {\\n        return uniform_int_distribution<int>(low, high)(e);\\n    }\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool res = pos.find(val) == pos.end() ? true : false;\\n\\n        buf.push_back(val);\\n        pos[val].insert(buf.size() - 1);\\n\\n        return res;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (pos.find(val) == pos.end()) {\\n            return false;\\n        }\\n\\n        int index = *(pos[val].begin());\\n        pos[val].erase(index);\\n        if (pos[val].empty()) {\\n            pos.erase(val);\\n        }\\n\\n        // [note]: cornor case here, if index is already pointing the last element, do nothing. otherwise there may be RE\\n        int sz = buf.size();\\n        if (index != sz - 1) {\\n            int end = sz - 1;\\n            pos[buf[end]].erase(end);\\n            pos[buf[end]].insert(index);\\n            buf[index] = buf[end];\\n        }\\n        buf.pop_back();\\n\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return buf[randomInt(0, buf.size() - 1)];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.insert(val);\\n * bool param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 141075,
                "title": "python-simple-readable-solution-100-ms-beats-98",
                "content": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.arr, self.pos = [], collections.defaultdict(set)\\n    def insert(self, val):\\n        out = val not in self.pos\\n        self.arr.append(val)\\n        self.pos[val].add(len(self.arr) - 1)\\n        return out\\n\\n    def remove(self, val):\\n        if val in self.pos:\\n            if self.arr[-1] != val:\\n                x, y = self.pos[val].pop(), self.arr[-1]\\n                self.pos[y].discard(len(self.arr) - 1)\\n                self.pos[y].add(x)\\n                self.arr[x] = y\\n            else:\\n                self.pos[val].discard(len(self.arr) - 1)\\n            self.arr.pop()\\n            if not self.pos[val]:\\n                self.pos.pop(val)\\n            return True \\n        return False\\n\\n    def getRandom(self):\\n        return random.choice(self.arr)\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.arr, self.pos = [], collections.defaultdict(set)\\n    def insert(self, val):\\n        out = val not in self.pos\\n        self.arr.append(val)\\n        self.pos[val].add(len(self.arr) - 1)\\n        return out\\n\\n    def remove(self, val):\\n        if val in self.pos:\\n            if self.arr[-1] != val:\\n                x, y = self.pos[val].pop(), self.arr[-1]\\n                self.pos[y].discard(len(self.arr) - 1)\\n                self.pos[y].add(x)\\n                self.arr[x] = y\\n            else:\\n                self.pos[val].discard(len(self.arr) - 1)\\n            self.arr.pop()\\n            if not self.pos[val]:\\n                self.pos.pop(val)\\n            return True \\n        return False\\n\\n    def getRandom(self):\\n        return random.choice(self.arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131690,
                "title": "java-map-set-beats-96-69-122ms",
                "content": "```\\nclass RandomizedCollection {\\n     Map<Integer,Set<Integer>> valueToPosition;\\n    List<Integer> nums;\\n    Random rand ;\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        valueToPosition = new HashMap<>();\\n        nums = new ArrayList<>();\\n        rand = new Random();\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        valueToPosition.putIfAbsent(val, new HashSet<>());\\n        valueToPosition.get(val).add(nums.size());\\n        nums.add(val);\\n        return valueToPosition.get(val).size() == 1;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!valueToPosition.containsKey(val)) return false;\\n        \\n        int currentPosition = valueToPosition.get(val).iterator().next();\\n        \\n        //Update \\n        int lastOne = nums.get(nums.size() -1);\\n        nums.set(currentPosition, lastOne);\\n        \\n        //Remove\\n        valueToPosition.get(val).remove(currentPosition);\\n        valueToPosition.get(lastOne).add(currentPosition);\\n        valueToPosition.get(lastOne).remove(nums.size()-1);\\n        \\n        nums.remove(nums.size() -1);\\n        if(valueToPosition.get(val).size()== 0){\\n            valueToPosition.remove(val);\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return nums.get(rand.nextInt(nums.size()));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\n     Map<Integer,Set<Integer>> valueToPosition;\\n    List<Integer> nums;\\n    Random rand ;\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        valueToPosition = new HashMap<>();\\n        nums = new ArrayList<>();\\n        rand = new Random();\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        valueToPosition.putIfAbsent(val, new HashSet<>());\\n        valueToPosition.get(val).add(nums.size());\\n        nums.add(val);\\n        return valueToPosition.get(val).size() == 1;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!valueToPosition.containsKey(val)) return false;\\n        \\n        int currentPosition = valueToPosition.get(val).iterator().next();\\n        \\n        //Update \\n        int lastOne = nums.get(nums.size() -1);\\n        nums.set(currentPosition, lastOne);\\n        \\n        //Remove\\n        valueToPosition.get(val).remove(currentPosition);\\n        valueToPosition.get(lastOne).add(currentPosition);\\n        valueToPosition.get(lastOne).remove(nums.size()-1);\\n        \\n        nums.remove(nums.size() -1);\\n        if(valueToPosition.get(val).size()== 0){\\n            valueToPosition.remove(val);\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return nums.get(rand.nextInt(nums.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85554,
                "title": "c-unordered-map-unordered-set-solution",
                "content": "use hash table to record value and index set; \\nuse unordered_set to perform remove and insert operation in O(1)\\n```\\nclass RandomizedCollection {\\n    vector<int> elem;\\n    unordered_map<int, unordered_set<int>> cache;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool rst = cache[val].empty(); // allow duplicate\\n        cache[val].insert(elem.size());\\n        elem.push_back(val);\\n        return rst;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (cache[val].empty()) return false;\\n        \\n        int idx = *(cache[val].begin()); \\n        cache[val].erase(idx);\\n        \\n        if (idx != elem.size()-1) { // if only 1 element available, then no need to update tail element info\\n            int tval = elem.back();\\n            elem[idx] = tval;\\n            cache[tval].erase(elem.size()-1);\\n            cache[tval].insert(idx);\\n        }\\n        elem.pop_back();\\n\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return elem.empty() ? -1:elem[rand()%elem.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\n    vector<int> elem;\\n    unordered_map<int, unordered_set<int>> cache;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool rst = cache[val].empty(); // allow duplicate\\n        cache[val].insert(elem.size());\\n        elem.push_back(val);\\n        return rst;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (cache[val].empty()) return false;\\n        \\n        int idx = *(cache[val].begin()); \\n        cache[val].erase(idx);\\n        \\n        if (idx != elem.size()-1) { // if only 1 element available, then no need to update tail element info\\n            int tval = elem.back();\\n            elem[idx] = tval;\\n            cache[tval].erase(elem.size()-1);\\n            cache[tval].insert(idx);\\n        }\\n        elem.pop_back();\\n\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return elem.empty() ? -1:elem[rand()%elem.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85575,
                "title": "readable-java-hashmap-arraylist-solution",
                "content": "Basically we reuse the code structure of problem Insert Delete GetRandom O(1). The only change is to extend original HashMap<val,idx> to HashMap<val,<idx1,idx2...>>. While it takes some time for to decide which data structure to be used as the value of HashMap. At first I thought Queue or Stack, but at last I found the problem: it's convenient to remove element from head, but **it cannot remove any index in O(1), which is required when we copy the last element of ArrayList to overwrite deleted one**. Finally, I decided to use HashSet inside the map. Here is my solution for your reference.\\n\\n```java\\n    private Random rand = new Random();\\n    private List<Integer> list = new ArrayList<>();\\n    private Map<Integer,Set<Integer>> bag = new HashMap<>();\\n    \\n    public boolean insert(int val) {\\n        boolean isNew = false;\\n        if (!bag.containsKey(val)) {\\n            bag.put(val, new HashSet<>());\\n            isNew = true;\\n        }\\n        bag.get(val).add(list.size());\\n        list.add(val);\\n        return isNew;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (bag.containsKey(val)) {\\n            int idx = bag.get(val).iterator().next();\\n            bag.get(val).remove(idx);\\n            // Copy last one to deleted position\\n            if (idx < list.size() - 1) {\\n                int lastval = list.get(list.size() - 1);\\n                bag.get(lastval).remove(list.size() - 1);\\n                bag.get(lastval).add(idx);\\n                list.set(idx, lastval);\\n            }\\n            // Delete last one\\n            list.remove(list.size() - 1);\\n            if (bag.get(val).isEmpty()) {\\n                bag.remove(val);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    private Random rand = new Random();\\n    private List<Integer> list = new ArrayList<>();\\n    private Map<Integer,Set<Integer>> bag = new HashMap<>();\\n    \\n    public boolean insert(int val) {\\n        boolean isNew = false;\\n        if (!bag.containsKey(val)) {\\n            bag.put(val, new HashSet<>());\\n            isNew = true;\\n        }\\n        bag.get(val).add(list.size());\\n        list.add(val);\\n        return isNew;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (bag.containsKey(val)) {\\n            int idx = bag.get(val).iterator().next();\\n            bag.get(val).remove(idx);\\n            // Copy last one to deleted position\\n            if (idx < list.size() - 1) {\\n                int lastval = list.get(list.size() - 1);\\n                bag.get(lastval).remove(list.size() - 1);\\n                bag.get(lastval).add(idx);\\n                list.set(idx, lastval);\\n            }\\n            // Delete last one\\n            list.remove(list.size() - 1);\\n            if (bag.get(val).isEmpty()) {\\n                bag.remove(val);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85584,
                "title": "85ms-solution-from-insert-delete-getrandom-o-1-duplicates-not-allowed",
                "content": "the main idea of `Insert Delete GetRandom O(1) - Duplicates not allowed` is to keep the vector continuous\\uff0cusing the hashmap to keep the position of value. when it comes to `Insert Delete GetRandom O(1) - Duplicates allowed`\\uff0cuse the hashmap to keep the position of link list's head\\uff0cwhen remove the value\\uff0cupdate the hashmap and vector to keep vector continuous.\\n```\\nstruct Node {\\n    int val;\\n    int next;\\n\\n    Node() : val(0), next(-1) {};\\n\\n    Node(int v, int n) : val(v), next(n) {};\\n\\n};\\n\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int, int> linkb;\\n    vector<Node> vec;\\n\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        srand(time(nullptr));\\n    }\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ret = linkb.find(val) == linkb.end();\\n        Node t(val, -1);\\n        if (!ret) t.next = linkb[val];\\n        linkb[val] = vec.size();\\n        vec.push_back(t);\\n        return ret;\\n    }\\n\\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (linkb.find(val) == linkb.end()) return false;\\n        int pos = linkb[val];\\n        if (vec[pos].next == -1) linkb.erase(val);\\n        else linkb[val] = vec[pos].next;\\n\\n        int p = vec.size() - 1;\\n        if(p==pos) {\\n            vec.pop_back();\\n            return true;\\n        }\\n        while (vec[p].next != -1 && vec[p].next > pos)\\n            p = vec[p].next;\\n        vec[pos].val = vec.back().val;\\n        vec[pos].next = vec[p].next;\\n        vec[p].next = pos;\\n        linkb[vec.back().val] = vec.back().next;\\n        vec.pop_back();\\n        return true;\\n    }\\n\\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return vec[rand() % vec.size()].val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\n    int val;\\n    int next;\\n\\n    Node() : val(0), next(-1) {};\\n\\n    Node(int v, int n) : val(v), next(n) {};\\n\\n};\\n\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int, int> linkb;\\n    vector<Node> vec;\\n\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        srand(time(nullptr));\\n    }\\n\\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ret = linkb.find(val) == linkb.end();\\n        Node t(val, -1);\\n        if (!ret) t.next = linkb[val];\\n        linkb[val] = vec.size();\\n        vec.push_back(t);\\n        return ret;\\n    }\\n\\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        if (linkb.find(val) == linkb.end()) return false;\\n        int pos = linkb[val];\\n        if (vec[pos].next == -1) linkb.erase(val);\\n        else linkb[val] = vec[pos].next;\\n\\n        int p = vec.size() - 1;\\n        if(p==pos) {\\n            vec.pop_back();\\n            return true;\\n        }\\n        while (vec[p].next != -1 && vec[p].next > pos)\\n            p = vec[p].next;\\n        vec[pos].val = vec.back().val;\\n        vec[pos].next = vec[p].next;\\n        vec[p].next = pos;\\n        linkb[vec.back().val] = vec.back().next;\\n        vec.pop_back();\\n        return true;\\n    }\\n\\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        return vec[rand() % vec.size()].val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85602,
                "title": "solve-this-problem-by-implementing-open-addressing-hash-table",
                "content": "```\\n#include <vector>\\n#include <iterator>\\n#include <functional>\\n#include <random>\\n#include <chrono>\\n#include <numeric>\\n#include <algorithm>\\n#include <limits>\\n#include <cmath>\\n#include <sstream>\\n#include <unordered_set>\\n#include <iostream>\\n\\n#ifdef RUN_TEST\\n#   include \"catch.hpp\"\\n#   include \"stringify.h\"\\n#   define private public\\n#else\\n#   define NDEBUG   // remove assert() call\\n#endif\\n#include <cassert>\\n\\n\\n// https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/\\n\\n\\nusing namespace std;\\n\\n\\ntemplate<class ElemType, class FlagsType = vector<bool>>\\nclass HashMultiSetOpenAddress {\\n\\nprivate:\\n    vector<ElemType> values;\\n    FlagsType flags;\\n    size_t _count;\\n    double _max_load_factor;\\n    hash<ElemType> _hash_fn;\\n\\n    /**\\n     * @brief _insert\\n     * @param ctn\\n     * @param val\\n     * @return Return true if \\\\a ctn did not already contain \\\\a val\\n     */\\n    bool _insert(vector<ElemType> &ctn, FlagsType &flags, const ElemType &val) {\\n        bool found = false;\\n\\n        size_t h = this->_hash_fn(val);\\n        h %= ctn.size();\\n        while (flags[h]) {\\n            if (ctn[h] == val) {\\n                found = true;\\n            }\\n            h++;\\n            h %= ctn.size();\\n        }\\n\\n        ctn[h] = val;\\n        flags[h] = true;\\n        return !found;\\n    }\\n\\n    size_t _next_capacity(int prev) {\\n        assert(prev >= 0);\\n        if (prev == 0) {\\n            return 1;\\n        } else if (prev == 1) {\\n            return 4;\\n        } else {\\n            return prev * 2;\\n        }\\n    }\\n\\npublic:\\n    class iterator : public std::iterator<forward_iterator_tag, ElemType> {\\n\\n    private:\\n        const HashMultiSetOpenAddress &rc;\\n        size_t index;\\n\\n    public:\\n        iterator(const HashMultiSetOpenAddress &rc, size_t index)\\n            : rc(rc), index(index)\\n        {}\\n\\n        // Pre-increment\\n        iterator &operator++ () {\\n            assert(this->index < this->rc.capacity() && \"WTF\");\\n\\n            this->index++;\\n            while (this->index < this->rc.capacity() && !this->rc.flags[this->index]) {\\n                this->index++;\\n            }\\n\\n            if (this->index == this->rc.capacity()) {\\n                // end()\\n                this->index = numeric_limits<size_t>::max();\\n            }\\n\\n            return *this;\\n        }\\n\\n        // Post-increment\\n        iterator operator++ (int) {\\n            iterator tmp(*this);\\n            ++(*this);\\n            return tmp;\\n        }\\n\\n        // two-way comparison: v.begin() == v.cbegin() and vice versa\\n        bool operator == (const iterator &rhs) const {\\n            assert(&this->rc == &rhs.rc);\\n            return this->index == rhs.index;\\n        }\\n\\n        bool operator != (const iterator &rhs) const {\\n            return !(*this == rhs);\\n        }\\n\\n        const ElemType &operator *() const {\\n            assert(this->index < this->rc.capacity());\\n            assert(this->rc.flags[this->index]);\\n            return this->rc.values[this->index];\\n        }\\n\\n        const ElemType *operator->() const {\\n            return &this->operator *();\\n        }\\n\\n        friend ostream &operator << ( ostream &os, const iterator &it ) {\\n            os << \"<Iterator for \" << std::hex << &it.rc << \" index=\" << it.index << \">\";\\n            return os;\\n        }\\n    };\\n\\n    /** Initialize your data structure here. */\\n    HashMultiSetOpenAddress()\\n        : values(), flags(), _count(0), _max_load_factor(0.6)\\n    {}\\n\\n    size_t size() const {\\n        return this->_count;\\n    }\\n\\n    size_t capacity() const {\\n        return this->values.size();\\n    }\\n\\n    double load_factor() const {\\n        if (this->capacity() == 0) {\\n            assert(this->size() == 0);\\n            return 0;\\n        } else {\\n            return (double)this->size() / this->capacity();\\n        }\\n    }\\n\\n    double max_load_factor() const {\\n        return this->_max_load_factor;\\n    }\\n\\n    void max_load_factor(double val) {\\n        assert(val < 1.0);\\n        this->_max_load_factor = val;\\n    }\\n\\n    iterator begin() const {\\n        if (this->size() == 0) {\\n            return this->end();\\n        }\\n\\n        iterator it(*this, 0);\\n        if (this->flags[0]) {\\n            return it;\\n        } else {\\n            ++it;\\n            return it;\\n        }\\n    }\\n\\n    iterator end() const {\\n        return iterator(*this, numeric_limits<size_t>::max());\\n    }\\n\\n    /** Inserts a value to the collection.\\n     *\\n     * Returns true if the collection did not already contain the specified element.\\n     */\\n    bool insert(const ElemType &val) {\\n        // rehash\\n        if (this->capacity() == 0 || this->load_factor() > this->max_load_factor()) {\\n            this->rehash(this->_next_capacity(this->capacity()));\\n        }\\n        assert(this->load_factor() < this->max_load_factor());\\n\\n        this->_count++;\\n        return this->_insert(this->values, this->flags, val);\\n    }\\n\\n    void rehash(size_t new_cap) {\\n        assert(new_cap > this->size() / this->max_load_factor());\\n        vector<ElemType> new_ctn(new_cap);\\n        FlagsType new_flags(new_cap);\\n\\n        for (int i = 0; i < this->capacity(); i++) {\\n            if (this->flags[i]) {\\n                this->_insert(new_ctn, new_flags, this->values[i]);\\n            }\\n        }\\n\\n        swap(this->values, new_ctn);\\n        swap(this->flags, new_flags);\\n    }\\n\\n    /** Removes a value from the collection.\\n     *\\n     * Returns true if the collection contained the specified element.\\n     */\\n    bool remove(const ElemType &val) {\\n        if (this->size() == 0) {    // capacity may be zero\\n            return false;\\n        }\\n\\n        bool found = false;\\n        size_t last_found;\\n\\n        int count = 0;\\n        size_t h = this->_hash_fn(val);\\n        h %= this->capacity();\\n        while (this->flags[h] && count < this->capacity()) {\\n            if (this->values[h] == val) {\\n                last_found = h;\\n                found = true;\\n            }\\n\\n            h++;\\n            h %= this->capacity();\\n\\n            count++;\\n        }\\n\\n        if (!found) {\\n            return false;\\n        } else {\\n            // remove element\\n            this->values[last_found] = ElemType();  // replace old element with default one\\n            this->flags[last_found] = false;\\n\\n            // rehash next element\\n            int count = 0;\\n            for (h = (last_found + 1) % this->capacity();\\n                 this->flags[h] && count < this->capacity();\\n                 h = (h + 1) % this->capacity())\\n            {\\n                if (this->_hash_fn(this->values[h]) % this->capacity() != h) {\\n                    this->flags[h] = false;\\n                    this->_insert(this->values, this->flags, this->values[h]);\\n                }\\n                count++;\\n            }\\n\\n            this->_count--;\\n            return true;\\n        }\\n    }\\n\\n    /** Get a random element from the collection. */\\n    const ElemType &getRandom() const {\\n        assert(this->size() > 0);   // capacity must not be zero\\n        random_device rd;\\n        uniform_int_distribution<int> dis(0, this->capacity() - 1);\\n\\n        for (int i = dis(rd); ; i = dis(rd)) {\\n            if (this->flags[i]) {\\n                return this->values[i];\\n            }\\n        }\\n        assert(false);\\n    }\\n\\n    iterator find(const ElemType &val) const {\\n        int count = 0;\\n        size_t h = this->_hash_fn(val) % this->capacity();\\n        while (count < this->capacity() && this->flags[h]) {\\n            if (this->values[h] == val) {\\n                return iterator(*this, h);\\n            }\\n\\n            h++;\\n            h %= this->capacity();\\n            count++;\\n        }\\n\\n        return this->end();\\n    }\\n\\n#ifdef RUN_TEST\\n    unordered_multiset<ElemType> to_multiset() const {\\n        unordered_multiset<ElemType> ans(this->begin(), this->end());\\n        return ans;\\n    }\\n\\n    vector<pair<ElemType, bool>> dump() const {\\n        vector<pair<ElemType, bool>> ans;\\n        for (int i = 0; i < this->capacity(); i++) {\\n            ans.push_back({ this->values[i], this->flags[i] });\\n        }\\n\\n        return ans;\\n    }\\n#endif\\n};\\n\\ntypedef HashMultiSetOpenAddress<int> RandomizedCollection;\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.insert(val);\\n * bool param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n\\n\\n#ifdef RUN_TEST\\nTEST_CASE(\"Test on types other than int\") {\\n    HashMultiSetOpenAddress<string> mset;\\n    mset.insert(\"asdf\");\\n    mset.insert(\"343\");\\n    mset.insert(\"asdf\");\\n    mset.insert(\"fda\");\\n    mset.remove(\"asdf\");\\n\\n    unordered_multiset<string> expected = {\\n        \"asdf\", \"343\", \"fda\"\\n    };\\n    CHECK(mset.to_multiset() == expected);\\n}\\n\\nTEST_CASE(\"Test insert/remove/find/iterator\") {\\n    RandomizedCollection rc;\\n    CHECK(rc.capacity() == 0);\\n    CHECK(rc.size() == 0);\\n    CHECK(rc.begin() == rc.end());\\n    unordered_multiset<int> expected = {};\\n    CHECK(rc.to_multiset() == expected);\\n\\n    CHECK(rc.insert(1));\\n    CHECK(rc.capacity() >= 1);\\n    CHECK(rc.size() == 1);\\n    CHECK(rc.begin() != rc.end());\\n    CHECK(++rc.begin() == rc.end());\\n    CHECK(*rc.begin() == 1);\\n    CHECK(rc.find(0) == rc.end());\\n    CHECK(*rc.find(1) == 1);\\n\\n    // test iterator copy & assign\\n    auto it = rc.begin();\\n    auto it_copy = RandomizedCollection::iterator(it);\\n    CHECK(it == it_copy);\\n    auto it_copy_assign = it;\\n    CHECK(it == it_copy_assign);\\n\\n    CHECK(rc.insert(2));\\n    CHECK(rc.capacity() >= 2);\\n    CHECK(rc.size() == 2);\\n    CHECK(rc.begin() != rc.end());\\n    CHECK(++rc.begin() != rc.end());\\n    CHECK(++++rc.begin() == rc.end());\\n    expected = { 1, 2 };\\n    CHECK(rc.to_multiset() == expected);\\n\\n    CHECK_FALSE(rc.insert(1));\\n    CHECK(rc.capacity() >= 3);\\n    CHECK(rc.size() == 3);\\n    expected = { 1, 1, 2 };\\n    CHECK(rc.to_multiset() == expected);\\n\\n    CHECK(rc.insert(3));\\n    CHECK(rc.insert(4));\\n    CHECK(rc.size() == 5);\\n    expected = { 1, 1, 2, 3, 4 };\\n    CHECK(rc.to_multiset() == expected);\\n\\n    // test find\\n    CHECK(rc.find(1) != rc.end());\\n    CHECK(*rc.find(1) == 1);\\n    CHECK(*rc.find(2) == 2);\\n    CHECK(rc.find(5) == rc.end());\\n\\n    // test removal\\n    CHECK_FALSE(rc.remove(5));\\n    CHECK(rc.size() == 5);\\n\\n    CHECK(rc.remove(3));\\n    CHECK(rc.size() == 4);\\n    expected = { 1, 1, 2, 4 };\\n    CHECK(rc.to_multiset() == expected);\\n\\n    CHECK(rc.remove(1));\\n    expected = { 1, 2, 4 };\\n    CHECK(rc.to_multiset() == expected);\\n}\\n\\nTEST_CASE(\"Random test insert/remove\") {\\n    uniform_int_distribution<int> elem_gen(0, 9);\\n    discrete_distribution<int> action_gen({ 2, 1 });\\n    random_device rd;\\n\\n    for (int round = 0; round < 1000; round++) {\\n        const int N = 100;\\n        RandomizedCollection rc;\\n        unordered_multiset<int> expected;\\n\\n        for (int i = 0; i < N; i++) {\\n            int el = elem_gen(rd);\\n            int action = action_gen(rd);\\n\\n            if (action == 0) {\\n                bool has = !rc.insert(el);\\n                CHECK((expected.count(el) > 0) == has);\\n                expected.insert(el);\\n            } else {\\n                bool has = rc.remove(el);\\n                CHECK((expected.count(el) > 0) == has);\\n\\n                if (has) {\\n                    expected.erase(expected.find(el));\\n                }\\n            }\\n        }\\n\\n        CAPTURE(round);\\n        CHECK(rc.to_multiset() == expected);\\n    }\\n}\\n\\ntemplate<class ElemType>\\ndouble length(const vector<ElemType> &v) {\\n    return sqrt(accumulate(v.begin(), v.end(), 0.0, [](const ElemType &sum, const ElemType &d) {\\n        return sum + d * d;\\n    }));\\n}\\n\\ntemplate<class ElemType1, class ElemType2, class ResultType = decltype(ElemType1() - ElemType2())>\\ndouble distance(const vector<ElemType1> &v1, const vector<ElemType2> &v2) {\\n    assert(v1.size() == v2.size());\\n    vector<ResultType> sub;\\n    for (int i = 0; i < v1.size(); i++) {\\n        sub.push_back(v1[i] - v2[i]);\\n    }\\n    return length(sub);\\n}\\n\\ntemplate<class ElemType, class ResultType = decltype(ElemType() / double(1))>\\nvector<ResultType> normalized(const vector<ElemType> &v1) {\\n    vector<ResultType> ans;\\n    double len = length(v1);\\n    for (ElemType d : v1) {\\n        ans.push_back(d / len);\\n    }\\n    assert(length(ans) == Approx(1.0));\\n    return ans;\\n}\\n\\nTEST_CASE(\"Test getRandom() distribution\") {\\n    auto test_dist = [](\\n        const vector<int> &freqs,\\n        int insert_round = 100,\\n        int test_round = 10000)\\n    {\\n        RandomizedCollection rc;\\n\\n        for (int round = 0; round < insert_round; round++) {\\n            for (int i = 0; i < freqs.size(); i++) {\\n                for (int j = 0; j < freqs[i]; j++) {\\n                    rc.insert(i);\\n                }\\n            }\\n        }\\n\\n        vector<double> stats(freqs.size());\\n        for (int i = 0; i < test_round; i++) {\\n            stats[rc.getRandom()] += 1.0;\\n        }\\n        for (double &d : stats) {\\n            d /= test_round;\\n        }\\n        return stats;\\n    };\\n\\n    auto test = [&](\\n        const vector<int> &freqs,\\n        int insert_round = 100,\\n        int test_round = 10000)\\n    {\\n        vector<double> stats = test_dist(freqs);\\n        CAPTURE(stats);\\n        CHECK(distance(normalized(stats), normalized(freqs)) < 0.04);\\n    };\\n\\n    test({ 1 }, 1);\\n    test({ 1, 1 });\\n    test({ 1, 2 });\\n    test({ 2, 1 }, 1);\\n    test({ 2, 1, 2, 1, 2, 1, 0, 5 });\\n}\\n\\nTEST_CASE(\"Performance test\") {\\n    uniform_int_distribution<int> elem_gen(0, numeric_limits<int>::max());\\n    random_device rd;\\n\\n    const int INSERT_N = 1000000;\\n    vector<int> to_insert;\\n    for (int i = 0; i < INSERT_N; i++) {\\n        to_insert.push_back(elem_gen(rd));\\n    }\\n\\n    const int REMOVE_N = 100000;\\n    vector<int> to_remove_non_exist;\\n    uniform_int_distribution<int> rm_gen(numeric_limits<int>::min(), -1);\\n    for (int i = 0; i < REMOVE_N; i++) {\\n        to_remove_non_exist.push_back(rm_gen(rd));\\n    }\\n\\n    uniform_int_distribution<int> pos_gen(0, INSERT_N - 1);\\n    vector<int> to_remove_exist(to_insert.begin(), to_insert.begin() + REMOVE_N);\\n    random_shuffle(to_insert.begin(), to_insert.end());\\n\\n    vector<int> to_lookup_non_exist(to_remove_non_exist);\\n\\n    // stl insert\\n    unordered_multiset<int> stl;\\n    auto start = chrono::steady_clock::now();\\n    for (int i : to_insert) {\\n        stl.insert(i);\\n    }\\n    auto end = chrono::steady_clock::now();\\n    chrono::duration<double> diff = end - start;\\n    INFO(\"STL insert \" << INSERT_N << \" ints, cost \" << diff.count() << \"s.\");\\n\\n    // HashMultiSetOpenAddress insert\\n    HashMultiSetOpenAddress<int> msoa;\\n    start = chrono::steady_clock::now();\\n    for (int i : to_insert) {\\n        msoa.insert(i);\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"XXX insert \" << INSERT_N << \" ints, cost \" << diff.count() << \"s.\");\\n\\n    CHECK(true);\\n\\n    // stl lookup\\n    int count_found = 0;\\n    start = chrono::steady_clock::now();\\n    for (int i : to_insert) {\\n        count_found += (stl.find(i) != stl.end());\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"STL lookup \" << INSERT_N << \" ints, cost \" << diff.count() << \"s.\");\\n    CHECK(count_found == INSERT_N);\\n\\n    // HashMultiSetOpenAddress lookup\\n    count_found = 0;\\n    start = chrono::steady_clock::now();\\n    for (int i : to_insert) {\\n        count_found += (msoa.find(i) != msoa.end());\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"XXX lookup \" << INSERT_N << \" ints, cost \" << diff.count() << \"s.\");\\n    CHECK(count_found == INSERT_N);\\n\\n    // stl lookup non-exist\\n    count_found = 0;\\n    start = chrono::steady_clock::now();\\n    for (int i : to_lookup_non_exist) {\\n        count_found += (stl.find(i) != stl.end());\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"STL lookup \" << INSERT_N << \" non-exist ints, cost \" << diff.count() << \"s.\");\\n    CHECK(count_found == 0);\\n\\n    // HashMultiSetOpenAddress lookup non-exist\\n    count_found = 0;\\n    start = chrono::steady_clock::now();\\n    for (int i : to_lookup_non_exist) {\\n        count_found += (msoa.find(i) != msoa.end());\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"XXX lookup \" << INSERT_N << \" non-exist ints, cost \" << diff.count() << \"s.\");\\n    CHECK(count_found == 0);\\n\\n    // stl remove\\n    start = chrono::steady_clock::now();\\n    for (int i : to_remove_exist) {\\n        stl.erase(stl.find(i));\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"STL remove \" << REMOVE_N << \" ints, cost \" << diff.count() << \"s.\");\\n\\n    // HashMultiSetOpenAddress remove\\n    int remove_count = 0;\\n    start = chrono::steady_clock::now();\\n    for (int i : to_remove_exist) {\\n        remove_count += !!msoa.remove(i);\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"XXX remove \" << REMOVE_N << \" ints, cost \" << diff.count() << \"s.\");\\n    CHECK(remove_count == REMOVE_N);\\n}\\n\\nTEST_CASE(\"381. Insert Delete GetRandom O(1) - Duplicates allowed\") {\\n    // dummy\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <iterator>\\n#include <functional>\\n#include <random>\\n#include <chrono>\\n#include <numeric>\\n#include <algorithm>\\n#include <limits>\\n#include <cmath>\\n#include <sstream>\\n#include <unordered_set>\\n#include <iostream>\\n\\n#ifdef RUN_TEST\\n#   include \"catch.hpp\"\\n#   include \"stringify.h\"\\n#   define private public\\n#else\\n#   define NDEBUG   // remove assert() call\\n#endif\\n#include <cassert>\\n\\n\\n// https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/\\n\\n\\nusing namespace std;\\n\\n\\ntemplate<class ElemType, class FlagsType = vector<bool>>\\nclass HashMultiSetOpenAddress {\\n\\nprivate:\\n    vector<ElemType> values;\\n    FlagsType flags;\\n    size_t _count;\\n    double _max_load_factor;\\n    hash<ElemType> _hash_fn;\\n\\n    /**\\n     * @brief _insert\\n     * @param ctn\\n     * @param val\\n     * @return Return true if \\\\a ctn did not already contain \\\\a val\\n     */\\n    bool _insert(vector<ElemType> &ctn, FlagsType &flags, const ElemType &val) {\\n        bool found = false;\\n\\n        size_t h = this->_hash_fn(val);\\n        h %= ctn.size();\\n        while (flags[h]) {\\n            if (ctn[h] == val) {\\n                found = true;\\n            }\\n            h++;\\n            h %= ctn.size();\\n        }\\n\\n        ctn[h] = val;\\n        flags[h] = true;\\n        return !found;\\n    }\\n\\n    size_t _next_capacity(int prev) {\\n        assert(prev >= 0);\\n        if (prev == 0) {\\n            return 1;\\n        } else if (prev == 1) {\\n            return 4;\\n        } else {\\n            return prev * 2;\\n        }\\n    }\\n\\npublic:\\n    class iterator : public std::iterator<forward_iterator_tag, ElemType> {\\n\\n    private:\\n        const HashMultiSetOpenAddress &rc;\\n        size_t index;\\n\\n    public:\\n        iterator(const HashMultiSetOpenAddress &rc, size_t index)\\n            : rc(rc), index(index)\\n        {}\\n\\n        // Pre-increment\\n        iterator &operator++ () {\\n            assert(this->index < this->rc.capacity() && \"WTF\");\\n\\n            this->index++;\\n            while (this->index < this->rc.capacity() && !this->rc.flags[this->index]) {\\n                this->index++;\\n            }\\n\\n            if (this->index == this->rc.capacity()) {\\n                // end()\\n                this->index = numeric_limits<size_t>::max();\\n            }\\n\\n            return *this;\\n        }\\n\\n        // Post-increment\\n        iterator operator++ (int) {\\n            iterator tmp(*this);\\n            ++(*this);\\n            return tmp;\\n        }\\n\\n        // two-way comparison: v.begin() == v.cbegin() and vice versa\\n        bool operator == (const iterator &rhs) const {\\n            assert(&this->rc == &rhs.rc);\\n            return this->index == rhs.index;\\n        }\\n\\n        bool operator != (const iterator &rhs) const {\\n            return !(*this == rhs);\\n        }\\n\\n        const ElemType &operator *() const {\\n            assert(this->index < this->rc.capacity());\\n            assert(this->rc.flags[this->index]);\\n            return this->rc.values[this->index];\\n        }\\n\\n        const ElemType *operator->() const {\\n            return &this->operator *();\\n        }\\n\\n        friend ostream &operator << ( ostream &os, const iterator &it ) {\\n            os << \"<Iterator for \" << std::hex << &it.rc << \" index=\" << it.index << \">\";\\n            return os;\\n        }\\n    };\\n\\n    /** Initialize your data structure here. */\\n    HashMultiSetOpenAddress()\\n        : values(), flags(), _count(0), _max_load_factor(0.6)\\n    {}\\n\\n    size_t size() const {\\n        return this->_count;\\n    }\\n\\n    size_t capacity() const {\\n        return this->values.size();\\n    }\\n\\n    double load_factor() const {\\n        if (this->capacity() == 0) {\\n            assert(this->size() == 0);\\n            return 0;\\n        } else {\\n            return (double)this->size() / this->capacity();\\n        }\\n    }\\n\\n    double max_load_factor() const {\\n        return this->_max_load_factor;\\n    }\\n\\n    void max_load_factor(double val) {\\n        assert(val < 1.0);\\n        this->_max_load_factor = val;\\n    }\\n\\n    iterator begin() const {\\n        if (this->size() == 0) {\\n            return this->end();\\n        }\\n\\n        iterator it(*this, 0);\\n        if (this->flags[0]) {\\n            return it;\\n        } else {\\n            ++it;\\n            return it;\\n        }\\n    }\\n\\n    iterator end() const {\\n        return iterator(*this, numeric_limits<size_t>::max());\\n    }\\n\\n    /** Inserts a value to the collection.\\n     *\\n     * Returns true if the collection did not already contain the specified element.\\n     */\\n    bool insert(const ElemType &val) {\\n        // rehash\\n        if (this->capacity() == 0 || this->load_factor() > this->max_load_factor()) {\\n            this->rehash(this->_next_capacity(this->capacity()));\\n        }\\n        assert(this->load_factor() < this->max_load_factor());\\n\\n        this->_count++;\\n        return this->_insert(this->values, this->flags, val);\\n    }\\n\\n    void rehash(size_t new_cap) {\\n        assert(new_cap > this->size() / this->max_load_factor());\\n        vector<ElemType> new_ctn(new_cap);\\n        FlagsType new_flags(new_cap);\\n\\n        for (int i = 0; i < this->capacity(); i++) {\\n            if (this->flags[i]) {\\n                this->_insert(new_ctn, new_flags, this->values[i]);\\n            }\\n        }\\n\\n        swap(this->values, new_ctn);\\n        swap(this->flags, new_flags);\\n    }\\n\\n    /** Removes a value from the collection.\\n     *\\n     * Returns true if the collection contained the specified element.\\n     */\\n    bool remove(const ElemType &val) {\\n        if (this->size() == 0) {    // capacity may be zero\\n            return false;\\n        }\\n\\n        bool found = false;\\n        size_t last_found;\\n\\n        int count = 0;\\n        size_t h = this->_hash_fn(val);\\n        h %= this->capacity();\\n        while (this->flags[h] && count < this->capacity()) {\\n            if (this->values[h] == val) {\\n                last_found = h;\\n                found = true;\\n            }\\n\\n            h++;\\n            h %= this->capacity();\\n\\n            count++;\\n        }\\n\\n        if (!found) {\\n            return false;\\n        } else {\\n            // remove element\\n            this->values[last_found] = ElemType();  // replace old element with default one\\n            this->flags[last_found] = false;\\n\\n            // rehash next element\\n            int count = 0;\\n            for (h = (last_found + 1) % this->capacity();\\n                 this->flags[h] && count < this->capacity();\\n                 h = (h + 1) % this->capacity())\\n            {\\n                if (this->_hash_fn(this->values[h]) % this->capacity() != h) {\\n                    this->flags[h] = false;\\n                    this->_insert(this->values, this->flags, this->values[h]);\\n                }\\n                count++;\\n            }\\n\\n            this->_count--;\\n            return true;\\n        }\\n    }\\n\\n    /** Get a random element from the collection. */\\n    const ElemType &getRandom() const {\\n        assert(this->size() > 0);   // capacity must not be zero\\n        random_device rd;\\n        uniform_int_distribution<int> dis(0, this->capacity() - 1);\\n\\n        for (int i = dis(rd); ; i = dis(rd)) {\\n            if (this->flags[i]) {\\n                return this->values[i];\\n            }\\n        }\\n        assert(false);\\n    }\\n\\n    iterator find(const ElemType &val) const {\\n        int count = 0;\\n        size_t h = this->_hash_fn(val) % this->capacity();\\n        while (count < this->capacity() && this->flags[h]) {\\n            if (this->values[h] == val) {\\n                return iterator(*this, h);\\n            }\\n\\n            h++;\\n            h %= this->capacity();\\n            count++;\\n        }\\n\\n        return this->end();\\n    }\\n\\n#ifdef RUN_TEST\\n    unordered_multiset<ElemType> to_multiset() const {\\n        unordered_multiset<ElemType> ans(this->begin(), this->end());\\n        return ans;\\n    }\\n\\n    vector<pair<ElemType, bool>> dump() const {\\n        vector<pair<ElemType, bool>> ans;\\n        for (int i = 0; i < this->capacity(); i++) {\\n            ans.push_back({ this->values[i], this->flags[i] });\\n        }\\n\\n        return ans;\\n    }\\n#endif\\n};\\n\\ntypedef HashMultiSetOpenAddress<int> RandomizedCollection;\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.insert(val);\\n * bool param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n\\n\\n#ifdef RUN_TEST\\nTEST_CASE(\"Test on types other than int\") {\\n    HashMultiSetOpenAddress<string> mset;\\n    mset.insert(\"asdf\");\\n    mset.insert(\"343\");\\n    mset.insert(\"asdf\");\\n    mset.insert(\"fda\");\\n    mset.remove(\"asdf\");\\n\\n    unordered_multiset<string> expected = {\\n        \"asdf\", \"343\", \"fda\"\\n    };\\n    CHECK(mset.to_multiset() == expected);\\n}\\n\\nTEST_CASE(\"Test insert/remove/find/iterator\") {\\n    RandomizedCollection rc;\\n    CHECK(rc.capacity() == 0);\\n    CHECK(rc.size() == 0);\\n    CHECK(rc.begin() == rc.end());\\n    unordered_multiset<int> expected = {};\\n    CHECK(rc.to_multiset() == expected);\\n\\n    CHECK(rc.insert(1));\\n    CHECK(rc.capacity() >= 1);\\n    CHECK(rc.size() == 1);\\n    CHECK(rc.begin() != rc.end());\\n    CHECK(++rc.begin() == rc.end());\\n    CHECK(*rc.begin() == 1);\\n    CHECK(rc.find(0) == rc.end());\\n    CHECK(*rc.find(1) == 1);\\n\\n    // test iterator copy & assign\\n    auto it = rc.begin();\\n    auto it_copy = RandomizedCollection::iterator(it);\\n    CHECK(it == it_copy);\\n    auto it_copy_assign = it;\\n    CHECK(it == it_copy_assign);\\n\\n    CHECK(rc.insert(2));\\n    CHECK(rc.capacity() >= 2);\\n    CHECK(rc.size() == 2);\\n    CHECK(rc.begin() != rc.end());\\n    CHECK(++rc.begin() != rc.end());\\n    CHECK(++++rc.begin() == rc.end());\\n    expected = { 1, 2 };\\n    CHECK(rc.to_multiset() == expected);\\n\\n    CHECK_FALSE(rc.insert(1));\\n    CHECK(rc.capacity() >= 3);\\n    CHECK(rc.size() == 3);\\n    expected = { 1, 1, 2 };\\n    CHECK(rc.to_multiset() == expected);\\n\\n    CHECK(rc.insert(3));\\n    CHECK(rc.insert(4));\\n    CHECK(rc.size() == 5);\\n    expected = { 1, 1, 2, 3, 4 };\\n    CHECK(rc.to_multiset() == expected);\\n\\n    // test find\\n    CHECK(rc.find(1) != rc.end());\\n    CHECK(*rc.find(1) == 1);\\n    CHECK(*rc.find(2) == 2);\\n    CHECK(rc.find(5) == rc.end());\\n\\n    // test removal\\n    CHECK_FALSE(rc.remove(5));\\n    CHECK(rc.size() == 5);\\n\\n    CHECK(rc.remove(3));\\n    CHECK(rc.size() == 4);\\n    expected = { 1, 1, 2, 4 };\\n    CHECK(rc.to_multiset() == expected);\\n\\n    CHECK(rc.remove(1));\\n    expected = { 1, 2, 4 };\\n    CHECK(rc.to_multiset() == expected);\\n}\\n\\nTEST_CASE(\"Random test insert/remove\") {\\n    uniform_int_distribution<int> elem_gen(0, 9);\\n    discrete_distribution<int> action_gen({ 2, 1 });\\n    random_device rd;\\n\\n    for (int round = 0; round < 1000; round++) {\\n        const int N = 100;\\n        RandomizedCollection rc;\\n        unordered_multiset<int> expected;\\n\\n        for (int i = 0; i < N; i++) {\\n            int el = elem_gen(rd);\\n            int action = action_gen(rd);\\n\\n            if (action == 0) {\\n                bool has = !rc.insert(el);\\n                CHECK((expected.count(el) > 0) == has);\\n                expected.insert(el);\\n            } else {\\n                bool has = rc.remove(el);\\n                CHECK((expected.count(el) > 0) == has);\\n\\n                if (has) {\\n                    expected.erase(expected.find(el));\\n                }\\n            }\\n        }\\n\\n        CAPTURE(round);\\n        CHECK(rc.to_multiset() == expected);\\n    }\\n}\\n\\ntemplate<class ElemType>\\ndouble length(const vector<ElemType> &v) {\\n    return sqrt(accumulate(v.begin(), v.end(), 0.0, [](const ElemType &sum, const ElemType &d) {\\n        return sum + d * d;\\n    }));\\n}\\n\\ntemplate<class ElemType1, class ElemType2, class ResultType = decltype(ElemType1() - ElemType2())>\\ndouble distance(const vector<ElemType1> &v1, const vector<ElemType2> &v2) {\\n    assert(v1.size() == v2.size());\\n    vector<ResultType> sub;\\n    for (int i = 0; i < v1.size(); i++) {\\n        sub.push_back(v1[i] - v2[i]);\\n    }\\n    return length(sub);\\n}\\n\\ntemplate<class ElemType, class ResultType = decltype(ElemType() / double(1))>\\nvector<ResultType> normalized(const vector<ElemType> &v1) {\\n    vector<ResultType> ans;\\n    double len = length(v1);\\n    for (ElemType d : v1) {\\n        ans.push_back(d / len);\\n    }\\n    assert(length(ans) == Approx(1.0));\\n    return ans;\\n}\\n\\nTEST_CASE(\"Test getRandom() distribution\") {\\n    auto test_dist = [](\\n        const vector<int> &freqs,\\n        int insert_round = 100,\\n        int test_round = 10000)\\n    {\\n        RandomizedCollection rc;\\n\\n        for (int round = 0; round < insert_round; round++) {\\n            for (int i = 0; i < freqs.size(); i++) {\\n                for (int j = 0; j < freqs[i]; j++) {\\n                    rc.insert(i);\\n                }\\n            }\\n        }\\n\\n        vector<double> stats(freqs.size());\\n        for (int i = 0; i < test_round; i++) {\\n            stats[rc.getRandom()] += 1.0;\\n        }\\n        for (double &d : stats) {\\n            d /= test_round;\\n        }\\n        return stats;\\n    };\\n\\n    auto test = [&](\\n        const vector<int> &freqs,\\n        int insert_round = 100,\\n        int test_round = 10000)\\n    {\\n        vector<double> stats = test_dist(freqs);\\n        CAPTURE(stats);\\n        CHECK(distance(normalized(stats), normalized(freqs)) < 0.04);\\n    };\\n\\n    test({ 1 }, 1);\\n    test({ 1, 1 });\\n    test({ 1, 2 });\\n    test({ 2, 1 }, 1);\\n    test({ 2, 1, 2, 1, 2, 1, 0, 5 });\\n}\\n\\nTEST_CASE(\"Performance test\") {\\n    uniform_int_distribution<int> elem_gen(0, numeric_limits<int>::max());\\n    random_device rd;\\n\\n    const int INSERT_N = 1000000;\\n    vector<int> to_insert;\\n    for (int i = 0; i < INSERT_N; i++) {\\n        to_insert.push_back(elem_gen(rd));\\n    }\\n\\n    const int REMOVE_N = 100000;\\n    vector<int> to_remove_non_exist;\\n    uniform_int_distribution<int> rm_gen(numeric_limits<int>::min(), -1);\\n    for (int i = 0; i < REMOVE_N; i++) {\\n        to_remove_non_exist.push_back(rm_gen(rd));\\n    }\\n\\n    uniform_int_distribution<int> pos_gen(0, INSERT_N - 1);\\n    vector<int> to_remove_exist(to_insert.begin(), to_insert.begin() + REMOVE_N);\\n    random_shuffle(to_insert.begin(), to_insert.end());\\n\\n    vector<int> to_lookup_non_exist(to_remove_non_exist);\\n\\n    // stl insert\\n    unordered_multiset<int> stl;\\n    auto start = chrono::steady_clock::now();\\n    for (int i : to_insert) {\\n        stl.insert(i);\\n    }\\n    auto end = chrono::steady_clock::now();\\n    chrono::duration<double> diff = end - start;\\n    INFO(\"STL insert \" << INSERT_N << \" ints, cost \" << diff.count() << \"s.\");\\n\\n    // HashMultiSetOpenAddress insert\\n    HashMultiSetOpenAddress<int> msoa;\\n    start = chrono::steady_clock::now();\\n    for (int i : to_insert) {\\n        msoa.insert(i);\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"XXX insert \" << INSERT_N << \" ints, cost \" << diff.count() << \"s.\");\\n\\n    CHECK(true);\\n\\n    // stl lookup\\n    int count_found = 0;\\n    start = chrono::steady_clock::now();\\n    for (int i : to_insert) {\\n        count_found += (stl.find(i) != stl.end());\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"STL lookup \" << INSERT_N << \" ints, cost \" << diff.count() << \"s.\");\\n    CHECK(count_found == INSERT_N);\\n\\n    // HashMultiSetOpenAddress lookup\\n    count_found = 0;\\n    start = chrono::steady_clock::now();\\n    for (int i : to_insert) {\\n        count_found += (msoa.find(i) != msoa.end());\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"XXX lookup \" << INSERT_N << \" ints, cost \" << diff.count() << \"s.\");\\n    CHECK(count_found == INSERT_N);\\n\\n    // stl lookup non-exist\\n    count_found = 0;\\n    start = chrono::steady_clock::now();\\n    for (int i : to_lookup_non_exist) {\\n        count_found += (stl.find(i) != stl.end());\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"STL lookup \" << INSERT_N << \" non-exist ints, cost \" << diff.count() << \"s.\");\\n    CHECK(count_found == 0);\\n\\n    // HashMultiSetOpenAddress lookup non-exist\\n    count_found = 0;\\n    start = chrono::steady_clock::now();\\n    for (int i : to_lookup_non_exist) {\\n        count_found += (msoa.find(i) != msoa.end());\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"XXX lookup \" << INSERT_N << \" non-exist ints, cost \" << diff.count() << \"s.\");\\n    CHECK(count_found == 0);\\n\\n    // stl remove\\n    start = chrono::steady_clock::now();\\n    for (int i : to_remove_exist) {\\n        stl.erase(stl.find(i));\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"STL remove \" << REMOVE_N << \" ints, cost \" << diff.count() << \"s.\");\\n\\n    // HashMultiSetOpenAddress remove\\n    int remove_count = 0;\\n    start = chrono::steady_clock::now();\\n    for (int i : to_remove_exist) {\\n        remove_count += !!msoa.remove(i);\\n    }\\n    end = chrono::steady_clock::now();\\n    diff = end - start;\\n    INFO(\"XXX remove \" << REMOVE_N << \" ints, cost \" << diff.count() << \"s.\");\\n    CHECK(remove_count == REMOVE_N);\\n}\\n\\nTEST_CASE(\"381. Insert Delete GetRandom O(1) - Duplicates allowed\") {\\n    // dummy\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 85608,
                "title": "c-unordered-multimap-and-vector-solution",
                "content": "Use multimap so we could store value pair with same key. The place it needs to pay attention is when we update the index of vector for removed element in the multimap, we need to make sure we update the last node of the vector in the multimap.\\n\\n```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ret = true;\\n        if(valToIndexMap.find(val) != valToIndexMap.end())\\n            ret = false;\\n        \\n        vals.push_back(val);\\n        valToIndexMap.insert(pair<int,int>(val, vals.size()-1));\\n        \\n        return ret;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        auto removeItemIt = valToIndexMap.find(val);\\n\\n\\t\\tif (removeItemIt == valToIndexMap.end())\\n\\t\\t\\treturn false;\\n\\n\\t\\tint removeItemIndex = removeItemIt->second;\\n\\t\\tauto replaceItemItRange = valToIndexMap.equal_range(vals[vals.size() - 1]);\\n\\t\\tunordered_multimap<int, int>::iterator replaceItemIt = replaceItemItRange.first;\\n\\t\\tfor (auto it = replaceItemItRange.first; it != replaceItemItRange.second; it++){\\n\\t\\t\\tif (it->second > replaceItemIt->second){\\n\\t\\t\\t\\treplaceItemIt = it;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treplaceItemIt->second = removeItemIndex;\\n\\t\\tswap(vals[vals.size() - 1], vals[removeItemIndex]);\\n\\n\\t\\tvals.pop_back();\\n\\t\\tvalToIndexMap.erase(removeItemIt);\\n\\n\\t\\treturn true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        int retIndex = rand() % vals.size();\\n        return vals[retIndex];\\n    }\\n    \\nprivate:\\n    unordered_multimap<int, int> valToIndexMap;\\n    vector<int> vals;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    bool insert(int val) {\\n        bool ret = true;\\n        if(valToIndexMap.find(val) != valToIndexMap.end())\\n            ret = false;\\n        \\n        vals.push_back(val);\\n        valToIndexMap.insert(pair<int,int>(val, vals.size()-1));\\n        \\n        return ret;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    bool remove(int val) {\\n        auto removeItemIt = valToIndexMap.find(val);\\n\\n\\t\\tif (removeItemIt == valToIndexMap.end())\\n\\t\\t\\treturn false;\\n\\n\\t\\tint removeItemIndex = removeItemIt->second;\\n\\t\\tauto replaceItemItRange = valToIndexMap.equal_range(vals[vals.size() - 1]);\\n\\t\\tunordered_multimap<int, int>::iterator replaceItemIt = replaceItemItRange.first;\\n\\t\\tfor (auto it = replaceItemItRange.first; it != replaceItemItRange.second; it++){\\n\\t\\t\\tif (it->second > replaceItemIt->second){\\n\\t\\t\\t\\treplaceItemIt = it;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treplaceItemIt->second = removeItemIndex;\\n\\t\\tswap(vals[vals.size() - 1], vals[removeItemIndex]);\\n\\n\\t\\tvals.pop_back();\\n\\t\\tvalToIndexMap.erase(removeItemIt);\\n\\n\\t\\treturn true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    int getRandom() {\\n        int retIndex = rand() % vals.size();\\n        return vals[retIndex];\\n    }\\n    \\nprivate:\\n    unordered_multimap<int, int> valToIndexMap;\\n    vector<int> vals;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85628,
                "title": "do-we-really-need-linkedhashset-aren-t-arraylist-and-hashmap-integer-arraylist-integer-enough-java",
                "content": "My idea was to use a hashmap, where the key is the number, the value is the list of indices of the number in sorted order. \\n\\ninsert() and getRandom() is pretty standard. \\n\\nWhen we do remove, we first find the list of indices of the number (suppose it exists in our collection), delete the last index and swap with the end of our list and finally update our date structures.  \\n\\nMy code was accepted. Then I checked out the discussion session and it seemed most people were using linkedhashset. I know it certainly works. But first it's language dependent, second if you can use a simpler DS to get the job done, why bother the more advanced, as it has more internal overload.\\n\\nCorrect me if my solution is wrong.\\n\\n\\n// 134ms\\npublic class RandomizedCollection {\\n    private Random rand;\\n    private List<Integer> list;\\n    private Map<Integer, List<Integer>> val2indices;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        rand = new Random();\\n        list = new ArrayList<>();\\n        val2indices = new HashMap<>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean notPresent = false;\\n        if(!val2indices.containsKey(val)){  // if not already in, set notPresent and create a val -> idxList entry for it\\n            notPresent = true;\\n            val2indices.put(val, new ArrayList<>());\\n        }\\n        val2indices.get(val).add(list.size());  // add it into val2indices\\n        list.add(val);                          // add it to list\\n        return notPresent;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!val2indices.containsKey(val)){      // not in the collection\\n            return false;\\n        }\\n        List<Integer> valIdxList = val2indices.get(val);\\n        int valIdx = valIdxList.get(valIdxList.size() - 1); // get the last pos of val\\n        valIdxList.remove(valIdxList.size()-1);             // remove this pos in val's idx list\\n        if(valIdxList.isEmpty()){                           // if idx list empty, val has only 1 in the collection\\n            val2indices.remove(val);                            // remove it's entry\\n        }\\n        list.set(valIdx, list.get(list.size()-1));          // swap the last element into the val's pos\\n        list.remove(list.size()-1);                         // remove the last pos of list\\n        if(valIdx < list.size()){                   // if val is not the last element int the original list\\n            List<Integer> swapIdxList = val2indices.get(list.get(valIdx));// get the idx list of the swapped element\\n            swapIdxList.set(swapIdxList.size()-1, valIdx);      // replace the deleted last pos of list with the swapped pos\\n        }\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));        \\n    }\\n}",
                "solutionTags": [],
                "code": "My idea was to use a hashmap, where the key is the number, the value is the list of indices of the number in sorted order. \\n\\ninsert() and getRandom() is pretty standard. \\n\\nWhen we do remove, we first find the list of indices of the number (suppose it exists in our collection), delete the last index and swap with the end of our list and finally update our date structures.  \\n\\nMy code was accepted. Then I checked out the discussion session and it seemed most people were using linkedhashset. I know it certainly works. But first it's language dependent, second if you can use a simpler DS to get the job done, why bother the more advanced, as it has more internal overload.\\n\\nCorrect me if my solution is wrong.\\n\\n\\n// 134ms\\npublic class RandomizedCollection {\\n    private Random rand;\\n    private List<Integer> list;\\n    private Map<Integer, List<Integer>> val2indices;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        rand = new Random();\\n        list = new ArrayList<>();\\n        val2indices = new HashMap<>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean notPresent = false;\\n        if(!val2indices.containsKey(val)){  // if not already in, set notPresent and create a val -> idxList entry for it\\n            notPresent = true;\\n            val2indices.put(val, new ArrayList<>());\\n        }\\n        val2indices.get(val).add(list.size());  // add it into val2indices\\n        list.add(val);                          // add it to list\\n        return notPresent;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!val2indices.containsKey(val)){      // not in the collection\\n            return false;\\n        }\\n        List<Integer> valIdxList = val2indices.get(val);\\n        int valIdx = valIdxList.get(valIdxList.size() - 1); // get the last pos of val\\n        valIdxList.remove(valIdxList.size()-1);             // remove this pos in val's idx list\\n        if(valIdxList.isEmpty()){                           // if idx list empty, val has only 1 in the collection\\n            val2indices.remove(val);                            // remove it's entry\\n        }\\n        list.set(valIdx, list.get(list.size()-1));          // swap the last element into the val's pos\\n        list.remove(list.size()-1);                         // remove the last pos of list\\n        if(valIdx < list.size()){                   // if val is not the last element int the original list\\n            List<Integer> swapIdxList = val2indices.get(list.get(valIdx));// get the idx list of the swapped element\\n            swapIdxList.set(swapIdxList.size()-1, valIdx);      // replace the deleted last pos of list with the swapped pos\\n        }\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));        \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 85630,
                "title": "hashmap-linkedlist-solution",
                "content": "Similar idea to the one without duplicates. Please see the comments in the code for detailed ideas.\\n\\n    public class RandomizedCollection {\\n        List<Integer> list; // stores the numbers that are currently in the collection\\n        Map<Integer, Set<Integer>> map; // stores the value and the corresponding     multiple indexes where we can find the number. The usage of set is due to the O(1) requirement\\n        java.util.Random rand = new java.util.Random();\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean res = false;\\n        if (!map.containsKey(val)) {\\n            map.put(val, new HashSet<Integer>());\\n            res = true;\\n        }\\n        map.get(val).add(list.size());\\n        list.add(val);\\n        return res;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) return false;\\n        int idx = map.get(val).iterator().next();\\n        // list.remove(idx); // here if we use remove(), the complexity can be up to O(n), which is not desired\\n        if (list.get(idx) != list.get(list.size()-1)) { // if the number to be removed is not equal to the last number in the list\\n            int last = list.get(list.size()-1);\\n            list.set(idx, last);\\n            map.get(last).remove(list.size()-1);\\n            map.get(last).add(idx);\\n            map.get(val).remove(idx);\\n        } else {\\n        \\tmap.get(val).remove(list.size()-1);\\n        }\\n        list.remove(list.size()-1);\\n        if (map.get(val).size() == 0) map.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n}",
                "solutionTags": [],
                "code": "Similar idea to the one without duplicates. Please see the comments in the code for detailed ideas.\\n\\n    public class RandomizedCollection {\\n        List<Integer> list; // stores the numbers that are currently in the collection\\n        Map<Integer, Set<Integer>> map; // stores the value and the corresponding     multiple indexes where we can find the number. The usage of set is due to the O(1) requirement\\n        java.util.Random rand = new java.util.Random();\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedCollection() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean res = false;\\n        if (!map.containsKey(val)) {\\n            map.put(val, new HashSet<Integer>());\\n            res = true;\\n        }\\n        map.get(val).add(list.size());\\n        list.add(val);\\n        return res;\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) return false;\\n        int idx = map.get(val).iterator().next();\\n        // list.remove(idx); // here if we use remove(), the complexity can be up to O(n), which is not desired\\n        if (list.get(idx) != list.get(list.size()-1)) { // if the number to be removed is not equal to the last number in the list\\n            int last = list.get(list.size()-1);\\n            list.set(idx, last);\\n            map.get(last).remove(list.size()-1);\\n            map.get(last).add(idx);\\n            map.get(val).remove(idx);\\n        } else {\\n        \\tmap.get(val).remove(list.size()-1);\\n        }\\n        list.remove(list.size()-1);\\n        if (map.get(val).size() == 0) map.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 85615,
                "title": "java-using-hashmap-integer-hashset-integer-and-arraylist-with-explaination-151ms",
                "content": "The same as problem one but contains duplicate. So using the key of HashMap to store number and HashSet as the value to store indexes in the list. Every time when the set is empty, remove the key form HashMap. \\n\\nHope it helps~ \\n~~~java\\npublic class RandomizedCollection {\\n\\n    /** Initialize your data structure here. */\\n    HashMap<Integer,HashSet<Integer>> map;\\n    List<Integer> list;\\n    java.util.Random r = new java.util.Random();\\n    public RandomizedCollection() {\\n        map = new HashMap<Integer,HashSet<Integer>>();\\n        list = new ArrayList<Integer>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        list.add(val);\\n        if(map.containsKey(val)) {\\n            HashSet<Integer> set = map.get(val);\\n            set.add(list.size()-1);\\n            map.put(val , set);\\n            return false;\\n        }else {\\n            HashSet<Integer> set = new HashSet<Integer>();\\n            set.add(list.size()-1);\\n            map.put(val , set);\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(map.containsKey(val)) {\\n            HashSet<Integer> set = map.get(val);\\n            Iterator<Integer> it = set.iterator();\\n            int index = 0;\\n            if(it.hasNext()) {\\n                index = it.next();\\n            }else {\\n                return false;\\n            }\\n            set.remove(index);\\n            if(set.isEmpty()) {\\n                map.remove(val);\\n            }\\n            if(index == list.size()-1) {\\n                list.remove(list.size()-1);\\n                return true;\\n            }else {\\n                int deletenum = list.get(index);\\n                int lastnum = list.get(list.size()-1);\\n                if(lastnum == deletenum) { //if the last number in the list equals to the number to be delete\\n                    set.remove(list.size() - 1);\\n                    set.add(index);\\n                    list.remove(list.size() - 1);\\n                }else {\\n                    list.set(index , lastnum);\\n                    HashSet<Integer> lastnumset = map.get(lastnum);\\n                    lastnumset.remove(list.size() - 1);\\n                    lastnumset.add(index);\\n                    list.remove(list.size() - 1);\\n                }\\n                return true;\\n            }\\n        }else {\\n            return false;\\n        }\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        int index = r.nextInt(list.size());\\n        return list.get(index);\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */",
                "solutionTags": [],
                "code": "The same as problem one but contains duplicate. So using the key of HashMap to store number and HashSet as the value to store indexes in the list. Every time when the set is empty, remove the key form HashMap. \\n\\nHope it helps~ \\n~~~java\\npublic class RandomizedCollection {\\n\\n    /** Initialize your data structure here. */\\n    HashMap<Integer,HashSet<Integer>> map;\\n    List<Integer> list;\\n    java.util.Random r = new java.util.Random();\\n    public RandomizedCollection() {\\n        map = new HashMap<Integer,HashSet<Integer>>();\\n        list = new ArrayList<Integer>();\\n    }\\n    \\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        list.add(val);\\n        if(map.containsKey(val)) {\\n            HashSet<Integer> set = map.get(val);\\n            set.add(list.size()-1);\\n            map.put(val , set);\\n            return false;\\n        }else {\\n            HashSet<Integer> set = new HashSet<Integer>();\\n            set.add(list.size()-1);\\n            map.put(val , set);\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\\n    public boolean remove(int val) {\\n        if(map.containsKey(val)) {\\n            HashSet<Integer> set = map.get(val);\\n            Iterator<Integer> it = set.iterator();\\n            int index = 0;\\n            if(it.hasNext()) {\\n                index = it.next();\\n            }else {\\n                return false;\\n            }\\n            set.remove(index);\\n            if(set.isEmpty()) {\\n                map.remove(val);\\n            }\\n            if(index == list.size()-1) {\\n                list.remove(list.size()-1);\\n                return true;\\n            }else {\\n                int deletenum = list.get(index);\\n                int lastnum = list.get(list.size()-1);\\n                if(lastnum == deletenum) { //if the last number in the list equals to the number to be delete\\n                    set.remove(list.size() - 1);\\n                    set.add(index);\\n                    list.remove(list.size() - 1);\\n                }else {\\n                    list.set(index , lastnum);\\n                    HashSet<Integer> lastnumset = map.get(lastnum);\\n                    lastnumset.remove(list.size() - 1);\\n                    lastnumset.add(index);\\n                    list.remove(list.size() - 1);\\n                }\\n                return true;\\n            }\\n        }else {\\n            return false;\\n        }\\n    }\\n    \\n    /** Get a random element from the collection. */\\n    public int getRandom() {\\n        int index = r.nextInt(list.size());\\n        return list.get(index);\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 85617,
                "title": "python-ac-solution",
                "content": "**EDITED:**\\n\\nThanks to @stachenov\\n\\nUse an array to store all element.\\nUse a dictionary to store the appearane of each element. (key = val, value = set of index)\\n\\nTo insert, simply add new element to the array and update the dictionary.\\nTo remove, first check the existance of this element with dictionary. (and get an arbitrary index)\\nSwap it with the last element, and update the dictionary.\\nTo getRandom, directly use random.randint to get the index from the array.\\n\\n\\n```\\nimport random\\n\\nclass RandomizedCollection(object):\\n    def __init__(self):\\n        self.collection = {}        # key = item stored in array, value = set of index\\n        self.array = []             # store all items in the array\\n\\n    def insert(self, val):\\n        index = len(self.array)\\n        self.array += val,\\n\\n        if val not in self.collection.keys():\\n            self.collection[val] = set([index])\\n            return True\\n        else:\\n            self.collection[val].add(index)\\n            return False\\n\\n    def remove(self, val):\\n        if not self.array or val not in self.collection.keys():\\n            return False\\n\\n        else:\\n            last = self.array[-1]                           # the other element\\n            i_last = len(self.array)-1                      # index of last position\\n            i_val = self.collection[val].pop()              # index of val position\\n            self.array[i_val] = self.array[i_last]          # update the array\\n            self.array.pop()\\n\\n            self.collection[last].add(i_val)                # update the dict\\n            self.collection[last].remove(i_last)\\n\\n            if len(self.collection[val]) == 0:\\n                del self.collection[val]                    # remove empty set\\n            \\n            return True\\n\\n    def getRandom(self):\\n        if len(self.array) == 0: return -1\\n        else: return self.array[random.randint(0, len(self.array)-1)]\\n```\\n\\n\\n**Original Post:**\\n\\nSimilar to #380, which can be solved just using set().\\n\\nIn order to deal with duplication here, use one more dictionary to store the appearance of each element. (key = val, value = appearance). In the sets, we can store each val as a tuple: (val, appearance)\\n\\nFor example, if input = [insert 1, insert 2, insert 1], then the set will be: set((1,1), (2,1), (1,2))\\n\\nFor deleting, just see whether val is in dictionary or not. If exist, remove the one with the latest appearance in the set. (And also fix the dictionary)\\n\\nFor sampling, just sample as #380, but only return the val part.\\n\\nIt should be one of the easiest way.\\n\\n```\\nimport random\\n\\nclass RandomizedCollection(object):\\n    def __init__(self):\\n        self.collection = {}        # key = val, value = appearances\\n        self.data = set()           # store val with appearance\\n\\n    def insert(self, val):\\n        if val not in self.collection.keys():\\n            self.collection[val] = 1\\n            self.data.add((val, 1))\\n            return True\\n        else:\\n            self.collection[val] += 1\\n            self.data.add((val, self.collection[val]))\\n            return False\\n\\n    def remove(self, val):\\n        # if exist => remove it from dictionary and set\\n        # if appearances == 0 => remove from the dictionary\\n\\n        if val in self.collection.keys():\\n            self.data.remove((val, self.collection[val]))\\n            self.collection[val] -= 1\\n            if self.collection[val] == 0: del self.collection[val]\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self):\\n        return random.sample(self.data, 1)[0][0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport random\\n\\nclass RandomizedCollection(object):\\n    def __init__(self):\\n        self.collection = {}        # key = item stored in array, value = set of index\\n        self.array = []             # store all items in the array\\n\\n    def insert(self, val):\\n        index = len(self.array)\\n        self.array += val,\\n\\n        if val not in self.collection.keys():\\n            self.collection[val] = set([index])\\n            return True\\n        else:\\n            self.collection[val].add(index)\\n            return False\\n\\n    def remove(self, val):\\n        if not self.array or val not in self.collection.keys():\\n            return False\\n\\n        else:\\n            last = self.array[-1]                           # the other element\\n            i_last = len(self.array)-1                      # index of last position\\n            i_val = self.collection[val].pop()              # index of val position\\n            self.array[i_val] = self.array[i_last]          # update the array\\n            self.array.pop()\\n\\n            self.collection[last].add(i_val)                # update the dict\\n            self.collection[last].remove(i_last)\\n\\n            if len(self.collection[val]) == 0:\\n                del self.collection[val]                    # remove empty set\\n            \\n            return True\\n\\n    def getRandom(self):\\n        if len(self.array) == 0: return -1\\n        else: return self.array[random.randint(0, len(self.array)-1)]\\n```\n```\\nimport random\\n\\nclass RandomizedCollection(object):\\n    def __init__(self):\\n        self.collection = {}        # key = val, value = appearances\\n        self.data = set()           # store val with appearance\\n\\n    def insert(self, val):\\n        if val not in self.collection.keys():\\n            self.collection[val] = 1\\n            self.data.add((val, 1))\\n            return True\\n        else:\\n            self.collection[val] += 1\\n            self.data.add((val, self.collection[val]))\\n            return False\\n\\n    def remove(self, val):\\n        # if exist => remove it from dictionary and set\\n        # if appearances == 0 => remove from the dictionary\\n\\n        if val in self.collection.keys():\\n            self.data.remove((val, self.collection[val]))\\n            self.collection[val] -= 1\\n            if self.collection[val] == 0: del self.collection[val]\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self):\\n        return random.sample(self.data, 1)[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042076,
                "title": "soln-using-list-java-kotlin-hyder-nabi",
                "content": "# Java Code \\n```\\nclass RandomizedCollection() {\\n    private val multiSet : MutableList<Int> = mutableListOf()\\n    fun insert(`val`: Int): Boolean {\\n        if(multiSet.contains(`val`)) {\\n            multiSet.add(`val`)\\n            return false\\n        } else {\\n            multiSet.add(`val`)\\n            return true\\n        }\\n    }\\n\\n    fun remove(`val`: Int): Boolean {\\n        return if(multiSet.contains(`val`)){\\n            multiSet.remove(`val`)\\n            true\\n        } else {\\n            false\\n        }\\n    }\\n\\n    fun getRandom(): Int {\\n        val random = (Math.random() * multiSet.size).toInt()\\n        return multiSet[random]\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * var obj = RandomizedCollection()\\n * var param_1 = obj.insert(`val`)\\n * var param_2 = obj.remove(`val`)\\n * var param_3 = obj.getRandom()\\n */\\n```\\n# Kotlin\\n```\\nclass RandomizedCollection() {\\n    private val multiSet : MutableList<Int> = mutableListOf()\\n    fun insert(`val`: Int): Boolean {\\n        if(multiSet.contains(`val`)) {\\n            multiSet.add(`val`)\\n            return false\\n        } else {\\n            multiSet.add(`val`)\\n            return true\\n        }\\n    }\\n\\n    fun remove(`val`: Int): Boolean {\\n        return if(multiSet.contains(`val`)){\\n            multiSet.remove(`val`)\\n            true\\n        } else {\\n            false\\n        }\\n    }\\n\\n    fun getRandom(): Int {\\n        val random = (Math.random() * multiSet.size).toInt()\\n        return multiSet[random]\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * var obj = RandomizedCollection()\\n * var param_1 = obj.insert(`val`)\\n * var param_2 = obj.remove(`val`)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\nclass RandomizedCollection() {\\n    private val multiSet : MutableList<Int> = mutableListOf()\\n    fun insert(`val`: Int): Boolean {\\n        if(multiSet.contains(`val`)) {\\n            multiSet.add(`val`)\\n            return false\\n        } else {\\n            multiSet.add(`val`)\\n            return true\\n        }\\n    }\\n\\n    fun remove(`val`: Int): Boolean {\\n        return if(multiSet.contains(`val`)){\\n            multiSet.remove(`val`)\\n            true\\n        } else {\\n            false\\n        }\\n    }\\n\\n    fun getRandom(): Int {\\n        val random = (Math.random() * multiSet.size).toInt()\\n        return multiSet[random]\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * var obj = RandomizedCollection()\\n * var param_1 = obj.insert(`val`)\\n * var param_2 = obj.remove(`val`)\\n * var param_3 = obj.getRandom()\\n */\\n```\n```\\nclass RandomizedCollection() {\\n    private val multiSet : MutableList<Int> = mutableListOf()\\n    fun insert(`val`: Int): Boolean {\\n        if(multiSet.contains(`val`)) {\\n            multiSet.add(`val`)\\n            return false\\n        } else {\\n            multiSet.add(`val`)\\n            return true\\n        }\\n    }\\n\\n    fun remove(`val`: Int): Boolean {\\n        return if(multiSet.contains(`val`)){\\n            multiSet.remove(`val`)\\n            true\\n        } else {\\n            false\\n        }\\n    }\\n\\n    fun getRandom(): Int {\\n        val random = (Math.random() * multiSet.size).toInt()\\n        return multiSet[random]\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * var obj = RandomizedCollection()\\n * var param_1 = obj.insert(`val`)\\n * var param_2 = obj.remove(`val`)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028232,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class RandomizedCollection {\\n    IList<int> values = null;\\n    IDictionary<int, IList<int>> dict = null;\\n    Random rand = null;\\n    public RandomizedCollection() {\\n        values = new List<int>();\\n        dict = new Dictionary<int, IList<int>>();\\n        rand = new Random();\\n    }\\n    public bool Insert(int val) {\\n        bool status = dict.TryAdd(val, new List<int>());\\n        values.Add(val);\\n        dict[val].Add(val);\\n        return status;\\n    }\\n    public bool Remove(int val) {\\n        Console.WriteLine(\"1. val = \" + val);\\n        if(dict.TryGetValue(val, out var list))\\n        {\\n            dict[val].Remove(val);\\n            if(dict[val].Count == 0)\\n            {\\n                dict.Remove(val);\\n            }\\n            values.Remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int GetRandom() {\\n        return values[rand.Next(values.Count)];\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.Insert(val);\\n * bool param_2 = obj.Remove(val);\\n * int param_3 = obj.GetRandom();\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table",
                    "Design",
                    "Randomized"
                ],
                "code": "```\\npublic class RandomizedCollection {\\n    IList<int> values = null;\\n    IDictionary<int, IList<int>> dict = null;\\n    Random rand = null;\\n    public RandomizedCollection() {\\n        values = new List<int>();\\n        dict = new Dictionary<int, IList<int>>();\\n        rand = new Random();\\n    }\\n    public bool Insert(int val) {\\n        bool status = dict.TryAdd(val, new List<int>());\\n        values.Add(val);\\n        dict[val].Add(val);\\n        return status;\\n    }\\n    public bool Remove(int val) {\\n        Console.WriteLine(\"1. val = \" + val);\\n        if(dict.TryGetValue(val, out var list))\\n        {\\n            dict[val].Remove(val);\\n            if(dict[val].Count == 0)\\n            {\\n                dict.Remove(val);\\n            }\\n            values.Remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int GetRandom() {\\n        return values[rand.Next(values.Count)];\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * bool param_1 = obj.Insert(val);\\n * bool param_2 = obj.Remove(val);\\n * int param_3 = obj.GetRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980555,
                "title": "easy-solution-clear-concise-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedCollection {\\nprivate:\\n    vector<pair<int, int>> v;\\n    unordered_map<int, vector<int>> mp;\\npublic:\\n    RandomizedCollection() {\\n    }\\n    \\n    bool insert(int val) {\\n        bool res = false;\\n        if(mp.find(val) == mp.end()) res = true;\\n        mp[val].push_back(v.size());\\n        v.push_back({val, mp[val].size() - 1});\\n        return res;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val) == mp.end()) return false;\\n        int index = mp[val].back();\\n        pair<int, int> last = v.back();\\n        v.pop_back();\\n        v[index] = last;\\n        mp[last.first][last.second] = index;\\n        mp[val].pop_back();\\n        if(mp[val].size() == 0) mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand() % v.size()].first;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Design",
                    "Randomized"
                ],
                "code": "```\\nclass RandomizedCollection {\\nprivate:\\n    vector<pair<int, int>> v;\\n    unordered_map<int, vector<int>> mp;\\npublic:\\n    RandomizedCollection() {\\n    }\\n    \\n    bool insert(int val) {\\n        bool res = false;\\n        if(mp.find(val) == mp.end()) res = true;\\n        mp[val].push_back(v.size());\\n        v.push_back({val, mp[val].size() - 1});\\n        return res;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val) == mp.end()) return false;\\n        int index = mp[val].back();\\n        pair<int, int> last = v.back();\\n        v.pop_back();\\n        v[index] = last;\\n        mp[last.first][last.second] = index;\\n        mp[val].pop_back();\\n        if(mp[val].size() == 0) mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand() % v.size()].first;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955010,
                "title": "java-python-solution-explained",
                "content": "# Intuition - \\n\\nThe given code implements a data structure called `RandomizedCollection`, which is similar to a set but allows for duplicates and supports efficient random element retrieval. It allows inserting elements, removing elements (if they exist), and getting a random element.\\n\\n# Approach - \\n\\n1. `RandomizedCollection` uses two data structures:\\n   - `valueToIndices`: A dictionary (HashMap in Java) that maps a value to a list of indices in the `items` list where that value appears.\\n   - `items`: A list that stores instances of the `Item` class. Each `Item` object represents a value and its index in the `items` list.\\n\\n2. **Insertion (`insert` method):**\\n   - When inserting a value, we first check if it exists in the `valueToIndices` dictionary.\\n   - If it doesn\\'t exist, we create an entry with an empty list as the value.\\n   - We add the current index of the `items` list to the corresponding list in `valueToIndices`, representing the index of the newly added value.\\n   - We create an `Item` object with the value and its index in the corresponding list.\\n   - We add this `Item` object to the `items` list.\\n   - If the size of the corresponding list in `valueToIndices` is 1, it means this is the first occurrence of the value, and we return `true`. Otherwise, we return `false`.\\n\\n3. **Removal (`remove` method):**\\n   - When removing a value, we first check if it exists in the `valueToIndices` dictionary.\\n   - If it doesn\\'t exist, we return `false` as the value is not in the collection.\\n   - Otherwise, we retrieve the last index of the value from the corresponding list in `valueToIndices`.\\n   - We update the last `Item` in the `items` list with the value and index of the removed value.\\n   - We remove the last `Item` from the `items` list.\\n   - If the list of indices in `valueToIndices` becomes empty after removing the value, we remove the entry from the dictionary.\\n   - We return `true` to indicate successful removal.\\n\\n4. **Random Element Retrieval (`getRandom` method):**\\n   - We generate a random index within the range of valid indices in the `items` list.\\n   - We retrieve the `Item` object at that index and return its value.\\n\\n5. Helper methods:\\n   - `lastIndex`: Returns the last index in a list of indices.\\n   - `last`: Returns the last `Item` in a list of `Item` objects.\\n\\n# Complexity Analysis - \\n - Time Complexity - (O(1))\\n\\n - Space Complexity - (O(N))\\n\\n\\n# Code\\n``` Java []\\nclass Item {\\n    public int value;\\n    public int indexInMap;\\n\\n    public Item(int value, int indexInMap) {\\n        this.value = value;\\n        this.indexInMap = indexInMap;\\n    }\\n}\\n\\nclass RandomizedCollection {\\n    private Map<Integer, List<Integer>> valueToIndices = new HashMap<>();\\n    private List<Item> items = new ArrayList<>();\\n    private Random rand = new Random();\\n\\n    public boolean insert(int value) {\\n        valueToIndices.putIfAbsent(value, new ArrayList<>());\\n        valueToIndices.get(value).add(items.size());\\n        items.add(new Item(value, valueToIndices.get(value).size() - 1));\\n        return valueToIndices.get(value).size() == 1;\\n    }\\n\\n    public boolean remove(int value) {\\n        if (!valueToIndices.containsKey(value))\\n            return false;\\n\\n        int index = lastIndex(valueToIndices.get(value));\\n        valueToIndices.get(last(items).value).set(last(items).indexInMap, index);\\n        int indicesSize = valueToIndices.get(value).size();\\n        valueToIndices.get(value).remove(indicesSize - 1);\\n        if (valueToIndices.get(value).isEmpty())\\n            valueToIndices.remove(value);\\n        items.set(index, last(items));\\n        items.remove(items.size() - 1);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        int index = rand.nextInt(items.size());\\n        return items.get(index).value;\\n    }\\n\\n    private int lastIndex(List<Integer> indices) {\\n        return indices.get(indices.size() - 1);\\n    }\\n\\n    private Item last(List<Item> items) {\\n        return items.get(items.size() - 1);\\n    }\\n}\\n\\n```\\n\\n\\n``` Python []\\nimport random\\n\\nclass Item:\\n    def __init__(self, value, index_in_map):\\n        self.value = value\\n        self.index_in_map = index_in_map\\n\\nclass RandomizedCollection:\\n    def __init__(self):\\n        self.value_to_indices = {}\\n        self.items = []\\n        \\n    def insert(self, value):\\n        self.value_to_indices.setdefault(value, [])\\n        self.value_to_indices[value].append(len(self.items))\\n        self.items.append(Item(value, len(self.value_to_indices[value]) - 1))\\n        return len(self.value_to_indices[value]) == 1\\n\\n    def remove(self, value):\\n        if value not in self.value_to_indices:\\n            return False\\n\\n        index = self.value_to_indices[value].pop()\\n        last_item = self.items[-1]\\n\\n        if index != len(self.items) - 1:\\n            self.value_to_indices[last_item.value][last_item.index_in_map] = index\\n\\n        if not self.value_to_indices[value]:\\n            del self.value_to_indices[value]\\n\\n        self.items[index] = last_item\\n        self.items.pop()\\n        return True\\n\\n    def getRandom(self):\\n        index = random.randint(0, len(self.items) - 1)\\n        return self.items[index].value\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Design",
                    "Randomized"
                ],
                "code": "``` Java []\\nclass Item {\\n    public int value;\\n    public int indexInMap;\\n\\n    public Item(int value, int indexInMap) {\\n        this.value = value;\\n        this.indexInMap = indexInMap;\\n    }\\n}\\n\\nclass RandomizedCollection {\\n    private Map<Integer, List<Integer>> valueToIndices = new HashMap<>();\\n    private List<Item> items = new ArrayList<>();\\n    private Random rand = new Random();\\n\\n    public boolean insert(int value) {\\n        valueToIndices.putIfAbsent(value, new ArrayList<>());\\n        valueToIndices.get(value).add(items.size());\\n        items.add(new Item(value, valueToIndices.get(value).size() - 1));\\n        return valueToIndices.get(value).size() == 1;\\n    }\\n\\n    public boolean remove(int value) {\\n        if (!valueToIndices.containsKey(value))\\n            return false;\\n\\n        int index = lastIndex(valueToIndices.get(value));\\n        valueToIndices.get(last(items).value).set(last(items).indexInMap, index);\\n        int indicesSize = valueToIndices.get(value).size();\\n        valueToIndices.get(value).remove(indicesSize - 1);\\n        if (valueToIndices.get(value).isEmpty())\\n            valueToIndices.remove(value);\\n        items.set(index, last(items));\\n        items.remove(items.size() - 1);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        int index = rand.nextInt(items.size());\\n        return items.get(index).value;\\n    }\\n\\n    private int lastIndex(List<Integer> indices) {\\n        return indices.get(indices.size() - 1);\\n    }\\n\\n    private Item last(List<Item> items) {\\n        return items.get(items.size() - 1);\\n    }\\n}\\n\\n```\n``` Python []\\nimport random\\n\\nclass Item:\\n    def __init__(self, value, index_in_map):\\n        self.value = value\\n        self.index_in_map = index_in_map\\n\\nclass RandomizedCollection:\\n    def __init__(self):\\n        self.value_to_indices = {}\\n        self.items = []\\n        \\n    def insert(self, value):\\n        self.value_to_indices.setdefault(value, [])\\n        self.value_to_indices[value].append(len(self.items))\\n        self.items.append(Item(value, len(self.value_to_indices[value]) - 1))\\n        return len(self.value_to_indices[value]) == 1\\n\\n    def remove(self, value):\\n        if value not in self.value_to_indices:\\n            return False\\n\\n        index = self.value_to_indices[value].pop()\\n        last_item = self.items[-1]\\n\\n        if index != len(self.items) - 1:\\n            self.value_to_indices[last_item.value][last_item.index_in_map] = index\\n\\n        if not self.value_to_indices[value]:\\n            del self.value_to_indices[value]\\n\\n        self.items[index] = last_item\\n        self.items.pop()\\n        return True\\n\\n    def getRandom(self):\\n        index = random.randint(0, len(self.items) - 1)\\n        return self.items[index].value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933869,
                "title": "sunilking55",
                "content": "# Code\\n```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.a = []\\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.a:\\n            self.a.append(val)\\n            return False\\n        else:\\n            self.a.append(val)\\n            return True\\n        \\n    def remove(self, val: int) -> bool:\\n        if val in self.a:\\n            self.a.remove(val)\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        if len(self.a)>0:\\n            return random.choice(self.a)\\n        else:\\n            return -1\\n        \\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.a = []\\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.a:\\n            self.a.append(val)\\n            return False\\n        else:\\n            self.a.append(val)\\n            return True\\n        \\n    def remove(self, val: int) -> bool:\\n        if val in self.a:\\n            self.a.remove(val)\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        if len(self.a)>0:\\n            return random.choice(self.a)\\n        else:\\n            return -1\\n        \\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933867,
                "title": "sunilking55",
                "content": "# Code\\n```\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int,int> hp;\\n    vector<int> v;\\n    mt19937 rand;\\n    int tot;\\n\\n    RandomizedCollection() {\\n        random_device seed;\\n        rand = mt19937(seed());\\n        tot = 0;\\n    }\\n    \\n    bool insert(int val) {\\n        hp[val]+=1;\\n        v.insert(v.begin()+tot, val);\\n        tot+=1;\\n        if(hp[val]==1) {\\n            return true;\\n        } else{\\n            return false;\\n        }\\n    }\\n    \\n    bool remove(int val) {\\n        if (hp.find(val) != hp.end()) {\\n            if (hp[val] > 1) {\\n                hp[val] -= 1;\\n            } else {\\n                hp.erase(val);\\n            }\\n        \\n            auto it = find(v.begin(), v.begin() + tot, val);\\n            if (it != v.end()) {\\n                v.erase(it);\\n                tot -= 1;\\n            }\\n        \\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    int getRandom() {\\n        return v[rand()%tot];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int,int> hp;\\n    vector<int> v;\\n    mt19937 rand;\\n    int tot;\\n\\n    RandomizedCollection() {\\n        random_device seed;\\n        rand = mt19937(seed());\\n        tot = 0;\\n    }\\n    \\n    bool insert(int val) {\\n        hp[val]+=1;\\n        v.insert(v.begin()+tot, val);\\n        tot+=1;\\n        if(hp[val]==1) {\\n            return true;\\n        } else{\\n            return false;\\n        }\\n    }\\n    \\n    bool remove(int val) {\\n        if (hp.find(val) != hp.end()) {\\n            if (hp[val] > 1) {\\n                hp[val] -= 1;\\n            } else {\\n                hp.erase(val);\\n            }\\n        \\n            auto it = find(v.begin(), v.begin() + tot, val);\\n            if (it != v.end()) {\\n                v.erase(it);\\n                tot -= 1;\\n            }\\n        \\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    int getRandom() {\\n        return v[rand()%tot];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904064,
                "title": "python",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    list data structure\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.cache = []\\n\\n    # O(1)\\n    def insert(self, val: int) -> bool:\\n        if val in self.cache:\\n            self.cache.append(val)\\n            return False\\n\\n        self.cache.append(val)\\n        return True\\n\\n    # O(1)\\n    def remove(self, val: int) -> bool:\\n        if val in self.cache:\\n            self.cache.remove(val)\\n            return True\\n\\n        return False\\n\\n    # O(1)\\n    def getRandom(self) -> int:\\n        return random.choice(self.cache)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.cache = []\\n\\n    # O(1)\\n    def insert(self, val: int) -> bool:\\n        if val in self.cache:\\n            self.cache.append(val)\\n            return False\\n\\n        self.cache.append(val)\\n        return True\\n\\n    # O(1)\\n    def remove(self, val: int) -> bool:\\n        if val in self.cache:\\n            self.cache.remove(val)\\n            return True\\n\\n        return False\\n\\n    # O(1)\\n    def getRandom(self) -> int:\\n        return random.choice(self.cache)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899315,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Item {\\n  int val;\\n  int indexInMap;\\n  Item(int val, int indexInMap) : val(val), indexInMap(indexInMap) {}\\n};\\n\\nclass RandomizedCollection {\\n public:\\n  /** Inserts a value to the collection. Returns true if the collection did not\\n   * already contain the specified element. */\\n  bool insert(int val) {\\n    valToIndices[val].push_back(items.size());\\n    items.emplace_back(val, valToIndices[val].size() - 1);\\n    return valToIndices[val].size() == 1;\\n  }\\n\\n  /** Removes a value from the collection. Returns true if the collection\\n   * contained the specified element. */\\n  bool remove(int val) {\\n    if (!valToIndices.count(val))\\n      return false;\\n\\n    const int index = valToIndices[val].back();\\n    valToIndices[items.back().val][items.back().indexInMap] = index;\\n    valToIndices[val].pop_back();\\n    if (valToIndices[val].empty())\\n      valToIndices.erase(val);\\n    items[index] = items.back();\\n    items.pop_back();\\n    return true;\\n  }\\n\\n  /** Get a random element from the collection. */\\n  int getRandom() {\\n    const int index = rand() % items.size();\\n    return items[index].val;\\n  }\\n\\n private:\\n  unordered_map<int, vector<int>> valToIndices;\\n  vector<Item> items;\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Item {\\n  int val;\\n  int indexInMap;\\n  Item(int val, int indexInMap) : val(val), indexInMap(indexInMap) {}\\n};\\n\\nclass RandomizedCollection {\\n public:\\n  /** Inserts a value to the collection. Returns true if the collection did not\\n   * already contain the specified element. */\\n  bool insert(int val) {\\n    valToIndices[val].push_back(items.size());\\n    items.emplace_back(val, valToIndices[val].size() - 1);\\n    return valToIndices[val].size() == 1;\\n  }\\n\\n  /** Removes a value from the collection. Returns true if the collection\\n   * contained the specified element. */\\n  bool remove(int val) {\\n    if (!valToIndices.count(val))\\n      return false;\\n\\n    const int index = valToIndices[val].back();\\n    valToIndices[items.back().val][items.back().indexInMap] = index;\\n    valToIndices[val].pop_back();\\n    if (valToIndices[val].empty())\\n      valToIndices.erase(val);\\n    items[index] = items.back();\\n    items.pop_back();\\n    return true;\\n  }\\n\\n  /** Get a random element from the collection. */\\n  int getRandom() {\\n    const int index = rand() % items.size();\\n    return items[index].val;\\n  }\\n\\n private:\\n  unordered_map<int, vector<int>> valToIndices;\\n  vector<Item> items;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823734,
                "title": "simplest-python-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.stack = []\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        \\n        if val not in self.stack:\\n            self.stack.append(val)\\n            return True  \\n        else:      \\n            self.stack.append(val)\\n            return False\\n        \\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.stack:\\n            self.stack.remove(val)\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.stack)\\n        \\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.stack = []\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        \\n        if val not in self.stack:\\n            self.stack.append(val)\\n            return True  \\n        else:      \\n            self.stack.append(val)\\n            return False\\n        \\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.stack:\\n            self.stack.remove(val)\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.stack)\\n        \\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822523,
                "title": "c-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass RandomizedCollection {\\npublic:\\n    vector<int>v;\\n    unordered_map<int,int>mp;\\n    RandomizedCollection() \\n    {\\n        //no code\\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp[val] == 0)  //the element is not present yet in the vector or map\\n        {\\n            v.push_back(val);\\n            mp[val]++;   //due to the reazon of duplicate \\n            return true;\\n        }\\n        else if(mp[val] > 0)   //it is present in the vector or mp\\n        {\\n            v.push_back(val);\\n            mp[val]++;\\n            return false;\\n        }\\n        return false;    //this will not get encounterd\\n    }\\n    \\n    bool remove(int val) \\n    {\\n         if(mp[val] > 0)  //the element is present\\n         {\\n             auto it = find(v.begin(),v.end(),val);\\n             v.erase(it);\\n             mp[val]--;\\n             return true;\\n         }\\n         return false;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    vector<int>v;\\n    unordered_map<int,int>mp;\\n    RandomizedCollection() \\n    {\\n        //no code\\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp[val] == 0)  //the element is not present yet in the vector or map\\n        {\\n            v.push_back(val);\\n            mp[val]++;   //due to the reazon of duplicate \\n            return true;\\n        }\\n        else if(mp[val] > 0)   //it is present in the vector or mp\\n        {\\n            v.push_back(val);\\n            mp[val]++;\\n            return false;\\n        }\\n        return false;    //this will not get encounterd\\n    }\\n    \\n    bool remove(int val) \\n    {\\n         if(mp[val] > 0)  //the element is present\\n         {\\n             auto it = find(v.begin(),v.end(),val);\\n             v.erase(it);\\n             mp[val]--;\\n             return true;\\n         }\\n         return false;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779843,
                "title": "java-solution-beats92-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Item {\\n  public int val;\\n  public int indexInMap;\\n  public Item(int val, int indexInMap) {\\n    this.val = val;\\n    this.indexInMap = indexInMap;\\n  }\\n}\\n\\nclass RandomizedCollection {\\n  /**\\n   * Inserts a value to the collection. Returns true if the collection did not already contain the\\n   * specified element.\\n   */\\n  public boolean insert(int val) {\\n    valToIndices.putIfAbsent(val, new ArrayList<>());\\n    valToIndices.get(val).add(items.size());\\n    items.add(new Item(val, valToIndices.get(val).size() - 1));\\n    return valToIndices.get(val).size() == 1;\\n  }\\n\\n  /**\\n   * Removes a value from the collection. Returns true if the collection contained the specified\\n   * element.\\n   */\\n  public boolean remove(int val) {\\n    if (!valToIndices.containsKey(val))\\n      return false;\\n\\n    final int index = lastIndex(valToIndices.get(val));\\n    valToIndices.get(last(items).val).set(last(items).indexInMap, index);\\n    final int indicesSize = valToIndices.get(val).size();\\n    valToIndices.get(val).remove(indicesSize - 1);\\n    if (valToIndices.get(val).isEmpty())\\n      valToIndices.remove(val);\\n    items.set(index, last(items));\\n    items.remove(items.size() - 1);\\n    return true;\\n  }\\n\\n  /** Get a random element from the collection. */\\n  public int getRandom() {\\n    final int index = rand.nextInt(items.size());\\n    return items.get(index).val;\\n  }\\n\\n  private Map<Integer, List<Integer>> valToIndices = new HashMap<>();\\n  private List<Item> items = new ArrayList<>();\\n  private Random rand = new Random();\\n\\n  private int lastIndex(List<Integer> indices) {\\n    return indices.get(indices.size() - 1);\\n  }\\n\\n  private Item last(List<Item> items) {\\n    return items.get(items.size() - 1);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Item {\\n  public int val;\\n  public int indexInMap;\\n  public Item(int val, int indexInMap) {\\n    this.val = val;\\n    this.indexInMap = indexInMap;\\n  }\\n}\\n\\nclass RandomizedCollection {\\n  /**\\n   * Inserts a value to the collection. Returns true if the collection did not already contain the\\n   * specified element.\\n   */\\n  public boolean insert(int val) {\\n    valToIndices.putIfAbsent(val, new ArrayList<>());\\n    valToIndices.get(val).add(items.size());\\n    items.add(new Item(val, valToIndices.get(val).size() - 1));\\n    return valToIndices.get(val).size() == 1;\\n  }\\n\\n  /**\\n   * Removes a value from the collection. Returns true if the collection contained the specified\\n   * element.\\n   */\\n  public boolean remove(int val) {\\n    if (!valToIndices.containsKey(val))\\n      return false;\\n\\n    final int index = lastIndex(valToIndices.get(val));\\n    valToIndices.get(last(items).val).set(last(items).indexInMap, index);\\n    final int indicesSize = valToIndices.get(val).size();\\n    valToIndices.get(val).remove(indicesSize - 1);\\n    if (valToIndices.get(val).isEmpty())\\n      valToIndices.remove(val);\\n    items.set(index, last(items));\\n    items.remove(items.size() - 1);\\n    return true;\\n  }\\n\\n  /** Get a random element from the collection. */\\n  public int getRandom() {\\n    final int index = rand.nextInt(items.size());\\n    return items.get(index).val;\\n  }\\n\\n  private Map<Integer, List<Integer>> valToIndices = new HashMap<>();\\n  private List<Item> items = new ArrayList<>();\\n  private Random rand = new Random();\\n\\n  private int lastIndex(List<Integer> indices) {\\n    return indices.get(indices.size() - 1);\\n  }\\n\\n  private Item last(List<Item> items) {\\n    return items.get(items.size() - 1);\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767161,
                "title": "c-simple-approach-simple-to-understand-for-new-student",
                "content": "# Intuition\\nThis approach is very simple to understand but it is very poor in terms of time complexity.\\n\\n# Approach\\nINSERT()\\n    >In insert() i used a for loop to traverse through my vector and check if given value is present or not. If present return false\\nand insert the given element else return true and push the element also.\\n    >In remove() same approach is used as use in insert() just added a count to check keep check that if the element occurance is more than one, so i just have to remove only one element form vector.\\n    >And in getRandom() i just used a simple rand() funtion to get a number between 0 to container size.\\n\\n# Complexity\\n- Time complexity:\\n    738ms (Beats 5.30%) this is very bad but approach is easy.\\n\\n- Space complexity:\\n    101.20mb (Beats 98.12%) \\n\\n# Code\\n```\\nclass RandomizedCollection {\\n     \\npublic:\\n    vector<int> container = {};\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        \\n       \\n        \\n            for(int i = 0; i < container.size(); i++)\\n            {\\n                if(container[i] == val)\\n                {\\n                    container.push_back(val);\\n                    return false;\\n                }\\n            }\\n           \\n    container.push_back(val);\\n    return true;\\n    }\\n    \\n    bool remove(int val) {\\n        int count =0;\\n       \\n            for(int i = 0; i < container.size(); i++)\\n            {\\n                if(container[i] == val && count==0)\\n                {\\n                    container.erase (container.begin()+i);\\n                    count++;\\n                    return true;\\n                }\\n            }\\n            count =0;\\n        \\n    return false;\\n\\n    }\\n    \\n    int getRandom() {\\n        int ans = rand()%container.size();\\n        return container[ans];\\n      \\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedCollection {\\n     \\npublic:\\n    vector<int> container = {};\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        \\n       \\n        \\n            for(int i = 0; i < container.size(); i++)\\n            {\\n                if(container[i] == val)\\n                {\\n                    container.push_back(val);\\n                    return false;\\n                }\\n            }\\n           \\n    container.push_back(val);\\n    return true;\\n    }\\n    \\n    bool remove(int val) {\\n        int count =0;\\n       \\n            for(int i = 0; i < container.size(); i++)\\n            {\\n                if(container[i] == val && count==0)\\n                {\\n                    container.erase (container.begin()+i);\\n                    count++;\\n                    return true;\\n                }\\n            }\\n            count =0;\\n        \\n    return false;\\n\\n    }\\n    \\n    int getRandom() {\\n        int ans = rand()%container.size();\\n        return container[ans];\\n      \\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743267,
                "title": "c-solution-using-map-set-and-vector",
                "content": "**To have O(1) first I thought of using something like a map of values with a vector which stores all of its instances (positions) but removing from an vector would be very costly especially if index is not known.**\\n#### So I came up with the idea of using map of int and unordered set to store the indexes. As removing and adding values was less intensive.\\n#### The idea was fairly simple but there were few edge cases such in the remove function. So try to go through it carefully.\\n\\n```\\nclass RandomizedCollection {\\n    unordered_map<int, unordered_set<int>> map;\\n    vector<int>nums;\\npublic:\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        bool present=true;\\n        if(map.find(val) == map.end()) present=false;\\n        nums.push_back(val);\\n        map[val].insert(nums.size()-1);\\n        return !present;\\n    }\\n    \\n    bool remove(int val) {\\n    // not present\\n    if(map.find(val)==map.end() || map[val].empty() ){\\n        return false;\\n    }\\n    else{           \\n        auto first = map[val].begin();\\n        int firstindex = *(first);\\n        map[val].erase(firstindex);\\n        if (map[val].empty()) {\\n            map.erase(val);\\n        }\\n        if (firstindex != nums.size() - 1) {\\n            nums[firstindex]=nums.back(); // swapping the values\\n            int back = nums.back();\\n            map[back].erase(nums.size()-1);\\n            map[back].insert(firstindex);\\n        }\\n        nums.pop_back();\\n    }\\n    return true;\\n    }\\n    \\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n```\\nPeace",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    unordered_map<int, unordered_set<int>> map;\\n    vector<int>nums;\\npublic:\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        bool present=true;\\n        if(map.find(val) == map.end()) present=false;\\n        nums.push_back(val);\\n        map[val].insert(nums.size()-1);\\n        return !present;\\n    }\\n    \\n    bool remove(int val) {\\n    // not present\\n    if(map.find(val)==map.end() || map[val].empty() ){\\n        return false;\\n    }\\n    else{           \\n        auto first = map[val].begin();\\n        int firstindex = *(first);\\n        map[val].erase(firstindex);\\n        if (map[val].empty()) {\\n            map.erase(val);\\n        }\\n        if (firstindex != nums.size() - 1) {\\n            nums[firstindex]=nums.back(); // swapping the values\\n            int back = nums.back();\\n            map[back].erase(nums.size()-1);\\n            map[back].insert(firstindex);\\n        }\\n        nums.pop_back();\\n    }\\n    return true;\\n    }\\n    \\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740266,
                "title": "java-31-ms-keeping-track-of-next-insertion-index",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain a hashmap with <Element: [array of indexes of Element]>.  \\nKeep track of next insertion index `nextInsertionIndex` while doing insertions and deletions. \\n\\nFor insertion,\\nAlways increment `nextInsertionIndex` as duplicated are allowed. Modify the map accodingly.\\n\\nFor deletion,\\nSwap the last valid number (which will be `arr[nextInsertionIndex-1]`) with the element to be deleted, and decrement `nextInsertionIndex`.\\nNote that map modification becomes quite tricky here. We need to make sure the new values for the deleted element as well as the swapped element are consistent.\\n\\n\\n# Complexity\\n- Time complexity:\\ninsertion, getRandom: O(1)\\nDeletion worst case: O(1), \\naverage will be O(1) given the duplicates in the array are not that high\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass RandomizedCollection {\\n\\n    Map<Integer, List<Integer>> map;\\n    List<Integer> arr;\\n    Random random = new Random();\\n\\n    private int nextInsertionIndex;\\n    public RandomizedCollection() {\\n        map = new HashMap<>();\\n        arr = new ArrayList<>();\\n        nextInsertionIndex = 0;\\n    }\\n    \\n    public boolean insert(int val) {\\n        boolean result = false;\\n        if(map.containsKey(val)){\\n            result = false;\\n            map.get(val).add(nextInsertionIndex);\\n        } else {\\n            result = true;\\n            List<Integer> indexArr = new ArrayList<>();\\n            indexArr.add(nextInsertionIndex);\\n            map.put(val, indexArr);\\n        }\\n\\n        if(nextInsertionIndex < arr.size()){\\n            arr.set(nextInsertionIndex, val);\\n        } else {\\n            arr.add(val);\\n        }\\n        nextInsertionIndex++;\\n\\n        return result;\\n        \\n    }\\n    \\n    public boolean remove(int val) {\\n        boolean result = false;\\n        // System.out.println(map);\\n        if(!map.containsKey(val)){\\n            result = false;\\n        } else {\\n            result = true;\\n            int lastValidNumber = arr.get(nextInsertionIndex - 1);\\n            arr.set(nextInsertionIndex - 1, val);\\n\\n            List<Integer> indexForVal = map.get(val);\\n            int oneIndexForVal = indexForVal.get(0);\\n            arr.set(oneIndexForVal, lastValidNumber);\\n\\n            // now make sure the map remains consistent\\n            List<Integer> validNumIndexArray = map.get(lastValidNumber);\\n            for(int i=0;i<validNumIndexArray.size();i++){\\n                if(validNumIndexArray.get(i) == nextInsertionIndex - 1){\\n                    validNumIndexArray.set(i, oneIndexForVal); \\n                }\\n            }\\n            indexForVal.remove(new Integer(oneIndexForVal)); // with plain int, it triggers the index deletion. With new Integer(), it triggers the value deletion.\\n\\n            // en empty means the element is not longer in data structure. Remove the key\\n            if(indexForVal.size() == 0){\\n                map.remove(val);\\n            }\\n            nextInsertionIndex--;\\n            \\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int getRandom() {\\n        int index = random.nextInt(nextInsertionIndex);\\n        return arr.get(index);\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass RandomizedCollection {\\n\\n    Map<Integer, List<Integer>> map;\\n    List<Integer> arr;\\n    Random random = new Random();\\n\\n    private int nextInsertionIndex;\\n    public RandomizedCollection() {\\n        map = new HashMap<>();\\n        arr = new ArrayList<>();\\n        nextInsertionIndex = 0;\\n    }\\n    \\n    public boolean insert(int val) {\\n        boolean result = false;\\n        if(map.containsKey(val)){\\n            result = false;\\n            map.get(val).add(nextInsertionIndex);\\n        } else {\\n            result = true;\\n            List<Integer> indexArr = new ArrayList<>();\\n            indexArr.add(nextInsertionIndex);\\n            map.put(val, indexArr);\\n        }\\n\\n        if(nextInsertionIndex < arr.size()){\\n            arr.set(nextInsertionIndex, val);\\n        } else {\\n            arr.add(val);\\n        }\\n        nextInsertionIndex++;\\n\\n        return result;\\n        \\n    }\\n    \\n    public boolean remove(int val) {\\n        boolean result = false;\\n        // System.out.println(map);\\n        if(!map.containsKey(val)){\\n            result = false;\\n        } else {\\n            result = true;\\n            int lastValidNumber = arr.get(nextInsertionIndex - 1);\\n            arr.set(nextInsertionIndex - 1, val);\\n\\n            List<Integer> indexForVal = map.get(val);\\n            int oneIndexForVal = indexForVal.get(0);\\n            arr.set(oneIndexForVal, lastValidNumber);\\n\\n            // now make sure the map remains consistent\\n            List<Integer> validNumIndexArray = map.get(lastValidNumber);\\n            for(int i=0;i<validNumIndexArray.size();i++){\\n                if(validNumIndexArray.get(i) == nextInsertionIndex - 1){\\n                    validNumIndexArray.set(i, oneIndexForVal); \\n                }\\n            }\\n            indexForVal.remove(new Integer(oneIndexForVal)); // with plain int, it triggers the index deletion. With new Integer(), it triggers the value deletion.\\n\\n            // en empty means the element is not longer in data structure. Remove the key\\n            if(indexForVal.size() == 0){\\n                map.remove(val);\\n            }\\n            nextInsertionIndex--;\\n            \\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int getRandom() {\\n        int index = random.nextInt(nextInsertionIndex);\\n        return arr.get(index);\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730522,
                "title": "best-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedCollection {\\n    private ArrayList<Integer> nums;\\n    private HashMap<Integer, ArrayList<Integer>> map;\\n    private Random rand;\\n\\n    public RandomizedCollection() {\\n        nums = new ArrayList<>();\\n        map = new HashMap<>();\\n        rand = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        boolean res = !map.containsKey(val);\\n        if(!map.containsKey(val)){\\n            map.put(val, new ArrayList<>());\\n        }\\n        map.get(val).add(nums.size());\\n        nums.add(val);\\n        return res;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n        int idx = map.get(val).get(map.get(val).size() - 1);\\n        map.get(val).remove(map.get(val).size() - 1);\\n        if (map.get(val).isEmpty()) {\\n            map.remove(val);\\n        }\\n        if (idx != nums.size() - 1) {\\n            int last = nums.get(nums.size() - 1);\\n            nums.set(idx, last);\\n            map.get(last).set(map.get(last).indexOf(nums.size() - 1), idx);\\n        }\\n        nums.remove(nums.size() - 1);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n         return nums.get(rand.nextInt(nums.size()));\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    private ArrayList<Integer> nums;\\n    private HashMap<Integer, ArrayList<Integer>> map;\\n    private Random rand;\\n\\n    public RandomizedCollection() {\\n        nums = new ArrayList<>();\\n        map = new HashMap<>();\\n        rand = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        boolean res = !map.containsKey(val);\\n        if(!map.containsKey(val)){\\n            map.put(val, new ArrayList<>());\\n        }\\n        map.get(val).add(nums.size());\\n        nums.add(val);\\n        return res;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n        int idx = map.get(val).get(map.get(val).size() - 1);\\n        map.get(val).remove(map.get(val).size() - 1);\\n        if (map.get(val).isEmpty()) {\\n            map.remove(val);\\n        }\\n        if (idx != nums.size() - 1) {\\n            int last = nums.get(nums.size() - 1);\\n            nums.set(idx, last);\\n            map.get(last).set(map.get(last).indexOf(nums.size() - 1), idx);\\n        }\\n        nums.remove(nums.size() - 1);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n         return nums.get(rand.nextInt(nums.size()));\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730521,
                "title": "best-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedCollection {\\n    private ArrayList<Integer> nums;\\n    private HashMap<Integer, ArrayList<Integer>> map;\\n    private Random rand;\\n\\n    public RandomizedCollection() {\\n        nums = new ArrayList<>();\\n        map = new HashMap<>();\\n        rand = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        boolean res = !map.containsKey(val);\\n        if(!map.containsKey(val)){\\n            map.put(val, new ArrayList<>());\\n        }\\n        map.get(val).add(nums.size());\\n        nums.add(val);\\n        return res;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n        int idx = map.get(val).get(map.get(val).size() - 1);\\n        map.get(val).remove(map.get(val).size() - 1);\\n        if (map.get(val).isEmpty()) {\\n            map.remove(val);\\n        }\\n        if (idx != nums.size() - 1) {\\n            int last = nums.get(nums.size() - 1);\\n            nums.set(idx, last);\\n            map.get(last).set(map.get(last).indexOf(nums.size() - 1), idx);\\n        }\\n        nums.remove(nums.size() - 1);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n         return nums.get(rand.nextInt(nums.size()));\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    private ArrayList<Integer> nums;\\n    private HashMap<Integer, ArrayList<Integer>> map;\\n    private Random rand;\\n\\n    public RandomizedCollection() {\\n        nums = new ArrayList<>();\\n        map = new HashMap<>();\\n        rand = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        boolean res = !map.containsKey(val);\\n        if(!map.containsKey(val)){\\n            map.put(val, new ArrayList<>());\\n        }\\n        map.get(val).add(nums.size());\\n        nums.add(val);\\n        return res;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n        int idx = map.get(val).get(map.get(val).size() - 1);\\n        map.get(val).remove(map.get(val).size() - 1);\\n        if (map.get(val).isEmpty()) {\\n            map.remove(val);\\n        }\\n        if (idx != nums.size() - 1) {\\n            int last = nums.get(nums.size() - 1);\\n            nums.set(idx, last);\\n            map.get(last).set(map.get(last).indexOf(nums.size() - 1), idx);\\n        }\\n        nums.remove(nums.size() - 1);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n         return nums.get(rand.nextInt(nums.size()));\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726722,
                "title": "commented-o-1-solution-with-dict-key-set-for-insert-and-remove-list-for-random",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsearch for all O(1) methods. look at insert, remove and random seperately.\\nThen bridge them.\\n\\nall lines commented\\n\\n# Complexity\\n\\n- Time complexity:\\nO(1) - all operations are constant in time\\n\\n\\n- Space complexity:\\nO(n) - linear for dict, set and list. No extra objects created\\n\\n\\n\\n# Code\\n```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.item_dict = dict() # needed for O(1) insert and remove (values are the keys of dict())\\n        self.item_list = list() # needed for O(1) random selection\\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.item_dict: # O(1) if value present in dict (cant have 0 occurances)\\n            self.item_dict[val].add(len(self.item_list)) # O(1) store new list index of value\\n            self.item_list.append(val) # O(1) add value to list\\n            return False\\n        else:\\n            self.item_dict[val] = {len(self.item_list)} # O(1) k-v pair where v is set of indexes\\n            self.item_list.append(val) # O(1) add value to list\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.item_dict:\\n            swap_val = self.item_list[-1] # O(1) take last val in list\\n            ind = self.item_dict[val].pop() # O(1) delete and assign an index from set of indexes\\n            self.item_list[ind] = swap_val # O(1) put swap_val in place of val\\n            self.item_list.pop() # O(1) remove last value from list\\n            self.item_dict[swap_val].add(ind) # O(1) add swap_val\\'s new index to index set\\n            self.item_dict[swap_val].discard(len(self.item_list)) # O(1) remove index of poped val\\n            if len(self.item_dict[val]) == 0: # O(1) k-v pair has zero occurances\\n                del self.item_dict[val] # O(1) delete k-v pair\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        item = random.choice(self.item_list) # O(1)\\n        return item\\n        \\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.item_dict = dict() # needed for O(1) insert and remove (values are the keys of dict())\\n        self.item_list = list() # needed for O(1) random selection\\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.item_dict: # O(1) if value present in dict (cant have 0 occurances)\\n            self.item_dict[val].add(len(self.item_list)) # O(1) store new list index of value\\n            self.item_list.append(val) # O(1) add value to list\\n            return False\\n        else:\\n            self.item_dict[val] = {len(self.item_list)} # O(1) k-v pair where v is set of indexes\\n            self.item_list.append(val) # O(1) add value to list\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.item_dict:\\n            swap_val = self.item_list[-1] # O(1) take last val in list\\n            ind = self.item_dict[val].pop() # O(1) delete and assign an index from set of indexes\\n            self.item_list[ind] = swap_val # O(1) put swap_val in place of val\\n            self.item_list.pop() # O(1) remove last value from list\\n            self.item_dict[swap_val].add(ind) # O(1) add swap_val\\'s new index to index set\\n            self.item_dict[swap_val].discard(len(self.item_list)) # O(1) remove index of poped val\\n            if len(self.item_dict[val]) == 0: # O(1) k-v pair has zero occurances\\n                del self.item_dict[val] # O(1) delete k-v pair\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        item = random.choice(self.item_list) # O(1)\\n        return item\\n        \\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707785,
                "title": "java-solution-using-hashmap-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedCollection {\\n    HashMap<Integer, HashSet<Integer>> map;\\n    ArrayList<Integer> list;\\n    Random r;\\n    public RandomizedCollection() {\\n        map= new HashMap<>();\\n        list= new ArrayList<>();\\n        r= new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        list.add(val);\\n        if(map.containsKey(val)){\\n\\n            HashSet<Integer> set= map.get(val);\\n            set.add(list.size()-1);\\n            map.put(val, set);\\n            return false;\\n\\n        }\\n            HashSet<Integer> set= new HashSet<>();\\n            set.add(list.size()-1);\\n            map.put(val, set);\\n            return true;\\n        \\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)){\\n            return false;\\n        }\\n        int vidx= map.get(val).iterator().next();\\n        int lidx= list.size()-1;\\n        int vlidx= list.get(lidx);\\n\\n        list.set(lidx,val);\\n        list.set(vidx,vlidx);\\n         list.remove(lidx);\\n        map.get(val).remove(vidx);\\n\\n        if(map.get(val).size()==0){\\n            map.remove(val);\\n        }\\n        if(map.containsKey(vlidx)){\\n            \\n            map.get(vlidx).remove(lidx);\\n            map.get(vlidx).add(vidx);\\n        }\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        int idx= r.nextInt(list.size());\\n        return list.get(idx);\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    HashMap<Integer, HashSet<Integer>> map;\\n    ArrayList<Integer> list;\\n    Random r;\\n    public RandomizedCollection() {\\n        map= new HashMap<>();\\n        list= new ArrayList<>();\\n        r= new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        list.add(val);\\n        if(map.containsKey(val)){\\n\\n            HashSet<Integer> set= map.get(val);\\n            set.add(list.size()-1);\\n            map.put(val, set);\\n            return false;\\n\\n        }\\n            HashSet<Integer> set= new HashSet<>();\\n            set.add(list.size()-1);\\n            map.put(val, set);\\n            return true;\\n        \\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)){\\n            return false;\\n        }\\n        int vidx= map.get(val).iterator().next();\\n        int lidx= list.size()-1;\\n        int vlidx= list.get(lidx);\\n\\n        list.set(lidx,val);\\n        list.set(vidx,vlidx);\\n         list.remove(lidx);\\n        map.get(val).remove(vidx);\\n\\n        if(map.get(val).size()==0){\\n            map.remove(val);\\n        }\\n        if(map.containsKey(vlidx)){\\n            \\n            map.get(vlidx).remove(lidx);\\n            map.get(vlidx).add(vidx);\\n        }\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        int idx= r.nextInt(list.size());\\n        return list.get(idx);\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704277,
                "title": "easy-go-solution-with-a-simple-explanation",
                "content": "# Intuition\\nGetRandom linearlly must be an array. Now let see how to solve the rest.\\n\\n# Approach\\nFirst step is understanding that GetRandom forces us to have an array of all values. Than, we should think how to implement both `Insert` and `Remove` in $$O(1)$$ complexity.\\nImplementing `Insert` in $$O(1)$$ complexity is stays just appending for now.\\n\\nWhlie implementing `Remove` seems tricky. We need to find the value in $$O(1)$$ instead of $$O(n)$$ and remove it from an array in $$O(1)$$ as well. To accomplish this, we utilize the understanding that both appending and removing from the end of an array are $$O(1)$$ operations.\\nTo solve the finding of a val proble, we use the map. \\nTo solve the removing, we move the value from the last index to be the value in the removed index.\\nDuring both of those operations we have to keep the map updated.\\n\\n### indices has another array\\nTo update the array of indices, I perform a binary insert to a sorted array. This is not $$O(1)$$ at all, and the better approach would be to have a `set` of all the indices that can both `pop` and `push` a value in $$O(1)$$.\\n\\n# Code\\n```\\n\\ntype RandomizedCollection struct {\\n    collection []int\\n    indices map[int][]int\\n}\\n\\n\\nfunc Constructor() RandomizedCollection {\\n    return RandomizedCollection{\\n        collection: make([]int, 0),\\n        indices: make(map[int][]int, 0),\\n    }\\n}\\n\\nfunc (this *RandomizedCollection) Insert(val int) bool {\\n    _, exists := this.indices[val]\\n    if !exists {\\n        this.indices[val] = []int{}\\n    }\\n    this.indices[val] = append(this.indices[val], len(this.collection))\\n    this.collection = append(this.collection, val)\\n    return !exists\\n}\\n\\nfunc binsert(ts []int, t int) []int {\\n    // Should be a binary search    \\n    i := sort.Search(len(ts), func(i int) bool { return ts[i] >= t })  \\n    \\n    if i == len(ts) {\\n        return append(ts, t)\\n    }\\n    ts = append(ts[:i+1], ts[i:]...)\\n    ts[i] = t\\n    return ts\\n}\\n\\nfunc (this *RandomizedCollection) Remove(val int) bool {\\n    // fmt.Println(\"before remove \",val,\". Map -\",this.indices,\" data - \",this.collection)\\n    indices, exists := this.indices[val]\\n    if !exists {\\n        return exists\\n    }\\n    l := len(indices)-1\\n    idx := indices[l]\\n    if l == 0 {\\n        delete(this.indices, val)\\n    } else {\\n        this.indices[val] = indices[:l]\\n    }\\n    lastIdx := len(this.collection) - 1\\n    if idx != lastIdx {\\n        num := this.collection[lastIdx]\\n        this.indices[num] = binsert(this.indices[num][:len(this.indices[num])-1], idx)\\n        this.collection[idx] = num\\n    }\\n    this.collection = this.collection[:lastIdx]\\n    // fmt.Println(\"after remove \",val,\". Map -\",this.indices,\" data - \",this.collection)\\n    return exists\\n}\\n\\n\\nfunc (this *RandomizedCollection) GetRandom() int {\\n    return this.collection[rand.Intn(len(this.collection))]\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\n\\ntype RandomizedCollection struct {\\n    collection []int\\n    indices map[int][]int\\n}\\n\\n\\nfunc Constructor() RandomizedCollection {\\n    return RandomizedCollection{\\n        collection: make([]int, 0),\\n        indices: make(map[int][]int, 0),\\n    }\\n}\\n\\nfunc (this *RandomizedCollection) Insert(val int) bool {\\n    _, exists := this.indices[val]\\n    if !exists {\\n        this.indices[val] = []int{}\\n    }\\n    this.indices[val] = append(this.indices[val], len(this.collection))\\n    this.collection = append(this.collection, val)\\n    return !exists\\n}\\n\\nfunc binsert(ts []int, t int) []int {\\n    // Should be a binary search    \\n    i := sort.Search(len(ts), func(i int) bool { return ts[i] >= t })  \\n    \\n    if i == len(ts) {\\n        return append(ts, t)\\n    }\\n    ts = append(ts[:i+1], ts[i:]...)\\n    ts[i] = t\\n    return ts\\n}\\n\\nfunc (this *RandomizedCollection) Remove(val int) bool {\\n    // fmt.Println(\"before remove \",val,\". Map -\",this.indices,\" data - \",this.collection)\\n    indices, exists := this.indices[val]\\n    if !exists {\\n        return exists\\n    }\\n    l := len(indices)-1\\n    idx := indices[l]\\n    if l == 0 {\\n        delete(this.indices, val)\\n    } else {\\n        this.indices[val] = indices[:l]\\n    }\\n    lastIdx := len(this.collection) - 1\\n    if idx != lastIdx {\\n        num := this.collection[lastIdx]\\n        this.indices[num] = binsert(this.indices[num][:len(this.indices[num])-1], idx)\\n        this.collection[idx] = num\\n    }\\n    this.collection = this.collection[:lastIdx]\\n    // fmt.Println(\"after remove \",val,\". Map -\",this.indices,\" data - \",this.collection)\\n    return exists\\n}\\n\\n\\nfunc (this *RandomizedCollection) GetRandom() int {\\n    return this.collection[rand.Intn(len(this.collection))]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704074,
                "title": "unordered-map-set",
                "content": "```\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int,int> mpp;\\n    unordered_map<int,set<int>> index; //val,index\\n    vector<int> arr;\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        bool flag=false;\\n        if(index.find(val)==index.end()) flag=true;\\n        arr.push_back(val);\\n        index[val].insert(arr.size()-1);\\n\\n        return flag;\\n    }\\n    \\n    bool remove(int val) {\\n        auto it= index.find(val);\\n        if(it!=index.end()){\\n            auto pos=*it->second.begin(); // position from the first of the set\\n            it->second.erase(it->second.begin()); //erasing the pos from the set\\n            arr[pos]=arr.back(); //replacing the pos with the last element of the vec\\n            index[arr[pos]].insert(pos);\\n            index[arr[pos]].erase(arr.size()-1); //erasing the old index as the last element has been shifted to pos\\n            arr.pop_back();\\n            if(it->second.size()==0) index.erase(it);\\n            return true;\\n         \\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        return arr[rand()%arr.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    unordered_map<int,int> mpp;\\n    unordered_map<int,set<int>> index; //val,index\\n    vector<int> arr;\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        bool flag=false;\\n        if(index.find(val)==index.end()) flag=true;\\n        arr.push_back(val);\\n        index[val].insert(arr.size()-1);\\n\\n        return flag;\\n    }\\n    \\n    bool remove(int val) {\\n        auto it= index.find(val);\\n        if(it!=index.end()){\\n            auto pos=*it->second.begin(); // position from the first of the set\\n            it->second.erase(it->second.begin()); //erasing the pos from the set\\n            arr[pos]=arr.back(); //replacing the pos with the last element of the vec\\n            index[arr[pos]].insert(pos);\\n            index[arr[pos]].erase(arr.size()-1); //erasing the old index as the last element has been shifted to pos\\n            arr.pop_back();\\n            if(it->second.size()==0) index.erase(it);\\n            return true;\\n         \\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        return arr[rand()%arr.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695560,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass RandomizedCollection {\\n\\n    Map <Integer,LinkedList<Integer>> appearances; // locations(index list) of a talent in the main list\\n    Set<Integer> deleted; // indexes deleted from the main list\\n    List<Integer> list; // main list\\n    \\n    public RandomizedCollection() {\\n        list = new ArrayList();\\n        deleted = new HashSet();\\n        appearances= new HashMap();\\n    }\\n    \\n    public boolean insert(int val) {\\n        int insertIndex = -1; \\n        if (deleted.isEmpty()){\\n            list.add(val);\\n            insertIndex = list.size()-1;\\n        }\\n        else {\\n            insertIndex= deleted.iterator().next();\\n            deleted.remove(insertIndex);\\n            list.set(insertIndex,val);\\n        }\\n        appearances.putIfAbsent(val,new LinkedList());\\n        appearances.get(val).add(insertIndex);\\n        return (appearances.get(val).size() == 1);\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (!appearances.containsKey(val) || appearances.get(val).isEmpty()) return false;\\n        LinkedList<Integer> valsAppearances = appearances.get(val);\\n        deleted.add(valsAppearances.remove());\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        Random r = new Random();\\n        while (true){\\n            int index = r.nextInt(list.size());\\n            if (!deleted.contains(index)) return list.get(index);\\n        }\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedCollection {\\n\\n    Map <Integer,LinkedList<Integer>> appearances; // locations(index list) of a talent in the main list\\n    Set<Integer> deleted; // indexes deleted from the main list\\n    List<Integer> list; // main list\\n    \\n    public RandomizedCollection() {\\n        list = new ArrayList();\\n        deleted = new HashSet();\\n        appearances= new HashMap();\\n    }\\n    \\n    public boolean insert(int val) {\\n        int insertIndex = -1; \\n        if (deleted.isEmpty()){\\n            list.add(val);\\n            insertIndex = list.size()-1;\\n        }\\n        else {\\n            insertIndex= deleted.iterator().next();\\n            deleted.remove(insertIndex);\\n            list.set(insertIndex,val);\\n        }\\n        appearances.putIfAbsent(val,new LinkedList());\\n        appearances.get(val).add(insertIndex);\\n        return (appearances.get(val).size() == 1);\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (!appearances.containsKey(val) || appearances.get(val).isEmpty()) return false;\\n        LinkedList<Integer> valsAppearances = appearances.get(val);\\n        deleted.add(valsAppearances.remove());\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        Random r = new Random();\\n        while (true){\\n            int index = r.nextInt(list.size());\\n            if (!deleted.contains(index)) return list.get(index);\\n        }\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670947,
                "title": "easy-c-solution-faster-than-98-64",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncan be solved by <strong>index</strong> tracking\\n\\n# Approach\\nits solved using <strong>unordered_map</strong> and <strong>priority_queue</strong>\\nwe keep the indecies in priority queue of an element\\n- when its called to insert an element we simply insert the index on the queue\\n- and when its called to remove an element we simply swap the index of val with the last element of the vector, and remove it\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedCollection {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,priority_queue<int>> o;\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        bool f;\\n        if(o.count(val))f=false;\\n        else f=true;\\n        o[val].push(v.size());\\n        //if(val==40)cout<<o[30][0]<<endl;\\n        v.push_back(val);\\n        return f;\\n    }\\n    \\n    bool remove(int val) {\\n        if(!o.count(val))return false;\\n        int lst=v[v.size()-1];\\n\\n        int id=o[val].top();\\n        \\n        o[val].pop();\\n        o[lst].push(id);\\n        o[lst].pop();\\n\\n        v[id]=lst;\\n        \\n        v.pop_back();\\n\\n        if(o[val].empty())o.erase(val);\\n        //if(v.size()==1 && o[40].size())cout<<o[40][0]<<endl;\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,priority_queue<int>> o;\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        bool f;\\n        if(o.count(val))f=false;\\n        else f=true;\\n        o[val].push(v.size());\\n        //if(val==40)cout<<o[30][0]<<endl;\\n        v.push_back(val);\\n        return f;\\n    }\\n    \\n    bool remove(int val) {\\n        if(!o.count(val))return false;\\n        int lst=v[v.size()-1];\\n\\n        int id=o[val].top();\\n        \\n        o[val].pop();\\n        o[lst].push(id);\\n        o[lst].pop();\\n\\n        v[id]=lst;\\n        \\n        v.pop_back();\\n\\n        if(o[val].empty())o.erase(val);\\n        //if(v.size()==1 && o[40].size())cout<<o[40][0]<<endl;\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3666252,
                "title": "typescript-solution-a-combination-of-an-array-and-a-map-hash-map-data-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe array `values` is used to store the values in the collection. The indices of each value are stored in the map `indices`, where the keys are the values and the values are sets containing the indices of each occurrence of the value in the array. This allows for efficient insertion, removal, and retrieval of random elements. The insert operation has an average time complexity of O(1) since it only involves appending a value to the array and updating the map.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(1)$ since `insert`, `remove` and `getRandom` all ahve O(1) operation. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n + m)$ where n is the number of elements in the collection and m is the number of unique elements.\\n\\n# Code\\n```\\nclass RandomizedCollection {\\n  private values: number[];\\n  private indices: Map<number, Set<number>>;\\n\\n  constructor() {\\n    this.values = [];\\n    this.indices = new Map<number, Set<number>>();\\n  }\\n\\n  public insert(val: number): boolean {\\n    const isNew = !this.indices.has(val);\\n    if (!isNew) {\\n      this.indices.get(val).add(this.values.length);\\n    } else {\\n      this.indices.set(val, new Set<number>([this.values.length]));\\n    }\\n    this.values.push(val);\\n    return isNew;\\n  }\\n\\n  public remove(val: number): boolean {\\n    if (!this.indices.has(val)) {\\n      return false;\\n    }\\n    const removeIndex = this.indices.get(val).values().next().value;\\n    const lastIndex = this.values.length - 1;\\n    const lastValue = this.values[lastIndex];\\n    this.values[removeIndex] = lastValue;\\n    this.indices.get(val).delete(removeIndex);\\n    this.indices.get(lastValue).delete(lastIndex);\\n    if (removeIndex !== lastIndex) {\\n      this.indices.get(lastValue).add(removeIndex);\\n    }\\n    if (this.indices.get(val).size === 0) {\\n      this.indices.delete(val);\\n    }\\n    this.values.pop();\\n    return true;\\n  }\\n\\n  public getRandom(): number {\\n    const randomIndex = Math.floor(Math.random() * this.values.length);\\n    return this.values[randomIndex];\\n  }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * var obj = new RandomizedCollection()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass RandomizedCollection {\\n  private values: number[];\\n  private indices: Map<number, Set<number>>;\\n\\n  constructor() {\\n    this.values = [];\\n    this.indices = new Map<number, Set<number>>();\\n  }\\n\\n  public insert(val: number): boolean {\\n    const isNew = !this.indices.has(val);\\n    if (!isNew) {\\n      this.indices.get(val).add(this.values.length);\\n    } else {\\n      this.indices.set(val, new Set<number>([this.values.length]));\\n    }\\n    this.values.push(val);\\n    return isNew;\\n  }\\n\\n  public remove(val: number): boolean {\\n    if (!this.indices.has(val)) {\\n      return false;\\n    }\\n    const removeIndex = this.indices.get(val).values().next().value;\\n    const lastIndex = this.values.length - 1;\\n    const lastValue = this.values[lastIndex];\\n    this.values[removeIndex] = lastValue;\\n    this.indices.get(val).delete(removeIndex);\\n    this.indices.get(lastValue).delete(lastIndex);\\n    if (removeIndex !== lastIndex) {\\n      this.indices.get(lastValue).add(removeIndex);\\n    }\\n    if (this.indices.get(val).size === 0) {\\n      this.indices.delete(val);\\n    }\\n    this.values.pop();\\n    return true;\\n  }\\n\\n  public getRandom(): number {\\n    const randomIndex = Math.floor(Math.random() * this.values.length);\\n    return this.values[randomIndex];\\n  }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * var obj = new RandomizedCollection()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661709,
                "title": "easy-to-understand-beats-94-in-memory-and-12-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedCollection\\n{\\npublic:\\n    vector<int> temp;\\n    unordered_map<int, int> s;\\n    RandomizedCollection()\\n    {\\n        // no code\\n    }\\n\\n    bool insert(int val)\\n    {\\n        if (s[val] == 0)\\n        {\\n            temp.push_back(val);\\n            s[val]++;\\n            return true;\\n        }\\n        else if (s[val] > 0)\\n        {\\n            temp.push_back(val);\\n            s[val]++;\\n            return false;\\n        }\\n        return false;\\n    }\\n\\n    bool remove(int val)\\n    {\\n        if (s[val] > 0)\\n        {\\n            auto it = find(temp.begin(), temp.end(), val);\\n            temp.erase(it);\\n            s[val]--;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    int getRandom()\\n    {\\n        return temp[rand() % temp.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedCollection\\n{\\npublic:\\n    vector<int> temp;\\n    unordered_map<int, int> s;\\n    RandomizedCollection()\\n    {\\n        // no code\\n    }\\n\\n    bool insert(int val)\\n    {\\n        if (s[val] == 0)\\n        {\\n            temp.push_back(val);\\n            s[val]++;\\n            return true;\\n        }\\n        else if (s[val] > 0)\\n        {\\n            temp.push_back(val);\\n            s[val]++;\\n            return false;\\n        }\\n        return false;\\n    }\\n\\n    bool remove(int val)\\n    {\\n        if (s[val] > 0)\\n        {\\n            auto it = find(temp.begin(), temp.end(), val);\\n            temp.erase(it);\\n            s[val]--;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    int getRandom()\\n    {\\n        return temp[rand() % temp.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658176,
                "title": "anyone-please-let-me-know-why-my-solution-is-not-working",
                "content": "\\n\\n# Code\\n```\\nclass RandomizedCollection {\\nprivate:\\n    unordered_map<int,int> mp;\\n    vector<pair<int,int>> ans;\\npublic:\\n    RandomizedCollection() {\\n    }\\n    \\n    bool insert(int val) {\\n        if(mp.find(val)==mp.end()){\\n            ans.push_back({val, 1});\\n            mp[val] = ans.size()-1;\\n            return true;\\n        }\\n\\n        ans[mp[val]].second++;\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val)==mp.end()) return false;\\n        int index = mp[val];\\n        if(ans[index].second ==1){\\n            mp[ans[ans.size()-1].first] = index;\\n            ans[index] = ans[ans.size()-1];\\n            ans.pop_back();\\n            mp.erase(val);\\n        }\\n        else {\\n           ans[index].second--;\\n        }\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        int random = rand() % ans.size();\\n        return ans[random].first;\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedCollection {\\nprivate:\\n    unordered_map<int,int> mp;\\n    vector<pair<int,int>> ans;\\npublic:\\n    RandomizedCollection() {\\n    }\\n    \\n    bool insert(int val) {\\n        if(mp.find(val)==mp.end()){\\n            ans.push_back({val, 1});\\n            mp[val] = ans.size()-1;\\n            return true;\\n        }\\n\\n        ans[mp[val]].second++;\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val)==mp.end()) return false;\\n        int index = mp[val];\\n        if(ans[index].second ==1){\\n            mp[ans[ans.size()-1].first] = index;\\n            ans[index] = ans[ans.size()-1];\\n            ans.pop_back();\\n            mp.erase(val);\\n        }\\n        else {\\n           ans[index].second--;\\n        }\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        int random = rand() % ans.size();\\n        return ans[random].first;\\n    }\\n};\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection* obj = new RandomizedCollection();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652438,
                "title": "simple-python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.d=defaultdict(int)\\n        self.li=[]\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        self.li.append(val)\\n        self.d[val]+=1\\n        if self.d[val]!=1:\\n            return False\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if self.d[val]!=0:\\n            self.li.remove(val)\\n            self.d[val]-=1\\n            return True\\n        return False\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.li)\\n        \\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass RandomizedCollection:\\n\\n    def __init__(self):\\n        self.d=defaultdict(int)\\n        self.li=[]\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        self.li.append(val)\\n        self.d[val]+=1\\n        if self.d[val]!=1:\\n            return False\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if self.d[val]!=0:\\n            self.li.remove(val)\\n            self.d[val]-=1\\n            return True\\n        return False\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.li)\\n        \\n\\n\\n# Your RandomizedCollection object will be instantiated and called as such:\\n# obj = RandomizedCollection()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635432,
                "title": "c-easy-map-and-vector-erase",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedCollection {\\npublic:\\n    vector<int>v;\\n    unordered_map<int,int>mp;\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n       if(mp[val] == 0) \\n        {\\n            v.push_back(val);\\n            mp[val]++; \\n            return true;\\n        }\\n        else if(mp[val] > 0)  \\n        {\\n            v.push_back(val);\\n            mp[val]++;\\n            return false;\\n        }\\n        return false;  \\n    }\\n    \\n    bool remove(int val) {\\n       if(mp[val] > 0) \\n         {\\n             auto it = find(v.begin(),v.end(),val);\\n             v.erase(it);\\n             mp[val]--;\\n             return true;\\n         }\\n         return false; \\n    }\\n    \\n    int getRandom() {\\n         return v[rand()%v.size()];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedCollection {\\npublic:\\n    vector<int>v;\\n    unordered_map<int,int>mp;\\n    RandomizedCollection() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n       if(mp[val] == 0) \\n        {\\n            v.push_back(val);\\n            mp[val]++; \\n            return true;\\n        }\\n        else if(mp[val] > 0)  \\n        {\\n            v.push_back(val);\\n            mp[val]++;\\n            return false;\\n        }\\n        return false;  \\n    }\\n    \\n    bool remove(int val) {\\n       if(mp[val] > 0) \\n         {\\n             auto it = find(v.begin(),v.end(),val);\\n             v.erase(it);\\n             mp[val]--;\\n             return true;\\n         }\\n         return false; \\n    }\\n    \\n    int getRandom() {\\n         return v[rand()%v.size()];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593901,
                "title": "using-arraylist-and-hashset-in-java-faster-34ms",
                "content": "All you need is to maintain a set containing indices of the elements and whenever the elements needs to be removed just replace that with the last element i.e the current value of the global count variable. \\n\\nHere\\'s the solution in Java \\n```\\nclass RandomizedCollection {\\n\\n    Map<Integer, Set<Integer>> indices;\\n    List<Integer> elements;\\n    int counter;\\n    Random rand;\\n    \\n    public RandomizedCollection() {\\n        indices = new HashMap<>();\\n        elements = new ArrayList<>();\\n        counter = 0;\\n        rand = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        \\n        if(indices.containsKey(val)) {\\n            indices.get(val).add(counter++);\\n            elements.add(val);\\n            return false;\\n        }\\n        indices.put(val, new HashSet<>());\\n        indices.get(val).add(counter++);\\n        elements.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        \\n        if(indices.containsKey(val)) {\\n            int first = indices.get(val).stream().findFirst().get(); \\n            int last = counter - 1; \\n            int lastElement = elements.get(last); \\n            indices.get(lastElement).remove(last);\\n            indices.get(val).remove(first);\\n            if(first != last) {    \\n                indices.get(lastElement).add(first);\\n            }\\n            \\n            counter--;\\n            // Now swap the elements from the list and delete the last element\\n            if(indices.get(val).size() == 0) indices.remove(val);\\n            elements.set(last, val);\\n            elements.set(first, lastElement);\\n            elements.remove(last);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        return elements.get( rand.nextInt(elements.size()) );\\n    \\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass RandomizedCollection {\\n\\n    Map<Integer, Set<Integer>> indices;\\n    List<Integer> elements;\\n    int counter;\\n    Random rand;\\n    \\n    public RandomizedCollection() {\\n        indices = new HashMap<>();\\n        elements = new ArrayList<>();\\n        counter = 0;\\n        rand = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        \\n        if(indices.containsKey(val)) {\\n            indices.get(val).add(counter++);\\n            elements.add(val);\\n            return false;\\n        }\\n        indices.put(val, new HashSet<>());\\n        indices.get(val).add(counter++);\\n        elements.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        \\n        if(indices.containsKey(val)) {\\n            int first = indices.get(val).stream().findFirst().get(); \\n            int last = counter - 1; \\n            int lastElement = elements.get(last); \\n            indices.get(lastElement).remove(last);\\n            indices.get(val).remove(first);\\n            if(first != last) {    \\n                indices.get(lastElement).add(first);\\n            }\\n            \\n            counter--;\\n            // Now swap the elements from the list and delete the last element\\n            if(indices.get(val).size() == 0) indices.remove(val);\\n            elements.set(last, val);\\n            elements.set(first, lastElement);\\n            elements.remove(last);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        return elements.get( rand.nextInt(elements.size()) );\\n    \\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * RandomizedCollection obj = new RandomizedCollection();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590766,
                "title": "php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedCollection {\\n    private $values = [];\\n    /**\\n     */\\n    function __construct() {\\n    }\\n  \\n    /**\\n     * @param Integer $val\\n     * @return Boolean\\n    \\n     */\\n    function insert($val) {\\n        $found = in_array($val, $this->values);\\n        $this->values[] = $val;\\n        return $found ? false : true;\\n    }\\n  \\n    /**\\n     * @param Integer $val\\n     * @return Boolean\\n     */\\n    function remove($val) {\\n        if (in_array($val, $this->values)) {\\n            $key = array_search($val, $this->values);\\n            unset($this->values[$key]);\\n            return true;\\n        }\\n        return false;\\n    }\\n  \\n    /**\\n     * @return Integer\\n     */\\n    function getRandom() {\\n        return $this->values[array_rand($this->values)];\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * $obj = RandomizedCollection();\\n * $ret_1 = $obj->insert($val);\\n * $ret_2 = $obj->remove($val);\\n * $ret_3 = $obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    private $values = [];\\n    /**\\n     */\\n    function __construct() {\\n    }\\n  \\n    /**\\n     * @param Integer $val\\n     * @return Boolean\\n    \\n     */\\n    function insert($val) {\\n        $found = in_array($val, $this->values);\\n        $this->values[] = $val;\\n        return $found ? false : true;\\n    }\\n  \\n    /**\\n     * @param Integer $val\\n     * @return Boolean\\n     */\\n    function remove($val) {\\n        if (in_array($val, $this->values)) {\\n            $key = array_search($val, $this->values);\\n            unset($this->values[$key]);\\n            return true;\\n        }\\n        return false;\\n    }\\n  \\n    /**\\n     * @return Integer\\n     */\\n    function getRandom() {\\n        return $this->values[array_rand($this->values)];\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * $obj = RandomizedCollection();\\n * $ret_1 = $obj->insert($val);\\n * $ret_2 = $obj->remove($val);\\n * $ret_3 = $obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581771,
                "title": "solution",
                "content": "\\n# Code\\n```\\nimport random\\n\\nclass RandomizedCollection:\\n    def __init__(self):\\n        self.collection = []\\n        self.indices = {}\\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.indices:\\n            self.indices[val] = set()\\n        self.indices[val].add(len(self.collection))\\n        self.collection.append(val)\\n        return len(self.indices[val]) == 1\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.indices:\\n            index = self.indices[val].pop()\\n            last_element = self.collection[-1]\\n            if index != len(self.collection) - 1:\\n                self.collection[index] = last_element\\n                self.indices[last_element].remove(len(self.collection) - 1)\\n                self.indices[last_element].add(index)\\n            if not self.indices[val]:\\n                del self.indices[val]\\n            self.collection.pop()\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.collection)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport random\\n\\nclass RandomizedCollection:\\n    def __init__(self):\\n        self.collection = []\\n        self.indices = {}\\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.indices:\\n            self.indices[val] = set()\\n        self.indices[val].add(len(self.collection))\\n        self.collection.append(val)\\n        return len(self.indices[val]) == 1\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.indices:\\n            index = self.indices[val].pop()\\n            last_element = self.collection[-1]\\n            if index != len(self.collection) - 1:\\n                self.collection[index] = last_element\\n                self.indices[last_element].remove(len(self.collection) - 1)\\n                self.indices[last_element].add(index)\\n            if not self.indices[val]:\\n                del self.indices[val]\\n            self.collection.pop()\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.collection)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580127,
                "title": "my-first-hard-yaay",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedCollection {\\n    set: number[] = [];\\n\\n    insert(val: number): boolean {\\n        const res = !this.set.includes(val);\\n        this.set.push(val);\\n        return res;\\n    }\\n\\n    remove(val: number): boolean {\\n        const index = this.set.indexOf(val);\\n        if(index === -1) {\\n            return false;\\n        }\\n\\n        this.set.splice(index, 1);\\n        return true;\\n    }\\n\\n    getRandom(): number {\\n        return this.set[Math.floor(Math.random() * this.set.length)];\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * var obj = new RandomizedCollection()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass RandomizedCollection {\\n    set: number[] = [];\\n\\n    insert(val: number): boolean {\\n        const res = !this.set.includes(val);\\n        this.set.push(val);\\n        return res;\\n    }\\n\\n    remove(val: number): boolean {\\n        const index = this.set.indexOf(val);\\n        if(index === -1) {\\n            return false;\\n        }\\n\\n        this.set.splice(index, 1);\\n        return true;\\n    }\\n\\n    getRandom(): number {\\n        return this.set[Math.floor(Math.random() * this.set.length)];\\n    }\\n}\\n\\n/**\\n * Your RandomizedCollection object will be instantiated and called as such:\\n * var obj = new RandomizedCollection()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567258,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1568629,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1569748,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1572982,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1572542,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1571655,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 2037163,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 2037158,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1944536,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1936252,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1567258,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1568629,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1569748,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1572982,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1572542,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1571655,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 2037163,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 2037158,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1944536,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            },
            {
                "id": 1936252,
                "content": [
                    {
                        "username": "Tanych",
                        "content": "For the random problem, how to test whether the result is random? how leetcode works?\\nTo generate a large number of test cases and get the probability?"
                    },
                    {
                        "username": "NAbdulla",
                        "content": "The `insert` function description says \"bool insert(int val) Inserts an item val into the multiset **if not present**. Returns true if the item was not present, false otherwise.\" Shouldn\\'t it be something like this: \"*bool insert(int val) Inserts an item val into the multiset. Returns true if the item was not present, false otherwise.*\"?"
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "to me this is more likely a STL test, much easier than those DP, recursion, sliding window etc."
                    },
                    {
                        "username": "InsZVA",
                        "content": "should be medium"
                    },
                    {
                        "username": "juggernout1",
                        "content": "should be Easy+- not Medium"
                    },
                    {
                        "username": "kai99",
                        "content": "I solved this question like many others using a combination of a linear storage (some form of a list) and a mapping from values to indexes. The solution is constant time but space complexity is horrible. The idea depends of adding all values to the list (with their repeatition) to make random function work. \\n\\nThe problem is space. If we have an element repeated a million time, we will add it to the values list million time and save its million indexes in our mapping. If this is the solution to the question then it\\'s a a bad question, and shouldn\\'t be identified as Hard at all. I consider my solution is stupid.\\n\\nAt first I thought this problem is an application of weighted random selection where we can use the [Alias method](https://en.wikipedia.org/wiki/Alias_method). Then I realized that this won\\'t work as we need to support removal from the data structure. \\n\\nAfter more thinking, the best I could come up with is to leverage the [binary index tree](https://en.wikipedia.org/wiki/Fenwick_tree) (otherwise known as Fenwick tree) where any node in the tree has the prefix sum of its children (in our case it\\'s the sum of children frequencies). This data structure supports addition/update in log(n) and we can model removal as updating the node weight to 0 (weight is the value\\'s frequency).\\n\\nPlease let me know if you think this may not work. I havn\\'t coded it. Also please let me know if someone can find a constant time solution without this horrible space complexity."
                    },
                    {
                        "username": "umakantv",
                        "content": "You can simply use a map with `val` as key and `frequency` as value.  \\nFor getting random:\\n* Calculate the sum of all frequencies (say `total`)\\n* Generate a random number between 0 and `total` \\n* You can iterate through the map, and check at what `val`, the cumulative frequency falls at the generated random number."
                    },
                    {
                        "username": "chonne",
                        "content": "Hi,\\n\\nIt looks like the JavaScript version of the test is flawed, but I may be mistaken.\\n\\n1. Comments at the end of the example: `var obj = Object.create(RandomizedCollection).createNew()`. Looks like this isn't the case, as running the code with a testcase shows a constructor is needed, so it's a `new RandomizedCollection();` that's performed\\n2. Running the code expects specific items returned by `getRandom()`: not sure if that's normal, I hope it isn't the case when submitting the code\\n3. Submitting my code resulted in a Runtime Error even though running it with the same test case worked\\n4. Test case values used when submitting the code looked wrong as there were a few inserts then many identical calls to `getRandom()`, not sure if that's normal\\n\\nSo I wrote some code to work the example provided `obj = Object.create(RandomizedCollection).createNew()`, which didn't run. Then I wrote it to work with a call to `new RandomizedCollection()` and that one passed (except for the `getRandom()` call, which was randomly right.\\n\\nI'm not yet used to this website so I hope I'm not missing something obvious.\\n\\nShaun"
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did anyone find solution that works with time complexity O(1)? My best is almost O(1) with a bit of O(log n) operations."
                    },
                    {
                        "username": "maksym-petrenko",
                        "content": "Did I get right it that if I submit wrong solution that doesn\\'t count amount of values, I still can get passed, but with exctremely small probability?"
                    },
                    {
                        "username": "IlyaIeshin",
                        "content": "Why 32 testcase will fail with the message \"Time Limit Exceeded\" \\n`class RandomizedCollection {\\n    std::unordered_multiset<int> uset;\\npublic:\\n    RandomizedCollection() : uset(){\\n    }\\n    \\n    bool insert(int val) {\\n        if(uset.find(val) == uset.end())\\n        {\\n            uset.insert(val);\\n            return true;\\n        }\\n        uset.insert(val);\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        auto first_iter = uset.find(val);\\n        if(first_iter != uset.end())\\n        {\\n            uset.erase(first_iter);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it = uset.begin();\\n        std::advance(it, rand() % uset.size());\\n        return *it;\\n    }\\n};`"
                    },
                    {
                        "username": "E1egant",
                        "content": "I guess because `uset.find(val)` works for O(n)"
                    },
                    {
                        "username": "error_407",
                        "content": " Can anyone  please let me know why this one is not working .\n`\n\nclass RandomizedCollection {\nprivate:\n    unordered_map<int,int> mp;\n    vector<pair<int,int>> ans;\npublic:\n    RandomizedCollection() {\n    }\n    \n    bool insert(int val) {\n        if(mp.find(val)==mp.end()){\n            ans.push_back({val, 1});\n            mp[val] = ans.size()-1;\n            return true;\n        }\n\n        ans[mp[val]].second++;\n        return false;\n    }\n    \n    bool remove(int val) {\n        if(mp.find(val)==mp.end()) return false;\n        int index = mp[val];\n        if(ans[index].second ==1){\n            mp[ans[ans.size()-1].first] = index;\n            ans[index] = ans[ans.size()-1];\n            ans.pop_back();\n            mp.erase(val);\n        }\n        else {\n           ans[index].second--;\n        }\n        return true;\n    }\n    \n    int getRandom() {\n        int random = rand() % ans.size();\n        return ans[random].first;\n    }\n};\n\n\n`"
                    }
                ]
            }
        ]
    }
]