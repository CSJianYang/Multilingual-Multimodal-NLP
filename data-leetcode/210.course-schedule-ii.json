[
    {
        "title": "Course Schedule II",
        "question_content": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\n\tFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\n&nbsp;\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n\nExample 2:\n\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n\nExample 3:\n\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\n\n&nbsp;\nConstraints:\n\n\t1 <= numCourses <= 2000\n\t0 <= prerequisites.length <= numCourses * (numCourses - 1)\n\tprerequisites[i].length == 2\n\t0 <= ai, bi < numCourses\n\tai != bi\n\tAll the pairs [ai, bi] are distinct.",
        "solutions": [
            {
                "id": 59317,
                "title": "two-ac-solution-in-java-using-bfs-and-dfs-with-explanation",
                "content": "This question asks for an order in which prerequisite courses must be taken first. This prerequisite relationship reminds one of directed graphs. Then, the problem reduces to find a topological sort order of the courses, which would be a DAG if it has a valid order.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int[] incLinkCounts = new int[numCourses];\\n        List<List<Integer>> adjs = new ArrayList<>(numCourses);\\n        initialiseGraph(incLinkCounts, adjs, prerequisites);\\n        //return solveByBFS(incLinkCounts, adjs);\\n        return solveByDFS(adjs);\\n    }\\n\\nThe first step is to transform it into a directed graph. Since it is likely to be sparse,we use adjacency list graph data structure. 1 -> 2 means 1 must be taken before 2.\\n\\n    private void initialiseGraph(int[] incLinkCounts, List<List<Integer>> adjs, int[][] prerequisites){\\n        int n = incLinkCounts.length;\\n        while (n-- > 0) adjs.add(new ArrayList<>());\\n        for (int[] edge : prerequisites) {\\n            incLinkCounts[edge[0]]++;\\n            adjs.get(edge[1]).add(edge[0]);\\n        }\\n    }\\n\\nHow can we obtain a topological sort order of a DAG?\\n\\nWe observe that if a node has incoming edges, it has prerequisites. Therefore, the first few in the order must be those with no prerequisites, i.e. no incoming edges. Any non-empty DAG must have at least one node without incoming links. You can draw a small graph to convince yourself. If we visit these few and remove all edges attached to them, we are left with a smaller DAG, which is the same problem. This will then give our BFS solution.\\n\\n    private int[] solveByBFS(int[] incLinkCounts, List<List<Integer>> adjs){\\n        int[] order = new int[incLinkCounts.length];\\n        Queue<Integer> toVisit = new ArrayDeque<>();\\n        for (int i = 0; i < incLinkCounts.length; i++) {\\n            if (incLinkCounts[i] == 0) toVisit.offer(i);\\n        }\\n        int visited = 0;\\n        while (!toVisit.isEmpty()) {\\n            int from = toVisit.poll();\\n            order[visited++] = from;\\n            for (int to : adjs.get(from)) {\\n                incLinkCounts[to]--;\\n                if (incLinkCounts[to] == 0) toVisit.offer(to);\\n            }\\n        }\\n        return visited == incLinkCounts.length ? order : new int[0]; \\n    }\\n\\nAnother way to think about it is the last few in the order must be those which are not prerequisites of other courses. Thinking it recursively means if one node has unvisited child node, you should visit them first before you put this node down in the final order array. This sounds like the post-order of a DFS. Since we are putting nodes down in the reverse order, we should reverse it back to correct ordering or use a stack.\\n\\n    private int[] solveByDFS(List<List<Integer>> adjs) {\\n        BitSet hasCycle = new BitSet(1);\\n        BitSet visited = new BitSet(adjs.size());\\n        BitSet onStack = new BitSet(adjs.size());\\n        Deque<Integer> order = new ArrayDeque<>();\\n        for (int i = adjs.size() - 1; i >= 0; i--) {\\n            if (visited.get(i) == false && hasOrder(i, adjs, visited, onStack, order) == false) return new int[0];\\n        }\\n        int[] orderArray = new int[adjs.size()];\\n        for (int i = 0; !order.isEmpty(); i++) orderArray[i] = order.pop();\\n        return orderArray;\\n    }\\n    \\n    private boolean hasOrder(int from, List<List<Integer>> adjs, BitSet visited, BitSet onStack, Deque<Integer> order) {\\n        visited.set(from);\\n        onStack.set(from);\\n        for (int to : adjs.get(from)) {\\n            if (visited.get(to) == false) {\\n                if (hasOrder(to, adjs, visited, onStack, order) == false) return false;\\n            } else if (onStack.get(to) == true) {\\n                return false;\\n            }\\n        }\\n        onStack.clear(from);\\n        order.push(from);\\n        return true;\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "This question asks for an order in which prerequisite courses must be taken first. This prerequisite relationship reminds one of directed graphs. Then, the problem reduces to find a topological sort order of the courses, which would be a DAG if it has a valid order.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int[] incLinkCounts = new int[numCourses];\\n        List<List<Integer>> adjs = new ArrayList<>(numCourses);\\n        initialiseGraph(incLinkCounts, adjs, prerequisites);\\n        //return solveByBFS(incLinkCounts, adjs);\\n        return solveByDFS(adjs);\\n    }\\n\\nThe first step is to transform it into a directed graph. Since it is likely to be sparse,we use adjacency list graph data structure. 1 -> 2 means 1 must be taken before 2.\\n\\n    private void initialiseGraph(int[] incLinkCounts, List<List<Integer>> adjs, int[][] prerequisites){\\n        int n = incLinkCounts.length;\\n        while (n-- > 0) adjs.add(new ArrayList<>());\\n        for (int[] edge : prerequisites) {\\n            incLinkCounts[edge[0]]++;\\n            adjs.get(edge[1]).add(edge[0]);\\n        }\\n    }\\n\\nHow can we obtain a topological sort order of a DAG?\\n\\nWe observe that if a node has incoming edges, it has prerequisites. Therefore, the first few in the order must be those with no prerequisites, i.e. no incoming edges. Any non-empty DAG must have at least one node without incoming links. You can draw a small graph to convince yourself. If we visit these few and remove all edges attached to them, we are left with a smaller DAG, which is the same problem. This will then give our BFS solution.\\n\\n    private int[] solveByBFS(int[] incLinkCounts, List<List<Integer>> adjs){\\n        int[] order = new int[incLinkCounts.length];\\n        Queue<Integer> toVisit = new ArrayDeque<>();\\n        for (int i = 0; i < incLinkCounts.length; i++) {\\n            if (incLinkCounts[i] == 0) toVisit.offer(i);\\n        }\\n        int visited = 0;\\n        while (!toVisit.isEmpty()) {\\n            int from = toVisit.poll();\\n            order[visited++] = from;\\n            for (int to : adjs.get(from)) {\\n                incLinkCounts[to]--;\\n                if (incLinkCounts[to] == 0) toVisit.offer(to);\\n            }\\n        }\\n        return visited == incLinkCounts.length ? order : new int[0]; \\n    }\\n\\nAnother way to think about it is the last few in the order must be those which are not prerequisites of other courses. Thinking it recursively means if one node has unvisited child node, you should visit them first before you put this node down in the final order array. This sounds like the post-order of a DFS. Since we are putting nodes down in the reverse order, we should reverse it back to correct ordering or use a stack.\\n\\n    private int[] solveByDFS(List<List<Integer>> adjs) {\\n        BitSet hasCycle = new BitSet(1);\\n        BitSet visited = new BitSet(adjs.size());\\n        BitSet onStack = new BitSet(adjs.size());\\n        Deque<Integer> order = new ArrayDeque<>();\\n        for (int i = adjs.size() - 1; i >= 0; i--) {\\n            if (visited.get(i) == false && hasOrder(i, adjs, visited, onStack, order) == false) return new int[0];\\n        }\\n        int[] orderArray = new int[adjs.size()];\\n        for (int i = 0; !order.isEmpty(); i++) orderArray[i] = order.pop();\\n        return orderArray;\\n    }\\n    \\n    private boolean hasOrder(int from, List<List<Integer>> adjs, BitSet visited, BitSet onStack, Deque<Integer> order) {\\n        visited.set(from);\\n        onStack.set(from);\\n        for (int to : adjs.get(from)) {\\n            if (visited.get(to) == false) {\\n                if (hasOrder(to, adjs, visited, onStack, order) == false) return false;\\n            } else if (onStack.get(to) == true) {\\n                return false;\\n            }\\n        }\\n        onStack.clear(from);\\n        order.push(from);\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 59330,
                "title": "concise-java-solution-based-on-bfs-with-comments",
                "content": "    public int[] findOrder(int numCourses, int[][] prerequisites) { \\n        if (numCourses == 0) return null;\\n        // Convert graph presentation from edges to indegree of adjacent list.\\n        int indegree[] = new int[numCourses], order[] = new int[numCourses], index = 0;\\n        for (int i = 0; i < prerequisites.length; i++) // Indegree - how many prerequisites are needed.\\n            indegree[prerequisites[i][0]]++;    \\n    \\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        for (int i = 0; i < numCourses; i++) \\n            if (indegree[i] == 0) {\\n                // Add the course to the order because it has no prerequisites.\\n                order[index++] = i;\\n                queue.offer(i);\\n            }\\n    \\n        // How many courses don't need prerequisites. \\n        while (!queue.isEmpty()) {\\n            int prerequisite = queue.poll(); // Already finished this prerequisite course.\\n            for (int i = 0; i < prerequisites.length; i++)  {\\n                if (prerequisites[i][1] == prerequisite) {\\n                    indegree[prerequisites[i][0]]--; \\n                    if (indegree[prerequisites[i][0]] == 0) {\\n                        // If indegree is zero, then add the course to the order.\\n                        order[index++] = prerequisites[i][0];\\n                        queue.offer(prerequisites[i][0]);\\n                    }\\n                } \\n            }\\n        }\\n    \\n        return (index == numCourses) ? order : new int[0];\\n    }",
                "solutionTags": [],
                "code": "    public int[] findOrder(int numCourses, int[][] prerequisites) { \\n        if (numCourses == 0) return null;\\n        // Convert graph presentation from edges to indegree of adjacent list.\\n        int indegree[] = new int[numCourses], order[] = new int[numCourses], index = 0;\\n        for (int i = 0; i < prerequisites.length; i++) // Indegree - how many prerequisites are needed.\\n            indegree[prerequisites[i][0]]++;    \\n    \\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        for (int i = 0; i < numCourses; i++) \\n            if (indegree[i] == 0) {\\n                // Add the course to the order because it has no prerequisites.\\n                order[index++] = i;\\n                queue.offer(i);\\n            }\\n    \\n        // How many courses don't need prerequisites. \\n        while (!queue.isEmpty()) {\\n            int prerequisite = queue.poll(); // Already finished this prerequisite course.\\n            for (int i = 0; i < prerequisites.length; i++)  {\\n                if (prerequisites[i][1] == prerequisite) {\\n                    indegree[prerequisites[i][0]]--; \\n                    if (indegree[prerequisites[i][0]] == 0) {\\n                        // If indegree is zero, then add the course to the order.\\n                        order[index++] = prerequisites[i][0];\\n                        queue.offer(prerequisites[i][0]);\\n                    }\\n                } \\n            }\\n        }\\n    \\n        return (index == numCourses) ? order : new int[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 190393,
                "title": "topological-sort-template-general-approach",
                "content": "```Topological Sort is Easy``` -- The General Template\\n*\\n**What we need ?**  \\n```1. HashMap<Node, Indegree> inDegree```: A in-degree map, which record each nodes in-degree. \\n```2. HashMap<Node, List<Node>children> topoMap```: A topo-map which record the Node\\'s children\\n\\n**What we do ?**  \\n```1. Init```:  Init the two HashMaps.\\n```2. Build Map```: Put the child into parent\\'s list ; Increase child\\'s in-degree by 1.\\n```3. Find Node with 0 in-degree```: Iterate the inDegree map, find the Node has 0 inDegree. (If none, there must be a circle)\\n```4. Decrease the children\\'s inDegree by 1```: Decrease step3\\'s children\\'s inDegree by 1.\\n```5. Remove this Node```: Remove step3\\'s Node from inDegree. Break current iteration.\\n```6. Do 3-5 until inDegree is Empty```: Use a while loop\\n\\n```java\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        // Topological sort\\n        // Edge case\\n        if(numCourses <= 0) return new int[0];\\n        \\n        //1. Init Map\\n        HashMap<Integer, Integer> inDegree = new HashMap<>();\\n        HashMap<Integer, List<Integer>> topoMap = new HashMap<>();\\n        for(int i = 0; i < numCourses; i++) {\\n            inDegree.put(i, 0);\\n            topoMap.put(i, new ArrayList<Integer>());\\n        }\\n        \\n        //2. Build Map\\n        for(int[] pair : prerequisites) {\\n            int curCourse = pair[0], preCourse = pair[1];\\n            topoMap.get(preCourse).add(curCourse);  // put the child into it\\'s parent\\'s list\\n            inDegree.put(curCourse, inDegree.get(curCourse) + 1); // increase child inDegree by 1\\n        }\\n        //3. find course with 0 indegree, minus one to its children\\'s indegree, until all indegree is 0\\n        int[] res = new int[numCourses];\\n        int base = 0;\\n        while(!inDegree.isEmpty()) {\\n            boolean flag = false;   // use to check whether there is cycle\\n            for(int key : inDegree.keySet()) {  // find nodes with 0 indegree\\n                if(inDegree.get(key) == 0) {\\n                    res[base ++] = key;\\n                    List<Integer> children = topoMap.get(key);  // get the node\\'s children, and minus their inDegree\\n                    for(int child : children) \\n                        inDegree.put(child, inDegree.get(child) - 1);\\n                    inDegree.remove(key);      // remove the current node with 0 degree and start over\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(!flag)  // there is a circle --> All Indegree are not 0\\n                return new int[0];\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**Alien Dictionary**\\n```java\\npublic class Solution {\\n    /**\\n     * @param words: a list of words\\n     * @return: a string which is correct order\\n     */\\n    public String alienOrder(String[] words) {\\n        // Topo sort\\n        // Edge case\\n        if(words == null || words.length == 0) return \"\";\\n        \\n        //1. Init inDegree & topoMap\\n        HashMap<Character, Integer> inDegree = new HashMap<>();\\n        HashMap<Character, List<Character>> topoMap = new HashMap<>();\\n        for(String word : words)\\n            for(char c : word.toCharArray()) {\\n                inDegree.put(c, 0);\\n                topoMap.put(c, new ArrayList<Character>());\\n            }\\n        \\n        //2. Build Map\\n        for(int i = 0; i < words.length - 1; i++) {\\n            String w1 = words[i], w2 = words[i + 1];\\n            for(int j = 0; j < Math.min(w1.length(), w2.length()); j++) {\\n                char parent = w1.charAt(j), child = w2.charAt(j);\\n                if(parent != child) {\\n                    inDegree.put(child, inDegree.get(child) + 1);\\n                    topoMap.get(parent).add(child);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        //3. Topo sort\\n        StringBuilder res = new StringBuilder();\\n        while(!inDegree.isEmpty()) {\\n            boolean flag = false;\\n            for(Character c : inDegree.keySet()) {\\n                if(inDegree.get(c) == 0) {\\n                    flag = true;\\n                    res.append(c);\\n                    List<Character> children = topoMap.get(c);\\n                    for(Character ch : children)\\n                        inDegree.put(ch, inDegree.get(ch) - 1);\\n                    inDegree.remove(c);\\n                    break;\\n                }\\n            }\\n            if(flag == false)\\n                return \"\";\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Topological Sort is Easy```\n```1. HashMap<Node, Indegree> inDegree```\n```2. HashMap<Node, List<Node>children> topoMap```\n```1. Init```\n```2. Build Map```\n```3. Find Node with 0 in-degree```\n```4. Decrease the children\\'s inDegree by 1```\n```5. Remove this Node```\n```6. Do 3-5 until inDegree is Empty```\n```java\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        // Topological sort\\n        // Edge case\\n        if(numCourses <= 0) return new int[0];\\n        \\n        //1. Init Map\\n        HashMap<Integer, Integer> inDegree = new HashMap<>();\\n        HashMap<Integer, List<Integer>> topoMap = new HashMap<>();\\n        for(int i = 0; i < numCourses; i++) {\\n            inDegree.put(i, 0);\\n            topoMap.put(i, new ArrayList<Integer>());\\n        }\\n        \\n        //2. Build Map\\n        for(int[] pair : prerequisites) {\\n            int curCourse = pair[0], preCourse = pair[1];\\n            topoMap.get(preCourse).add(curCourse);  // put the child into it\\'s parent\\'s list\\n            inDegree.put(curCourse, inDegree.get(curCourse) + 1); // increase child inDegree by 1\\n        }\\n        //3. find course with 0 indegree, minus one to its children\\'s indegree, until all indegree is 0\\n        int[] res = new int[numCourses];\\n        int base = 0;\\n        while(!inDegree.isEmpty()) {\\n            boolean flag = false;   // use to check whether there is cycle\\n            for(int key : inDegree.keySet()) {  // find nodes with 0 indegree\\n                if(inDegree.get(key) == 0) {\\n                    res[base ++] = key;\\n                    List<Integer> children = topoMap.get(key);  // get the node\\'s children, and minus their inDegree\\n                    for(int child : children) \\n                        inDegree.put(child, inDegree.get(child) - 1);\\n                    inDegree.remove(key);      // remove the current node with 0 degree and start over\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(!flag)  // there is a circle --> All Indegree are not 0\\n                return new int[0];\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\npublic class Solution {\\n    /**\\n     * @param words: a list of words\\n     * @return: a string which is correct order\\n     */\\n    public String alienOrder(String[] words) {\\n        // Topo sort\\n        // Edge case\\n        if(words == null || words.length == 0) return \"\";\\n        \\n        //1. Init inDegree & topoMap\\n        HashMap<Character, Integer> inDegree = new HashMap<>();\\n        HashMap<Character, List<Character>> topoMap = new HashMap<>();\\n        for(String word : words)\\n            for(char c : word.toCharArray()) {\\n                inDegree.put(c, 0);\\n                topoMap.put(c, new ArrayList<Character>());\\n            }\\n        \\n        //2. Build Map\\n        for(int i = 0; i < words.length - 1; i++) {\\n            String w1 = words[i], w2 = words[i + 1];\\n            for(int j = 0; j < Math.min(w1.length(), w2.length()); j++) {\\n                char parent = w1.charAt(j), child = w2.charAt(j);\\n                if(parent != child) {\\n                    inDegree.put(child, inDegree.get(child) + 1);\\n                    topoMap.get(parent).add(child);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        //3. Topo sort\\n        StringBuilder res = new StringBuilder();\\n        while(!inDegree.isEmpty()) {\\n            boolean flag = false;\\n            for(Character c : inDegree.keySet()) {\\n                if(inDegree.get(c) == 0) {\\n                    flag = true;\\n                    res.append(c);\\n                    List<Character> children = topoMap.get(c);\\n                    for(Character ch : children)\\n                        inDegree.put(ch, inDegree.get(ch) - 1);\\n                    inDegree.remove(c);\\n                    break;\\n                }\\n            }\\n            if(flag == false)\\n                return \"\";\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59316,
                "title": "c-bfs-and-dfs",
                "content": "Similar to [Course Schedule](https://leetcode.com/problems/course-schedule/ ), during the process of visiting the nodes, store them in order to a `vector`. In DFS, you may need an additional `reverse`.\\n\\n**BFS**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g = buildGraph(numCourses, prerequisites);\\n        vector<int> degrees = computeIndegrees(g);\\n        vector<int> order;\\n        for (int i = 0; i < numCourses; i++) {\\n            int j = 0;\\n            for (; j < numCourses; j++) {\\n                if (!degrees[j]) {\\n                    order.push_back(j);\\n                    break;\\n                }\\n            }\\n            if (j == numCourses) {\\n                return {};\\n            }\\n            degrees[j]--;\\n            for (int v : g[j]) {\\n                degrees[v]--;\\n            }\\n        }        \\n        return order;\\n    }\\nprivate:\\n    typedef vector<vector<int>> graph;\\n    \\n    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g(numCourses);\\n        for (auto p : prerequisites) {\\n            g[p.second].push_back(p.first);\\n        }\\n        return g;\\n    }\\n    \\n    vector<int> computeIndegrees(graph& g) {\\n        vector<int> degrees(g.size(), 0);\\n        for (auto adj : g) {\\n            for (int v : adj) {\\n                degrees[v]++;\\n            }\\n        }\\n        return degrees;\\n    }\\n};\\n```\\n\\n**DFS**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g = buildGraph(numCourses, prerequisites);\\n        vector<int> order;\\n        vector<bool> todo(numCourses, false), done(numCourses, false);\\n        for (int i = 0; i < numCourses; i++) {\\n            if (!done[i] && !acyclic(g, todo, done, i, order)) {\\n                return {};\\n            }\\n        }\\n        reverse(order.begin(), order.end());\\n        return order;\\n    }\\nprivate:\\n    typedef vector<vector<int>> graph;\\n    \\n    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g(numCourses);\\n        for (auto p : prerequisites) {\\n            g[p.second].push_back(p.first);\\n        }\\n        return g;\\n    }\\n    \\n    bool acyclic(graph& g, vector<bool>& todo, vector<bool>& done, int node, vector<int>& order) {\\n        if (todo[node]) {\\n            return false;\\n        }\\n        if (done[node]) {\\n            return true;\\n        }\\n        todo[node] = done[node] = true;\\n        for (int neigh : g[node]) {\\n            if (!acyclic(g, todo, done, neigh, order)) {\\n                return false;\\n            }\\n        }\\n        order.push_back(node);\\n        todo[node] = false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g = buildGraph(numCourses, prerequisites);\\n        vector<int> degrees = computeIndegrees(g);\\n        vector<int> order;\\n        for (int i = 0; i < numCourses; i++) {\\n            int j = 0;\\n            for (; j < numCourses; j++) {\\n                if (!degrees[j]) {\\n                    order.push_back(j);\\n                    break;\\n                }\\n            }\\n            if (j == numCourses) {\\n                return {};\\n            }\\n            degrees[j]--;\\n            for (int v : g[j]) {\\n                degrees[v]--;\\n            }\\n        }        \\n        return order;\\n    }\\nprivate:\\n    typedef vector<vector<int>> graph;\\n    \\n    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g(numCourses);\\n        for (auto p : prerequisites) {\\n            g[p.second].push_back(p.first);\\n        }\\n        return g;\\n    }\\n    \\n    vector<int> computeIndegrees(graph& g) {\\n        vector<int> degrees(g.size(), 0);\\n        for (auto adj : g) {\\n            for (int v : adj) {\\n                degrees[v]++;\\n            }\\n        }\\n        return degrees;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g = buildGraph(numCourses, prerequisites);\\n        vector<int> order;\\n        vector<bool> todo(numCourses, false), done(numCourses, false);\\n        for (int i = 0; i < numCourses; i++) {\\n            if (!done[i] && !acyclic(g, todo, done, i, order)) {\\n                return {};\\n            }\\n        }\\n        reverse(order.begin(), order.end());\\n        return order;\\n    }\\nprivate:\\n    typedef vector<vector<int>> graph;\\n    \\n    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        graph g(numCourses);\\n        for (auto p : prerequisites) {\\n            g[p.second].push_back(p.first);\\n        }\\n        return g;\\n    }\\n    \\n    bool acyclic(graph& g, vector<bool>& todo, vector<bool>& done, int node, vector<int>& order) {\\n        if (todo[node]) {\\n            return false;\\n        }\\n        if (done[node]) {\\n            return true;\\n        }\\n        todo[node] = done[node] = true;\\n        for (int neigh : g[node]) {\\n            if (!acyclic(g, todo, done, neigh, order)) {\\n                return false;\\n            }\\n        }\\n        order.push_back(node);\\n        todo[node] = false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59455,
                "title": "fast-python-dfs-solution-with-inline-explanation",
                "content": "Runs takes 80ms\\n\\n    class Solution:\\n        # @param {integer} numCourses\\n        # @param {integer[][]} prerequisites\\n        # @return {integer[]}\\n        def findOrder(self, numCourses, prerequisites):\\n            # use DFS to parse the course structure\\n            self.graph = collections.defaultdict(list) # a graph for all courses\\n            self.res = [] # start from empty\\n            for pair in prerequisites:\\n                self.graph[pair[0]].append(pair[1]) \\n            self.visited = [0 for x in xrange(numCourses)] # DAG detection \\n            for x in xrange(numCourses):\\n                if not self.DFS(x):\\n                    return []\\n                 # continue to search the whole graph\\n            return self.res\\n        \\n        def DFS(self, node):\\n            if self.visited[node] == -1: # cycle detected\\n                return False\\n            if self.visited[node] == 1:\\n                return True # has been finished, and been added to self.res\\n            self.visited[node] = -1 # mark as visited\\n            for x in self.graph[node]:\\n                if not self.DFS(x):\\n                    return False\\n            self.visited[node] = 1 # mark as finished\\n            self.res.append(node) # add to solution as the course depenedent on previous ones\\n            return True",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n        # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 1642354,
                "title": "c-python-simple-solutions-w-explanation-topological-sort-using-bfs-dfs",
                "content": "We are given `N` courses and an array of prerequisite courses `P` where <code>P[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that <code>a<sub>i</sub></code> is a prerequisite to <code>b<sub>i</sub></code>. We need to return order of courses to take to finish all courses satisfying the prerequisite constraints.\\n\\n ---\\n \\n \\u2714\\uFE0F ***Solution - I (Topological Sort - BFS)***\\n\\nWe need to take the courses in an ordering which satisfies the prerequisite constraints. This means that any course can only be taken when all its prerequisite course is already completed. We can visualize this problem as a graph where courses are nodes and edge from one course to the next means that 1st node is prerequisite of the 2nd. Then, we can visit a node only when all of its previous connected nodes leading to it are already visited. This is nothing but **Topological sort**. It refers to an order of vertices in which for every edge `u \\u2794 v`, `u` comes before `v` in the ordering. In this approach, we will be using BFS for topological sort.\\n\\nWe can observe that the only courses possible to take at the beginning are those without any prerequisites. We will maintain an array `indegree` which denotes the number of incoming edges to a node. This will basically tell us the number of prerequisite courses of a node. If there are no prerequisite courses remaining, then we can take that course.\\n\\n Thus, we initialize and fill up a queue with all courses having 0 prerequisites. This denotes the 1st level of BFS traversal, or in other words, the set of courses that we can start our ordering with. Then, we can perform a simple BFS. In each iteration, we pop the current course `cur` and see if we are eligible to take any courses for which `cur` was a prerequisite. The process continues till we have explored all possible courses starting from 0 prerequisite courses.\\n\\nFinally, we return `ans` if all courses are finished. If it is impossible to finish all courses, we return empty array. This case will occur only when the graph formed contains a cycle. It can be proved that a solution will always exist for a DAG.\\n\\nThe algorithm can be summarized as -\\n* Form adjacency list graph from `P`  & compute `indegree` for each node\\n* For the 1st level of BFS iteration, fill up the queue with courses having indegree<sub>i</sub> = 0, i.e, courses with no prerequisites\\n* At each iteration, pop & add the course from queue to ordering `ans`\\n* Decrement indegree of each course for which current course was prerequisite. If the indegree for those courses becomes 0, we can take it next by adding it to queue\\n* Continue the process till queue isn\\'t empty\\n* Finally, return `ans` if it contains `N` courses denoting all courses can be finished, otherwise we know that the graph contains cycle & its impossible to finish all courses in which case we return `[]`\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int N, vector<vector<int>>& P) {\\n        vector<vector<int>> G(N);                   // {prerequisite-course : [list of next courses]}\\n        vector<int> ans, indegree(N);               // indegree[i] denotes number of prerequisite courses for ith course\\n        for(auto& pre : P) \\n            G[pre[1]].push_back(pre[0]),            // forming adjacency list graph\\n            indegree[pre[0]]++;                     \\n        \\n        queue<int> q;\\n        for(int i = 0; i < N; i++)\\n            if(indegree[i] == 0) q.push(i);         // we can start with courses having no prequisites\\n        \\n        while(size(q)) {\\n            auto cur = q.front(); q.pop();\\n            ans.push_back(cur);                     // cur has no remaining pre courses, so we can take it now\\n            for(auto nextCourse : G[cur]) \\n                if(--indegree[nextCourse] == 0)     // if there\\'s a next course having 0 prequisite remaining,\\n                    q.push(nextCourse);             // then we can take it\\n        }\\n        if(size(ans) == N) return ans;              // ordering exists where all courses can be finished\\n        return {};                                      \\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findOrder(self, N, P):\\n        G, indegree, q, ans = defaultdict(list), [0]*N, deque(), []\\n        for nxt, pre in P:\\n            G[pre].append(nxt)\\n            indegree[nxt] += 1\\n        \\n        for i in range(N):\\n            if indegree[i] == 0:\\n                q.append(i)\\n        while q:\\n            cur = q.popleft()\\n            ans.append(cur)\\n            for nextCourse in G[cur]:\\n                indegree[nextCourse] -= 1\\n                if indegree[nextCourse] == 0: \\n                    q.append(nextCourse)\\n                    \\n        return ans if len(ans) == N else []\\n```\\n\\n***Time Complexity :*** <code>O(N + E)</code>, where `N` is the number of courses and `E` is the number of edges, i.e, `P.length`. We require `O(E)` to form adjacency list and `O(N + E)` for standard BFS traversal.\\n***Space Complexity :*** `O(N + E)`, required for queue and storing prerequisites as adjacency list graph in `G`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Topological Sort  - DFS)***\\n\\nA similar logic as above can be implemented using DFS traversal as well. Firstly, we form the adjacency list graph `G` and `indegree` of each node. Then, similar to previous approach, we can begin DFS at courses having no prerequisite. At each recursive level of DFS, we will mark the current course as visited, so that we dont start another DFS from that course and start recursive DFS if we are eligible to take any next courses for which current course was a prerequisite. The process is summarized below -\\n\\n* Form adjacency list graph from `P` & compute `indegree` for each node\\n* Start a DFS from course having indegree<sub>i</sub> = 0, i.e, courses with no prerequisites\\n* At each DFS recursion, add the current course to `ans` & mark it as visited\\n* Decrement indegree of each course for which current course was prerequisite. If the indegree for those courses becomes 0, we can include it next by starting DFS call from that course\\n* Repeat the process by starting DFS from each course having `indegree == 0`\\n* Finally, return `ans` if it contains all `N` courses, else return `[]`\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int N, vector<vector<int>>& P) {\\n        vector<vector<int>> G(N);\\n        vector<int> ans, indegree(N);\\n        for(auto& pre : P)\\n            G[pre[1]].push_back(pre[0]),\\n            indegree[pre[0]]++;\\n        \\n        function<void(int)> dfs = [&](int cur) {\\n            ans.push_back(cur);                     // take cur course & push it into ordering\\n            indegree[cur] = -1;                     // and mark it as visited\\n            for(auto nextCourse : G[cur])          \\n                if(--indegree[nextCourse] == 0)     // if there\\'s a next course having 0 prequisite remaining,\\n                    dfs(nextCourse);                // then we can take it\\n        };\\n        for(int i = 0; i < N; i++)\\n            if(indegree[i] == 0)                    // we can start with courses having no prequisites\\n                dfs(i);\\n        \\n        if(size(ans) == N) return ans;\\n        return {};\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findOrder(self, N, P):\\n        G, indegree, ans = defaultdict(list), [0]*N, []\\n        for nxt, pre in P:\\n            G[pre].append(nxt)\\n            indegree[nxt] += 1\\n        \\n        def dfs(cur):\\n            ans.append(cur)\\n            indegree[cur] = -1\\n            for nextCourse in G[cur]:\\n                indegree[nextCourse] -= 1\\n                if indegree[nextCourse] == 0: \\n                    dfs(nextCourse)            \\n        for i in range(N):\\n            if indegree[i] == 0:\\n                dfs(i)\\n\\n        return ans if len(ans) == N else []\\n```\\n\\n***Time Complexity :*** <code>O(N + E)</code>, We require `O(E)` to form adjacency list and `O(N + E)` for standard DFS traversal.\\n***Space Complexity :*** `O(N + E)`, required for recursive stack and storing prerequisites as adjacency list graph in `G`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int N, vector<vector<int>>& P) {\\n        vector<vector<int>> G(N);                   // {prerequisite-course : [list of next courses]}\\n        vector<int> ans, indegree(N);               // indegree[i] denotes number of prerequisite courses for ith course\\n        for(auto& pre : P) \\n            G[pre[1]].push_back(pre[0]),            // forming adjacency list graph\\n            indegree[pre[0]]++;                     \\n        \\n        queue<int> q;\\n        for(int i = 0; i < N; i++)\\n            if(indegree[i] == 0) q.push(i);         // we can start with courses having no prequisites\\n        \\n        while(size(q)) {\\n            auto cur = q.front(); q.pop();\\n            ans.push_back(cur);                     // cur has no remaining pre courses, so we can take it now\\n            for(auto nextCourse : G[cur]) \\n                if(--indegree[nextCourse] == 0)     // if there\\'s a next course having 0 prequisite remaining,\\n                    q.push(nextCourse);             // then we can take it\\n        }\\n        if(size(ans) == N) return ans;              // ordering exists where all courses can be finished\\n        return {};                                      \\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findOrder(self, N, P):\\n        G, indegree, q, ans = defaultdict(list), [0]*N, deque(), []\\n        for nxt, pre in P:\\n            G[pre].append(nxt)\\n            indegree[nxt] += 1\\n        \\n        for i in range(N):\\n            if indegree[i] == 0:\\n                q.append(i)\\n        while q:\\n            cur = q.popleft()\\n            ans.append(cur)\\n            for nextCourse in G[cur]:\\n                indegree[nextCourse] -= 1\\n                if indegree[nextCourse] == 0: \\n                    q.append(nextCourse)\\n                    \\n        return ans if len(ans) == N else []\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int N, vector<vector<int>>& P) {\\n        vector<vector<int>> G(N);\\n        vector<int> ans, indegree(N);\\n        for(auto& pre : P)\\n            G[pre[1]].push_back(pre[0]),\\n            indegree[pre[0]]++;\\n        \\n        function<void(int)> dfs = [&](int cur) {\\n            ans.push_back(cur);                     // take cur course & push it into ordering\\n            indegree[cur] = -1;                     // and mark it as visited\\n            for(auto nextCourse : G[cur])          \\n                if(--indegree[nextCourse] == 0)     // if there\\'s a next course having 0 prequisite remaining,\\n                    dfs(nextCourse);                // then we can take it\\n        };\\n        for(int i = 0; i < N; i++)\\n            if(indegree[i] == 0)                    // we can start with courses having no prequisites\\n                dfs(i);\\n        \\n        if(size(ans) == N) return ans;\\n        return {};\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findOrder(self, N, P):\\n        G, indegree, ans = defaultdict(list), [0]*N, []\\n        for nxt, pre in P:\\n            G[pre].append(nxt)\\n            indegree[nxt] += 1\\n        \\n        def dfs(cur):\\n            ans.append(cur)\\n            indegree[cur] = -1\\n            for nextCourse in G[cur]:\\n                indegree[nextCourse] -= 1\\n                if indegree[nextCourse] == 0: \\n                    dfs(nextCourse)            \\n        for i in range(N):\\n            if indegree[i] == 0:\\n                dfs(i)\\n\\n        return ans if len(ans) == N else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741784,
                "title": "python-topological-sort-with-recurcive-dfs-explained",
                "content": "This is the classical problem about **topological sort**: (for more details you can look https://en.wikipedia.org/wiki/Topological_sorting). The basic idea of topological for directed graphs is to check if there cycle in this graph. For example if you have in your schedule dependencies like `0 -> 5`, `5-> 3` and `3 -> 0`, then we say, that cycle exists and in this case we need to return `False`.\\n\\nThere are different ways to do topological sort, I prefer to use `dfs`. The idea is to use classical `dfs` traversal, but color our nodes into `3` different colors, `0 (white)` for node which is not visited yet, `1 (gray)` for node which is in process of visiting (not all its neibours are processed), and `2 (black)` for node which is fully visited (all its neibours are already processed). The proof can be found for example in classical Cormen book (note, that here we have slightly different notation with inversed edges, so we do not need to reverse list in the end).\\n\\nSo, basically we have three variables: `self.Visited = [0] * numCourses` where we keep our colors, define `self.FoundCycle = 0`, we keep it for early stopping, if we found cycle we do not need to continue and we can iterrurupt earlier and `Ans` is the list we need to return of fully visited nodes. Note, that graph can be not necessarily connected, so we need to start our `dfs` from all nodes.\\n\\n**Comlexity.** We use classical dfs, so time comlexity is `O(E+V)`, where `E` is number of edges and `V` is number of vertices. Space complexity is also `O(E+V)` because we work with adjacency lists.\\n\\n```\\nclass Solution:\\n    def findOrder(self, numCourses, prerequisites):\\n        self.adj_dict = defaultdict(set)\\n        for i, j in prerequisites:\\n            self.adj_dict[i].add(j)\\n\\n        self.Visited = [0] * numCourses\\n        self.Ans, self.FoundCycle = [], 0\\n        \\n        for i in range(numCourses):\\n            if self.FoundCycle == 1: break      # early stop if the loop is found\\n            if self.Visited[i] == 0:\\n                self.dfs(i)\\n     \\n        return [] if self.FoundCycle == 1 else self.Ans\\n\\n    def dfs(self, start):\\n        if self.FoundCycle == 1:   return     # early stop if the loop is found    \\n        if self.Visited[start] == 1:\\n            self.FoundCycle = 1               # loop is found\\n        if self.Visited[start] == 0:           # node is not visited yet, visit it\\n            self.Visited[start] = 1             # color current node as gray\\n            for neib in self.adj_dict[start]:   # visit all its neibours\\n                self.dfs(neib)\\n            self.Visited[start] = 2             # color current node as black\\n            self.Ans.append(start)              # add node to answer\\n```\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses, prerequisites):\\n        self.adj_dict = defaultdict(set)\\n        for i, j in prerequisites:\\n            self.adj_dict[i].add(j)\\n\\n        self.Visited = [0] * numCourses\\n        self.Ans, self.FoundCycle = [], 0\\n        \\n        for i in range(numCourses):\\n            if self.FoundCycle == 1: break      # early stop if the loop is found\\n            if self.Visited[i] == 0:\\n                self.dfs(i)\\n     \\n        return [] if self.FoundCycle == 1 else self.Ans\\n\\n    def dfs(self, start):\\n        if self.FoundCycle == 1:   return     # early stop if the loop is found    \\n        if self.Visited[start] == 1:\\n            self.FoundCycle = 1               # loop is found\\n        if self.Visited[start] == 0:           # node is not visited yet, visit it\\n            self.Visited[start] = 1             # color current node as gray\\n            for neib in self.adj_dict[start]:   # visit all its neibours\\n                self.dfs(neib)\\n            self.Visited[start] = 2             # color current node as black\\n            self.Ans.append(start)              # add node to answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59321,
                "title": "python-easy-to-understand-solution-with-comments",
                "content": "```\\nclass Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        indegree = [set() for _ in range(numCourses)]\\n        outdegree = [[] for _ in range(numCourses)]\\n        for p in prerequisites:\\n            indegree[p[0]].add(p[1])\\n            outdegree[p[1]].append(p[0])\\n        ret, start = [], [i for i in range(numCourses) if not indegree[i]]\\n        while start: # start contains courses without prerequisites\\n            newStart = [] \\n            for i in start:\\n                ret.append(i)\\n                for j in outdegree[i]:\\n                    indegree[j].remove(i)\\n                    if not indegree[j]:\\n                        newStart.append(j)\\n            start = newStart # newStart contains new courses with no prerequisites\\n        return ret if len(ret) == numCourses else [] # can finish if ret contains all courses \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        indegree = [set() for _ in range(numCourses)]\\n        outdegree = [[] for _ in range(numCourses)]\\n        for p in prerequisites:\\n            indegree[p[0]].add(p[1])\\n            outdegree[p[1]].append(p[0])\\n        ret, start = [], [i for i in range(numCourses) if not indegree[i]]\\n        while start: # start contains courses without prerequisites\\n            newStart = [] \\n            for i in start:\\n                ret.append(i)\\n                for j in outdegree[i]:\\n                    indegree[j].remove(i)\\n                    if not indegree[j]:\\n                        newStart.append(j)\\n            start = newStart # newStart contains new courses with no prerequisites\\n        return ret if len(ret) == numCourses else [] # can finish if ret contains all courses \\n```",
                "codeTag": "Java"
            },
            {
                "id": 161141,
                "title": "c-topological-solution",
                "content": "```\\nvector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        vector<vector<int>> graph(numCourses, vector<int>());\\n        queue<int> nodes;\\n        vector<int> indegrees(numCourses, 0);\\n        int visit_node_size = 0;\\n        vector<int> result;\\n        \\n        for (auto item : prerequisites) {\\n            graph[item.second].push_back(item.first);\\n            ++ indegrees[item.first];\\n        }\\n        for (int node_id = 0; node_id < indegrees.size(); ++ node_id) {\\n            if (indegrees[node_id] == 0) {\\n                nodes.push(node_id);\\n            }\\n        }\\n        while (!nodes.empty()) {\\n            ++ visit_node_size;\\n            int node_id = nodes.front();\\n            nodes.pop();\\n            result.push_back(node_id);\\n            for (auto neighber_id : graph[node_id]) {\\n                -- indegrees[neighber_id];\\n                if (indegrees[neighber_id] == 0) {\\n                    nodes.push(neighber_id);\\n                }\\n            }\\n        }\\n        \\n        return visit_node_size == numCourses ? result : vector<int>();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n        vector<vector<int>> graph(numCourses, vector<int>());\\n        queue<int> nodes;\\n        vector<int> indegrees(numCourses, 0);\\n        int visit_node_size = 0;\\n        vector<int> result;\\n        \\n        for (auto item : prerequisites) {\\n            graph[item.second].push_back(item.first);\\n            ++ indegrees[item.first];\\n        }\\n        for (int node_id = 0; node_id < indegrees.size(); ++ node_id) {\\n            if (indegrees[node_id] == 0) {\\n                nodes.push(node_id);\\n            }\\n        }\\n        while (!nodes.empty()) {\\n            ++ visit_node_size;\\n            int node_id = nodes.front();\\n            nodes.pop();\\n            result.push_back(node_id);\\n            for (auto neighber_id : graph[node_id]) {\\n                -- indegrees[neighber_id];\\n                if (indegrees[neighber_id] == 0) {\\n                    nodes.push(neighber_id);\\n                }\\n            }\\n        }\\n        \\n        return visit_node_size == numCourses ? result : vector<int>();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762346,
                "title": "python-bfs-beats-98-with-detailed-explanation-and-comments",
                "content": "The high level for this solution: We create a graph and prereq dict to track which nodes we have visited and if we\\'re able to travel to certain nodes (if there are no preqs for the intended next course - aka we\\'ve taken the prereqs or there are no prereqs.).\\nEg. 4, [[1,0],[2,0],[3,1],[3,2]]\\nStarting: q: deque([0])\\npreqs: {0: set(), 1: {0}, 2: {0}, 3: {1, 2}}\\ngraph: {0: {1, 2}, 1: {3}, 2: {3}}\\nWe start with course 0 because it has no preqs.\\nLooking at our graph, 0 has 2 neighbors 1 and 2\\nWe check 1 and 2 to see that if we have taken course 0 whether we can take them.\\nWe determine this by removing 0 (course we have taken) from 1 and 2\\'s prereqs and if there are no additional prereqs we take them (add them to our queue).\\nAfter taking 0, 1 and 2 added: deque([1, 2]) \\n1 and 2 added because they are neighbors (from our graph): {0: {1, 2}, 1: {3}, 2: {3}}) \\nAnd after taking course 0 now have no prereqs: {0: set(), 1: set(), 2: set(), 3: {1, 2}}\\nNow we visit 1 as it\\'s first in our FIFO queue.\\nLooking at course 1\\'s neighbors in our graph there\\'s 3, \\n{0: {1, 2}, 1: {3}, 2: {3}}\\nbut it has a prereq we haven\\'t taken 2,\\n{0: set(), 1: set(), 2: set(), 3: {2}}\\nWhich is still in our queue: deque([2])\\nSo we don\\'t add anything in this iter and then pop 2 from our q.\\nNow we\\'ve taken 2, we can hit 3 from our graph: 0: {1, 2}, 1: {3}, 2: {3}}\\nwe have now taken 2 so we remove the prereq: {0: set(), 1: set(), 2: set(), 3: set()}\\nAnd we add 3 to the queue.\\ndeque([3])\\nWe then pop 3, append 3 to our taken list and len(taken) == numCourses so we\\'re done!\\n\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        # Create a prerequisite dict. (containing courses (nodes) that need to be taken (visited)\\n\\t\\t# before we can visit the key.\\n        preq = {i:set() for i in range(numCourses)}\\n\\t\\t# Create a graph for adjacency and traversing.\\n        graph = collections.defaultdict(set)\\n        for i,j in prerequisites:\\n\\t\\t    # Preqs store requirments as their given.\\n            preq[i].add(j)\\n\\t\\t\\t# Graph stores nodes and neighbors.\\n            graph[j].add(i)\\n        \\n        q = collections.deque([])\\n\\t\\t# We need to find a starting location, aka courses that have no prereqs.\\n        for k, v in preq.items():\\n            if len(v) == 0:\\n                q.append(k)\\n\\t\\t# Keep track of which courses have been taken.\\n        taken = []\\n        while q:\\n            course = q.popleft()\\n            taken.append(course)\\n\\t\\t\\t# If we have visited the numCourses we\\'re done.\\n            if len(taken) == numCourses:\\n                return taken\\n\\t\\t\\t# For neighboring courses.\\n            for cor in graph[course]:\\n\\t\\t\\t    # If the course we\\'ve just taken was a prereq for the next course, remove it from its prereqs.\\n                preq[cor].remove(course)\\n\\t\\t\\t\\t# If we\\'ve taken all of the preqs for the new course, we\\'ll visit it.\\n                if not preq[cor]:\\n                    q.append(cor)\\n\\t\\t# If we didn\\'t hit numCourses in our search we know we can\\'t take all of the courses.\\n        return []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        # Create a prerequisite dict. (containing courses (nodes) that need to be taken (visited)\\n\\t\\t# before we can visit the key.\\n        preq = {i:set() for i in range(numCourses)}\\n\\t\\t# Create a graph for adjacency and traversing.\\n        graph = collections.defaultdict(set)\\n        for i,j in prerequisites:\\n\\t\\t    # Preqs store requirments as their given.\\n            preq[i].add(j)\\n\\t\\t\\t# Graph stores nodes and neighbors.\\n            graph[j].add(i)\\n        \\n        q = collections.deque([])\\n\\t\\t# We need to find a starting location, aka courses that have no prereqs.\\n        for k, v in preq.items():\\n            if len(v) == 0:\\n                q.append(k)\\n\\t\\t# Keep track of which courses have been taken.\\n        taken = []\\n        while q:\\n            course = q.popleft()\\n            taken.append(course)\\n\\t\\t\\t# If we have visited the numCourses we\\'re done.\\n            if len(taken) == numCourses:\\n                return taken\\n\\t\\t\\t# For neighboring courses.\\n            for cor in graph[course]:\\n\\t\\t\\t    # If the course we\\'ve just taken was a prereq for the next course, remove it from its prereqs.\\n                preq[cor].remove(course)\\n\\t\\t\\t\\t# If we\\'ve taken all of the preqs for the new course, we\\'ll visit it.\\n                if not preq[cor]:\\n                    q.append(cor)\\n\\t\\t# If we didn\\'t hit numCourses in our search we know we can\\'t take all of the courses.\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59342,
                "title": "java-dfs-double-cache-visiting-each-vertex-once-433ms",
                "content": "    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            List<List<Integer>> adj = new ArrayList<>(numCourses);\\n            for (int i = 0; i < numCourses; i++) adj.add(i, new ArrayList<>());\\n            for (int i = 0; i < prerequisites.length; i++) adj.get(prerequisites[i][1]).add(prerequisites[i][0]);\\n            boolean[] visited = new boolean[numCourses];\\n            Stack<Integer> stack = new Stack<>();\\n            for (int i = 0; i < numCourses; i++) {\\n                if (!topologicalSort(adj, i, stack, visited, new boolean[numCourses])) return new int[0];\\n            }\\n            int i = 0;\\n            int[] result = new int[numCourses];\\n            while (!stack.isEmpty()) {\\n                result[i++] = stack.pop();\\n            }\\n            return result;\\n        }\\n        \\n        private boolean topologicalSort(List<List<Integer>> adj, int v, Stack<Integer> stack, boolean[] visited, boolean[] isLoop) {\\n            if (visited[v]) return true;\\n            if (isLoop[v]) return false;\\n            isLoop[v] = true;\\n            for (Integer u : adj.get(v)) {\\n                if (!topologicalSort(adj, u, stack, visited, isLoop)) return false;\\n            }\\n            visited[v] = true;\\n            stack.push(v);\\n            return true;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            List<List<Integer>> adj = new ArrayList<>(numCourses);\\n            for (int i = 0; i < numCourses; i++) adj.add(i, new ArrayList<>());\\n            for (int i = 0; i < prerequisites.length; i++) adj.get(prerequisites[i][1]).add(prerequisites[i][0]);\\n            boolean[] visited = new boolean[numCourses];\\n            Stack<Integer> stack = new Stack<>();\\n            for (int i = 0; i < numCourses; i++) {\\n                if (!topologicalSort(adj, i, stack, visited, new boolean[numCourses])) return new int[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 742323,
                "title": "c-beginner-topological-sort-cycle-detection-using-dfs",
                "content": "#### This Is a really good question when it comes to building a concrete base for your Graph related problems.\\n\\n**Main Concepts:**\\n- DFS\\n- Topological Sort\\n- Cycle detection\\n\\n> For a really well excuted DFS using STL\\'s : [DFS_STL](https://gist.github.com/sr6033/3d4a018fc0ae598616ca11f134e060c5)\\n> For a better understanding about Topological Sort : [TopoSort](https://www.youtube.com/watch?v=ddTC4Zovtbc)\\n\\nI will talk about all these points in great detail.\\n\\n------\\n\\n**Global Variables**\\n> The following data structures are used.\\n\\n* Stack to store the Topological order : `stack<int> S`\\n* Vector \\'V\\' to store visited nodes : `vector<int> V`\\n* Vector \\'P\\' to store nodes in recursive stack : `vector<int> P`\\n* Map to store the graph : `map<int, vector<int> > G`\\n* Bool variable to store if there is a cycle: `bool cycle`\\n\\n------\\n\\n**Basic DFS**\\n> This is the heart of the code, But it needs a little modification to do a Topological Sort.\\n```\\nvoid DFS(int n)\\n{        \\n\\tfor(int i=0;i<n;++i)\\n\\t\\tif(!V[i]) DFS_recur(i);\\n}\\n\\nvoid DFS_recur(int curr)\\n{        \\n\\tV[curr] = true;\\n\\tcout << curr << \" \";\\n\\t\\n\\tfor(int i : G[curr])\\n\\t\\tif(!V[i]) DFS_recur(i);\\n}\\n```\\n\\n------\\n\\n**Custom DFS for TopoLogical Sort**\\n> We only need to update the DFS_recur function.\\n```\\nvoid DFS_recur(int curr)\\n{\\n\\tV[curr] = true;\\n\\n\\tfor(int i : G[curr])\\n\\t\\tif(!V[i]) DFS_recur(i);\\n\\n\\tS.push(curr);\\n}\\n```\\n\\nHere if we just add a **S.push(curr)** we will get the topological order in the Stack.\\nThink about it we will push only if we reach a **terminal node** in the graph.\\n\\n------\\n\\n**Custom DFS for Cycle Detection**\\n> We will use a vector \\'P\\' to keep track of elements in the recursion stack.\\n```\\nvoid DFS_recur(int curr)\\n    {\\n        if(cycle) return;\\n        \\n        V[curr] = true;\\n        P[curr] = true;\\n        \\n        for(int i : G[curr])\\n        {   \\n            if(P[i] == true) cycle = true;\\n            if(!V[i]) DFS_recur(i);\\n        }\\n        \\n        S.push(curr);\\n        P[curr] = false;\\n    }\\n```\\n\\nThis code will set the **cycle variable to true** as soon as a cycle is detected.\\n\\nHow do we detect the cycle?\\n> **Lets consider the followig Graph**\\n<img src=https://user-images.githubusercontent.com/66634743/87854395-cc302600-c922-11ea-9a54-c45e83f4e7b1.png width=300 height=200>\\n> **The map will be as follows**\\n> | Parent | Children |\\n> | - | - |\\n> | 0 | [ 1 ] |\\n> | 1 | [ 2 ] |\\n> | 2 | [ 4 ] |\\n> | 3 | [ 1 ] |\\n> | 4 | [ 3, 5 ] |\\n> **The vectors P and V**\\n> | i | 0 | 1 | 2 | 3 | 4 | 5 |\\n> | - | - | - | - | - | - | - |\\n> | **V** | F | F | F | F | F | F |\\n> | **P** | F | F | F | F | F | F |\\n> 0 will be the **curr** first, resulting in the following. P[0] = true means that 0 is in the recursive stack.\\n> | i | 0 | 1 | 2 | 3 | 4 | 5 |\\n> | - | - | - | - | - | - | - |\\n> | **V** | T | F | F | F | F | F |\\n> | **P** | T | F | F | F | F | F |\\n> Then we valuate its child:\\n>> **curr = 1**\\n>>> **curr = 2**\\n>>>> **curr = 4**\\n>>>>> **curr = 3**\\n>>>>> \\n> | i | 0 | 1 | 2 | 3 | 4 | 5 |\\n> | - | - | - | - | - | - | - |\\n> | **V** | T | T | T | F | T | F |\\n> | **P** | T | T | T | F | T | F |\\n> Now we see that **3\\'s child is 1**. Lets see what happens.\\n>> \\n``` \\nvoid DFS_recur(int curr)                   // curr = 3\\n{\\n\\tif(cycle) return;                      // cycle = false\\n\\n\\tV[curr] = true;                        // V[3] = true\\n\\tP[curr] = true;                        // P[3] = true\\n\\n\\tfor(int i : G[curr])                   // only one element in the vector, [ 1 ] \\n\\t{   \\n\\t\\tif(P[i] == true) cycle = true;     // P[1] == true therefore cycle = true\\n\\t\\tif(!V[i]) DFS_recur(i);            // recur with i = 1\\n\\t// Jump to DFS_recur(1)\\n\\nvoid DFS_recur(int curr)                   // curr = 1\\n{\\n\\tif(cycle) return;                      // cycle = true therefore return\\n\\t/*this will keep returning till the whole recursive stack in empty.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\tall the was till the initial curr = 0\\n\\tThen in the main function*/\\n\\t\\n\\tif(cycle) return {};                   // cycle = true return []\\n        return Ans;\\n```\\n\\n------\\n\\n**Complete Code**\\n```\\nclass Solution {\\npublic:\\n    stack<int> S;\\n    vector<int> V;\\n    vector<int> P;\\n    bool cycle;\\n    map<int, vector<int> > G;\\n    \\n    void DFS(int n)\\n    {        \\n        for(int i=0;i<n;++i)\\n        {\\n            if(!V[i]) DFS_recur(i);\\n        }\\n    }\\n    \\n    void DFS_recur(int curr)\\n    {\\n        if(cycle) return;\\n        \\n        V[curr] = true;\\n        P[curr] = true;\\n        \\n        for(int i : G[curr])\\n        {   \\n            if(P[i] == true) cycle = true;\\n            if(!V[i]) DFS_recur(i);\\n        }\\n        \\n        S.push(curr);\\n        P[curr] = false;\\n    }\\n    \\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) \\n    {\\n        vector<int> Ans;\\n        V.assign(n, false);\\n        P.assign(n, false);\\n        cycle = false;\\n        for(auto i : prerequisites)\\n        {\\n            G[i[1]].push_back(i[0]);\\n        }\\n\\n        DFS(n);\\n        \\n        while(!S.empty())\\n        {\\n            Ans.push_back(S.top());\\n            S.pop();\\n        }\\n        \\n        if(cycle) return {};\\n        return Ans;\\n    }\\n};\\n```\\n\\n------\\n***I dont know if this is any better than the explainations by others, this is a beginner friendly approach. \\nI have tried my best to break it down step by step, Let me know if it helped you.\\nIf you want to have a better understanding try dry running it using a success case (acyclic case)***",
                "solutionTags": [],
                "code": "```\\nvoid DFS(int n)\\n{        \\n\\tfor(int i=0;i<n;++i)\\n\\t\\tif(!V[i]) DFS_recur(i);\\n}\\n\\nvoid DFS_recur(int curr)\\n{        \\n\\tV[curr] = true;\\n\\tcout << curr << \" \";\\n\\t\\n\\tfor(int i : G[curr])\\n\\t\\tif(!V[i]) DFS_recur(i);\\n}\\n```\n```\\nvoid DFS_recur(int curr)\\n{\\n\\tV[curr] = true;\\n\\n\\tfor(int i : G[curr])\\n\\t\\tif(!V[i]) DFS_recur(i);\\n\\n\\tS.push(curr);\\n}\\n```\n```\\nvoid DFS_recur(int curr)\\n    {\\n        if(cycle) return;\\n        \\n        V[curr] = true;\\n        P[curr] = true;\\n        \\n        for(int i : G[curr])\\n        {   \\n            if(P[i] == true) cycle = true;\\n            if(!V[i]) DFS_recur(i);\\n        }\\n        \\n        S.push(curr);\\n        P[curr] = false;\\n    }\\n```\n``` \\nvoid DFS_recur(int curr)                   // curr = 3\\n{\\n\\tif(cycle) return;                      // cycle = false\\n\\n\\tV[curr] = true;                        // V[3] = true\\n\\tP[curr] = true;                        // P[3] = true\\n\\n\\tfor(int i : G[curr])                   // only one element in the vector, [ 1 ] \\n\\t{   \\n\\t\\tif(P[i] == true) cycle = true;     // P[1] == true therefore cycle = true\\n\\t\\tif(!V[i]) DFS_recur(i);            // recur with i = 1\\n\\t// Jump to DFS_recur(1)\\n\\nvoid DFS_recur(int curr)                   // curr = 1\\n{\\n\\tif(cycle) return;                      // cycle = true therefore return\\n\\t/*this will keep returning till the whole recursive stack in empty.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t...\\n\\tall the was till the initial curr = 0\\n\\tThen in the main function*/\\n\\t\\n\\tif(cycle) return {};                   // cycle = true return []\\n        return Ans;\\n```\n```\\nclass Solution {\\npublic:\\n    stack<int> S;\\n    vector<int> V;\\n    vector<int> P;\\n    bool cycle;\\n    map<int, vector<int> > G;\\n    \\n    void DFS(int n)\\n    {        \\n        for(int i=0;i<n;++i)\\n        {\\n            if(!V[i]) DFS_recur(i);\\n        }\\n    }\\n    \\n    void DFS_recur(int curr)\\n    {\\n        if(cycle) return;\\n        \\n        V[curr] = true;\\n        P[curr] = true;\\n        \\n        for(int i : G[curr])\\n        {   \\n            if(P[i] == true) cycle = true;\\n            if(!V[i]) DFS_recur(i);\\n        }\\n        \\n        S.push(curr);\\n        P[curr] = false;\\n    }\\n    \\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) \\n    {\\n        vector<int> Ans;\\n        V.assign(n, false);\\n        P.assign(n, false);\\n        cycle = false;\\n        for(auto i : prerequisites)\\n        {\\n            G[i[1]].push_back(i[0]);\\n        }\\n\\n        DFS(n);\\n        \\n        while(!S.empty())\\n        {\\n            Ans.push_back(S.top());\\n            S.pop();\\n        }\\n        \\n        if(cycle) return {};\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 59535,
                "title": "short-and-simple",
                "content": "Took 99ms.\\n\\n    class Solution:\\n        def findOrder(self, numCourses, prerequisites):\\n            from collections import *\\n            pre, suc = defaultdict(int), defaultdict(list)\\n            for a, b in prerequisites:\\n                pre[a] += 1\\n                suc[b].append(a)\\n            free = set(range(numCourses)) - set(pre)\\n            out = []\\n            while free:\\n                a = free.pop()\\n                out.append(a)\\n                for b in suc[a]:\\n                    pre[b] -= 1\\n                    pre[b] or free.add(b)\\n            return out * (len(out) == numCourses)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Took 99ms.\\n\\n    class Solution:\\n        def findOrder(self, numCourses, prerequisites):\\n            from collections import *\\n            pre, suc = defaultdict(int), defaultdict(list)\\n            for a, b in prerequisites:\\n                pre[a] += 1\\n                suc[b].append(a)\\n            free = set(range(numCourses)) - set(pre)\\n            out = []\\n            while free:\\n                a = free.pop()\\n                out.append(a)\\n                for b in suc[a]:\\n                    pre[b] -= 1\\n                    pre[b] or free.add(b)\\n            return out * (len(out) == numCourses)",
                "codeTag": "Java"
            },
            {
                "id": 266867,
                "title": "python-topological-sort-bfs-and-dfs-reserve-order",
                "content": "A regular topological sort problem. A good case for practice.\\n\\nThe first approach is BFS and we build the topological order in order: each time we put the node with `0` indegree at the front of the remaining sequence.\\n\\nWe need to maintain two graphes: ```dst``` sets edges as source->destination while the ```src``` sets edges as destination->source. \\n\\nFor our sorted array, each time we append the node which has no sources (`src` indegree is `0`) to it. And each time we pick one node in sorted array (ganranteed that all of its prerequisite nodes are sorted in front of it so none of rest nodes are its prerequisites) and check its destination nodes(children node in ```dst```). Then we \"remove\" it as a prerequsite from its destination nodes by decreasing all those destination nodes\\' indegree by `1`. Once any of those destination nodes has `0` indegree, we can put them into the sorted array.\\n\\nBesides, if there is a cycle in it, then schedule is not arrangable so we should return []. \\nIn such case, those nodes in the cycle will always has at least a source node (also in that cycle) so they will never be appended in the sorted array. After we finished our serach, if sorted array\\'s size is less than number of courses, then there is a cycle it it.\\n```\\ndef findOrder(n, prerequisites):\\n    src, dst = collections.Counter(), [set() for _ in range(n)]\\n    for d, s in prerequisites:\\n        src[d] += 1\\n\\t\\tdst[s].add(d)\\n    ans = [x for x in range(n) if not src[x]]\\n    for s in ans:\\n        for d in dst[s]:\\n            src[d] -= 1\\n            if not src[d]: \\n                ans.append(d)\\n    return ans if len(ans) == n else []\\n```\\n\\nThe second approach is DFS. Since the DFS searches the graph down to the end (the node with no outbound edges) and those nodes should be put at the end of the order, we can use this feature to build the topological order in reserved order: each time we reach the end of a DFS or finish searching the node (so it has no unvisited outbound edges), we put it  at the back of the remaining sequence.\\n\\n**In such way, we only need to build one destination graph, setting edges as source->destination. There is no need to remove any edges. And once we detect any directed cycle in DFS, we can stop right away. So I think DFS is a better way to do topological sort.** And each time we finised search a branch, the root of branch has no unvisitied outbound edges and we can safely add it into the order.\\n\\nAnd cycle can be detected during the DFS. And we need to set 3 visit status. 0 -> not visited; 1 -> visited, -1 -> visited and in the same DFS branch. So if we meet a node with status -1, we find a directed cycle. If we meet a node with status 1, we stop DFS from that node.\\n```\\ndef findOrder(self, n, prerequisites):\\n    G = [set() for _ in range(n)]\\n    for d, s in prerequisites:\\n        G[s].add(d)\\n    vis, orders = [0] * n, []\\n\\n    def dfs_circle(x):\\n        vis[x] = -1\\n        for y in G[x]:\\n            if vis[y] < 0 or (not vis[y] and dfs_circle(y)):\\n                return True\\n        vis[x] = 1\\n        orders.append(x)\\n        return False\\n\\n\\tfor x in range(numCourses):\\n\\t    if not vis[x] and dfs_circle(x):\\n\\t        return []\\n    return orders[::-1]\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dst```\n```src```\n```dst```\n```\\ndef findOrder(n, prerequisites):\\n    src, dst = collections.Counter(), [set() for _ in range(n)]\\n    for d, s in prerequisites:\\n        src[d] += 1\\n\\t\\tdst[s].add(d)\\n    ans = [x for x in range(n) if not src[x]]\\n    for s in ans:\\n        for d in dst[s]:\\n            src[d] -= 1\\n            if not src[d]: \\n                ans.append(d)\\n    return ans if len(ans) == n else []\\n```\n```\\ndef findOrder(self, n, prerequisites):\\n    G = [set() for _ in range(n)]\\n    for d, s in prerequisites:\\n        G[s].add(d)\\n    vis, orders = [0] * n, []\\n\\n    def dfs_circle(x):\\n        vis[x] = -1\\n        for y in G[x]:\\n            if vis[y] < 0 or (not vis[y] and dfs_circle(y)):\\n                return True\\n        vis[x] = 1\\n        orders.append(x)\\n        return False\\n\\n\\tfor x in range(numCourses):\\n\\t    if not vis[x] and dfs_circle(x):\\n\\t        return []\\n    return orders[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 892071,
                "title": "solution-based-on-kahn-s-algorithm-detailed-explantion",
                "content": "```\\n/* (https://leetcode.com/problems/course-schedule-ii/)\\n\\nSolution2:- Based on Kahn\\'s Algorithm (BFS + Queue)\\n\\nTime complexity:- O(V+E) where V is the number of vertices and E is the number of Edges.\\n\\nWhat is Kahn\\'s Algorithm?\\n=> This is the algorithm to do topological sorting. In this algorithm we will follow three steps:-\\n1. We will find indegree of every node means we will calculate the adjacent nodes of that vertice which are dependent on it.\\n2. We will push the node with 0 indegree into the queue.\\n3. Then we will remove all the nodes one by one from the queue and will reduce the indegree of their adjacent nodes which are prerequisites for it.\\n\\nWe will take a count variable to check if there is a deadlock(cycle) in the graph. Because if there is a cycle in the graph then it means we cant apply \\ntopological sort in it and there will be no way to complete all the courses.\\n\\nSo, for DAG(Directed acyclic graph) our count variable should be equal to the total no of nodes in the graph.\\n\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    bool kahnAlgo(vector<vector<int>> &adj, int n, vector<int> &indegree, vector<int> &ans)\\n    {\\n        queue<int> q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            // will push all the nodes with the indegree 0 in the queue as we have completed all the prerequisites for it.\\n            if (indegree[i] == 0)\\n                q.push(i);\\n        }\\n\\n        int count = 0;\\n        while (!q.empty())\\n        {\\n            // one by one we will take every element of the queue and will traverse the adjacency list of it \\n            // and will remove that node and will reduce the indegree of the adjacent nodes which are\\n            // prerequisites for it.\\n            int curr = q.front();\\n            q.pop();\\n\\n            for (auto a : adj[curr])\\n            {\\n                indegree[a] -= 1;\\n                // and will push the node having 0 indegree in the queue.\\n                if (indegree[a] == 0)\\n                    q.push(a);\\n            }\\n            // and after processing current node, will push it in the ans.\\n            ans.push_back(curr);\\n            count++;\\n        }\\n\\n        // checking for DAG.\\n        if (count != n)\\n            return false;\\n        return true;\\n    }\\n\\n    vector<int> findOrder(int numCourses, vector<vector<int>> &prerequisites)\\n    {\\n        int n = prerequisites.size();\\n        vector<vector<int>> adj(numCourses); // Adjacency matrix.\\n        vector<int> indegree(numCourses, 0); // indegree array.\\n\\n        // traversing all the nodes of the graph.\\n        for (int i = 0; i < n; i++)\\n        {\\n            // filling adjacency matrix for all the nodes of the graph.\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            // also filling indegree value for all nodes.\\n            indegree[prerequisites[i][0]] += 1;\\n        }\\n\\n        vector<int> ans;\\n\\n        // if graph is DAG and Kahn\\'s algo is applied then return the ans.\\n        if (kahnAlgo(adj, numCourses, indegree, ans))\\n            return ans;\\n\\n        // otherwise return the empty vector.\\n        return {};\\n    }\\n};\\n```\\n**If you like the solution and the explanation then please upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n/* (https://leetcode.com/problems/course-schedule-ii/)\\n\\nSolution2:- Based on Kahn\\'s Algorithm (BFS + Queue)\\n\\nTime complexity:- O(V+E) where V is the number of vertices and E is the number of Edges.\\n\\nWhat is Kahn\\'s Algorithm?\\n=> This is the algorithm to do topological sorting. In this algorithm we will follow three steps:-\\n1. We will find indegree of every node means we will calculate the adjacent nodes of that vertice which are dependent on it.\\n2. We will push the node with 0 indegree into the queue.\\n3. Then we will remove all the nodes one by one from the queue and will reduce the indegree of their adjacent nodes which are prerequisites for it.\\n\\nWe will take a count variable to check if there is a deadlock(cycle) in the graph. Because if there is a cycle in the graph then it means we cant apply \\ntopological sort in it and there will be no way to complete all the courses.\\n\\nSo, for DAG(Directed acyclic graph) our count variable should be equal to the total no of nodes in the graph.\\n\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    bool kahnAlgo(vector<vector<int>> &adj, int n, vector<int> &indegree, vector<int> &ans)\\n    {\\n        queue<int> q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            // will push all the nodes with the indegree 0 in the queue as we have completed all the prerequisites for it.\\n            if (indegree[i] == 0)\\n                q.push(i);\\n        }\\n\\n        int count = 0;\\n        while (!q.empty())\\n        {\\n            // one by one we will take every element of the queue and will traverse the adjacency list of it \\n            // and will remove that node and will reduce the indegree of the adjacent nodes which are\\n            // prerequisites for it.\\n            int curr = q.front();\\n            q.pop();\\n\\n            for (auto a : adj[curr])\\n            {\\n                indegree[a] -= 1;\\n                // and will push the node having 0 indegree in the queue.\\n                if (indegree[a] == 0)\\n                    q.push(a);\\n            }\\n            // and after processing current node, will push it in the ans.\\n            ans.push_back(curr);\\n            count++;\\n        }\\n\\n        // checking for DAG.\\n        if (count != n)\\n            return false;\\n        return true;\\n    }\\n\\n    vector<int> findOrder(int numCourses, vector<vector<int>> &prerequisites)\\n    {\\n        int n = prerequisites.size();\\n        vector<vector<int>> adj(numCourses); // Adjacency matrix.\\n        vector<int> indegree(numCourses, 0); // indegree array.\\n\\n        // traversing all the nodes of the graph.\\n        for (int i = 0; i < n; i++)\\n        {\\n            // filling adjacency matrix for all the nodes of the graph.\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            // also filling indegree value for all nodes.\\n            indegree[prerequisites[i][0]] += 1;\\n        }\\n\\n        vector<int> ans;\\n\\n        // if graph is DAG and Kahn\\'s algo is applied then return the ans.\\n        if (kahnAlgo(adj, numCourses, indegree, ans))\\n            return ans;\\n\\n        // otherwise return the empty vector.\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420402,
                "title": "clean-javascript-solution",
                "content": "```js\\nconst findOrder = (numCourses, prerequisites) => {\\n  const inDegrees = Array(numCourses).fill(0);\\n  for (const [v] of prerequisites) {\\n    inDegrees[v]++;\\n  }\\n\\n  const q = [];\\n  for (let i = 0; i < inDegrees.length; i++) {\\n    const degree = inDegrees[i];\\n    if (degree === 0) q.push(i);\\n  }\\n\\n  const res = [];\\n  while (q.length) {\\n    const u0 = q.shift();\\n    numCourses--;\\n    res.push(u0);\\n    for (const [v, u] of prerequisites) {\\n      if (u === u0) {\\n        inDegrees[v]--;\\n        if (inDegrees[v] === 0) q.push(v);\\n      }\\n    }\\n  }\\n  return numCourses === 0 ? res : [];\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```js\\nconst findOrder = (numCourses, prerequisites) => {\\n  const inDegrees = Array(numCourses).fill(0);\\n  for (const [v] of prerequisites) {\\n    inDegrees[v]++;\\n  }\\n\\n  const q = [];\\n  for (let i = 0; i < inDegrees.length; i++) {\\n    const degree = inDegrees[i];\\n    if (degree === 0) q.push(i);\\n  }\\n\\n  const res = [];\\n  while (q.length) {\\n    const u0 = q.shift();\\n    numCourses--;\\n    res.push(u0);\\n    for (const [v, u] of prerequisites) {\\n      if (u === u0) {\\n        inDegrees[v]--;\\n        if (inDegrees[v] === 0) q.push(v);\\n      }\\n    }\\n  }\\n  return numCourses === 0 ? res : [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59390,
                "title": "java-6ms-topological-sort-solution-with-explanation",
                "content": "This problem is a classic graph topological sort problem. Each prerequisite has edges to the courses that require it.\\n\\nWe define **in degree** as the number of edges into a node in the graph. What we do is we remove the nodes that has in degree equals to 0, decrease the in degree of the nodes that require the current node, and repeat, until we've removed all the nodes (the successful case), or there's no node with in degree equals to 0 (the failed case).\\n\\nSo, we can do this using a priority queue, and make the in degree as the priority. Every time we poll a node from the queue, and decrease the priorities of the children of the node. If the polled node has in degree larger than 1, it means we failed. But since Java's priority queue doesn't support convenient decrease key operation, we have to remove one node and add it back, which causes bad performance.\\n\\n**Or we can use two pointers. We put the removed node in an array, and use a left pointer to iterate through the array and decrease the in degrees of the nodes than require the current node. And use a right pointer to add those nodes which have 0 in degree after the decreasing operation. Repeat this until all nodes are added.**\\n\\n    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            \\n            int[] inDeg = new int[numCourses];\\n            List<Integer>[] chl = new ArrayList[numCourses];\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                chl[i] = new ArrayList<Integer>();\\n            }\\n            \\n            int pre;\\n            int cour;\\n            \\n            for (int[] pair : prerequisites) {\\n                pre = pair[1];\\n                cour = pair[0];\\n                \\n                chl[pre].add(cour);\\n                inDeg[cour]++;\\n            }\\n            \\n            int[] res = new int[numCourses];\\n            int k = 0;\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                if (inDeg[i] == 0) {\\n                    res[k++] = i;\\n                }\\n            }\\n            \\n            if (k == 0) {\\n                return new int[0];\\n            }\\n            \\n            int j = 0;\\n            List<Integer> tmp;\\n            \\n            while (k < numCourses) {\\n                tmp = chl[res[j++]];\\n                \\n                for (int id : tmp) {\\n                    if (--inDeg[id] == 0) {\\n                        res[k++] = id;\\n                    }\\n                }\\n                \\n                if (j == k) {\\n                    return new int[0];\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            \\n            int[] inDeg = new int[numCourses];\\n            List<Integer>[] chl = new ArrayList[numCourses];\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                chl[i] = new ArrayList<Integer>();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 526064,
                "title": "javascript-topological-sort",
                "content": "Wiki - https://en.wikipedia.org/wiki/Topological_sorting\\n\\n```javascript\\n/**\\n * @param {number} numCourses\\n * @param {number[][]} prerequisites\\n * @return {number[]}\\n */\\nvar findOrder = function(numCourses, prerequisites) {\\n  const order = [];\\n  const queue = [];\\n  const graph = new Map();\\n  const indegree = Array(numCourses).fill(0);\\n\\n  for (const [e, v] of prerequisites) {\\n    // build graph map\\n    if (graph.has(v)) {\\n      graph.get(v).push(e);\\n    } else {\\n      graph.set(v, [e]);\\n    }\\n    // build indegree array\\n    indegree[e]++;\\n  }\\n\\n  for (let i = 0; i < indegree.length; i++) {\\n    if (indegree[i] === 0) queue.push(i);\\n  }\\n\\n  while (queue.length) {\\n    const v = queue.shift();\\n    if (graph.has(v)) {\\n      for (const e of graph.get(v)) {\\n        indegree[e]--;\\n        if (indegree[e] === 0) queue.push(e);\\n      }\\n    }\\n    order.push(v);\\n  }\\n\\n  return numCourses === order.length ? order : [];\\n};\\n```\\n\\n* 44/44 cases passed (64 ms)\\n* Your runtime beats 96.3 % of javascript submissions\\n* Your memory usage beats 33.33 % of javascript submissions (38.2 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number} numCourses\\n * @param {number[][]} prerequisites\\n * @return {number[]}\\n */\\nvar findOrder = function(numCourses, prerequisites) {\\n  const order = [];\\n  const queue = [];\\n  const graph = new Map();\\n  const indegree = Array(numCourses).fill(0);\\n\\n  for (const [e, v] of prerequisites) {\\n    // build graph map\\n    if (graph.has(v)) {\\n      graph.get(v).push(e);\\n    } else {\\n      graph.set(v, [e]);\\n    }\\n    // build indegree array\\n    indegree[e]++;\\n  }\\n\\n  for (let i = 0; i < indegree.length; i++) {\\n    if (indegree[i] === 0) queue.push(i);\\n  }\\n\\n  while (queue.length) {\\n    const v = queue.shift();\\n    if (graph.has(v)) {\\n      for (const e of graph.get(v)) {\\n        indegree[e]--;\\n        if (indegree[e] === 0) queue.push(e);\\n      }\\n    }\\n    order.push(v);\\n  }\\n\\n  return numCourses === order.length ? order : [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1642760,
                "title": "c-easy-to-solve-detailed-explanation-of-topological-sort-using-dfs",
                "content": "**Intiuition:-**\\nFirst let\\'s reframe the question ,  We are given `numCourses` respresenting total number of courses and a array `prerequisites`  where `prerequisites[i] = [ai, bi]` .\\nWe must take `ai` if we want to take `bi` course. So after getting a gist we can convert those statements into graph by making nodes as courses. \\n```\\nLet\\'s understand this a bit more in a clear way. \\nSo we will make courses as our nodes and the nodes will be connected with each other . \\nFor Example : \\nIf to complete course number 3 the prerequisite is 2 and to complete course 2 the prerequisite is 1 then the formualted graph can be  1->2->3 . \\nThis type of sorting is known as topological sorting .\\n\\nSo after understanding the example we also got one more clue that the first course we learn should have no prerequisites then only \\nwe can learn that course otherwise we need to return an empty array []. \\n```\\nThe problem can be solved in two ways one is BFS and other is DFS . \\n\\n**Algorithm implemented using DFS:-**\\n1.Let\\'s initialize a 2d `graph` and an `result` and `indegree` vector  ,this vector will help us on whether the node is visited or not  i.e., all courses require before that course has taken or not.\\n2. After initializing, start the DFS traversal from the course which has 0 `prerequisites ` i.e whose indegree is 0 and make sure you mark it as `visited ` \\n3. After completion of a course add the `current course` to our `result` . Since we aded a course we will reduce the `indegree` for all the courses whose prerequisited was the current course.\\n4. If the indegree becomes 0 of a course then again add them into DFS and start DFS call from that course .\\n5. Now repeat the steps by calling dfs again for each course with `indegree` 0.\\n6. In the end return `result` if it contains all `numCourses` i.e Check size of result. `If size == numCourses`, return `result`, else `return an []`\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        //Initializing a 2d graph , result vector and indegree array\\n        vector<vector<int>> graph(numCourses);\\n        vector<int> result, indegree(numCourses);\\n        \\n        //Indegree\\n        for(auto& prereq : prerequisites)\\n            graph[prereq[1]].push_back(prereq[0]),\\n            indegree[prereq[0]]++;\\n        \\n        //dfs call\\n        function<void(int)> dfs = [&](int current) {\\n            //Adding the current course into the result \\n            result.push_back(current);            \\n            //Making sure that the current course that we added is marked as visited\\n            indegree[current] = -1;                     \\n            \\n            //if any next course has a indegree of 0 ie if it has no prerequisites requirement than make dfs call for that course\\n            for(auto nextCourse : graph[current])          \\n                if(--indegree[nextCourse] == 0)     \\n                    dfs(nextCourse);                \\n        };\\n        \\n        // If the indegree becomes 0 of a course then again add them into DFS and start DFS call from that course .\\n        for(int i = 0; i < numCourses; i++)\\n            if(indegree[i] == 0) dfs(i);                   \\n        \\n        //In the end return `result` if it contains all `numCourses` else return  []\\n        if(size(result) == numCourses) return result;\\n        return {};\\n    }\\n};\\n```\\n**Time Complexity :** *`O(N + E)`* [O(E) to form adjacency list and O(N + E) for our DFS ].\\n**Space Complexity :** *`O(N + E)`*, [Used by recursive stack and prerequisites as adjacency list graph in `graph`]\\n\\n.......*Continuation from previous posts..\\nTill now in the Dr.Cheems Doge ancient ruins arc phase 2, \"Doggo,Dogenderous,Dogelina,Yomru and JThree all were trying to open the door of ancient ruin by their own ways .After failing several times they all took a pause while JThree started to circulate around the doors. After investigating the doors he found some clues based on an ancient story of four cardinal seasons. He referenced this theory as \\'Celestial dogemon\\', JThree told others about it but rest felt a bit uneasy after listening the story . So to verify this, they called a chopper and  a chopper picked them up and fleed towards the sky right above the ceiling they all verified theory and all were amazed by the view of Ancient laboratory...\"\\nPhase 3 to be continued in the next post*...........\\n\\n**Feel free to comment or upvote if you liked the post**\\nSpecial thanks to @archit91 :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nLet\\'s understand this a bit more in a clear way. \\nSo we will make courses as our nodes and the nodes will be connected with each other . \\nFor Example : \\nIf to complete course number 3 the prerequisite is 2 and to complete course 2 the prerequisite is 1 then the formualted graph can be  1->2->3 . \\nThis type of sorting is known as topological sorting .\\n\\nSo after understanding the example we also got one more clue that the first course we learn should have no prerequisites then only \\nwe can learn that course otherwise we need to return an empty array []. \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        //Initializing a 2d graph , result vector and indegree array\\n        vector<vector<int>> graph(numCourses);\\n        vector<int> result, indegree(numCourses);\\n        \\n        //Indegree\\n        for(auto& prereq : prerequisites)\\n            graph[prereq[1]].push_back(prereq[0]),\\n            indegree[prereq[0]]++;\\n        \\n        //dfs call\\n        function<void(int)> dfs = [&](int current) {\\n            //Adding the current course into the result \\n            result.push_back(current);            \\n            //Making sure that the current course that we added is marked as visited\\n            indegree[current] = -1;                     \\n            \\n            //if any next course has a indegree of 0 ie if it has no prerequisites requirement than make dfs call for that course\\n            for(auto nextCourse : graph[current])          \\n                if(--indegree[nextCourse] == 0)     \\n                    dfs(nextCourse);                \\n        };\\n        \\n        // If the indegree becomes 0 of a course then again add them into DFS and start DFS call from that course .\\n        for(int i = 0; i < numCourses; i++)\\n            if(indegree[i] == 0) dfs(i);                   \\n        \\n        //In the end return `result` if it contains all `numCourses` else return  []\\n        if(size(result) == numCourses) return result;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390636,
                "title": "c-solution-topological-sort",
                "content": "Topological sort -> BFS-> kahn\\'s Algorithm\\n\\n**Time complexity - O(V* E)**\\nSimilar to Course Schedule 1: https://leetcode.com/problems/course-schedule/discuss/1390567/c-solution-9956-faster\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n       \\n        vector<int>adj[numCourses];\\n        queue<int>q;\\n        vector<int>indegree(numCourses,0);\\n        //store \\n         for(int i =0; i< prerequisites.size(); i++ ){\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }\\n        //indegree u -> v\\n        for(int i =0; i < prerequisites.size(); i++){\\n            indegree[prerequisites[i][0]]++;\\n            \\n        }\\n        //push into q,indegree having 0\\n        for(int i =0; i< indegree.size(); i++){\\n            if(indegree[i] == 0)q.push(i);\\n        }\\n        vector<int>result;\\n        //Simple BFS and keep storing indegree values equal to 0 into result vector\\n        while(!q.empty()){\\n           int v = q.front();\\n            q.pop();\\n            for(auto it : adj[v]){\\n                indegree[it]--;\\n                 if(indegree[it] == 0)q.push(it);\\n            }\\n            result.emplace_back(v);\\n        }\\n        //check case \\n        if (result.size() != numCourses)\\n        result.clear();\\n        return result;\\n    }\\n};\\n```\\n**Please upvote if you like the solution and comment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n       \\n        vector<int>adj[numCourses];\\n        queue<int>q;\\n        vector<int>indegree(numCourses,0);\\n        //store \\n         for(int i =0; i< prerequisites.size(); i++ ){\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }\\n        //indegree u -> v\\n        for(int i =0; i < prerequisites.size(); i++){\\n            indegree[prerequisites[i][0]]++;\\n            \\n        }\\n        //push into q,indegree having 0\\n        for(int i =0; i< indegree.size(); i++){\\n            if(indegree[i] == 0)q.push(i);\\n        }\\n        vector<int>result;\\n        //Simple BFS and keep storing indegree values equal to 0 into result vector\\n        while(!q.empty()){\\n           int v = q.front();\\n            q.pop();\\n            for(auto it : adj[v]){\\n                indegree[it]--;\\n                 if(indegree[it] == 0)q.push(it);\\n            }\\n            result.emplace_back(v);\\n        }\\n        //check case \\n        if (result.size() != numCourses)\\n        result.clear();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59472,
                "title": "java-13ms-iterative-dfs-solution-with-explanation",
                "content": "Just FYI, here is [my solution for the other problem: Course Schedule][1].\\n\\nMapping of element value in `visited` array to colors in CLRS DFS algorithm: \\n0 -> White, -1 -> Gray, 1 -> Black\\n\\nWe need to peek a node in stack for the first time, and pop it for the second time we meet it. In other words, we need to keep a node in stack until the dfs search rooted at it has been finished, which is equivalent to the end of a recursive call.\\n\\nFor the end of the corresponding dfs search rooted at `prere`: -1 corresponding to `prere` as a normal node; 1 corresponding to `prere` as an end node of a cross edge. \\n\\nMy Java implementation of the iterative DFS algorithm based on its recursive counterpart in CLRS (13ms):\\n\\n    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            int[] visited = new int[numCourses];\\n            List<List<Integer>> graph = new ArrayList<>();\\n            ArrayDeque<Integer> stack = new ArrayDeque<>();\\n            ArrayDeque<Integer> auxStack = new ArrayDeque<>();\\n            int[] order = new int[numCourses];\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                graph.add(new ArrayList<Integer>());\\n            }\\n            for (int i = 0; i < prerequisites.length; i++) {\\n                int course = prerequisites[i][0], prere = prerequisites[i][1];\\n                graph.get(prere).add(course);\\n            }\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                if (visited[i] == 0) {\\n                    stack.push(i);\\n                    while (!stack.isEmpty()) {\\n                        Integer prere = stack.peek();\\n                        if(visited[prere] == 0) {\\n                            // start of dfs search rooted at prere\\n                            visited[prere] = -1;\\n                        }\\n                        else if (visited[prere] == -1){\\n                            // end of dfs search rooted at prere; prere is a normal node\\n                            stack.pop();\\n                            visited[prere] = 1;\\n                            auxStack.push(prere);\\n                            continue;\\n                        } \\n                        else if (visited[prere] == 1) {\\n                           // since prere is an end node of a cross edge; the dfs search rooted at prere\\n                           // has been finished as part of another dfs search rooted at another node\\n                           // we have no need to explore its neighbors again\\n                            stack.pop();\\n                            continue;\\n                        }\\n                        for (Integer course: graph.get(prere)) {\\n                            if (visited[course] == 0) {\\n                                stack.push(course);\\n                            }\\n                            else if (visited[course] == -1) {\\n                                return new int[0];\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n            for (int i = 0; i<numCourses; i++) {\\n                order[i] = auxStack.pop();\\n            }\\n            return order;\\n        }\\n    }\\n\\nJust for comparison, here is my Java implementation of the recursive DFS algorithm in CLRS (8ms):\\n\\n    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            int[] visited = new int[numCourses];\\n            ArrayDeque<Integer> stack = new ArrayDeque<Integer>();\\n            List<ArrayList<Integer>> graph = new ArrayList<ArrayList<Integer>>();\\n            for (int i = 0; i < numCourses; i++) {\\n                graph.add(new ArrayList<Integer>());\\n            }\\n            for (int i = 0; i < prerequisites.length; i++) {\\n                graph.get(prerequisites[i][1]).add(prerequisites[i][0]);\\n            }\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                if (visited[i] == 0 && dfsDetectCycle(graph, visited, stack, i)) return new int[0];\\n            }\\n            int[] order = new int[numCourses];\\n            for (int i = 0; i < numCourses; i++) \\n                order[i] = stack.pop();\\n            return order;\\n        }\\n        \\n        private boolean dfsDetectCycle(List<ArrayList<Integer>> graph, int[] visited,\\n                                                  ArrayDeque<Integer> stack, int prere) {\\n            visited[prere] = -1; //Gray\\n            for (int course: graph.get(prere)) {\\n                if (visited[course] == -1) return true;\\n                else if (visited[course] == 0 && dfsDetectCycle(graph, visited, stack, course)) return true;\\n            }\\n            visited[prere] = 1; //Black\\n            stack.push(prere);\\n            return false;\\n        }\\n    }\\n\\n\\nMy Java implementation of the BFS solution with indegree (11ms):\\n\\n    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            int[] indegree = new int[numCourses];\\n            List<List<Integer>> graph = new ArrayList<>();\\n            Queue<Integer> queue = new ArrayDeque<>();\\n            int count = 0;\\n            int[] order = new int[numCourses];\\n            for (int i = 0; i < numCourses; i++) {\\n                graph.add(new ArrayList<Integer>());\\n            }\\n            for (int i = 0; i < prerequisites.length; i++) {\\n                int course = prerequisites[i][0], prere = prerequisites[i][1];\\n                indegree[course]++;\\n                graph.get(prere).add(course);\\n            }\\n            for (int i = 0; i < numCourses; i++) {\\n                if (indegree[i] == 0) \\n                    queue.offer(i);\\n            }\\n            \\n            while (!queue.isEmpty()) {\\n                Integer prere = queue.poll();\\n                order[count++] = prere;\\n                for (Integer course: graph.get(prere)) {\\n                    if (--indegree[course] == 0) \\n                        queue.offer(course);\\n                }\\n            }\\n            if(count == numCourses) {\\n                return order;\\n            }\\n            else {\\n                return new int[0];\\n            }\\n        }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/71444/explained-java-12ms-iterative-solution-based-algorithm-clrs?show=71444#q71444",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            int[] visited = new int[numCourses];\\n            List<List<Integer>> graph = new ArrayList<>();\\n            ArrayDeque<Integer> stack = new ArrayDeque<>();\\n            ArrayDeque<Integer> auxStack = new ArrayDeque<>();\\n            int[] order = new int[numCourses];\\n            \\n            for (int i = 0; i < numCourses; i++) {\\n                graph.add(new ArrayList<Integer>());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 59486,
                "title": "ac-python-topological-sort-72-ms-o-v-e-time-and-o-v-e-space",
                "content": "    def findOrder(self, n, pres):\\n        ind = [[] for _ in xrange(n)]  # indegree\\n        oud = [0] * n  # outdegree\\n        for p in pres:\\n            oud[p[0]] += 1\\n            ind[p[1]].append(p[0])\\n        ans = []\\n        for i in xrange(n):\\n            if oud[i] == 0:\\n                ans.append(i)\\n        l = 0\\n        while l != len(ans):\\n            x = ans[l]\\n            l += 1\\n            for i in ind[x]:\\n                oud[i] -= 1\\n                if oud[i] == 0:\\n                    ans.append(i)\\n        return ans if l == n else []\\n\\n\\n    # 35 / 35 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 72 ms\\n    # 96.08%\\n\\nThe code is almost the same as \"course schedule\". The only difference is we keep the courses taken instead of remove them, everything else is the same.",
                "solutionTags": [],
                "code": "    def findOrder(self, n, pres):\\n        ind = [[] for _ in xrange(n)]  # indegree\\n        oud = [0] * n  # outdegree\\n        for p in pres:\\n            oud[p[0]] += 1\\n            ind[p[1]].append(p[0])\\n        ans = []\\n        for i in xrange(n):\\n            if oud[i] == 0:\\n                ans.append(i)\\n        l = 0\\n        while l != len(ans):\\n            x = ans[l]\\n            l += 1\\n            for i in ind[x]:\\n                oud[i] -= 1\\n                if oud[i] == 0:\\n                    ans.append(i)\\n        return ans if l == n else []\\n\\n\\n    # 35 / 35 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 72 ms\\n    # 96.08%\\n\\nThe code is almost the same as \"course schedule\". The only difference is we keep the courses taken instead of remove them, everything else is the same.",
                "codeTag": "Python3"
            },
            {
                "id": 146326,
                "title": "javascript-dfs",
                "content": "```js\\nfunction findOrder(numCourses, prerequisites) {\\n  const seen = new Set();\\n  const seeing = new Set();\\n  const res = [];\\n  \\n  const adj = [...Array(numCourses)].map(r => []);\\n  for (let [u, v] of prerequisites) {\\n    adj[v].push(u);\\n  }\\n  \\n  for (let c = 0; c < numCourses; c++) {\\n    if (!dfs(c)) {\\n      return [];\\n    }\\n  }\\n  return res.reverse();\\n  \\n  function dfs(v) {\\n    if (seen.has(v)) {\\n      return true;\\n    }\\n    if (seeing.has(v)) {\\n      return false;\\n    }\\n    \\n    seeing.add(v);\\n    for (let nv of adj[v]) {\\n      if (!dfs(nv)) {\\n        return false;\\n      }\\n    }\\n    seeing.delete(v);\\n    seen.add(v);\\n    res.push(v);\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction findOrder(numCourses, prerequisites) {\\n  const seen = new Set();\\n  const seeing = new Set();\\n  const res = [];\\n  \\n  const adj = [...Array(numCourses)].map(r => []);\\n  for (let [u, v] of prerequisites) {\\n    adj[v].push(u);\\n  }\\n  \\n  for (let c = 0; c < numCourses; c++) {\\n    if (!dfs(c)) {\\n      return [];\\n    }\\n  }\\n  return res.reverse();\\n  \\n  function dfs(v) {\\n    if (seen.has(v)) {\\n      return true;\\n    }\\n    if (seeing.has(v)) {\\n      return false;\\n    }\\n    \\n    seeing.add(v);\\n    for (let nv of adj[v]) {\\n      if (!dfs(nv)) {\\n        return false;\\n      }\\n    }\\n    seeing.delete(v);\\n    seen.add(v);\\n    res.push(v);\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59425,
                "title": "my-python-dfs-recursive-solution-same-algorithm-for-207-and-210",
                "content": "    class Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        \"\"\"\\n        :type numCourses: int\\n        :type prerequisites: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        course_array = [[] for i in xrange(numCourses)] # each sub-list records the pre-requisites\\n        visit = [0 for i in xrange(numCourses)]         # check whether these is a loop\\n        res = []                                        # the course ordering for #210\\n        for edge in prerequisites:\\n            course_array[edge[0]].append(edge[1])\\n\\n        # For #210, put courses that don't need prerequisites into ordering.\\n        i = 0\\n        while i < numCourses:\\n            if len(course_array[i]) == 0:\\n                res += i,               # add into ordering.\\n                visit[i] = -1           # visited.\\n            i += 1\\n\\n        def dfs(x, res):\\n            # find out this course is in a loop or not\\n            # True => in a loop => invalid course\\n            if visit[x] == -1:          # visit here earlier, there's no loop.\\n                return False\\n            if visit[x] == 1:           # there's a loop!\\n                return True\\n\\n            visit[x] = 1                # begin to check this node and its prerequisite\\n            for v in course_array[x]:\\n                if dfs(v, res):\\n                    return True\\n            visit[x] = -1               # check PASSED, add this course into ordering. \\n            res.append(x)               # For #210, Here prerequisite will be added earlier.\\n            return False\\n\\n        # begin from the root\\n        for i in xrange(numCourses):\\n            if dfs(i, res):\\n                return []           # if there's a loop => NOT possible to complete.\\n        \\n        return res        # In #207, just return True",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "    class Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        \"\"\"\\n        :type numCourses: int\\n        :type prerequisites: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        course_array = [[] for i in xrange(numCourses)] # each sub-list records the pre-requisites\\n        visit = [0 for i in xrange(numCourses)]         # check whether these is a loop\\n        res = []                                        # the course ordering for #210\\n        for edge in prerequisites:\\n            course_array[edge[0]].append(edge[1])\\n\\n        # For #210, put courses that don't need prerequisites into ordering.\\n        i = 0\\n        while i < numCourses:\\n            if len(course_array[i]) == 0:\\n                res += i,               # add into ordering.\\n                visit[i] = -1           # visited.\\n            i += 1\\n\\n        def dfs(x, res):\\n            # find out this course is in a loop or not\\n            # True => in a loop => invalid course\\n            if visit[x] == -1:          # visit here earlier, there's no loop.\\n                return False\\n            if visit[x] == 1:           # there's a loop!\\n                return True\\n\\n            visit[x] = 1                # begin to check this node and its prerequisite\\n            for v in course_array[x]:\\n                if dfs(v, res):\\n                    return True\\n            visit[x] = -1               # check PASSED, add this course into ordering. \\n            res.append(x)               # For #210, Here prerequisite will be added earlier.\\n            return False\\n\\n        # begin from the root\\n        for i in xrange(numCourses):\\n            if dfs(i, res):\\n                return []           # if there's a loop => NOT possible to complete.\\n        \\n        return res        # In #207, just return True",
                "codeTag": "Java"
            },
            {
                "id": 3224528,
                "title": "210-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved using topological sort. First, we need to build a graph to represent the courses and their prerequisites, and then perform topological sort on the graph to get the order of courses.\\n\\nHere is the step by step explanation:\\n\\n1. Build the graph:\\nWe can represent the courses and their prerequisites using a directed graph. Each course is a node in the graph, and each prerequisite relationship is an edge from the prerequisite to the course. We can build the graph using an adjacency list.\\n\\n2. Calculate the in-degree of each node:\\nIn-degree is the number of incoming edges for a node. We can calculate the in-degree of each node in the graph by counting the number of prerequisites for each course.\\n\\n3. Perform topological sort:\\nWe can perform topological sort on the graph using a queue. We start by adding all the nodes with in-degree 0 to the queue. Then, while the queue is not empty, we remove a node from the queue and add it to the result. For each of the node\\'s neighbors, we decrement their in-degree by 1. If a neighbor\\'s in-degree becomes 0, we add it to the queue.\\n\\n4. Check for cycle:\\nIf the result size is less than the number of courses, it means there is a cycle in the graph, and it is impossible to finish all courses.\\n\\n# Complexity\\n- Time complexity: 85.26%\\nBuilding the graph takes O(E), where E is the number of edges (prerequisites). Calculating the in-degree takes O(E). Performing topological sort takes O(V + E), where V is the number of nodes (courses). Therefore, the overall time complexity is O(V + E).\\n\\n- Space complexity: 83.92%\\nWe use O(V + E) space to store the graph and the in-degree. We also use O(V) space for the queue and the result. Therefore, the overall space complexity is O(V + E).\\n\\n# Code\\n```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        # Step 1: Build the graph\\n        graph = defaultdict(list)\\n        for course, prereq in prerequisites:\\n            graph[prereq].append(course)\\n        \\n        # Step 2: Calculate the in-degree of each node\\n        in_degree = [0] * numCourses\\n        for course, prereq in prerequisites:\\n            in_degree[course] += 1\\n        \\n        # Step 3: Perform topological sort\\n        queue = deque()\\n        for i in range(numCourses):\\n            if in_degree[i] == 0:\\n                queue.append(i)\\n        \\n        result = []\\n        while queue:\\n            node = queue.popleft()\\n            result.append(node)\\n            for neighbor in graph[node]:\\n                in_degree[neighbor] -= 1\\n                if in_degree[neighbor] == 0:\\n                    queue.append(neighbor)\\n        \\n        # Step 4: Check for cycle\\n        if len(result) < numCourses:\\n            return []\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        # Step 1: Build the graph\\n        graph = defaultdict(list)\\n        for course, prereq in prerequisites:\\n            graph[prereq].append(course)\\n        \\n        # Step 2: Calculate the in-degree of each node\\n        in_degree = [0] * numCourses\\n        for course, prereq in prerequisites:\\n            in_degree[course] += 1\\n        \\n        # Step 3: Perform topological sort\\n        queue = deque()\\n        for i in range(numCourses):\\n            if in_degree[i] == 0:\\n                queue.append(i)\\n        \\n        result = []\\n        while queue:\\n            node = queue.popleft()\\n            result.append(node)\\n            for neighbor in graph[node]:\\n                in_degree[neighbor] -= 1\\n                if in_degree[neighbor] == 0:\\n                    queue.append(neighbor)\\n        \\n        # Step 4: Check for cycle\\n        if len(result) < numCourses:\\n            return []\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59536,
                "title": "c-using-3-colored-approach",
                "content": "Here, i have used 3 colored approach. Here w -> represent white means vertex yet not visited.\\ng -> gray , it means it is under DFS recursion and we again found the same node. This means cycle exists and return false.\\nb -> black node when DFS is done visiting the node. \\nThis method checks cycle as well as keeps storing answer in stack in case cycle doesn't exists.\\n\\n    \\n\\n    class Graph {\\n        public:\\n        int v;\\n        list <int> *adj;\\n        Graph(int v)\\n        {\\n            this->v=v;\\n            adj = new list<int> [v];\\n        }\\n        void addedges(int src , int dest)\\n           {\\n    \\t     adj[dest].push_back(src);\\n           }\\t\\n    };\\n    class Solution {\\n    public:\\n        stack <int> st;\\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            Graph g(numCourses);\\n            for (int i=0 ; i < prerequisites.size() ; i++)\\n                    g.addedges(prerequisites[i].first , prerequisites[i].second);        \\n            vector <int> ans;\\n            if(!courseScheduleCheck(g))\\n                    return ans;              \\n            while(!st.empty())\\n                {\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }\\n            return ans;       \\n        }\\n       bool courseScheduleCheck(Graph g)\\n        {\\n            int v = g.v;    \\n            vector <char> visit(v,'w');\\n            for(int i=0 ; i<v;i++)\\n            {        \\n               if(visit[i]== 'w')\\n                    if(iscycle(g,i,visit))\\n                        return false;\\n            }\\n            return true;\\n        }  \\n        bool iscycle(Graph g , int i, vector <char> & visit)\\n        {\\n            list <int> ::iterator it;\\n            for(it = g.adj[i].begin() ; it!=g.adj[i].end() ; it++)\\n            {\\n                if(visit[*it]== 'g')\\n                    return true;\\n                else\\n                {\\n                    if(visit[*it] != 'b')\\n                     {\\n                         visit[*it] = 'g';\\n                         if(iscycle(g,*it,visit))\\n                            return true;\\n                     }        \\n                }     \\n            }\\n             visit[i]='b';\\n             st.push(i);           \\n            return false;\\n        }            \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        stack <int> st;\\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            Graph g(numCourses);\\n            for (int i=0 ; i < prerequisites.size() ; i++)\\n                    g.addedges(prerequisites[i].first , prerequisites[i].second);        \\n            vector <int> ans;\\n            if(!courseScheduleCheck(g))\\n                    return ans;              \\n            while(!st.empty())\\n                {\\n                    ans.push_back(st.top());\\n                    st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1333151,
                "title": "c-simple-and-clean-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCycle(vector<vector<int>>& graph,vector<int> &colors, vector<int> &res, int i) {\\n        colors[i] = 1;\\n        \\n        for (auto neighbor : graph[i]) {\\n            if(colors[neighbor] == 1) return true;\\n            if(colors[neighbor] == 0) {\\n                if (isCycle(graph, colors, res,neighbor)) return true;\\n            }\\n        }\\n        \\n        colors[i] = 2;\\n        res.push_back(i);\\n        return false;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> colors(numCourses, 0), res;\\n        vector<vector<int>> graph(numCourses);\\n        \\n        // build graph\\n        for (auto pre : prerequisites) {\\n            graph[pre[0]].push_back(pre[1]);\\n        }\\n        \\n        for (int i = 0; i < numCourses; i++) {\\n            if (!colors[i]) {\\n                if (isCycle(graph, colors, res, i)) return {};\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCycle(vector<vector<int>>& graph,vector<int> &colors, vector<int> &res, int i) {\\n        colors[i] = 1;\\n        \\n        for (auto neighbor : graph[i]) {\\n            if(colors[neighbor] == 1) return true;\\n            if(colors[neighbor] == 0) {\\n                if (isCycle(graph, colors, res,neighbor)) return true;\\n            }\\n        }\\n        \\n        colors[i] = 2;\\n        res.push_back(i);\\n        return false;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> colors(numCourses, 0), res;\\n        vector<vector<int>> graph(numCourses);\\n        \\n        // build graph\\n        for (auto pre : prerequisites) {\\n            graph[pre[0]].push_back(pre[1]);\\n        }\\n        \\n        for (int i = 0; i < numCourses; i++) {\\n            if (!colors[i]) {\\n                if (isCycle(graph, colors, res, i)) return {};\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886870,
                "title": "c-dfs-commented",
                "content": "In this approach we are checking for cycles, if there is one then we will return empty array or return the visited arrays\\n0 -> unvisited\\n1 -> unexplored\\n2 -> visited\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int node, vector<vector<int>>& graph, vector<int>& visited, vector<int>& result)\\n    {\\n        visited[node]=1;\\n        for(int i=0;i<graph[node].size();i++)\\n        {\\n            if(visited[graph[node][i]]==1)return false; // if this node is unexplored that means there is a cycle\\n            if(visited[graph[node][i]]==0)\\n            {\\n                if(!dfs(graph[node][i],graph,visited,result)) //return false \\n                    return false;\\n            }\\n        }\\n        visited[node]=2; //if function comes till here then we can mark the current node as 2 i.e, visited\\n        result.push_back(node); //we will push the visited nodes to the resulting array\\n        return true;\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<vector<int>> graph(numCourses);\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            graph[prerequisites[i][0]].push_back(prerequisites[i][1]); //making an adjacency list\\n        }\\n        vector<int> visited(numCourses,0);  //for keeping track of the nodes position.\\n\\t\\t//We first initialize every node as 0 i,e. unvisited\\n        vector<int> result; //result vector\\n        bool flag = true; \\n        for(int i=0;i<numCourses;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                if(!dfs(i,graph,visited,result)){\\n                    flag = false; // it will return false if there is a cycle detected so we can break it \\n                    break;\\n                }\\n            }\\n        }\\n        if(!flag)\\n            return vector<int>();\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int node, vector<vector<int>>& graph, vector<int>& visited, vector<int>& result)\\n    {\\n        visited[node]=1;\\n        for(int i=0;i<graph[node].size();i++)\\n        {\\n            if(visited[graph[node][i]]==1)return false; // if this node is unexplored that means there is a cycle\\n            if(visited[graph[node][i]]==0)\\n            {\\n                if(!dfs(graph[node][i],graph,visited,result)) //return false \\n                    return false;\\n            }\\n        }\\n        visited[node]=2; //if function comes till here then we can mark the current node as 2 i.e, visited\\n        result.push_back(node); //we will push the visited nodes to the resulting array\\n        return true;\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<vector<int>> graph(numCourses);\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            graph[prerequisites[i][0]].push_back(prerequisites[i][1]); //making an adjacency list\\n        }\\n        vector<int> visited(numCourses,0);  //for keeping track of the nodes position.\\n\\t\\t//We first initialize every node as 0 i,e. unvisited\\n        vector<int> result; //result vector\\n        bool flag = true; \\n        for(int i=0;i<numCourses;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                if(!dfs(i,graph,visited,result)){\\n                    flag = false; // it will return false if there is a cycle detected so we can break it \\n                    break;\\n                }\\n            }\\n        }\\n        if(!flag)\\n            return vector<int>();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646120,
                "title": "c-topological-sort-solution",
                "content": "This problem is essentially the same as [Course Schedule I](https://leetcode.com/problems/course-schedule/), except now we also need to output the ordering of courses. A topological sort works great for this because it has the property that if element `i` comes before element `j` in an array, then element `i` is a course that can be taken without taking the course represented by element `j`. The solution is basically [my solution to Course Schedule 1](https://leetcode.com/problems/course-schedule/discuss/645953/C%2B%2B-Topological-Sort-Solution), but with a slight modification to store each node once it has been discovered to have an indegree of 0, rather than simply decrementing the number of courses left to take.\\n\\nAll the courses can be taken if we can come up with a topological sorting of the courses that includes every single course. However, the input provided in the form of an array of edges is not very easy to work with, so we first convert it to an adjacency list representation. Then, we simply run a standard topological sort on the graph. We first loop through the adjacency list to get all the courses with no prerequisites (nodes of indegree 0), which will be the starting points of the topological ordering, and add them to our final result. Then, for each of those nodes, we \"remove\" the node from the graph by decrementing the indegree of all courses that it is a prerequisite for, and if any course ends up having an updated indegree of 0, then we add it to our result, as well as a queue of courses to process next and repeat the node removal process with.\\n\\nEvery time we \"remove\" a course from the graph, we decrement the number of courses to take by 1. Thus, at the end, we can simply check if the number of courses we can take (the size of the result) is equal to the number of courses we need to take: if so, then that means we were able to take all the courses and so we return the topological ordering; otherwise, we were not able to and so an empty array is returned.\\n\\nTraversing all the edges takes O(E) and then running topological sort takes O(V+E), so this solution takes O(V+E) overall. We also represent the input as an adjacency list, which takes up O(V+E) space.\\n\\nA bit wordy but easier to understand (in my opinion) than the super short solutions.\\n\\n```\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<vector<int>> graph(numCourses);\\n        vector<int> degree(numCourses, 0);\\n        queue<int> zeroDegree;\\n        vector<int> topoOrder;\\n        for(int i = 0; i<prerequisites.size(); i++){\\n            graph[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            degree[prerequisites[i][0]]++;\\n        }\\n\\n        for(int i = 0; i<degree.size(); i++){\\n            if(degree[i] == 0){\\n                zeroDegree.push(i);\\n                topoOrder.push_back(i);\\n            }\\n        }\\n\\n        while(!zeroDegree.empty()){\\n            int node = zeroDegree.front();\\n            zeroDegree.pop();\\n            for(int i = 0; i<graph[node].size(); i++){\\n                int connectedNode = graph[node][i];\\n                degree[connectedNode]--;\\n                if(degree[connectedNode] == 0){\\n                    zeroDegree.push(connectedNode);\\n                    topoOrder.push_back(connectedNode);\\n                }\\n            }\\n        }\\n        if(topoOrder.size() != numCourses){\\n            return vector<int>();\\n        }\\n        return topoOrder;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<vector<int>> graph(numCourses);\\n        vector<int> degree(numCourses, 0);\\n        queue<int> zeroDegree;\\n        vector<int> topoOrder;\\n        for(int i = 0; i<prerequisites.size(); i++){\\n            graph[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            degree[prerequisites[i][0]]++;\\n        }\\n\\n        for(int i = 0; i<degree.size(); i++){\\n            if(degree[i] == 0){\\n                zeroDegree.push(i);\\n                topoOrder.push_back(i);\\n            }\\n        }\\n\\n        while(!zeroDegree.empty()){\\n            int node = zeroDegree.front();\\n            zeroDegree.pop();\\n            for(int i = 0; i<graph[node].size(); i++){\\n                int connectedNode = graph[node][i];\\n                degree[connectedNode]--;\\n                if(degree[connectedNode] == 0){\\n                    zeroDegree.push(connectedNode);\\n                    topoOrder.push_back(connectedNode);\\n                }\\n            }\\n        }\\n        if(topoOrder.size() != numCourses){\\n            return vector<int>();\\n        }\\n        return topoOrder;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293048,
                "title": "detecting-cycle-in-directed-graph-problem",
                "content": "```\\nclass Solution {\\n    static class DetectCycleGraph {\\n\\t\\tprivate int V;\\n\\t\\tprivate List<List<Integer>> edges;\\n\\n\\t\\tDetectCycleGraph(int n) {\\n\\t\\t\\tthis.V = n;\\n\\t\\t\\tSystem.out.println(n);\\n\\t\\t\\tedges = new ArrayList<>();\\n\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tedges.add(new ArrayList<>());\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic DetectCycleGraph() {\\n\\t\\t}\\n\\n\\t\\tprivate void addEdge(int i, int j) {\\n\\t\\t\\tedges.get(i).add(j);\\n\\t\\t}\\n\\n\\t\\tList<Integer> l = new ArrayList<>();\\n\\n\\t\\tpublic int[] isCycle(DetectCycleGraph graph) {\\n\\n\\t\\t\\tboolean[] visited = new boolean[this.V];\\n\\t\\t\\tboolean[] curRec = new boolean[this.V];\\n\\t\\t\\tfor (int i = 0; i < this.V; i++) {\\n\\t\\t\\t\\tif (isCycleUtil(visited, curRec, i))\\n\\t\\t\\t\\t\\treturn new int[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tint[] res = new int[V];\\n\\t\\t\\tint index = 0;\\n\\t\\t\\tfor (Integer i : l) {\\n\\t\\t\\t\\tres[index] = i;\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic boolean isCycleUtil(boolean[] visited, boolean[] curRec, int i) {\\n\\n\\t\\t\\tif (visited[i] == false) {\\n\\n\\t\\t\\t\\tvisited[i] = true;\\n\\t\\t\\t\\tcurRec[i] = true;\\n\\n\\t\\t\\t\\tList<Integer> neighbours = edges.get(i);\\n\\t\\t\\t\\tfor (Integer v : neighbours) {\\n\\n\\t\\t\\t\\t\\tif (!visited[v] && isCycleUtil(visited, curRec, v))\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\telse if (curRec[v])\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tl.add(new Integer(i));\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurRec[i] = false;\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\n\\t\\tDetectCycleGraph graph = new DetectCycleGraph(numCourses);\\n\\t\\tfor (int i = 0; i < prerequisites.length; i++) {\\n\\t\\t\\tint[] sub = prerequisites[i];\\n\\t\\t\\tgraph.addEdge(sub[0], sub[1]);\\n\\t\\t}\\n\\t\\treturn graph.isCycle(graph);\\n\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static class DetectCycleGraph {\\n\\t\\tprivate int V;\\n\\t\\tprivate List<List<Integer>> edges;\\n\\n\\t\\tDetectCycleGraph(int n) {\\n\\t\\t\\tthis.V = n;\\n\\t\\t\\tSystem.out.println(n);\\n\\t\\t\\tedges = new ArrayList<>();\\n\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tedges.add(new ArrayList<>());\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic DetectCycleGraph() {\\n\\t\\t}\\n\\n\\t\\tprivate void addEdge(int i, int j) {\\n\\t\\t\\tedges.get(i).add(j);\\n\\t\\t}\\n\\n\\t\\tList<Integer> l = new ArrayList<>();\\n\\n\\t\\tpublic int[] isCycle(DetectCycleGraph graph) {\\n\\n\\t\\t\\tboolean[] visited = new boolean[this.V];\\n\\t\\t\\tboolean[] curRec = new boolean[this.V];\\n\\t\\t\\tfor (int i = 0; i < this.V; i++) {\\n\\t\\t\\t\\tif (isCycleUtil(visited, curRec, i))\\n\\t\\t\\t\\t\\treturn new int[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tint[] res = new int[V];\\n\\t\\t\\tint index = 0;\\n\\t\\t\\tfor (Integer i : l) {\\n\\t\\t\\t\\tres[index] = i;\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic boolean isCycleUtil(boolean[] visited, boolean[] curRec, int i) {\\n\\n\\t\\t\\tif (visited[i] == false) {\\n\\n\\t\\t\\t\\tvisited[i] = true;\\n\\t\\t\\t\\tcurRec[i] = true;\\n\\n\\t\\t\\t\\tList<Integer> neighbours = edges.get(i);\\n\\t\\t\\t\\tfor (Integer v : neighbours) {\\n\\n\\t\\t\\t\\t\\tif (!visited[v] && isCycleUtil(visited, curRec, v))\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\telse if (curRec[v])\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tl.add(new Integer(i));\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurRec[i] = false;\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\n\\t\\tDetectCycleGraph graph = new DetectCycleGraph(numCourses);\\n\\t\\tfor (int i = 0; i < prerequisites.length; i++) {\\n\\t\\t\\tint[] sub = prerequisites[i];\\n\\t\\t\\tgraph.addEdge(sub[0], sub[1]);\\n\\t\\t}\\n\\t\\treturn graph.isCycle(graph);\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59460,
                "title": "java-5-6ms-dfs-solution",
                "content": "To keep the dfs algorithm from loop, I used 0, 1, 2 to represent the states of \"unvisited\", \"visiting\", \"visited\", respectively.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List[] course=new List[numCourses];\\n        int[] map=new int[numCourses];\\n        List<Integer> ans=new ArrayList<Integer>();\\n        for(int i=0;i<numCourses;i++)\\n        course[i]=new ArrayList<Integer>();\\n        for(int i=0;i<prerequisites.length;i++)\\n        course[prerequisites[i][0]].add(prerequisites[i][1]);\\n        for(int i=0;i<numCourses;i++)\\n        if(dfs(course,i,ans,map)==false) return new int[0];\\n        int[] an=new int[ans.size()];\\n        for(int i=0;i<ans.size();i++)\\n        an[i]=ans.get(i);\\n        return an;\\n    }\\n    public boolean dfs(List[] course,int req,List<Integer> ans,int[] map)\\n    {\\n        if(map[req]==0)\\n        {\\n            map[req]=1;\\n            for(int i=0;i<course[req].size();i++) \\n            if(dfs(course,(int)course[req].get(i),ans,map)==false) return false;\\n            map[req]=2;\\n        } \\n        else if(map[req]==1) return false;\\n        else if(map[req]==2) return true;\\n        ans.add(req);\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "To keep the dfs algorithm from loop, I used 0, 1, 2 to represent the states of \"unvisited\", \"visiting\", \"visited\", respectively.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List[] course=new List[numCourses];\\n        int[] map=new int[numCourses];\\n        List<Integer> ans=new ArrayList<Integer>();\\n        for(int i=0;i<numCourses;i++)\\n        course[i]=new ArrayList<Integer>();\\n        for(int i=0;i<prerequisites.length;i++)\\n        course[prerequisites[i][0]].add(prerequisites[i][1]);\\n        for(int i=0;i<numCourses;i++)\\n        if(dfs(course,i,ans,map)==false) return new int[0];\\n        int[] an=new int[ans.size()];\\n        for(int i=0;i<ans.size();i++)\\n        an[i]=ans.get(i);\\n        return an;\\n    }\\n    public boolean dfs(List[] course,int req,List<Integer> ans,int[] map)\\n    {\\n        if(map[req]==0)\\n        {\\n            map[req]=1;\\n            for(int i=0;i<course[req].size();i++) \\n            if(dfs(course,(int)course[req].get(i),ans,map)==false) return false;\\n            map[req]=2;\\n        } \\n        else if(map[req]==1) return false;\\n        else if(map[req]==2) return true;\\n        ans.add(req);\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1213903,
                "title": "clean-java-dfs-topological-sort-with-comments",
                "content": "```\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\t\\t\\n\\t// build the adjacency list, with each course acting as a node.\\n    List<Integer> [] adj = new ArrayList[numCourses];\\n    for (int i = 0; i < numCourses; i++) adj[i] = new ArrayList<Integer>();\\n    for (int i = 0; i < prerequisites.length; i++) adj[prerequisites[i][0]].add(prerequisites[i][1]);\\n\\n    // this array is to track the visited nodes, initially all nodes are in state 0 (unvisisted).\\n    int[] visited = new int[numCourses];\\n    List<Integer> res = new ArrayList<>();\\n    \\n\\t// perform dfs on each node in the graph as the graph may not be fully connected.\\n    for (int i = 0; i < adj.length; i++) {\\n        if (visited[i] == 0)  {\\n\\t\\t\\t// if cycle found from any node return an empty array.\\n            if (topSort(i, res, adj, visited) == false) return new int[0];\\n        }\\n    }\\n\\t// if no cycles were found we can copy the ArrayList over to an array and return.\\n    int[] ans = new int[res.size()];\\n    for (int i = 0; i < res.size(); i++) ans[i] = res.get(i);\\n    return ans;\\n}\\n\\npublic boolean topSort(int curr, List<Integer> res, List<Integer> [] adj, int[] visited) {\\n    visited[curr] = 1; // mark the current node with state 1 (visiting).\\n    List<Integer> neighbours = adj[curr]; // get all neighbouring nodes.\\n    for (Integer i : neighbours) {\\n\\t\\t// if one of the neighbours is also being visited then there is a cycle.\\n        if(visited[i] == 1) return false; \\n        if (visited[i] == 0) {\\n\\t\\t\\t// perform top sort on all unvisisted neighbours.\\n            if (topSort(i, res, adj, visited) == false) return false;\\n        }\\n    }\\n\\t// mark current node with state 2 (visited) and add it to the list holding the result.\\n    visited[curr] = 2;\\n    res.add(curr);\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort",
                    "Recursion"
                ],
                "code": "```\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\t\\t\\n\\t// build the adjacency list, with each course acting as a node.\\n    List<Integer> [] adj = new ArrayList[numCourses];\\n    for (int i = 0; i < numCourses; i++) adj[i] = new ArrayList<Integer>();\\n    for (int i = 0; i < prerequisites.length; i++) adj[prerequisites[i][0]].add(prerequisites[i][1]);\\n\\n    // this array is to track the visited nodes, initially all nodes are in state 0 (unvisisted).\\n    int[] visited = new int[numCourses];\\n    List<Integer> res = new ArrayList<>();\\n    \\n\\t// perform dfs on each node in the graph as the graph may not be fully connected.\\n    for (int i = 0; i < adj.length; i++) {\\n        if (visited[i] == 0)  {\\n\\t\\t\\t// if cycle found from any node return an empty array.\\n            if (topSort(i, res, adj, visited) == false) return new int[0];\\n        }\\n    }\\n\\t// if no cycles were found we can copy the ArrayList over to an array and return.\\n    int[] ans = new int[res.size()];\\n    for (int i = 0; i < res.size(); i++) ans[i] = res.get(i);\\n    return ans;\\n}\\n\\npublic boolean topSort(int curr, List<Integer> res, List<Integer> [] adj, int[] visited) {\\n    visited[curr] = 1; // mark the current node with state 1 (visiting).\\n    List<Integer> neighbours = adj[curr]; // get all neighbouring nodes.\\n    for (Integer i : neighbours) {\\n\\t\\t// if one of the neighbours is also being visited then there is a cycle.\\n        if(visited[i] == 1) return false; \\n        if (visited[i] == 0) {\\n\\t\\t\\t// perform top sort on all unvisisted neighbours.\\n            if (topSort(i, res, adj, visited) == false) return false;\\n        }\\n    }\\n\\t// mark current node with state 2 (visited) and add it to the list holding the result.\\n    visited[curr] = 2;\\n    res.add(curr);\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947592,
                "title": "java-simple-dfs-3ms",
                "content": "```\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<numCourses;i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int[] pre:prerequisites)\\n            graph.get(pre[1]).add(pre[0]);\\n        \\n        boolean[] checked = new boolean[numCourses];\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0;i<numCourses;i++){\\n            boolean[] path = new boolean[numCourses];\\n            if(isCyclic(i,graph,stack,path,checked)==true)\\n                return new int[0];\\n        }\\n        int[] res = new int[numCourses];\\n        for(int i=0;i<numCourses;i++)\\n            res[i] = stack.pop();\\n        return res;\\n    }\\n    \\n    boolean isCyclic(int node,List<List<Integer>> graph,Stack<Integer> stack,boolean[] path,boolean[] checked){\\n        if(checked[node]==true)\\n            return false;\\n        if(path[node]==true)\\n            return true;\\n        path[node] = true;\\n        for(int adj:graph.get(node)){\\n            if(isCyclic(adj,graph,stack,path,checked)==true)\\n                return true;\\n        }\\n        stack.push(node);\\n        path[node] = false;\\n        checked[node] = true;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<numCourses;i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int[] pre:prerequisites)\\n            graph.get(pre[1]).add(pre[0]);\\n        \\n        boolean[] checked = new boolean[numCourses];\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0;i<numCourses;i++){\\n            boolean[] path = new boolean[numCourses];\\n            if(isCyclic(i,graph,stack,path,checked)==true)\\n                return new int[0];\\n        }\\n        int[] res = new int[numCourses];\\n        for(int i=0;i<numCourses;i++)\\n            res[i] = stack.pop();\\n        return res;\\n    }\\n    \\n    boolean isCyclic(int node,List<List<Integer>> graph,Stack<Integer> stack,boolean[] path,boolean[] checked){\\n        if(checked[node]==true)\\n            return false;\\n        if(path[node]==true)\\n            return true;\\n        path[node] = true;\\n        for(int adj:graph.get(node)){\\n            if(isCyclic(adj,graph,stack,path,checked)==true)\\n                return true;\\n        }\\n        stack.push(node);\\n        path[node] = false;\\n        checked[node] = true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59538,
                "title": "standard-bfs-method-for-course-schedule-ii",
                "content": "The idea is to start from courses upon which no other courses will depend(These courses all have the least  priority and should come at the last in the order list).  Then do standard BFS on these courses and try to find  courses that have next level of priority(These courses will come right before the least priority courses in the order list). And continue the process until we have no more courses to deal with. If there is no cycle in the prerequisites graph, then in this way we should be able to deal with all the courses. Otherwise there will be remaining courses left untended.  See the comments in the code for more information.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n    \\t// for each course in the map nextVertex, the corresponding set contains prerequisite courses for this course \\n        Map<Integer, Set<Integer>> nextVertex = new HashMap<>();\\n        // preVertex[i] indicates the number of courses that depend on course i\\n        int[] preVertex = new int[numCourses];\\n        \\n        // set up nextVertex and preVertex\\n        for (int i = 0; i < prerequisites.length; i++) {\\n        \\tif (!nextVertex.containsKey(prerequisites[i][0])) {\\n        \\t\\tnextVertex.put(prerequisites[i][0], new HashSet<>());\\n        \\t}\\n        \\t\\n        \\tif (nextVertex.get(prerequisites[i][0]).add(prerequisites[i][1])) {\\n        \\t\\tpreVertex[prerequisites[i][1]]++;\\n        \\t}\\n        }\\n        \\n        // queue for BFS, which will only hold courses currently upon which no other courses depend\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < preVertex.length; i++) {\\n        \\t// start from courses upon which no other courses depend. These courses should come last in the order list\\n        \\tif (preVertex[i] == 0) {\\n        \\t\\tqueue.offerLast(i);\\n        \\t}\\n        }\\n        \\n        // array for the result, which will be filled up from the end by index\\n        int[] res = new int[numCourses];\\n        int index = res.length - 1;\\n        \\n        while (!queue.isEmpty()) {\\n        \\tint key = queue.pollFirst(); // this is a course that no other courses will depend upon\\n        \\tres[index--] = key;          // so we put it at the end of the order list\\n        \\t\\n        \\t// since we are done with course \"key\", for any other course that course \"key\" is dependent on, we can decrease\\n        \\t// the corrresponding preVertex by one and check if it is qualified to be added to the queue.\\n        \\tif (nextVertex.containsKey(key)) {\\n        \\t\\tfor (int i : nextVertex.get(key)) {\\n        \\t\\t\\tif (--preVertex[i] == 0) {\\n        \\t\\t\\t\\tqueue.offerLast(i);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\t\\n        \\t--numCourses; // we are done with course \"key\", so reduce the remaining number of courses by 1\\n        }\\n        \\n        // if the remaining number of courses is not zero, then we cannot complete all the courses; otherwise return the result\\n        return numCourses == 0 ? res : new int[0];\\n    }",
                "solutionTags": [],
                "code": "The idea is to start from courses upon which no other courses will depend(These courses all have the least  priority and should come at the last in the order list).  Then do standard BFS on these courses and try to find  courses that have next level of priority(These courses will come right before the least priority courses in the order list). And continue the process until we have no more courses to deal with. If there is no cycle in the prerequisites graph, then in this way we should be able to deal with all the courses. Otherwise there will be remaining courses left untended.  See the comments in the code for more information.\\n\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n    \\t// for each course in the map nextVertex, the corresponding set contains prerequisite courses for this course \\n        Map<Integer, Set<Integer>> nextVertex = new HashMap<>();\\n        // preVertex[i] indicates the number of courses that depend on course i\\n        int[] preVertex = new int[numCourses];\\n        \\n        // set up nextVertex and preVertex\\n        for (int i = 0; i < prerequisites.length; i++) {\\n        \\tif (!nextVertex.containsKey(prerequisites[i][0])) {\\n        \\t\\tnextVertex.put(prerequisites[i][0], new HashSet<>());\\n        \\t}\\n        \\t\\n        \\tif (nextVertex.get(prerequisites[i][0]).add(prerequisites[i][1])) {\\n        \\t\\tpreVertex[prerequisites[i][1]]++;\\n        \\t}\\n        }\\n        \\n        // queue for BFS, which will only hold courses currently upon which no other courses depend\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < preVertex.length; i++) {\\n        \\t// start from courses upon which no other courses depend. These courses should come last in the order list\\n        \\tif (preVertex[i] == 0) {\\n        \\t\\tqueue.offerLast(i);\\n        \\t}\\n        }\\n        \\n        // array for the result, which will be filled up from the end by index\\n        int[] res = new int[numCourses];\\n        int index = res.length - 1;\\n        \\n        while (!queue.isEmpty()) {\\n        \\tint key = queue.pollFirst(); // this is a course that no other courses will depend upon\\n        \\tres[index--] = key;          // so we put it at the end of the order list\\n        \\t\\n        \\t// since we are done with course \"key\", for any other course that course \"key\" is dependent on, we can decrease\\n        \\t// the corrresponding preVertex by one and check if it is qualified to be added to the queue.\\n        \\tif (nextVertex.containsKey(key)) {\\n        \\t\\tfor (int i : nextVertex.get(key)) {\\n        \\t\\t\\tif (--preVertex[i] == 0) {\\n        \\t\\t\\t\\tqueue.offerLast(i);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\t\\n        \\t--numCourses; // we are done with course \"key\", so reduce the remaining number of courses by 1\\n        }\\n        \\n        // if the remaining number of courses is not zero, then we cannot complete all the courses; otherwise return the result\\n        return numCourses == 0 ? res : new int[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3530515,
                "title": "c-solution-topological-sort-kahn-s-algorithm",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(V + E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool kahnAlgo(vector<vector<int>> &adj, int n, vector<int> &indegree, vector<int> &ans)\\n    {\\n        queue<int> q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (indegree[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n\\n        int count = 0;\\n        while (!q.empty())\\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            for (auto a : adj[curr])\\n            {\\n                indegree[a] -= 1;\\n                if (indegree[a] == 0)\\n                    q.push(a);\\n            }\\n            ans.push_back(curr);\\n            count++;\\n        }\\n\\n        // checking for DAG.\\n        if (count != n)\\n            return false;\\n        return true;\\n    }\\n\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = prerequisites.size();\\n        vector<vector<int>> adj(numCourses); \\n        vector<int> indegree(numCourses, 0); \\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            indegree[prerequisites[i][0]] += 1;\\n        }\\n\\n        vector<int> ans;\\n\\n        // if graph is DAG and Kahn\\'s algo is applied then return the ans.\\n        if (kahnAlgo(adj, numCourses, indegree, ans))\\n            return ans;\\n\\n        // otherwise return the empty vector.\\n        return {};\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/9bcb26b6-4375-43e4-93c7-c60a0e0d583b_1684235159.5613005.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool kahnAlgo(vector<vector<int>> &adj, int n, vector<int> &indegree, vector<int> &ans)\\n    {\\n        queue<int> q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (indegree[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n\\n        int count = 0;\\n        while (!q.empty())\\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            for (auto a : adj[curr])\\n            {\\n                indegree[a] -= 1;\\n                if (indegree[a] == 0)\\n                    q.push(a);\\n            }\\n            ans.push_back(curr);\\n            count++;\\n        }\\n\\n        // checking for DAG.\\n        if (count != n)\\n            return false;\\n        return true;\\n    }\\n\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = prerequisites.size();\\n        vector<vector<int>> adj(numCourses); \\n        vector<int> indegree(numCourses, 0); \\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            indegree[prerequisites[i][0]] += 1;\\n        }\\n\\n        vector<int> ans;\\n\\n        // if graph is DAG and Kahn\\'s algo is applied then return the ans.\\n        if (kahnAlgo(adj, numCourses, indegree, ans))\\n            return ans;\\n\\n        // otherwise return the empty vector.\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406618,
                "title": "python-96-95-faster-bfs-dfs-explained",
                "content": "**In this question we have applied topological sorting method**\\n\\n**DFS Solution:**\\n```\\ndef findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        def dfs(sv,visited):\\n            if visited[sv]==-1:# this course had not been added into the res, but visited again; there is a cycle!\\n                return False\\n            if visited[sv]==1:# this course had been successfully added into the res\\n                return True\\n            visited[sv]=-1 # set the current course as currently being visited\\n            for u in adj[sv]:\\n                if not dfs(u,visited):\\n                    return False # if there is a cycle detected at any point, terminate!\\n            res.append(sv) # no cycle found, dfs finished, good to add the course into the res\\n            visited[sv]=1  # this course finished\\n            return True\\n        \\n        adj=[[] for i in range(numCourses)]\\n        res=[]\\n        for u,v in prerequisites:\\n            adj[v].append(u)\\n        visited=[0]*numCourses\\n        for i in range(numCourses):\\n            if not dfs(i,visited):\\n                # if False, there must be a cycle; terminate by returning an empty list\\n                return []\\n        return res[::-1]\\n```\\n\\n**BFS Solution:**\\n```\\ndef findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        adj=[[] for i in range(numCourses)]\\n        for u,v in prerequisites:\\n            adj[v].append(u)\\n        visited=[0]*numCourses\\n        indeg=[0]*numCourses\\n        res=[]\\n        q=deque()\\n        for i in range(numCourses):\\n            for j in adj[i]:\\n                indeg[j]+=1\\n        for i in range(numCourses):\\n            if indeg[i]==0:\\n                q.append(i)\\n        while q:\\n            u=q.popleft()\\n            res.append(u)\\n            for i in adj[u]:\\n                if indeg[i]!=0:\\n                    indeg[i]-=1\\n                if indeg[i]==0:\\n                    q.append(i)\\n        if len(res)!=numCourses:\\n            return []\\n        return res\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\ndef findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        def dfs(sv,visited):\\n            if visited[sv]==-1:# this course had not been added into the res, but visited again; there is a cycle!\\n                return False\\n            if visited[sv]==1:# this course had been successfully added into the res\\n                return True\\n            visited[sv]=-1 # set the current course as currently being visited\\n            for u in adj[sv]:\\n                if not dfs(u,visited):\\n                    return False # if there is a cycle detected at any point, terminate!\\n            res.append(sv) # no cycle found, dfs finished, good to add the course into the res\\n            visited[sv]=1  # this course finished\\n            return True\\n        \\n        adj=[[] for i in range(numCourses)]\\n        res=[]\\n        for u,v in prerequisites:\\n            adj[v].append(u)\\n        visited=[0]*numCourses\\n        for i in range(numCourses):\\n            if not dfs(i,visited):\\n                # if False, there must be a cycle; terminate by returning an empty list\\n                return []\\n        return res[::-1]\\n```\n```\\ndef findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        adj=[[] for i in range(numCourses)]\\n        for u,v in prerequisites:\\n            adj[v].append(u)\\n        visited=[0]*numCourses\\n        indeg=[0]*numCourses\\n        res=[]\\n        q=deque()\\n        for i in range(numCourses):\\n            for j in adj[i]:\\n                indeg[j]+=1\\n        for i in range(numCourses):\\n            if indeg[i]==0:\\n                q.append(i)\\n        while q:\\n            u=q.popleft()\\n            res.append(u)\\n            for i in adj[u]:\\n                if indeg[i]!=0:\\n                    indeg[i]-=1\\n                if indeg[i]==0:\\n                    q.append(i)\\n        if len(res)!=numCourses:\\n            return []\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1398163,
                "title": "c-topological-sort-each-line-clearly-explained",
                "content": "# Feel free to ask your doubts in comment \\n**There are 2 ways of Topological Sort**\\n* DFS \\n* BFS ( Kahn\\'s algorithm ) \\n\\nI have used Kahn\\'s algorithm, each and every line is having comment\\n\\n* **Time Complexity** : O( numCourses + prerequesties.size() ) \\n* **Space Complexity** : O( numCourses )\\n\\n```\\n// Questions directly hints of topological sort\\n// I will be doing topological sort using BFS which is popularly known as Kahn\\'s algorithm\\nclass Solution {\\npublic:\\n    vector<int> topologicalSort( vector<vector<int>>& G, int n ){\\n        vector<int> indegree( n, 0 ); // it keeps the track of number of incoming edges \\n        for( auto v : G ){\\n            for( auto u : v )\\n                indegree[u]++; // filling the indegree array\\n        }\\n        vector<int> ans; // this will contain the ordered courses\\n        queue<int> q; \\n        \\n        // now there will be atleast one node which will have no incoming edge\\n        // if there is no such node, course cant be finished as there is cycle \\n        // we will find the independent nodes and insert in queue\\n        for( int i=0; i<n; i++ )\\n            if( !indegree[i] ) \\n                q.push( i );\\n        \\n        // now the idea is to, pop each node, i.e. we will be doing independent courses one by one \\n        // and offcourse if a course will be done, the dependencies of its children will be decreased by 1\\n        // ans we will keep checking if the dependency of any node gets 0, if it gets 0, we will insert it into queue\\n        \\n        while( !q.empty() ){\\n            int v = q.front(); \\n            q.pop(); // independent course is done \\n            ans.push_back( v ); // pushed the course in answer vector \\n            \\n            // iterate on courses which were dependent on this course \\n            for( auto u : G[v] ){\\n                indegree[ u ]--; // decreasing the dependency\\n                if( !indegree[u] ) // checking if dependency became 0\\n                    q.push( u ); // pushed in queue to complete the course \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& p) {\\n        vector<vector<int>> G(n); // declare a adjacency list graph vector\\n        for( auto v : p ) // iterate over prerequesties to make graph\\n            G[ v[1] ].push_back( v[0] ); // v[1] need to be done before v[0], so edge from v[1]->v[0]\\n        \\n        auto orderedCourse = topologicalSort( G, n ); // ordered the course \\n        \\n        // now I need to check if all the courses are there in the ordered list \\n        // if yes => return \\n        if( orderedCourse.size() == n ) return orderedCourse;\\n        \\n        // if no => Courses can not be finished bcz. there might be cycle \\n        else return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n// Questions directly hints of topological sort\\n// I will be doing topological sort using BFS which is popularly known as Kahn\\'s algorithm\\nclass Solution {\\npublic:\\n    vector<int> topologicalSort( vector<vector<int>>& G, int n ){\\n        vector<int> indegree( n, 0 ); // it keeps the track of number of incoming edges \\n        for( auto v : G ){\\n            for( auto u : v )\\n                indegree[u]++; // filling the indegree array\\n        }\\n        vector<int> ans; // this will contain the ordered courses\\n        queue<int> q; \\n        \\n        // now there will be atleast one node which will have no incoming edge\\n        // if there is no such node, course cant be finished as there is cycle \\n        // we will find the independent nodes and insert in queue\\n        for( int i=0; i<n; i++ )\\n            if( !indegree[i] ) \\n                q.push( i );\\n        \\n        // now the idea is to, pop each node, i.e. we will be doing independent courses one by one \\n        // and offcourse if a course will be done, the dependencies of its children will be decreased by 1\\n        // ans we will keep checking if the dependency of any node gets 0, if it gets 0, we will insert it into queue\\n        \\n        while( !q.empty() ){\\n            int v = q.front(); \\n            q.pop(); // independent course is done \\n            ans.push_back( v ); // pushed the course in answer vector \\n            \\n            // iterate on courses which were dependent on this course \\n            for( auto u : G[v] ){\\n                indegree[ u ]--; // decreasing the dependency\\n                if( !indegree[u] ) // checking if dependency became 0\\n                    q.push( u ); // pushed in queue to complete the course \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& p) {\\n        vector<vector<int>> G(n); // declare a adjacency list graph vector\\n        for( auto v : p ) // iterate over prerequesties to make graph\\n            G[ v[1] ].push_back( v[0] ); // v[1] need to be done before v[0], so edge from v[1]->v[0]\\n        \\n        auto orderedCourse = topologicalSort( G, n ); // ordered the course \\n        \\n        // now I need to check if all the courses are there in the ordered list \\n        // if yes => return \\n        if( orderedCourse.size() == n ) return orderedCourse;\\n        \\n        // if no => Courses can not be finished bcz. there might be cycle \\n        else return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447774,
                "title": "java-topological-sort-dfs-3ms",
                "content": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List<List<Integer>> list = new ArrayList<>(numCourses);\\n        for(int i = 0; i < numCourses; i++) list.add(new ArrayList<Integer>());\\n        for(int[] p: prerequisites) list.get(p[0]).add(p[1]);\\n        \\n        List<Integer> arr = new ArrayList<>();\\n        // 0: not visited | 1: visited | 2: visiting\\n        int[] visited = new int[numCourses];\\n        for(int i = 0; i < numCourses; i++) {\\n            if(dfs(list, visited, i, arr)) return new int[0];\\n        }\\n        \\n        int[] res = new int[arr.size()];\\n        for(int i = 0; !arr.isEmpty(); i++) res[i] = arr.remove(0);\\n        return res;\\n    }\\n    \\n    private boolean dfs(List<List<Integer>> list, int[] visited, int cur, List<Integer> arr) {\\n        if(visited[cur] == 2) return true;\\n        if(visited[cur] == 1) return false;\\n        visited[cur] = 2;\\n        for(int next: list.get(cur)) {\\n            if(dfs(list, visited, next, arr)) return true;\\n        }\\n        visited[cur] = 1;\\n        arr.add(cur);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List<List<Integer>> list = new ArrayList<>(numCourses);\\n        for(int i = 0; i < numCourses; i++) list.add(new ArrayList<Integer>());\\n        for(int[] p: prerequisites) list.get(p[0]).add(p[1]);\\n        \\n        List<Integer> arr = new ArrayList<>();\\n        // 0: not visited | 1: visited | 2: visiting\\n        int[] visited = new int[numCourses];\\n        for(int i = 0; i < numCourses; i++) {\\n            if(dfs(list, visited, i, arr)) return new int[0];\\n        }\\n        \\n        int[] res = new int[arr.size()];\\n        for(int i = 0; !arr.isEmpty(); i++) res[i] = arr.remove(0);\\n        return res;\\n    }\\n    \\n    private boolean dfs(List<List<Integer>> list, int[] visited, int cur, List<Integer> arr) {\\n        if(visited[cur] == 2) return true;\\n        if(visited[cur] == 1) return false;\\n        visited[cur] = 2;\\n        for(int next: list.get(cur)) {\\n            if(dfs(list, visited, next, arr)) return true;\\n        }\\n        visited[cur] = 1;\\n        arr.add(cur);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203087,
                "title": "python-solution",
                "content": "We first build a directed graph `G` from `prerequisites`. The nodes are `0` to `n-1`, and there is an edge from `i` to `j` if `i` is the prerequisite of `j`. Then to get a correct order of the courses, we just need to topologically sort the graph, so that if there is an edge from `i` to `j` in `G`, `i` comes before `j` in the ordering.\\n\\nWe start by labelling each node `0`, meaning that they have not been dfs visited. We initialize a queue `res`. We iterate `i` in `range(numCourses)`, and if `i` has not been dfs visited, we dfs visit `i`. If any of such dfs visits return `False`, we return the empty list because the graph is not acyclic and cannot be topologically sorted; Else we return `list(res)`. For the dfs visit procedure, we first label `i` to be `1`, meaning that we are currently dfs visiting the descendants of `i` in the dfs tree. Then for each neighbor `j` of `i`, If `j` has label `1`, then `j` is a predecessor of `i` in the dfs visit, and ` i -> j` is a back edge, so the graph contains a cycle, we return `False`; Else if `j` has label `0`, it has not been visited, and we need to do `dfs(j)`. If `dfs(j)` returns `False`, it means that the dfs subgraph starting with `j` contains a cycle, and we need to return `False`. Finally, if no `dfs(j)` returns `False`, it means that the dfs subgraph starting with `i` is acyclic, we label `i` to be `2`, meaning that we finished dfs searches all the descendants of `i`, and append `i` to the head of the queue `res`, and we return `True`.\\n\\nThe time complexity is O(n+m), and the space complexity is O(n+m), where `n = numCourses`, and `m = len(prerequisites)`.\\n```\\nclass Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        \"\"\"\\n        :type numCourses: int\\n        :type prerequisites: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        def dfs(i):\\n            color[i] = 1\\n            if i in graph:\\n                for j in graph[i]:\\n                    if color[j] == 1:\\n                        return False\\n                    elif color[j] == 0:\\n                        if not dfs(j):\\n                            return False\\n            res.appendleft(i)\\n            color[i] = 2\\n            return True\\n                            \\n        graph = {}\\n        for pair in prerequisites:\\n            if pair[1] in graph:\\n                graph[pair[1]].add(pair[0])\\n            else:\\n                graph[pair[1]] = set([pair[0]])\\n        color = [0]*numCourses\\n        res = collections.deque([])\\n        for i in range(numCourses):\\n            if color[i] == 0:\\n                if not dfs(i):\\n                    return []\\n        return list(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findOrder(self, numCourses, prerequisites):\\n        \"\"\"\\n        :type numCourses: int\\n        :type prerequisites: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        def dfs(i):\\n            color[i] = 1\\n            if i in graph:\\n                for j in graph[i]:\\n                    if color[j] == 1:\\n                        return False\\n                    elif color[j] == 0:\\n                        if not dfs(j):\\n                            return False\\n            res.appendleft(i)\\n            color[i] = 2\\n            return True\\n                            \\n        graph = {}\\n        for pair in prerequisites:\\n            if pair[1] in graph:\\n                graph[pair[1]].add(pair[0])\\n            else:\\n                graph[pair[1]] = set([pair[0]])\\n        color = [0]*numCourses\\n        res = collections.deque([])\\n        for i in range(numCourses):\\n            if color[i] == 0:\\n                if not dfs(i):\\n                    return []\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59475,
                "title": "a-simple-java-solution-with-queue",
                "content": "\\tpublic static int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\t\\tint[] result = new int[numCourses];\\n\\t\\tint[] preCnt = new int[numCourses];\\n\\t\\tList<Integer>[] nextSet = new List[numCourses];\\n\\t\\tfor(int i=0; i<numCourses; i++)\\n\\t\\t\\tnextSet[i] = new ArrayList<>();\\n\\n\\t\\tfor(int[] p : prerequisites) {\\n\\t\\t\\tpreCnt[p[0]]++;\\n\\t\\t\\tnextSet[p[1]].add(p[0]);\\n\\t\\t}\\n\\n\\t\\tQueue<Integer> sourceNode = new LinkedList<Integer>();\\n\\t\\tfor(int i=0; i<numCourses; i++)\\n\\t\\t\\tif(preCnt[i] == 0)\\n\\t\\t\\t\\tsourceNode.add(i);\\n\\t\\t\\n\\t\\tfor(int i=0; i<numCourses; i++) {\\n\\t\\t\\tif(sourceNode.isEmpty())\\n\\t\\t\\t\\treturn new int[0];\\n\\t\\t\\tint n = sourceNode.poll();\\n\\t\\t\\tresult[i] = n;\\n\\t\\t\\tfor(int next : nextSet[n]) {\\n\\t\\t\\t\\tpreCnt[next]--;\\n\\t\\t\\t\\tif(preCnt[next] == 0)\\n\\t\\t\\t\\t\\tsourceNode.add(next);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\nHere we keep adding those nodes has no incoming vertex source node. And once it's added, it will be removed from the graph and update the preCnt of the destination nodes. I use preCnt[i] to keep track the number of incomming vertex and use queue sourceNode to keep track the remain source node.",
                "solutionTags": [],
                "code": "\\tpublic static int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\t\\tint[] result = new int[numCourses];\\n\\t\\tint[] preCnt = new int[numCourses];\\n\\t\\tList<Integer>[] nextSet = new List[numCourses];\\n\\t\\tfor(int i=0; i<numCourses; i++)\\n\\t\\t\\tnextSet[i] = new ArrayList<>();\\n\\n\\t\\tfor(int[] p : prerequisites) {\\n\\t\\t\\tpreCnt[p[0]]++;\\n\\t\\t\\tnextSet[p[1]].add(p[0]);\\n\\t\\t}\\n\\n\\t\\tQueue<Integer> sourceNode = new LinkedList<Integer>();\\n\\t\\tfor(int i=0; i<numCourses; i++)\\n\\t\\t\\tif(preCnt[i] == 0)\\n\\t\\t\\t\\tsourceNode.add(i);\\n\\t\\t\\n\\t\\tfor(int i=0; i<numCourses; i++) {\\n\\t\\t\\tif(sourceNode.isEmpty())\\n\\t\\t\\t\\treturn new int[0];\\n\\t\\t\\tint n = sourceNode.poll();\\n\\t\\t\\tresult[i] = n;\\n\\t\\t\\tfor(int next : nextSet[n]) {\\n\\t\\t\\t\\tpreCnt[next]--;\\n\\t\\t\\t\\tif(preCnt[next] == 0)\\n\\t\\t\\t\\t\\tsourceNode.add(next);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\nHere we keep adding those nodes has no incoming vertex source node. And once it's added, it will be removed from the graph and update the preCnt of the destination nodes. I use preCnt[i] to keep track the number of incomming vertex and use queue sourceNode to keep track the remain source node.",
                "codeTag": "Unknown"
            },
            {
                "id": 3300472,
                "title": "best-dfs-bfs-solution",
                "content": "# Approach 1\\nDFS\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool dfs(int node, vector<int> adj[], vector<int>& vis, vector <int>& tasks) {\\n        vis[node] = 2;\\n        for (auto it: adj[node]) {\\n            if (vis[it] == 0) {\\n                if (dfs(it, adj, vis, tasks) == true)\\n                    return true;\\n            } else if (vis[it] == 2) {\\n                return true;\\n            }\\n        }\\n        tasks.push_back(node);\\n        vis[node] = 1;\\n        return false;  \\n    }\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = prerequisites.size();\\n        vector <int> vis(numCourses, 0);\\n        vector <int> adj[numCourses];\\n        for (int i = 0; i < n; i++) \\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        vector <int> tasks;    \\n        for (int i = 0; i < numCourses; i++) {\\n            if (vis[i] == 0) {\\n                if (dfs(i, adj, vis, tasks) == true)\\n                    return {};\\n            }\\n        }\\n        reverse(tasks.begin(), tasks.end());\\n        return tasks;\\n    }\\n};\\n```\\n\\n# Approach 2\\nBFS\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = prerequisites.size();\\n        vector <int> indegree(numCourses, 0);\\n        vector <int> adj[numCourses];\\n        for (int i = 0; i < n; i++) \\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        for (int i = 0; i < numCourses; i++) \\n            for (auto it: adj[i]) \\n                indegree[it]++;\\n        queue <int> q;        \\n        for (int i = 0; i < numCourses; i++) \\n            if (indegree[i] == 0)\\n                q.push(i);\\n        vector <int> tasks;\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            tasks.push_back(node);\\n            for (auto it: adj[node]) {\\n                indegree[it]--;\\n                if (indegree[it] == 0)\\n                    q.push(it);\\n            }\\n        }\\n        if (tasks.size() == numCourses)\\n            return tasks;\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(int node, vector<int> adj[], vector<int>& vis, vector <int>& tasks) {\\n        vis[node] = 2;\\n        for (auto it: adj[node]) {\\n            if (vis[it] == 0) {\\n                if (dfs(it, adj, vis, tasks) == true)\\n                    return true;\\n            } else if (vis[it] == 2) {\\n                return true;\\n            }\\n        }\\n        tasks.push_back(node);\\n        vis[node] = 1;\\n        return false;  \\n    }\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = prerequisites.size();\\n        vector <int> vis(numCourses, 0);\\n        vector <int> adj[numCourses];\\n        for (int i = 0; i < n; i++) \\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        vector <int> tasks;    \\n        for (int i = 0; i < numCourses; i++) {\\n            if (vis[i] == 0) {\\n                if (dfs(i, adj, vis, tasks) == true)\\n                    return {};\\n            }\\n        }\\n        reverse(tasks.begin(), tasks.end());\\n        return tasks;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = prerequisites.size();\\n        vector <int> indegree(numCourses, 0);\\n        vector <int> adj[numCourses];\\n        for (int i = 0; i < n; i++) \\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        for (int i = 0; i < numCourses; i++) \\n            for (auto it: adj[i]) \\n                indegree[it]++;\\n        queue <int> q;        \\n        for (int i = 0; i < numCourses; i++) \\n            if (indegree[i] == 0)\\n                q.push(i);\\n        vector <int> tasks;\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            tasks.push_back(node);\\n            for (auto it: adj[node]) {\\n                indegree[it]--;\\n                if (indegree[it] == 0)\\n                    q.push(it);\\n            }\\n        }\\n        if (tasks.size() == numCourses)\\n            return tasks;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042868,
                "title": "c-dfs-cycle-check-o-v-e-time-easy-to-understand",
                "content": "We can use DFS to detect cycle by transforming the vector of vector to an array of vectors (for our adjacency list). If we don\\'t detect a cycle, we can finish all the courses. While doing the DFS traversal, add the answer after checking for cycle in the adjacent nodes.\\n\\nTime complexity: O(V + E)\\nSpace complexity: O(V + E)\\n\\n```\\nclass Solution {\\nprivate:\\n    bool checkCycle(int start, vector<int> adjList[], vector<bool> &visited, vector<bool> &dfsCurrentVisit, vector<int> &ans) {\\n        // we visit the start vertex\\n        visited[start] = dfsCurrentVisit[start] = true;\\n        \\n        // for all nodes in the adjacency list of start vertex\\n        for(auto it : adjList[start]) {\\n            // if its not visited and we found a cycle\\n            if(!visited[it] && checkCycle(it, adjList, visited, dfsCurrentVisit, ans))\\n                return true;\\n            // if its visited in the current dfs call\\n            else if(dfsCurrentVisit[it])\\n                return true;\\n        }\\n        // adding start vertex to answer\\n        ans.push_back(start);\\n        // we will return from the current dfs call hence marking it as unvisited\\n        dfsCurrentVisit[start] = false;\\n        return false;\\n    }\\n    \\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites, vector<int> &ans) {\\n        // to label all vertices as visited or not\\n        vector<bool> visited(numCourses, false);\\n        // to label all vertices in the current dfs call as visited or not\\n        vector<bool> dfsCurrentVisit(numCourses, false);\\n        // array of vectors for adjacency list\\n        vector<int> adjList[numCourses];\\n        \\n        // constructing our adjacency list\\n        for(auto it : prerequisites) {\\n            adjList[it[0]].push_back(it[1]);\\n        }\\n        // checking all components for cycle\\n        for(int i = 0; i < numCourses; ++i) {\\n            // if we found a cycle we can\\'t finish all courses\\n            if(!visited[i] && checkCycle(i, adjList, visited, dfsCurrentVisit, ans))\\n                return false;\\n        }\\n        // no cycle so we have an answer\\n        return true;\\n    }\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> ans;\\n        if(numCourses == 1) return {0};\\n        if(canFinish(numCourses, prerequisites, ans))\\n            return ans;\\n        return {};\\n    }\\n};\\n```\\n\\nAnother solution that uses stack and maybe more intuitive according to the problem statement\\n\\n```\\nclass Solution {\\nprivate:\\n    bool isCycleDFS(int start, vector<int> adjList[], vector<bool> &visited, \\n                    vector<bool> &dfsVisit, stack<int> &courseDFS) {\\n        visited[start] = dfsVisit[start] = true;\\n        for(int adjNode : adjList[start]) {\\n            if(!visited[adjNode] and isCycleDFS(adjNode, adjList, visited, dfsVisit, courseDFS))\\n                return true;\\n            else if(dfsVisit[adjNode])\\n                return true;\\n        }\\n        dfsVisit[start] = false;\\n        courseDFS.push(start);\\n        return false;\\n    }\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        // lets first create our graph using adjacency list representation\\n        vector<int> adjList[numCourses];\\n        for(auto prereq : prerequisites)\\n            adjList[prereq[1]].push_back(prereq[0]);\\n        \\n        // now we will use DFS to iterate over our graph and check if we see a cycle\\n        // if we don\\'t see a cycle we will return our answer\\n        vector<int> courseOrder;\\n        stack<int> courseDFS;\\n        vector<bool> visited(numCourses), dfsVisit(numCourses);\\n        \\n        for(int i = 0; i < numCourses; ++i) {\\n            if(!visited[i] and isCycleDFS(i, adjList, visited, dfsVisit, courseDFS))\\n                return {};\\n        }\\n        // now add the courses done from the stack into our answer\\n        while(!courseDFS.empty()) {\\n            courseOrder.push_back(courseDFS.top());\\n            courseDFS.pop();\\n        }\\n        return courseOrder;\\n    }\\n};\\n```\\n\\nThanks for reading. An upvote would be appreciated. ^_^",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool checkCycle(int start, vector<int> adjList[], vector<bool> &visited, vector<bool> &dfsCurrentVisit, vector<int> &ans) {\\n        // we visit the start vertex\\n        visited[start] = dfsCurrentVisit[start] = true;\\n        \\n        // for all nodes in the adjacency list of start vertex\\n        for(auto it : adjList[start]) {\\n            // if its not visited and we found a cycle\\n            if(!visited[it] && checkCycle(it, adjList, visited, dfsCurrentVisit, ans))\\n                return true;\\n            // if its visited in the current dfs call\\n            else if(dfsCurrentVisit[it])\\n                return true;\\n        }\\n        // adding start vertex to answer\\n        ans.push_back(start);\\n        // we will return from the current dfs call hence marking it as unvisited\\n        dfsCurrentVisit[start] = false;\\n        return false;\\n    }\\n    \\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites, vector<int> &ans) {\\n        // to label all vertices as visited or not\\n        vector<bool> visited(numCourses, false);\\n        // to label all vertices in the current dfs call as visited or not\\n        vector<bool> dfsCurrentVisit(numCourses, false);\\n        // array of vectors for adjacency list\\n        vector<int> adjList[numCourses];\\n        \\n        // constructing our adjacency list\\n        for(auto it : prerequisites) {\\n            adjList[it[0]].push_back(it[1]);\\n        }\\n        // checking all components for cycle\\n        for(int i = 0; i < numCourses; ++i) {\\n            // if we found a cycle we can\\'t finish all courses\\n            if(!visited[i] && checkCycle(i, adjList, visited, dfsCurrentVisit, ans))\\n                return false;\\n        }\\n        // no cycle so we have an answer\\n        return true;\\n    }\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> ans;\\n        if(numCourses == 1) return {0};\\n        if(canFinish(numCourses, prerequisites, ans))\\n            return ans;\\n        return {};\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    bool isCycleDFS(int start, vector<int> adjList[], vector<bool> &visited, \\n                    vector<bool> &dfsVisit, stack<int> &courseDFS) {\\n        visited[start] = dfsVisit[start] = true;\\n        for(int adjNode : adjList[start]) {\\n            if(!visited[adjNode] and isCycleDFS(adjNode, adjList, visited, dfsVisit, courseDFS))\\n                return true;\\n            else if(dfsVisit[adjNode])\\n                return true;\\n        }\\n        dfsVisit[start] = false;\\n        courseDFS.push(start);\\n        return false;\\n    }\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        // lets first create our graph using adjacency list representation\\n        vector<int> adjList[numCourses];\\n        for(auto prereq : prerequisites)\\n            adjList[prereq[1]].push_back(prereq[0]);\\n        \\n        // now we will use DFS to iterate over our graph and check if we see a cycle\\n        // if we don\\'t see a cycle we will return our answer\\n        vector<int> courseOrder;\\n        stack<int> courseDFS;\\n        vector<bool> visited(numCourses), dfsVisit(numCourses);\\n        \\n        for(int i = 0; i < numCourses; ++i) {\\n            if(!visited[i] and isCycleDFS(i, adjList, visited, dfsVisit, courseDFS))\\n                return {};\\n        }\\n        // now add the courses done from the stack into our answer\\n        while(!courseDFS.empty()) {\\n            courseOrder.push_back(courseDFS.top());\\n            courseDFS.pop();\\n        }\\n        return courseOrder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416975,
                "title": "python-clean-and-easy-to-understand-dfs-solution",
                "content": "\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        graph, self.stack, self.visited = defaultdict(list), [], {}\\n        for f,t in prerequisites:\\n            graph[t].append(f)\\n\\n        for i in range(numCourses):\\n            if i not in self.visited:\\n                self.dfs(graph,i)\\n                \\n        return list(reversed(self.stack)) if len(self.stack) == numCourses else []\\n    \\n    def dfs(self,graph,i):\\n\\t# visited[i] will be true for every i that is still in call stack, to catch a cycle if any.\\n\\t\\n        self.visited[i] = True\\n        for nbr in graph[i]:\\n            if nbr not in self.visited:\\n                self.dfs(graph,nbr)\\n\\t\\t\\t\\t# indicating that there is cycle in the graph,\\n\\t\\t\\t\\t# returning here will result in len(stack) being < 0 which will return []\\n\\t\\t\\t\\t# as topological sort is not for cyclic graph\\n            elif nbr in self.visited and self.visited[nbr]:\\n                return\\n\\t\\n\\t#before returning form dfs add i to stack and make visited[i] False, as not in call stack anymore.\\n\\t\\n        self.stack.append(i)\\n        self.visited[i] = False\\n```\\n* Read about **Topological Sort** to better understand this problem",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        graph, self.stack, self.visited = defaultdict(list), [], {}\\n        for f,t in prerequisites:\\n            graph[t].append(f)\\n\\n        for i in range(numCourses):\\n            if i not in self.visited:\\n                self.dfs(graph,i)\\n                \\n        return list(reversed(self.stack)) if len(self.stack) == numCourses else []\\n    \\n    def dfs(self,graph,i):\\n\\t# visited[i] will be true for every i that is still in call stack, to catch a cycle if any.\\n\\t\\n        self.visited[i] = True\\n        for nbr in graph[i]:\\n            if nbr not in self.visited:\\n                self.dfs(graph,nbr)\\n\\t\\t\\t\\t# indicating that there is cycle in the graph,\\n\\t\\t\\t\\t# returning here will result in len(stack) being < 0 which will return []\\n\\t\\t\\t\\t# as topological sort is not for cyclic graph\\n            elif nbr in self.visited and self.visited[nbr]:\\n                return\\n\\t\\n\\t#before returning form dfs add i to stack and make visited[i] False, as not in call stack anymore.\\n\\t\\n        self.stack.append(i)\\n        self.visited[i] = False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026664,
                "title": "clean-javascript-dfs-solution",
                "content": "**Runtime: 84 ms, faster than 99.24% of JavaScript online submissions for Course Schedule II.**\\n\\n```\\nlet visited;\\nlet graph;\\nlet stack;\\n\\nvar findOrder = function(numCourses, prerequisites) {\\n    \\n    graph = new Map();\\n    visited = new Array(numCourses).fill(0);\\n    stack = new Array();\\n    \\n    for(let [v, e] of prerequisites){\\n        if(graph.has(v)){\\n            let values = graph.get(v);\\n            values.push(e);\\n            graph.set(v, values)\\n        } else {\\n            graph.set(v, [e])\\n        }\\n    }\\n    \\n    for(let i = 0; i < numCourses; i++){\\n        if(visited[i] == 0 && DFS(i)) return [];\\n    }\\n    \\n    return stack;\\n}\\n\\n\\nfunction DFS(index){\\n    \\n    visited[index] = 1;\\n    let edges = graph.get(index);\\n    \\n    if(edges){\\n        for(let e of edges){\\n            if(visited[e] == 1) return true;\\n            if(visited[e] == 0 && DFS(e)) return true\\n        }  \\n    }\\n  \\n    visited[index] = 2;\\n    stack.push(index)\\n    return false\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nlet visited;\\nlet graph;\\nlet stack;\\n\\nvar findOrder = function(numCourses, prerequisites) {\\n    \\n    graph = new Map();\\n    visited = new Array(numCourses).fill(0);\\n    stack = new Array();\\n    \\n    for(let [v, e] of prerequisites){\\n        if(graph.has(v)){\\n            let values = graph.get(v);\\n            values.push(e);\\n            graph.set(v, values)\\n        } else {\\n            graph.set(v, [e])\\n        }\\n    }\\n    \\n    for(let i = 0; i < numCourses; i++){\\n        if(visited[i] == 0 && DFS(i)) return [];\\n    }\\n    \\n    return stack;\\n}\\n\\n\\nfunction DFS(index){\\n    \\n    visited[index] = 1;\\n    let edges = graph.get(index);\\n    \\n    if(edges){\\n        for(let e of edges){\\n            if(visited[e] == 1) return true;\\n            if(visited[e] == 0 && DFS(e)) return true\\n        }  \\n    }\\n  \\n    visited[index] = 2;\\n    stack.push(index)\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 357095,
                "title": "swift-solution-dfs-straightforward-beats-100",
                "content": "```\\nclass Solution {\\n    func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\\n        var preCourses = [Int:[Int]]()\\n        var order = [Int]()\\n        var isVisited = [Int:Bool]() // store each course visit status\\n        \\n        // store info in dict\\n        for relation in prerequisites {\\n            preCourses[relation[0], default: []].append(relation[1])\\n        }\\n        \\n        for course in 0..<numCourses {\\n            guard dfs(course, preCourses, &order, &isVisited) else { return [] } // when exists circle, there is no chance to show an order\\n        }\\n        return order\\n    }\\n    \\n    func dfs(_ course: Int, _ preCourses: [Int:[Int]], _ order: inout [Int], _ isVisited: inout [Int:Bool]) -> Bool {\\n        // check if fully visited;if checked unfully visited, which means existing circles, we return false and terminate searching\\n        if let fullyVisited = isVisited[course] { return fullyVisited } \\n        \\n        isVisited[course] = false // when start to visit\\n        \\n        for preCourse in preCourses[course] ?? [] {\\n            guard dfs(preCourse, preCourses, &order, &isVisited) else { return false }\\n        }\\n        \\n        isVisited[course] = true // when fully visited\\n        order.append(course)\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\\n        var preCourses = [Int:[Int]]()\\n        var order = [Int]()\\n        var isVisited = [Int:Bool]() // store each course visit status\\n        \\n        // store info in dict\\n        for relation in prerequisites {\\n            preCourses[relation[0], default: []].append(relation[1])\\n        }\\n        \\n        for course in 0..<numCourses {\\n            guard dfs(course, preCourses, &order, &isVisited) else { return [] } // when exists circle, there is no chance to show an order\\n        }\\n        return order\\n    }\\n    \\n    func dfs(_ course: Int, _ preCourses: [Int:[Int]], _ order: inout [Int], _ isVisited: inout [Int:Bool]) -> Bool {\\n        // check if fully visited;if checked unfully visited, which means existing circles, we return false and terminate searching\\n        if let fullyVisited = isVisited[course] { return fullyVisited } \\n        \\n        isVisited[course] = false // when start to visit\\n        \\n        for preCourse in preCourses[course] ?? [] {\\n            guard dfs(preCourse, preCourses, &order, &isVisited) else { return false }\\n        }\\n        \\n        isVisited[course] = true // when fully visited\\n        order.append(course)\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458796,
                "title": "dfs-order-of-courses-in-the-graph-java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code declares a public class called Solution that implements a method called findOrder with two parameters: an integer numCourses and a 2D integer array prerequisites.\\n\\n- The code declares a list called ans as a public class variable. This list will store the order of courses to be taken.\\n\\n- The code declares a boolean flag called flag as a public class variable and initializes it to true. However, the flag is not used anywhere in the code.\\n\\n- The code creates a hash set called s to keep track of visited courses. This hash set will be used to prevent revisiting courses that have already been processed.\\n\\n- The code creates a hash map called hs to store the prerequisites for each course. The prerequisites are given in the prerequisites array as a list of pairs (c, prereqCourse), where c is the course and prereqCourse is its prerequisite. If a course has no prerequisites, it will not be added to this hash map.\\n\\n- The code loops through all the courses from 0 to numCourses - 1. For each course, it checks if it has been visited before by checking if it is in the hash set s. If the course has not been visited, the code calls the dfs method to perform depth-first search traversal.\\n\\n- The dfs method takes four parameters: a hash set s to keep track of visited courses, an integer i representing the current course being processed, a hash map adj representing the adjacency list of the graph (i.e., the list of courses and their prerequisites), and a hash set curr to keep track of the current path being traversed.\\n\\n- The dfs method first checks if the current course has been visited before by checking if it is in the hash set s. If it has been visited, it returns true. This check ensures that the algorithm does not revisit courses that have already been processed.\\n\\n- If the course does not have any prerequisites (i.e., it is not in the hash map adj), the dfs method adds it to the answer list ans, marks it as visited in the hash set s, and returns true. This check ensures that courses without prerequisites are processed first.\\n\\n- If the course has prerequisites, the dfs method adds the course to the hash set curr to keep track of the current path being traversed.\\n\\n- The dfs method loops through all the prerequisites of the current course and checks if any of them have already been visited (i.e., are in the hash set curr). If any of the prerequisites have already been visited, it returns false, indicating an invalid order of courses. This check ensures that the algorithm does not form a cycle in the graph.\\n\\n- If none of the prerequisites have been visited, the dfs method calls itself recursively with each prerequisite as input. If any of these recursive calls return false, the method also returns false.\\n\\n- If all the prerequisites have been visited, the dfs method removes the current course from the curr hash set, adds it to the answer list ans, marks it as visited in the hash set s, and returns true.\\n\\n- After all the courses have been visited, the findOrder method creates an integer array result of size numCourses and copies the order of courses from the ans list to the result array.\\n\\n- Finally, the findOrder method returns the result array as an \\'int[]\\' array by coverting ArrayList into int[].\\n\\n# Complexity\\n- Time complexity:\\n ```\\nThe overall time complexity of the code is O(N^2).\\n```\\n- Space complexity:\\n ```\\nThe overall Space complexity of the code is O(N^2).\\n```\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> ans = new ArrayList<>();\\n    boolean flag = true;\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        HashSet<Integer> s = new HashSet<>();\\n        HashMap<Integer, List<Integer>> hs = new HashMap<>();\\n        for (int[] pre : prerequisites) {\\n            int c = pre[0];\\n            int prereqCourse = pre[1];\\n            hs.putIfAbsent(c, new ArrayList<>());\\n            hs.get(c).add(prereqCourse);\\n        }\\n        for (int i = 0; i < numCourses; i++) {\\n            if (!s.contains(i)) {\\n                if (!dfs(s, i, hs, new HashSet<>())) {\\n                    return new int[]{};\\n                }\\n            }\\n        }\\n        int[] result = new int[numCourses];\\n        for (int i = 0; i < numCourses; i++) {\\n            result[i] = ans.get(i);\\n        }\\n        return result;\\n    }\\n    \\n    public boolean dfs(HashSet<Integer> s, int i, HashMap<Integer, List<Integer>> adj, HashSet<Integer> curr) {\\n        if (s.contains(i)) {\\n            return true;\\n        }\\n        if (!adj.containsKey(i)) {\\n            ans.add(i);\\n            s.add(i);\\n            return true;\\n        }\\n        curr.add(i);\\n        for (int pre : adj.get(i)) {\\n            if (curr.contains(pre) || !dfs(s, pre, adj, curr)) {\\n                return false;\\n            }\\n        }\\n        curr.remove(i);\\n        ans.add(i);\\n        s.add(i);\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nThe overall time complexity of the code is O(N^2).\\n```\n```\\nThe overall Space complexity of the code is O(N^2).\\n```\n```\\nclass Solution {\\n    public List<Integer> ans = new ArrayList<>();\\n    boolean flag = true;\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        HashSet<Integer> s = new HashSet<>();\\n        HashMap<Integer, List<Integer>> hs = new HashMap<>();\\n        for (int[] pre : prerequisites) {\\n            int c = pre[0];\\n            int prereqCourse = pre[1];\\n            hs.putIfAbsent(c, new ArrayList<>());\\n            hs.get(c).add(prereqCourse);\\n        }\\n        for (int i = 0; i < numCourses; i++) {\\n            if (!s.contains(i)) {\\n                if (!dfs(s, i, hs, new HashSet<>())) {\\n                    return new int[]{};\\n                }\\n            }\\n        }\\n        int[] result = new int[numCourses];\\n        for (int i = 0; i < numCourses; i++) {\\n            result[i] = ans.get(i);\\n        }\\n        return result;\\n    }\\n    \\n    public boolean dfs(HashSet<Integer> s, int i, HashMap<Integer, List<Integer>> adj, HashSet<Integer> curr) {\\n        if (s.contains(i)) {\\n            return true;\\n        }\\n        if (!adj.containsKey(i)) {\\n            ans.add(i);\\n            s.add(i);\\n            return true;\\n        }\\n        curr.add(i);\\n        for (int pre : adj.get(i)) {\\n            if (curr.contains(pre) || !dfs(s, pre, adj, curr)) {\\n                return false;\\n            }\\n        }\\n        curr.remove(i);\\n        ans.add(i);\\n        s.add(i);\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392818,
                "title": "topological-sorting-breadth-first-search-c",
                "content": "\\n# Approach :\\nThe given code implements a topological sorting algorithm to find the order in which courses can be taken, given a list of prerequisites in the form of directed edges.\\n\\nThe main approach used in the code is as follows:\\n\\n1. Constructing the Graph: The code first constructs an adjacency list adj to represent the directed graph of courses and their prerequisites. The prerequisites are given in the form of a vector of vectors prereq, where each inner vector contains two elements: the prerequisite course and the course that depends on it. The adjacency list is constructed by iterating over the prereq vector and adding directed edges from prerequisite courses to the dependent courses in the adj list.\\n\\n1. Calculating Indegrees: Next, the code calculates the indegree (number of incoming edges) for each vertex in the adj list. This is done using a separate vector indegree of size V (where V is the number of courses) initialized to 0. The code iterates over the adj list and increments the indegree of each vertex (course) whenever it appears as a dependent course (i.e., as the destination of a directed edge) in the adj list.\\n\\n1. Performing BFS: The code then uses a queue-based Breadth-First Search (BFS) approach to perform topological sorting. It starts by adding all the vertices (courses) with an indegree of 0 to the queue, indicating that they have no dependencies and can be taken first. It then iteratively dequeues a vertex from the queue, adds it to the topo list (which stores the topological order), and reduces the indegree of its adjacent vertices (courses) by 1. If the indegree of an adjacent vertex becomes 0 after decrementing, it is also added to the queue. This process continues until the queue is empty.\\n\\n1. Checking for Valid Topological Order: After the BFS, if the size of the topo list is equal to the total number of courses (V), it means a valid topological order has been found, and the topo list contains the correct order in which the courses can be taken. In this case, the topo list is returned as the result. Otherwise, an empty vector is returned, indicating that no valid topological order is possible due to the presence of cycles in the graph.\\n\\nOverall, the code effectively uses the BFS-based topological sorting approach to find the order in which courses can be taken, given their prerequisites, and handles cases where no valid topological order is possible.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n# Time complexity :\\nThe time complexity of the given code is dominated by the BFS-based topological sorting algorithm, which has a time complexity of $$O(V + E)$$, where V is the number of vertices (courses) and E is the number of edges (prerequisites). This is because in the worst case, we may need to visit all the vertices and edges in the graph once during the BFS traversal.\\n\\nIn addition to the BFS, the code also performs some additional operations such as constructing the adjacency list, calculating indegrees, and appending vertices to the topo list. These operations take $$O(V + E)$$ time in total because the adjacency list needs to be constructed by iterating over the prereq vector, and the indegrees need to be calculated by iterating over the adjacency list.\\n\\nTherefore, the overall time complexity of the code is $$O(V + E)$$, where V is the number of courses and E is the number of prerequisites.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space complexity :\\nThe space complexity of the given code is primarily determined by the space used to store the adjacency list adj, the indegree vector, and the topo list, as well as the space used by the queue q for the BFS.\\n\\nThe adjacency list adj uses $$O(V + E)$$ space as it stores the edges between courses. The indegree vector also uses $$O(V)$$ space as it stores the indegrees of all the vertices. The topo list also uses $$O(V)$$ space as it stores the topological order of the courses.\\n\\nThe queue q used for the BFS can have a maximum of V vertices at any time, so it uses $$O(V)$$ space.\\n\\nTherefore, the overall space complexity of the code is $$O(V + E)$$, where V is the number of courses and E is the number of prerequisites.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prereq) {\\n        int V = numCourses;\\n        vector<int>adj[V]; // adjacency list to represent the directed graph\\n        // constructing the adjacency list from the given prerequisites\\n        for(auto it:prereq){\\n            vector<int> x = it;\\n            adj[x[1]].push_back(x[0]); // adding directed edge from prerequisite to the course\\n        }\\n        vector<int>topo; // to store topological order\\n        vector<int>indegree(V,0); // to store indegrees of all the vertices\\n        // calculating the indegrees of all the vertices\\n        for(int i=0;i<V;i++){\\n            for(auto it:adj[i]){\\n            indegree[it]++;\\n            }\\n        }\\n        queue<int>q; // to perform BFS\\n        // adding vertices with indegree 0 to the queue\\n        for(int i=0;i<V;i++){\\n            if(!indegree[i]){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            topo.push_back(node); // adding the node to topological order\\n            // reducing the indegree of adjacent vertices and adding them to the queue if their indegree becomes 0\\n            for(auto it:adj[node]){\\n                indegree[it]--;\\n                if(!indegree[it]){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(topo.size()==V) // if a valid topological order is found, return it\\n            return topo;\\n        return {}; // otherwise, return an empty vector\\n    }\\n};\\n\\n```\\n\\n---\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION :)**\\n\\n![559f9a3b-35d8-4a33-997c-25bdc3011c6d_1680759592.848775.gif](https://assets.leetcode.com/users/images/27f775da-8040-45a3-a517-660cb70023f7_1680937174.0448825.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prereq) {\\n        int V = numCourses;\\n        vector<int>adj[V]; // adjacency list to represent the directed graph\\n        // constructing the adjacency list from the given prerequisites\\n        for(auto it:prereq){\\n            vector<int> x = it;\\n            adj[x[1]].push_back(x[0]); // adding directed edge from prerequisite to the course\\n        }\\n        vector<int>topo; // to store topological order\\n        vector<int>indegree(V,0); // to store indegrees of all the vertices\\n        // calculating the indegrees of all the vertices\\n        for(int i=0;i<V;i++){\\n            for(auto it:adj[i]){\\n            indegree[it]++;\\n            }\\n        }\\n        queue<int>q; // to perform BFS\\n        // adding vertices with indegree 0 to the queue\\n        for(int i=0;i<V;i++){\\n            if(!indegree[i]){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            topo.push_back(node); // adding the node to topological order\\n            // reducing the indegree of adjacent vertices and adding them to the queue if their indegree becomes 0\\n            for(auto it:adj[node]){\\n                indegree[it]--;\\n                if(!indegree[it]){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(topo.size()==V) // if a valid topological order is found, return it\\n            return topo;\\n        return {}; // otherwise, return an empty vector\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643104,
                "title": "java-topological-sort-handwritten-illustrations-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/093d02f9-2cc9-4952-9f90-b8118e236689_1640266790.9655185.png)\\n\\n```\\n//Time complexity: O(V+E), iterating over V verticies and their neighbours in total number of neighbours traversed will be equal to E edges in the graph\\n//Space Complexity:O(V+E), V verticies stored in graph as keys and in total E edges.\\nclass Solution {\\n    \\n    public int[] findOrder(int numCrs, int[][] preq) {\\n        HashMap<Integer, HashSet<Integer>> graph = new HashMap<>();\\n        int degree[] = new int[numCrs]; \\n        makeGraphCalDegree(preq, graph, degree);\\n        int resOrdr[] = new int[numCrs];\\n      \\n        findOrder(resOrdr, graph, degree);\\n//Checking if we found solution i.e. is it possible to finish all courses.\\n        boolean solNotPos = false;\\n        for(int deg : degree){\\n            if(deg != 0){\\n                solNotPos = true;\\n                break;\\n            }\\n        }\\n\\n        return solNotPos ? new int[0] : resOrdr;\\n    }\\n    private void findOrder(int resOrdr[], HashMap<Integer, HashSet<Integer>> graph, int degree[]){\\n        Queue<Integer> que = new LinkedList<>();\\n        int numCrs = degree.length;\\n        for(int crs = 0; crs<numCrs; crs++){\\n            if(degree[crs] == 0){\\n                que.offer(crs);\\n            }\\n        }\\n        int rIndx = 0;\\n        while(!que.isEmpty()){\\n            int src = que.poll();\\n            resOrdr[rIndx++] = src;\\n            if(!graph.containsKey(src)) continue;\\n            for(int neigh : graph.get(src)){\\n                degree[neigh]--;\\n                if(degree[neigh] == 0){\\n                    que.offer(neigh);\\n                }\\n            }\\n        }\\n    }\\n    private void makeGraphCalDegree(int [][]preq, HashMap<Integer, HashSet<Integer>> graph, int degree[]){\\n        for(int pr[] : preq){\\n            int dest = pr[0], src = pr[1];\\n            degree[dest]++;\\n            graph.putIfAbsent(src, new HashSet<>());\\n            graph.get(src).add(dest);\\n        }\\n    }\\n}\\n```\\nAny corrections, suggestions or optimizations to code are welcomed.:)\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)",
                "solutionTags": [],
                "code": "```\\n//Time complexity: O(V+E), iterating over V verticies and their neighbours in total number of neighbours traversed will be equal to E edges in the graph\\n//Space Complexity:O(V+E), V verticies stored in graph as keys and in total E edges.\\nclass Solution {\\n    \\n    public int[] findOrder(int numCrs, int[][] preq) {\\n        HashMap<Integer, HashSet<Integer>> graph = new HashMap<>();\\n        int degree[] = new int[numCrs]; \\n        makeGraphCalDegree(preq, graph, degree);\\n        int resOrdr[] = new int[numCrs];\\n      \\n        findOrder(resOrdr, graph, degree);\\n//Checking if we found solution i.e. is it possible to finish all courses.\\n        boolean solNotPos = false;\\n        for(int deg : degree){\\n            if(deg != 0){\\n                solNotPos = true;\\n                break;\\n            }\\n        }\\n\\n        return solNotPos ? new int[0] : resOrdr;\\n    }\\n    private void findOrder(int resOrdr[], HashMap<Integer, HashSet<Integer>> graph, int degree[]){\\n        Queue<Integer> que = new LinkedList<>();\\n        int numCrs = degree.length;\\n        for(int crs = 0; crs<numCrs; crs++){\\n            if(degree[crs] == 0){\\n                que.offer(crs);\\n            }\\n        }\\n        int rIndx = 0;\\n        while(!que.isEmpty()){\\n            int src = que.poll();\\n            resOrdr[rIndx++] = src;\\n            if(!graph.containsKey(src)) continue;\\n            for(int neigh : graph.get(src)){\\n                degree[neigh]--;\\n                if(degree[neigh] == 0){\\n                    que.offer(neigh);\\n                }\\n            }\\n        }\\n    }\\n    private void makeGraphCalDegree(int [][]preq, HashMap<Integer, HashSet<Integer>> graph, int degree[]){\\n        for(int pr[] : preq){\\n            int dest = pr[0], src = pr[1];\\n            degree[dest]++;\\n            graph.putIfAbsent(src, new HashSet<>());\\n            graph.get(src).add(dest);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642634,
                "title": "kahn-s-algorithm",
                "content": "**Idea?**\\n* For a given Condition *[a,b]*, course *b* must be completed before course *a* right? Can we put a **directed edge from course b to course a** denoting that we will complete the course a only when course b is completed?\\n* Yes, **Create a Graph G**, which will contain **directed edges** from **Bi to Ai** for all prerequisites, denoting that course Bi must be completed before we start course Ai.\\n* Can we have a specific ordering? Now, consider certain nodes of the graph which has **indegree as zero**. These nodes should be **processed first** because, there are no criteria for this node right?\\n* So, for all nodes which have indegree as zero, push them into the queue and each time for the adjacent neighbors of the current node, **decrease the indegree count of the adjacent node**, and when it becomes zero, it signifies that this node can be processed now...so push them into the queue.\\n* For the above steps, it is called **Kahn\\'s Algorithm for Topological Sorting of the Graph**.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(V+E)\\n    // Space Complexity:- O(V)\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[numCourses],in(numCourses);\\n        for(auto& v:prerequisites){\\n            adj[v[1]].push_back(v[0]); // create a directed edge\\n            in[v[0]]++; // indegree is incremented\\n        }\\n        queue<int> q;\\n        vector<int> ans; // stores answer\\n        for(int i=0;i<numCourses;i++){\\n            if(!in[i])\\n                q.push(i); // we can start will all those nodes which doesn\\'t have any prerequisites\\n        }\\n        while(!q.empty()){\\n            int v = q.front();q.pop();\\n            ans.push_back(v);\\n            for(auto&u :adj[v]){\\n                if(--in[u]==0) // when indegree of adjacent node becomes zero, means all prerequistes has been satisfied\\n                    q.push(u);\\n            }\\n        }\\n        if(ans.size()!=numCourses) // if we can\\'t cover all nodes, means there is a cycle in the graph, hence no ordering exists\\n            ans.clear();\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(V+E)\\n    // Space Complexity:- O(V)\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[numCourses],in(numCourses);\\n        for(auto& v:prerequisites){\\n            adj[v[1]].push_back(v[0]); // create a directed edge\\n            in[v[0]]++; // indegree is incremented\\n        }\\n        queue<int> q;\\n        vector<int> ans; // stores answer\\n        for(int i=0;i<numCourses;i++){\\n            if(!in[i])\\n                q.push(i); // we can start will all those nodes which doesn\\'t have any prerequisites\\n        }\\n        while(!q.empty()){\\n            int v = q.front();q.pop();\\n            ans.push_back(v);\\n            for(auto&u :adj[v]){\\n                if(--in[u]==0) // when indegree of adjacent node becomes zero, means all prerequistes has been satisfied\\n                    q.push(u);\\n            }\\n        }\\n        if(ans.size()!=numCourses) // if we can\\'t cover all nodes, means there is a cycle in the graph, hence no ordering exists\\n            ans.clear();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067857,
                "title": "c-topological-sort",
                "content": "In this question, we basically have to check if there are any controversial prerequisites lists. For example, if we have B as a pre-requisite of A, then A can\\'t be a pre-requisite of B. Or say B is the prerequisite of A, C is prerequisite of B and A is prerequisite of C. This example fairly tells you what is the logic of the question. \\n* Like in Course Schedule I, we have to find whether or not there is a cycle. Furthermore we have to return the list in order those courses can be done.\\n* One point to note here is that, the input is very consistent and we don\\'t have to check for any cases like courses present in the prerequistes like being greater than numCourses, and courses always start from 0 - numCourses.\\n\\nOne approach is to first check whether the graph is cyclic or not and then performing DFS. We will traverse the graph twice here and once while making the graph. Other one, the one that I have followed here is to push the elements as we check for a cycle and in case, the graph is a cycle, we clear the array and return. \\n\\n\\nclass Solution {\\npublic:\\n\\n    bool isCyclic(vector<int> graph[], vector<int>& visited, int start,vector<int>& ans){\\n        if(visited[start]==2){ //base condition if we meet the same element while traversing one branch\\n            ans.clear(); \\n            return true;\\n        }\\n        visited[start]=2; //visiting index -2, visited -1, not visited -0\\n        \\n\\t\\tfor(int i=0;i<graph[start].size();i++)\\n            if(visited[graph[start][i]]!=1) \\n                if(isCyclic(graph,visited, graph[start][i],ans)){\\n                    ans.clear();\\n                    return true;\\n                }\\n        visited[start]=true;\\n        ans.push_back(start);\\n        return false;\\n    }\\n\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> graph[numCourses], visited(numCourses,0), ans; \\n        for(int i=0;i<prerequisites.size();i++)\\n            graph[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        \\n        for(int i=0;i<numCourses;i++)\\n            if(!visited[i])\\n                if(isCyclic(graph,visited,i,ans))\\n                    return ans;\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isCyclic(vector<int> graph[], vector<int>& visited, int start,vector<int>& ans){\\n        if(visited[start]==2){ //base condition if we meet the same element while traversing one branch\\n            ans.clear(); \\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 982542,
                "title": "python3-kahn-s-algorithm-beats-90-and-dfs-topological-sort",
                "content": "Kahn\\'s algorithm works by deleting nodes as you go and keeping track of how many incoming edges each vertex has.  When a vertex reaches 0 incoming edges, add it to the queue and continue processing until the queue is empty.\\n\\nStart with the vertices with no incoming edges in a queue and keep a list of vertices and the total number of incoming edges.  While the queue is not empty, pop an element off of it that contains a vertex with no edges, each time decrementing the \"degree\" of each neighboring vertex by 1.  If any of those neighbors reach a degree of 0 (meaning after removal, they have no incoming edges), add it to the queue.\\n\\nIf at the end of the loop, the size of the topological ordered list is not equal to the total number of courses, it means there is a cycle or a course is not listed in the prerequisites list.\\n\\nBoth algorithms take O(V + E) time and O(V + E) space, where V = # of vertices and E = # of edges.  Kahn\\'s performs better in leetcode (>90% time) vs DFS (>50% time) but it\\'s the same big O time complexity.\\n\\n**Kahn\\'s Algorithm**\\n```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \"\"\"Kahn\\'s algorithm\"\"\"\\n        courses = defaultdict(list)\\n        indegree = defaultdict(int) # could also use collections.Counter here\\n        for course, prereq in prerequisites:\\n            courses[prereq].append(course)\\n            indegree[course] += 1\\n\\n        q = deque(i for i in range(numCourses) if i not in indegree)\\n        \\n        order, visited = [], set()\\n        \\n        # queue will store vertices with no incoming edges\\n        while q:\\n            course = q.popleft()\\n            order.append(course)\\n            visited.add(course)\\n            \\n            for next_course in courses[course]:\\n                if next_course in indegree:\\n                    indegree[next_course] -= 1\\n                    if indegree[next_course] == 0 and next_course not in visited:\\n                        q.append(next_course)\\n                        \\n\\t\\t# check if there is a cycle or a course is not listed\\n        return order if len(order) == numCourses else []\\n```\\n\\nThe DFS solution is the traditional [topological sort algorithm](https://en.wikipedia.org/wiki/Topological_sorting) using recursion.  It\\'s important to check for cycles by keeping track of what is currently being visited.  If at any point during the callstack, we are visiting a node that has already been visited, that means there is a cycle and the DAG is invalid for topological sorting.\\n\\n**DFS**\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        courses = defaultdict(list)\\n        visited = [0 for _ in range(numCourses)]\\n        order = []\\n        \\n        def dfs(course: int, visited: List[int], order: List[int]) -> bool:\\n            if visited[course] == -1:\\n                return False\\n            elif visited[course] == 1:\\n                return True\\n            \\n            # visiting\\n            visited[course] = -1\\n            for next_course in courses[course]:\\n                if not dfs(next_course, visited, order):\\n                    return False\\n                \\n            # visited\\n            visited[course] = 1\\n            order.append(course)\\n            \\n            return True\\n        \\n        for course, prereq in prerequisites:\\n            courses[prereq].append(course)\\n            \\n        return order[::-1] if all(dfs(course, visited, order) for course in range(numCourses)) else []\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \"\"\"Kahn\\'s algorithm\"\"\"\\n        courses = defaultdict(list)\\n        indegree = defaultdict(int) # could also use collections.Counter here\\n        for course, prereq in prerequisites:\\n            courses[prereq].append(course)\\n            indegree[course] += 1\\n\\n        q = deque(i for i in range(numCourses) if i not in indegree)\\n        \\n        order, visited = [], set()\\n        \\n        # queue will store vertices with no incoming edges\\n        while q:\\n            course = q.popleft()\\n            order.append(course)\\n            visited.add(course)\\n            \\n            for next_course in courses[course]:\\n                if next_course in indegree:\\n                    indegree[next_course] -= 1\\n                    if indegree[next_course] == 0 and next_course not in visited:\\n                        q.append(next_course)\\n                        \\n\\t\\t# check if there is a cycle or a course is not listed\\n        return order if len(order) == numCourses else []\\n```\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        courses = defaultdict(list)\\n        visited = [0 for _ in range(numCourses)]\\n        order = []\\n        \\n        def dfs(course: int, visited: List[int], order: List[int]) -> bool:\\n            if visited[course] == -1:\\n                return False\\n            elif visited[course] == 1:\\n                return True\\n            \\n            # visiting\\n            visited[course] = -1\\n            for next_course in courses[course]:\\n                if not dfs(next_course, visited, order):\\n                    return False\\n                \\n            # visited\\n            visited[course] = 1\\n            order.append(course)\\n            \\n            return True\\n        \\n        for course, prereq in prerequisites:\\n            courses[prereq].append(course)\\n            \\n        return order[::-1] if all(dfs(course, visited, order) for course in range(numCourses)) else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311215,
                "title": "different-python-solutions-bfs-dfs",
                "content": "Same solutions to solve topological sorting problems:\\n[Problem 207. Course schedule](https://leetcode.com/problems/course-schedule/discuss/311183/Different-Python-solutions-with-thinking-process),\\n[Problem 210. Course schedule II](https://leetcode.com/problems/course-schedule-ii/discuss/311215/Different-Python-solution-with-thinking-process).\\n\\nMethod 2 and 3 are more general. They can be a part of [Kosaraju\\'s algorithm](https://www.coursera.org/learn/algorithms-graphs-data-structures/lecture/rng2S/computing-strong-components-the-algorithm) to compute the strongly connected components.\\n\\nMethod 1: BFS: delete a source node step-by-step, don\\'t need to remove edges in the graph.\\nTime complexity: O(n + m) (98.58%)\\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        indegree = [0] * numCourses\\n        edges = [set() for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].add(u)\\n            indegree[u] += 1\\n        sources = [v for v in range(numCourses) if indegree[v] == 0]\\n        topo_order = []\\n        while sources:\\n            s = sources.pop(0) # can be any sequence to delete\\n            topo_order.append(s)\\n            for v in edges[s]:\\n                indegree[v] -= 1\\n                if indegree[v] == 0:\\n                    sources.append(v)\\n        if len(topo_order) != numCourses:\\n            return []\\n        else:\\n            return topo_order\\n```\\nMethod 2:  recursive DFS using a global variable \\'t\\' to record the finishing times,\\ntime complexity O(n + m) (Beat 94.95%)\\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        def dfs(i):\\n            visited[i] = True\\n            for j in edges[i]:\\n                if not visited[j]:\\n                    dfs(j)\\n            post[i] = t[0]\\n            t[0] += 1\\n            finish_order.append(i) \\n        \\n        edges = [[] for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].append(u)\\n        t = [0]\\n        visited = [False] * numCourses\\n        post = [0] * numCourses\\n        finish_order = []\\n        for i in range(numCourses):\\n            if not visited[i]:\\n                dfs(i)\\n        for u, v in prerequisites:\\n            if post[v] < post[u]:\\n                return []\\n        return finish_order[::-1]\\n```\\nMethod 3: iterative DFS using stack, and a global variable \\'t\\' to recording the finishing times,\\ntime complexity O(n + m) (Beat 94.95%)\\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        edges = [[] for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].append(u)\\n        visited = [False] * numCourses\\n        stack = []\\n        post = [0] * numCourses\\n        finish_order = []\\n        t = 0\\n        for i in range(numCourses):\\n            if not visited[i]:\\n                visited[i] = True\\n                stack.append(i)\\n            while stack:\\n                no_next = True\\n                top = stack[-1]\\n                for j in edges[top]:\\n                    if not visited[j]:\\n                        visited[j] = True\\n                        stack.append(j)\\n                        no_next = False\\n                        break\\n                if no_next:\\n                    post[top] = t\\n                    t += 1\\n                    finish_order.append(top)\\n                    stack.pop()\\n        for u, v in prerequisites:\\n            if post[v] < post[u]:\\n                return []\\n        return finish_order[::-1]\\n```\\nMethod 4: recursive DFS: visited[i] == 0 means not visited before, visited[i] == 1 means visited in the current path, visited[i] == 2 means visited before.\\nTime complexity O(n + m) (Beat 94.95%)\\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        def dfs(i):\\n            visited[i] = 1\\n            for j in edges[i]:\\n                if visited[j] == 1:\\n                    return False\\n                elif visited[j] == 0:\\n                    if not dfs(j):\\n                        return False\\n            finish_order.append(i)\\n            visited[i] = 2\\n            return True\\n        \\n        edges = [[] for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].append(u)\\n        visited = [0 for _ in range(numCourses)]\\n        finish_order = []\\n        for i in range(numCourses):\\n            if visited[i] == 0:\\n                if not dfs(i):\\n                    return []\\n        return finish_order[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def findOrder(self, numCourses, prerequisites):\\n        indegree = [0] * numCourses\\n        edges = [set() for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].add(u)\\n            indegree[u] += 1\\n        sources = [v for v in range(numCourses) if indegree[v] == 0]\\n        topo_order = []\\n        while sources:\\n            s = sources.pop(0) # can be any sequence to delete\\n            topo_order.append(s)\\n            for v in edges[s]:\\n                indegree[v] -= 1\\n                if indegree[v] == 0:\\n                    sources.append(v)\\n        if len(topo_order) != numCourses:\\n            return []\\n        else:\\n            return topo_order\\n```\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        def dfs(i):\\n            visited[i] = True\\n            for j in edges[i]:\\n                if not visited[j]:\\n                    dfs(j)\\n            post[i] = t[0]\\n            t[0] += 1\\n            finish_order.append(i) \\n        \\n        edges = [[] for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].append(u)\\n        t = [0]\\n        visited = [False] * numCourses\\n        post = [0] * numCourses\\n        finish_order = []\\n        for i in range(numCourses):\\n            if not visited[i]:\\n                dfs(i)\\n        for u, v in prerequisites:\\n            if post[v] < post[u]:\\n                return []\\n        return finish_order[::-1]\\n```\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        edges = [[] for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].append(u)\\n        visited = [False] * numCourses\\n        stack = []\\n        post = [0] * numCourses\\n        finish_order = []\\n        t = 0\\n        for i in range(numCourses):\\n            if not visited[i]:\\n                visited[i] = True\\n                stack.append(i)\\n            while stack:\\n                no_next = True\\n                top = stack[-1]\\n                for j in edges[top]:\\n                    if not visited[j]:\\n                        visited[j] = True\\n                        stack.append(j)\\n                        no_next = False\\n                        break\\n                if no_next:\\n                    post[top] = t\\n                    t += 1\\n                    finish_order.append(top)\\n                    stack.pop()\\n        for u, v in prerequisites:\\n            if post[v] < post[u]:\\n                return []\\n        return finish_order[::-1]\\n```\n```\\n    def findOrder(self, numCourses, prerequisites):\\n        def dfs(i):\\n            visited[i] = 1\\n            for j in edges[i]:\\n                if visited[j] == 1:\\n                    return False\\n                elif visited[j] == 0:\\n                    if not dfs(j):\\n                        return False\\n            finish_order.append(i)\\n            visited[i] = 2\\n            return True\\n        \\n        edges = [[] for _ in range(numCourses)]\\n        for u, v in prerequisites:\\n            edges[v].append(u)\\n        visited = [0 for _ in range(numCourses)]\\n        finish_order = []\\n        for i in range(numCourses):\\n            if visited[i] == 0:\\n                if not dfs(i):\\n                    return []\\n        return finish_order[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 59381,
                "title": "simple-ac-c-dfs-toposort-solution",
                "content": "    class Solution {\\n        vector<bool> visited;\\n        vector<int> path; \\n        vector<bool> rec;\\n        vector<list<int>> graph;\\n        \\n    public:\\n    \\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) \\n        {\\n            vector<int> cycle();\\n            \\n            if(prerequisites.empty())\\n            {\\n                for(int i = 0; i < numCourses; ++i)\\n                {\\n                    path.push_back(i);\\n                }\\n                return path;\\n            }\\n            \\n            graph.assign(numCourses, list<int>());\\n            visited.assign(numCourses, false);\\n            rec.assign(numCourses, false);\\n            \\n            for(int i = 0; i < prerequisites.size(); ++i)\\n            {\\n                graph[prerequisites[i].first].push_back(prerequisites[i].second);\\n            }\\n            \\n            for(int i = 0; i < graph.size(); ++i)\\n            {\\n                if(visited[i]) continue;\\n                if(isCycle(i)) return vector<int>();\\n            }\\n            \\n            return path;\\n        }\\n    \\n        bool isCycle(int course)\\n        {\\n            visited[course] = true;\\n            rec[course] = true;\\n            \\n            for(auto it = graph[course].begin(); it!=graph[course].end(); ++it)\\n            {\\n                if(!visited[*it])\\n                {\\n                    if(isCycle(*it)) return true;\\n                }\\n                if(rec[*it]) return true;\\n            }\\n            rec[course] = false;\\n            path.push_back(course);\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        vector<bool> visited;\\n        vector<int> path; \\n        vector<bool> rec;\\n        vector<list<int>> graph;\\n        \\n    public:\\n    \\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) \\n        {\\n            vector<int> cycle();\\n            \\n            if(prerequisites.empty())\\n            {\\n                for(int i = 0; i < numCourses; ++i)\\n                {\\n                    path.push_back(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3125036,
                "title": "topological-sort-kahn-s-algorithm",
                "content": "# Intuition\\nKahn\\'s algorithm is much easier to think about intuitively as will be clear from the following point/fact about topological ordering.\\n\\nThe first node in the topological ordering will be the node that doesn\\'t have any incoming edges. Essentially, any node that has an in-degree of 0 can start the topologically sorted order. If there are multiple such nodes, their relative order doesn\\'t matter and they can appear in any order.\\n\\nOur current algorithm is based on this idea. We first process all the nodes/course with 0 in-degree implying no prerequisite courses required. If we remove all these courses from the graph, along with their outgoing edges, we can find out the courses/nodes that should be processed next. These would again be the nodes with 0 in-degree. We can continuously do this until all the courses have been accounted for.\\n# Solution\\n- Let G(V,E)G(V, E)G(V,E) represent a directed, unweighted graph.\\n- Each course would represent a vertex in the graph.\\n- The edges are modeled after the prerequisite relationship between courses. So, we are **`given, that a pair such as [a,b] in the question means the course b is a prerequisite for the course a. This can be represented as a directed edge b \\u2794 a in the graph.`**\\n- The graph is a cyclic graph because there is a possibility of a cycle in the graph. If the graph would be acyclic, then an ordering of subjects as required in the question would always be possible. Since it\\'s mentioned that such an ordering may not always be possible, that means we have a cyclic graph.\\nLet\\'s look at a sample graph representing a set of courses where such an ordering is possible and one where such an ordering is not possible. \\n![image.png](https://assets.leetcode.com/users/images/96ab2f58-0252-47de-acfb-17b5c1b528b8_1675222209.7890244.png)\\n\\n\\n\\n\\n# Approach\\n\\n---\\n\\n1. Initialize a queue, Q to keep a track of all the nodes in the graph with 0 in-degree.\\n2. Iterate over all the edges in the input and create an adjacency list and also a map of node v/s in-degree.\\n3. Add all the nodes with 0 in-degree to Q.\\nThe following steps are to be done until the Q becomes empty :\\n\\ni.   Pop a node from the Q. Let\\'s call this node, N.\\nii.   For all the neighbors of this node, N, reduce their in-degree by 1.\\niii.  If any of the nodes\\' in-degree reaches 0, add it to the Q.\\nAdd the node N to the list maintaining topologically sorted order.\\nContinue from step i\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/030c5933-fd0e-4121-9356-011df8d6bcca_1675219363.011586.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/a5b8a6de-8e61-460b-a70b-12e4ba33b7b8_1675219380.4713616.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/546ac47a-8bd4-480d-a7e2-5609740df478_1675219403.4589553.png)\\n![image.png](https://assets.leetcode.com/users/images/bfe54eff-0095-4af5-82f4-549d3edd2bc9_1675219432.0764031.png)\\n![image.png](https://assets.leetcode.com/users/images/9bd5ef41-2254-4cc6-95ce-b4ce51e2b1bc_1675219448.1810558.png)\\n![image.png](https://assets.leetcode.com/users/images/162cf5dc-b968-4bd9-8088-fe613f830c40_1675219467.4133434.png)\\n![image.png](https://assets.leetcode.com/users/images/9229c045-a436-4468-b54b-d4915a992235_1675219481.997302.png)\\n![image.png](https://assets.leetcode.com/users/images/3139ab59-1177-4bab-af75-9adf257f09d8_1675219496.9231634.png)\\n![image.png](https://assets.leetcode.com/users/images/9eb1de1a-d56f-402d-a265-8e943783cd84_1675219517.7548423.png)\\n![image.png](https://assets.leetcode.com/users/images/285fe13d-1290-4272-b1c7-ae206731563d_1675219530.1526.png)\\n![image.png](https://assets.leetcode.com/users/images/0d1c575a-31f6-4421-b4d2-a0fef0c4193a_1675219543.0513816.png)\\n![image.png](https://assets.leetcode.com/users/images/b9849b5f-7df1-413c-aa11-4b1279b2974e_1675219562.1890574.png)\\n![image.png](https://assets.leetcode.com/users/images/dde522e8-de72-41eb-814f-3b57366854c7_1675219580.0661752.png)\\n![image.png](https://assets.leetcode.com/users/images/4fd4f7d0-eec6-4161-a81f-ffe7739764fc_1675219590.8891854.png)\\n\\nAn important thing to note here is, using a queue is not a hard requirement for this algorithm. We can make use of a stack. That however, will give us a different ordering than what we might get from the queue because of the difference in access patterns between the two data-structures.\\n\\n\\n# Complexity\\n**Time Complexity:** O(V+E)O(V + E)O(V+E) where VVV represents the number of vertices and EEE represents the number of edges. We pop each node exactly once from the zero in-degree queue and that gives us VVV. Also, for each vertex, we iterate over its adjacency list and in totality, we iterate over all the edges in the graph which gives us EEE. Hence, O(V+E)O(V + E)O(V+E)\\n\\n**Space Complexity:** O(V+E)O(V + E)O(V+E). We use an intermediate queue data structure to keep all the nodes with 0 in-degree. In the worst case, there won\\'t be any prerequisite relationship and the queue will contain all the vertices initially since all of them will have 0 in-degree. That gives us O(V)O(V)O(V). Additionally, we also use the adjacency list to represent our graph initially. The space occupied is defined by the number of edges because for each node as the key, we have all its adjacent nodes in the form of a list as the value. Hence, O(E)O(E)O(E). So, the overall space complexity is O(V+E)O(V + E)O(V+E).\\n\\n# Video link: https://youtu.be/tggiFvaxjrY\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        \\n        int indegree[2005]={0};\\n        vector<int>graph[2006];\\n         for(auto i:pre)\\n         {\\n            int x=i[0],y=i[1];\\n            graph[y].push_back(x); \\n            indegree[x]++;\\n         }\\n\\n         queue<int>q;\\n         vector<int>ans;\\n         for(int i=0;i<n;i++)if(!indegree[i])q.push(i);\\n\\n         while(!q.empty())\\n         {\\n            int t=q.front();q.pop();\\n            ans.push_back(t);\\n            for(auto u:graph[t])\\n             {\\n                 indegree[u]--;\\n                 if(indegree[u]==0)q.push(u);\\n             }\\n         }\\n        \\n         if(ans.size()!=n)ans.clear();\\n         //reverse(ans.begin(),ans.end());\\n         return ans;\\n    }\\n};\\n```\\nIf you like this post then upvote please  ^_^",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        \\n        int indegree[2005]={0};\\n        vector<int>graph[2006];\\n         for(auto i:pre)\\n         {\\n            int x=i[0],y=i[1];\\n            graph[y].push_back(x); \\n            indegree[x]++;\\n         }\\n\\n         queue<int>q;\\n         vector<int>ans;\\n         for(int i=0;i<n;i++)if(!indegree[i])q.push(i);\\n\\n         while(!q.empty())\\n         {\\n            int t=q.front();q.pop();\\n            ans.push_back(t);\\n            for(auto u:graph[t])\\n             {\\n                 indegree[u]--;\\n                 if(indegree[u]==0)q.push(u);\\n             }\\n         }\\n        \\n         if(ans.size()!=n)ans.clear();\\n         //reverse(ans.begin(),ans.end());\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338090,
                "title": "go-solution-with-topological-sort",
                "content": "```\\nimport \"container/list\"\\n\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    adList := make(map[int][]int, numCourses)\\n    degree := make([]int, numCourses)\\n    ans := []int{}\\n    q := list.New()\\n    for _, node := range prerequisites {\\n        adList[node[1]] = append(adList[node[1]], node[0])\\n        degree[node[0]]++\\n    }\\n    for i:=0; i<numCourses; i++ {\\n        if degree[i] == 0 {\\n            q.PushBack(i)\\n        }\\n    }\\n    for q.Len() > 0 {\\n        f := q.Front().Value.(int)\\n        ans = append(ans, f)\\n        q.Remove(q.Front())\\n        numCourses--\\n        for _, d := range adList[f] {\\n            degree[d]--\\n            if degree[d] == 0 {\\n                q.PushBack(d)\\n            }\\n        }\\n    }\\n    if numCourses == 0 {\\n        return ans\\n    }\\n    return []int{}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Topological Sort"
                ],
                "code": "```\\nimport \"container/list\"\\n\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    adList := make(map[int][]int, numCourses)\\n    degree := make([]int, numCourses)\\n    ans := []int{}\\n    q := list.New()\\n    for _, node := range prerequisites {\\n        adList[node[1]] = append(adList[node[1]], node[0])\\n        degree[node[0]]++\\n    }\\n    for i:=0; i<numCourses; i++ {\\n        if degree[i] == 0 {\\n            q.PushBack(i)\\n        }\\n    }\\n    for q.Len() > 0 {\\n        f := q.Front().Value.(int)\\n        ans = append(ans, f)\\n        q.Remove(q.Front())\\n        numCourses--\\n        for _, d := range adList[f] {\\n            degree[d]--\\n            if degree[d] == 0 {\\n                q.PushBack(d)\\n            }\\n        }\\n    }\\n    if numCourses == 0 {\\n        return ans\\n    }\\n    return []int{}\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1307798,
                "title": "c-faster-than-93-topological-sort-with-recursive-dfs-coloring-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int color[2001] = {0};\\n    // 0 -> white or unvisited\\n    // 1 -> gray or visiting\\n    // 2-> black or visited\\n    bool DFS(int v, vector<int> adj[], vector<int>&res) {\\n    if(color[v]==1) { // when you meet the same node twice which traversing the route , it has a cycle\\n        return false; // break from cycle\\n    }\\n\\tcolor[v] = 1;\\n\\n\\tfor(int u = 0; u < adj[v].size(); ++u ) {    \\n    \\tif(color[adj[v][u]]==0) { // visit only unvisited nodes\\n             if(!DFS(adj[v][u], adj, res)) { // if cycle discovered , break free and return false\\n                 return false;\\n             }\\n\\t\\t}\\n        if(color[adj[v][u]]==1) {\\n             return false;\\n         }\\n\\t\\t\\n\\t}\\n    color[v] = 2;\\n    res.push_back(v);\\n\\treturn true;\\n}    \\n\\nvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n    int n = prerequisites.size();\\n\\tvector<int> adj[numCourses];\\n\\tvector<int> res;\\n\\tfor(int i = 0; i < n; ++i) {\\n\\t\\tadj[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n\\t}\\n\\t\\n\\tfor(int v = 0; v < numCourses; ++v) {\\n        if(color[v]==0) { \\n            if (!DFS(v, adj, res))  return {}; \\n        }\\n\\t}\\n\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int color[2001] = {0};\\n    // 0 -> white or unvisited\\n    // 1 -> gray or visiting\\n    // 2-> black or visited\\n    bool DFS(int v, vector<int> adj[], vector<int>&res) {\\n    if(color[v]==1) { // when you meet the same node twice which traversing the route , it has a cycle\\n        return false; // break from cycle\\n    }\\n\\tcolor[v] = 1;\\n\\n\\tfor(int u = 0; u < adj[v].size(); ++u ) {    \\n    \\tif(color[adj[v][u]]==0) { // visit only unvisited nodes\\n             if(!DFS(adj[v][u], adj, res)) { // if cycle discovered , break free and return false\\n                 return false;\\n             }\\n\\t\\t}\\n        if(color[adj[v][u]]==1) {\\n             return false;\\n         }\\n\\t\\t\\n\\t}\\n    color[v] = 2;\\n    res.push_back(v);\\n\\treturn true;\\n}    \\n\\nvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n    int n = prerequisites.size();\\n\\tvector<int> adj[numCourses];\\n\\tvector<int> res;\\n\\tfor(int i = 0; i < n; ++i) {\\n\\t\\tadj[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n\\t}\\n\\t\\n\\tfor(int v = 0; v < numCourses; ++v) {\\n        if(color[v]==0) { \\n            if (!DFS(v, adj, res))  return {}; \\n        }\\n\\t}\\n\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136423,
                "title": "javascript-kahn-s-algo",
                "content": "```\\nvar findOrder = function(numCourses, prerequisites) {\\n    let inDegree = new Array(numCourses).fill(0);\\n    let queue = [];\\n    let res = [];\\n    \\n    for (let [course] of prerequisites) {\\n        inDegree[course] ++;\\n    }\\n    for (let course = 0; course < inDegree.length; course ++) {\\n        if (inDegree[course] === 0) {\\n            queue.push(course);\\n        }\\n    }\\n    \\n    while (queue.length) {\\n        let currentCourse = queue.pop();\\n        numCourses --;\\n        res.push(currentCourse);\\n        for (let [course, preq] of prerequisites) {\\n            if (currentCourse === preq) {\\n                inDegree[course] --;\\n                if (inDegree[course] === 0) {\\n                    queue.push(course)\\n                }\\n            }\\n \\n        }\\n    }\\n    return numCourses === 0 ? res : [];\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findOrder = function(numCourses, prerequisites) {\\n    let inDegree = new Array(numCourses).fill(0);\\n    let queue = [];\\n    let res = [];\\n    \\n    for (let [course] of prerequisites) {\\n        inDegree[course] ++;\\n    }\\n    for (let course = 0; course < inDegree.length; course ++) {\\n        if (inDegree[course] === 0) {\\n            queue.push(course);\\n        }\\n    }\\n    \\n    while (queue.length) {\\n        let currentCourse = queue.pop();\\n        numCourses --;\\n        res.push(currentCourse);\\n        for (let [course, preq] of prerequisites) {\\n            if (currentCourse === preq) {\\n                inDegree[course] --;\\n                if (inDegree[course] === 0) {\\n                    queue.push(course)\\n                }\\n            }\\n \\n        }\\n    }\\n    return numCourses === 0 ? res : [];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 975877,
                "title": "dfs-easy-java-solution",
                "content": "\\n```\\nclass Solution {\\n    \\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List<List<Integer>> courses = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i=0; i<numCourses; i++){\\n            courses.add(new ArrayList<>());\\n        }\\n        \\n        for(int i=0; i<prerequisites.length; i++){\\n            courses.get(prerequisites[i][0]).add(prerequisites[i][1]);\\n        }\\n        \\n        int track []= new int[numCourses]; \\n        for(int i=0; i<numCourses; i++){\\n            if(dfs(courses, i, list, track)==false){\\n                return new int[0];\\n            }\\n        }\\n            \\n        int[] ans = list.stream().mapToInt(i->i).toArray();\\n        \\n        return ans;\\n    }\\n    \\n    public boolean dfs(List<List<Integer>> courses, int start, List<Integer> list, int track[]){\\n        \\n        if(track[start]==2) return true;\\n        if(track[start]==1) return false;\\n        \\n        track[start] = 1;\\n        \\n        for(int j=0; j<courses.get(start).size(); j++){\\n            if(dfs(courses, courses.get(start).get(j),list, track)==false) return false;\\n        }\\n        track[start] = 2;\\n        list.add(start);\\n        return true;\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        List<List<Integer>> courses = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i=0; i<numCourses; i++){\\n            courses.add(new ArrayList<>());\\n        }\\n        \\n        for(int i=0; i<prerequisites.length; i++){\\n            courses.get(prerequisites[i][0]).add(prerequisites[i][1]);\\n        }\\n        \\n        int track []= new int[numCourses]; \\n        for(int i=0; i<numCourses; i++){\\n            if(dfs(courses, i, list, track)==false){\\n                return new int[0];\\n            }\\n        }\\n            \\n        int[] ans = list.stream().mapToInt(i->i).toArray();\\n        \\n        return ans;\\n    }\\n    \\n    public boolean dfs(List<List<Integer>> courses, int start, List<Integer> list, int track[]){\\n        \\n        if(track[start]==2) return true;\\n        if(track[start]==1) return false;\\n        \\n        track[start] = 1;\\n        \\n        for(int j=0; j<courses.get(start).size(); j++){\\n            if(dfs(courses, courses.get(start).get(j),list, track)==false) return false;\\n        }\\n        track[start] = 2;\\n        list.add(start);\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905012,
                "title": "animated-explanation-c-both-solutions-in-degrees-traversal-backtracking-dfs",
                "content": "Animated Video Explanation:\\nhttps://www.youtube.com/watch?v=3KBmTfKT_5s\\n\\nIn-Degree Traversal Code (Kahn\\'s Algorithm):\\n```\\nclass Solution {\\npublic:\\n     vector<int> topological_sort(int n, vector<vector<int>>& edges) {\\n      // convert to adjacency lists, and record in-degrees\\n      vector<vector<int>> adj(n);\\n      vector<int> in_degree(n);\\n      for (auto &p : edges) {\\n        adj[p[1]].push_back(p[0]);\\n        in_degree[p[0]]++;\\n      }\\n\\n      // initialize our todo queue with all the in_degree=0 nodes\\n      queue<int> todo;\\n      for (int i = 0; i < n; ++i) {\\n        if (in_degree[i] == 0)\\n          todo.push(i);\\n      }\\n\\n      // traverse our graph\\n      vector<int> ret;\\n      while (!todo.empty()) {\\n        int cur = todo.front();\\n        todo.pop();\\n        ret.push_back(cur);\\n        for (auto i : adj[cur]) {\\n          --in_degree[i];\\n          if (in_degree[i] == 0)\\n            todo.push(i);\\n        }\\n      }\\n\\n      // detect cycles\\n      if (ret.size() < n)\\n        return vector<int>();\\n\\n      return ret;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        return topological_sort(numCourses, prerequisites);\\n    }\\n};\\n```\\nBacktracking DFS Code:\\n```\\nclass Solution {\\npublic:\\n     const int BLUE = 0, GREEN = 1, RED = 2;\\n\\n    // returns TRUE if a cycle is detected\\n    // (and, if so, sets ret to an empty vector)\\n    bool backtracking_dfs(vector<vector<int>> &adj, vector<int> &ret,\\n                          vector<int> &color, int v) {\\n      // if we have already visited here, act appropriately\\n\\n      // if the color is green, a CYCLE has been detected\\n      if (color[v] == GREEN) {\\n        ret = vector<int>();\\n        return true;\\n      }\\n      // if the color is red, do nothing (already visited and recursed on)\\n      if (color[v] == RED) {\\n        return false;\\n      }\\n      // otherwise, add the current node to the stack of greens\\n      color[v] = GREEN;\\n      // then visit its neighbours\\n      for (int u : adj[v]) {\\n        // if any neighbour searches find a cycle, return true again\\n        if (backtracking_dfs(adj, ret, color, u))\\n          return true;\\n      }\\n      // done visiting all neighbours and their traversals too\\n      // remove from stack\\n      color[v] = RED;\\n      // add to return list\\n      ret.push_back(v);\\n\\n      // no cycle detected\\n      return false;\\n    }\\n\\n    // this becomes a helper function\\n    vector<int> topological_sort(int n, vector<vector<int>> edges) {\\n      vector<int> ret;\\n\\n      // convert edge list to adjacency lists\\n      vector<vector<int>> adj(n);\\n      for (auto &p : edges) {\\n        // construct the graph with the edges in reverse since the return vector\\n        // will be reversed if we do so\\n        adj[p[0]].push_back(p[1]);\\n      }\\n\\n      vector<int> color(n, BLUE);\\n\\n      // simulate a \"super node\", i.e. do the DFS from all starting positions\\n      for (int i = 0; i < n; ++i) {\\n        // if a cycle is detected, terminate early here too\\n        if (backtracking_dfs(adj, ret, color, i))\\n          return ret;\\n      }\\n      return ret;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        return topological_sort(numCourses, prerequisites);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int> topological_sort(int n, vector<vector<int>>& edges) {\\n      // convert to adjacency lists, and record in-degrees\\n      vector<vector<int>> adj(n);\\n      vector<int> in_degree(n);\\n      for (auto &p : edges) {\\n        adj[p[1]].push_back(p[0]);\\n        in_degree[p[0]]++;\\n      }\\n\\n      // initialize our todo queue with all the in_degree=0 nodes\\n      queue<int> todo;\\n      for (int i = 0; i < n; ++i) {\\n        if (in_degree[i] == 0)\\n          todo.push(i);\\n      }\\n\\n      // traverse our graph\\n      vector<int> ret;\\n      while (!todo.empty()) {\\n        int cur = todo.front();\\n        todo.pop();\\n        ret.push_back(cur);\\n        for (auto i : adj[cur]) {\\n          --in_degree[i];\\n          if (in_degree[i] == 0)\\n            todo.push(i);\\n        }\\n      }\\n\\n      // detect cycles\\n      if (ret.size() < n)\\n        return vector<int>();\\n\\n      return ret;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        return topological_sort(numCourses, prerequisites);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     const int BLUE = 0, GREEN = 1, RED = 2;\\n\\n    // returns TRUE if a cycle is detected\\n    // (and, if so, sets ret to an empty vector)\\n    bool backtracking_dfs(vector<vector<int>> &adj, vector<int> &ret,\\n                          vector<int> &color, int v) {\\n      // if we have already visited here, act appropriately\\n\\n      // if the color is green, a CYCLE has been detected\\n      if (color[v] == GREEN) {\\n        ret = vector<int>();\\n        return true;\\n      }\\n      // if the color is red, do nothing (already visited and recursed on)\\n      if (color[v] == RED) {\\n        return false;\\n      }\\n      // otherwise, add the current node to the stack of greens\\n      color[v] = GREEN;\\n      // then visit its neighbours\\n      for (int u : adj[v]) {\\n        // if any neighbour searches find a cycle, return true again\\n        if (backtracking_dfs(adj, ret, color, u))\\n          return true;\\n      }\\n      // done visiting all neighbours and their traversals too\\n      // remove from stack\\n      color[v] = RED;\\n      // add to return list\\n      ret.push_back(v);\\n\\n      // no cycle detected\\n      return false;\\n    }\\n\\n    // this becomes a helper function\\n    vector<int> topological_sort(int n, vector<vector<int>> edges) {\\n      vector<int> ret;\\n\\n      // convert edge list to adjacency lists\\n      vector<vector<int>> adj(n);\\n      for (auto &p : edges) {\\n        // construct the graph with the edges in reverse since the return vector\\n        // will be reversed if we do so\\n        adj[p[0]].push_back(p[1]);\\n      }\\n\\n      vector<int> color(n, BLUE);\\n\\n      // simulate a \"super node\", i.e. do the DFS from all starting positions\\n      for (int i = 0; i < n; ++i) {\\n        // if a cycle is detected, terminate early here too\\n        if (backtracking_dfs(adj, ret, color, i))\\n          return ret;\\n      }\\n      return ret;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        return topological_sort(numCourses, prerequisites);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741963,
                "title": "topological-sort-using-dfs-simple-understandable-solution-in-c",
                "content": "```\\nif you understand the intuition behind the logic plse give a upvote\\n```/*\\nThis is topological  order finding question but the twist is that the graph may be cyclic(not DAG)\\n\\nso basically i use dfs and check that two nodes are in same call stack and one of which is already visited then there is a cycle\\n\\nif there is any cycle then no topological order is possible\\n\\nif there is no cycle then just store the node values when the dfs call stack is going to end or simply when returning from the call and at last reverse the vector\\nI take a flag for checking cycle is present or not\\n*/\\nclass Solution {\\npublic:\\n    int f=0;\\n    void dfs(int node,vector<vector<int>> &graph,vector<int> &vis,vector<int> &ans){\\n        if(vis[node]!=0){\\n            return;\\n        }\\n        //cout<<\"called node \"<<node<<\\'\\\\n\\';\\n        vis[node]=1;\\n        for(auto x:graph[node]){\\n            if(vis[x]==0){\\n                dfs(x,graph,vis,ans);\\n            }else if(vis[x]==1){\\n                f=1;\\n            }\\n        }\\n        vis[node]=2;\\n        ans.push_back(node);\\n    }\\n    \\n    vector<int> findOrder(int n, vector<vector<int>>& p) {\\n        vector<int> ans;\\n        vector<vector<int>> graph(n);\\n        vector<int> vis(n,0);\\n        for(int i=0;i<p.size();i++){\\n            graph[p[i][1]].push_back(p[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            dfs(i,graph,vis,ans);   \\n        }\\n        if(f){\\n            ans.clear();\\n            return ans;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nif you understand the intuition behind the logic plse give a upvote\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477308,
                "title": "python-dfs",
                "content": "This is a classic topological sorting problem. We want to evaluate a directed acyclic graph and sort based on the traversal of this graph through the dependency relationships. More specifically a topological sort is a linear ordering of vertices such that for every directed edge uv, vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG. For example, a topological sorting of the following graph is \\u201C5 4 2 3 1 0\\u201D. There can be more than one topological sorting for a graph. For example, another topological sorting of the following graph is \\u201C4 5 2 3 1 0\\u201D. The first vertex in topological sorting is always a vertex with in-degree as 0 (a vertex with no incoming edges).\\n\\nA clean python solution:\\n\\n```python\\nclass CycleError(Exception):\\n    pass\\n\\n\\nclass Solution:\\n    def findOrder(self, n: int, prerequisites: List[List[int]]) -> bool:\\n        graph = [[] for _ in range(n)]\\n        for p in prerequisites:\\n            graph[p[1]].append(p[0])\\n\\n        visited = set()  # All visited elements.\\n        ordered = []     # Ordered returns DAG order traversal.\\n\\n        def search(node, parents):\\n            if node in parents:\\n                raise CycleError(node)\\n            if node in visited:\\n                return\\n\\n            visited.add(node)\\n            parents = parents.union((node,))\\n            for adj in graph[node]:\\n                search(adj, parents)\\n\\n            ordered.insert(0, node)\\n\\n        try:\\n            for node in range(n):\\n                search(node, set())\\n            return ordered\\n        except CycleError:\\n            return []\\n```",
                "solutionTags": [],
                "code": "```python\\nclass CycleError(Exception):\\n    pass\\n\\n\\nclass Solution:\\n    def findOrder(self, n: int, prerequisites: List[List[int]]) -> bool:\\n        graph = [[] for _ in range(n)]\\n        for p in prerequisites:\\n            graph[p[1]].append(p[0])\\n\\n        visited = set()  # All visited elements.\\n        ordered = []     # Ordered returns DAG order traversal.\\n\\n        def search(node, parents):\\n            if node in parents:\\n                raise CycleError(node)\\n            if node in visited:\\n                return\\n\\n            visited.add(node)\\n            parents = parents.union((node,))\\n            for adj in graph[node]:\\n                search(adj, parents)\\n\\n            ordered.insert(0, node)\\n\\n        try:\\n            for node in range(n):\\n                search(node, set())\\n            return ordered\\n        except CycleError:\\n            return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59394,
                "title": "share-my-cpp-topological-sort-solution",
                "content": "```\\nvector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites)  {\\n\\tvector<int> result;\\n\\tvector<int> indegree(numCourses, 0);\\n\\tqueue<int> Q;\\n\\tvector<vector<int> > G(numCourses, vector<int>());    \\n\\n\\tfor (int i = 0; i < prerequisites.size(); i++)  {\\n\\t\\tint x = prerequisites[i].first;\\n\\t\\tint y = prerequisites[i].second;\\n\\t\\tG[y].push_back(x);\\n\\t\\tindegree[x]++;\\n\\t}\\n\\n\\tfor (int node = 0; node < numCourses; node++) {\\n\\t\\tif (indegree[node] == 0)\\n\\t\\t\\tQ.push(node);\\n\\t}\\n\\n\\twhile (!Q.empty()) {\\n\\t\\tint x = Q.front();\\n\\t\\tQ.pop();\\n\\t\\tresult.push_back(x);\\n\\t\\tfor (int i = 0; i < G[x].size(); i++) {\\n\\t\\t\\tint y = G[x][i];\\n\\t\\t\\tindegree[y]--;\\n\\t\\t\\tif (indegree[y] == 0) {\\n\\t\\t\\t\\tQ.push(y);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (result.size() < numCourses)\\n\\t\\tresult.clear();\\n\\n\\treturn result;    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites)  {\\n\\tvector<int> result;\\n\\tvector<int> indegree(numCourses, 0);\\n\\tqueue<int> Q;\\n\\tvector<vector<int> > G(numCourses, vector<int>());    \\n\\n\\tfor (int i = 0; i < prerequisites.size(); i++)  {\\n\\t\\tint x = prerequisites[i].first;\\n\\t\\tint y = prerequisites[i].second;\\n\\t\\tG[y].push_back(x);\\n\\t\\tindegree[x]++;\\n\\t}\\n\\n\\tfor (int node = 0; node < numCourses; node++) {\\n\\t\\tif (indegree[node] == 0)\\n\\t\\t\\tQ.push(node);\\n\\t}\\n\\n\\twhile (!Q.empty()) {\\n\\t\\tint x = Q.front();\\n\\t\\tQ.pop();\\n\\t\\tresult.push_back(x);\\n\\t\\tfor (int i = 0; i < G[x].size(); i++) {\\n\\t\\t\\tint y = G[x][i];\\n\\t\\t\\tindegree[y]--;\\n\\t\\t\\tif (indegree[y] == 0) {\\n\\t\\t\\t\\tQ.push(y);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (result.size() < numCourses)\\n\\t\\tresult.clear();\\n\\n\\treturn result;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59424,
                "title": "simple-yet-beating-them-all-in-cpp",
                "content": "    class Solution {\\n    public:\\n        vector<int> findOrder(int num, vector<pair<int, int>>& pres) {\\n            vector<vector<int>> graph(num);\\n            vector<int> indegrees(num, 0), v;\\n            stack<int> toVisit;\\n            int count = 0;\\n            for(auto& pair: pres)\\n            {\\n                graph[pair.second].push_back(pair.first);\\n                indegrees[pair.first]++;\\n            }\\n            for(int i = 0; i < num; i++)\\n                if(!indegrees[i]) toVisit.push(i);\\n            while(!toVisit.empty())\\n            {\\n                int from = toVisit.top();\\n                toVisit.pop();\\n                for(auto n: graph[from])\\n                    if(--indegrees[n] == 0) toVisit.push(n);\\n                count++;\\n                v.push_back(from);\\n            }\\n            return count==num? v : (v.clear(), v);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> findOrder(int num, vector<pair<int, int>>& pres) {\\n            vector<vector<int>> graph(num);\\n            vector<int> indegrees(num, 0), v;\\n            stack<int> toVisit;\\n            int count = 0;\\n            for(auto& pair: pres)\\n            {\\n                graph[pair.second].push_back(pair.first);\\n                indegrees[pair.first]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 59529,
                "title": "java-code-for-course-schedule-ii",
                "content": "    public class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            if (numCourses <= 0) {\\n    \\t\\t\\treturn null;\\n    \\t\\t}\\n    \\t\\tint[] res = new int[numCourses];\\n    \\t\\tint index = 0;\\n    \\t\\tif (prerequisites.length == 0 || prerequisites[0].length == 0) {\\n    \\t\\t\\twhile (index < numCourses) {\\n    \\t\\t\\t\\tres[index] = index++;\\n    \\t\\t\\t}\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n            int[] course = new int[numCourses];\\n    \\t\\tMap<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();\\n    \\t\\tfor (int i = 0; i < prerequisites.length; i++) {\\n    \\t\\t\\tint val = prerequisites[i][0];\\n    \\t\\t\\tint key = prerequisites[i][1];\\n    \\t\\t\\tif (!map.containsKey(key)) {\\n    \\t\\t\\t\\tmap.put(key, new ArrayList<Integer>());\\n    \\t\\t\\t}\\n    \\t\\t\\tmap.get(key).add(val);\\n    \\t\\t\\tcourse[val]++;\\n    \\t\\t}\\n    \\t\\tQueue<Integer> queue = new LinkedList<Integer>();\\n    \\t\\tfor (int i = 0; i < numCourses; i++) {\\n    \\t\\t\\tif (course[i] == 0) {\\n    \\t\\t\\t\\tqueue.add(i);\\n    \\t\\t\\t\\tres[index++] = i;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\tint cur = queue.poll();\\n    \\t\\t\\tif (map.get(cur) != null) {\\n    \\t\\t\\t\\tfor (int temp : map.get(cur)) {\\n    \\t\\t\\t\\t\\tcourse[temp]--;\\n    \\t\\t\\t\\t\\tif (course[temp] == 0) {\\n    \\t\\t\\t\\t\\t\\tqueue.offer(temp);\\n    \\t\\t\\t\\t\\t\\tres[index++] = temp;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tfor (int i = 0; i < numCourses; i++) {\\n    \\t\\t\\tif (course[i] != 0) {\\n    \\t\\t\\t\\treturn new int[0];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int[] findOrder(int numCourses, int[][] prerequisites) {\\n            if (numCourses <= 0) {\\n    \\t\\t\\treturn null;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3848242,
                "title": "java-easiest-solution-ever-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(V + E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(V + E)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/dc199378-24e8-4321-b63c-21e3c11d288b_1690897182.3665764.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        // Form Graph - Create an adjacency list to represent the graph\\n        ArrayList<ArrayList<Integer>> adjacencyList = new ArrayList<>();\\n\\n        for (int i = 0; i < numCourses; i++) {\\n            adjacencyList.add(new ArrayList<>());\\n        }\\n\\n        int numOfPrerequisites = prerequisites.length;\\n\\n        // Add edges to the graph based on prerequisites\\n        for (int i = 0; i < numOfPrerequisites; i++) {\\n            int course = prerequisites[i][0];\\n            int prerequisite = prerequisites[i][1];\\n            adjacencyList.get(prerequisite).add(course);\\n        }\\n\\n        // Perform Topological Sort\\n\\n        // Initialize an array to store the in-degree of each course\\n        int[] inDegree = new int[numCourses];\\n\\n        // Calculate in-degree for each course\\n        for (int i = 0; i < numCourses; i++) {\\n            for (int neighbor : adjacencyList.get(i)) {\\n                inDegree[neighbor]++;\\n            }\\n        }\\n\\n        // Use a queue to store nodes with in-degree 0 (no prerequisites)\\n        Queue<Integer> queue = new LinkedList<>();\\n\\n        // Add courses with in-degree 0 to the queue\\n        for (int i = 0; i < numCourses; i++) {\\n            if (inDegree[i] == 0) {\\n                queue.add(i);\\n            }\\n        }\\n\\n        // Initialize an array to store the topological order of courses\\n        int[] topologicalOrder = new int[numCourses];\\n        int index = 0;\\n\\n        // Perform BFS to find the topological order\\n        while (!queue.isEmpty()) {\\n            int course = queue.peek();\\n            queue.remove();\\n            topologicalOrder[index++] = course;\\n\\n            // Decrease in-degree of neighbors and add them to the queue if their in-degree becomes 0\\n            for (int neighbor : adjacencyList.get(course)) {\\n                inDegree[neighbor]--;\\n\\n                if (inDegree[neighbor] == 0) {\\n                    queue.add(neighbor);\\n                }\\n            }\\n        }\\n\\n        // If all courses are included in the topological order, return the order array\\n        if (index == numCourses) {\\n            return topologicalOrder;\\n        }\\n\\n        // If there is a cycle in the graph (not all courses are included), return an empty array\\n        int[] emptyArray = {};\\n        return emptyArray;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        // Form Graph - Create an adjacency list to represent the graph\\n        ArrayList<ArrayList<Integer>> adjacencyList = new ArrayList<>();\\n\\n        for (int i = 0; i < numCourses; i++) {\\n            adjacencyList.add(new ArrayList<>());\\n        }\\n\\n        int numOfPrerequisites = prerequisites.length;\\n\\n        // Add edges to the graph based on prerequisites\\n        for (int i = 0; i < numOfPrerequisites; i++) {\\n            int course = prerequisites[i][0];\\n            int prerequisite = prerequisites[i][1];\\n            adjacencyList.get(prerequisite).add(course);\\n        }\\n\\n        // Perform Topological Sort\\n\\n        // Initialize an array to store the in-degree of each course\\n        int[] inDegree = new int[numCourses];\\n\\n        // Calculate in-degree for each course\\n        for (int i = 0; i < numCourses; i++) {\\n            for (int neighbor : adjacencyList.get(i)) {\\n                inDegree[neighbor]++;\\n            }\\n        }\\n\\n        // Use a queue to store nodes with in-degree 0 (no prerequisites)\\n        Queue<Integer> queue = new LinkedList<>();\\n\\n        // Add courses with in-degree 0 to the queue\\n        for (int i = 0; i < numCourses; i++) {\\n            if (inDegree[i] == 0) {\\n                queue.add(i);\\n            }\\n        }\\n\\n        // Initialize an array to store the topological order of courses\\n        int[] topologicalOrder = new int[numCourses];\\n        int index = 0;\\n\\n        // Perform BFS to find the topological order\\n        while (!queue.isEmpty()) {\\n            int course = queue.peek();\\n            queue.remove();\\n            topologicalOrder[index++] = course;\\n\\n            // Decrease in-degree of neighbors and add them to the queue if their in-degree becomes 0\\n            for (int neighbor : adjacencyList.get(course)) {\\n                inDegree[neighbor]--;\\n\\n                if (inDegree[neighbor] == 0) {\\n                    queue.add(neighbor);\\n                }\\n            }\\n        }\\n\\n        // If all courses are included in the topological order, return the order array\\n        if (index == numCourses) {\\n            return topologicalOrder;\\n        }\\n\\n        // If there is a cycle in the graph (not all courses are included), return an empty array\\n        int[] emptyArray = {};\\n        return emptyArray;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588978,
                "title": "both-dfs-and-bfs-to-print-topological-order-c-dfs-bfs",
                "content": "# Intuition\\nUsing DFS and BFS i tried to use Topological sort\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->  \\n\\n# Code DFS\\n```\\nclass Solution {\\npublic:\\nbool dfs(vector<vector<int>> &ad,vector<bool> &vis,stack<int> &st,int i,vector<bool> & stk)\\n    {\\n        vis[i]=1;\\n        stk[i]=1;\\n        for(auto it:ad[i])\\n        {\\n            if(!vis[it])\\n            {\\n                if(dfs(ad,vis,st,it,stk))return true;\\n            }\\n            else if(stk[it])return true;\\n        }\\n        st.push(i);\\n        stk[i]=false;\\n        return false;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& pp) {\\n         vector<vector<int>> ad(n);\\n        vector<bool> vis(n,false),stk(n,false);\\n        vector<int> ans;\\n        for(int i=0;i<pp.size();i++)\\n        {\\n            ad[pp[i][1]].push_back(pp[i][0]);\\n        }\\n        stack<int> st;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                if(dfs(ad,vis,st,i,stk))return {};\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n# Code BFS\\n```\\nclass Solution {\\npublic:\\nbool bfs(vector<vector<int>> adj,int V,stack<int> &st)\\n    {\\n        vector<int> indegree(V,0);\\n        for(int i=0;i<V;i++)\\n        {\\n            for(auto it:adj[i])\\n            {\\n                indegree[it]++;\\n            }\\n        }\\n        for(int i=0;i<V;i++)\\n        {\\n            int j=0;\\n            for(;j<V;j++)\\n            {\\n                if(indegree[j]==0)\\n                {  \\n                    st.push(j);\\n                    break;\\n                }\\n            }\\n            if(j==V)return false;\\n            indegree[j]--;\\n            for(auto it:adj[j])\\n            {\\n                indegree[it]--;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& pp) {\\n         vector<vector<int>> ad(n);\\n        vector<bool> vis(n,false),stk(n,false);\\n        vector<int> ans;\\n        for(int i=0;i<pp.size();i++)\\n        {\\n            ad[pp[i][1]].push_back(pp[i][0]);\\n        }\\n        stack<int> st;\\n\\n        if(bfs(ad,n,st)==false)return {};\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool dfs(vector<vector<int>> &ad,vector<bool> &vis,stack<int> &st,int i,vector<bool> & stk)\\n    {\\n        vis[i]=1;\\n        stk[i]=1;\\n        for(auto it:ad[i])\\n        {\\n            if(!vis[it])\\n            {\\n                if(dfs(ad,vis,st,it,stk))return true;\\n            }\\n            else if(stk[it])return true;\\n        }\\n        st.push(i);\\n        stk[i]=false;\\n        return false;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& pp) {\\n         vector<vector<int>> ad(n);\\n        vector<bool> vis(n,false),stk(n,false);\\n        vector<int> ans;\\n        for(int i=0;i<pp.size();i++)\\n        {\\n            ad[pp[i][1]].push_back(pp[i][0]);\\n        }\\n        stack<int> st;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                if(dfs(ad,vis,st,i,stk))return {};\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321175,
                "title": "easy-to-understand-c-kahn-s-algorithm-bfs-topological-sorting-striver-s-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        vector<int> indeg(n,0);\\n        vector<int> adj[n];\\n        queue<int> q;\\n        vector<int> topo;\\n        for(auto it:prerequisites) adj[it[1]].push_back(it[0]);\\n        for(int i=0;i<n;i++){\\n            for(auto it:adj[i]) indeg[it]++;\\n        }\\n        for(int i=0;i<n;i++)\\n            if(indeg[i]==0)\\n                 q.push(i);\\n\\n        while(!q.empty()){\\n            int node = q.front();q.pop();\\n            topo.push_back(node);\\n            for(auto it:adj[node]){\\n                indeg[it]--;\\n                if(indeg[it]==0) q.push(it);\\n            }\\n        }\\n        if(topo.size()==n) return topo;\\n       return vector<int>();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        vector<int> indeg(n,0);\\n        vector<int> adj[n];\\n        queue<int> q;\\n        vector<int> topo;\\n        for(auto it:prerequisites) adj[it[1]].push_back(it[0]);\\n        for(int i=0;i<n;i++){\\n            for(auto it:adj[i]) indeg[it]++;\\n        }\\n        for(int i=0;i<n;i++)\\n            if(indeg[i]==0)\\n                 q.push(i);\\n\\n        while(!q.empty()){\\n            int node = q.front();q.pop();\\n            topo.push_back(node);\\n            for(auto it:adj[node]){\\n                indeg[it]--;\\n                if(indeg[it]==0) q.push(it);\\n            }\\n        }\\n        if(topo.size()==n) return topo;\\n       return vector<int>();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055663,
                "title": "topological-sort-c-indegree-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically here courses have dependencies to other course, so the problem boils down to topological sort in which total dependencies to a particular course is equivalent to the indegree of the node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we will visulaize this problem as graph. Now after that we will calculate the indegree of each and every node. Node haveing 0 indegree is free from any course dependencies so we can simply put 0 indegree node to our ans. Now after exploring dependency free nodes we will update the nodes indegree of those nodes which have dependencies of previous explored nodes i.e we will decrease the neighbours node of curr exploring node to 1. In this way we will explore all node and get the correct topological sorted order. \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we are visiting every node\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFor adjacency matrix of graph\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n\\n        vector<int> indegree(numCourses, 0);\\n        vector<vector<int>> adj(numCourses);\\n        vector<int> ans;\\n\\n        for(auto x : prerequisites){\\n            adj[x[1]].push_back(x[0]);\\n            indegree[x[0]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i = 0 ; i < numCourses; i++){\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n\\n\\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n\\n            ans.push_back(cur);\\n    \\n            for(auto neighbours: adj[cur]){\\n                indegree[neighbours]--;\\n                if(indegree[neighbours] == 0)\\n                    q.push(neighbours);\\n            }\\n        }\\n        if(ans.size() != numCourses) return {};\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/8a7f101f-fbb5-44ff-a9bc-4883e9d62969_1677837881.3926222.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n\\n        vector<int> indegree(numCourses, 0);\\n        vector<vector<int>> adj(numCourses);\\n        vector<int> ans;\\n\\n        for(auto x : prerequisites){\\n            adj[x[1]].push_back(x[0]);\\n            indegree[x[0]]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i = 0 ; i < numCourses; i++){\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n\\n\\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n\\n            ans.push_back(cur);\\n    \\n            for(auto neighbours: adj[cur]){\\n                indegree[neighbours]--;\\n                if(indegree[neighbours] == 0)\\n                    q.push(neighbours);\\n            }\\n        }\\n        if(ans.size() != numCourses) return {};\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045278,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        map<int, vector<int>> mp;\\n        vector<int> in(n);\\n        queue<int> q;\\n        for(auto v:prerequisites)\\n        {\\n            mp[v[1]].push_back(v[0]);\\n            in[v[0]]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            q.push(i);\\n        }\\n        cout<<q.size();\\n        vector<int> ans;\\n        while(!q.empty())\\n        {\\n            int t=q.front();\\n            q.pop();\\n            cout<<t<<\"e\";\\n            ans.push_back(t);\\n            for(int i:mp[t])\\n            {\\n                in[i]--;\\n                if(in[i]==0)\\n                q.push(i);\\n            }\\n        }\\n        if(ans.size()==n)\\n        return ans;\\n        return {};\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        map<int, vector<int>> mp;\\n        vector<int> in(n);\\n        queue<int> q;\\n        for(auto v:prerequisites)\\n        {\\n            mp[v[1]].push_back(v[0]);\\n            in[v[0]]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            q.push(i);\\n        }\\n        cout<<q.size();\\n        vector<int> ans;\\n        while(!q.empty())\\n        {\\n            int t=q.front();\\n            q.pop();\\n            cout<<t<<\"e\";\\n            ans.push_back(t);\\n            for(int i:mp[t])\\n            {\\n                in[i]--;\\n                if(in[i]==0)\\n                q.push(i);\\n            }\\n        }\\n        if(ans.size()==n)\\n        return ans;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2944256,
                "title": "my-java-solution-using-kahn-s-algo",
                "content": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prereq) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0; i<numCourses; i++) graph.add(new ArrayList<>());\\n        \\n        \\n        int[] indegree = new int[numCourses];\\n        for(int i=0; i<prereq.length; i++){\\n            graph.get(prereq[i][1]).add(prereq[i][0]);\\n            indegree[prereq[i][0]]++;\\n        }\\n        \\n        Queue<Integer> que = new ArrayDeque<>();\\n        for(int i=0; i<indegree.length; i++) if(indegree[i] == 0) que.add(i);\\n        int[] ans = new int[numCourses];\\n        int idx=0;\\n        \\n        while(que.size()!=0){\\n            int rem = que.poll();\\n            ans[idx++] = rem;\\n            List<Integer> get = graph.get(rem);\\n            for(int ele : get){\\n                indegree[ele]--;\\n                if(indegree[ele] == 0) que.add(ele);\\n            }\\n        }\\n        if(idx!=numCourses) return new int[0];\\n        else return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] findOrder(int numCourses, int[][] prereq) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0; i<numCourses; i++) graph.add(new ArrayList<>());\\n        \\n        \\n        int[] indegree = new int[numCourses];\\n        for(int i=0; i<prereq.length; i++){\\n            graph.get(prereq[i][1]).add(prereq[i][0]);\\n            indegree[prereq[i][0]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2386578,
                "title": "simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        //Make The Graph\\n        vector<vector<int>> Graph(n);\\n        for(int i = 0 ; i < prerequisites.size() ; i++){\\n            Graph[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        }\\n        \\n        //I have Graph at this point...\\n        //i will make a dfs call on my graph and check whether there is any cycle in my graph or not.\\n        //it there is a cycle i can say that topo sort will not exist and return empty vector\\n        //else i will return the topo sort that i will get after dfs call(because toposort is same as \\n        //postorder traveral)\\n        vector<int> visited(n,0);\\n        //0 means that the given vertex is unvisited\\n        //1 means that the given vertex is in the path\\n        //2 means that the given vertex is processed and not the part of the given path\\n        vector<int> ans;\\n        function<int(int)> dfs = [&](int u){\\n            // mark\\n            visited[u] = 1;\\n            //for each not processed children make a dfs call.\\n            //if the vertex has visited[v] = 1 menas it is part of the current path so there is a cycle\\n            for(int i = 0 ; i < Graph[u].size() ; i++){\\n                int v = Graph[u][i];\\n                if(!visited[v]){\\n                    if(dfs(v) == -1)\\n                        return -1;\\n                }else if(visited[v] == 1){\\n                    //there is a cycle\\n                    return -1;\\n                }\\n            }\\n            visited[u] = 2;\\n            ans.push_back(u);\\n            return 2;\\n        };\\n        for(int i = 0 ; i < n ; i++){\\n            if(!visited[i]){\\n                if(dfs(i) == -1)\\n                    return {};\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        //Make The Graph\\n        vector<vector<int>> Graph(n);\\n        for(int i = 0 ; i < prerequisites.size() ; i++){\\n            Graph[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        }\\n        \\n        //I have Graph at this point...\\n        //i will make a dfs call on my graph and check whether there is any cycle in my graph or not.\\n        //it there is a cycle i can say that topo sort will not exist and return empty vector\\n        //else i will return the topo sort that i will get after dfs call(because toposort is same as \\n        //postorder traveral)\\n        vector<int> visited(n,0);\\n        //0 means that the given vertex is unvisited\\n        //1 means that the given vertex is in the path\\n        //2 means that the given vertex is processed and not the part of the given path\\n        vector<int> ans;\\n        function<int(int)> dfs = [&](int u){\\n            // mark\\n            visited[u] = 1;\\n            //for each not processed children make a dfs call.\\n            //if the vertex has visited[v] = 1 menas it is part of the current path so there is a cycle\\n            for(int i = 0 ; i < Graph[u].size() ; i++){\\n                int v = Graph[u][i];\\n                if(!visited[v]){\\n                    if(dfs(v) == -1)\\n                        return -1;\\n                }else if(visited[v] == 1){\\n                    //there is a cycle\\n                    return -1;\\n                }\\n            }\\n            visited[u] = 2;\\n            ans.push_back(u);\\n            return 2;\\n        };\\n        for(int i = 0 ; i < n ; i++){\\n            if(!visited[i]){\\n                if(dfs(i) == -1)\\n                    return {};\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885484,
                "title": "golang-using-topo-bfs-order",
                "content": "```\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    var result []int\\n    \\n    var queue []int\\n    \\n    indegree := make(map[int][]int)\\n    adjacent := make(map[int][]int)\\n    count := 0\\n    \\n    for _,  prerequisite := range  prerequisites {\\n        src :=  prerequisite[1]\\n        dst :=  prerequisite[0]\\n        \\n        indegree[dst] = append(indegree[dst], src)\\n        adjacent[src] = append(adjacent[src], dst)\\n    }\\n    \\n    for i := 0; i < numCourses; i++ {\\n        if len(indegree[i]) == 0 {\\n            enqueue(&queue, i)\\n            result = append(result, i)\\n        }\\n    }\\n    \\n    for len(queue) > 0 {\\n        dequeuedEle := dequeue(&queue)\\n        \\n        for _, vertex := range adjacent[dequeuedEle] {\\n            tmp := indegree[vertex]\\n            remove(&tmp, dequeuedEle)\\n            indegree[vertex] = tmp\\n\\n            if len(indegree[vertex]) == 0 {\\n                enqueue(&queue, vertex)\\n                result = append(result, vertex)\\n            }\\n        }\\n        \\n        count += 1\\n    }\\n\\n    if count == numCourses {\\n        return result\\n    }\\n    \\n    return []int{}\\n}\\n\\nfunc remove(lst *[]int, removedEle int) {\\n\\tif lst == nil {\\n\\t\\tpanic(\"nil pointer\")\\n\\t}\\n\\n\\tif len(*lst) == 0 {\\n\\t\\tpanic(\"empty list\")\\n\\t}\\n\\n\\tfor idx, num := range *lst {\\n\\t\\tif num == removedEle {\\n\\t\\t\\t*lst = append((*lst)[:idx], (*lst)[idx+1:]...)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc enqueue(queue *[]int, newEle int) {\\n    if queue == nil {\\n        panic(\"nil pointer\")\\n    }\\n    \\n    *queue = append(*queue, newEle)\\n}\\n\\nfunc dequeue(queue *[]int) int {\\n    if queue == nil {\\n        panic(\"nil pointer\")\\n    }\\n    \\n    if len(*queue) == 0 {\\n        panic(\"empty queue\")\\n    }\\n    \\n    dequeuedEle := (*queue)[0]\\n    \\n    *queue = (*queue)[1:]\\n    \\n    return dequeuedEle\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    var result []int\\n    \\n    var queue []int\\n    \\n    indegree := make(map[int][]int)\\n    adjacent := make(map[int][]int)\\n    count := 0\\n    \\n    for _,  prerequisite := range  prerequisites {\\n        src :=  prerequisite[1]\\n        dst :=  prerequisite[0]\\n        \\n        indegree[dst] = append(indegree[dst], src)\\n        adjacent[src] = append(adjacent[src], dst)\\n    }\\n    \\n    for i := 0; i < numCourses; i++ {\\n        if len(indegree[i]) == 0 {\\n            enqueue(&queue, i)\\n            result = append(result, i)\\n        }\\n    }\\n    \\n    for len(queue) > 0 {\\n        dequeuedEle := dequeue(&queue)\\n        \\n        for _, vertex := range adjacent[dequeuedEle] {\\n            tmp := indegree[vertex]\\n            remove(&tmp, dequeuedEle)\\n            indegree[vertex] = tmp\\n\\n            if len(indegree[vertex]) == 0 {\\n                enqueue(&queue, vertex)\\n                result = append(result, vertex)\\n            }\\n        }\\n        \\n        count += 1\\n    }\\n\\n    if count == numCourses {\\n        return result\\n    }\\n    \\n    return []int{}\\n}\\n\\nfunc remove(lst *[]int, removedEle int) {\\n\\tif lst == nil {\\n\\t\\tpanic(\"nil pointer\")\\n\\t}\\n\\n\\tif len(*lst) == 0 {\\n\\t\\tpanic(\"empty list\")\\n\\t}\\n\\n\\tfor idx, num := range *lst {\\n\\t\\tif num == removedEle {\\n\\t\\t\\t*lst = append((*lst)[:idx], (*lst)[idx+1:]...)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc enqueue(queue *[]int, newEle int) {\\n    if queue == nil {\\n        panic(\"nil pointer\")\\n    }\\n    \\n    *queue = append(*queue, newEle)\\n}\\n\\nfunc dequeue(queue *[]int) int {\\n    if queue == nil {\\n        panic(\"nil pointer\")\\n    }\\n    \\n    if len(*queue) == 0 {\\n        panic(\"empty queue\")\\n    }\\n    \\n    dequeuedEle := (*queue)[0]\\n    \\n    *queue = (*queue)[1:]\\n    \\n    return dequeuedEle\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848781,
                "title": "dfs-implementation",
                "content": "Just like [course-schedule-i](https://leetcode.com/problems/course-schedule/) we can try to solve the problem using dfs. \\n\\nfor every course we can make a dfs call to check for *cycle* at same time, storing the path using a **vector**. If at any point we encounter a cycle we can return an empty vector. \\n\\nThe Tricky part here is how to store the path in which the courses should be taken, after dry running the code with given examles we can see **where** we should be pushing our element in the answer vector. Since this a dfs call the course(s) which require more number of courses to be completed before hand will come first in vector ( as this is leaf/bottom one ), now after traversals if there is no cycle we return the **vector** which is used to maintain the order of courses in reverse order.\\n\\n```\\nclass Solution {\\npublic:\\n     bool dfs(int i, unordered_map<int,vector<int>>& pre,vector<int>&visited,vector<int>&dfsvisited,vector<int>&v)\\n    {\\n        visited[i]=true;\\n        dfsvisited[i]=true;\\n        for(auto u:pre[i])\\n        {\\n            if(!visited[u] )\\n                if(dfs(u,pre,visited,dfsvisited,v))\\n                    return true;\\n            if(dfsvisited[u])return true;\\n        }\\n       v.push_back(i);\\n       dfsvisited[i]=false;\\n       return false;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& course) {\\n        vector<int>visited(n+1,false);\\n        vector<int>dfsvisited(n+1,false);\\n\\t\\t\\n        unordered_map<int,vector<int>>pre;\\n\\t\\t\\n        for(int i=0;i<course.size();i++)\\n        {\\n            pre[course[i][1]].push_back(course[i][0]);\\n        }\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                if(dfs(i,pre,visited,dfsvisited,v))\\n                {\\n                    v.clear();\\n                    return v;\\n                }\\n            }   \\n        }\\n        reverse(v.begin(),v.end()); \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool dfs(int i, unordered_map<int,vector<int>>& pre,vector<int>&visited,vector<int>&dfsvisited,vector<int>&v)\\n    {\\n        visited[i]=true;\\n        dfsvisited[i]=true;\\n        for(auto u:pre[i])\\n        {\\n            if(!visited[u] )\\n                if(dfs(u,pre,visited,dfsvisited,v))\\n                    return true;\\n            if(dfsvisited[u])return true;\\n        }\\n       v.push_back(i);\\n       dfsvisited[i]=false;\\n       return false;\\n    }\\n    vector<int> findOrder(int n, vector<vector<int>>& course) {\\n        vector<int>visited(n+1,false);\\n        vector<int>dfsvisited(n+1,false);\\n\\t\\t\\n        unordered_map<int,vector<int>>pre;\\n\\t\\t\\n        for(int i=0;i<course.size();i++)\\n        {\\n            pre[course[i][1]].push_back(course[i][0]);\\n        }\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                if(dfs(i,pre,visited,dfsvisited,v))\\n                {\\n                    v.clear();\\n                    return v;\\n                }\\n            }   \\n        }\\n        reverse(v.begin(),v.end()); \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670975,
                "title": "simple-topological-sort",
                "content": "consider each subject given as a node...we are given pairs where each pair has two subjects .the first subject of the pair has to be completed in order to study second and this condition has to be satisfied for all pairs. Its equivalent to finding topological sort for a given directed acyclic graph.(the ans is null if there exists a cycle ).This can be done easily using dfs +stack. feel free to ask questions about the code.....\\n```\\nclass Solution {\\npublic:\\n     bool vis[2001];\\n    bool dfsvis[2001];\\n    bool flag=true;\\n      vector<int>adj[2001];\\n    void dfs(int a,stack<int>&st)\\n    {\\n        vis[a]=true;\\n        dfsvis[a]=true;\\n        for(auto it:adj[a])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,st);\\n            }\\n            else if(dfsvis[it])\\n            {\\n                flag=false;\\n                return;\\n            }\\n        }\\n        st.push(a);\\n        dfsvis[a]=false;\\n        \\n    }\\n    \\n    \\n    \\n\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        \\n        vector<int>ans;\\n         stack<int>st;\\n        for(int i=0;i<pre.size();i++)\\n        {\\n            adj[pre[i][0]].push_back(pre[i][1]);\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(i,st);\\n            }\\n        }\\n        if(flag==false || st.empty())\\n        {\\n            return ans;\\n        }\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool vis[2001];\\n    bool dfsvis[2001];\\n    bool flag=true;\\n      vector<int>adj[2001];\\n    void dfs(int a,stack<int>&st)\\n    {\\n        vis[a]=true;\\n        dfsvis[a]=true;\\n        for(auto it:adj[a])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,st);\\n            }\\n            else if(dfsvis[it])\\n            {\\n                flag=false;\\n                return;\\n            }\\n        }\\n        st.push(a);\\n        dfsvis[a]=false;\\n        \\n    }\\n    \\n    \\n    \\n\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        \\n        vector<int>ans;\\n         stack<int>st;\\n        for(int i=0;i<pre.size();i++)\\n        {\\n            adj[pre[i][0]].push_back(pre[i][1]);\\n            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(i,st);\\n            }\\n        }\\n        if(flag==false || st.empty())\\n        {\\n            return ans;\\n        }\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642887,
                "title": "c-kahn-s-algorithm-99-09-faster",
                "content": "```\\nvector<int> topoSort(vector<int> adj[], int n) {\\n        // Kahn\\'s Algorithm\\n        \\n        vector<int> inDegree(n, 0), ans;\\n        int count = 0;\\n        queue<int> q;\\n    \\n        for(int i = 0; i < n; i++) for(auto it : adj[i]) inDegree[it]++;\\n        for(int i = 0; i < n; i++) if(inDegree[i] == 0) q.push(i);\\n        \\n        while(q.size() != 0) {\\n            int node = q.front();\\n            q.pop();\\n            count++;\\n            ans.push_back(node);\\n            \\n            for(auto it : adj[node]) {\\n                if(inDegree[it]) {\\n                    inDegree[it]--;\\n                    if(inDegree[it] == 0) q.push(it);\\n                }\\n            }\\n        }\\n        if(count == n) return ans;\\n        return {};\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[numCourses];\\n        for(int i = 0; i < prerequisites.size(); i++)\\n            adj[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        vector<int> ans = topoSort(adj, numCourses);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> topoSort(vector<int> adj[], int n) {\\n        // Kahn\\'s Algorithm\\n        \\n        vector<int> inDegree(n, 0), ans;\\n        int count = 0;\\n        queue<int> q;\\n    \\n        for(int i = 0; i < n; i++) for(auto it : adj[i]) inDegree[it]++;\\n        for(int i = 0; i < n; i++) if(inDegree[i] == 0) q.push(i);\\n        \\n        while(q.size() != 0) {\\n            int node = q.front();\\n            q.pop();\\n            count++;\\n            ans.push_back(node);\\n            \\n            for(auto it : adj[node]) {\\n                if(inDegree[it]) {\\n                    inDegree[it]--;\\n                    if(inDegree[it] == 0) q.push(it);\\n                }\\n            }\\n        }\\n        if(count == n) return ans;\\n        return {};\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[numCourses];\\n        for(int i = 0; i < prerequisites.size(); i++)\\n            adj[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        vector<int> ans = topoSort(adj, numCourses);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428496,
                "title": "very-easy-topological-sort-apna-college",
                "content": "**Please Upvote if you like it**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        \\n        int n = numCourses;\\n        int m = prerequisites.size();\\n        vector<vector<int>> adj(n);\\n        vector<int> indeg(n,0);\\n        vector<int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]); \\n            indeg[prerequisites[i][0]]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i =0;i<n;i++)\\n        {\\n            if(indeg[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int x = q.front();\\n            q.pop();\\n            ans.push_back(x);\\n            \\n            for(auto it : adj[x])\\n            {\\n                indeg[it]--;\\n                if(indeg[it] == 0)\\n                    q.push(it);\\n            }\\n        }\\n        if(ans.size() == n)\\n            return ans;\\n        return {};\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        \\n        int n = numCourses;\\n        int m = prerequisites.size();\\n        vector<vector<int>> adj(n);\\n        vector<int> indeg(n,0);\\n        vector<int> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]); \\n            indeg[prerequisites[i][0]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1411551,
                "title": "java-99-faster-topo-sort-cycle-detection-using-dfs",
                "content": "```\\nclass Solution {\\n    \\n    public boolean dfs(int curr, ArrayList<ArrayList<Integer>> adj, boolean[] visit, \\n                    boolean[] dfsVisit, Queue<Integer> q){\\n        visit[curr] = true;\\n        dfsVisit[curr] = true;\\n        \\n        for(Integer v : adj.get(curr)){\\n            if(!visit[v]){\\n                if(dfs(v, adj, visit, dfsVisit, q)) return true;\\n            }\\n            else if(dfsVisit[v]) return true;\\n        }\\n        \\n        q.add(curr);\\n        dfsVisit[curr] = false;\\n        return false;\\n    }\\n    \\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList();\\n        for(int i=0;i<numCourses;i++) adj.add(new ArrayList());\\n        for(int[] e : prerequisites) adj.get(e[0]).add(e[1]);\\n        \\n        boolean[] visit = new boolean[numCourses];\\n        boolean[] dfsVisit = new boolean[numCourses];\\n        Queue<Integer> q = new LinkedList();\\n        \\n        for(int i=0;i<numCourses;i++){\\n            if(!visit[i]){\\n                if(dfs(i, adj, visit, dfsVisit, q)) return new int[0];\\n            }\\n        }\\n        \\n        int[] res = new int[numCourses];\\n        int i = 0;\\n        while(!q.isEmpty()) res[i++] = q.remove();\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean dfs(int curr, ArrayList<ArrayList<Integer>> adj, boolean[] visit, \\n                    boolean[] dfsVisit, Queue<Integer> q){\\n        visit[curr] = true;\\n        dfsVisit[curr] = true;\\n        \\n        for(Integer v : adj.get(curr)){\\n            if(!visit[v]){\\n                if(dfs(v, adj, visit, dfsVisit, q)) return true;\\n            }\\n            else if(dfsVisit[v]) return true;\\n        }\\n        \\n        q.add(curr);\\n        dfsVisit[curr] = false;\\n        return false;\\n    }\\n    \\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList();\\n        for(int i=0;i<numCourses;i++) adj.add(new ArrayList());\\n        for(int[] e : prerequisites) adj.get(e[0]).add(e[1]);\\n        \\n        boolean[] visit = new boolean[numCourses];\\n        boolean[] dfsVisit = new boolean[numCourses];\\n        Queue<Integer> q = new LinkedList();\\n        \\n        for(int i=0;i<numCourses;i++){\\n            if(!visit[i]){\\n                if(dfs(i, adj, visit, dfsVisit, q)) return new int[0];\\n            }\\n        }\\n        \\n        int[] res = new int[numCourses];\\n        int i = 0;\\n        while(!q.isEmpty()) res[i++] = q.remove();\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347278,
                "title": "c-cpp-explanation-all-approaches",
                "content": "```\\n/* LeetCode Question: https://leetcode.com/problems/course-schedule-ii/ */\\n/* We have n courses numbered from 0 to n-1. We also have a prerequisite array, each element is of the form [a, b] which\\nindicates that to take the course a the pre-requisite is the course b. So, basically we have to finish the course b before\\nwe can start the course a. If there is a way to complete all the courses then we have to return the order otherwise empty \\nvector */\\n\\n/* Intution: The graph would have edge like a-> b, means to go and do the course b we first have to complete or visit the course a.\\nSo, here we have to find the ordering of the nodes such that all the further nodes or child nodes will come after the parent node\\nwhich can be done using topological sort  */\\n\\n/* Time Complexity: O((E + V) + V) {one for topo sort and order for cycle detection} */\\n/* Space Complexity: O(E + E + V) { for storing adjacency list, recursion stack and topo sort } */\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int node, vector<bool> &visited, stack<int> &s) {\\n        visited[node] = true;\\n        \\n        for(int v : adj[node]) {\\n            if(!visited[v])\\n                dfs(adj, v, visited, s);\\n        }\\n        \\n        /* After we have finished visiting all further nodes, now all the further nodes are in stack. Hence, we can push \\n        this node into the stack */\\n        s.push(node);\\n    }\\n    \\n    vector<int> getTopologicalSort(vector<int> adj[], int nC) {\\n        stack<int> s;\\n        vector<bool> visited(nC, false);\\n        \\n        /* Normal DFS call for all the nodes */\\n        for(int i=0; i<nC; i++) {\\n            if(!visited[i])\\n                dfs(adj, i, visited, s);\\n        }\\n        \\n        /* Pop all elements from stack to get topo sort */\\n        vector<int> topoSort;\\n        while(!s.empty()) {\\n            topoSort.push_back(s.top());\\n            s.pop();\\n        }\\n        \\n        return topoSort;\\n    }\\n    \\n    bool checkCycleExist(vector<int> adj[], int V, vector<int> &topoSort) {\\n        unordered_map<int, int> pos;\\n        \\n        for(int i=0; i<topoSort.size(); i++) {\\n            pos[topoSort[i]] = i;\\n        }\\n        \\n        for(int i=0; i<V; i++) {\\n            for(int v : adj[i]) {\\n                if(pos[v] < pos[i]) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<int> findOrder(int nC, vector<vector<int>>& pre) {\\n        vector<int> adj[nC];\\n        \\n        /* Making a directed graph adjacency list */\\n        for(int i=0; i<pre.size(); i++) {\\n            adj[pre[i][1]].push_back(pre[i][0]);\\n        }\\n        \\n        vector<int> topo(getTopologicalSort(adj, nC));\\n        if(checkCycleExist(adj, nC, topo)) return {};\\n        \\n        return topo;\\n    }\\n};\\n\\n/* Checking if the cycle exist or not simultanously while finding topological sort */\\n/* Approach : Have used the general way to find cycle in directed graph i.e. by tracing the nodes in current DFS call */\\nclass Solution {\\npublic:\\n    bool dfs(vector<int> adj[], int node, vector<bool> &visited, vector<bool> &currDFS, stack<int> &s) {\\n        visited[node] = true;\\n        currDFS[node] = true;\\n        \\n        for(int v : adj[node]) {\\n            if(!visited[v]) {\\n                if(!dfs(adj, v, visited, currDFS, s)) return false;   \\n            } else if(currDFS[v]) return false;\\n        }\\n        \\n        currDFS[node] = false;\\n        s.push(node);\\n        return true;\\n    }\\n    \\n    vector<int> getCourseOrder(vector<int> adj[], int nC) {\\n        stack<int> s;\\n        vector<bool> visited(nC, false);\\n        vector<bool> currDFS(nC, false);\\n        \\n        for(int i=0; i<nC; i++) {\\n            if(!visited[i]) {\\n                if(!dfs(adj, i, visited, currDFS, s)) return {};\\n            }\\n        }\\n        \\n        vector<int> topoSort;\\n        while(!s.empty()) {\\n            topoSort.push_back(s.top());\\n            s.pop();\\n        }\\n        \\n        return topoSort;\\n    }\\n    \\n    vector<int> findOrder(int nC, vector<vector<int>>& pre) {\\n        vector<int> adj[nC];\\n        \\n        for(int i=0; i<pre.size(); i++) {\\n            adj[pre[i][1]].push_back(pre[i][0]);\\n        }\\n        \\n        vector<int> topo(getCourseOrder(adj, nC));\\n        \\n        return topo;\\n    }\\n};\\n\\n/* Approach: Kahn\\'s Algorithm */\\n/* TC: O(E + V+E) { for creatin adj list, traversing over all vector and edges }, \\n  SC: O(V+E + V + V + V) { Adjacency List, indegree-vector, queue, order } */\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> indegree(numCourses);\\n        vector<int> adj[numCourses];\\n        \\n        for(int i=0; i<prerequisites.size(); i++) {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            \\n            indegree[prerequisites[i][0]]++;\\n        }\\n        \\n        int doneCnt = 0;    // to keep track of number of nodes completed\\n        queue<int> q;\\n        \\n        /* Push all courses or nodes with indegree 0, means this course has no other prerequisite course */\\n        for(int i=0; i<indegree.size(); i++) {\\n            if(indegree[i] == 0) q.push(i);\\n        }\\n        \\n        vector<int> order;\\n        while(!q.empty()) {\\n            int v = q.front();\\n            q.pop();\\n\\n            doneCnt++; // incremenet complete count\\n            order.push_back(v); \\n            \\n            /* Decrease indegree for all adjacent node of v */\\n            for(int u : adj[v]) {\\n                indegree[u]--;\\n                \\n                if(indegree[u] == 0) q.push(u);\\n            }\\n        }\\n        \\n        /* If all the nodes are traversed then order is correct otherwise graph has a cycle */\\n        return doneCnt == numCourses ? order : vector<int> {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n/* LeetCode Question: https://leetcode.com/problems/course-schedule-ii/ */\\n/* We have n courses numbered from 0 to n-1. We also have a prerequisite array, each element is of the form [a, b] which\\nindicates that to take the course a the pre-requisite is the course b. So, basically we have to finish the course b before\\nwe can start the course a. If there is a way to complete all the courses then we have to return the order otherwise empty \\nvector */\\n\\n/* Intution: The graph would have edge like a-> b, means to go and do the course b we first have to complete or visit the course a.\\nSo, here we have to find the ordering of the nodes such that all the further nodes or child nodes will come after the parent node\\nwhich can be done using topological sort  */\\n\\n/* Time Complexity: O((E + V) + V) {one for topo sort and order for cycle detection} */\\n/* Space Complexity: O(E + E + V) { for storing adjacency list, recursion stack and topo sort } */\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int node, vector<bool> &visited, stack<int> &s) {\\n        visited[node] = true;\\n        \\n        for(int v : adj[node]) {\\n            if(!visited[v])\\n                dfs(adj, v, visited, s);\\n        }\\n        \\n        /* After we have finished visiting all further nodes, now all the further nodes are in stack. Hence, we can push \\n        this node into the stack */\\n        s.push(node);\\n    }\\n    \\n    vector<int> getTopologicalSort(vector<int> adj[], int nC) {\\n        stack<int> s;\\n        vector<bool> visited(nC, false);\\n        \\n        /* Normal DFS call for all the nodes */\\n        for(int i=0; i<nC; i++) {\\n            if(!visited[i])\\n                dfs(adj, i, visited, s);\\n        }\\n        \\n        /* Pop all elements from stack to get topo sort */\\n        vector<int> topoSort;\\n        while(!s.empty()) {\\n            topoSort.push_back(s.top());\\n            s.pop();\\n        }\\n        \\n        return topoSort;\\n    }\\n    \\n    bool checkCycleExist(vector<int> adj[], int V, vector<int> &topoSort) {\\n        unordered_map<int, int> pos;\\n        \\n        for(int i=0; i<topoSort.size(); i++) {\\n            pos[topoSort[i]] = i;\\n        }\\n        \\n        for(int i=0; i<V; i++) {\\n            for(int v : adj[i]) {\\n                if(pos[v] < pos[i]) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<int> findOrder(int nC, vector<vector<int>>& pre) {\\n        vector<int> adj[nC];\\n        \\n        /* Making a directed graph adjacency list */\\n        for(int i=0; i<pre.size(); i++) {\\n            adj[pre[i][1]].push_back(pre[i][0]);\\n        }\\n        \\n        vector<int> topo(getTopologicalSort(adj, nC));\\n        if(checkCycleExist(adj, nC, topo)) return {};\\n        \\n        return topo;\\n    }\\n};\\n\\n/* Checking if the cycle exist or not simultanously while finding topological sort */\\n/* Approach : Have used the general way to find cycle in directed graph i.e. by tracing the nodes in current DFS call */\\nclass Solution {\\npublic:\\n    bool dfs(vector<int> adj[], int node, vector<bool> &visited, vector<bool> &currDFS, stack<int> &s) {\\n        visited[node] = true;\\n        currDFS[node] = true;\\n        \\n        for(int v : adj[node]) {\\n            if(!visited[v]) {\\n                if(!dfs(adj, v, visited, currDFS, s)) return false;   \\n            } else if(currDFS[v]) return false;\\n        }\\n        \\n        currDFS[node] = false;\\n        s.push(node);\\n        return true;\\n    }\\n    \\n    vector<int> getCourseOrder(vector<int> adj[], int nC) {\\n        stack<int> s;\\n        vector<bool> visited(nC, false);\\n        vector<bool> currDFS(nC, false);\\n        \\n        for(int i=0; i<nC; i++) {\\n            if(!visited[i]) {\\n                if(!dfs(adj, i, visited, currDFS, s)) return {};\\n            }\\n        }\\n        \\n        vector<int> topoSort;\\n        while(!s.empty()) {\\n            topoSort.push_back(s.top());\\n            s.pop();\\n        }\\n        \\n        return topoSort;\\n    }\\n    \\n    vector<int> findOrder(int nC, vector<vector<int>>& pre) {\\n        vector<int> adj[nC];\\n        \\n        for(int i=0; i<pre.size(); i++) {\\n            adj[pre[i][1]].push_back(pre[i][0]);\\n        }\\n        \\n        vector<int> topo(getCourseOrder(adj, nC));\\n        \\n        return topo;\\n    }\\n};\\n\\n/* Approach: Kahn\\'s Algorithm */\\n/* TC: O(E + V+E) { for creatin adj list, traversing over all vector and edges }, \\n  SC: O(V+E + V + V + V) { Adjacency List, indegree-vector, queue, order } */\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> indegree(numCourses);\\n        vector<int> adj[numCourses];\\n        \\n        for(int i=0; i<prerequisites.size(); i++) {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            \\n            indegree[prerequisites[i][0]]++;\\n        }\\n        \\n        int doneCnt = 0;    // to keep track of number of nodes completed\\n        queue<int> q;\\n        \\n        /* Push all courses or nodes with indegree 0, means this course has no other prerequisite course */\\n        for(int i=0; i<indegree.size(); i++) {\\n            if(indegree[i] == 0) q.push(i);\\n        }\\n        \\n        vector<int> order;\\n        while(!q.empty()) {\\n            int v = q.front();\\n            q.pop();\\n\\n            doneCnt++; // incremenet complete count\\n            order.push_back(v); \\n            \\n            /* Decrease indegree for all adjacent node of v */\\n            for(int u : adj[v]) {\\n                indegree[u]--;\\n                \\n                if(indegree[u] == 0) q.push(u);\\n            }\\n        }\\n        \\n        /* If all the nodes are traversed then order is correct otherwise graph has a cycle */\\n        return doneCnt == numCourses ? order : vector<int> {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327646,
                "title": "elegant-python-dfs",
                "content": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \\n        # Handle edge case.\\n        if not prerequisites: return [course for course in range(numCourses)]\\n        \\n        # \\'parents\\' maps each course to a list of its pre\\n\\t\\t# -requisites.\\n        parents = {course: [] for course in range(numCourses)}\\n        for course, prerequisite in prerequisites:\\n            parents[course].append(prerequisite)\\n            \\n        topological_order = []\\n        visited, current_path = [False]*numCourses, [False]*numCourses\\n        \\n        # Returns False if the digraph rooted at \\'course\\'\\n\\t\\t# is acyclic, else, appends courses to \\'topological\\n        # _order\\' in topological order and returns True.\\n        def dfs(course):\\n            if current_path[course]: return False\\n            if visited[course]: return True\\n            visited[course], current_path[course] = True, True\\n            if parents[course]:\\n                for parent in parents[course]:\\n                    if not dfs(parent): return False\\n            topological_order.append(course)\\n            current_path[course] = False\\n            return True\\n        \\n        for course in range(numCourses):\\n            if not dfs(course): return []\\n            \\n        return topological_order\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \\n        # Handle edge case.\\n        if not prerequisites: return [course for course in range(numCourses)]\\n        \\n        # \\'parents\\' maps each course to a list of its pre\\n\\t\\t# -requisites.\\n        parents = {course: [] for course in range(numCourses)}\\n        for course, prerequisite in prerequisites:\\n            parents[course].append(prerequisite)\\n            \\n        topological_order = []\\n        visited, current_path = [False]*numCourses, [False]*numCourses\\n        \\n        # Returns False if the digraph rooted at \\'course\\'\\n\\t\\t# is acyclic, else, appends courses to \\'topological\\n        # _order\\' in topological order and returns True.\\n        def dfs(course):\\n            if current_path[course]: return False\\n            if visited[course]: return True\\n            visited[course], current_path[course] = True, True\\n            if parents[course]:\\n                for parent in parents[course]:\\n                    if not dfs(parent): return False\\n            topological_order.append(course)\\n            current_path[course] = False\\n            return True\\n        \\n        for course in range(numCourses):\\n            if not dfs(course): return []\\n            \\n        return topological_order\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317570,
                "title": "java-using-indegree-and-bfs-faster-than-94",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList<Integer>[] graph = new ArrayList[numCourses];\\n        for(int i = 0; i < numCourses; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        int[] indegree = new int[numCourses];\\n        for(int[] pre : prerequisites) {\\n            int u = pre[0];\\n            int v = pre[1];\\n            graph[u].add(v);\\n            indegree[v]++;\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        for(int i = 0; i < indegree.length; i++) {\\n            if(indegree[i] == 0) {\\n                queue.add(i);\\n            }\\n        }\\n        \\n        int i = numCourses - 1;\\n        int[] ans = new int[numCourses];\\n        while(!queue.isEmpty()) {\\n            int vtx = queue.poll();\\n            ans[i--] = vtx;\\n            \\n            for(int v : graph[vtx]){\\n                if(--indegree[v] == 0){\\n                    queue.add(v);\\n                }\\n            }\\n        }\\n        \\n        if(i == -1)\\n            return ans;\\n       return new int[0];\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList<Integer>[] graph = new ArrayList[numCourses];\\n        for(int i = 0; i < numCourses; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        int[] indegree = new int[numCourses];\\n        for(int[] pre : prerequisites) {\\n            int u = pre[0];\\n            int v = pre[1];\\n            graph[u].add(v);\\n            indegree[v]++;\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<Integer>();\\n        for(int i = 0; i < indegree.length; i++) {\\n            if(indegree[i] == 0) {\\n                queue.add(i);\\n            }\\n        }\\n        \\n        int i = numCourses - 1;\\n        int[] ans = new int[numCourses];\\n        while(!queue.isEmpty()) {\\n            int vtx = queue.poll();\\n            ans[i--] = vtx;\\n            \\n            for(int v : graph[vtx]){\\n                if(--indegree[v] == 0){\\n                    queue.add(v);\\n                }\\n            }\\n        }\\n        \\n        if(i == -1)\\n            return ans;\\n       return new int[0];\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096569,
                "title": "graph-class-implementation-adjacency-list-dfs-java",
                "content": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] pre) {\\n        if(numCourses==1){\\n            return new int[] {0};\\n        }\\n        Graph g = new Graph(numCourses);\\n        for(int i=0; i<pre.length; i++){\\n            g.addEdge(pre[i][1], pre[i][0]);\\n        }\\n        return g.topSort();\\n    }\\n\\n    class Graph {\\n        class Node {\\n            int id;\\n            LinkedList<Node> adjacents = new LinkedList<>();\\n\\n            Node(int id) {\\n                this.id = id;\\n            }\\n        }\\n        \\n        int V;\\n\\n        Graph(int v) {\\n            this.V = v;\\n            for(int i=0; i<V; i++){\\n                nodeLookup.put(i, new Node(i));\\n            }\\n        }\\n\\n        HashMap<Integer, Node> nodeLookup = new HashMap<>();\\n\\n        Node getNode(int id) {\\n            if (nodeLookup.containsKey(id))\\n                return nodeLookup.get(id);\\n            else {\\n                Node newNode = new Node(id);\\n                nodeLookup.put(id, newNode);\\n                return newNode;\\n            }\\n        }\\n\\n        void addEdge(int source, int dest) {\\n            Node s = getNode(source);\\n            Node d = getNode(dest);\\n\\n            s.adjacents.add(d);\\n        }\\n\\n        boolean checkCycle() {\\n            boolean visited[] = new boolean[V];\\n            boolean tracker[] = new boolean[V];\\n            for (Map.Entry<Integer, Node> entry : nodeLookup.entrySet()) {\\n                boolean loop = DFS(visited, tracker, entry.getKey());\\n                if (loop) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        boolean DFS(boolean[] visited, boolean[] tracker, int current) {\\n            if (tracker[current]) {\\n                return true;\\n            }\\n            visited[current] = true;\\n            tracker[current] = true;\\n\\n            Node node = getNode(current);\\n            for (Node neighbor : node.adjacents) {\\n                boolean res = DFS(visited, tracker, neighbor.id);\\n                if (res) {\\n                    return true;\\n                }\\n            }\\n            tracker[current] = false;\\n\\n            return false;\\n        }\\n\\n        int[] topSort() {\\n            if (checkCycle()) {\\n                return new int[] {};\\n            }\\n            Stack<Integer> result = new Stack<>();\\n            HashSet<Integer> visited = new HashSet<>();\\n            for (Map.Entry<Integer, Node> entry : nodeLookup.entrySet()) {\\n                topSortHelper(entry.getKey(), visited, result);\\n            }\\n            int res[] = new int[result.size()];\\n            for (int i = 0; i < res.length; i++) {\\n                res[i] = result.pop();\\n            }\\n            return res;\\n        }\\n\\n        void topSortHelper(int id, HashSet<Integer> visited, Stack<Integer> result) {\\n            if (visited.contains(id)) {\\n                return;\\n            }\\n            visited.add(id);\\n            for (Node adjacent : getNode(id).adjacents) {\\n                topSortHelper(adjacent.id, visited, result);\\n            }\\n            result.push(id);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] pre) {\\n        if(numCourses==1){\\n            return new int[] {0};\\n        }\\n        Graph g = new Graph(numCourses);\\n        for(int i=0; i<pre.length; i++){\\n            g.addEdge(pre[i][1], pre[i][0]);\\n        }\\n        return g.topSort();\\n    }\\n\\n    class Graph {\\n        class Node {\\n            int id;\\n            LinkedList<Node> adjacents = new LinkedList<>();\\n\\n            Node(int id) {\\n                this.id = id;\\n            }\\n        }\\n        \\n        int V;\\n\\n        Graph(int v) {\\n            this.V = v;\\n            for(int i=0; i<V; i++){\\n                nodeLookup.put(i, new Node(i));\\n            }\\n        }\\n\\n        HashMap<Integer, Node> nodeLookup = new HashMap<>();\\n\\n        Node getNode(int id) {\\n            if (nodeLookup.containsKey(id))\\n                return nodeLookup.get(id);\\n            else {\\n                Node newNode = new Node(id);\\n                nodeLookup.put(id, newNode);\\n                return newNode;\\n            }\\n        }\\n\\n        void addEdge(int source, int dest) {\\n            Node s = getNode(source);\\n            Node d = getNode(dest);\\n\\n            s.adjacents.add(d);\\n        }\\n\\n        boolean checkCycle() {\\n            boolean visited[] = new boolean[V];\\n            boolean tracker[] = new boolean[V];\\n            for (Map.Entry<Integer, Node> entry : nodeLookup.entrySet()) {\\n                boolean loop = DFS(visited, tracker, entry.getKey());\\n                if (loop) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        boolean DFS(boolean[] visited, boolean[] tracker, int current) {\\n            if (tracker[current]) {\\n                return true;\\n            }\\n            visited[current] = true;\\n            tracker[current] = true;\\n\\n            Node node = getNode(current);\\n            for (Node neighbor : node.adjacents) {\\n                boolean res = DFS(visited, tracker, neighbor.id);\\n                if (res) {\\n                    return true;\\n                }\\n            }\\n            tracker[current] = false;\\n\\n            return false;\\n        }\\n\\n        int[] topSort() {\\n            if (checkCycle()) {\\n                return new int[] {};\\n            }\\n            Stack<Integer> result = new Stack<>();\\n            HashSet<Integer> visited = new HashSet<>();\\n            for (Map.Entry<Integer, Node> entry : nodeLookup.entrySet()) {\\n                topSortHelper(entry.getKey(), visited, result);\\n            }\\n            int res[] = new int[result.size()];\\n            for (int i = 0; i < res.length; i++) {\\n                res[i] = result.pop();\\n            }\\n            return res;\\n        }\\n\\n        void topSortHelper(int id, HashSet<Integer> visited, Stack<Integer> result) {\\n            if (visited.contains(id)) {\\n                return;\\n            }\\n            visited.add(id);\\n            for (Node adjacent : getNode(id).adjacents) {\\n                topSortHelper(adjacent.id, visited, result);\\n            }\\n            result.push(id);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998853,
                "title": "c-bfs-queue-easy-to-understand-explannation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> pre_req_count(numCourses,0);\\n        unordered_map<int,vector<int>> before_after;\\n        vector<int> res;\\n        \\n        for (int i=0; i<prerequisites.size(); ++i) {\\n            // \\n            before_after[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            //increase pre-req count of this course needed by 1 \\n            pre_req_count[prerequisites[i][0]]++;\\n        }\\n        \\n        int total = 0, curr;\\n        queue<int> q;\\n        //find all courses that don\\'t have any prerequisites and add to queue\\n        for (int i=0; i<pre_req_count.size(); ++i) {\\n            if (pre_req_count[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while (!q.empty()) {\\n            curr = q.front(); q.pop();\\n            res.push_back(curr);\\n            //find all courses that has this course as pre-req\\n            for (auto &i : before_after[curr]) {\\n                //this course now has one less pre-req\\n                pre_req_count[i]--;\\n                //if now this course is pre-req free, add to q\\n                if (pre_req_count[i] == 0)\\n                    q.push(i);\\n            } \\n            ++total;\\n        }\\n        if (total != numCourses)\\n            return {};\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> pre_req_count(numCourses,0);\\n        unordered_map<int,vector<int>> before_after;\\n        vector<int> res;\\n        \\n        for (int i=0; i<prerequisites.size(); ++i) {\\n            // \\n            before_after[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n            //increase pre-req count of this course needed by 1 \\n            pre_req_count[prerequisites[i][0]]++;\\n        }\\n        \\n        int total = 0, curr;\\n        queue<int> q;\\n        //find all courses that don\\'t have any prerequisites and add to queue\\n        for (int i=0; i<pre_req_count.size(); ++i) {\\n            if (pre_req_count[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while (!q.empty()) {\\n            curr = q.front(); q.pop();\\n            res.push_back(curr);\\n            //find all courses that has this course as pre-req\\n            for (auto &i : before_after[curr]) {\\n                //this course now has one less pre-req\\n                pre_req_count[i]--;\\n                //if now this course is pre-req free, add to q\\n                if (pre_req_count[i] == 0)\\n                    q.push(i);\\n            } \\n            ++total;\\n        }\\n        if (total != numCourses)\\n            return {};\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942920,
                "title": "dfs-topological-sort-js-solution",
                "content": "```\\n// DFS\\nvar findOrder = function(numCourses, prerequisites) {\\n    let adjList = new Array(numCourses).fill(0).map(() => []);\\n    let visited = new Array(numCourses).fill(false);\\n    let inDegree = new Array(numCourses).fill(0);\\n    for (let [course, preCourse] of prerequisites) {\\n        adjList[preCourse].push(course);\\n        inDegree[course]++;\\n    }\\n    // We can take courses that have no prerequisite or whose pre-requisites have already been taken\\n    let res = [];\\n    for (let i = 0; i < numCourses; i++) {\\n        if (inDegree[i] == 0 && !visited[i]) {\\n            dfs(i);\\n        }\\n    }\\n\\n    return res.length === numCourses ? res : [];\\n    \\n    function dfs(node) {\\n        res.push(node);\\n        visited[node] = true;\\n        for (let next of adjList[node]) {\\n            inDegree[next]--;\\n            if (inDegree[next] == 0 && !visited[next]) {\\n                dfs(next);\\n            }\\n        }\\n    }\\n    // Time Complexity: O(V + E), if there is a valid answer, we visit every node and all of its neighbours (those that current node is pointing to)\\n    // Space Complexity: O(V + E), for adjacency list  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// DFS\\nvar findOrder = function(numCourses, prerequisites) {\\n    let adjList = new Array(numCourses).fill(0).map(() => []);\\n    let visited = new Array(numCourses).fill(false);\\n    let inDegree = new Array(numCourses).fill(0);\\n    for (let [course, preCourse] of prerequisites) {\\n        adjList[preCourse].push(course);\\n        inDegree[course]++;\\n    }\\n    // We can take courses that have no prerequisite or whose pre-requisites have already been taken\\n    let res = [];\\n    for (let i = 0; i < numCourses; i++) {\\n        if (inDegree[i] == 0 && !visited[i]) {\\n            dfs(i);\\n        }\\n    }\\n\\n    return res.length === numCourses ? res : [];\\n    \\n    function dfs(node) {\\n        res.push(node);\\n        visited[node] = true;\\n        for (let next of adjList[node]) {\\n            inDegree[next]--;\\n            if (inDegree[next] == 0 && !visited[next]) {\\n                dfs(next);\\n            }\\n        }\\n    }\\n    // Time Complexity: O(V + E), if there is a valid answer, we visit every node and all of its neighbours (those that current node is pointing to)\\n    // Space Complexity: O(V + E), for adjacency list  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807757,
                "title": "java-dfs-solution-detecting-cycle",
                "content": "1. Here its similar to the cycle detection problem.\\n2. We check for the cycle using the dfs recursion function and if cycle is encountered we just return empty array.\\n3. If we do not encounter the cycle, then we just add it into arraylist and return it as an integer array.\\n\\nGeneral Concept is:\\nJust check for the cycle, if cycle return empty array, else add the vertex to array and finally just return the array.\\n\\n```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int v = numCourses;\\n        List<List<Integer>> adjacent = new ArrayList<>(v);\\n        for (int i=0; i<numCourses; i++)\\n            adjacent.add(new LinkedList<>());\\n        for (int i=0; i<prerequisites.length; i++)\\n            adjacent.get(prerequisites[i][0]).add(prerequisites[i][1]);\\n        List<Integer> list = new ArrayList<>();\\n        boolean [] visited = new boolean[numCourses];\\n        boolean [] recursionStack = new boolean[numCourses];\\n        for (int i=0; i<numCourses; i++) {\\n            if (isCycle(i, visited, recursionStack, numCourses, adjacent, list))\\n                return new int[0];\\n            }\\n        int [] result = new int[list.size()];  \\n        for (int i=0; !list.isEmpty(); i++)\\n            result[i] = list.remove(0);\\n        return result;\\n    }\\n    public boolean isCycle(int v, boolean [] visited, boolean [] recursionStack, int numCourses, List<List<Integer>> adjacent,List<Integer> list){\\n        if (recursionStack[v])\\n            return true;\\n        if (visited[v])\\n            return false;\\n        visited[v]= true;\\n        recursionStack[v] = true;\\n        for (int child: adjacent.get(v)) {\\n            if (isCycle(child, visited, recursionStack, numCourses, adjacent, list))\\n                return true;\\n        }\\n        recursionStack[v] = false;\\n        list.add(v);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int v = numCourses;\\n        List<List<Integer>> adjacent = new ArrayList<>(v);\\n        for (int i=0; i<numCourses; i++)\\n            adjacent.add(new LinkedList<>());\\n        for (int i=0; i<prerequisites.length; i++)\\n            adjacent.get(prerequisites[i][0]).add(prerequisites[i][1]);\\n        List<Integer> list = new ArrayList<>();\\n        boolean [] visited = new boolean[numCourses];\\n        boolean [] recursionStack = new boolean[numCourses];\\n        for (int i=0; i<numCourses; i++) {\\n            if (isCycle(i, visited, recursionStack, numCourses, adjacent, list))\\n                return new int[0];\\n            }\\n        int [] result = new int[list.size()];  \\n        for (int i=0; !list.isEmpty(); i++)\\n            result[i] = list.remove(0);\\n        return result;\\n    }\\n    public boolean isCycle(int v, boolean [] visited, boolean [] recursionStack, int numCourses, List<List<Integer>> adjacent,List<Integer> list){\\n        if (recursionStack[v])\\n            return true;\\n        if (visited[v])\\n            return false;\\n        visited[v]= true;\\n        recursionStack[v] = true;\\n        for (int child: adjacent.get(v)) {\\n            if (isCycle(child, visited, recursionStack, numCourses, adjacent, list))\\n                return true;\\n        }\\n        recursionStack[v] = false;\\n        list.add(v);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775519,
                "title": "c-toposort-using-dfs-solution",
                "content": "Applying Topological Sort using DFS approach.\\nWe will use a state vector which will denote the state of any node at a given time.\\nStates:\\n-1: Node is unprocessed\\n0: Node is being processed\\n1: Node is processed\\n\\nChecking for cycle:\\nWhile traversing through DFS if we encounter a node which is at state 1 i.e. being processed, it means there is a cycle in the graph so we instantly break the program and retrun an empty array.\\n\\nIf there is no cycle, we coninue with dfs and then using backtracking add the nodes in the orderings vector, which is the resulting answer.\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int i, vector<int> &state, vector<int> &orderings, map<int, vector<int>> &adjList) {\\n        state[i] = 0;\\n        bool res = true;\\n        \\n        for(auto nextNode : adjList[i]) {\\n            if(state[nextNode] == -1)\\n                res = res & dfs(nextNode, state, orderings, adjList);\\n            if(state[nextNode] == 0)\\n                return false;\\n        }\\n        state[i] = 1;\\n        orderings.push_back(i);\\n        return true;\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = numCourses;\\n        if(n==0)\\n            return {};\\n        \\n        //Making adjacency list\\n        map<int, vector<int>> adjList;\\n        for(int i=0;i<prerequisites.size();i++)\\n            adjList[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        \\n        for(int i=0; i<adjList.size();i++){\\n            cout<<i<<\":\";\\n            for(int j=0;j<adjList[i].size();j++)\\n                cout<<adjList[i][j]<<\" \";\\n            cout<<endl;\\n        }\\n        \\n        vector<int> state(n,-1);\\n        vector<int> orderings;\\n        \\n        for(int i=0;i<n;i++){\\n            if(state[i] == -1) {\\n                bool res = dfs(i, state, orderings, adjList);\\n                if(res == false)\\n                    return {};\\n            }\\n        }\\n        \\n        return orderings;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i, vector<int> &state, vector<int> &orderings, map<int, vector<int>> &adjList) {\\n        state[i] = 0;\\n        bool res = true;\\n        \\n        for(auto nextNode : adjList[i]) {\\n            if(state[nextNode] == -1)\\n                res = res & dfs(nextNode, state, orderings, adjList);\\n            if(state[nextNode] == 0)\\n                return false;\\n        }\\n        state[i] = 1;\\n        orderings.push_back(i);\\n        return true;\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int n = numCourses;\\n        if(n==0)\\n            return {};\\n        \\n        //Making adjacency list\\n        map<int, vector<int>> adjList;\\n        for(int i=0;i<prerequisites.size();i++)\\n            adjList[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        \\n        for(int i=0; i<adjList.size();i++){\\n            cout<<i<<\":\";\\n            for(int j=0;j<adjList[i].size();j++)\\n                cout<<adjList[i][j]<<\" \";\\n            cout<<endl;\\n        }\\n        \\n        vector<int> state(n,-1);\\n        vector<int> orderings;\\n        \\n        for(int i=0;i<n;i++){\\n            if(state[i] == -1) {\\n                bool res = dfs(i, state, orderings, adjList);\\n                if(res == false)\\n                    return {};\\n            }\\n        }\\n        \\n        return orderings;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 746030,
                "title": "topological-sort-neater-than-official-solution",
                "content": "I found the official solution to be a bit of a confusing implementation of topological sort, so I wanted to share my implementation in case it helped anyone:\\n\\n```\\nclass Solution:\\n    def findOrder(self, numVertices, edges):\\n        visited = set()\\n        sortedList = []\\n        depsDict = {vertex: set() for vertex in range(numVertices)}\\n        for node, dep in edges: \\n\\t\\t\\tdepsDict[node].add(dep)\\n            \\n        noDeps = [vertex for vertex, deps in depsDict.items() if len(deps) == 0 and vertex not in visited]\\n        while noDeps:\\n            vertex = noDeps.pop()\\n            visited.add(vertex)\\n            sortedList.append(vertex)\\n            \\n            for node, dep in depsDict.items():\\n                if vertex in depsDict[node]:\\n                    depsDict[node].remove(vertex)\\n            \\n            noDeps = [vertex for vertex, deps in depsDict.items() if len(deps) == 0 and vertex not in visited]\\n            \\n        return sortedList if len(sortedList) == numVertices else []\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Topological Sort"
                ],
                "code": "class Solution:\\n    def findOrder(self, numVertices, edges):\\n        visited = set()\\n        sortedList = []\\n        depsDict = {vertex: set() for vertex in range(numVertices)}",
                "codeTag": "Java"
            },
            {
                "id": 741815,
                "title": "python-by-dfs-and-deadlock-detection-w-comment",
                "content": "Python by DFS and dead lock detection\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n\\n        NOT_CHECKED, CHECKING, COMPLETED = 0, 1, 2\\n        \\n        # -------------------------------\\n        \\n        def has_deadlock( course )->bool:\\n            \\n            if course_state[course] == CHECKING:\\n                # There is a cycle(i.e., deadlock ) in prerequisites\\n                return True\\n            \\n            elif course_state[course] == COMPLETED:\\n                # current course has been checked and marked as completed\\n                return False\\n            \\n            \\n            \\n            # update current course as checking\\n            course_state[course] = CHECKING\\n            \\n            # check pre_course in DFS and detect whether there is deadlock\\n            for pre_course in requirement[course]:\\n                \\n                if has_deadlock( pre_course ):\\n                    # deadlock is found, impossible to finish all courses\\n                    return True\\n                \\n                \\n                \\n            # update current course as completed\\n            course_state[course] = COMPLETED\\n            \\n            # add current completed course into taking order\\n            course_taking_order.append( course )\\n            \\n            return False\\n        \\n        # -------------------------------\\n        \\n        # each course maintain a list of its own prerequisites\\n        requirement = collections.defaultdict( list )\\n        \\n        for course, pre_course in prerequisites:\\n            requirement[course].append( pre_course )\\n        \\n        \\n        # each course maintain a state among {NOT_CHECKED, CHECKING, COMPLETED}\\n        course_state = [ NOT_CHECKED for _ in range(numCourses) ]\\n           \\n        \\n        course_taking_order = []\\n        \\n\\n        for course_idx in range(0, numCourses):\\n            \\n            if has_deadlock(course_idx):\\n                # deadlock is found, impossible to finish all courses\\n                return []\\n        \\n        \\n        return course_taking_order\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n\\n        NOT_CHECKED, CHECKING, COMPLETED = 0, 1, 2\\n        \\n        # -------------------------------\\n        \\n        def has_deadlock( course )->bool:\\n            \\n            if course_state[course] == CHECKING:\\n                # There is a cycle(i.e., deadlock ) in prerequisites\\n                return True\\n            \\n            elif course_state[course] == COMPLETED:\\n                # current course has been checked and marked as completed\\n                return False\\n            \\n            \\n            \\n            # update current course as checking\\n            course_state[course] = CHECKING\\n            \\n            # check pre_course in DFS and detect whether there is deadlock\\n            for pre_course in requirement[course]:\\n                \\n                if has_deadlock( pre_course ):\\n                    # deadlock is found, impossible to finish all courses\\n                    return True\\n                \\n                \\n                \\n            # update current course as completed\\n            course_state[course] = COMPLETED\\n            \\n            # add current completed course into taking order\\n            course_taking_order.append( course )\\n            \\n            return False\\n        \\n        # -------------------------------\\n        \\n        # each course maintain a list of its own prerequisites\\n        requirement = collections.defaultdict( list )\\n        \\n        for course, pre_course in prerequisites:\\n            requirement[course].append( pre_course )\\n        \\n        \\n        # each course maintain a state among {NOT_CHECKED, CHECKING, COMPLETED}\\n        course_state = [ NOT_CHECKED for _ in range(numCourses) ]\\n           \\n        \\n        course_taking_order = []\\n        \\n\\n        for course_idx in range(0, numCourses):\\n            \\n            if has_deadlock(course_idx):\\n                # deadlock is found, impossible to finish all courses\\n                return []\\n        \\n        \\n        return course_taking_order\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 741765,
                "title": "c-solution-topological-order",
                "content": "```\\nclass Solution {\\npublic:\\n    //here topological order represents the topological order of the DAG\\n    //If it is not a DAG ,let us say A directed graph with cycles then \\n    //there topological ordering is not possible and topological_order here \\n    //contains the nodes leaving the nodes present in cycle .\\n    //This topological ordering represents a path through which each node is visited once.\\n    bool cycle_detect(int n, vector<int> &topological_order, vector<vector<int> > &adj) {\\n        vector<int> degree(n, 0);\\n        for (vector<int> p: adj)\\n            for(int node: p)\\n                degree[node]++;\\n        queue<int> q;\\n        for (int i = 0; i < n; i++)\\n            if (degree[i] == 0) q.push(i);\\n        while (!q.empty()) \\n        {\\n            int curr = q.front(); q.pop(); n--;\\n            topological_order.push_back(curr);\\n            for (auto next: adj[curr])\\n                if (--degree[next] == 0) q.push(next);\\n        }\\n        return n == 0;\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int> >& prerequisites) {\\n        vector<int> topologicalOrder;\\n        vector<vector<int> > adj(numCourses);\\n        for(vector<int> v: prerequisites){\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        if(!cycle_detect(numCourses, topologicalOrder, adj))\\n            return vector<int>(0);\\n        return topologicalOrder;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //here topological order represents the topological order of the DAG\\n    //If it is not a DAG ,let us say A directed graph with cycles then \\n    //there topological ordering is not possible and topological_order here \\n    //contains the nodes leaving the nodes present in cycle .\\n    //This topological ordering represents a path through which each node is visited once.\\n    bool cycle_detect(int n, vector<int> &topological_order, vector<vector<int> > &adj) {\\n        vector<int> degree(n, 0);\\n        for (vector<int> p: adj)\\n            for(int node: p)\\n                degree[node]++;\\n        queue<int> q;\\n        for (int i = 0; i < n; i++)\\n            if (degree[i] == 0) q.push(i);\\n        while (!q.empty()) \\n        {\\n            int curr = q.front(); q.pop(); n--;\\n            topological_order.push_back(curr);\\n            for (auto next: adj[curr])\\n                if (--degree[next] == 0) q.push(next);\\n        }\\n        return n == 0;\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int> >& prerequisites) {\\n        vector<int> topologicalOrder;\\n        vector<vector<int> > adj(numCourses);\\n        for(vector<int> v: prerequisites){\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        if(!cycle_detect(numCourses, topologicalOrder, adj))\\n            return vector<int>(0);\\n        return topologicalOrder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730056,
                "title": "c-topological-sort-using-3-markings-types",
                "content": "```csharp\\npublic class Solution \\n{\\n    enum Marking\\n    {\\n        Unvisited = 0,        \\n        Temporary = 1,\\n        Visited = 2\\n    };\\n    \\n    public int[] FindOrder(int numCourses, int[][] pre) \\n    {\\n        Marking[] visited = new Marking[numCourses];\\n        List<int> result = new List<int>();\\n        \\n        Dictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n        for(int i = 0; i < numCourses; i++)\\n        {\\n            graph[i] = new List<int>();\\n        }\\n        \\n        for(int i = 0; i < pre.Length; i++)\\n        {            \\n            graph[pre[i][1]].Add(pre[i][0]);\\n        }        \\n        \\n        for(int i = 0; i < graph.Count; i++)\\n        {           \\n            if(!visit(i, graph, visited, result))\\n            {\\n                return Array.Empty<int>();\\n            }            \\n        }\\n        \\n        result.Reverse();\\n        return result.ToArray();\\n    }\\n    \\n    private bool visit(int node, Dictionary<int, List<int>> graph, Marking[] visited, List<int> result)\\n    {\\n        if(visited[node] == Marking.Temporary)\\n        {\\n            return false;\\n        }\\n        \\n        if(visited[node] == Marking.Visited)\\n        {\\n            return true;\\n        }\\n                \\n        visited[node] = Marking.Temporary;\\n\\n        foreach(var neighbour in graph[node])\\n        {\\n            if(!visit(neighbour, graph, visited, result))\\n            {\\n                return false;    \\n            }  \\n        }        \\n\\n        visited[node] = Marking.Visited;\\n        result.Add(node);                \\n        return true;\\n    }\\n}\\n```\\n\\nAlso, In-Degree based solution:\\n\\n```csharp\\npublic int[] FindOrder(int numCourses, int[][] pre) \\n{\\n\\tList<int> result = new List<int>(numCourses);\\n\\tint[] inDegree = new int[numCourses];\\n\\tQueue<int> zeroInDegreeQueue = new Queue<int>();\\n\\n\\tDictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n\\tfor(int i = 0; i < numCourses; i++)\\n\\t{\\n\\t\\tgraph[i] = new List<int>();\\n\\t}\\n\\n\\tfor(int i = 0; i < pre.Length; i++)\\n\\t{            \\n\\t\\tgraph[pre[i][1]].Add(pre[i][0]);\\n\\t\\tinDegree[pre[i][0]]++;\\n\\t} \\n\\n\\tfor(int i = 0; i < numCourses; i++)\\n\\t{\\n\\t\\tif(inDegree[i] == 0)\\n\\t\\t{                \\n\\t\\t\\tzeroInDegreeQueue.Enqueue(i);\\n\\t\\t}\\n\\t}\\n\\n\\twhile(zeroInDegreeQueue.Count > 0)\\n\\t{\\n\\t\\tint node = zeroInDegreeQueue.Dequeue();\\n\\t\\tresult.Add(node);\\n\\n\\t\\tforeach(var neighbour in graph[node])\\n\\t\\t{\\n\\t\\t\\tinDegree[neighbour]--;\\n\\t\\t\\tif(inDegree[neighbour] == 0)\\n\\t\\t\\t{             \\n\\t\\t\\t\\tzeroInDegreeQueue.Enqueue(neighbour);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif(result.Count == numCourses)\\n\\t{            \\n\\t\\treturn result.ToArray();\\n\\t}\\n\\n\\treturn Array.Empty<int>();\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    enum Marking\\n    {\\n        Unvisited = 0,        \\n        Temporary = 1,\\n        Visited = 2\\n    };\\n    \\n    public int[] FindOrder(int numCourses, int[][] pre) \\n    {\\n        Marking[] visited = new Marking[numCourses];\\n        List<int> result = new List<int>();\\n        \\n        Dictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n        for(int i = 0; i < numCourses; i++)\\n        {\\n            graph[i] = new List<int>();\\n        }\\n        \\n        for(int i = 0; i < pre.Length; i++)\\n        {            \\n            graph[pre[i][1]].Add(pre[i][0]);\\n        }        \\n        \\n        for(int i = 0; i < graph.Count; i++)\\n        {           \\n            if(!visit(i, graph, visited, result))\\n            {\\n                return Array.Empty<int>();\\n            }            \\n        }\\n        \\n        result.Reverse();\\n        return result.ToArray();\\n    }\\n    \\n    private bool visit(int node, Dictionary<int, List<int>> graph, Marking[] visited, List<int> result)\\n    {\\n        if(visited[node] == Marking.Temporary)\\n        {\\n            return false;\\n        }\\n        \\n        if(visited[node] == Marking.Visited)\\n        {\\n            return true;\\n        }\\n                \\n        visited[node] = Marking.Temporary;\\n\\n        foreach(var neighbour in graph[node])\\n        {\\n            if(!visit(neighbour, graph, visited, result))\\n            {\\n                return false;    \\n            }  \\n        }        \\n\\n        visited[node] = Marking.Visited;\\n        result.Add(node);                \\n        return true;\\n    }\\n}\\n```\n```csharp\\npublic int[] FindOrder(int numCourses, int[][] pre) \\n{\\n\\tList<int> result = new List<int>(numCourses);\\n\\tint[] inDegree = new int[numCourses];\\n\\tQueue<int> zeroInDegreeQueue = new Queue<int>();\\n\\n\\tDictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n\\tfor(int i = 0; i < numCourses; i++)\\n\\t{\\n\\t\\tgraph[i] = new List<int>();\\n\\t}\\n\\n\\tfor(int i = 0; i < pre.Length; i++)\\n\\t{            \\n\\t\\tgraph[pre[i][1]].Add(pre[i][0]);\\n\\t\\tinDegree[pre[i][0]]++;\\n\\t} \\n\\n\\tfor(int i = 0; i < numCourses; i++)\\n\\t{\\n\\t\\tif(inDegree[i] == 0)\\n\\t\\t{                \\n\\t\\t\\tzeroInDegreeQueue.Enqueue(i);\\n\\t\\t}\\n\\t}\\n\\n\\twhile(zeroInDegreeQueue.Count > 0)\\n\\t{\\n\\t\\tint node = zeroInDegreeQueue.Dequeue();\\n\\t\\tresult.Add(node);\\n\\n\\t\\tforeach(var neighbour in graph[node])\\n\\t\\t{\\n\\t\\t\\tinDegree[neighbour]--;\\n\\t\\t\\tif(inDegree[neighbour] == 0)\\n\\t\\t\\t{             \\n\\t\\t\\t\\tzeroInDegreeQueue.Enqueue(neighbour);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif(result.Count == numCourses)\\n\\t{            \\n\\t\\treturn result.ToArray();\\n\\t}\\n\\n\\treturn Array.Empty<int>();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723374,
                "title": "neat-python3-iterative-postorder-dfs",
                "content": "```Python\\nNOT_VISITED = 0\\nDISCOVERING = 1\\nVISITED = 2\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \\n        # construct graph\\n        graph_neighbor = collections.defaultdict(list)\\n        for course, pre in prerequisites:\\n            graph_neighbor[pre].append(course)\\n        \\n        # iterative postorder DFS for topological sort\\n        tsort_rev = []\\n        status = [NOT_VISITED] * numCourses\\n        \\n        for course in range(numCourses):\\n            if status[course] == NOT_VISITED:\\n                dfs = [course]\\n                status[course] = DISCOVERING\\n                \\n                while dfs:\\n                    if graph_neighbor[dfs[-1]]:\\n                        n = graph_neighbor[dfs[-1]].pop()\\n                        if status[n] == DISCOVERING:\\n                            return []\\n                        if status[n] == NOT_VISITED:\\n                            dfs.append(n)\\n                            status[n] = DISCOVERING\\n                    else:\\n                        tsort_rev.append(dfs.pop())\\n                        status[tsort_rev[-1]] = VISITED\\n        \\n        return tsort_rev[::-1]\\n```",
                "solutionTags": [],
                "code": "```Python\\nNOT_VISITED = 0\\nDISCOVERING = 1\\nVISITED = 2\\n\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \\n        # construct graph\\n        graph_neighbor = collections.defaultdict(list)\\n        for course, pre in prerequisites:\\n            graph_neighbor[pre].append(course)\\n        \\n        # iterative postorder DFS for topological sort\\n        tsort_rev = []\\n        status = [NOT_VISITED] * numCourses\\n        \\n        for course in range(numCourses):\\n            if status[course] == NOT_VISITED:\\n                dfs = [course]\\n                status[course] = DISCOVERING\\n                \\n                while dfs:\\n                    if graph_neighbor[dfs[-1]]:\\n                        n = graph_neighbor[dfs[-1]].pop()\\n                        if status[n] == DISCOVERING:\\n                            return []\\n                        if status[n] == NOT_VISITED:\\n                            dfs.append(n)\\n                            status[n] = DISCOVERING\\n                    else:\\n                        tsort_rev.append(dfs.pop())\\n                        status[tsort_rev[-1]] = VISITED\\n        \\n        return tsort_rev[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663036,
                "title": "c",
                "content": "topological sort again\\n```\\npublic class Solution {\\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\\n        List<int>[] g = new List<int>[numCourses];\\n        int[] indegree = new int[numCourses];\\n        Queue<int> q = new Queue<int>();\\n        Stack<int> s = new Stack<int>();\\n        int[] res = new int[numCourses];\\n        \\n        foreach (var item in prerequisites)\\n        {\\n            if (g[item[0]] == null)\\n                g[item[0]] = new List<int>();\\n            \\n            g[item[0]].Add(item[1]);\\n            indegree[item[1]] += 1;\\n        }\\n        \\n        for (int i = 0; i < numCourses; i++)\\n            if (indegree[i] == 0)\\n                q.Enqueue(i);\\n        \\n        while (q.Count > 0)\\n        {\\n            int cur = q.Dequeue();\\n            \\n            if (g[cur] != null)            \\n                foreach (var item in g[cur])\\n                    if (--indegree[item] == 0)\\n                        q.Enqueue(item);\\n            \\n            s.Push(cur);\\n        }\\n        \\n        if (s.Count != numCourses)\\n            return new int[] { };\\n        \\n        for (int i = 0; i < numCourses; i++)\\n            res[i] = s.Pop();\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\\n        List<int>[] g = new List<int>[numCourses];\\n        int[] indegree = new int[numCourses];\\n        Queue<int> q = new Queue<int>();\\n        Stack<int> s = new Stack<int>();\\n        int[] res = new int[numCourses];\\n        \\n        foreach (var item in prerequisites)\\n        {\\n            if (g[item[0]] == null)\\n                g[item[0]] = new List<int>();\\n            \\n            g[item[0]].Add(item[1]);\\n            indegree[item[1]] += 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 294815,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    // do not need backtracking because we only need one solution.\\n    private int[] _result;\\n    private int resultIndex = 0;\\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\\n        _result = new int[numCourses];\\n\\n        var adjacencyMatrix = new HashSet<int>[numCourses];\\n\\n        for (int i = 0; i < numCourses; i++) {\\n            adjacencyMatrix[i] = new HashSet<int>();\\n        }\\n\\n        foreach (var fromTo in prerequisites) {\\n            var from = fromTo[0];\\n            var to = fromTo[1];\\n\\n            adjacencyMatrix[from].Add(to);\\n        }\\n\\n        var isVisited = new bool[numCourses];\\n        var isAdded = new bool[numCourses];\\n\\n        for (int i = 0; i < numCourses; i++) {\\n            if (isAdded[i]) continue;\\n            var noCyclic = DFS(i, adjacencyMatrix, isVisited, isAdded);\\n            if (!noCyclic) return new int[0];\\n        }\\n\\n        return _result;\\n    }\\n\\n    private bool DFS(int cur, HashSet<int>[] adjacencyMatrix, bool[] isVisited, bool[] isAdded) {\\n        if (isVisited[cur]) return false;\\n\\n        isVisited[cur] = true;\\n        var nextCourses = adjacencyMatrix[cur];\\n\\n        foreach (var next in nextCourses) {\\n            var oneResult = DFS(next, adjacencyMatrix, isVisited, isAdded);\\n            if (!oneResult) return false;\\n        }\\n\\n        if (!isAdded[cur]) {\\n            _result[resultIndex] = cur;\\n            resultIndex++;\\n            isAdded[cur] = true;\\n        }\\n\\n        isVisited[cur] = false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // do not need backtracking because we only need one solution.\\n    private int[] _result;\\n    private int resultIndex = 0;\\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\\n        _result = new int[numCourses];\\n\\n        var adjacencyMatrix = new HashSet<int>[numCourses];\\n\\n        for (int i = 0; i < numCourses; i++) {\\n            adjacencyMatrix[i] = new HashSet<int>();\\n        }\\n\\n        foreach (var fromTo in prerequisites) {\\n            var from = fromTo[0];\\n            var to = fromTo[1];\\n\\n            adjacencyMatrix[from].Add(to);\\n        }\\n\\n        var isVisited = new bool[numCourses];\\n        var isAdded = new bool[numCourses];\\n\\n        for (int i = 0; i < numCourses; i++) {\\n            if (isAdded[i]) continue;\\n            var noCyclic = DFS(i, adjacencyMatrix, isVisited, isAdded);\\n            if (!noCyclic) return new int[0];\\n        }\\n\\n        return _result;\\n    }\\n\\n    private bool DFS(int cur, HashSet<int>[] adjacencyMatrix, bool[] isVisited, bool[] isAdded) {\\n        if (isVisited[cur]) return false;\\n\\n        isVisited[cur] = true;\\n        var nextCourses = adjacencyMatrix[cur];\\n\\n        foreach (var next in nextCourses) {\\n            var oneResult = DFS(next, adjacencyMatrix, isVisited, isAdded);\\n            if (!oneResult) return false;\\n        }\\n\\n        if (!isAdded[cur]) {\\n            _result[resultIndex] = cur;\\n            resultIndex++;\\n            isAdded[cur] = true;\\n        }\\n\\n        isVisited[cur] = false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251095,
                "title": "java-topological-sort",
                "content": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int[] inDegrees = new int[numCourses];\\n        Map<Integer,List<Integer>> graph = new HashMap();\\n        \\n        for (int[] edge : prerequisites) {\\n            int start = edge[1], end = edge[0];\\n            inDegrees[end]++;\\n            if (!graph.containsKey(start))  graph.put(start, new ArrayList());\\n            graph.get(start).add(end);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList();\\n        int[] res = new int[numCourses];\\n        int idx = 0, count = 0;\\n        \\n        for (int i = 0; i < numCourses; ++i) {\\n            if (inDegrees[i] == 0)  queue.offer(i);\\n        }\\n        \\n        while(!queue.isEmpty()) {\\n            int course = queue.poll();\\n            if(graph.containsKey(course)) {\\n                for (int neigh : graph.get(course)) {\\n                    if (--inDegrees[neigh] == 0) {\\n                        queue.offer(neigh);\\n                    }\\n                }\\n            }\\n            res[idx++] = course;\\n            count++;\\n        }\\n        return count == numCourses ? res : new int[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int[] inDegrees = new int[numCourses];\\n        Map<Integer,List<Integer>> graph = new HashMap();\\n        \\n        for (int[] edge : prerequisites) {\\n            int start = edge[1], end = edge[0];\\n            inDegrees[end]++;\\n            if (!graph.containsKey(start))  graph.put(start, new ArrayList());\\n            graph.get(start).add(end);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList();\\n        int[] res = new int[numCourses];\\n        int idx = 0, count = 0;\\n        \\n        for (int i = 0; i < numCourses; ++i) {\\n            if (inDegrees[i] == 0)  queue.offer(i);\\n        }\\n        \\n        while(!queue.isEmpty()) {\\n            int course = queue.poll();\\n            if(graph.containsKey(course)) {\\n                for (int neigh : graph.get(course)) {\\n                    if (--inDegrees[neigh] == 0) {\\n                        queue.offer(neigh);\\n                    }\\n                }\\n            }\\n            res[idx++] = course;\\n            count++;\\n        }\\n        return count == numCourses ? res : new int[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248415,
                "title": "simple-java-solutions-kahn-dfs-5ms",
                "content": "Kahn approach :\\n\\n```java\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\n\\tList<List<Integer>> adjLists = new ArrayList<>();\\n\\tfor (int i = 0; i < numCourses; ++i) {\\n\\t\\tadjLists.add(new ArrayList<>());\\n\\t}\\n\\n\\tint[] inDegrees = new int[numCourses];\\n\\tfor (int[] prerequisite : prerequisites) {\\n\\t\\tadjLists.get(prerequisite[1]).add(prerequisite[0]);\\n\\t\\t++inDegrees[prerequisite[0]];\\n\\t}\\n\\n\\tQueue<Integer> queue = new LinkedList<>();\\n\\tfor (int i = 0; i < inDegrees.length; i++) {\\n\\t\\tif (inDegrees[i] == 0) {\\n\\t\\t\\tqueue.add(i);\\n\\t\\t}\\n\\t}\\n\\n\\tint[] res = new int[numCourses];\\n\\tint pos = 0;\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tint course = queue.remove();\\n\\t\\tfor (int vertex : adjLists.get(course)) {\\n\\t\\t\\tif (--inDegrees[vertex] == 0) {\\n\\t\\t\\t\\tqueue.add(vertex);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres[pos++] = course;\\n\\t}\\n\\n\\treturn pos == numCourses ? res : new int[] {};\\n}\\n```\\n\\nDFS approach:\\n\\n```java\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\tList<List<Integer>> adjLists = new ArrayList<>();\\n\\tfor (int i = 0; i < numCourses; ++i) {\\n\\t\\tadjLists.add(new ArrayList<>());\\n\\t}\\n\\n\\tfor (int[] prerequisite : prerequisites) {\\n\\t\\tadjLists.get(prerequisite[1]).add(prerequisite[0]);\\n\\t}\\n\\n\\tboolean[] visited = new boolean[numCourses];\\n\\tboolean[] onVisitingPath = new boolean[numCourses];\\n\\tLinkedList<Integer> stack = new LinkedList<>();\\n\\n\\tfor (int i = 0; i < numCourses; i++) {\\n\\t\\tif (!visited[i]) {\\n\\t\\t\\tdfs(adjLists, stack, visited, onVisitingPath, i);\\n\\t\\t}\\n\\t}\\n\\n\\tif (stack.size() != numCourses) {\\n\\t\\treturn new int[] {};\\n\\t} else {\\n\\t\\tint[] res = new int[numCourses];\\n\\t\\tfor (int i = 0; i < res.length; i++) {\\n\\t\\t\\tres[i] = stack.pop();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n\\nprivate void dfs(List<List<Integer>> adjLists, LinkedList<Integer> stack, boolean[] visited,\\n\\t\\tboolean[] onVisitingPath, int curr) {\\n\\n\\tvisited[curr] = true;\\n\\tonVisitingPath[curr] = true;\\n\\tfor (int vertex : adjLists.get(curr)) {\\n\\t\\tif (onVisitingPath[vertex]) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (!visited[vertex]) {\\n\\t\\t\\tdfs(adjLists, stack, visited, onVisitingPath, vertex);\\n\\t\\t}\\n\\t}\\n\\tonVisitingPath[curr] = false;\\n\\tstack.push(curr);\\n}\\n```\\n\\nHope this helps ! :D",
                "solutionTags": [],
                "code": "```java\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\n\\tList<List<Integer>> adjLists = new ArrayList<>();\\n\\tfor (int i = 0; i < numCourses; ++i) {\\n\\t\\tadjLists.add(new ArrayList<>());\\n\\t}\\n\\n\\tint[] inDegrees = new int[numCourses];\\n\\tfor (int[] prerequisite : prerequisites) {\\n\\t\\tadjLists.get(prerequisite[1]).add(prerequisite[0]);\\n\\t\\t++inDegrees[prerequisite[0]];\\n\\t}\\n\\n\\tQueue<Integer> queue = new LinkedList<>();\\n\\tfor (int i = 0; i < inDegrees.length; i++) {\\n\\t\\tif (inDegrees[i] == 0) {\\n\\t\\t\\tqueue.add(i);\\n\\t\\t}\\n\\t}\\n\\n\\tint[] res = new int[numCourses];\\n\\tint pos = 0;\\n\\twhile (!queue.isEmpty()) {\\n\\t\\tint course = queue.remove();\\n\\t\\tfor (int vertex : adjLists.get(course)) {\\n\\t\\t\\tif (--inDegrees[vertex] == 0) {\\n\\t\\t\\t\\tqueue.add(vertex);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres[pos++] = course;\\n\\t}\\n\\n\\treturn pos == numCourses ? res : new int[] {};\\n}\\n```\n```java\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n\\tList<List<Integer>> adjLists = new ArrayList<>();\\n\\tfor (int i = 0; i < numCourses; ++i) {\\n\\t\\tadjLists.add(new ArrayList<>());\\n\\t}\\n\\n\\tfor (int[] prerequisite : prerequisites) {\\n\\t\\tadjLists.get(prerequisite[1]).add(prerequisite[0]);\\n\\t}\\n\\n\\tboolean[] visited = new boolean[numCourses];\\n\\tboolean[] onVisitingPath = new boolean[numCourses];\\n\\tLinkedList<Integer> stack = new LinkedList<>();\\n\\n\\tfor (int i = 0; i < numCourses; i++) {\\n\\t\\tif (!visited[i]) {\\n\\t\\t\\tdfs(adjLists, stack, visited, onVisitingPath, i);\\n\\t\\t}\\n\\t}\\n\\n\\tif (stack.size() != numCourses) {\\n\\t\\treturn new int[] {};\\n\\t} else {\\n\\t\\tint[] res = new int[numCourses];\\n\\t\\tfor (int i = 0; i < res.length; i++) {\\n\\t\\t\\tres[i] = stack.pop();\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n\\nprivate void dfs(List<List<Integer>> adjLists, LinkedList<Integer> stack, boolean[] visited,\\n\\t\\tboolean[] onVisitingPath, int curr) {\\n\\n\\tvisited[curr] = true;\\n\\tonVisitingPath[curr] = true;\\n\\tfor (int vertex : adjLists.get(curr)) {\\n\\t\\tif (onVisitingPath[vertex]) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (!visited[vertex]) {\\n\\t\\t\\tdfs(adjLists, stack, visited, onVisitingPath, vertex);\\n\\t\\t}\\n\\t}\\n\\tonVisitingPath[curr] = false;\\n\\tstack.push(curr);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59365,
                "title": "easily-understand-9ms-java-solution-using-bfs-with-topological-sorting",
                "content": "This solution is based on BFS and topological sorting algorithm.\\nI was inspired a solution in Course Schedule, here is the problem: [link text](https://leetcode.com/problems/course-schedule/?tab=Description). But I can't find the solution now. I will add the link later. ^^\\nWe need an **adjacent table** to record the relationship between prerequisite course and current course. \\nAlso, we need an **indegree table** to record the number of courses we need to taken in order to take this current course.\\n**queue** is to record the course with indegree 0, which means we can take this course immediately without limitation.\\nOnce we take the course with indegree 0, we can look up other courses which require this course as prerequisite and subtract their indegree by 1. \\nOnce the indegree is 0, add this course to the queue.\\nbefore return, we need to check if there's a circle.\\n```\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n// initialize an adjacent table\\n      List<Integer>[] adj = new List[numCourses];\\n      for(int i = 0; i < numCourses; i++){\\n          adj[i] = new ArrayList<Integer>();\\n      }\\n// define an indegree table recording the number of prerequisite courses should be taken in order to take this current course\\n      int[] indegree = new int[numCourses];\\n      int[] result = new int[numCourses];\\n      for(int i = 0; i < prerequisites.length; i++){\\n          int preCourses = prerequisites[i][1];\\n          int curCourses = prerequisites[i][0];\\n          adj[preCourses].add(curCourses);\\n          indegree[curCourses]++;\\n      }\\n// to find the course with indegree 0 (which we can take immediately)\\n      Queue<Integer> readyCourses = new LinkedList<Integer>();\\n      for(int i = 0; i < numCourses; i++){\\n          if(indegree[i] == 0){\\n              readyCourses.offer(i);\\n          }\\n      }\\n      int count = 0;\\n// if we take the course with indegree 0, we look up for the courses needing this course as prerequisite and subtract their indegree value by 1\\n      while(!readyCourses.isEmpty()){\\n          int ready = readyCourses.poll();\\n          result[count++] = ready;\\n          for(int nextCourse : adj[ready]){\\n              indegree[nextCourse]--;\\n              if(indegree[nextCourse] == 0){\\n                  readyCourses.offer(nextCourse);\\n              }\\n          }\\n      }\\n// to check if there's a circle-like requirements before return\\n      return count == numCourses ? result : new int[0];\\n    }\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n// initialize an adjacent table\\n      List<Integer>[] adj = new List[numCourses];\\n      for(int i = 0; i < numCourses; i++){\\n          adj[i] = new ArrayList<Integer>();\\n      }\\n// define an indegree table recording the number of prerequisite courses should be taken in order to take this current course\\n      int[] indegree = new int[numCourses];\\n      int[] result = new int[numCourses];\\n      for(int i = 0; i < prerequisites.length; i++){\\n          int preCourses = prerequisites[i][1];\\n          int curCourses = prerequisites[i][0];\\n          adj[preCourses].add(curCourses);\\n          indegree[curCourses]++;\\n      }\\n// to find the course with indegree 0 (which we can take immediately)\\n      Queue<Integer> readyCourses = new LinkedList<Integer>();\\n      for(int i = 0; i < numCourses; i++){\\n          if(indegree[i] == 0){\\n              readyCourses.offer(i);\\n          }\\n      }\\n      int count = 0;\\n// if we take the course with indegree 0, we look up for the courses needing this course as prerequisite and subtract their indegree value by 1\\n      while(!readyCourses.isEmpty()){\\n          int ready = readyCourses.poll();\\n          result[count++] = ready;\\n          for(int nextCourse : adj[ready]){\\n              indegree[nextCourse]--;\\n              if(indegree[nextCourse] == 0){\\n                  readyCourses.offer(nextCourse);\\n              }\\n          }\\n      }\\n// to check if there's a circle-like requirements before return\\n      return count == numCourses ? result : new int[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59423,
                "title": "pure-c-recursive-solution-8ms-beats-100",
                "content": "1. choose a course as start point, DFS.\\n2. if there is a circle, return;\\n3. else record all the points from bottom to up. and set all the points with a `visited` flag.\\n4. when you encounter any of these visited points, just ignoring it, because all the points and their prerequisites have already been recorded.\\n         \\n```\\nbool helper(int **list, int *len, int start, char *flag, char *visited, int *res, int *returnSize) {\\n        flag[start] = 1; \\n\\tint i;\\n\\tfor (i = 0; i < len[start]; i++) {\\n\\t\\tint key = list[start][i];\\n\\t\\tif (visited[key]) continue;\\n\\t\\tif (flag[key]) return false;\\n\\t\\tif (!len[key]) {\\n\\t\\t\\tres[(*returnSize)++] = key;\\n\\t\\t\\tvisited[key] = 1;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (!helper(list, len, key, flag, visited, res, returnSize)) return false;\\n\\t}\\n\\tflag[start] = 0;  // backtracing\\n\\tvisited[start] = 1;\\n\\tres[(*returnSize)++] = start;\\n\\treturn true;\\n}\\n\\nint* findOrder(int numCourses, int** prerequisites, int prerequisitesRowSize, int prerequisitesColSize, int* returnSize) {\\n\\tif (numCourses < 1) return 0;\\n\\tint *res = malloc(numCourses * sizeof(int));\\n\\t*returnSize = 0;\\n\\tint **list = calloc(numCourses, sizeof(int *));\\n\\tint *len = calloc(numCourses, sizeof(int));\\n\\tint i;\\n\\tfor (i = 0; i < prerequisitesRowSize; i++) {\\n\\t\\tint left = prerequisites[i][0];\\n\\t\\tint right = prerequisites[i][1];\\n\\t\\tlen[left]++;\\n\\t\\tlist[left] = realloc(list[left], len[left] * sizeof(int));\\n\\t\\tlist[left][len[left] - 1] = right;\\n\\t}\\n\\n\\tchar *flag = calloc(numCourses, 1);  //for single traversal from a start point.\\n\\tchar *visited = calloc(numCourses, 1); //for all traversal.\\n\\tfor (i = 0; i < numCourses; i++) {\\n\\t\\tif (visited[i]) continue; \\n\\t\\tif (!len[i]) {\\n\\t\\t\\tres[(*returnSize)++] = i;\\n\\t\\t\\tvisited[i] = 1;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (!helper(list, len, i, flag, visited, res, returnSize)) {\\n\\t\\t\\t*returnSize = 0;\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool helper(int **list, int *len, int start, char *flag, char *visited, int *res, int *returnSize) {\\n        flag[start] = 1; \\n\\tint i;\\n\\tfor (i = 0; i < len[start]; i++) {\\n\\t\\tint key = list[start][i];\\n\\t\\tif (visited[key]) continue;\\n\\t\\tif (flag[key]) return false;\\n\\t\\tif (!len[key]) {\\n\\t\\t\\tres[(*returnSize)++] = key;\\n\\t\\t\\tvisited[key] = 1;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (!helper(list, len, key, flag, visited, res, returnSize)) return false;\\n\\t}\\n\\tflag[start] = 0;  // backtracing\\n\\tvisited[start] = 1;\\n\\tres[(*returnSize)++] = start;\\n\\treturn true;\\n}\\n\\nint* findOrder(int numCourses, int** prerequisites, int prerequisitesRowSize, int prerequisitesColSize, int* returnSize) {\\n\\tif (numCourses < 1) return 0;\\n\\tint *res = malloc(numCourses * sizeof(int));\\n\\t*returnSize = 0;\\n\\tint **list = calloc(numCourses, sizeof(int *));\\n\\tint *len = calloc(numCourses, sizeof(int));\\n\\tint i;\\n\\tfor (i = 0; i < prerequisitesRowSize; i++) {\\n\\t\\tint left = prerequisites[i][0];\\n\\t\\tint right = prerequisites[i][1];\\n\\t\\tlen[left]++;\\n\\t\\tlist[left] = realloc(list[left], len[left] * sizeof(int));\\n\\t\\tlist[left][len[left] - 1] = right;\\n\\t}\\n\\n\\tchar *flag = calloc(numCourses, 1);  //for single traversal from a start point.\\n\\tchar *visited = calloc(numCourses, 1); //for all traversal.\\n\\tfor (i = 0; i < numCourses; i++) {\\n\\t\\tif (visited[i]) continue; \\n\\t\\tif (!len[i]) {\\n\\t\\t\\tres[(*returnSize)++] = i;\\n\\t\\t\\tvisited[i] = 1;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (!helper(list, len, i, flag, visited, res, returnSize)) {\\n\\t\\t\\t*returnSize = 0;\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704398,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n        for(auto it:prerequisites){\\n            adj[it[1]].push_back(it[0]);\\n            indegree[it[0]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        vector<int> topo;\\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            topo.push_back(it);\\n            for(auto node:adj[it]){\\n                indegree[node]--;\\n                if(indegree[node] == 0)\\n                    q.push(node);\\n            }\\n        }\\n        if(topo.size() == n)\\n            return topo;\\n        return {};\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n        for(auto it:prerequisites){\\n            adj[it[1]].push_back(it[0]);\\n            indegree[it[0]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        vector<int> topo;\\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            topo.push_back(it);\\n            for(auto node:adj[it]){\\n                indegree[node]--;\\n                if(indegree[node] == 0)\\n                    q.push(node);\\n            }\\n        }\\n        if(topo.size() == n)\\n            return topo;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589844,
                "title": "i-had-provided-you-the-easiest-solution-using-topology-sort",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<vector<int>> adj(numCourses);\\n        for (auto it : prerequisites) {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<int> indegree(numCourses, 0);\\n        for (int i = 0; i < numCourses; i++) {\\n            for (int it : adj[i]) {\\n                indegree[it]++;\\n            }\\n        }\\n        \\n        queue<int> pq;\\n        for (int i = 0; i < numCourses; i++) {\\n            if (indegree[i] == 0) {\\n                pq.push(i);\\n            }\\n        }\\n        \\n        vector<int> topo;\\n        while (!pq.empty()) {\\n            int curr = pq.front();\\n            topo.push_back(curr);\\n            pq.pop();\\n            \\n            for (int it : adj[curr]) {\\n                indegree[it]--;\\n                if (indegree[it] == 0) {\\n                    pq.push(it);\\n                }\\n            }\\n        }\\n        \\n        if (topo.size() != numCourses) {\\n            return {}; // Return empty array if there is a cycle\\n        }\\n        \\n        return topo; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<vector<int>> adj(numCourses);\\n        for (auto it : prerequisites) {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<int> indegree(numCourses, 0);\\n        for (int i = 0; i < numCourses; i++) {\\n            for (int it : adj[i]) {\\n                indegree[it]++;\\n            }\\n        }\\n        \\n        queue<int> pq;\\n        for (int i = 0; i < numCourses; i++) {\\n            if (indegree[i] == 0) {\\n                pq.push(i);\\n            }\\n        }\\n        \\n        vector<int> topo;\\n        while (!pq.empty()) {\\n            int curr = pq.front();\\n            topo.push_back(curr);\\n            pq.pop();\\n            \\n            for (int it : adj[curr]) {\\n                indegree[it]--;\\n                if (indegree[it] == 0) {\\n                    pq.push(it);\\n                }\\n            }\\n        }\\n        \\n        if (topo.size() != numCourses) {\\n            return {}; // Return empty array if there is a cycle\\n        }\\n        \\n        return topo; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542870,
                "title": "python-simple-and-clean-beats-90-89",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n# Intuition\\nThe problem of finding the order of courses to finish all courses can be modeled as a graph problem. Each course can be represented as a node in the graph, and the prerequisites can be represented as directed edges between the nodes. The problem then becomes one of finding a topological ordering of the nodes in the graph.\\n\\n# Approach\\n1. Initialize an empty list `toposort` to store the topological ordering of the nodes.\\n2. Create an adjacency list `AList` to represent the graph and a dictionary `indegree` to keep track of the indegree of each node.\\n3. For each edge in the prerequisites, add an edge from `bi` to `ai` in the adjacency list and increment the indegree of node `ai`.\\n4. Initialize a queue and add all nodes with indegree 0 to it.\\n5. While the queue is not empty, remove the first node from the queue and add it to `toposort`.\\n6. For each neighbor of the removed node, decrement its indegree by 1. If its indegree becomes 0, add it to the queue.\\n7. If the length of `toposort` is equal to `numCourses`, return `toposort`. Otherwise, return an empty array because it is impossible to finish all courses.\\n\\n# Complexity\\n- Time complexity: $$O(n + e)$$ where $$n$$ is the number of courses and $$e$$ is the number of prerequisites.\\n- Space complexity: $$O(n + e)$$ where $$n$$ is the number of courses and $$e$$ is the number of prerequisites.\\n\\n# Code\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, p: List[List[int]]) -> List[int]:\\n        toposort = []\\n        queue = deque()\\n        AList = defaultdict(list)\\n        indegree = defaultdict(lambda:0)\\n        for edge in p:\\n            indegree[edge[0]]+=1\\n            AList[edge[1]].append(edge[0])\\n        for i in range(numCourses):\\n            if indegree[i]==0:\\n                queue.append(i)\\n        while len(queue)>0:\\n            curr = queue.popleft()\\n            toposort.append(curr)\\n            for nodes in AList[curr]:\\n                indegree[nodes]-=1\\n                if indegree[nodes]==0:\\n                    queue.append(nodes)\\n        return toposort if len(toposort)==numCourses else []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, p: List[List[int]]) -> List[int]:\\n        toposort = []\\n        queue = deque()\\n        AList = defaultdict(list)\\n        indegree = defaultdict(lambda:0)\\n        for edge in p:\\n            indegree[edge[0]]+=1\\n            AList[edge[1]].append(edge[0])\\n        for i in range(numCourses):\\n            if indegree[i]==0:\\n                queue.append(i)\\n        while len(queue)>0:\\n            curr = queue.popleft()\\n            toposort.append(curr)\\n            for nodes in AList[curr]:\\n                indegree[nodes]-=1\\n                if indegree[nodes]==0:\\n                    queue.append(nodes)\\n        return toposort if len(toposort)==numCourses else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469846,
                "title": "topological-sorting-python",
                "content": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        dic={i:[] for i in range(numCourses)}\\n        for crs,pre in prerequisites:\\n            dic[crs].append(pre)\\n        output=[]\\n        visit,cycle=set(),set()\\n        def dfs(crs):\\n            if crs in cycle:\\n                return False\\n            if crs in visit:\\n                return True\\n            cycle.add(crs)\\n            for pre in dic[crs]:\\n                if dfs(pre)==False:\\n                    return False\\n            cycle.remove(crs)\\n            visit.add(crs)\\n            output.append(crs)\\n            return True\\n        for c in range(numCourses):\\n            if dfs(c)==False:\\n                return []\\n        return output\\n   ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        dic={i:[] for i in range(numCourses)}\\n        for crs,pre in prerequisites:\\n            dic[crs].append(pre)\\n        output=[]\\n        visit,cycle=set(),set()\\n        def dfs(crs):\\n            if crs in cycle:\\n                return False\\n            if crs in visit:\\n                return True\\n            cycle.add(crs)\\n            for pre in dic[crs]:\\n                if dfs(pre)==False:\\n                    return False\\n            cycle.remove(crs)\\n            visit.add(crs)\\n            output.append(crs)\\n            return True\\n        for c in range(numCourses):\\n            if dfs(c)==False:\\n                return []\\n        return output\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 3468058,
                "title": "swift-solution-topological-sort-beats-92-9",
                "content": "```\\nfunc findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\\n      var inDegreesArr = Array(repeating: 0, count: numCourses)\\n      var adjDict = [Int: [Int]]()\\n      \\n      for prereqPair in prerequisites {\\n          inDegreesArr[prereqPair[0]] += 1\\n          adjDict[prereqPair[1], default: []].append(prereqPair[0])\\n      }\\n      \\n      var zeroIndegreeQueue = [Int]()\\n      for courseNumber in 0..<numCourses {\\n          if inDegreesArr[courseNumber] == 0 {\\n              zeroIndegreeQueue.append(courseNumber)\\n          }\\n      }\\n      \\n      var topologicallySortedCourses = [Int]()\\n      while !zeroIndegreeQueue.isEmpty {\\n          let prereqCourse = zeroIndegreeQueue.removeFirst()\\n          topologicallySortedCourses.append(prereqCourse)\\n          \\n          for course in adjDict[prereqCourse] ?? [] {\\n              inDegreesArr[course] -= 1\\n              if inDegreesArr[course] == 0 {\\n                  zeroIndegreeQueue.append(course)\\n              }\\n          }\\n      }\\n      return (topologicallySortedCourses.count == numCourses) ? topologicallySortedCourses : []\\n  }\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\\n      var inDegreesArr = Array(repeating: 0, count: numCourses)\\n      var adjDict = [Int: [Int]]()\\n      \\n      for prereqPair in prerequisites {\\n          inDegreesArr[prereqPair[0]] += 1\\n          adjDict[prereqPair[1], default: []].append(prereqPair[0])\\n      }\\n      \\n      var zeroIndegreeQueue = [Int]()\\n      for courseNumber in 0..<numCourses {\\n          if inDegreesArr[courseNumber] == 0 {\\n              zeroIndegreeQueue.append(courseNumber)\\n          }\\n      }\\n      \\n      var topologicallySortedCourses = [Int]()\\n      while !zeroIndegreeQueue.isEmpty {\\n          let prereqCourse = zeroIndegreeQueue.removeFirst()\\n          topologicallySortedCourses.append(prereqCourse)\\n          \\n          for course in adjDict[prereqCourse] ?? [] {\\n              inDegreesArr[course] -= 1\\n              if inDegreesArr[course] == 0 {\\n                  zeroIndegreeQueue.append(course)\\n              }\\n          }\\n      }\\n      return (topologicallySortedCourses.count == numCourses) ? topologicallySortedCourses : []\\n  }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3333839,
                "title": "python-solution-using-topological-sort",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        prereq = {c:[] for c in range(numCourses)}\\n        for crs, pre in prerequisites:\\n            prereq[crs].append(pre)\\n        \\n        output = []\\n        visit, cycle = set(), set()\\n        def dfs(crs):\\n            if crs in cycle:\\n                return False\\n            if crs in visit:\\n                return True\\n            \\n            cycle.add(crs)\\n            for pre in prereq[crs]:\\n                if dfs(pre)== False:\\n                    return False\\n            cycle.remove(crs)\\n            visit.add(crs)\\n            output.append(crs)\\n            return True\\n        for i in range(numCourses):\\n            if dfs(i) == False:\\n                return []\\n        return output\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        prereq = {c:[] for c in range(numCourses)}\\n        for crs, pre in prerequisites:\\n            prereq[crs].append(pre)\\n        \\n        output = []\\n        visit, cycle = set(), set()\\n        def dfs(crs):\\n            if crs in cycle:\\n                return False\\n            if crs in visit:\\n                return True\\n            \\n            cycle.add(crs)\\n            for pre in prereq[crs]:\\n                if dfs(pre)== False:\\n                    return False\\n            cycle.remove(crs)\\n            visit.add(crs)\\n            output.append(crs)\\n            return True\\n        for i in range(numCourses):\\n            if dfs(i) == False:\\n                return []\\n        return output\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136324,
                "title": "java-kahn-s-algorithm-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList < ArrayList < Integer >>adj=new ArrayList<>();\\n\\n        for(int i=0;i<=numCourses;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<prerequisites.length;i++){\\n            adj.get(prerequisites[i][1]).add(prerequisites[i][0]);\\n        }\\n\\n\\n        Queue<Integer>q=new LinkedList<>();\\n        int indegree[]=new int[numCourses];\\n        \\n        for(int i=0;i<numCourses;i++){\\n            for(int e:adj.get(i)){\\n                indegree[e]++;\\n            }\\n        }\\n        \\n        for(int i=0;i<numCourses;i++){\\n            if(indegree[i]==0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        int ans[]=new int[numCourses];\\n        int i=0;\\n        \\n        while(!q.isEmpty()){\\n            int node=q.peek();\\n            q.poll();\\n            ans[i++]=node;\\n            \\n            for(int e:adj.get(node)){\\n                indegree[e]--;\\n                if(indegree[e]==0) q.add(e);\\n            }\\n        }\\n        if(i==numCourses) return ans;\\n        int arr[]={};\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        ArrayList < ArrayList < Integer >>adj=new ArrayList<>();\\n\\n        for(int i=0;i<=numCourses;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<prerequisites.length;i++){\\n            adj.get(prerequisites[i][1]).add(prerequisites[i][0]);\\n        }\\n\\n\\n        Queue<Integer>q=new LinkedList<>();\\n        int indegree[]=new int[numCourses];\\n        \\n        for(int i=0;i<numCourses;i++){\\n            for(int e:adj.get(i)){\\n                indegree[e]++;\\n            }\\n        }\\n        \\n        for(int i=0;i<numCourses;i++){\\n            if(indegree[i]==0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        int ans[]=new int[numCourses];\\n        int i=0;\\n        \\n        while(!q.isEmpty()){\\n            int node=q.peek();\\n            q.poll();\\n            ans[i++]=node;\\n            \\n            for(int e:adj.get(node)){\\n                indegree[e]--;\\n                if(indegree[e]==0) q.add(e);\\n            }\\n        }\\n        if(i==numCourses) return ans;\\n        int arr[]={};\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136253,
                "title": "c-striver-toposort",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tvector<int> findOrder(int V, vector<vector<int>> prerequisites)\\n\\t{\\n\\t\\tvector<int> adj[V];\\n\\t\\tfor (auto it : prerequisites) {\\n\\t\\t\\tadj[it[1]].push_back(it[0]);\\n\\t\\t}\\n\\t\\tvector<int> indegree(V , 0);\\n\\t\\tfor (int i = 0; i < V; i++) {\\n\\t\\t\\tfor (auto it : adj[i]) {\\n\\t\\t\\t\\tindegree[it]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tqueue<int> q;\\n\\t\\tfor (int i = 0; i < V; i++) {\\n\\t\\t\\tif (indegree[i] == 0) {\\n\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<int> topo;\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tint node = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\ttopo.push_back(node);\\n\\t\\t\\t// node is in your topo sort\\n\\t\\t\\t// so please remove it from the indegree\\n\\n\\t\\t\\tfor (auto it : adj[node]) {\\n\\t\\t\\t\\tindegree[it]--;\\n\\t\\t\\t\\tif (indegree[it] == 0) q.push(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (topo.size() == V) return topo;\\n\\t\\treturn {};\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> findOrder(int V, vector<vector<int>> prerequisites)\\n\\t{\\n\\t\\tvector<int> adj[V];\\n\\t\\tfor (auto it : prerequisites) {\\n\\t\\t\\tadj[it[1]].push_back(it[0]);\\n\\t\\t}\\n\\t\\tvector<int> indegree(V , 0);\\n\\t\\tfor (int i = 0; i < V; i++) {\\n\\t\\t\\tfor (auto it : adj[i]) {\\n\\t\\t\\t\\tindegree[it]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tqueue<int> q;\\n\\t\\tfor (int i = 0; i < V; i++) {\\n\\t\\t\\tif (indegree[i] == 0) {\\n\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<int> topo;\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tint node = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\ttopo.push_back(node);\\n\\t\\t\\t// node is in your topo sort\\n\\t\\t\\t// so please remove it from the indegree\\n\\n\\t\\t\\tfor (auto it : adj[node]) {\\n\\t\\t\\t\\tindegree[it]--;\\n\\t\\t\\t\\tif (indegree[it] == 0) q.push(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (topo.size() == V) return topo;\\n\\t\\treturn {};\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967250,
                "title": "c-striver-s-easy-approach-easy-clean",
                "content": "![image](https://assets.leetcode.com/users/images/b7e0daab-d4eb-404e-84a0-c8b8eaa9cccd_1672318597.4229276.png)\\n\\n***Logic-> No logic! Very basic question of Topological sorting.Just apply it!***\\n\\n**T->O(n+e) [For directed graph, same as BFS Traversal] && S->O(n)**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> findOrder(int n,vector<vector<int>>& pre) {\\n\\t\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\t\\tfor(auto i:pre) adj[i[1]].push_back(i[0]);\\n\\t\\t\\t\\tvector<int> topo;\\n\\t\\t\\t\\tvector<int> in(n,0);\\n\\t\\t\\t\\tqueue<int>q;\\n\\t\\t\\t\\tfor(int node=0;node<n;node++){\\n\\t\\t\\t\\t\\tfor(auto j:adj[node]) in[j]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int node=0;node<n;node++){\\n\\t\\t\\t\\t\\tif(!in[node]) q.push(node);  \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint node=q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\ttopo.push_back(node);\\n\\t\\t\\t\\t\\tfor(auto i:adj[node]){\\n\\t\\t\\t\\t\\t\\tin[i]--;\\n\\t\\t\\t\\t\\t\\tif(!in[i]) q.push(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(topo.size()!=n) return {};\\n\\t\\t\\t\\treturn topo;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> findOrder(int n,vector<vector<int>>& pre) {\\n\\t\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\t\\tfor(auto i:pre) adj[i[1]].push_back(i[0]);\\n\\t\\t\\t\\tvector<int> topo;\\n\\t\\t\\t\\tvector<int> in(n,0);\\n\\t\\t\\t\\tqueue<int>q;\\n\\t\\t\\t\\tfor(int node=0;node<n;node++){\\n\\t\\t\\t\\t\\tfor(auto j:adj[node]) in[j]++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2509569,
                "title": "leetcode-the-hard-way-bfs-topological-sort-with-template-explained",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\nAlso exact same solution as [207. Course Schedule](https://leetcode.com/problems/course-schedule/discuss/2509551/LeetCode-The-Hard-Way-BFS-Topological-Sort-with-Template-Explained).\\n\\n---\\n\\n```cpp\\n// for topological sorting tutorial,\\n// see https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/topological-sorting\\nstruct TopologicalSort {\\n    int n;\\n    vector<int> indegree;\\n    vector<int> orders;\\n    vector<vector<int>> G;\\n    bool isTopologicalSorted = false;\\n\\n    TopologicalSort(vector<vector<int>>& g, vector<int>& in) {\\n        G = g;\\n        n = (int) G.size();\\n        indegree = in;\\n\\n        int res = 0;\\n        queue<int> q;\\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()) {\\n            auto u = q.front(); q.pop();\\n            orders.push_back(u);\\n            for(auto v : G[u]) {\\n                if(--indegree[v] == 0) {\\n                    q.push(v);\\n                }\\n            }\\n            res++;\\n        }\\n        isTopologicalSorted = res == n;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        // define the graph\\n        vector<vector<int>> g(n);\\n        // define indegree\\n        vector<int> indegree(n);\\n        // build the graph\\n        for(auto p : prerequisites) {\\n            // we have to take p[1] in order to take p[0]\\n            g[p[1]].push_back(p[0]);\\n            // increase indegree by 1 for p[0]\\n            indegree[p[0]]++;\\n        }\\n        // init topological sort\\n        TopologicalSort ts(g, indegree);\\n        // we can finish all courses only if we can topologically sort\\n        // hence, return an empty array if it cannot be sorted\\n        if (!ts.isTopologicalSorted) return {};\\n        // else return the order\\n        return ts.orders;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```cpp\\n// for topological sorting tutorial,\\n// see https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/topological-sorting\\nstruct TopologicalSort {\\n    int n;\\n    vector<int> indegree;\\n    vector<int> orders;\\n    vector<vector<int>> G;\\n    bool isTopologicalSorted = false;\\n\\n    TopologicalSort(vector<vector<int>>& g, vector<int>& in) {\\n        G = g;\\n        n = (int) G.size();\\n        indegree = in;\\n\\n        int res = 0;\\n        queue<int> q;\\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()) {\\n            auto u = q.front(); q.pop();\\n            orders.push_back(u);\\n            for(auto v : G[u]) {\\n                if(--indegree[v] == 0) {\\n                    q.push(v);\\n                }\\n            }\\n            res++;\\n        }\\n        isTopologicalSorted = res == n;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        // define the graph\\n        vector<vector<int>> g(n);\\n        // define indegree\\n        vector<int> indegree(n);\\n        // build the graph\\n        for(auto p : prerequisites) {\\n            // we have to take p[1] in order to take p[0]\\n            g[p[1]].push_back(p[0]);\\n            // increase indegree by 1 for p[0]\\n            indegree[p[0]]++;\\n        }\\n        // init topological sort\\n        TopologicalSort ts(g, indegree);\\n        // we can finish all courses only if we can topologically sort\\n        // hence, return an empty array if it cannot be sorted\\n        if (!ts.isTopologicalSorted) return {};\\n        // else return the order\\n        return ts.orders;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467417,
                "title": "python-solution-using-topological-sort-bfs-approach",
                "content": "```\\ndef findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        # build the graph\\n        visited = [0] * numCourses\\n        graph = defaultdict(list)\\n        for courses in prerequisites:\\n            graph[courses[1]].append(courses[0])\\n            visited[courses[0]] += 1\\n            \\n        # add courses that doesn\\'t have any prerequisite to the queue\\n        queue = deque()\\n        for i in range(numCourses):\\n            if visited[i] == 0:\\n                queue.append(i)\\n        \\n        # topological sort algorithm using bfs approach\\n        course_order = []\\n        while queue:\\n            course = queue.popleft()\\n            course_order.append(course)\\n            for prerequisite in graph[course]:\\n                visited[prerequisite] -= 1\\n                if visited[prerequisite] == 0:\\n                    queue.append(prerequisite)\\n                    \\n        return course_order if len(course_order) == numCourses else []",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\ndef findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        # build the graph\\n        visited = [0] * numCourses\\n        graph = defaultdict(list)\\n        for courses in prerequisites:\\n            graph[courses[1]].append(courses[0])\\n            visited[courses[0]] += 1\\n            \\n        # add courses that doesn\\'t have any prerequisite to the queue\\n        queue = deque()\\n        for i in range(numCourses):\\n            if visited[i] == 0:\\n                queue.append(i)\\n        \\n        # topological sort algorithm using bfs approach\\n        course_order = []\\n        while queue:\\n            course = queue.popleft()\\n            course_order.append(course)\\n            for prerequisite in graph[course]:\\n                visited[prerequisite] -= 1\\n                if visited[prerequisite] == 0:\\n                    queue.append(prerequisite)\\n                    \\n        return course_order if len(course_order) == numCourses else []",
                "codeTag": "Python3"
            },
            {
                "id": 2335321,
                "title": "c-topological-sort-dfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    void topologicalSort(vector<int>adj[],vector<bool>& visited, stack<int>& st, int node){\\n        visited[node]=true;\\n        for(auto it: adj[node]){ //dfs \\n            if(!visited[it]) topologicalSort(adj,visited,st,it); \\n        }\\n        st.push(node); //push node into stack after its dfs call is over\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++){ //creating adjacency list\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]); \\n        }\\n        vector<bool>visited(numCourses, false);\\n        stack<int> st;\\n        unordered_map<int,int> position;\\n        for(int i=0;i<numCourses;i++){\\n            if(!visited[i]) topologicalSort(adj,visited,st,i); \\n        }\\n        vector<int> ans;\\n        int idx=0;\\n        while(!st.empty()){\\n            ans.push_back(st.top()); //storing ordering in ans vector\\n            position[st.top()]=idx; //indexing all nodes in map to check if ordering is possible\\n            idx++;\\n            st.pop();\\n        }\\n        for(int i=0;i<numCourses;i++){\\n            for(auto it: adj[i]){\\n                if(position[i]>position[it]) return {}; //if ordering not possible\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you find this useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void topologicalSort(vector<int>adj[],vector<bool>& visited, stack<int>& st, int node){\\n        visited[node]=true;\\n        for(auto it: adj[node]){ //dfs \\n            if(!visited[it]) topologicalSort(adj,visited,st,it); \\n        }\\n        st.push(node); //push node into stack after its dfs call is over\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++){ //creating adjacency list\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]); \\n        }\\n        vector<bool>visited(numCourses, false);\\n        stack<int> st;\\n        unordered_map<int,int> position;\\n        for(int i=0;i<numCourses;i++){\\n            if(!visited[i]) topologicalSort(adj,visited,st,i); \\n        }\\n        vector<int> ans;\\n        int idx=0;\\n        while(!st.empty()){\\n            ans.push_back(st.top()); //storing ordering in ans vector\\n            position[st.top()]=idx; //indexing all nodes in map to check if ordering is possible\\n            idx++;\\n            st.pop();\\n        }\\n        for(int i=0;i<numCourses;i++){\\n            for(auto it: adj[i]){\\n                if(position[i]>position[it]) return {}; //if ordering not possible\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207652,
                "title": "c-dfs-topological-sort-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&pre,vector<bool>&visi,vector<bool>& proc,int val){\\n        if(proc[val])\\n            return false;\\n        if(visi[val])\\n            return true;\\n        \\n        visi[val]=true;\\n        \\n        for(int j=0;j<pre[val].size();j++){\\n            if(dfs(pre,visi,proc,pre[val][j]))\\n                return true;\\n        }\\n        visi[val]=false;\\n        return false;\\n    }\\n    \\n    bool cycleDetect(vector<vector<int>>&pre,vector<bool>&visi,int V){\\n        vector<bool> proc(V,false);\\n        for(int i=0;i<V;i++){       \\n            if(dfs(pre,visi,proc,i))\\n                return true;\\n            proc[i]=true;\\n        }\\n        return false;\\n    }\\n    \\n    \\n    void toposort(vector<vector<int>> &temp,int val,stack<int>&st,vector<bool>&visited){\\n        for(int i=0;i<temp[val].size();i++){\\n            if(!visited[temp[val][i]])\\n                toposort(temp,temp[val][i],st,visited);\\n        }\\n        visited[val]=true;\\n        st.push(val);\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        \\n        vector<bool> visited(numCourses,false);\\n        vector<vector<int>> temp(numCourses);\\n        vector<int> ans;\\n        for(int i=0;i<prerequisites.size();i++){\\n            temp[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        }\\n        \\n        //if the course are related in cyclic then there will be no sequence of course picking as they all depened on each other.\\n        if(cycleDetect(temp,visited,numCourses))\\n            return ans;\\n        \\n        \\n        // Here we use topological sort as it give most independent course first and so on........\\n        stack<int> st;\\n        for(int i=0;i<numCourses;i++){\\n            if(!visited[i]){\\n                toposort(temp,i,st,visited);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&pre,vector<bool>&visi,vector<bool>& proc,int val){\\n        if(proc[val])\\n            return false;\\n        if(visi[val])\\n            return true;\\n        \\n        visi[val]=true;\\n        \\n        for(int j=0;j<pre[val].size();j++){\\n            if(dfs(pre,visi,proc,pre[val][j]))\\n                return true;\\n        }\\n        visi[val]=false;\\n        return false;\\n    }\\n    \\n    bool cycleDetect(vector<vector<int>>&pre,vector<bool>&visi,int V){\\n        vector<bool> proc(V,false);\\n        for(int i=0;i<V;i++){       \\n            if(dfs(pre,visi,proc,i))\\n                return true;\\n            proc[i]=true;\\n        }\\n        return false;\\n    }\\n    \\n    \\n    void toposort(vector<vector<int>> &temp,int val,stack<int>&st,vector<bool>&visited){\\n        for(int i=0;i<temp[val].size();i++){\\n            if(!visited[temp[val][i]])\\n                toposort(temp,temp[val][i],st,visited);\\n        }\\n        visited[val]=true;\\n        st.push(val);\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        \\n        vector<bool> visited(numCourses,false);\\n        vector<vector<int>> temp(numCourses);\\n        vector<int> ans;\\n        for(int i=0;i<prerequisites.size();i++){\\n            temp[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        }\\n        \\n        //if the course are related in cyclic then there will be no sequence of course picking as they all depened on each other.\\n        if(cycleDetect(temp,visited,numCourses))\\n            return ans;\\n        \\n        \\n        // Here we use topological sort as it give most independent course first and so on........\\n        stack<int> st;\\n        for(int i=0;i<numCourses;i++){\\n            if(!visited[i]){\\n                toposort(temp,i,st,visited);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755757,
                "title": "getting-tle-using-kahn-s-algorithm-can-anyone-help",
                "content": "I have solved this problem using Kahn\\'s algorithm but getting TLE on test case 42/44. My solution is mostly similar to the the provided solution no. 2 by LeetCode (again it is Kahn\\'s algo). Can you please tell me how can I optimise this solution.\\n```\\nclass Solution {\\n    typedef vector<vector<int>> graph;\\n    \\n    graph buildGraph(int N, graph &prerequisites){\\n        graph g(N);\\n        for(int i=0; i<N; i++){\\n            for(auto edge : prerequisites)\\n                g[edge[1]].push_back(edge[0]);\\n        }\\n        return g;\\n    }\\n    \\n    vector<int> computeInDegree(int N, graph &g){\\n        vector<int>inDegree(N, 0);\\n        for(int u=0; u<N; u++){\\n            for(auto v : g[u]){\\n                inDegree[v]++;\\n            }\\n        }\\n        return inDegree;\\n    }\\n    \\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        \\n        vector<int>inDegree, topoOrder;\\n        \\n        graph g = buildGraph(numCourses, prerequisites);\\n        inDegree = computeInDegree(numCourses, g);\\n        \\n        queue<int>q;\\n        for(int i=0; i<numCourses; i++){\\n            if(inDegree[i]==0) q.push(i);\\n        }\\n        \\n        int cntNodes = 0;\\n        while(!q.empty()){\\n            int curNode = q.front();\\n            q.pop();\\n            \\n            cntNodes++;\\n            if(cntNodes > numCourses) return {};\\n            topoOrder.push_back(curNode);\\n            \\n            for(auto to : g[curNode]){\\n                inDegree[to]--;\\n                if(inDegree[to]==0) \\n                    q.push(to);\\n            }\\n        }\\n        \\n        if(cntNodes==numCourses)\\n            return topoOrder;\\n        return {};\\n    }\\n};\\n```\\nthank you in advance!",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    typedef vector<vector<int>> graph;\\n    \\n    graph buildGraph(int N, graph &prerequisites){\\n        graph g(N);\\n        for(int i=0; i<N; i++){\\n            for(auto edge : prerequisites)\\n                g[edge[1]].push_back(edge[0]);\\n        }\\n        return g;\\n    }\\n    \\n    vector<int> computeInDegree(int N, graph &g){\\n        vector<int>inDegree(N, 0);\\n        for(int u=0; u<N; u++){\\n            for(auto v : g[u]){\\n                inDegree[v]++;\\n            }\\n        }\\n        return inDegree;\\n    }\\n    \\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        \\n        vector<int>inDegree, topoOrder;\\n        \\n        graph g = buildGraph(numCourses, prerequisites);\\n        inDegree = computeInDegree(numCourses, g);\\n        \\n        queue<int>q;\\n        for(int i=0; i<numCourses; i++){\\n            if(inDegree[i]==0) q.push(i);\\n        }\\n        \\n        int cntNodes = 0;\\n        while(!q.empty()){\\n            int curNode = q.front();\\n            q.pop();\\n            \\n            cntNodes++;\\n            if(cntNodes > numCourses) return {};\\n            topoOrder.push_back(curNode);\\n            \\n            for(auto to : g[curNode]){\\n                inDegree[to]--;\\n                if(inDegree[to]==0) \\n                    q.push(to);\\n            }\\n        }\\n        \\n        if(cntNodes==numCourses)\\n            return topoOrder;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642812,
                "title": "c-simple-and-clean-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCycle(vector<vector<int>>& graph,vector<int> &colors, vector<int> &res, int i) {\\n        colors[i] = 1;\\n        \\n        for (auto neighbor : graph[i]) {\\n            if(colors[neighbor] == 1) return true;\\n            if(colors[neighbor] == 0) {\\n                if (isCycle(graph, colors, res,neighbor)) return true;\\n            }\\n        }\\n        \\n        colors[i] = 2;\\n        res.push_back(i);\\n        return false;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> colors(numCourses, 0), res;\\n        vector<vector<int>> graph(numCourses);\\n        \\n        // build graph\\n        for (auto pre : prerequisites) {\\n            graph[pre[0]].push_back(pre[1]);\\n        }\\n        \\n        for (int i = 0; i < numCourses; i++) {\\n            if (!colors[i]) {\\n                if (isCycle(graph, colors, res, i)) return {};\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCycle(vector<vector<int>>& graph,vector<int> &colors, vector<int> &res, int i) {\\n        colors[i] = 1;\\n        \\n        for (auto neighbor : graph[i]) {\\n            if(colors[neighbor] == 1) return true;\\n            if(colors[neighbor] == 0) {\\n                if (isCycle(graph, colors, res,neighbor)) return true;\\n            }\\n        }\\n        \\n        colors[i] = 2;\\n        res.push_back(i);\\n        return false;\\n    }\\n    \\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> colors(numCourses, 0), res;\\n        vector<vector<int>> graph(numCourses);\\n        \\n        // build graph\\n        for (auto pre : prerequisites) {\\n            graph[pre[0]].push_back(pre[1]);\\n        }\\n        \\n        for (int i = 0; i < numCourses; i++) {\\n            if (!colors[i]) {\\n                if (isCycle(graph, colors, res, i)) return {};\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642387,
                "title": "python3-iterative-toposort-explained",
                "content": "Approach this problem in three steps:\\n\\n1. Build an adjacency list\\n2. Do Topological Sort of the courses (iterative)\\n3. Check for cycles. While building the result out of the stack from the TopoSort, we create a dictionary that maps each node to its position in the toposort. Then iterate over the adjacency list to verify whether all parent nodes are located before children. Notice that checking for cycles also can be done during the topological sort which simplifies the algorithm (check the solution).\\n\\nTime: **O(n)** - linear for all scans\\nSpace: **O(n)** - linear for all sets and stacks\\n\\nRuntime: 92 ms, faster than **94.59%** of Python3 online submissions for Course Schedule II.\\nMemory Usage: 15.9 MB, less than **46.39%** of Python3 online submissions for Course Schedule II.\\n\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, pr: List[List[int]]) -> List[int]:\\n\\t\\n        # Build adjacency list\\n        adj = defaultdict(list)\\n        for a, b in prerequisites:\\n            adj[b].append(a)\\n            \\n        # TopoSort\\n        topo = list()\\n        vis = set()\\n        processed = set()\\n        for node in range(numCourses):\\n            if node in vis:\\n                continue\\n                \\n            st = [node]\\n            while st:\\n                cur = st[-1]\\n                vis.add(cur)\\n                \\n                if cur in processed:\\n                    st.pop()\\n                    continue\\n                \\n\\t\\t\\t\\tfor ch in adj[cur]:\\n\\t\\t\\t\\t\\tif not ch in vis:\\n\\t\\t\\t\\t\\t\\tst.append(ch)\\n                    \\n                if cur == st[-1]:\\n                    topo.append(st.pop())\\n                    processed.add(cur)\\n\\n        # Result\\n        res = []\\n        i = 0\\n        pos = dict()\\n        while topo:\\n            node = topo.pop()\\n            pos[node] = i\\n            i += 1\\n            res.append(node)\\n        \\n        # Check for cycles\\n        for parent, children in adj.items():\\n            for child in children:\\n                if pos[parent] > pos[child]:\\n                    return []\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, pr: List[List[int]]) -> List[int]:\\n\\t\\n        # Build adjacency list\\n        adj = defaultdict(list)\\n        for a, b in prerequisites:\\n            adj[b].append(a)\\n            \\n        # TopoSort\\n        topo = list()\\n        vis = set()\\n        processed = set()\\n        for node in range(numCourses):\\n            if node in vis:\\n                continue\\n                \\n            st = [node]\\n            while st:\\n                cur = st[-1]\\n                vis.add(cur)\\n                \\n                if cur in processed:\\n                    st.pop()\\n                    continue\\n                \\n\\t\\t\\t\\tfor ch in adj[cur]:\\n\\t\\t\\t\\t\\tif not ch in vis:\\n\\t\\t\\t\\t\\t\\tst.append(ch)\\n                    \\n                if cur == st[-1]:\\n                    topo.append(st.pop())\\n                    processed.add(cur)\\n\\n        # Result\\n        res = []\\n        i = 0\\n        pos = dict()\\n        while topo:\\n            node = topo.pop()\\n            pos[node] = i\\n            i += 1\\n            res.append(node)\\n        \\n        # Check for cycles\\n        for parent, children in adj.items():\\n            for child in children:\\n                if pos[parent] > pos[child]:\\n                    return []\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466187,
                "title": "python-bfs-topological-sort-solution-time-o-v-e-space-o-v-e",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        map, inDegrees = [set() for i in range(numCourses)], [0]*numCourses\\n        for pre in prerequisites:\\n            map[pre[1]].add(pre[0])\\n            inDegrees[pre[0]] += 1\\n        result, queue = [], deque()\\n        for i in range(numCourses):\\n            if inDegrees[i] == 0:\\n                queue.append(i)\\n        while queue:\\n            current = queue.popleft()\\n            result.append(current)\\n            for i in map[current]:\\n                inDegrees[i] -= 1\\n                if inDegrees[i] == 0:\\n                    queue.append(i)\\n        \\n        for i in range(numCourses):\\n            if inDegrees[i] != 0:\\n                return []\\n        return result;\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        map, inDegrees = [set() for i in range(numCourses)], [0]*numCourses\\n        for pre in prerequisites:\\n            map[pre[1]].add(pre[0])\\n            inDegrees[pre[0]] += 1\\n        result, queue = [], deque()\\n        for i in range(numCourses):\\n            if inDegrees[i] == 0:\\n                queue.append(i)\\n        while queue:\\n            current = queue.popleft()\\n            result.append(current)\\n            for i in map[current]:\\n                inDegrees[i] -= 1\\n                if inDegrees[i] == 0:\\n                    queue.append(i)\\n        \\n        for i in range(numCourses):\\n            if inDegrees[i] != 0:\\n                return []\\n        return result;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367215,
                "title": "c-simple-bfs",
                "content": "Use return array as the queue :)\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& p) {\\n        vector <int> cnt(n, 0), ret;\\n        vector <vector <int>> edge(n); // prerequisite edges\\n        for (auto &z : p) {\\n            int x = z[0], y = z[1];\\n            edge[y].push_back(x); // after taking course \\'y\\' we might want to take course \\'x\\'\\n            cnt[x]++; // indegree up, means there are cnt[x] courses we need to take before taking course \\'x\\'\\n        }\\n        for (int i = 0; i < n; i++)\\n            if (cnt[i] == 0) // every course that doesn\\'t have prerequisites we can add to the queue and take these courses\\n                ret.push_back(i); // put courses we can take into our return array\\n        for (int i = 0; i < ret.size(); i++) // go by the courses we can take\\n            for (auto &x : edge[ret[i]]) // check every other course we might want to take from the current course\\n                if (--cnt[x] == 0) // reduce prerequisite count\\n                    ret.push_back(x);  // add courses to the queue if they don\\'t have any more prerequisites\\n        return ret.size() == n ? ret : vector <int> (); // if \\'ret\\' has \\'n\\' elements means we were able to take all courses, otherwise we couldn\\'t.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& p) {\\n        vector <int> cnt(n, 0), ret;\\n        vector <vector <int>> edge(n); // prerequisite edges\\n        for (auto &z : p) {\\n            int x = z[0], y = z[1];\\n            edge[y].push_back(x); // after taking course \\'y\\' we might want to take course \\'x\\'\\n            cnt[x]++; // indegree up, means there are cnt[x] courses we need to take before taking course \\'x\\'\\n        }\\n        for (int i = 0; i < n; i++)\\n            if (cnt[i] == 0) // every course that doesn\\'t have prerequisites we can add to the queue and take these courses\\n                ret.push_back(i); // put courses we can take into our return array\\n        for (int i = 0; i < ret.size(); i++) // go by the courses we can take\\n            for (auto &x : edge[ret[i]]) // check every other course we might want to take from the current course\\n                if (--cnt[x] == 0) // reduce prerequisite count\\n                    ret.push_back(x);  // add courses to the queue if they don\\'t have any more prerequisites\\n        return ret.size() == n ? ret : vector <int> (); // if \\'ret\\' has \\'n\\' elements means we were able to take all courses, otherwise we couldn\\'t.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302468,
                "title": "c-simple-solution-using-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    //using topological sort\\n    vector<int> findOrder(int n, vector<vector<int>>& preq) {\\n        vector<int> adj[n];\\n        vector<int> indegree(n);    \\n        vector<int> ans;\\n        \\n        for(auto i : preq) {\\n            adj[i[1]].push_back(i[0]);\\n            indegree[i[0]]++;              \\n        }\\n        \\n        queue<int> q;\\n        for(int i = 0; i<n; i++) {\\n            if(indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int node= q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            \\n            for(auto v : adj[node]) {\\n                indegree[v]--;\\n                if(indegree[v] == 0) q.push(v);\\n            }\\n        }\\n        \\n        return ans.size() == n ? ans : vector<int> {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //using topological sort\\n    vector<int> findOrder(int n, vector<vector<int>>& preq) {\\n        vector<int> adj[n];\\n        vector<int> indegree(n);    \\n        vector<int> ans;\\n        \\n        for(auto i : preq) {\\n            adj[i[1]].push_back(i[0]);\\n            indegree[i[0]]++;              \\n        }\\n        \\n        queue<int> q;\\n        for(int i = 0; i<n; i++) {\\n            if(indegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int node= q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            \\n            for(auto v : adj[node]) {\\n                indegree[v]--;\\n                if(indegree[v] == 0) q.push(v);\\n            }\\n        }\\n        \\n        return ans.size() == n ? ans : vector<int> {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270578,
                "title": "js-kahn-s-topological-sort-algorithm",
                "content": "```javascript\\nfunction findOrder(numCourses, prerequisites) {\\n    const adjacencyList = Array(numCourses).fill().map(x => []);\\n    const node2inDegree = new Uint8Array(numCourses);\\n    prerequisites.forEach(([course, prereq]) => {\\n        adjacencyList[prereq].push(course);\\n        node2inDegree[course]++;\\n    });\\n\\n    const order = new Set();\\n    const courses = Object.entries(node2inDegree).reduce((acc, [node, inDegree]) => {\\n        if (inDegree === 0)\\n            acc.push(node);\\n        return acc;\\n    }, []);\\n\\n    while (courses.length) {\\n        const top = courses.pop();\\n        for (const neighbour of adjacencyList[top]) {\\n            if (order.has(neighbour))\\n                return [];\\n            if (--node2inDegree[neighbour] === 0)\\n                courses.push(neighbour);\\n        }\\n        order.add(Number(top));\\n    }\\n\\n    return order.size === numCourses ? Array.from(order) : [];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Topological Sort"
                ],
                "code": "```javascript\\nfunction findOrder(numCourses, prerequisites) {\\n    const adjacencyList = Array(numCourses).fill().map(x => []);\\n    const node2inDegree = new Uint8Array(numCourses);\\n    prerequisites.forEach(([course, prereq]) => {\\n        adjacencyList[prereq].push(course);\\n        node2inDegree[course]++;\\n    });\\n\\n    const order = new Set();\\n    const courses = Object.entries(node2inDegree).reduce((acc, [node, inDegree]) => {\\n        if (inDegree === 0)\\n            acc.push(node);\\n        return acc;\\n    }, []);\\n\\n    while (courses.length) {\\n        const top = courses.pop();\\n        for (const neighbour of adjacencyList[top]) {\\n            if (order.has(neighbour))\\n                return [];\\n            if (--node2inDegree[neighbour] === 0)\\n                courses.push(neighbour);\\n        }\\n        order.add(Number(top));\\n    }\\n\\n    return order.size === numCourses ? Array.from(order) : [];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1247385,
                "title": "java-easy-solution-using-kahn-s-algorithm-bfs",
                "content": "**Please Upvote if you liked this post**\\n\\n```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0;i<numCourses;i++){\\n            map.put(i,new ArrayList<>());\\n        }\\n        int [] indegree = new int[numCourses];\\n        \\n        for(int i = 0;i<prerequisites.length;i++){\\n            map.get(prerequisites[i][1]).add(prerequisites[i][0]);  //for ex in [0,1] to make edge 1->0\\n            indegree[prerequisites[i][0]]++; //indegree of node 0 will be incremented\\n        }\\n        \\n        int topo[] = new int[numCourses];\\n        int count = 0;\\n        Deque<Integer> q = new ArrayDeque<>();\\n        \\n        for(int i = 0;i<indegree.length;i++){\\n            if(indegree[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        int idx = 0;\\n        while(q.size() > 0){\\n            int rem = q.poll();\\n\\t\\t\\tcount++                                    //count will be used to test whether graph is DAG or not\\n            topo[idx++] = rem;\\n            for(int nbr : map.get(rem)){\\n                indegree[nbr]--;\\n                if(indegree[nbr] == 0){\\n                    q.add(nbr);\\n                }\\n            }\\n        }\\n        \\n        return count == numCourses ? topo : new int[]{};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0;i<numCourses;i++){\\n            map.put(i,new ArrayList<>());\\n        }\\n        int [] indegree = new int[numCourses];\\n        \\n        for(int i = 0;i<prerequisites.length;i++){\\n            map.get(prerequisites[i][1]).add(prerequisites[i][0]);  //for ex in [0,1] to make edge 1->0\\n            indegree[prerequisites[i][0]]++; //indegree of node 0 will be incremented\\n        }\\n        \\n        int topo[] = new int[numCourses];\\n        int count = 0;\\n        Deque<Integer> q = new ArrayDeque<>();\\n        \\n        for(int i = 0;i<indegree.length;i++){\\n            if(indegree[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        int idx = 0;\\n        while(q.size() > 0){\\n            int rem = q.poll();\\n\\t\\t\\tcount++                                    //count will be used to test whether graph is DAG or not\\n            topo[idx++] = rem;\\n            for(int nbr : map.get(rem)){\\n                indegree[nbr]--;\\n                if(indegree[nbr] == 0){\\n                    q.add(nbr);\\n                }\\n            }\\n        }\\n        \\n        return count == numCourses ? topo : new int[]{};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214268,
                "title": "c-easy-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        vector<vector<int>> adj(n, vector<int>());\\n        vector<int> degree(n, 0);\\n        for (auto &p: pre) {\\n            adj[p[1]].push_back(p[0]);\\n            degree[p[0]]++;\\n        }\\n        queue<int> q;\\n        vector<int> res;\\n        for (int i = 0; i < n; i++)\\n            if (degree[i] == 0) {\\n                q.push(i);\\n                res.push_back(i);\\n            }\\n        while (!q.empty()) {\\n            int curr = q.front(); q.pop(); n--;\\n            for (auto next: adj[curr])\\n                if (--degree[next] == 0) \\n                {\\n                    q.push(next);\\n                    res.push_back(next);   \\n                }\\n        }\\n        if(n==0)\\n            return res;\\n        else\\n            return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        vector<vector<int>> adj(n, vector<int>());\\n        vector<int> degree(n, 0);\\n        for (auto &p: pre) {\\n            adj[p[1]].push_back(p[0]);\\n            degree[p[0]]++;\\n        }\\n        queue<int> q;\\n        vector<int> res;\\n        for (int i = 0; i < n; i++)\\n            if (degree[i] == 0) {\\n                q.push(i);\\n                res.push_back(i);\\n            }\\n        while (!q.empty()) {\\n            int curr = q.front(); q.pop(); n--;\\n            for (auto next: adj[curr])\\n                if (--degree[next] == 0) \\n                {\\n                    q.push(next);\\n                    res.push_back(next);   \\n                }\\n        }\\n        if(n==0)\\n            return res;\\n        else\\n            return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961954,
                "title": "topological-sort-easy-java-solution",
                "content": "Here we are using Topological Sorting approach.\\nStep 1 : Calculate indegree for each of the nodes.\\nStep 2: The nodes with indegree 0 are added to queue for processing. After a node with 0 degree(say y) is processed it its added to an ans arrays and also  we reduce the degree of the nodes (to which y was the incoming edge) by 1\\nStep 3: In the end we\\'ll check if the total courses is equal to the nodes that we have processed, if they are equal so return the array that we have created by popping the queue elements else return null array.\\n\\n\\n```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int ans[] = new int[numCourses];\\n        int indegree[] = new int[numCourses];\\n        \\n        for(int i=0;i<prerequisites.length;i++)\\n        {\\n            indegree[prerequisites[i][0]]++;\\n        }\\n        \\n        Queue<Integer> bfs = new LinkedList<>();\\n        \\n        for(int i=0;i<numCourses;i++)\\n        {\\n            if(indegree[i] == 0)\\n                bfs.add(i);\\n        }\\n    \\n        int count = bfs.size();\\n        \\n        int j=0;\\n       \\n        while(!bfs.isEmpty())\\n        {\\n             int comp=bfs.poll();\\n            ans[j++]=comp;\\n            for(int i=0;i<prerequisites.length;i++)\\n            {\\n                if(prerequisites[i][1] == comp)\\n                {\\n                    int dependent=prerequisites[i][0];\\n                    indegree[dependent]--;\\n                    \\n                    if(indegree[dependent] == 0)\\n                    {  bfs.add(dependent);\\n                     count++;\\n                    }\\n                }\\n            }\\n        }\\n        return (count == numCourses) ? ans : new int[0];\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        int ans[] = new int[numCourses];\\n        int indegree[] = new int[numCourses];\\n        \\n        for(int i=0;i<prerequisites.length;i++)\\n        {\\n            indegree[prerequisites[i][0]]++;\\n        }\\n        \\n        Queue<Integer> bfs = new LinkedList<>();\\n        \\n        for(int i=0;i<numCourses;i++)\\n        {\\n            if(indegree[i] == 0)\\n                bfs.add(i);\\n        }\\n    \\n        int count = bfs.size();\\n        \\n        int j=0;\\n       \\n        while(!bfs.isEmpty())\\n        {\\n             int comp=bfs.poll();\\n            ans[j++]=comp;\\n            for(int i=0;i<prerequisites.length;i++)\\n            {\\n                if(prerequisites[i][1] == comp)\\n                {\\n                    int dependent=prerequisites[i][0];\\n                    indegree[dependent]--;\\n                    \\n                    if(indegree[dependent] == 0)\\n                    {  bfs.add(dependent);\\n                     count++;\\n                    }\\n                }\\n            }\\n        }\\n        return (count == numCourses) ? ans : new int[0];\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805495,
                "title": "faster-than-95-less-space-that-80-python-topological-sort-indegree-queue",
                "content": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        indegree = [0 for i in range(numCourses)]\\n        adj = [[] for i in range(numCourses)]\\n        ans = []\\n        for [a,b] in prerequisites:\\n            adj[a].append(b)\\n            indegree[b] += 1\\n        queue = []\\n        for i in range(numCourses):\\n            if indegree[i]==0:\\n                queue.append(i)\\n                ans.append(i)\\n        if queue==[]:\\n            return []\\n        while queue:\\n            j = queue.pop()\\n            for i in adj[j]:\\n                indegree[i] -= 1\\n                if indegree[i]==0:\\n                    queue.append(i)\\n                    ans.append(i)\\n        if indegree==[0 for i in range(numCourses)]:\\n            return ans[::-1]\\n        return []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        indegree = [0 for i in range(numCourses)]\\n        adj = [[] for i in range(numCourses)]\\n        ans = []\\n        for [a,b] in prerequisites:\\n            adj[a].append(b)\\n            indegree[b] += 1\\n        queue = []\\n        for i in range(numCourses):\\n            if indegree[i]==0:\\n                queue.append(i)\\n                ans.append(i)\\n        if queue==[]:\\n            return []\\n        while queue:\\n            j = queue.pop()\\n            for i in adj[j]:\\n                indegree[i] -= 1\\n                if indegree[i]==0:\\n                    queue.append(i)\\n                    ans.append(i)\\n        if indegree==[0 for i in range(numCourses)]:\\n            return ans[::-1]\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743319,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 8 ms, faster than 98.89% of Go online submissions for Course Schedule II.\\nMemory Usage: 5.9 MB, less than 82.67% of Go online submissions for Course Schedule II.\\n\\n```go\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    edges, indegree := make([][]int, numCourses), make([]int, numCourses)\\n    for _, v := range prerequisites {\\n        edges[v[1]] = append(edges[v[1]], v[0])\\n        indegree[v[0]]++\\n    }\\n    queue, res := []int{}, []int{}\\n    for i, v := range indegree { if v == 0 { queue = append(queue, i) } }\\n    for len(queue) > 0 {\\n        cur := queue[0]\\n        queue = queue[1:]\\n        numCourses--\\n        res = append(res, cur)\\n        for _, v := range edges[cur] {\\n            indegree[v]--\\n            if indegree[v] == 0 { queue = append(queue, v) }\\n        }\\n    }\\n    if numCourses != 0 { return []int{} }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    edges, indegree := make([][]int, numCourses), make([]int, numCourses)\\n    for _, v := range prerequisites {\\n        edges[v[1]] = append(edges[v[1]], v[0])\\n        indegree[v[0]]++\\n    }\\n    queue, res := []int{}, []int{}\\n    for i, v := range indegree { if v == 0 { queue = append(queue, i) } }\\n    for len(queue) > 0 {\\n        cur := queue[0]\\n        queue = queue[1:]\\n        numCourses--\\n        res = append(res, cur)\\n        for _, v := range edges[cur] {\\n            indegree[v]--\\n            if indegree[v] == 0 { queue = append(queue, v) }\\n        }\\n    }\\n    if numCourses != 0 { return []int{} }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 742790,
                "title": "c-bfs-based-solution-explained",
                "content": "Okay, let\\'s go with my longest (and not even so efficient, but still pretty readable) solution to date.\\n\\nFirst of all I need to parse my input into 2 maps: one (`paths`) that I will use to navigate my graph directly and one (`reqs`) that I am going to use to check what are the requirements to unlock a given course.\\n\\nKnowing that I also have `n` courses from `0` to `n-1)`, I will build a boolean vector `cells` (not the best naming, I know) to keep track of which starting points are available to me: initially all the values of `cells` are `true`, but when I find that a course as a prereq, I set it to `false`.\\n\\nOnce I am done populating my `paths`, `reqs` and `cells` container with data, I am going to populate `layer` with the viable starting points I found through `cells` (and then I reset them all to `false`, while at it).\\n\\nWith `layer` I can start grinding my own BFS logic, updating it as I proceed with my running through it: as in any ordinary BFS approach, I store its current length and I go through the queue merrily as I pop nodes from there and had them to my result vector `res` - that is, unless I either alredy added that course to `res` (in which case I will just move on) or the current course (`currCourse`, of course) I am parsing is not blocked by other missing requirements, that I check calling `checkReq` on it - using its own overall `reqs` and checking if they all match against the current state of `cells` (in which case I will just push it back to end of `layer`).\\n\\nThe logic behind using the `progressed` boolean is to make sure I do not run a single cycle of my `while` loop without adding at least one course to `res` - if that happens, it just means I am stuck and I need to move forward.\\n\\nOnce I am out of the loop, I just return `res` if its lenght is the same as the expected number of courses, empty vector otherwise.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool checkReq(vector<int>& reqs, vector<bool>& cells) {\\n        for (auto n: reqs) if (!cells[n]) return false;\\n        return true;\\n    }\\n    vector<int> findOrder(int nc, vector<vector<int>>& ps) {\\n        vector<int> res;\\n        unordered_map<int, vector<int>> paths;\\n        unordered_map<int, vector<int>> reqs;\\n        queue<int> layer;\\n        vector<bool> cells(nc, true);\\n        for (auto p: ps) {\\n            paths[p[1]].push_back(p[0]);\\n            reqs[p[0]].push_back(p[1]);\\n            cells[p[0]] = false;\\n        }\\n        for (int i = 0; i < cells.size(); i++) {\\n            if (cells[i]) {\\n                layer.push(i);\\n                cells[i] = false;\\n            }\\n        }\\n        int len = layer.size(), currCourse;\\n        bool progressed = true;\\n        while (progressed && layer.size()) {\\n            progressed = false;\\n            for (int i = 0; i < len; i++) {\\n                currCourse = layer.front();\\n                layer.pop();\\n                if (!cells[currCourse]) {\\n                    if (checkReq(reqs[currCourse], cells)) {\\n                        progressed = true;\\n                        res.push_back(currCourse);\\n                        cells[currCourse] = true;\\n                        for (auto path: paths[currCourse]) layer.push(path);\\n                    } else {\\n                        layer.push(currCourse);\\n                    }\\n                }\\n            }\\n            len = layer.size();\\n        }\\n        return res.size() == nc ? res : vector<int>();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool checkReq(vector<int>& reqs, vector<bool>& cells) {\\n        for (auto n: reqs) if (!cells[n]) return false;\\n        return true;\\n    }\\n    vector<int> findOrder(int nc, vector<vector<int>>& ps) {\\n        vector<int> res;\\n        unordered_map<int, vector<int>> paths;\\n        unordered_map<int, vector<int>> reqs;\\n        queue<int> layer;\\n        vector<bool> cells(nc, true);\\n        for (auto p: ps) {\\n            paths[p[1]].push_back(p[0]);\\n            reqs[p[0]].push_back(p[1]);\\n            cells[p[0]] = false;\\n        }\\n        for (int i = 0; i < cells.size(); i++) {\\n            if (cells[i]) {\\n                layer.push(i);\\n                cells[i] = false;\\n            }\\n        }\\n        int len = layer.size(), currCourse;\\n        bool progressed = true;\\n        while (progressed && layer.size()) {\\n            progressed = false;\\n            for (int i = 0; i < len; i++) {\\n                currCourse = layer.front();\\n                layer.pop();\\n                if (!cells[currCourse]) {\\n                    if (checkReq(reqs[currCourse], cells)) {\\n                        progressed = true;\\n                        res.push_back(currCourse);\\n                        cells[currCourse] = true;\\n                        for (auto path: paths[currCourse]) layer.push(path);\\n                    } else {\\n                        layer.push(currCourse);\\n                    }\\n                }\\n            }\\n            len = layer.size();\\n        }\\n        return res.size() == nc ? res : vector<int>();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741847,
                "title": "c-solution-topological-sort-cycle-detection",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCycle(int i, vector<bool> &visited, vector<bool> &restack, vector<vector<int>> &g)\\n    {\\n        if(!visited[i])\\n        {\\n            visited[i] =1;\\n            restack[i] = 1;\\n            for(int j=0;j<g[i].size();j++)\\n            {\\n                if(!visited[g[i][j]] and isCycle(g[i][j], visited, restack, g))\\n                    return true;\\n                else if(restack[g[i][j]])\\n                    return 1;\\n            }\\n        }\\n        restack[i] = false;\\n        return false;\\n    }\\n    void topo(int i, vector<bool> &visited, vector<int> &ans, vector<vector<int>> & g)\\n    {\\n        visited[i] = 1;\\n        for(int j=0;j<g[i].size();j++)\\n            if(!visited[g[i][j]])\\n                topo(g[i][j], visited, ans, g);\\n        ans.push_back(i);\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) { \\n        vector<vector<int>> g(numCourses);\\n        for(int i=0;i<prerequisites.size();i++)\\n            g[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        vector<bool> visited(numCourses, 0);\\n        vector<bool> restack(numCourses, 0);\\n        for(int i=0;i<numCourses;i++)\\n            if(isCycle(i, visited, restack, g))\\n                return {};\\n        for(int i=0;i<numCourses;i++)\\n            visited[i] = 0;\\n        vector<int> ans;\\n        for(int i=0;i<numCourses;i++)\\n            if(!visited[i])\\n                topo(i, visited, ans, g);\\n        return ans;      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCycle(int i, vector<bool> &visited, vector<bool> &restack, vector<vector<int>> &g)\\n    {\\n        if(!visited[i])\\n        {\\n            visited[i] =1;\\n            restack[i] = 1;\\n            for(int j=0;j<g[i].size();j++)\\n            {\\n                if(!visited[g[i][j]] and isCycle(g[i][j], visited, restack, g))\\n                    return true;\\n                else if(restack[g[i][j]])\\n                    return 1;\\n            }\\n        }\\n        restack[i] = false;\\n        return false;\\n    }\\n    void topo(int i, vector<bool> &visited, vector<int> &ans, vector<vector<int>> & g)\\n    {\\n        visited[i] = 1;\\n        for(int j=0;j<g[i].size();j++)\\n            if(!visited[g[i][j]])\\n                topo(g[i][j], visited, ans, g);\\n        ans.push_back(i);\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) { \\n        vector<vector<int>> g(numCourses);\\n        for(int i=0;i<prerequisites.size();i++)\\n            g[prerequisites[i][0]].push_back(prerequisites[i][1]);\\n        vector<bool> visited(numCourses, 0);\\n        vector<bool> restack(numCourses, 0);\\n        for(int i=0;i<numCourses;i++)\\n            if(isCycle(i, visited, restack, g))\\n                return {};\\n        for(int i=0;i<numCourses;i++)\\n            visited[i] = 0;\\n        vector<int> ans;\\n        for(int i=0;i<numCourses;i++)\\n            if(!visited[i])\\n                topo(i, visited, ans, g);\\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571094,
                "title": "c-topological-sort-solution-using-dfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tbool dfs(vector<int>& ans, int cur,vector<vector<int>>& graph, vector<int>& cnt)\\n\\t\\t{\\n\\n\\t\\t  //  cout<<cur<<endl;\\n\\t\\t\\tif(cnt[cur]==1) return true;\\n\\t\\t\\tif(cnt[cur]==2) return false;\\n\\n\\t\\t\\tcnt[cur]=1;\\n\\n\\t\\t\\tfor(auto& x:graph[cur])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dfs(ans,x,graph,cnt)) return true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcnt[cur]=2;\\n\\t\\t\\tans.push_back(cur);\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n\\t\\t\\tvector<int> cnt(numCourses);\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tvector<vector<int>> graph(numCourses);\\n\\t\\t\\tfor(auto& x:prerequisites)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgraph[x[1]].push_back(x[0]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0;i<numCourses;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dfs(ans,i,graph,cnt)) return {};\\n\\t\\t\\t}\\n\\n\\t\\t\\treverse(ans.begin(),ans.end());\\n\\t\\t\\treturn ans;\\n\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tbool dfs(vector<int>& ans, int cur,vector<vector<int>>& graph, vector<int>& cnt)\\n\\t\\t{\\n\\n\\t\\t  //  cout<<cur<<endl;\\n\\t\\t\\tif(cnt[cur]==1) return true;\\n\\t\\t\\tif(cnt[cur]==2) return false;\\n\\n\\t\\t\\tcnt[cur]=1;\\n\\n\\t\\t\\tfor(auto& x:graph[cur])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dfs(ans,x,graph,cnt)) return true;\\n\\t\\t\\t}",
                "codeTag": "C++"
            },
            {
                "id": 429350,
                "title": "java-course-schedule-i-ii-dfs-bfs",
                "content": "Reference: [Problem I](https://leetcode.com/problems/course-schedule/), [Problem II](https://leetcode.com/problems/course-schedule-ii/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n\\n\\n## Problem I\\n\\n> There are a total of `n` courses you have to take, labeled from `0` to `n-1`.\\n\\n> Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: `[0,1]`\\n\\n> Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\\n\\n**Note:** \\n\\n- The input is represented by a **list of edges**, not adjacency matrices or list.\\n- You may assume that there are no duplicate edges in the input prerequisites.\\n\\n**Example:** \\n\\n```java\\nInput: 2, [[1,0]] \\nOutput: true\\nExplanation: There are a total of 2 courses to take. \\n             To take course 1 you should have finished course 0. So it is possible.\\n\\nInput: 2, [[1,0],[0,1]]\\nOutput: false\\nExplanation: There are a total of 2 courses to take. \\n             To take course 1 you should have finished course 0, and to take course 0 you should\\n             also have finished course 1. So it is impossible.\\n```\\n\\n\\n### DFS (Cycle Detection)\\n\\nThis problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.\\n\\n**My mistake:** Using only true/false `marked` array does not solve the problem. We need more information because we are not dealing with a problem like finding a cycle in a path.\\n\\nReference: [Python 20 lines DFS solution sharing with explanation](https://leetcode.com/problems/course-schedule/discuss/58586/Python-20-lines-DFS-solution-sharing-with-explanation)\\n\\n`marked` array has three states:\\n\\n1. If node `v` has not been visited, then mark it as `0`.\\n2. If node `v` is being visited, then mark it as `-1`. If we find a vertex marked as `-1` in DFS, then there is a ring.\\n3. If node `v` has been visited, then mark it as `+1`. If a vertex was marked as `-1`, then no ring contains `v` or its successors.\\n\\n**Note:** First, we convert the input to a graph represented by an adjacency list (gain efficiency).\\n\\n```java\\npublic boolean canFinish(int numCourses, int[][] preReq) {\\n  if (numCourses == 0 || preReq == null || preReq.length == 0) {\\n    return true; // or false\\n  }\\n  // convert to adjacency list O(E)\\n  List<List<Integer>> graph = new ArrayList<>();\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]);\\n  }\\n  // dfs\\n  int[] marked = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) { // O(V)\\n    if (dfs(v, graph, marked)) return false; // O(E) in total\\n  }\\n  return true; // no cycle -> can finish\\n}\\n\\n// Returns true if a cycle is detected.\\nprivate boolean dfs(int v, List<List<Integer>> graph, int[] marked) {\\n  // not visited: 0 | being visited: -1 | visited: +1\\n  marked[v] = -1; // visit\\n  // for each neighbor\\n  for (int w : graph.get(v)) {\\n    if (marked[w] == -1) return true; // cycle exists\\n    if (marked[w] == 0) { // not visited\\n      if (dfs(w, graph, marked)) return true;\\n    }\\n  }\\n  marked[v] = +1; // visited\\n  return false; // no cycle is detected\\n}\\n```\\n\\n**Time:** `O(V + E)`\\n**Space:** `O(V)`\\n\\n\\n\\n### BFS (Topological Sort)\\n\\nThe problem can be reduced to the one that finds if there is a topological sort in the graph (also equivalent to the one that finds if the graph is acyclic).\\n\\nThere are two ways of finding a topological sort: `Reversed DFS` and `BFS`. We pick `BFS` at this time.\\n\\nThe basic idea is that we add all nodes with `0` degrees into a queue, and do `BFS` from these nodes. They are the starting nodes in a graphs. \\n\\nEach time we poll a node from the queue, we decrease all its neighbors\\' in-degree by one. This is like deleting the node from the graph and removing all its outgoing edges. **If a topological sort exists, we can remove the whole graph!**\\n\\nThe whole process takes `O(V)` steps in total if there is a topological sort.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/g660d.jpg \"Two Cases\")\\n\\nSo we need a `count` variable to check how many steps we have along this process. If it finally reduces to `0`, then there is a topological sort.\\n\\n```java\\npublic boolean canFinish(int numCourses, int[][] preReq) {\\n  if (numCourses == 0 || preReq == null || preReq.length == 0) {\\n    return true; // or false\\n  }\\n  // convert to adjacency list\\n  List<List<Integer>> graph = new ArrayList<>();\\n  int[] indegree = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]); // edge[1] is the prerequisite of edge[0]\\n    indegree[edge[0]] += 1; // count indegree for each node\\n  }\\n  // bfs\\n  Queue<Integer> queue = new LinkedList<>();\\n  int count = numCourses;\\n  // push all 0-degree nodes\\n  for (int v = 0; v < numCourses; ++v) {\\n    if (indegree[v] == 0) { // starting nodes\\n      queue.offer(v);\\n    }\\n  }\\n  \\n  while (queue.size() > 0) {\\n    int v = queue.poll();\\n    // for each neighbor w\\n    for (int w : graph.get(v)) {\\n      --indegree[w];\\n      if (indegree[w] == 0) {\\n        queue.offer(w);\\n      }\\n    }\\n    --count;\\n  }\\n  \\n  return count == 0;\\n}\\n```\\n\\n**Time:** `O(V + E)`\\n**Space:** `O(V)`\\n\\n\\n\\n## Problem II\\n\\n\\n### DFS (Reversed Post-Order Traversal)\\n\\nReference: [CS 61B | Part 11 | Topological Sort, DAG-LPT, DAG-SPT, DP, LIS / LLIS](https://www.junhaow.com/studynotes/cs61b/cs61b%20p11.html)\\n\\nBased on the version of cycle detection, we can update it to construct a topological ordering.\\n\\n1. Perform a DFS traversal from every vertex (any order) in the graph, **not clearing** markings between traversals (means not traversing marked vertices).\\n2. Record DFS post-order along the way (add to list when backtracking).\\n3. Topological ordering is the reverse of the post-order.\\n\\n```java\\npublic int[] findOrder(int numCourses, int[][] preReq) {\\n  if (numCourses == 0) return null;\\n  if (preReq == null || preReq.length == 0) { // no constraint\\n    int[] result = new int[numCourses];\\n    for (int i = 0; i < numCourses; ++i) result[i] = i;\\n    return result;\\n  }\\n  // convert to adjacency list\\n  List<List<Integer>> graph = new ArrayList<>();\\n  int[] indegree = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]);\\n  }\\n  // dfs\\n  List<Integer> result = new ArrayList<>();\\n  int[] marked = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) {\\n    if (marked[v] == 0) {\\n      if (dfs(v, marked, graph, result)) { // returns true if a cycle is detected\\n        return new int[0]; // no topological sort\\n      }\\n    }\\n  }\\n  // convert to array\\n  int[] output = new int[result.size()];\\n  for (int i = 0; i < result.size(); ++i) {\\n    output[i] = result.get(result.size() - i - 1);\\n  }\\n  return output;\\n}\\n\\n// Returns true if a cycle is detected.\\nprivate boolean dfs(int v, int[] marked, List<List<Integer>> graph, List<Integer> result) {\\n  marked[v] = -1; // being visited\\n  // for each neighbor\\n  for (int w : graph.get(v)) {\\n    if (marked[w] == -1) { // cycle detected!\\n      return true;\\n    }\\n    if (marked[w] == 0) {\\n      if (dfs(w, marked, graph, result)) return true;\\n    }\\n  }\\n  marked[v] = +1; // visited\\n  result.add(v); // post-order dfs\\n  return false;\\n}\\n```\\n\\n**Time:** `O(V + E)`\\n**Space:** `O(V)`\\n\\n\\n\\n### BFS (Simpler)\\n\\nReturn a node list in topological ordering. Use `BFS`. Add to the list when a node is polled from the queue.\\n\\n**Note:** \\n\\n- Base case! When there is no prerequisite, return a list of all nodes.\\n- When there is no topological sort, return an empty array.\\n\\n```java\\npublic int[] findOrder(int numCourses, int[][] preReq) {\\n  if (numCourses == 0) return null;\\n  if (preReq == null || preReq.length == 0) { // no constraint\\n    int[] result = new int[numCourses];\\n    for (int i = 0; i < numCourses; ++i) result[i] = i;\\n    return result;\\n  }\\n  // convert to adjacency list\\n  List<List<Integer>> graph = new ArrayList<>();\\n  int[] indegree = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]);\\n    indegree[edge[0]] += 1; // count indegree for each node\\n  }\\n  // bfs\\n  int[] result = new int[numCourses];\\n  int count = 0;\\n  Queue<Integer> queue = new LinkedList<>();\\n  for (int v = 0; v < numCourses; ++v) {\\n    if (indegree[v] == 0) {\\n      queue.offer(v);\\n    }\\n  }\\n  \\n  while (queue.size() > 0) {\\n    int v = queue.poll();\\n    result[count++] = v;\\n    // for each of its neighbors\\n    for (int w : graph.get(v)) {\\n      --indegree[w];\\n      if (indegree[w] == 0) {\\n        queue.offer(w);\\n      }\\n    }\\n  }\\n  \\n  // check if there is topologial sort\\n  if (count == numCourses) {\\n    return result;\\n  } else {\\n    return new int[0];\\n  }\\n}\\n```\\n\\n**Time:** `O(V + E)`\\n**Space:** `O(V)`",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```java\\nInput: 2, [[1,0]] \\nOutput: true\\nExplanation: There are a total of 2 courses to take. \\n             To take course 1 you should have finished course 0. So it is possible.\\n\\nInput: 2, [[1,0],[0,1]]\\nOutput: false\\nExplanation: There are a total of 2 courses to take. \\n             To take course 1 you should have finished course 0, and to take course 0 you should\\n             also have finished course 1. So it is impossible.\\n```\n```java\\npublic boolean canFinish(int numCourses, int[][] preReq) {\\n  if (numCourses == 0 || preReq == null || preReq.length == 0) {\\n    return true; // or false\\n  }\\n  // convert to adjacency list O(E)\\n  List<List<Integer>> graph = new ArrayList<>();\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]);\\n  }\\n  // dfs\\n  int[] marked = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) { // O(V)\\n    if (dfs(v, graph, marked)) return false; // O(E) in total\\n  }\\n  return true; // no cycle -> can finish\\n}\\n\\n// Returns true if a cycle is detected.\\nprivate boolean dfs(int v, List<List<Integer>> graph, int[] marked) {\\n  // not visited: 0 | being visited: -1 | visited: +1\\n  marked[v] = -1; // visit\\n  // for each neighbor\\n  for (int w : graph.get(v)) {\\n    if (marked[w] == -1) return true; // cycle exists\\n    if (marked[w] == 0) { // not visited\\n      if (dfs(w, graph, marked)) return true;\\n    }\\n  }\\n  marked[v] = +1; // visited\\n  return false; // no cycle is detected\\n}\\n```\n```java\\npublic boolean canFinish(int numCourses, int[][] preReq) {\\n  if (numCourses == 0 || preReq == null || preReq.length == 0) {\\n    return true; // or false\\n  }\\n  // convert to adjacency list\\n  List<List<Integer>> graph = new ArrayList<>();\\n  int[] indegree = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]); // edge[1] is the prerequisite of edge[0]\\n    indegree[edge[0]] += 1; // count indegree for each node\\n  }\\n  // bfs\\n  Queue<Integer> queue = new LinkedList<>();\\n  int count = numCourses;\\n  // push all 0-degree nodes\\n  for (int v = 0; v < numCourses; ++v) {\\n    if (indegree[v] == 0) { // starting nodes\\n      queue.offer(v);\\n    }\\n  }\\n  \\n  while (queue.size() > 0) {\\n    int v = queue.poll();\\n    // for each neighbor w\\n    for (int w : graph.get(v)) {\\n      --indegree[w];\\n      if (indegree[w] == 0) {\\n        queue.offer(w);\\n      }\\n    }\\n    --count;\\n  }\\n  \\n  return count == 0;\\n}\\n```\n```java\\npublic int[] findOrder(int numCourses, int[][] preReq) {\\n  if (numCourses == 0) return null;\\n  if (preReq == null || preReq.length == 0) { // no constraint\\n    int[] result = new int[numCourses];\\n    for (int i = 0; i < numCourses; ++i) result[i] = i;\\n    return result;\\n  }\\n  // convert to adjacency list\\n  List<List<Integer>> graph = new ArrayList<>();\\n  int[] indegree = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]);\\n  }\\n  // dfs\\n  List<Integer> result = new ArrayList<>();\\n  int[] marked = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) {\\n    if (marked[v] == 0) {\\n      if (dfs(v, marked, graph, result)) { // returns true if a cycle is detected\\n        return new int[0]; // no topological sort\\n      }\\n    }\\n  }\\n  // convert to array\\n  int[] output = new int[result.size()];\\n  for (int i = 0; i < result.size(); ++i) {\\n    output[i] = result.get(result.size() - i - 1);\\n  }\\n  return output;\\n}\\n\\n// Returns true if a cycle is detected.\\nprivate boolean dfs(int v, int[] marked, List<List<Integer>> graph, List<Integer> result) {\\n  marked[v] = -1; // being visited\\n  // for each neighbor\\n  for (int w : graph.get(v)) {\\n    if (marked[w] == -1) { // cycle detected!\\n      return true;\\n    }\\n    if (marked[w] == 0) {\\n      if (dfs(w, marked, graph, result)) return true;\\n    }\\n  }\\n  marked[v] = +1; // visited\\n  result.add(v); // post-order dfs\\n  return false;\\n}\\n```\n```java\\npublic int[] findOrder(int numCourses, int[][] preReq) {\\n  if (numCourses == 0) return null;\\n  if (preReq == null || preReq.length == 0) { // no constraint\\n    int[] result = new int[numCourses];\\n    for (int i = 0; i < numCourses; ++i) result[i] = i;\\n    return result;\\n  }\\n  // convert to adjacency list\\n  List<List<Integer>> graph = new ArrayList<>();\\n  int[] indegree = new int[numCourses];\\n  for (int v = 0; v < numCourses; ++v) graph.add(new ArrayList<>()); // init\\n  for (int[] edge : preReq) {\\n    graph.get(edge[1]).add(edge[0]);\\n    indegree[edge[0]] += 1; // count indegree for each node\\n  }\\n  // bfs\\n  int[] result = new int[numCourses];\\n  int count = 0;\\n  Queue<Integer> queue = new LinkedList<>();\\n  for (int v = 0; v < numCourses; ++v) {\\n    if (indegree[v] == 0) {\\n      queue.offer(v);\\n    }\\n  }\\n  \\n  while (queue.size() > 0) {\\n    int v = queue.poll();\\n    result[count++] = v;\\n    // for each of its neighbors\\n    for (int w : graph.get(v)) {\\n      --indegree[w];\\n      if (indegree[w] == 0) {\\n        queue.offer(w);\\n      }\\n    }\\n  }\\n  \\n  // check if there is topologial sort\\n  if (count == numCourses) {\\n    return result;\\n  } else {\\n    return new int[0];\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427037,
                "title": "adjacency-list-bfs",
                "content": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        //1.Create graph\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        int[] inDegree = new int[numCourses];\\n        for (int i = 0; i < numCourses; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for (int i = 0; i < prerequisites.length; i++) {\\n            int pre = prerequisites[i][1];\\n            int pos = prerequisites[i][0];\\n            map.get(pre).add(pos);\\n            inDegree[pos]++;\\n        }\\n        \\n        //2.BFS Topological Sorting\\n        Queue<Integer> queue = new LinkedList<>();\\n        int[] res = new int[numCourses];\\n        for (int i = 0; i < numCourses; i++) {\\n            if (inDegree[i] == 0) {\\n                queue.offer(i);\\n            }\\n        }\\n        int index = 0;\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            res[index++] = curr;\\n            List<Integer> list = map.get(curr);\\n            for (int i : list) {\\n                if (--inDegree[i] == 0) {\\n                    queue.offer(i);\\n                }\\n            }\\n        }\\n        \\n        //3.return res\\n        for (int i : inDegree) {\\n            if (i != 0) {\\n                return new int[0];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\\n        //1.Create graph\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        int[] inDegree = new int[numCourses];\\n        for (int i = 0; i < numCourses; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for (int i = 0; i < prerequisites.length; i++) {\\n            int pre = prerequisites[i][1];\\n            int pos = prerequisites[i][0];\\n            map.get(pre).add(pos);\\n            inDegree[pos]++;\\n        }\\n        \\n        //2.BFS Topological Sorting\\n        Queue<Integer> queue = new LinkedList<>();\\n        int[] res = new int[numCourses];\\n        for (int i = 0; i < numCourses; i++) {\\n            if (inDegree[i] == 0) {\\n                queue.offer(i);\\n            }\\n        }\\n        int index = 0;\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            res[index++] = curr;\\n            List<Integer> list = map.get(curr);\\n            for (int i : list) {\\n                if (--inDegree[i] == 0) {\\n                    queue.offer(i);\\n                }\\n            }\\n        }\\n        \\n        //3.return res\\n        for (int i : inDegree) {\\n            if (i != 0) {\\n                return new int[0];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322701,
                "title": "python-topology-sort-bfs-with-detailed-comments-beats-99-53",
                "content": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \\n        edges = {i:[] for i in range(numCourses)} # initialization. i->be relied on, list []->courses that rely on i.\\n        \\n        indeg = [0 for i in range(numCourses)]   # initialization. Indegree for elements that reply on the others\\n        \\n        for x,y in prerequisites:           # initialization.\\n            edges[y].append(x)\\n            indeg[x]+=1\\n            \\n        que = collections.deque()\\n     \\n        for i in range(len(indeg)):\\n            if indeg[i] == 0:       #store courses with no reliance on other course(indegree = 0)\\n                que.append(i)\\n        res = []\\n                                    #Begin BFS search\\n        while que:\\n            x = que.popleft()       #Pop out the course that has indegree = 0, which means\\n            res.append(x)           #that courses now is \"clear\", not relying on other courses now. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t#Also means this course is free to take, append it in res.\\n            \\n            for n in edges[x]:      #Loop every element that depend on x, and minus their indegree by 1\\n                indeg[n] -= 1       #(since x now has been poped out and \"cleared\"\\n                if indeg[n] == 0:\\n                    que.append(n)\\n                \\n        if len(res) == numCourses:\\n            return res\\n        else:return []\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        \\n        edges = {i:[] for i in range(numCourses)} # initialization. i->be relied on, list []->courses that rely on i.\\n        \\n        indeg = [0 for i in range(numCourses)]   # initialization. Indegree for elements that reply on the others\\n        \\n        for x,y in prerequisites:           # initialization.\\n            edges[y].append(x)\\n            indeg[x]+=1\\n            \\n        que = collections.deque()\\n     \\n        for i in range(len(indeg)):\\n            if indeg[i] == 0:       #store courses with no reliance on other course(indegree = 0)\\n                que.append(i)\\n        res = []\\n                                    #Begin BFS search\\n        while que:\\n            x = que.popleft()       #Pop out the course that has indegree = 0, which means\\n            res.append(x)           #that courses now is \"clear\", not relying on other courses now. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t#Also means this course is free to take, append it in res.\\n            \\n            for n in edges[x]:      #Loop every element that depend on x, and minus their indegree by 1\\n                indeg[n] -= 1       #(since x now has been poped out and \"cleared\"\\n                if indeg[n] == 0:\\n                    que.append(n)\\n                \\n        if len(res) == numCourses:\\n            return res\\n        else:return []\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59367,
                "title": "c-iterative-bfs-using-prereq-counting-clear-explanation",
                "content": "Do BFS and each prereq that leads to a course will decrements the course's prereq count.  When that course gets to zero it can now be \"taken\" and it can enqueue to decrement it's children.  If the prereq counter for course is already zero there is a cycle.  If not all courses were reached this is also indicative of a cycle because the prereq count never reached zero and that course could never be \"taken\".  \\n\\n```\\n    public int[] FindOrder(int numCourses, int[,] prerequisites) \\n    {\\n        // map :: key=course; value=list of courses that have the key as a pre-req\\n        List<int>[] map = new List<int>[numCourses];\\n        for (int i = 0; i < numCourses; i++) map[i] = new List<int>();\\n        \\n        // count number of pre-reqs for each course\\n        int[] cnts = new int[numCourses];\\n        \\n        // build graph and counts\\n        for (int i = 0; i < prerequisites.GetLength(0); i++)\\n        {\\n            int course = prerequisites[i,0];\\n            int pre = prerequisites[i,1];\\n            map[pre].Add(course);        \\n            cnts[course]++;\\n        }\\n        \\n        // enqueue all course which have no pre-reqs\\n        Queue<int> queue = new Queue<int>();\\n        for (int i = 0; i < numCourses; i++) if (cnts[i] == 0) queue.Enqueue(i);\\n        \\n        // no starting point - cycle(s)\\n        if (queue.Count == 0) return new int[0];\\n        \\n        // track visited - only visit once\\n        bool[] visited = new bool[numCourses];\\n        \\n        // add to list on each first visit\\n        int[] order = new int[numCourses];\\n        int orderIndex = 0;\\n        \\n        // when unvisited decriment each child's count\\n        // if that child already has zero count -> cycle\\n        // if that child has zero count after deduction then enque this node\\n        while(queue.Count > 0)\\n        {\\n            int i = queue.Dequeue(); \\n            if (!visited[i])\\n            {\\n                visited[i] = true;\\n                order[orderIndex++] = i;\\n                foreach (int x in map[i])\\n                {\\n                    if (cnts[x] == 0) return new int[0]; // cycle\\n                    cnts[x]--;\\n                    if (cnts[x] == 0) queue.Enqueue(x);\\n                }\\n            }\\n        }\\n        \\n        // if not all courses were added there were pre-reqs that could not be removed (cycle)\\n        return orderIndex < numCourses ? new int[0] : order;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] FindOrder(int numCourses, int[,] prerequisites) \\n    {\\n        // map :: key=course; value=list of courses that have the key as a pre-req\\n        List<int>[] map = new List<int>[numCourses];\\n        for (int i = 0; i < numCourses; i++) map[i] = new List<int>();\\n        \\n        // count number of pre-reqs for each course\\n        int[] cnts = new int[numCourses];\\n        \\n        // build graph and counts\\n        for (int i = 0; i < prerequisites.GetLength(0); i++)\\n        {\\n            int course = prerequisites[i,0];\\n            int pre = prerequisites[i,1];\\n            map[pre].Add(course);        \\n            cnts[course]++;\\n        }\\n        \\n        // enqueue all course which have no pre-reqs\\n        Queue<int> queue = new Queue<int>();\\n        for (int i = 0; i < numCourses; i++) if (cnts[i] == 0) queue.Enqueue(i);\\n        \\n        // no starting point - cycle(s)\\n        if (queue.Count == 0) return new int[0];\\n        \\n        // track visited - only visit once\\n        bool[] visited = new bool[numCourses];\\n        \\n        // add to list on each first visit\\n        int[] order = new int[numCourses];\\n        int orderIndex = 0;\\n        \\n        // when unvisited decriment each child's count\\n        // if that child already has zero count -> cycle\\n        // if that child has zero count after deduction then enque this node\\n        while(queue.Count > 0)\\n        {\\n            int i = queue.Dequeue(); \\n            if (!visited[i])\\n            {\\n                visited[i] = true;\\n                order[orderIndex++] = i;\\n                foreach (int x in map[i])\\n                {\\n                    if (cnts[x] == 0) return new int[0]; // cycle\\n                    cnts[x]--;\\n                    if (cnts[x] == 0) queue.Enqueue(x);\\n                }\\n            }\\n        }\\n        \\n        // if not all courses were added there were pre-reqs that could not be removed (cycle)\\n        return orderIndex < numCourses ? new int[0] : order;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59418,
                "title": "simple-java",
                "content": "```\\n  public int[] findOrder(int numCourses,int[][] prerequisites){\\n        List<List<Integer>> list=new ArrayList<>();\\n        for(int i=0;i<numCourses;i++){\\n            list.add(new ArrayList<>());\\n        }\\n        int[] degree=new int[numCourses];\\n        for(int i=0;i<prerequisites.length;i++){\\n            int to=prerequisites[i][0];\\n            int from=prerequisites[i][1];\\n            degree[to]++;\\n            list.get(from).add(to);\\n        }\\n        Queue<Integer> queue=new LinkedList<>();\\n        List<Integer> res=new ArrayList<>();\\n        for(int i=0;i<numCourses;i++){\\n            if(degree[i]==0){\\n                queue.add(i);\\n                res.add(i);\\n            }\\n        }\\n        while(!queue.isEmpty()){\\n            int node=queue.poll();\\n            List<Integer> toList=list.get(node);\\n            for(int to : toList){\\n                degree[to]--;\\n                if(degree[to]==0){\\n                    queue.offer(to);\\n                    res.add(to);\\n                }\\n            }\\n        }\\n        if(res.size()<numCourses){\\n            return new int[0];\\n        }else{\\n            int[] array=new int[numCourses];\\n            for(int i=0;i<array.length;i++){\\n                array[i]=res.get(i);\\n            }\\n            return array;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public int[] findOrder(int numCourses,int[][] prerequisites){\\n        List<List<Integer>> list=new ArrayList<>();\\n        for(int i=0;i<numCourses;i++){\\n            list.add(new ArrayList<>());\\n        }\\n        int[] degree=new int[numCourses];\\n        for(int i=0;i<prerequisites.length;i++){\\n            int to=prerequisites[i][0];\\n            int from=prerequisites[i][1];\\n            degree[to]++;\\n            list.get(from).add(to);\\n        }\\n        Queue<Integer> queue=new LinkedList<>();\\n        List<Integer> res=new ArrayList<>();\\n        for(int i=0;i<numCourses;i++){\\n            if(degree[i]==0){\\n                queue.add(i);\\n                res.add(i);\\n            }\\n        }\\n        while(!queue.isEmpty()){\\n            int node=queue.poll();\\n            List<Integer> toList=list.get(node);\\n            for(int to : toList){\\n                degree[to]--;\\n                if(degree[to]==0){\\n                    queue.offer(to);\\n                    res.add(to);\\n                }\\n            }\\n        }\\n        if(res.size()<numCourses){\\n            return new int[0];\\n        }else{\\n            int[] array=new int[numCourses];\\n            for(int i=0;i<array.length;i++){\\n                array[i]=res.get(i);\\n            }\\n            return array;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 59454,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "JUST THE SAME AS THE previous question.\\nWe just can use extra vector-array to record the result.\\n\\n    class Solution {\\n    public:\\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            vector<int> result;\\n            vector<unordered_set<int>> graph(numCourses, unordered_set<int>());\\n            for(int i=0; i<prerequisites.size(); i++)\\n                graph[prerequisites[i].second].insert(prerequisites[i].first);\\n            vector<int> in_degree(numCourses, 0);\\n            for(int i=0; i<graph.size(); i++)\\n                for(auto it:graph[i])\\n                    in_degree[it]++;\\n                    \\n            int count=0;\\n            for(int i=0; i<numCourses; i++){\\n                int j;\\n                for(j=0; j<numCourses; j++) if(in_degree[j]==0)  break;\\n                /*** return {} means return null vector ***/\\n                if(j==numCourses)   return {};\\n                in_degree[j]=-1;\\n                for(auto it : graph[j])   in_degree[it]--;\\n                result.push_back(j);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {\\n            vector<int> result;\\n            vector<unordered_set<int>> graph(numCourses, unordered_set<int>());\\n            for(int i=0; i<prerequisites.size(); i++)\\n                graph[prerequisites[i].second].insert(prerequisites[i].first);\\n            vector<int> in_degree(numCourses, 0);\\n            for(int i=0; i<graph.size(); i++)\\n                for(auto it:graph[i])\\n                    in_degree[it]++;\\n                    \\n            int count=0;\\n            for(int i=0; i<numCourses; i++){\\n                int j;\\n                for(j=0; j<numCourses; j++) if(in_degree[j]==0)  break;\\n                /*** return {}",
                "codeTag": "Java"
            },
            {
                "id": 59428,
                "title": "46ms-java-bfs-toposort-with-kahn-s-algorithm",
                "content": "Note: it is a vanilla toposort with Kahn's BFS algorithm. The conversion of the final result from list to array is a bit ugly.\\n\\n    public class Solution {\\n    \\tpublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n    \\t\\t// BFS toposort with Kahn's algorithm\\n    \\t\\tint[] indegree = new int[numCourses];\\n    \\t\\tfor (int[] p : prerequisites) {\\n    \\t\\t\\tindegree[p[0]]++;\\n    \\t\\t}\\n    \\t\\t// enqueue vertices with indegree == 0, no prerequisite is needed\\n    \\t\\tLinkedList<Integer> queue = new LinkedList<Integer>();\\n    \\t\\tfor (int i = 0; i < indegree.length; i++) {\\n    \\t\\t\\tif (indegree[i] == 0) {\\n    \\t\\t\\t\\tqueue.offer(i);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tList<Integer> result = new ArrayList<Integer>();\\n    \\t\\twhile (queue.size() != 0) {\\n    \\t\\t\\tInteger curr = queue.poll();\\n    \\t\\t\\tresult.add(curr);\\n    \\t\\t\\tfor (int[] p : prerequisites) {\\n    \\t\\t\\t\\tif (p[1] == curr) {\\n    \\t\\t\\t\\t\\tindegree[p[0]]--;\\n    \\t\\t\\t\\t\\tif (indegree[p[0]] == 0) {\\n    \\t\\t\\t\\t\\t\\tqueue.offer(p[0]);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif (result.size() != numCourses) {\\n    \\t\\t\\treturn new int[0];\\n    \\t\\t}\\n    \\t\\tint[] finalResult = new int[result.size()];\\n    \\t\\tfor (int i = 0; i < result.size(); i++) {\\n    \\t\\t\\tfinalResult[i] = result.get(i);\\n    \\t\\t}\\n    \\t\\treturn finalResult;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\tpublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n    \\t\\t// BFS toposort with Kahn's algorithm\\n    \\t\\tint[] indegree = new int[numCourses];\\n    \\t\\tfor (int[] p : prerequisites) {\\n    \\t\\t\\tindegree[p[0]]++;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 59477,
                "title": "simple-python-solution-using-dfs",
                "content": "    def findOrder(numCourses, prerequisites):\\n        def dfs(i, visited, graph, ret):\\n            #Stop visiting checked nodes\\n            if visited[i] == 1:\\n                return True\\n            #If cycle is detected, return False\\n            if visited[i] == -1:\\n                return False\\n                \\n            visited[i] = -1\\n            for n in graph[i]:\\n                if not dfs(n, visited, graph, ret):\\n                    return False\\n            #collecting results\\n            ret.append(i)\\n                    \\n            visited[i] = 1\\n            return True\\n            \\n        #Initializing graph data\\n        visited = [0] * numCourses\\n        graph = {x:[] for x in xrange(numCourses)}\\n        for p in prerequisites:\\n            graph[p[1]].append(p[0])\\n            \\n        #collecting topological order\\n        ret = []\\n        for i in xrange(numCourses):\\n            if not dfs(i, visited, graph, ret):\\n                return []\\n                \\n        return ret[::-1]",
                "solutionTags": [],
                "code": "    def findOrder(numCourses, prerequisites):\\n        def dfs(i, visited, graph, ret):\\n            #Stop visiting checked nodes\\n            if visited[i] == 1:\\n                return True\\n            #If cycle is detected, return False\\n            if visited[i] == -1:\\n                return False\\n                \\n            visited[i] = -1\\n            for n in graph[i]:\\n                if not dfs(n, visited, graph, ret):\\n                    return False\\n            #collecting results\\n            ret.append(i)\\n                    \\n            visited[i] = 1\\n            return True\\n            \\n        #Initializing graph data\\n        visited = [0] * numCourses\\n        graph = {x:[] for x in xrange(numCourses)}\\n        for p in prerequisites:\\n            graph[p[1]].append(p[0])\\n            \\n        #collecting topological order\\n        ret = []\\n        for i in xrange(numCourses):\\n            if not dfs(i, visited, graph, ret):\\n                return []\\n                \\n        return ret[::-1]",
                "codeTag": "Python3"
            },
            {
                "id": 59522,
                "title": "java-dfs-solution",
                "content": "Using hashset to detect if the course has shown before. If it does, it must be true, so continue.\\n\\n    public static class Solution {\\n    \\t\\tpublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n    \\t\\t\\tArrayList[] graph = new ArrayList[numCourses];\\n    \\t\\t\\tint[] res = new int[numCourses];\\n    \\t\\t\\tSet hs = new HashSet();\\n                int index = 0;\\n                \\n                for(int i=0;i<numCourses;i++)\\n                    graph[i] = new ArrayList();\\n                    \\n                boolean[] visited = new boolean[numCourses];\\n                for(int i=0; i<prerequisites.length;i++){\\n                    graph[prerequisites[i][0]].add(prerequisites[i][1]);\\n                }\\n    \\n                for(int i=0; i<numCourses; i++){\\n                    if(hs.contains(i))\\n                        continue;\\n                \\tStack stack = new Stack();\\n                    if(!dfs(graph,visited,i,stack,hs))\\n                        return (new int[0]);\\n                    while(stack.size()!=0){\\n                        int temp = (int)stack.pop();\\n                        if(!hs.contains(temp)){\\n                            res[index++] = temp;\\n                            hs.add(temp);\\n                        }\\n                    }\\n                }\\n                return res;\\n            }\\n    \\n            private boolean dfs(ArrayList[] graph, boolean[] visited, int course,Stack stack,Set hs){\\n                if(visited[course])\\n                    return false;\\n                else{\\n                \\tif(hs.contains(course))\\n                        return true;\\n                \\telse{\\n                        stack.add(course);\\n                \\t\\tvisited[course] = true;\\n                \\t}\\n                }\\n    \\n                for(int i=0; i<graph[course].size();i++){\\n                    if(!dfs(graph,visited,(int)graph[course].get(i),stack,hs))\\n                        return false;\\n                }\\n                visited[course] = false;\\n                return true;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\t\\tpublic int[] findOrder(int numCourses, int[][] prerequisites) {\\n    \\t\\t\\tArrayList[] graph = new ArrayList[numCourses];\\n    \\t\\t\\tint[] res = new int[numCourses];\\n    \\t\\t\\tSet hs = new HashSet();\\n                int index = 0;\\n                \\n                for(int i=0;i<numCourses;i++)\\n                    graph[i] = new ArrayList();\\n                    \\n                boolean[] visited = new boolean[numCourses];\\n                for(int i=0; i<prerequisites.length;i++){\\n                    graph[prerequisites[i][0]].add(prerequisites[i][1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4101762,
                "title": "topological-sort-bfs-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int>adj[numCourses];\\n        for (auto prerequisite : prerequisites) {\\n        int course = prerequisite[1]; \\n        int prereq = prerequisite[0];\\n        adj[course].push_back(prereq); \\n    }\\n        vector<int> indegree(numCourses, 0);\\n        for(int i=0;i<numCourses;i++)\\n        {\\n            for(auto it:adj[i])\\n            {\\n                indegree[it]++;\\n            }\\n        }\\n        queue<int>q;\\n        for(int i=0;i<numCourses;i++)\\n        {\\n            if( indegree[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        vector<int>tobo;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            tobo.push_back(node);\\n            for(auto it:adj[node])\\n            {\\n                indegree[it]--;\\n                if( indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n                \\n            }\\n        }\\n        vector<int>empty;\\n        if(tobo.size()!=numCourses)\\n        {\\n            return empty;\\n        }\\n        return tobo; \\n        \\n    }\\n};\\n```\\n![c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg](https://assets.leetcode.com/users/images/ac3905a0-5aab-41e9-8798-4520ad00a684_1695920413.222806.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int>adj[numCourses];\\n        for (auto prerequisite : prerequisites) {\\n        int course = prerequisite[1]; \\n        int prereq = prerequisite[0];\\n        adj[course].push_back(prereq); \\n    }\\n        vector<int> indegree(numCourses, 0);\\n        for(int i=0;i<numCourses;i++)\\n        {\\n            for(auto it:adj[i])\\n            {\\n                indegree[it]++;\\n            }\\n        }\\n        queue<int>q;\\n        for(int i=0;i<numCourses;i++)\\n        {\\n            if( indegree[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        vector<int>tobo;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            tobo.push_back(node);\\n            for(auto it:adj[node])\\n            {\\n                indegree[it]--;\\n                if( indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n                \\n            }\\n        }\\n        vector<int>empty;\\n        if(tobo.size()!=numCourses)\\n        {\\n            return empty;\\n        }\\n        return tobo; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065652,
                "title": "beats-90-in-speed-88-in-memory-very-short-sol-topological-sort-kahn-s-algorithm",
                "content": "# Approach\\nThe algorithm is designed to find a valid ordering of courses given a number of courses (`n`) and a list of prerequisites (`edges`). It utilizes a breadth-first search (BFS) approach and employs several data structures:\\n\\n- `adj`: An adjacency list representing the directed edges between courses.\\n- `visited`: A boolean array to track visited nodes.\\n- `indegree`: An array keeping track of the indegree of each node.\\n- `ans`: A vector to store the final result.\\n\\nHere\\'s a summarized outline of the algorithm:\\n\\n1. **Initialize Data Structures**:\\n   - Initialize a queue (`q`) for BFS.\\n   - Create an adjacency list (`adj`), visited array (`visited`), and indegree array (`indegree`).\\n   - Initialize an empty vector (`ans`) to store the final ordering.\\n\\n2. **Build the Graph and Calculate Indegrees**:\\n   - Iterate through the list of prerequisites (`edges`).\\n   - For each pair `(x[1], x[0])`, add an edge from `x[1]` to `x[0]` in the adjacency list (`adj`).\\n   - Here we have created the adjancey list in reverese to get the answer vector already reversed. \\n   - Increment the indegree of `x[0]`.\\n\\n3. **Enqueue Nodes with Indegree Zero**:\\n   - Iterate through all nodes.\\n   - If the indegree of a node is zero, enqueue it in the queue (`q`).\\n\\n4. **Perform Breadth-First Search (BFS)**:\\n   - While the queue is not empty:\\n     - Dequeue the front element.\\n     - Add it to the result (`ans`).\\n     - For each adjacent node `x` of the front element:\\n       - Decrement its indegree.\\n       - If the indegree becomes zero, enqueue `x`.\\n\\n5. **Check for Valid Ordering**:\\n   - If the size of the result (`ans`) is not equal to the total number of courses (`n`), return an empty vector (indicating no valid ordering).\\n   - Otherwise, return the result vector.\\n\\n**Summary**:\\nThe algorithm constructs a directed graph based on course prerequisites, performs a topological sort using BFS, and ensures the resulting ordering covers all courses. It returns a valid ordering if one exists, or an empty vector if not.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& edges) {\\n        queue<int> q;\\n        vector<int> adj[n], visited(n,false), indegree(n,0), ans;   \\n        for(auto& x : edges) {\\n            adj[x[1]].emplace_back(x[0]);\\n            indegree[x[0]]++;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 0) q.emplace(i);\\n        }\\n        while(!q.empty()) {\\n            auto front = q.front();\\n            q.pop();\\n            ans.emplace_back(front);\\n            for(auto& x : adj[front]) {\\n                indegree[x]--;\\n                if(indegree[x] == 0) q.emplace(x);\\n            }\\n        }\\n        return ans.size() != n ? vector<int>{} : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& edges) {\\n        queue<int> q;\\n        vector<int> adj[n], visited(n,false), indegree(n,0), ans;   \\n        for(auto& x : edges) {\\n            adj[x[1]].emplace_back(x[0]);\\n            indegree[x[0]]++;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 0) q.emplace(i);\\n        }\\n        while(!q.empty()) {\\n            auto front = q.front();\\n            q.pop();\\n            ans.emplace_back(front);\\n            for(auto& x : adj[front]) {\\n                indegree[x]--;\\n                if(indegree[x] == 0) q.emplace(x);\\n            }\\n        }\\n        return ans.size() != n ? vector<int>{} : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997895,
                "title": "basic-c-solution-topological-sort-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is possible to finish all courses only when there is no cycle present in the graph i.e nothing but what we do in Topological Sort. \\nSo the solution is same as the Topological Sorting Algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int V, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[V];\\n        for(auto it : prerequisites){\\n            adj[it[0]].push_back(it[1]);\\n        }\\n\\n        vector<int> indegree(V, 0);\\n          for(int i=0; i<V; i++){\\n              for(auto it: adj[i]){\\n                  indegree[it]++;\\n              }\\n          }\\n         \\n          queue<int>q;\\n          for(int i=0; i<V; i++){\\n              if(indegree[i] == 0) q.push(i);\\n          }\\n         \\n          vector<int> topo;\\n          while(!q.empty()){\\n              int node = q.front();\\n              q.pop();\\n              topo.push_back(node);\\n             \\n              for(auto it: adj[node]){\\n                  indegree[it]--;\\n                  if(indegree[it] == 0) q.push(it);\\n              }\\n          }\\n          \\n          reverse(topo.begin(), topo.end());\\n          if(topo.size() == V) return topo;\\n          return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int V, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[V];\\n        for(auto it : prerequisites){\\n            adj[it[0]].push_back(it[1]);\\n        }\\n\\n        vector<int> indegree(V, 0);\\n          for(int i=0; i<V; i++){\\n              for(auto it: adj[i]){\\n                  indegree[it]++;\\n              }\\n          }\\n         \\n          queue<int>q;\\n          for(int i=0; i<V; i++){\\n              if(indegree[i] == 0) q.push(i);\\n          }\\n         \\n          vector<int> topo;\\n          while(!q.empty()){\\n              int node = q.front();\\n              q.pop();\\n              topo.push_back(node);\\n             \\n              for(auto it: adj[node]){\\n                  indegree[it]--;\\n                  if(indegree[it] == 0) q.push(it);\\n              }\\n          }\\n          \\n          reverse(topo.begin(), topo.end());\\n          if(topo.size() == V) return topo;\\n          return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921588,
                "title": "easy-c-solution-beat-95",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topoSortBFS(int n,unordered_map<int,list<int>>& adj){\\n        vector<int> ans;\\n        unordered_map<int,int> indegree;\\n        queue<int> q;\\n        //calculating indegree\\n        for(auto i:adj){\\n            for(auto nbr:i.second)\\n                indegree[nbr]++;\\n        }\\n        //put all node inside q with in degree 0 \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n\\n        while(!q.empty()){\\n            int fnode=q.front();\\n            q.pop();\\n            ans.push_back(fnode);\\n            for(auto nbr : adj[fnode]){\\n                indegree[nbr]--;\\n                    //check for zero again\\n                    if(indegree[nbr] == 0) {\\n                        q.push(nbr);\\n                    }\\n            }\\n        }\\n        if(ans.size()==n)\\n            return ans;\\n        else\\n            return {};\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        unordered_map<int,list<int>> adj;\\n        for(auto task:prerequisites){\\n            int u=task[0];\\n            int v=task[1];\\n            adj[u].push_back(v);\\n        }\\n        vector<int> ans= topoSortBFS(numCourses,adj);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topoSortBFS(int n,unordered_map<int,list<int>>& adj){\\n        vector<int> ans;\\n        unordered_map<int,int> indegree;\\n        queue<int> q;\\n        //calculating indegree\\n        for(auto i:adj){\\n            for(auto nbr:i.second)\\n                indegree[nbr]++;\\n        }\\n        //put all node inside q with in degree 0 \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n\\n        while(!q.empty()){\\n            int fnode=q.front();\\n            q.pop();\\n            ans.push_back(fnode);\\n            for(auto nbr : adj[fnode]){\\n                indegree[nbr]--;\\n                    //check for zero again\\n                    if(indegree[nbr] == 0) {\\n                        q.push(nbr);\\n                    }\\n            }\\n        }\\n        if(ans.size()==n)\\n            return ans;\\n        else\\n            return {};\\n    }\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        unordered_map<int,list<int>> adj;\\n        for(auto task:prerequisites){\\n            int u=task[0];\\n            int v=task[1];\\n            adj[u].push_back(v);\\n        }\\n        vector<int> ans= topoSortBFS(numCourses,adj);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844142,
                "title": "c-dfs-kahn-s-algorithm-topological-sort",
                "content": "# Intuition\\nTopological sort\\n\\n# DFS\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int& v = numCourses; // alias\\n\\n        vector<int> adj[v];\\n\\n        // building adjacency list\\n        for (auto& pr : prerequisites) {\\n            adj[pr[1]].emplace_back(pr[0]);\\n        }\\n\\n        vector<bool> visited(v, false), pathVisited(v, false);\\n        vector<int> result;\\n\\n        for (int node = 0; node < v; node++) {\\n            if (!visited[node] && dfs(adj, visited, pathVisited, result, node))\\n                return {};\\n        }\\n\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n\\nprivate:\\n    bool dfs(vector<int> adj[], vector<bool>& visited, vector<bool>& pathVisited, \\n                vector<int>& result, int node)\\n    {\\n        if (pathVisited[node])\\n            return true;    \\n        if (visited[node])\\n            return false;\\n\\n        visited[node] = pathVisited[node] = true;\\n\\n        for (auto& adjNode : adj[node]) {\\n            if (dfs(adj, visited, pathVisited, result, adjNode))\\n                return true;\\n        }\\n\\n        pathVisited[node] = false;\\n        result.emplace_back(node);\\n        return false;\\n    }\\n};\\n```\\n\\n# Kahn\\'s Algorithm\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int& v = numCourses; // alias\\n\\n        vector<int> adj[v], result(v), indegree(v);\\n        int topoLen = 0;\\n\\n        // building adjacency list\\n        for (auto& pr : prerequisites) {\\n            adj[pr[1]].emplace_back(pr[0]);\\n        }\\n\\n        for (int node = 0; node < v; node++) {\\n            for (auto& adjNode : adj[node])\\n                indegree[adjNode]++;\\n        }\\n\\n        queue<int> Q;\\n\\n        for (int node = 0; node < v; node++) {\\n            if (indegree[node] == 0)\\n                Q.emplace(node);\\n        }\\n\\n        int i = 0;\\n        while (!Q.empty()) {\\n            int node = Q.front(); Q.pop();\\n            result[i++] = node;\\n            topoLen++;\\n\\n            for (auto& adjNode : adj[node]) {\\n                if (--indegree[adjNode] == 0)\\n                    Q.emplace(adjNode);\\n            }\\n        }\\n\\n        if (topoLen != v) return {};\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int& v = numCourses; // alias\\n\\n        vector<int> adj[v];\\n\\n        // building adjacency list\\n        for (auto& pr : prerequisites) {\\n            adj[pr[1]].emplace_back(pr[0]);\\n        }\\n\\n        vector<bool> visited(v, false), pathVisited(v, false);\\n        vector<int> result;\\n\\n        for (int node = 0; node < v; node++) {\\n            if (!visited[node] && dfs(adj, visited, pathVisited, result, node))\\n                return {};\\n        }\\n\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n\\nprivate:\\n    bool dfs(vector<int> adj[], vector<bool>& visited, vector<bool>& pathVisited, \\n                vector<int>& result, int node)\\n    {\\n        if (pathVisited[node])\\n            return true;    \\n        if (visited[node])\\n            return false;\\n\\n        visited[node] = pathVisited[node] = true;\\n\\n        for (auto& adjNode : adj[node]) {\\n            if (dfs(adj, visited, pathVisited, result, adjNode))\\n                return true;\\n        }\\n\\n        pathVisited[node] = false;\\n        result.emplace_back(node);\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        int& v = numCourses; // alias\\n\\n        vector<int> adj[v], result(v), indegree(v);\\n        int topoLen = 0;\\n\\n        // building adjacency list\\n        for (auto& pr : prerequisites) {\\n            adj[pr[1]].emplace_back(pr[0]);\\n        }\\n\\n        for (int node = 0; node < v; node++) {\\n            for (auto& adjNode : adj[node])\\n                indegree[adjNode]++;\\n        }\\n\\n        queue<int> Q;\\n\\n        for (int node = 0; node < v; node++) {\\n            if (indegree[node] == 0)\\n                Q.emplace(node);\\n        }\\n\\n        int i = 0;\\n        while (!Q.empty()) {\\n            int node = Q.front(); Q.pop();\\n            result[i++] = node;\\n            topoLen++;\\n\\n            for (auto& adjNode : adj[node]) {\\n                if (--indegree[adjNode] == 0)\\n                    Q.emplace(adjNode);\\n            }\\n        }\\n\\n        if (topoLen != v) return {};\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759649,
                "title": "python3-topological-sort-solution-intuition-and-imagination-of-solution-96-9-faster",
                "content": "# Intuition\\nHow to proceed with the Question is to think for yourself, where do I start with my first course?\\n \\nAnalogy will come in imagination to a graph problem itself as direct the node starting from which course needs to be completed first to get to the other course.\\n\\nFor example: prerequisites = [[1,0],[2,0],[3,1],[3,2]] numCourses=4\\n\\nTo complete course 0 I have to complete the course 1 first \\n and to complete the course 2 I have to complete the course 0 first again. \\n\\n How the graph will look like at the end, and you can imagine how the adjacancy list will be made. \\n\\n**{ 0 : *[1,2] from 0 we can either complete 1 or 2 so basically        for both the next courses 0 is necessary*\\n  1 : [3]\\n  2 : [3]\\n}**\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/cf20945d-9d07-4674-abd2-47d6ad84f994_1689255624.9738972.png)\\n\\n\\n\\n\\n\\n# Approach\\n\\n**We have to eliminate the node that can be completed without going to any node, meaning we have to complete the course that doesn\\'t have any prerequist and can be completed immediately**. That means all the courses with 0 indegree.\\n\\nWill put them in queue and start traversing in BFS. \\n\\nNow once that particular node(course) is completed, put that course in result as that will be compelted first and already is.\\nNow we will check all the courses that can be now completed or atleast have one less dependancy of a courses due to the completion of our current course (i.e.) Its neighbour or directs in the adjacency list.\\n\\nSo basically, the next (neighbour) course is one less dependency, which means one less indegree. Therefore, indegree[neigh] -= 1. If the indegree becomes 0 (meaning there are no dependencies left), that course (node) is good to go in the queue to be completed.\\n\\n**At last we will check if we were able to complete all the courses that means all the courses were popped from the queue atleast once and no course is left with any dependancy now. That means we have completed all the courses and give the result in order we poped the courses out of the bfs queue.**\\n\\n# Complexity\\n- Time complexity:\\n**O(V+E) BFS Traversal complexity** \\n\\n- Space complexity:\\n**O(V) to contain indegree and adjacency list**\\n\\n# Code\\n```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        ## Dependancy of each node/course\\n        indegree= [0]*numCourses\\n\\n        result = []\\n        ##Adjacency list\\n        mapper = defaultdict(list)\\n\\n        ##Putting all the courses that doesn\\'t have any dependancy in queue\\n        for ai, bi in prerequisites:\\n            mapper[bi].append(ai)\\n            indegree[ai]+=1\\n        # print(mapper,indegree)\\n\\n        q = deque()\\n\\n        for i in range(len(indegree)):\\n            if indegree[i]==0:\\n                q.append(i)\\n        while(q):\\n            node = q.popleft()\\n            result.append(node)\\n            for neigh in mapper[node]:\\n            # One less dependancy\\n                indegree[neigh]-=1\\n                if indegree[neigh]==0:\\n                    q.append(neigh)\\n        if len(result) == numCourses:\\n            return result\\n        return []        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        ## Dependancy of each node/course\\n        indegree= [0]*numCourses\\n\\n        result = []\\n        ##Adjacency list\\n        mapper = defaultdict(list)\\n\\n        ##Putting all the courses that doesn\\'t have any dependancy in queue\\n        for ai, bi in prerequisites:\\n            mapper[bi].append(ai)\\n            indegree[ai]+=1\\n        # print(mapper,indegree)\\n\\n        q = deque()\\n\\n        for i in range(len(indegree)):\\n            if indegree[i]==0:\\n                q.append(i)\\n        while(q):\\n            node = q.popleft()\\n            result.append(node)\\n            for neigh in mapper[node]:\\n            # One less dependancy\\n                indegree[neigh]-=1\\n                if indegree[neigh]==0:\\n                    q.append(neigh)\\n        if len(result) == numCourses:\\n            return result\\n        return []        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758475,
                "title": "easy-c-bfs-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int V, vector<vector<int>>& prerequisites) {\\n        vector<int>adj[V];\\n        for(auto it:prerequisites)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>indegree(V,0);\\n        for(int i=0;i<V;i++)\\n        {\\n            for(auto it:adj[i])\\n            {\\n                indegree[it]++;\\n            }\\n        }\\n        queue<int>q;\\n        for(int i=0;i<V;i++)\\n        {\\n            if(indegree[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        vector<int>ans;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            for(auto it:adj[node])\\n            {\\n                indegree[it]--;\\n                if(indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(ans.size()==V)\\n        {\\n            return ans;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int V, vector<vector<int>>& prerequisites) {\\n        vector<int>adj[V];\\n        for(auto it:prerequisites)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>indegree(V,0);\\n        for(int i=0;i<V;i++)\\n        {\\n            for(auto it:adj[i])\\n            {\\n                indegree[it]++;\\n            }\\n        }\\n        queue<int>q;\\n        for(int i=0;i<V;i++)\\n        {\\n            if(indegree[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        vector<int>ans;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            ans.push_back(node);\\n            for(auto it:adj[node])\\n            {\\n                indegree[it]--;\\n                if(indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(ans.size()==V)\\n        {\\n            return ans;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647087,
                "title": "golang",
                "content": "\\n\\n```\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    //build the graph\\n    graph := make([][]int,numCourses)\\n    in_degree := make([]int,numCourses)\\n    for _,v := range prerequisites{\\n        graph[v[1]] = append(graph[v[1]], v[0])\\n        in_degree[v[0]]++\\n    }\\n\\n    frontier := []int{}\\n    for i,v := range in_degree{\\n        if v==0{\\n            frontier = append(frontier,i)\\n        }\\n    }\\n\\n    result := []int{}\\n    for len(frontier)!=0{\\n        cur := frontier[0]\\n        frontier = frontier[1:]\\n        result = append(result,cur)\\n        for _,v := range graph[cur]{\\n            in_degree[v]--\\n            if in_degree[v]==0{\\n                frontier = append(frontier,v)\\n            }\\n        }\\n    }\\n\\n    if len(result)==numCourses{\\n        return result\\n    }\\n    return []int{}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findOrder(numCourses int, prerequisites [][]int) []int {\\n    //build the graph\\n    graph := make([][]int,numCourses)\\n    in_degree := make([]int,numCourses)\\n    for _,v := range prerequisites{\\n        graph[v[1]] = append(graph[v[1]], v[0])\\n        in_degree[v[0]]++\\n    }\\n\\n    frontier := []int{}\\n    for i,v := range in_degree{\\n        if v==0{\\n            frontier = append(frontier,i)\\n        }\\n    }\\n\\n    result := []int{}\\n    for len(frontier)!=0{\\n        cur := frontier[0]\\n        frontier = frontier[1:]\\n        result = append(result,cur)\\n        for _,v := range graph[cur]{\\n            in_degree[v]--\\n            if in_degree[v]==0{\\n                frontier = append(frontier,v)\\n            }\\n        }\\n    }\\n\\n    if len(result)==numCourses{\\n        return result\\n    }\\n    return []int{}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504656,
                "title": "c-topological-sort",
                "content": "# Complexity\\n- Time complexity: $$O(n+e)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[n];\\n        for (int i=0; i<prerequisites.size(); i++){\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }\\n        vector<int> topo;\\n        queue<int> q;\\n        vector<int> indegree(n,0);\\n        for (int i=0; i<n; i++){\\n            for (auto val: adj[i]){\\n                indegree[val]++;\\n            }\\n        }\\n        for (int i=0; i<n; i++){\\n            if (indegree[i]==0)q.push(i);\\n        }\\n        while (!q.empty()){\\n            int fr= q.front();\\n            q.pop();\\n            topo.push_back(fr);\\n            for (auto val: adj[fr]){\\n                indegree[val]--;\\n                if (indegree[val]==0)q.push(val);\\n            }\\n        }\\n        cout<<topo.size()<<endl;\\n        if (topo.size()==n)return topo;\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        vector<int> adj[n];\\n        for (int i=0; i<prerequisites.size(); i++){\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }\\n        vector<int> topo;\\n        queue<int> q;\\n        vector<int> indegree(n,0);\\n        for (int i=0; i<n; i++){\\n            for (auto val: adj[i]){\\n                indegree[val]++;\\n            }\\n        }\\n        for (int i=0; i<n; i++){\\n            if (indegree[i]==0)q.push(i);\\n        }\\n        while (!q.empty()){\\n            int fr= q.front();\\n            q.pop();\\n            topo.push_back(fr);\\n            for (auto val: adj[fr]){\\n                indegree[val]--;\\n                if (indegree[val]==0)q.push(val);\\n            }\\n        }\\n        cout<<topo.size()<<endl;\\n        if (topo.size()==n)return topo;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3177608,
                "title": "c-concise-topological-sort-142ms-97",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\\n        var degree = new int [numCourses];\\n\\n        var parentToChildren = prerequisites.ToLookup(\\n                p => p[1], \\n                c => { degree[c[0]]++; return c[0]; });\\n\\n        var bfs = new List<int>(numCourses);\\n\\n        for (int i = 0; i < numCourses; ++i) \\n            if (degree[i] == 0) bfs.Add(i);\\n\\n        for (int i = 0; i < bfs.Count; ++i)\\n        {\\n            foreach (var j in parentToChildren[bfs[i]])\\n            {\\n                if (--degree[j] == 0) \\n                    bfs.Add(j);\\n            }\\n        }\\n\\n        return bfs.Count == numCourses ? bfs.ToArray() : new int[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\\n        var degree = new int [numCourses];\\n\\n        var parentToChildren = prerequisites.ToLookup(\\n                p => p[1], \\n                c => { degree[c[0]]++; return c[0]; });\\n\\n        var bfs = new List<int>(numCourses);\\n\\n        for (int i = 0; i < numCourses; ++i) \\n            if (degree[i] == 0) bfs.Add(i);\\n\\n        for (int i = 0; i < bfs.Count; ++i)\\n        {\\n            foreach (var j in parentToChildren[bfs[i]])\\n            {\\n                if (--degree[j] == 0) \\n                    bfs.Add(j);\\n            }\\n        }\\n\\n        return bfs.Count == numCourses ? bfs.ToArray() : new int[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162718,
                "title": "explained-code-c",
                "content": "# Intuition\\nCheck if the directed graph has a cycle using any topo sort algo.\\nbecause if there is a cycle we will not be able to represent the graph in a linear fashion\\nIf there is no cycle return ant tppo sort.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        vector<int>ind(n,0);\\n        vector<int>v[n];\\n        for(auto it:pre){\\n            v[it[1]].push_back(it[0]);\\n        }\\n        vector<int>o;\\n        for(int i=0;i<n;i++){\\n            for(auto it:v[i]){\\n                ind[it]++;\\n            }\\n        }\\n        int cnt=0;\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n        if(ind[i]==0){\\n            q.push(i);\\n        }\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            cnt++;\\n            o.push_back(node);\\n            for(auto it:v[node]){\\n                ind[it]--;\\n                if(ind[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(cnt==n) return o;\\n        else return {};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& pre) {\\n        vector<int>ind(n,0);\\n        vector<int>v[n];\\n        for(auto it:pre){\\n            v[it[1]].push_back(it[0]);\\n        }\\n        vector<int>o;\\n        for(int i=0;i<n;i++){\\n            for(auto it:v[i]){\\n                ind[it]++;\\n            }\\n        }\\n        int cnt=0;\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n        if(ind[i]==0){\\n            q.push(i);\\n        }\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            cnt++;\\n            o.push_back(node);\\n            for(auto it:v[node]){\\n                ind[it]--;\\n                if(ind[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(cnt==n) return o;\\n        else return {};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034506,
                "title": "c-very-short-and-easy-understanding-5-lines-only",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& preq, int i = 0) {\\n        vector<vector<int>> graph(n); vector<int> indgr(n,0), ans,emptyVector;\\n        for(auto it: preq) graph[it[1]].push_back(it[0]),indgr[it[0]]++;\\n        for(int i = 0;i<n;i++) if(!indgr[i]) ans.push_back(i);\\n        while(ans.size()<n and i<ans.size())  for(auto it: graph[ans[i++]]) if(--indgr[it]==0) ans.push_back(it);\\n        return ans.size()==n ? ans : emptyVector;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& preq, int i = 0) {\\n        vector<vector<int>> graph(n); vector<int> indgr(n,0), ans,emptyVector;\\n        for(auto it: preq) graph[it[1]].push_back(it[0]),indgr[it[0]]++;\\n        for(int i = 0;i<n;i++) if(!indgr[i]) ans.push_back(i);\\n        while(ans.size()<n and i<ans.size())  for(auto it: graph[ans[i++]]) if(--indgr[it]==0) ans.push_back(it);\\n        return ans.size()==n ? ans : emptyVector;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966913,
                "title": "topological-sort-solution",
                "content": "\\n\\n# Code\\n```\\nfunction findOrder(numCourses: number, prerequisites: number[][]): number[] {\\n    const adjList:number[][] = new Array(numCourses)\\n\\n    for(let i=0; i<numCourses; i++) adjList[i] = []\\n\\n    //creating adjacency list\\n    for(let i=0; i<prerequisites.length; i++){\\n        const ver = prerequisites[i][0]\\n        const edge = prerequisites[i][1]\\n        adjList[ver].push(edge)\\n    }\\n\\n    return topoSort(numCourses, adjList)\\n};\\n\\nconst topoSort = (V:number, adj:number[][]):number[] => {\\n    const indegreeEdge = new Array(V).fill(0);\\n    const queue = [];\\n    const topoSort = [];\\n\\n    // indegree\\n    for(let i=0; i<V;i++){\\n        for(let it of adj[i]){\\n            indegreeEdge[it]++\\n        }\\n    }\\n    // zero incoming edge vertex;\\n    for(let i=0;i<V;i++){\\n        if(indegreeEdge[i] === 0){\\n            queue.push(i)\\n        }\\n    }\\n\\n    //topoSort\\n    while(queue.length){\\n        const node = queue.shift()\\n        topoSort.push(node)\\n\\n        //disconnet node;\\n        for(let it of adj[node]){\\n            indegreeEdge[it]--\\n            if(indegreeEdge[it] === 0) queue.push(it)\\n        }\\n    }\\n\\n    return topoSort.length === V ? topoSort.reverse() : []\\n}\\n\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nfunction findOrder(numCourses: number, prerequisites: number[][]): number[] {\\n    const adjList:number[][] = new Array(numCourses)\\n\\n    for(let i=0; i<numCourses; i++) adjList[i] = []\\n\\n    //creating adjacency list\\n    for(let i=0; i<prerequisites.length; i++){\\n        const ver = prerequisites[i][0]\\n        const edge = prerequisites[i][1]\\n        adjList[ver].push(edge)\\n    }\\n\\n    return topoSort(numCourses, adjList)\\n};\\n\\nconst topoSort = (V:number, adj:number[][]):number[] => {\\n    const indegreeEdge = new Array(V).fill(0);\\n    const queue = [];\\n    const topoSort = [];\\n\\n    // indegree\\n    for(let i=0; i<V;i++){\\n        for(let it of adj[i]){\\n            indegreeEdge[it]++\\n        }\\n    }\\n    // zero incoming edge vertex;\\n    for(let i=0;i<V;i++){\\n        if(indegreeEdge[i] === 0){\\n            queue.push(i)\\n        }\\n    }\\n\\n    //topoSort\\n    while(queue.length){\\n        const node = queue.shift()\\n        topoSort.push(node)\\n\\n        //disconnet node;\\n        for(let it of adj[node]){\\n            indegreeEdge[it]--\\n            if(indegreeEdge[it] === 0) queue.push(it)\\n        }\\n    }\\n\\n    return topoSort.length === V ? topoSort.reverse() : []\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2953835,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        map<int, vector<int>> mp;\\n        vector<int> in(n);\\n        queue<int> q;\\n        for(auto v:prerequisites)\\n        {\\n            mp[v[1]].push_back(v[0]);\\n            in[v[0]]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            q.push(i);\\n        }\\n        cout<<q.size();\\n        vector<int> ans;\\n        while(!q.empty())\\n        {\\n            int t=q.front();\\n            q.pop();\\n            cout<<t<<\"e\";\\n            ans.push_back(t);\\n            for(int i:mp[t])\\n            {\\n                in[i]--;\\n                if(in[i]==0)\\n                q.push(i);\\n            }\\n        }\\n        if(ans.size()==n)\\n        return ans;\\n        return {};\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {\\n        map<int, vector<int>> mp;\\n        vector<int> in(n);\\n        queue<int> q;\\n        for(auto v:prerequisites)\\n        {\\n            mp[v[1]].push_back(v[0]);\\n            in[v[0]]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            q.push(i);\\n        }\\n        cout<<q.size();\\n        vector<int> ans;\\n        while(!q.empty())\\n        {\\n            int t=q.front();\\n            q.pop();\\n            cout<<t<<\"e\";\\n            ans.push_back(t);\\n            for(int i:mp[t])\\n            {\\n                in[i]--;\\n                if(in[i]==0)\\n                q.push(i);\\n            }\\n        }\\n        if(ans.size()==n)\\n        return ans;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2938936,
                "title": "kotlin-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    private val stack = Stack<Int>()\\n    fun findOrder(numCourses: Int, prerequisites: Array<IntArray>): IntArray {\\n        val preReq = MutableList(numCourses) { mutableListOf<Int>() }\\n        prerequisites.forEach { (course, preq) -> preReq[course].add(preq) }\\n       \\n        val visited = mutableSetOf<Int>()    \\n        val cycle = mutableSetOf<Int>()        \\n        val ans = mutableListOf<Int>()\\n\\n        fun dfs(course: Int): Boolean {\\n            if (course in cycle) return false\\n            if (course in visited) return true\\n            \\n            cycle += course\\n            preReq[course]!!.forEach { if (!dfs(it)) return false }\\n            cycle -= course\\n            \\n            visited += course\\n            ans += course\\n            return true\\n        }\\n\\n        repeat(numCourses) { if (!dfs(it)) return intArrayOf() }\\n\\n        return ans.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private val stack = Stack<Int>()\\n    fun findOrder(numCourses: Int, prerequisites: Array<IntArray>): IntArray {\\n        val preReq = MutableList(numCourses) { mutableListOf<Int>() }\\n        prerequisites.forEach { (course, preq) -> preReq[course].add(preq) }\\n       \\n        val visited = mutableSetOf<Int>()    \\n        val cycle = mutableSetOf<Int>()        \\n        val ans = mutableListOf<Int>()\\n\\n        fun dfs(course: Int): Boolean {\\n            if (course in cycle) return false\\n            if (course in visited) return true\\n            \\n            cycle += course\\n            preReq[course]!!.forEach { if (!dfs(it)) return false }\\n            cycle -= course\\n            \\n            visited += course\\n            ans += course\\n            return true\\n        }\\n\\n        repeat(numCourses) { if (!dfs(it)) return intArrayOf() }\\n\\n        return ans.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742966,
                "title": "java-topological-sort-using-kahn-s-algo-is-93-82-faster-a-solution-you-will-love",
                "content": "**this post contains 3 section\\n1.why kahn\\'s algo work\\n2.applying kahn\\'s algo to this solution\\n3.code**\\njump to section 2 if you know what is topological sort, kahn\\'s algo and why kahn\\'s algo works.\\n**section 1:**\\nin **topological sort** parent comes before the child and this condition is valid for each node in the sequence ,works only for direct acyclic graph.\\nkahn\\'s algorithm is modified bfs algorithm which favours topological sort,when we talk of normal bfs every adjacent unvisited node to this node is added to the queue,so that we can propogate further deep from that node,quiet convenient for it\\'s functionality.\\nbut in kahn\\'s algo the goal is to create a sequence in which all the parents lie before sequence,so one may argue that ,this is what bfs do,yeah but bfs only takes local adjacent parent into consideration\\n![image](https://assets.leetcode.com/users/images/acc89b8b-1025-4d17-a760-1fe0b22a364a_1666703676.6675522.png)\\nbfs manages to put 1 before 2 but fails to put 5 before 2,hence it is modifed to form kahn\\'s algo\\n so we first count how many parent to each node exist,now these parents must be added into the sequence first before this node to be added into the sequence.we start with all the root nodes to which there is no incoming edge and start expending from them(here it is 1) now since 2 has 2 parents we won\\'t add it into the sequence until 5 is added into the sequence.we can simply check this by asking if all of it\\'s parent are traversed or not.and honestly speaking we can simply reduce the incoming edge count each time a parent is found and as soon as incoming edge count turns 0 we add it into the sequence.\\n **section 2**\\n having courses which form a dependency on each other such that both of them wait for each other\\'s completion is the only condition when we won\\'t be able to complete all the courses,which in other terms means that if the graph contains cycle we can\\'t complete all the courses,so how can we detect cycle,we can use kahn\\'s algo.as we know kahn\\'s algo is good in keeping track of parents traversed yet and only allow childs of a node to be traversed only if all of it\\'s parents are traversed(added to sequence),if a loop is encountered the node at which acyclic and cyclic portion of graph meets will wait for itself to be added into the queue so that it can traverse further but won\\'t be able to have the chance as one of it parent is reachable through it and since we are not traversing the node itself how can we traverse the parent,condition of all parents traversed not satisfied hence never added into the queue.the code it commented itself.\\n **section 3-the code**\\n ```\\n class Solution {\\n    public int[] findOrder(int numCourses, int[][] pre) {\\n        int[] ingress=new int[numCourses];//array to keep track of incoming edges\\n        //create graph from given array\\n        ArrayList<ArrayList<Integer>> graph=graph_creator(numCourses,pre);\\n        Arrays.fill(ingress,0);\\n        for(int i=0;i<numCourses;i++){\\n            for(int j:graph.get(i)){\\n            ingress[j]++;//increase if incoming edge to this node found\\n            }\\n        }\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=0;i<numCourses;i++){\\n            if(ingress[i]==0) q.add(i);//add all the root nodes to the queue as the starting points of traversal cause there is nothing which lie before them.\\n        }\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        while(!q.isEmpty()){\\n            int node=q.poll();\\n            ans.add(node);//here is why traversal means addition to answer.\\n            for(int i:graph.get(node)){\\n                ingress[i]--;//decrease the incoming edge count it won\\'t drop below 0.\\n                if(ingress[i]==0) q.add(i);//only add those whose parents have been added.\\n            }\\n        }\\n        if(ans.size()!=numCourses) return new int[0];//if we failed to add all node into answer there existed a cycle\\n        int[] output=new int[ans.size()];\\n        for(int i=0;i<ans.size();i++){\\n            output[i]=ans.get(i);\\n        }\\n        return output;\\n    }\\n    ArrayList<ArrayList<Integer>> graph_creator(int n,int[][]pre){\\n        ArrayList<ArrayList<Integer>> graph=new ArrayList<>(n);\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int[] temp:pre) graph.get(temp[1]).add(temp[0]);\\n        return graph;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n class Solution {\\n    public int[] findOrder(int numCourses, int[][] pre) {\\n        int[] ingress=new int[numCourses];//array to keep track of incoming edges\\n        //create graph from given array\\n        ArrayList<ArrayList<Integer>> graph=graph_creator(numCourses,pre);\\n        Arrays.fill(ingress,0);\\n        for(int i=0;i<numCourses;i++){\\n            for(int j:graph.get(i)){\\n            ingress[j]++;//increase if incoming edge to this node found\\n            }\\n        }\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=0;i<numCourses;i++){\\n            if(ingress[i]==0) q.add(i);//add all the root nodes to the queue as the starting points of traversal cause there is nothing which lie before them.\\n        }\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        while(!q.isEmpty()){\\n            int node=q.poll();\\n            ans.add(node);//here is why traversal means addition to answer.\\n            for(int i:graph.get(node)){\\n                ingress[i]--;//decrease the incoming edge count it won\\'t drop below 0.\\n                if(ingress[i]==0) q.add(i);//only add those whose parents have been added.\\n            }\\n        }\\n        if(ans.size()!=numCourses) return new int[0];//if we failed to add all node into answer there existed a cycle\\n        int[] output=new int[ans.size()];\\n        for(int i=0;i<ans.size();i++){\\n            output[i]=ans.get(i);\\n        }\\n        return output;\\n    }\\n    ArrayList<ArrayList<Integer>> graph_creator(int n,int[][]pre){\\n        ArrayList<ArrayList<Integer>> graph=new ArrayList<>(n);\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int[] temp:pre) graph.get(temp[1]).add(temp[0]);\\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715938,
                "title": "c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> res;\\n        vector<vector<int>> adj(numCourses, vector<int>());\\n        vector<int> degree(numCourses, 0);\\n        queue<int> q;\\n        for (const auto& pre : prerequisites) {\\n            // e.g, [2,4], then we store 4->2 \\n            // and [4]==1\\n            adj[pre[1]].push_back(pre[0]);\\n            degree[pre[0]]++;\\n        }\\n        for (int i = 0; i < numCourses; ++i) {\\n            // push cources without any pre into a queue.\\n            if (degree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int pre = q.front(); \\n            q.pop();\\n            numCourses --;\\n            // Found the result and store it. \\n            res.push_back(pre);\\n            for (auto c : adj[pre]) {\\n                degree[c]--;\\n                if (degree[c] == 0) {\\n                    q.push(c);\\n                }\\n            }\\n        }\\n        return (numCourses == 0) ? res : vector<int>();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\\n        vector<int> res;\\n        vector<vector<int>> adj(numCourses, vector<int>());\\n        vector<int> degree(numCourses, 0);\\n        queue<int> q;\\n        for (const auto& pre : prerequisites) {\\n            // e.g, [2,4], then we store 4->2 \\n            // and [4]==1\\n            adj[pre[1]].push_back(pre[0]);\\n            degree[pre[0]]++;\\n        }\\n        for (int i = 0; i < numCourses; ++i) {\\n            // push cources without any pre into a queue.\\n            if (degree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int pre = q.front(); \\n            q.pop();\\n            numCourses --;\\n            // Found the result and store it. \\n            res.push_back(pre);\\n            for (auto c : adj[pre]) {\\n                degree[c]--;\\n                if (degree[c] == 0) {\\n                    q.push(c);\\n                }\\n            }\\n        }\\n        return (numCourses == 0) ? res : vector<int>();\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565666,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1566541,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1567463,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1565916,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1567915,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1723612,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1569167,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1571430,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1662439,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1569024,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1565666,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1566541,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1567463,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1565916,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1567915,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1723612,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1569167,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1571430,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1662439,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1569024,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Python:\\n\\n    Input:\\t1, []\\n    Output:\\t[]\\n    Expected:\\tSpecial judge: No expected output available.\\n\\nWhy?"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "[0] is output\\n"
                    },
                    {
                        "username": "yifan97",
                        "content": "why does the test case `2  [] ` give me [1,0]"
                    },
                    {
                        "username": "thiennhank9",
                        "content": "It could be [0,1] also. The input means that you will have 2 courses (0,1) and there\\'s no requirement for each course. "
                    },
                    {
                        "username": "sdembla",
                        "content": "when the prerequisites are empty, then we need to return an empty array (thats what describe in problem statement). In test case: \\nfindOrder(2, []) \\nExpected: [1,0]. --> HOW ??\\nIt should return an empty array [], right ???\\n\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@Fiddle01](/Fiddle01) ..... the prerequisites array being empty only shows that the courses have no prereqs and you can take all courses in any possible order. So the answer must be any permutation of \n`[0, 1, ..., n-1]`."
                    },
                    {
                        "username": "Fiddle01",
                        "content": "The reason is that the prerequisites array only shows the courses that have prerequisites. All courses from 0...numCourses-1 exist, the prerequisites array being empty only shows that the courses have no prereqs. "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/course-schedule-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Depth First Search\n\n  \n**Approach 2:** Using Node Indegree\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SLH",
                        "content": "Input:\\t2, [[1,0]]\\nOutput:\\t[1,0]\\nExpected:\\tSpecial judge: No expected output available.\\n\\nI think it should output [1,0], why it is no expected output?"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "how you can take 1 before taking 0? Read problem statement carefully."
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "how can it make sense that [[1,0],[0,1]] ?"
                    },
                    {
                        "username": "ksdhananjaya05",
                        "content": "one condition to apply topsort is that the graph is a DAG. this testcase should be invalid"
                    },
                    {
                        "username": "radmehr",
                        "content": "In the problem description, note 2 says \"You may assume that there are no duplicate edges in the input prerequisites.\". However, one of the test cases is [[5,8],[3,5],[1,9],[4,5],[0,2],[1,9],[7,8],[4,9]] and there is clearly a duplicate edge [1,9]. Either the test case or the problem description needs to be updated unless I misunderstood something."
                    },
                    {
                        "username": "fuyun",
                        "content": "in the test case\\n3\\n[[0,2],[1,2],[2,0]]\\n0 is a prerequisite of 2 and 2 is a prerequisite of 0 in this case which subject should be studied first?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "it\\'s a cyclic case so it will return an empty array as we can\\'t take any course."
                    },
                    {
                        "username": "AndrewTheBug",
                        "content": "This is definitely not a medium task and without trivial solutions"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Mister_CK](/Mister_CK) Easy to med if you know topological sort/ bfs. \\nOtherwise, it is hard\\n\\nDon\\'t know how to do it with DFS though "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Do you think it is hard or easy? it is pretty straight forward topological sort."
                    },
                    {
                        "username": "iorilan",
                        "content": "for C# language  \\n\\nthe test case  :input : 3  , [[1,0]] expected result is wrong .\\n\\nexpected result should be : int[0] which is an empty array .  but it is not .\\n\\n\\nbut still showing \\n\\n'Special judge: No expected output available.'\\n\\n\\n\\nI wrote the same code by Java and accepted"
                    }
                ]
            },
            {
                "id": 1862133,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1576579,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1574533,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1572176,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1571877,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1571431,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1571432,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1571434,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1570613,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 1571433,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Why didn\\'t we use dfs algorithm for topological sort in this question. I used to following code for topological sorting and it gave incorrect result. \\n    void TopoSort(vector<vector<int>>& adj, vector<bool>& vis, stack<int>&st, int node){\\n        vis[node]=1;\\n        for(auto i:adj[node]){\\n            if(!vis[i])\\n            TopoSort(adj,vis,st,i);\\n        }\\n        st.push(node);\\n    }"
                    },
                    {
                        "username": "mkcoder77",
                        "content": "![image](https://assets.leetcode.com/users/images/649cdc18-238e-42d1-9236-dc06c820022a_1649077881.1893742.png)\\n"
                    },
                    {
                        "username": "alokonweb",
                        "content": "Input is 2 and and empty array and o/p expected is [0,1] ido not understand? can someone explain ?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "there are 2 courses and no prerequisites. One valid way to follow both courses is to follow 0 and then 1. [1,0] would also be accepted"
                    },
                    {
                        "username": "xiaokangpaul",
                        "content": "Hi, is 0 always the source?"
                    },
                    {
                        "username": "sinicLC",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/siniclc/image_1520450269.png)\n\ntwo [1,9], when problem statement says no duplicates in input edges"
                    },
                    {
                        "username": "Alpher",
                        "content": "Tried 3 different ways. none of them worked. any suggestion?\\n\\n==================================================\\nreturn null;\\n--------------------------------------------------\\nInput:\\n1\\n[]\\n\\nOutput:\\nnull\\n\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[0];\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n==================================================\\n\\n==================================================\\nreturn new int[]{};\\n--------------------------------------------------\\nInput:\\n1\\n[]\\nOutput:\\n[]\\nExpected:\\nSpecial judge: No expected output available.\\n=================================================="
                    },
                    {
                        "username": "shuoshankou",
                        "content": "Input:1\\n         []\\nOutput:\\n         []\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nMy output is empty array which makes perfect sense....."
                    },
                    {
                        "username": "rain4",
                        "content": "I am running to 32/35 test cases, and get the following error:\\nWhat does \"Special judge: No expected output available.\" mean?\\n\\nOutput:\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available.\\n\\nInput:\\n800, [[695,229],[199,149],[443,397],[258,247],[781,667],[350,160],[678,629],[467,166],[500,450],[477,107],[483,151],[792,785],[752,368],[659,623],[316,224],[487,268],[743,206],[552,211],[314,20],[720,196],[421,103],[493,288],[762,24],[528,318],[472,32],[684,502],[641,354],[586,480],[629,54],[611,412],[719,680],[733,42],[549,519],[697,316],[791,634],[546,70],[676,587],[460,58],[605,530],[617,579],[484,89],[571,482],[767,200],[555,547],[771,695],[624,542],[708,551],[432,266],[656,468],[724,317],[423,248],[621,593],[781,399],[535,528],[578,12],[770,549],[576,295],[318,247],[400,372],[465,363],[786,482],[441,398],[577,411],[524,30],[741,540],[459,59],[758,96],[550,89],[402,295],[476,336],[645,346],[750,116],[551,207],[343,226],[568,498],[530,228],[525,84],[507,128],[526,210],[535,381],[635,330],[654,535],[710,275],[397,213],[412,44],[131,70],[508,49],[679,223],[519,11],[626,286],[242,160],[778,199],[606,281],[226,16],[340,46],[578,127],[212,208],[674,343],[778,108], ......"
                    },
                    {
                        "username": "beingsid13",
                        "content": "3\\n[[0,1],[0,2],[1,2]]\\nfor the above input,\\nmy code is giving output as [2,0,1] but appearently it is wrong.\\nCan someone please explain me why is this wrong?"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "because when we loop from 0 to N course (0-3)  we first do DFS for 0 which require 1 as prerequisites , for which we do another recursive DFS  and check the prerequisites which is 2 , but 2 doesn\\'t have any prerequisites so we directly add it to our ans array. then while returning in post order we add 1 to the ans and then we add 0. \\nEven though loop moves from 0-N we have already marked 1 and 2 as visited or opted.\\nThe catch is that in topological order we need to add the ans in post order."
                    },
                    {
                        "username": "Gavin9999",
                        "content": "Input:\\n1\\n[]\\n\\nExpected:\\nSpecial judge: No expected output available."
                    }
                ]
            },
            {
                "id": 2065995,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 2064455,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 2054966,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 2035653,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 2020158,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 1957673,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 1942184,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 1940929,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 1898180,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            },
            {
                "id": 1897212,
                "content": [
                    {
                        "username": "A_Y",
                        "content": "The  fast solution (DAG) + DFS / c++ .:\nhttps://leetcode.com/problems/course-schedule-ii/submissions/1054627280/"
                    },
                    {
                        "username": "wscp",
                        "content": "If you used kahn\\'s algorithm in the first version of this, just use that solution and instead of counting the number of sorted nodes, append to a list instead. then that list will be the right answer."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you're passing the current index (to a DFS method) for the next vertice of the result **by value** (not by reference), you can return an index out of bounds if a cycle was detected. Otherwise, return the following index. `Tip`"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "use dfs to detect cycle and if cycle detected then return null list else use topsort to get order list"
                    },
                    {
                        "username": "debesis_27",
                        "content": "If someone is getting TLE for dfs solution, try passing the 2d vector by reference instead of passing it by value.\\nReference: https://www.tantalon.com/pete/cppopt/asyougo.htm#PassClassParametersByReference"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\\n\\nnumCourses =\\n3\\nprerequisites =\\n[[0,1],[0,2],[1,2]]\\n\\nOutput\\n[2,0, 1]\\nExpected\\n[2,1,0]\\n\\nMy code prints out a valid path that is possible to reach all num courses. Why aren\\'t test cases reflecting the possibility for different orderings.\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Notw that as per the input in order to do the first course you should have done the 0th one , but in your output 0 appears before 1 that isn\\'t correct .\\nHope that clears!"
                    },
                    {
                        "username": "parth-12345",
                        "content": "Result =Time limit exceeded\\n45/45 testcases passed\\nlast executed input- nothing\\nWhat is this behavior [@LeetCode](/LeetCode)?"
                    },
                    {
                        "username": "mayuksarkar12345",
                        "content": "When this question and its second part both has same kind of dependency then why when we change the given vector<vector<int>> &prerequisites into an adjacency list then here in this question we have to use\\n int n = numCourses;\\nvector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[1]].push_back(it[0]);\\n   }\\nBut in its first part if we use the same kind of change then it gives error so we have to use there \\n int n = numCourses;\\n   vector<int> adj[n];\\n   for (auto it : prerequisites)\\n   {\\n      adj[it[0]].push_back(it[1]);\\n   }\\n\\nso if in both question the dependency is same then why 2 different kind of changing is suitable ?\\n\\nif anybody know please clear my this doubt???????"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I used same for both :\\n\\n        vector<int>adj[numCourses];\\n        for(int i=0;i<prerequisites.size();i++)\\n        {\\n            adj[prerequisites[i][1]].push_back(prerequisites[i][0]);\\n        }"
                    },
                    {
                        "username": "Morpheus111",
                        "content": "well, the array i have, when i print it element by element, is correct. However, i just return the array and the site only sees \\']\\'. I am in C"
                    },
                    {
                        "username": "miglani_9121",
                        "content": "I think Toposort using dfs technique can\\'t be used to solve this question only Toposort+BFS is the correct method. Am i write?"
                    },
                    {
                        "username": "VinnyOnLC",
                        "content": "toposort using dfs runs extremely fast if you keep track of which vertices that were previously visited/handled (memoization-esque)"
                    }
                ]
            }
        ]
    }
]