[
    {
        "title": "Most Popular Video Creator",
        "question_content": "You are given two string arrays creators and ids, and an integer array views, all of length n. The ith video on a platform was created by creator[i], has an id of ids[i], and has views[i] views.\nThe popularity of a creator is the sum of the number of views on all of the creator's videos. Find the creator with the highest popularity and the id of their most viewed video.\n\n\tIf multiple creators have the highest popularity, find all of them.\n\tIf multiple videos have the highest view count for a creator, find the lexicographically smallest id.\n\nReturn a 2D array of strings answer where answer[i] = [creatori, idi] means that creatori has the highest popularity and idi is the id of their most popular video. The answer can be returned in any order.\n&nbsp;\nExample 1:\n\nInput: creators = [\"alice\",\"bob\",\"alice\",\"chris\"], ids = [\"one\",\"two\",\"three\",\"four\"], views = [5,10,5,4]\nOutput: [[\"alice\",\"one\"],[\"bob\",\"two\"]]\nExplanation:\nThe popularity of alice is 5 + 5 = 10.\nThe popularity of bob is 10.\nThe popularity of chris is 4.\nalice and bob are the most popular creators.\nFor bob, the video with the highest view count is \"two\".\nFor alice, the videos with the highest view count are \"one\" and \"three\". Since \"one\" is lexicographically smaller than \"three\", it is included in the answer.\n\nExample 2:\n\nInput: creators = [\"alice\",\"alice\",\"alice\"], ids = [\"a\",\"b\",\"c\"], views = [1,2,2]\nOutput: [[\"alice\",\"b\"]]\nExplanation:\nThe videos with id \"b\" and \"c\" have the highest view count.\nSince \"b\" is lexicographically smaller than \"c\", it is included in the answer.\n\n&nbsp;\nConstraints:\n\n\tn == creators.length == ids.length == views.length\n\t1 <= n <= 105\n\t1 <= creators[i].length, ids[i].length <= 5\n\tcreators[i] and ids[i] consist only of lowercase English letters.\n\t0 <= views[i] <= 105",
        "solutions": [
            {
                "id": 2758053,
                "title": "one-hashmap-no-sorting",
                "content": "**Algorithm**:\\n + Maintain a hashmap along with a class which will store:\\n      - **sum**       : Denotes the `total view count of a creator`, this will help us in finding popular creator among two different people.\\n      - **small**     : Denotes the `lexicographical smallest id` with greatest frequency of this creator.\\n      - **max_view**  : Denotes the `maximum view count of this creator` , this will help us in finding a single creators lexicographically smallest id with maximum view count at a particular video.\\n       \\n       \\n+  We will simple use a counter which will have the maximum view count among all creator.\\n+  We will use this count to find the creators with this total view count from hashmap.\\n\\n> We can use 3 different hashmap for 3 different values also, but in that case the repetition of same key thrice in the memory is costly as compared to binding all values for a single key.\\n\\n**Time** - O(n)\\n**Space** - O(n)\\n\\n# C++\\n    struct video{\\n        long sum = 0;\\n        string small;\\n        int max_view = 0;\\n    };\\n    \\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& ids, vector<int>& views){\\n        unordered_map<string, video> mp;\\n        long count = 0;\\n\\n        for (int i = 0; i < size(c); i++){\\n\\t\\t    // Check if creator present or not\\n            if (!mp.count(c[i])){\\n                mp[c[i]] = { views[i], ids[i], views[i] };\\n                count = max(count, mp[c[i]].sum);\\n                continue;\\n            }\\n        \\n\\t\\t    // If already present , update all parameters as said in above algorithm\\n            mp[c[i]].sum += views[i];\\n            if (mp[c[i]].max_view < views[i] || mp[c[i]].max_view == views[i] && ids[i] < mp[c[i]].small) {\\n                mp[c[i]].max_view = views[i];\\n                mp[c[i]].small = ids[i];\\n            }\\n    \\n            count = max(count, mp[c[i]].sum);\\n        }\\n\\n        //extract words with highest count of views\\n        vector<vector<string>> ans;\\n        for (auto &r: mp)\\n            if (r.second.sum == count)\\n                ans.push_back({ r.first, r.second.small });\\n\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Algorithm**:\\n + Maintain a hashmap along with a class which will store:\\n      - **sum**       : Denotes the `total view count of a creator`, this will help us in finding popular creator among two different people.\\n      - **small**     : Denotes the `lexicographical smallest id` with greatest frequency of this creator.\\n      - **max_view**  : Denotes the `maximum view count of this creator` , this will help us in finding a single creators lexicographically smallest id with maximum view count at a particular video.\\n       \\n       \\n+  We will simple use a counter which will have the maximum view count among all creator.\\n+  We will use this count to find the creators with this total view count from hashmap.\\n\\n> We can use 3 different hashmap for 3 different values also, but in that case the repetition of same key thrice in the memory is costly as compared to binding all values for a single key.\\n\\n**Time** - O(n)\\n**Space** - O(n)\\n\\n# C++\\n    struct video{\\n        long sum = 0;\\n        string small;\\n        int max_view = 0;\\n    };\\n    \\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& ids, vector<int>& views){\\n        unordered_map<string, video> mp;\\n        long count = 0;\\n\\n        for (int i = 0; i < size(c); i++){\\n\\t\\t    // Check if creator present or not\\n            if (!mp.count(c[i])){\\n                mp[c[i]] = { views[i], ids[i], views[i] };\\n                count = max(count, mp[c[i]].sum);\\n                continue;\\n            }\\n        \\n\\t\\t    // If already present , update all parameters as said in above algorithm\\n            mp[c[i]].sum += views[i];\\n            if (mp[c[i]].max_view < views[i] || mp[c[i]].max_view == views[i] && ids[i] < mp[c[i]].small) {\\n                mp[c[i]].max_view = views[i];\\n                mp[c[i]].small = ids[i];\\n            }\\n    \\n            count = max(count, mp[c[i]].sum);\\n        }\\n\\n        //extract words with highest count of views\\n        vector<vector<string>> ans;\\n        for (auto &r: mp)\\n            if (r.second.sum == count)\\n                ans.push_back({ r.first, r.second.small });\\n\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2758012,
                "title": "why-leetcode-why",
                "content": "# *The question was in the contest just to consume time*\\n\\nNote : Solution added Below\\n\\n![](https://i.pinimg.com/originals/9a/2b/3b/9a2b3b9411598ea9f4d26619a3d0c644.gif)\\n\\n\\n\\n**Solution 1 :** ***Using 3 Maps***\\n```\\nclass Solution {\\n\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        HashMap<String, Long> map_max = new HashMap<>(); //count maximum score\\n        HashMap<String, Integer> map = new HashMap<>();  //count totle score\\n        HashMap<String, ArrayList<Pair>> id = new HashMap<>(); //store ids in order with their views\\n        List<List<String>> ans = new ArrayList<>();\\n        long max = 0;\\n        for (int i = 0; i < views.length; i++) {\\n            if (!map.containsKey(creators[i])) map.put(creators[i], 0);\\n            if (!id.containsKey(creators[i])) id.put(creators[i], new ArrayList<>());\\n            if (!map_max.containsKey(creators[i])) map_max.put(creators[i], (long) 0);\\n\\t\\t\\t\\n\\t\\t\\t\\n            map.put(creators[i], map.get(creators[i]) + views[i]); //calculate score\\n            id.get(creators[i]).add(new Pair(ids[i], views[i]));\\n            map_max.put(creators[i], Math.max(map_max.get(creators[i]), views[i])); //store max score\\n\\n        }\\n        for (long num : map.values()) {\\n            max = Math.max(max, num);\\n        }\\n        ArrayList<Pair> list = new ArrayList<>();\\n\\n        for (String key : map.keySet()) {\\n            if (map.get(key) == max) {\\n                Collections.sort(id.get(key), (o1, o2) -> (o1.str.compareTo(o2.str))); //sort by lexicographical order\\n                for (Pair p : id.get(key)) {\\n                    if (p.num == map_max.get(key)) {\\n                        ans.add(new ArrayList<>(Arrays.asList(key, p.str)));\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n\\t\\n    class Pair {\\n        String str;\\n        long num;\\n        Pair(String s, long n) {\\n            str = s;\\n            num = n;\\n        }\\n    }\\n\\n}\\n\\n```\\n\\n**Solution 2 :** ***Using 2 Maps***\\n\\n*credit : @skate1512*\\n\\n```\\nclass Solution\\n{\\n    public:\\n        vector<vector < string>> mostPopularCreator(vector<string> &creators, vector<string> &ids, vector< int > &views)\\n        {\\n            int n = creators.size();\\n            unordered_map<string, long long > creatorViews;\\n            unordered_map<string, pair<int, string>> creatorMinID;\\n            long long mxViews = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                creatorViews[creators[i]] += views[i];\\n                if (creatorMinID.count(creators[i]))\\n                {\\n                    if (creatorMinID[creators[i]].first == views[i])\\n                    {\\n                        creatorMinID[creators[i]].second = min(creatorMinID[creators[i]].second, ids[i]);\\n                    }\\n                    else if (creatorMinID[creators[i]].first < views[i])\\n                        creatorMinID[creators[i]] = { views[i],\\n                            ids[i]\\n                        };\\n                }\\n                else\\n                {\\n                    creatorMinID[creators[i]] = { views[i],\\n                        ids[i]\\n                    };\\n                }\\n                mxViews = max(mxViews, creatorViews[creators[i]]);\\n            }\\n            vector<vector < string>> res;\\n            for (auto p: creatorViews)\\n            {\\n                if (p.second == mxViews)\\n                {\\n                    res.push_back({ p.first,\\n                        creatorMinID[p.first].second });\\n                }\\n            }\\n            return res;\\n        }\\n};\\n```\\n\\n**Solution 3 :** ***Using 1 Map***\\n\\n*credit : @dvisp*\\n\\n```\\nstruct video\\n{\\n    long sum = 0;\\n    string small;\\n    int max_view = 0;\\n};\\n\\nvector<vector < string>> mostPopularCreator(vector<string> &c, vector<string> &ids, vector< int > &views)\\n{\\n    unordered_map<string, video> mp;\\n    long count = 0;\\n\\n    for (int i = 0; i < size(c); i++)\\n    {\\n       \\t// Check if creator present or not\\n        if (!mp.count(c[i]))\\n        {\\n            mp[c[i]] = { views[i],\\n                ids[i],\\n                views[i]\\n            };\\n            count = max(count, mp[c[i]].sum);\\n            continue;\\n        }\\n\\n       \\t// If already present, update all parameters as said in above algorithm\\n        mp[c[i]].sum += views[i];\\n        if (mp[c[i]].max_view < views[i] || mp[c[i]].max_view == views[i] && ids[i] < mp[c[i]].small)\\n        {\\n            mp[c[i]].max_view = views[i];\\n            mp[c[i]].small = ids[i];\\n        }\\n\\n        count = max(count, mp[c[i]].sum);\\n    }\\n\\n   \\t//extract words with highest count of views\\n    vector<vector < string>> ans;\\n    for (auto &r: mp)\\n        if (r.second.sum == count)\\n            ans.push_back({ r.first,\\n                r.second.small });\\n\\n    return ans;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        HashMap<String, Long> map_max = new HashMap<>(); //count maximum score\\n        HashMap<String, Integer> map = new HashMap<>();  //count totle score\\n        HashMap<String, ArrayList<Pair>> id = new HashMap<>(); //store ids in order with their views\\n        List<List<String>> ans = new ArrayList<>();\\n        long max = 0;\\n        for (int i = 0; i < views.length; i++) {\\n            if (!map.containsKey(creators[i])) map.put(creators[i], 0);\\n            if (!id.containsKey(creators[i])) id.put(creators[i], new ArrayList<>());\\n            if (!map_max.containsKey(creators[i])) map_max.put(creators[i], (long) 0);\\n\\t\\t\\t\\n\\t\\t\\t\\n            map.put(creators[i], map.get(creators[i]) + views[i]); //calculate score\\n            id.get(creators[i]).add(new Pair(ids[i], views[i]));\\n            map_max.put(creators[i], Math.max(map_max.get(creators[i]), views[i])); //store max score\\n\\n        }\\n        for (long num : map.values()) {\\n            max = Math.max(max, num);\\n        }\\n        ArrayList<Pair> list = new ArrayList<>();\\n\\n        for (String key : map.keySet()) {\\n            if (map.get(key) == max) {\\n                Collections.sort(id.get(key), (o1, o2) -> (o1.str.compareTo(o2.str))); //sort by lexicographical order\\n                for (Pair p : id.get(key)) {\\n                    if (p.num == map_max.get(key)) {\\n                        ans.add(new ArrayList<>(Arrays.asList(key, p.str)));\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n\\t\\n    class Pair {\\n        String str;\\n        long num;\\n        Pair(String s, long n) {\\n            str = s;\\n            num = n;\\n        }\\n    }\\n\\n}\\n\\n```\n```\\nclass Solution\\n{\\n    public:\\n        vector<vector < string>> mostPopularCreator(vector<string> &creators, vector<string> &ids, vector< int > &views)\\n        {\\n            int n = creators.size();\\n            unordered_map<string, long long > creatorViews;\\n            unordered_map<string, pair<int, string>> creatorMinID;\\n            long long mxViews = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                creatorViews[creators[i]] += views[i];\\n                if (creatorMinID.count(creators[i]))\\n                {\\n                    if (creatorMinID[creators[i]].first == views[i])\\n                    {\\n                        creatorMinID[creators[i]].second = min(creatorMinID[creators[i]].second, ids[i]);\\n                    }\\n                    else if (creatorMinID[creators[i]].first < views[i])\\n                        creatorMinID[creators[i]] = { views[i],\\n                            ids[i]\\n                        };\\n                }\\n                else\\n                {\\n                    creatorMinID[creators[i]] = { views[i],\\n                        ids[i]\\n                    };\\n                }\\n                mxViews = max(mxViews, creatorViews[creators[i]]);\\n            }\\n            vector<vector < string>> res;\\n            for (auto p: creatorViews)\\n            {\\n                if (p.second == mxViews)\\n                {\\n                    res.push_back({ p.first,\\n                        creatorMinID[p.first].second });\\n                }\\n            }\\n            return res;\\n        }\\n};\\n```\n```\\nstruct video\\n{\\n    long sum = 0;\\n    string small;\\n    int max_view = 0;\\n};\\n\\nvector<vector < string>> mostPopularCreator(vector<string> &c, vector<string> &ids, vector< int > &views)\\n{\\n    unordered_map<string, video> mp;\\n    long count = 0;\\n\\n    for (int i = 0; i < size(c); i++)\\n    {\\n       \\t// Check if creator present or not\\n        if (!mp.count(c[i]))\\n        {\\n            mp[c[i]] = { views[i],\\n                ids[i],\\n                views[i]\\n            };\\n            count = max(count, mp[c[i]].sum);\\n            continue;\\n        }\\n\\n       \\t// If already present, update all parameters as said in above algorithm\\n        mp[c[i]].sum += views[i];\\n        if (mp[c[i]].max_view < views[i] || mp[c[i]].max_view == views[i] && ids[i] < mp[c[i]].small)\\n        {\\n            mp[c[i]].max_view = views[i];\\n            mp[c[i]].small = ids[i];\\n        }\\n\\n        count = max(count, mp[c[i]].sum);\\n    }\\n\\n   \\t//extract words with highest count of views\\n    vector<vector < string>> ans;\\n    for (auto &r: mp)\\n        if (r.second.sum == count)\\n            ans.push_back({ r.first,\\n                r.second.small });\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758009,
                "title": "python-c-java-rust-6-lines-using-hashmaps-and-min-max-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs hashmaps and min/max operations to obtain most popular values. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**. \\n\\n**Comment.** I explain the solution using Python code.\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: list[str], ids: list[str], views: list[int]) -> list[list[str]]:\\n\\t\\n        # total views by creator & list of videos by creator\\n        tot, vid = defaultdict(int), defaultdict(list)                    # Line 1\\n        \\n        # [1] compute total views for each creator and prepare\\n        #     a list of their videos to be searched for maximal\\n        #     views with lexicographically smallest id \\n        #     (if there are several top videos with equal views)\\n        for c, i, v in zip(creators, ids, views):                         # Line 2\\n            tot[c] += v                                                   # Line 3\\n            vid[c].append((-v,i))                                         # Line 4\\n        m = max(tot.values())                                             # Line 5\\n        \\n        # [2] minus sign for views allows to extract needed minimal id\\n        #     by simply applying min (that will extract max views first,\\n        #     and, if needed, smallest id afterwards)\\n        return [[c,min(v)[1]] for c, v in vid.items() if tot[c] == m]     # Line 6\\n```\\n\\nHere is the same solution in other languages.\\n<iframe src=\"https://leetcode.com/playground/ByoU3VJs/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: list[str], ids: list[str], views: list[int]) -> list[list[str]]:\\n\\t\\n        # total views by creator & list of videos by creator\\n        tot, vid = defaultdict(int), defaultdict(list)                    # Line 1\\n        \\n        # [1] compute total views for each creator and prepare\\n        #     a list of their videos to be searched for maximal\\n        #     views with lexicographically smallest id \\n        #     (if there are several top videos with equal views)\\n        for c, i, v in zip(creators, ids, views):                         # Line 2\\n            tot[c] += v                                                   # Line 3\\n            vid[c].append((-v,i))                                         # Line 4\\n        m = max(tot.values())                                             # Line 5\\n        \\n        # [2] minus sign for views allows to extract needed minimal id\\n        #     by simply applying min (that will extract max views first,\\n        #     and, if needed, smallest id afterwards)\\n        return [[c,min(v)[1]] for c, v in vid.items() if tot[c] == m]     # Line 6\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758346,
                "title": "c-solution-explained-using-map-with-o-n-very-simple-and-easy-to-understand",
                "content": "<b> Up Vote if you like the solution\\n\\n```\\n/*\\nConsider two map - one for keep track of total views and second for tracking best id with max view for each creator.\\n\\nSo the map storage looks like : { creator : view_count } & { creator : {view_count, id } }\\n\\nSo now just we need to keep track of max view count while adding to the map, and at the end, acan for the creators with sam view as that of max view found.\\n\\nNote: Do not forget to define view count as long long as the view count can be more than max int size.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        \\n        unordered_map<string, long long> mp;\\n        unordered_map<string, pair<int, string>> imp;\\n        long long mx = -1;\\n        for(int i = 0; i < creators.size(); ++i){\\n            long long v = views[i];\\n            if(mp.find(creators[i]) == mp.end()) mp[creators[i]] = v; \\n            else mp[creators[i]] += v;\\n            if(mx < mp[creators[i]]) mx = mp[creators[i]];\\n            \\n            if(imp.find(creators[i]) == imp.end())   imp[creators[i]] = {views[i], ids[i]};\\n            else{                                                           //Evaluate max view for each creator\\n                if( imp[creators[i]].first < views[i])  imp[creators[i]] = {views[i], ids[i]};\\n                else if(imp[creators[i]].first == views[i] && imp[creators[i]].second > ids[i]){\\n                    imp[creators[i]] = {views[i], ids[i]};\\n                }\\n            }\\n        }\\n        \\n        vector<vector<string>> ans;\\n        for(auto m: mp){                         //scan for the creators with view equal to max\\n            if(mx == m.second){\\n                ans.push_back({m.first, imp[m.first].second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nConsider two map - one for keep track of total views and second for tracking best id with max view for each creator.\\n\\nSo the map storage looks like : { creator : view_count } & { creator : {view_count, id } }\\n\\nSo now just we need to keep track of max view count while adding to the map, and at the end, acan for the creators with sam view as that of max view found.\\n\\nNote: Do not forget to define view count as long long as the view count can be more than max int size.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        \\n        unordered_map<string, long long> mp;\\n        unordered_map<string, pair<int, string>> imp;\\n        long long mx = -1;\\n        for(int i = 0; i < creators.size(); ++i){\\n            long long v = views[i];\\n            if(mp.find(creators[i]) == mp.end()) mp[creators[i]] = v; \\n            else mp[creators[i]] += v;\\n            if(mx < mp[creators[i]]) mx = mp[creators[i]];\\n            \\n            if(imp.find(creators[i]) == imp.end())   imp[creators[i]] = {views[i], ids[i]};\\n            else{                                                           //Evaluate max view for each creator\\n                if( imp[creators[i]].first < views[i])  imp[creators[i]] = {views[i], ids[i]};\\n                else if(imp[creators[i]].first == views[i] && imp[creators[i]].second > ids[i]){\\n                    imp[creators[i]] = {views[i], ids[i]};\\n                }\\n            }\\n        }\\n        \\n        vector<vector<string>> ans;\\n        for(auto m: mp){                         //scan for the creators with view equal to max\\n            if(mx == m.second){\\n                ans.push_back({m.first, imp[m.first].second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758160,
                "title": "passed-81-82-cases-but-missed-last-one-during-the-contest-why",
                "content": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, Long> popularity = new HashMap<>();\\n        Map<String, Map<String, Long>> info = new HashMap<>();\\n        List<List<String>> result = new ArrayList<>();\\n        int len = creators.length;\\n        long maxPop = 0;\\n        \\n        for (int i = 0; i < len; i++) {\\n            String name = creators[i];\\n            String id = ids[i];\\n            int view = views[i];\\n            long totalView = popularity.getOrDefault(name, (long)0) + (long)view;\\n            popularity.put(name, totalView);\\n            Map<String, Long> nameInfo = info.getOrDefault(name, new HashMap<>());\\n\\t\\t\\t\\n\\t\\t\\t// Uncomment next line and remove the line after will get the last one correct. The correct times of view is the maximum value instead of the accumulation of them.\\n\\t\\t\\t// long idView = Math.max(nameInfo.getOrDefault(id, (long)0), (long)view);\\n\\t\\t\\t\\n            long idView = nameInfo.getOrDefault(id, (long)0) + (long)view;\\n            nameInfo.put(id, idView);\\n            info.put(name, nameInfo);\\n            \\n            if (totalView > maxPop) {\\n                maxPop = totalView;\\n            }\\n        }\\n        \\n        for (Map.Entry<String, Long> entry : popularity.entrySet()) {\\n            if (entry.getValue() == maxPop) {\\n                List<String> temp = new ArrayList<>();\\n                temp.add(entry.getKey());\\n                result.add(temp);\\n            }\\n        }\\n        \\n        for (List<String> list : result) {\\n            String name = list.get(0);\\n            List<String> winner = new ArrayList<>();\\n            long maxView = 0;\\n            \\n            for (Map.Entry<String, Long> entry : info.get(name).entrySet()) {\\n                long view = entry.getValue();\\n                String id = entry.getKey();\\n                \\n                if (view > maxView) {\\n                    winner.clear();\\n                    winner.add(id);\\n                    maxView = view;\\n                } else if (view == maxView) {\\n                    winner.add(id);\\n                }\\n            }\\n            \\n            Collections.sort(winner);\\n            list.add(winner.get(0));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, Long> popularity = new HashMap<>();\\n        Map<String, Map<String, Long>> info = new HashMap<>();\\n        List<List<String>> result = new ArrayList<>();\\n        int len = creators.length;\\n        long maxPop = 0;\\n        \\n        for (int i = 0; i < len; i++) {\\n            String name = creators[i];\\n            String id = ids[i];\\n            int view = views[i];\\n            long totalView = popularity.getOrDefault(name, (long)0) + (long)view;\\n            popularity.put(name, totalView);\\n            Map<String, Long> nameInfo = info.getOrDefault(name, new HashMap<>());\\n\\t\\t\\t\\n\\t\\t\\t// Uncomment next line and remove the line after will get the last one correct. The correct times of view is the maximum value instead of the accumulation of them.\\n\\t\\t\\t// long idView = Math.max(nameInfo.getOrDefault(id, (long)0), (long)view);\\n\\t\\t\\t\\n            long idView = nameInfo.getOrDefault(id, (long)0) + (long)view;\\n            nameInfo.put(id, idView);\\n            info.put(name, nameInfo);\\n            \\n            if (totalView > maxPop) {\\n                maxPop = totalView;\\n            }\\n        }\\n        \\n        for (Map.Entry<String, Long> entry : popularity.entrySet()) {\\n            if (entry.getValue() == maxPop) {\\n                List<String> temp = new ArrayList<>();\\n                temp.add(entry.getKey());\\n                result.add(temp);\\n            }\\n        }\\n        \\n        for (List<String> list : result) {\\n            String name = list.get(0);\\n            List<String> winner = new ArrayList<>();\\n            long maxView = 0;\\n            \\n            for (Map.Entry<String, Long> entry : info.get(name).entrySet()) {\\n                long view = entry.getValue();\\n                String id = entry.getKey();\\n                \\n                if (view > maxView) {\\n                    winner.clear();\\n                    winner.add(id);\\n                    maxView = view;\\n                } else if (view == maxView) {\\n                    winner.add(id);\\n                }\\n            }\\n            \\n            Collections.sort(winner);\\n            list.add(winner.get(0));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759094,
                "title": "two-maps",
                "content": "This question is good to practice coding fluency (nothing fancy, but a lot of code).\\n\\nWe track total views for a creator in `sum_views`. And, for each creator, we track the most `popular` video.\\n\\nIn the end, we return all creators with total views equal to `max_views`, and their most popular video id.\\n\\n**C++**\\n```cpp\\nvector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n    unordered_map<string, long long> sum_views, popular;\\n    vector<vector<string>> res;\\n    long long max_views = 0;\\n    for (int i = 0; i < ids.size(); ++i) {\\n        max_views = max(max_views, sum_views[creators[i]] += views[i]);\\n        auto it = popular.find(creators[i]);\\n        if (it == end(popular))\\n            popular[creators[i]] = i;\\n        else if (views[i] >= views[it->second]) {\\n            if (views[i] == views[it->second])\\n               it->second = ids[i] < ids[it->second] ? i : it->second;\\n            else\\n               it->second = i;\\n        }\\n    }\\n    for (auto &[creator, sum] : sum_views)\\n        if (sum == max_views)\\n            res.push_back({creator, ids[popular[creator]]});\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n    unordered_map<string, long long> sum_views, popular;\\n    vector<vector<string>> res;\\n    long long max_views = 0;\\n    for (int i = 0; i < ids.size(); ++i) {\\n        max_views = max(max_views, sum_views[creators[i]] += views[i]);\\n        auto it = popular.find(creators[i]);\\n        if (it == end(popular))\\n            popular[creators[i]] = i;\\n        else if (views[i] >= views[it->second]) {\\n            if (views[i] == views[it->second])\\n               it->second = ids[i] < ids[it->second] ? i : it->second;\\n            else\\n               it->second = i;\\n        }\\n    }\\n    for (auto &[creator, sum] : sum_views)\\n        if (sum == max_views)\\n            res.push_back({creator, ids[popular[creator]]});\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758206,
                "title": "don-t-accumulate-the-same-video-of-same-user",
                "content": "The description of this question is not clear. The input can have multiple entry that are same video posted by same user. For exmaple,\\n\\n[\"alice\",\"alice\",\"alice\"]\\n[\"c\",\"b\",\"c\"]\\n[1,2,2]\\n\\nThe answer for this example is [\"alice\", \"b\"], not [\"alice\", \"c\"]. \\n\\nI wasted like at least 20mins on this issue. \\n\\n**Update:\\nLeetcode have fixed this by enforce the input has no duplicate ids for the same user. So the above example is not a valid test case now.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2758158,
                "title": "popular-video-creator",
                "content": "Hi,\\n\\nI solved this problem using hashmap, I used 3 hashmap\\'s storing the total, the highest views and the ids with respect to the highest view.\\n\\nAs mentioned in the given condition, if 2 id\\'s have same highest view then I compared them and stored the lexographically smallest one.\\n\\nSteps:\\n\\t1. Maintain 3 hashmaps and one max variable to see the maximum views\\n\\t2. Itrate through the given array\\n\\t3. Store the total, highest views and ids\\n\\t4. At last itrate through the map once and see which creators have total equal to max\\n\\t5. Get their respective ids and return the list.\\n\\n\\nKindly upvote if it helps,,,\\n\\n```\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n    \\tList<List<String>> res = new ArrayList();\\n    \\tHashMap<String, Long> total = new HashMap();\\n    \\tHashMap<String, Integer> highest = new HashMap();\\n    \\tHashMap<String, String> id = new HashMap();\\n    \\tlong max=0;\\n    \\tfor(int i=0; i<creators.length; i++){\\n    \\t\\tlong t = total.getOrDefault(creators[i], 0l);\\n    \\t\\tt=t+views[i];\\n    \\t\\ttotal.put(creators[i], t);\\n    \\t\\tint h = highest.getOrDefault(creators[i], -1);\\n    \\t\\tif(h==views[i]){\\n    \\t\\t\\tString exis = id.get(creators[i]);\\n    \\t\\t\\tif(exis.compareTo(ids[i])>0)\\n    \\t\\t\\t\\tid.put(creators[i], ids[i]);\\n    \\t\\t}\\n    \\t\\tif(h<views[i]){\\n    \\t\\t\\thighest.put(creators[i], views[i]);\\n    \\t\\t\\tid.put(creators[i], ids[i]);\\n    \\t\\t}\\n    \\t\\tmax = Math.max(t, max);\\n    \\t}\\n    \\tfor(Map.Entry<String, Long> e: total.entrySet()){\\n    \\t\\tif(e.getValue()==max){\\n    \\t\\t\\tList<String> one = new ArrayList<String>();\\n    \\t\\t\\tone.add(e.getKey());\\n    \\t\\t\\tone.add(id.get(e.getKey()));\\n    \\t\\t\\tres.add(one);\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi,\\n\\nI solved this problem using hashmap, I used 3 hashmap\\'s storing the total, the highest views and the ids with respect to the highest view.\\n\\nAs mentioned in the given condition, if 2 id\\'s have same highest view then I compared them and stored the lexographically smallest one.\\n\\nSteps:\\n\\t1. Maintain 3 hashmaps and one max variable to see the maximum views\\n\\t2. Itrate through the given array\\n\\t3. Store the total, highest views and ids\\n\\t4. At last itrate through the map once and see which creators have total equal to max\\n\\t5. Get their respective ids and return the list.\\n\\n\\nKindly upvote if it helps,,,\\n\\n```\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n    \\tList<List<String>> res = new ArrayList();\\n    \\tHashMap<String, Long> total = new HashMap();\\n    \\tHashMap<String, Integer> highest = new HashMap();\\n    \\tHashMap<String, String> id = new HashMap();\\n    \\tlong max=0;\\n    \\tfor(int i=0; i<creators.length; i++){\\n    \\t\\tlong t = total.getOrDefault(creators[i], 0l);\\n    \\t\\tt=t+views[i];\\n    \\t\\ttotal.put(creators[i], t);\\n    \\t\\tint h = highest.getOrDefault(creators[i], -1);\\n    \\t\\tif(h==views[i]){\\n    \\t\\t\\tString exis = id.get(creators[i]);\\n    \\t\\t\\tif(exis.compareTo(ids[i])>0)\\n    \\t\\t\\t\\tid.put(creators[i], ids[i]);\\n    \\t\\t}\\n    \\t\\tif(h<views[i]){\\n    \\t\\t\\thighest.put(creators[i], views[i]);\\n    \\t\\t\\tid.put(creators[i], ids[i]);\\n    \\t\\t}\\n    \\t\\tmax = Math.max(t, max);\\n    \\t}\\n    \\tfor(Map.Entry<String, Long> e: total.entrySet()){\\n    \\t\\tif(e.getValue()==max){\\n    \\t\\t\\tList<String> one = new ArrayList<String>();\\n    \\t\\t\\tone.add(e.getKey());\\n    \\t\\t\\tone.add(id.get(e.getKey()));\\n    \\t\\t\\tres.add(one);\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2758271,
                "title": "is-tc-for-duplicate-creator-and-id-correct",
                "content": "There is no description about how to handle duplicate ids and so I accumulated the number of views of the same creator and id.\\nHowever, this results in wrong answer. I spent a lot of time finding some bugs in the contest but failed. Below was my solution.\\nEspecially, TC 81/82 has lots of duplicates for creator \"l\" and id \"a\" and I think it should be the answer rather than \"l\" and \"vy\".\\nI guess this kind of duplicate handling code should be reassessed.\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string> &creators, vector<string> &ids, vector<int> &views) {\\n        int n = creators.size();        \\n        unordered_map<string, pair<long long, unordered_map<string, long long>>> stats;\\n        long long max_count = -1;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            stats[creators[i]].first += views[i];\\n            stats[creators[i]].second[ids[i]] += views[i];\\n            max_count = max(max_count, stats[creators[i]].first);\\n        }\\n        \\n        vector<vector<string>> answers;\\n        \\n        for (const auto &[name, total_idviews]: stats) {\\n            const auto &[total_cnt, id_views] = total_idviews;\\n            \\n            if (total_cnt == max_count) {\\n                long long max_view = -1;\\n                string max_id = \"\";\\n                for (const auto &[id, view]: id_views) {\\n                    if (view > max_view) {\\n                        max_view = view;\\n                        max_id = id;\\n                    } else if (view == max_view && id < max_id) {\\n                        max_id = id;\\n                    }\\n                }\\n\\n                answers.push_back({name, max_id});\\n            }\\n        }\\n        \\n        return answers;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string> &creators, vector<string> &ids, vector<int> &views) {\\n        int n = creators.size();        \\n        unordered_map<string, pair<long long, unordered_map<string, long long>>> stats;\\n        long long max_count = -1;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            stats[creators[i]].first += views[i];\\n            stats[creators[i]].second[ids[i]] += views[i];\\n            max_count = max(max_count, stats[creators[i]].first);\\n        }\\n        \\n        vector<vector<string>> answers;\\n        \\n        for (const auto &[name, total_idviews]: stats) {\\n            const auto &[total_cnt, id_views] = total_idviews;\\n            \\n            if (total_cnt == max_count) {\\n                long long max_view = -1;\\n                string max_id = \"\";\\n                for (const auto &[id, view]: id_views) {\\n                    if (view > max_view) {\\n                        max_view = view;\\n                        max_id = id;\\n                    } else if (view == max_view && id < max_id) {\\n                        max_id = id;\\n                    }\\n                }\\n\\n                answers.push_back({name, max_id});\\n            }\\n        }\\n        \\n        return answers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758377,
                "title": "why-your-solution-fail-detal-analysis-for-question",
                "content": "I\\'m pretty sure you know how to solve this problem, using hashmap.\\nBut even you know it, it\\'s hard to pass this problem, because its poor and ambiguous description of problem. If you don\\'t know why you fails this problem. Don\\'t worry, it is the fault of this problem, not your ability to apply hashmap to solve the problems.\\n\\nHere are some points to pay attention but not in description clearly.\\n1. All videos are unique, there are n videos, whatever the id or creator of the video, they are unique, which means we don\\'t need to add them up for the records with the same creator and id.\\n2. id and creator are not unique, for the replicated creator name, it refers to the same creator, the old one or a new creator. For the replicated id, it refers to a new video.\\n3. For each creator, their views are cumulative.\\n\\nSo to solve this problem, we need 2 hashmap, one is to record the videos info of each creator.\\n`creator2ids = creator: str -> Array<(views: int, ids: str)>`\\nAnother is to record the views of a creator have in total.\\n`creator2v = creator: str -> views: int`\\n\\nFirstly, we count up the max views for creators(may be more one creators), at the same time, we get the videos info list for each creator.\\n\\nAnd then, we get the video with max views(may be more than one) for the creators we just picked up based on `creator2ids`. For multiple videos, we picked up the videos with the highest views and then sort them as lexicographical order.\\n\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        creator2v = defaultdict(int)\\n        id2v = defaultdict(int)\\n        creator2id = defaultdict(list)\\n        n = len(creators)\\n        maxView = 0\\n        maxViewCreators = set()\\n        for i in range(n):\\n            c = creators[i]\\n            creator2id[c].append((views[i], ids[i]))\\n            creator2v[c] += views[i]\\n            if(maxView==creator2v[c]):\\n                maxViewCreators.add(c)\\n            elif(maxView<creator2v[c]):\\n                maxView = creator2v[c]\\n                maxViewCreators = {c}\\n        res = []\\n        # print(maxViewCreators)\\n        for creator in maxViewCreators:            \\n            idList = creator2id[creator]\\n            # print(idList)\\n            idList.sort(reverse=True)\\n            maxViewinId = idList[0][0]\\n            maxViewIdList = []\\n            for each in idList:\\n                if(maxViewinId == each[0]):\\n                    maxViewIdList.append(each[1])\\n            maxViewIdList.sort()\\n            # print(\\'same view:\\',maxViewIdList)\\n            res.append([creator, maxViewIdList[0]])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        creator2v = defaultdict(int)\\n        id2v = defaultdict(int)\\n        creator2id = defaultdict(list)\\n        n = len(creators)\\n        maxView = 0\\n        maxViewCreators = set()\\n        for i in range(n):\\n            c = creators[i]\\n            creator2id[c].append((views[i], ids[i]))\\n            creator2v[c] += views[i]\\n            if(maxView==creator2v[c]):\\n                maxViewCreators.add(c)\\n            elif(maxView<creator2v[c]):\\n                maxView = creator2v[c]\\n                maxViewCreators = {c}\\n        res = []\\n        # print(maxViewCreators)\\n        for creator in maxViewCreators:            \\n            idList = creator2id[creator]\\n            # print(idList)\\n            idList.sort(reverse=True)\\n            maxViewinId = idList[0][0]\\n            maxViewIdList = []\\n            for each in idList:\\n                if(maxViewinId == each[0]):\\n                    maxViewIdList.append(each[1])\\n            maxViewIdList.sort()\\n            # print(\\'same view:\\',maxViewIdList)\\n            res.append([creator, maxViewIdList[0]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758103,
                "title": "easy-to-understand-hashmap-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) \\n    {\\n        int n = ids.size();\\n        map<string, vector<pair<int, string>>>mp1; //creator => {views, ids}\\n        map<string, long long>mp2;  //creator => popularity\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp2[creators[i]] += views[i]; //sum all views of a creator [Popularity]\\n            mp1[creators[i]].push_back({views[i], ids[i]}); \\n        }\\n        //=================================\\n        long long mxPopularity = 0; //maximum Popularity\\n        for (auto it : mp2)\\n        {\\n            long long popularity = it.second;\\n            mxPopularity = max(mxPopularity, popularity);\\n        }\\n        //========================================\\n        vector<vector<string>>ans;\\n        for (auto it : mp2)\\n        {\\n            string creator = it.first;\\n            long long popularity = it.second;\\n            if (popularity == mxPopularity)\\n            {\\n                //sort all the videos of curr creator in decreasing order of views\\n                //if views same,  sort on basis of lexicographic order of ids\\n                sort(mp1[creator].begin(), mp1[creator].end(), [](pair<int, string>& a, pair<int, string>& b)->bool{\\n                    if (a.first > b.first) return true;\\n                    else if (a.first < b.first) return false;\\n                    else return (a.second < b.second);\\n                });\\n                string mostViewed = mp1[creator][0].second;\\n                ans.push_back({creator, mostViewed});\\n            }\\n        }\\n        //===============================================\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) \\n    {\\n        int n = ids.size();\\n        map<string, vector<pair<int, string>>>mp1; //creator => {views, ids}\\n        map<string, long long>mp2;  //creator => popularity\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp2[creators[i]] += views[i]; //sum all views of a creator [Popularity]\\n            mp1[creators[i]].push_back({views[i], ids[i]}); \\n        }\\n        //=================================\\n        long long mxPopularity = 0; //maximum Popularity\\n        for (auto it : mp2)\\n        {\\n            long long popularity = it.second;\\n            mxPopularity = max(mxPopularity, popularity);\\n        }\\n        //========================================\\n        vector<vector<string>>ans;\\n        for (auto it : mp2)\\n        {\\n            string creator = it.first;\\n            long long popularity = it.second;\\n            if (popularity == mxPopularity)\\n            {\\n                //sort all the videos of curr creator in decreasing order of views\\n                //if views same,  sort on basis of lexicographic order of ids\\n                sort(mp1[creator].begin(), mp1[creator].end(), [](pair<int, string>& a, pair<int, string>& b)->bool{\\n                    if (a.first > b.first) return true;\\n                    else if (a.first < b.first) return false;\\n                    else return (a.second < b.second);\\n                });\\n                string mostViewed = mp1[creator][0].second;\\n                ans.push_back({creator, mostViewed});\\n            }\\n        }\\n        //===============================================\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758104,
                "title": "python-hashmap-solution-no-sorting",
                "content": "Approach: \\nI have declared a hashmap to collect the following values,\\n1. total number current views for the creator\\n2. store the lexicographic id of the creator\\'s popular video\\n3. current popular view of the creator\\n\\nSo my final hashmap for the given basic test case looks like {\\'alice\\': [10, \\'one\\', 5], \\'bob\\': [10, \\'two\\', 10], \\'chris\\': [4, \\'four\\', 4]}\\nmemo[\"alice\"][0] = total number of views for alice\\nmemo[\"alice\"][1] = min lexicographic id for alice\\'s popular video\\nmemo[\"alice\"][2] = max popular video views for alice\\n\\nAlongside with these, I have also initiated overall_max_popular_video_count to track the max_total_number_of_views for a creator\\nOnce we collect all the above mentioned values,\\nI compare each and every creator\\'s total number of views with the current_popular_video_count and make my result array.\\nThanks for reading!\\n\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        memo = {}\\n\\t\\t#tracking the max popular video count\\n        overall_max_popular_video_count = -1\\n        #looping over the creators\\n        for i in range(len(creators)):\\n            if creators[i] in memo:\\n                #Step 1: update number of views for the creator\\n                memo[creators[i]][0] += views[i]\\n                #Step 2: update current_popular_video_view and id_of_most_popular_video_so_far\\n                if memo[creators[i]][2] < views[i]:\\n                    memo[creators[i]][1] = ids[i]\\n                    memo[creators[i]][2] = views[i]\\n                #Step 2a: finding the lexicographically smallest id as we hit the current_popularity_video_view again!\\n                elif memo[creators[i]][2] == views[i]:\\n                    memo[creators[i]][1] = min(memo[creators[i]][1],ids[i])\\n            else:\\n\\t\\t\\t#adding new entry to our memo\\n\\t\\t\\t#new entry is of the format memo[creator[i]] = [total number current views for the creator, store the lexicographic id of the popular video, current popular view of the creator]\\n                memo[creators[i]] = [views[i],ids[i],views[i]]\\n\\t\\t\\t#track the max popular video count\\n            overall_max_popular_video_count = max(memo[creators[i]][0],overall_max_popular_video_count)\\n        \\n        result = []\\n        for i in memo:\\n            if memo[i][0] == overall_max_popular_video_count:\\n                result.append([i,memo[i][1]])\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        memo = {}\\n\\t\\t#tracking the max popular video count\\n        overall_max_popular_video_count = -1\\n        #looping over the creators\\n        for i in range(len(creators)):\\n            if creators[i] in memo:\\n                #Step 1: update number of views for the creator\\n                memo[creators[i]][0] += views[i]\\n                #Step 2: update current_popular_video_view and id_of_most_popular_video_so_far\\n                if memo[creators[i]][2] < views[i]:\\n                    memo[creators[i]][1] = ids[i]\\n                    memo[creators[i]][2] = views[i]\\n                #Step 2a: finding the lexicographically smallest id as we hit the current_popularity_video_view again!\\n                elif memo[creators[i]][2] == views[i]:\\n                    memo[creators[i]][1] = min(memo[creators[i]][1],ids[i])\\n            else:\\n\\t\\t\\t#adding new entry to our memo\\n\\t\\t\\t#new entry is of the format memo[creator[i]] = [total number current views for the creator, store the lexicographic id of the popular video, current popular view of the creator]\\n                memo[creators[i]] = [views[i],ids[i],views[i]]\\n\\t\\t\\t#track the max popular video count\\n            overall_max_popular_video_count = max(memo[creators[i]][0],overall_max_popular_video_count)\\n        \\n        result = []\\n        for i in memo:\\n            if memo[i][0] == overall_max_popular_video_count:\\n                result.append([i,memo[i][1]])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757985,
                "title": "c-comparator-sort",
                "content": "**Store the values [creator, (total(view)] and [creator, (all id)] in 2 diffrent maps**\\n**map store a  values in sorted order**\\n**[creator, arrayof(id)]] stores all the id of creator**\\n**We need to sort the arrayof(id) corrosponding to the max views**\\n\\n```\\n#define ll long long\\nclass Solution {\\nprivate:\\n    // If the Total_Views of Creator is Same then it Sort according to lexicographically smallest String\\n    // else it sort according to Decreasing order of Total_Views\\n    static bool cmp(pair<ll,string> p1, pair<ll,string> p2){\\n        if(p1.first==p2.first)    return p1.second<p2.second;\\n        return p1.first>p2.first;\\n    }\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& id, vector<int>& v) {\\n        vector<vector<string>> ans;\\n        ll n = c.size(), maxi = INT_MIN;\\n        map<string, ll> m1;             // Creator, Total_Views\\n        map<string, vector<pair<ll,string>>> m2;    // Creator, ID\\n        \\n        // Store the values \\n        for(int i=0; i<n; i++){\\n            m1[c[i]] += v[i];\\n            m2[c[i]].push_back(make_pair(v[i], id[i]));\\n            maxi = max(maxi, m1[c[i]]);            // Store the max_number_View\\n        }\\n        \\n        for(auto &[l, r]: m1){            \\n\\t\\t\\t// if Views == Max_Views\\n            if(r == maxi){\\n                sort(m2[l].begin(), m2[l].end(), cmp);  // Comparator Sort\\n                ans.push_back({l, m2[l].front().second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\nprivate:\\n    // If the Total_Views of Creator is Same then it Sort according to lexicographically smallest String\\n    // else it sort according to Decreasing order of Total_Views\\n    static bool cmp(pair<ll,string> p1, pair<ll,string> p2){\\n        if(p1.first==p2.first)    return p1.second<p2.second;\\n        return p1.first>p2.first;\\n    }\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& id, vector<int>& v) {\\n        vector<vector<string>> ans;\\n        ll n = c.size(), maxi = INT_MIN;\\n        map<string, ll> m1;             // Creator, Total_Views\\n        map<string, vector<pair<ll,string>>> m2;    // Creator, ID\\n        \\n        // Store the values \\n        for(int i=0; i<n; i++){\\n            m1[c[i]] += v[i];\\n            m2[c[i]].push_back(make_pair(v[i], id[i]));\\n            maxi = max(maxi, m1[c[i]]);            // Store the max_number_View\\n        }\\n        \\n        for(auto &[l, r]: m1){            \\n\\t\\t\\t// if Views == Max_Views\\n            if(r == maxi){\\n                sort(m2[l].begin(), m2[l].end(), cmp);  // Comparator Sort\\n                ans.push_back({l, m2[l].front().second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758439,
                "title": "using-map-of-priorityqueue",
                "content": "```\\nclass pair{\\n    String x;\\n    int y;\\n    pair(String x1,int y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        List<List<String>> l=new ArrayList<>();\\n        Map<String,Long> m=new HashMap<>();\\n        Map<String,PriorityQueue<pair>> m1=new HashMap<>();\\n        int n=creators.length;\\n        for(int i=0;i<n;i++){\\n            if(!m.containsKey(creators[i])){\\n                m.put(creators[i],(long)views[i]);\\n            }\\n            else\\n                m.put(creators[i],(m.get(creators[i])+(long)views[i]));\\n            if(!m1.containsKey(creators[i])){\\n                m1.put(creators[i],new PriorityQueue<>((a,b)->a.y==b.y?(a.x.compareTo(b.x)):b.y-a.y));\\n            }    \\n            m1.get(creators[i]).add(new pair(ids[i],views[i]));\\n        }\\n        long max=0;\\n        for(long t:m.values())max=Math.max(max,t);\\n        \\n        for(String u:m.keySet()){\\n            \\n            if(m.get(u)==max){\\n                List<String> temp=new ArrayList<>();\\n                temp.add(u);\\n                PriorityQueue<pair> s1=m1.get(u);\\n                temp.add(s1.poll().x);\\n                l.add(temp);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass pair{\\n    String x;\\n    int y;\\n    pair(String x1,int y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        List<List<String>> l=new ArrayList<>();\\n        Map<String,Long> m=new HashMap<>();\\n        Map<String,PriorityQueue<pair>> m1=new HashMap<>();\\n        int n=creators.length;\\n        for(int i=0;i<n;i++){\\n            if(!m.containsKey(creators[i])){\\n                m.put(creators[i],(long)views[i]);\\n            }\\n            else\\n                m.put(creators[i],(m.get(creators[i])+(long)views[i]));\\n            if(!m1.containsKey(creators[i])){\\n                m1.put(creators[i],new PriorityQueue<>((a,b)->a.y==b.y?(a.x.compareTo(b.x)):b.y-a.y));\\n            }    \\n            m1.get(creators[i]).add(new pair(ids[i],views[i]));\\n        }\\n        long max=0;\\n        for(long t:m.values())max=Math.max(max,t);\\n        \\n        for(String u:m.keySet()){\\n            \\n            if(m.get(u)==max){\\n                List<String> temp=new ArrayList<>();\\n                temp.add(u);\\n                PriorityQueue<pair> s1=m1.get(u);\\n                temp.add(s1.poll().x);\\n                l.add(temp);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758445,
                "title": "java-solution-with-explanation-single-hashmap-no-sorting-o-n-beats-85",
                "content": "Logic\\n1. Create a custom node for each creator that stores \\n\\t- totalViewCount (sum of view count for all videos), \\n\\t- maxViewCount (maximum view count for a single video), \\n\\t- popularVideo: video that has been watched the most. If there are multiple videos, then store the lexicographically smallest video)\\n2. Populate the map with the above values for each creator entry\\n3. Keep track of a global `maxViewCount` that keeps track of the maximum view count for all videos across creators\\n\\t- during creator traversal, if we find any creator that has higher view count than this value; then clear existing list and add the current creator to the list\\n\\t- if current creator\\'s total view is equal to the maxViewCount, then simply add the creator to the list\\n\\t- Keep track of popularCreators in the list because there can be more than one creator that is popular according to our definition\\n\\n\\n```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        List<List<String>> result = new LinkedList<>();\\n        Map<String, CreatorNode> map = new HashMap<>();\\n        int length = creators.length, viewCount;\\n        long maxViewCount = 0;\\n        Set<String> popularCreators = new HashSet<>();\\n        String creator, id;\\n        CreatorNode temp;\\n\\n        for (int index = 0; index < length; index++){\\n            creator = creators[index];\\n            viewCount = views[index];\\n            id = ids[index];\\n            if (map.containsKey(creator)){\\n                temp = map.get(creator);\\n                temp.totalViewCount += viewCount;\\n                if (temp.maxViews < viewCount){\\n                    temp.maxViews = viewCount;\\n                    temp.popularVideo = id;\\n                } else if (temp.maxViews == viewCount){\\n                    temp.popularVideo = (id.compareTo(temp.popularVideo) < 0) ? id  : temp.popularVideo;\\n                }\\n            } else {\\n                temp = new CreatorNode(viewCount, viewCount, id);\\n                map.put(creator, temp);\\n            }\\n\\n            if (maxViewCount < temp.totalViewCount){\\n                maxViewCount = temp.totalViewCount;\\n                popularCreators.clear();\\n                popularCreators.add(creator);\\n            } else if (maxViewCount == temp.totalViewCount){\\n                popularCreators.add(creator);\\n            }\\n        }\\n\\n        for (String tempCreator : popularCreators){\\n            result.add(new LinkedList<>(Arrays.asList(tempCreator, map.get(tempCreator).popularVideo)));\\n        }\\n\\n        return result;\\n    }\\n    static class CreatorNode {\\n        long totalViewCount;\\n        int maxViews;\\n        String popularVideo;\\n\\n        public CreatorNode(long totalViewCount, int maxViews, String popularVideo) {\\n            this.totalViewCount = totalViewCount;\\n            this.maxViews = maxViews;\\n            this.popularVideo = popularVideo;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        List<List<String>> result = new LinkedList<>();\\n        Map<String, CreatorNode> map = new HashMap<>();\\n        int length = creators.length, viewCount;\\n        long maxViewCount = 0;\\n        Set<String> popularCreators = new HashSet<>();\\n        String creator, id;\\n        CreatorNode temp;\\n\\n        for (int index = 0; index < length; index++){\\n            creator = creators[index];\\n            viewCount = views[index];\\n            id = ids[index];\\n            if (map.containsKey(creator)){\\n                temp = map.get(creator);\\n                temp.totalViewCount += viewCount;\\n                if (temp.maxViews < viewCount){\\n                    temp.maxViews = viewCount;\\n                    temp.popularVideo = id;\\n                } else if (temp.maxViews == viewCount){\\n                    temp.popularVideo = (id.compareTo(temp.popularVideo) < 0) ? id  : temp.popularVideo;\\n                }\\n            } else {\\n                temp = new CreatorNode(viewCount, viewCount, id);\\n                map.put(creator, temp);\\n            }\\n\\n            if (maxViewCount < temp.totalViewCount){\\n                maxViewCount = temp.totalViewCount;\\n                popularCreators.clear();\\n                popularCreators.add(creator);\\n            } else if (maxViewCount == temp.totalViewCount){\\n                popularCreators.add(creator);\\n            }\\n        }\\n\\n        for (String tempCreator : popularCreators){\\n            result.add(new LinkedList<>(Arrays.asList(tempCreator, map.get(tempCreator).popularVideo)));\\n        }\\n\\n        return result;\\n    }\\n    static class CreatorNode {\\n        long totalViewCount;\\n        int maxViews;\\n        String popularVideo;\\n\\n        public CreatorNode(long totalViewCount, int maxViews, String popularVideo) {\\n            this.totalViewCount = totalViewCount;\\n            this.maxViews = maxViews;\\n            this.popularVideo = popularVideo;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800978,
                "title": "96-fastest-94-less-memeory-easy-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<vector < string>> mostPopularCreator(vector<string> &cr, vector<string> &id, vector< int > &views)\\n        {\\n            map<string, int> m;//stores string with sum\\n            map<string, int> m1;//stores string with index with max view count\\n            vector<vector < string>> vec;\\n            int mx = 0;\\n            for (int i = 0; i < cr.size(); i++)\\n            {\\n                if (m.find(cr[i]) == m.end())\\n                {\\n                    m[cr[i]] = views[i];\\n                    m1[cr[i]] = i;\\n                }\\n                else\\n                {\\n                    m[cr[i]] += views[i];\\n                    if (views[m1[cr[i]]] < views[i])\\n                        m1[cr[i]] = i;\\n                    else if (views[m1[cr[i]]] == views[i])\\n                    {\\n                        if (id[i] < id[m1[cr[i]]])\\n                            m1[cr[i]] = i;\\n                    }\\n                }\\n                mx = max(mx, m[cr[i]]);//finding maximum views\\n            }\\n            for (auto i: m)\\n            {\\n                if (mx == i.second)\\n                {\\n                    vec.push_back({ i.first,id[m1[i.first]] });\\n                }\\n            }\\n            return vec;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<vector < string>> mostPopularCreator(vector<string> &cr, vector<string> &id, vector< int > &views)\\n        {\\n            map<string, int> m;//stores string with sum\\n            map<string, int> m1;//stores string with index with max view count\\n            vector<vector < string>> vec;\\n            int mx = 0;\\n            for (int i = 0; i < cr.size(); i++)\\n            {\\n                if (m.find(cr[i]) == m.end())\\n                {\\n                    m[cr[i]] = views[i];\\n                    m1[cr[i]] = i;\\n                }\\n                else\\n                {\\n                    m[cr[i]] += views[i];\\n                    if (views[m1[cr[i]]] < views[i])\\n                        m1[cr[i]] = i;\\n                    else if (views[m1[cr[i]]] == views[i])\\n                    {\\n                        if (id[i] < id[m1[cr[i]]])\\n                            m1[cr[i]] = i;\\n                    }\\n                }\\n                mx = max(mx, m[cr[i]]);//finding maximum views\\n            }\\n            for (auto i: m)\\n            {\\n                if (mx == i.second)\\n                {\\n                    vec.push_back({ i.first,id[m1[i.first]] });\\n                }\\n            }\\n            return vec;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760380,
                "title": "c-single-map-of-tuples-399-ms-100",
                "content": "I guess the stats are not quite up to date, but it looks like this one was a lot faster than other solutions:\\n\\n### Approach 1: map of tuples\\n\\nIt would mayb be cleaner to use ```struct``` instead of a ```tuple```, oh well, sue me. :)\\n\\n```cpp\\n    vector<vector<string>> mostPopularCreator(\\n        const vector<string>& creators, const vector<string>& ids, const vector<int>& views) {\\n        const int n = size(creators);\\n        unordered_map<string, tuple<long, long, string>> vpcs;\\n        long mvpc = 0;\\n        for (int i = 0; i < n; ++i) {\\n            auto it = vpcs.find(creators[i]);\\n            if (it == end(vpcs)) {\\n                mvpc = max<long>(mvpc, views[i]);\\n                vpcs[creators[i]] = {views[i], views[i], ids[i]};\\n            } else {\\n                mvpc = max(mvpc, get<0>(it->second) += views[i]);\\n                if (views[i] > get<1>(it->second)) {\\n                    get<1>(it->second) = views[i];\\n                    get<2>(it->second) = ids[i];\\n                } else if (views[i] == get<1>(it->second)) {\\n                    get<2>(it->second) = min(get<2>(it->second), ids[i]);\\n                }\\n            }\\n        }\\n        vector<vector<string>> ans;\\n        for (const auto& [creator, v] : vpcs)\\n            if (get<0>(v) == mvpc) ans.push_back({creator, get<2>(v)});\\n\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the size of ```creators``` then the\\n  * Time complexity is $$O(n)$$, and the\\n  * Space complexity is $$O(n)$$ too.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```struct```\n```tuple```\n```cpp\\n    vector<vector<string>> mostPopularCreator(\\n        const vector<string>& creators, const vector<string>& ids, const vector<int>& views) {\\n        const int n = size(creators);\\n        unordered_map<string, tuple<long, long, string>> vpcs;\\n        long mvpc = 0;\\n        for (int i = 0; i < n; ++i) {\\n            auto it = vpcs.find(creators[i]);\\n            if (it == end(vpcs)) {\\n                mvpc = max<long>(mvpc, views[i]);\\n                vpcs[creators[i]] = {views[i], views[i], ids[i]};\\n            } else {\\n                mvpc = max(mvpc, get<0>(it->second) += views[i]);\\n                if (views[i] > get<1>(it->second)) {\\n                    get<1>(it->second) = views[i];\\n                    get<2>(it->second) = ids[i];\\n                } else if (views[i] == get<1>(it->second)) {\\n                    get<2>(it->second) = min(get<2>(it->second), ids[i]);\\n                }\\n            }\\n        }\\n        vector<vector<string>> ans;\\n        for (const auto& [creator, v] : vpcs)\\n            if (get<0>(v) == mvpc) ans.push_back({creator, get<2>(v)});\\n\\n        return ans;\\n    }\\n```\n```creators```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758437,
                "title": "best-time-consuming-question",
                "content": "It took whole 1 hour to solve this \\uD83D\\uDE25\\uD83D\\uDE25\\n```\\nclass Solution {\\npublic:\\n    bool comp (string s1, string  s2)\\n      {\\n        int n = s1.size(),m=s2.size();\\n        int mini = min(m,n);\\n        for(int i=0;i<mini;i++){\\n            char c1 = s1[i];\\n            char c2 = s2[i];\\n            if(c1<c2) return false;\\n            if(c1>c2) return true;\\n       }\\n        return true;\\n     \\n         }\\n  \\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        long long n = creators.size(),maxi=0;\\n        vector<vector<string>>ans;\\n        map<string,string>mp1;\\n        map<string,long long>mp;\\n        map<string,long long>mp3;\\n            // priority_queue<pair<int, string> > mp;\\n        for(int i=0;i<n;i++){\\n            \\n            string x = mp1[creators[i]];\\n            string y = ids[i];\\n            if(x==\"\" || mp3[creators[i]]<views[i]) {\\n                mp1[creators[i]] = ids[i];\\n                mp3[creators[i]] = views[i];\\n            }\\n            //         else if(mp3[creators[i]]>views[i]){\\n            //     continue;\\n            // }     \\n              \\n        else if(mp3[creators[i]] == views[i]) {\\n            if(comp(x,y)==true) mp1[creators[i]] = ids[i];\\n        }\\n            \\n             mp[creators[i]] += views[i];\\n            long long var  = mp3[creators[i]];\\n            // mp3[creators[i]] =  max(var,views[i]);\\n            if(views[i]>var) {\\n                 mp3[creators[i]] = views[i];\\n            }\\n       \\n         }\\n        for(auto it:mp){\\n            // maxi = max(maxi,it.second);\\n            if(maxi<it.second){\\n                maxi = it.second;\\n            }\\n        }\\n        for(auto it:mp1){\\n            if(mp[it.first]==maxi) ans.push_back({it.first,it.second});\\n        }\\n        cout<<maxi<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool comp (string s1, string  s2)\\n      {\\n        int n = s1.size(),m=s2.size();\\n        int mini = min(m,n);\\n        for(int i=0;i<mini;i++){\\n            char c1 = s1[i];\\n            char c2 = s2[i];\\n            if(c1<c2) return false;\\n            if(c1>c2) return true;\\n       }\\n        return true;\\n     \\n         }\\n  \\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        long long n = creators.size(),maxi=0;\\n        vector<vector<string>>ans;\\n        map<string,string>mp1;\\n        map<string,long long>mp;\\n        map<string,long long>mp3;\\n            // priority_queue<pair<int, string> > mp;\\n        for(int i=0;i<n;i++){\\n            \\n            string x = mp1[creators[i]];\\n            string y = ids[i];\\n            if(x==\"\" || mp3[creators[i]]<views[i]) {\\n                mp1[creators[i]] = ids[i];\\n                mp3[creators[i]] = views[i];\\n            }\\n            //         else if(mp3[creators[i]]>views[i]){\\n            //     continue;\\n            // }     \\n              \\n        else if(mp3[creators[i]] == views[i]) {\\n            if(comp(x,y)==true) mp1[creators[i]] = ids[i];\\n        }\\n            \\n             mp[creators[i]] += views[i];\\n            long long var  = mp3[creators[i]];\\n            // mp3[creators[i]] =  max(var,views[i]);\\n            if(views[i]>var) {\\n                 mp3[creators[i]] = views[i];\\n            }\\n       \\n         }\\n        for(auto it:mp){\\n            // maxi = max(maxi,it.second);\\n            if(maxi<it.second){\\n                maxi = it.second;\\n            }\\n        }\\n        for(auto it:mp1){\\n            if(mp[it.first]==maxi) ans.push_back({it.first,it.second});\\n        }\\n        cout<<maxi<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2758315,
                "title": "java-hashmap-solution-sorting",
                "content": "```\\nclass Solution {\\n    public class Pair implements Comparable<Pair>{\\n        int view;\\n        String id;\\n        \\n        Pair(int view, String id){\\n            this.view = view;\\n            this.id = id;\\n        }\\n        \\n        public int compareTo(Pair o){\\n            if(this.view != o.view){ //if views are different, then sort Decreasingly\\n                return o.view - this.view; \\n            }else{\\n                return this.id.compareTo(o.id); //if views are same, then sort lexicographically\\n            }\\n        }\\n    }\\n    \\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        HashMap<String, Integer> map1 = new HashMap<>(); //creators VS total views\\n        for(int i = 0; i < creators.length; ++i){ //O(N)\\n            String c = creators[i];\\n            map1.put(c, map1.getOrDefault(c, 0) + views[i]);\\n        }\\n        \\n        \\n        HashMap<String, ArrayList<Pair>> map2 = new HashMap<>(); //creators VS (His/Her all videos id\\'s list with there views)\\n        for(int i = 0; i < creators.length; ++i){ //O(N)\\n            String c = creators[i];\\n            if(map2.containsKey(c) == false){\\n                map2.put(c, new ArrayList<>());\\n            }\\n            map2.get(c).add(new Pair(views[i], ids[i])); //store video with id, and with there respective views\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        \\n        int max = 0;\\n        for(String key : map1.keySet()){ //finding the maximum views of the creator\\n            max = Math.max(max, map1.get(key));\\n        }\\n        \\n        for(String key : map1.keySet()){\\n            if(map1.get(key) == max){\\n                List<String> p = new ArrayList<>();\\n                p.add(key);\\n                Collections.sort(map2.get(key));\\n                p.add(map2.get(key).get(0).id);\\n                res.add(p);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n**If you liked the solution, please don\\'t forget to UPVOTE it. Thank You**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public class Pair implements Comparable<Pair>{\\n        int view;\\n        String id;\\n        \\n        Pair(int view, String id){\\n            this.view = view;\\n            this.id = id;\\n        }\\n        \\n        public int compareTo(Pair o){\\n            if(this.view != o.view){ //if views are different, then sort Decreasingly\\n                return o.view - this.view; \\n            }else{\\n                return this.id.compareTo(o.id); //if views are same, then sort lexicographically\\n            }\\n        }\\n    }\\n    \\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        HashMap<String, Integer> map1 = new HashMap<>(); //creators VS total views\\n        for(int i = 0; i < creators.length; ++i){ //O(N)\\n            String c = creators[i];\\n            map1.put(c, map1.getOrDefault(c, 0) + views[i]);\\n        }\\n        \\n        \\n        HashMap<String, ArrayList<Pair>> map2 = new HashMap<>(); //creators VS (His/Her all videos id\\'s list with there views)\\n        for(int i = 0; i < creators.length; ++i){ //O(N)\\n            String c = creators[i];\\n            if(map2.containsKey(c) == false){\\n                map2.put(c, new ArrayList<>());\\n            }\\n            map2.get(c).add(new Pair(views[i], ids[i])); //store video with id, and with there respective views\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        \\n        int max = 0;\\n        for(String key : map1.keySet()){ //finding the maximum views of the creator\\n            max = Math.max(max, map1.get(key));\\n        }\\n        \\n        for(String key : map1.keySet()){\\n            if(map1.get(key) == max){\\n                List<String> p = new ArrayList<>();\\n                p.add(key);\\n                Collections.sort(map2.get(key));\\n                p.add(map2.get(key).get(0).id);\\n                res.add(p);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758225,
                "title": "c-map",
                "content": "# Code\\n```\\nstruct MPC{\\n    int idx;\\n    string id;\\n    long long view;\\n    \\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        int n = creators.size();\\n        map<string, MPC> mp;\\n        int idx = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            MPC mpc;\\n            if(mp.find(creators[i]) == mp.end()) {\\n                mpc = MPC();\\n                mpc.idx = i;\\n                mpc.id = ids[i];\\n                mpc.view = views[i];\\n                mp[creators[i]] = mpc;\\n            } else {\\n                mpc = mp[creators[i]];\\n                if(views[mpc.idx] < views[i]) {\\n                    mpc.id = ids[i];\\n                    mpc.idx = i;\\n                } else if(views[mpc.idx] == views[i]) {\\n                    if(ids[mpc.idx] > ids[i]) {\\n                        mpc.id = ids[i];\\n                        mpc.idx = i;\\n                    }\\n                }\\n                \\n                mpc.view += views[i];\\n            }\\n            mp[creators[i]] = mpc;\\n        }\\n        \\n        vector<vector<string>> ans;\\n        long long maxviews = -1;\\n        for(auto itr: mp) {            \\n            maxviews = max(maxviews, itr.second.view);\\n        }\\n        \\n        for(auto itr: mp) {\\n            if(itr.second.view == maxviews) {\\n                ans.push_back({itr.first, itr.second.id});\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct MPC{\\n    int idx;\\n    string id;\\n    long long view;\\n    \\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        int n = creators.size();\\n        map<string, MPC> mp;\\n        int idx = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            MPC mpc;\\n            if(mp.find(creators[i]) == mp.end()) {\\n                mpc = MPC();\\n                mpc.idx = i;\\n                mpc.id = ids[i];\\n                mpc.view = views[i];\\n                mp[creators[i]] = mpc;\\n            } else {\\n                mpc = mp[creators[i]];\\n                if(views[mpc.idx] < views[i]) {\\n                    mpc.id = ids[i];\\n                    mpc.idx = i;\\n                } else if(views[mpc.idx] == views[i]) {\\n                    if(ids[mpc.idx] > ids[i]) {\\n                        mpc.id = ids[i];\\n                        mpc.idx = i;\\n                    }\\n                }\\n                \\n                mpc.view += views[i];\\n            }\\n            mp[creators[i]] = mpc;\\n        }\\n        \\n        vector<vector<string>> ans;\\n        long long maxviews = -1;\\n        for(auto itr: mp) {            \\n            maxviews = max(maxviews, itr.second.view);\\n        }\\n        \\n        for(auto itr: mp) {\\n            if(itr.second.view == maxviews) {\\n                ans.push_back({itr.first, itr.second.id});\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758059,
                "title": "c-map-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        map<string,long long int> mp;\\n        map<string,vector<pair<string,long long int>>> ans;\\n        long long int ma=0;\\n        for(long long int i=0;i<ids.size();i++)\\n        {\\n            mp[creators[i]]+=views[i];\\n            ma=max(ma, mp[creators[i]]);\\n            ans[creators[i]].push_back(make_pair(ids[i],views[i]));\\n            \\n        }\\n        vector<vector<string>> a;\\n        for(auto x:mp)\\n        {\\n            if(x.second==ma)\\n            {\\n                string p=ans[x.first][0].first;\\n                long long int q=ans[x.first][0].second;\\n                for(auto b:ans[x.first])\\n                {\\n                 if(b.second>q)\\n                 {p=b.first;\\n                  q=b.second;}\\n                 else if(b.second==q && p>b.first)\\n                     p=b.first;  \\n                }\\n                vector<string> s;\\n                s.push_back(x.first);\\n                s.push_back(p);\\n                a.push_back(s);\\n            }\\n                \\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        map<string,long long int> mp;\\n        map<string,vector<pair<string,long long int>>> ans;\\n        long long int ma=0;\\n        for(long long int i=0;i<ids.size();i++)\\n        {\\n            mp[creators[i]]+=views[i];\\n            ma=max(ma, mp[creators[i]]);\\n            ans[creators[i]].push_back(make_pair(ids[i],views[i]));\\n            \\n        }\\n        vector<vector<string>> a;\\n        for(auto x:mp)\\n        {\\n            if(x.second==ma)\\n            {\\n                string p=ans[x.first][0].first;\\n                long long int q=ans[x.first][0].second;\\n                for(auto b:ans[x.first])\\n                {\\n                 if(b.second>q)\\n                 {p=b.first;\\n                  q=b.second;}\\n                 else if(b.second==q && p>b.first)\\n                     p=b.first;  \\n                }\\n                vector<string> s;\\n                s.push_back(x.first);\\n                s.push_back(p);\\n                a.push_back(s);\\n            }\\n                \\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094277,
                "title": "c-solution-using-one-hashmap-with-explanation-no-sorting",
                "content": "# Intuition\\nWe can create a structure to store the details each creator and store it in a map. In this way we can avoid using multiple Hash Maps.\\n\\n# Approach\\nThe structure made for each creator will contain the \\n- Total views of that creator accross all the videos.\\n- View variable which will store the maximum view on a video created by that Creator.\\n- ID variable which will store the ID of creator\\'s video with the maximum view count. In case of multiple videos of the same creator with the same maximum view count, we can compare the ID to store lexicographically smallest ID in this variable.\\n\\nWe will iterate through each element of the vector and update our MaximumCount variable accross all creator and also update the detail of each creator in our map of structure.\\n\\nAfter that we will iterate through our map and store the answer in vector array if the total view count of the creator matches with the value of MaximumCount. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    struct creator{\\n        long long int totalView = 0; // Total view count of the creator\\n        string id = \"zzz\"; // Lexicographically Smallest Id of a creator\\'s \\n        // video based on maximum view \\n        int view=0; // Maximum View on the Video of Creator\\n    };\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        vector<vector<string>> ans;\\n        long long int n = ids.size(),count=0;// Count variable for keeping \\n        // the count of maximum view among all the creators \\n        map<string,creator> mp;\\n        \\n        //First we iterate through each element in creator array and update\\n        //the map of that creator accordingly\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[creators[i]].totalView += views[i];\\n            count = max(count,mp[creators[i]].totalView);\\n            if((mp[creators[i]].view < views[i]))\\n            {\\n                mp[creators[i]].view = views[i];\\n                mp[creators[i]].id = ids[i];\\n            }\\n            if((mp[creators[i]].view == views[i]) && (mp[creators[i]].id > ids[i]))\\n                mp[creators[i]].id = ids[i];\\n        }\\n\\n        // Iterate through each creator and check if the total count of \\n        // that creator is equal to the maximum count calculated above\\n        // and update the answer vector accordingly\\n        for(auto itr : mp)\\n        {\\n            if(itr.second.totalView == count)\\n            {\\n                ans.push_back({itr.first,itr.second.id});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    struct creator{\\n        long long int totalView = 0; // Total view count of the creator\\n        string id = \"zzz\"; // Lexicographically Smallest Id of a creator\\'s \\n        // video based on maximum view \\n        int view=0; // Maximum View on the Video of Creator\\n    };\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        vector<vector<string>> ans;\\n        long long int n = ids.size(),count=0;// Count variable for keeping \\n        // the count of maximum view among all the creators \\n        map<string,creator> mp;\\n        \\n        //First we iterate through each element in creator array and update\\n        //the map of that creator accordingly\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[creators[i]].totalView += views[i];\\n            count = max(count,mp[creators[i]].totalView);\\n            if((mp[creators[i]].view < views[i]))\\n            {\\n                mp[creators[i]].view = views[i];\\n                mp[creators[i]].id = ids[i];\\n            }\\n            if((mp[creators[i]].view == views[i]) && (mp[creators[i]].id > ids[i]))\\n                mp[creators[i]].id = ids[i];\\n        }\\n\\n        // Iterate through each creator and check if the total count of \\n        // that creator is equal to the maximum count calculated above\\n        // and update the answer vector accordingly\\n        for(auto itr : mp)\\n        {\\n            if(itr.second.totalView == count)\\n            {\\n                ans.push_back({itr.first,itr.second.id});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084701,
                "title": "c-map-stl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        int n=ids.size();\\n        if(count(views.begin(),views.end(),0)==n){\\n            for(int i=0;i<n;i++) views[i]++;\\n        }\\n        map<string,pair<long long,pair<string,long long>>>m;\\n        long long maxi=0;\\n        for(int i=0;i<n;i++){\\n            if(m[creators[i]].first==0){\\n                maxi=max(views[i]*1LL,maxi);\\n                m[creators[i]]={views[i],{ids[i],views[i]}};\\n            }\\n            else{\\n                m[creators[i]].first+=views[i];\\n                maxi=max(maxi,m[creators[i]].first);\\n                if(views[i]==m[creators[i]].second.second){\\n                    if(ids[i]<m[creators[i]].second.first){\\n                        m[creators[i]].second.first=ids[i];\\n                    }\\n                }\\n                else if(views[i]>m[creators[i]].second.second){\\n                    m[creators[i]].second.second=views[i];\\n                    m[creators[i]].second.first=ids[i];\\n                }\\n            }\\n        }\\n        vector<vector<string>> ans;\\n        for(auto &it:m){\\n            if(it.second.first==maxi){\\n                vector<string> t;\\n                t.push_back(it.first);\\n                t.push_back(it.second.second.first);\\n                ans.push_back(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        int n=ids.size();\\n        if(count(views.begin(),views.end(),0)==n){\\n            for(int i=0;i<n;i++) views[i]++;\\n        }\\n        map<string,pair<long long,pair<string,long long>>>m;\\n        long long maxi=0;\\n        for(int i=0;i<n;i++){\\n            if(m[creators[i]].first==0){\\n                maxi=max(views[i]*1LL,maxi);\\n                m[creators[i]]={views[i],{ids[i],views[i]}};\\n            }\\n            else{\\n                m[creators[i]].first+=views[i];\\n                maxi=max(maxi,m[creators[i]].first);\\n                if(views[i]==m[creators[i]].second.second){\\n                    if(ids[i]<m[creators[i]].second.first){\\n                        m[creators[i]].second.first=ids[i];\\n                    }\\n                }\\n                else if(views[i]>m[creators[i]].second.second){\\n                    m[creators[i]].second.second=views[i];\\n                    m[creators[i]].second.first=ids[i];\\n                }\\n            }\\n        }\\n        vector<vector<string>> ans;\\n        for(auto &it:m){\\n            if(it.second.first==maxi){\\n                vector<string> t;\\n                t.push_back(it.first);\\n                t.push_back(it.second.second.first);\\n                ans.push_back(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010087,
                "title": "tedious",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,pair<string,long long>>mp1;\\n        unordered_map<string,long long>mp2;\\n        vector<vector<string>>ans;\\n        priority_queue<pair<long long,string>>pq;\\n        int n=creators.size();\\n\\n\\n           for(int i=0;i<n;i++)\\n            mp2[creators[i]]+=views[i];\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n         if(mp1.find(creators[i])==mp1.end()||views[i]>mp1[creators[i]].second)\\n         {\\n                 mp1[creators[i]].first=ids[i];\\n                mp1[creators[i]].second=views[i];\\n         }      \\n            else if(views[i]==mp1[creators[i]].second)\\n            mp1[creators[i]].first=min(ids[i],mp1[creators[i]].first);      \\n        }\\n\\n\\n        for(auto itr:mp2)\\n            pq.push({itr.second,itr.first});\\n        \\n\\n\\n        while(!pq.empty())\\n        {\\n            int t=pq.top().first;\\n            vector<string>temp;\\n            temp.push_back(pq.top().second);\\n            temp.push_back(mp1[pq.top().second].first);\\n            ans.push_back(temp);\\n            pq.pop();\\n            if(pq.top().first!=t)\\n                break;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,pair<string,long long>>mp1;\\n        unordered_map<string,long long>mp2;\\n        vector<vector<string>>ans;\\n        priority_queue<pair<long long,string>>pq;\\n        int n=creators.size();\\n\\n\\n           for(int i=0;i<n;i++)\\n            mp2[creators[i]]+=views[i];\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n         if(mp1.find(creators[i])==mp1.end()||views[i]>mp1[creators[i]].second)\\n         {\\n                 mp1[creators[i]].first=ids[i];\\n                mp1[creators[i]].second=views[i];\\n         }      \\n            else if(views[i]==mp1[creators[i]].second)\\n            mp1[creators[i]].first=min(ids[i],mp1[creators[i]].first);      \\n        }\\n\\n\\n        for(auto itr:mp2)\\n            pq.push({itr.second,itr.first});\\n        \\n\\n\\n        while(!pq.empty())\\n        {\\n            int t=pq.top().first;\\n            vector<string>temp;\\n            temp.push_back(pq.top().second);\\n            temp.push_back(mp1[pq.top().second].first);\\n            ans.push_back(temp);\\n            pq.pop();\\n            if(pq.top().first!=t)\\n                break;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882559,
                "title": "no-sorting-one-hashmap-solution-python",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question clearly shoes us that we have to maintain a record of every creator.\\nAnd for maintaining the record a HashMap (dictionaryfor Python) is a good choice.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are going to maintain a hashmap which will have 3 values for every creator.\\n    - Total Views `sum of views`\\n    - Most populer video of this creator `id`\\n    - Views on the most popular video\\n\\nApart from that, on the run time, we will keep track of the Most number of views on any video. (`max_v`)\\n\\nEvery time we find a video which is more popular video than that which is present on the dictionary currently, We will keep on updating most popular video\\'s ID. *refer code*\\n`the elif condition`\\n\\nIn the end we just have to check how many creators have the maximum views `max_v`\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) Approx\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, cts: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        d = {}\\n        n = len(ids)\\n        max_v = 0\\n        for i in range(n):\\n            if cts[i] not in d :\\n                d[cts[i]] = [views[i] , ids[i] , views[i]]\\n            \\n            else:\\n                d[cts[i]][0] += views[i]\\n                if views[i] > d[cts[i]][2] :\\n                    d[cts[i]][2] = views[i]\\n                    d[cts[i]][1] = ids[i]\\n                elif views[i] == d[cts[i]][2] :\\n                    d[cts[i]][1] = min(d[cts[i]][1] , ids[i])\\n\\n            if d[cts[i]][0] > max_v:\\n                max_v = d[cts[i]][0]\\n\\n        ans = []\\n        for c in d:\\n            if d[c][0] == max_v:\\n                ans.append([c , d[c][1]])\\n        return ans\\n        \\n\\n```\\n> Quote\\nDone!\\n\\n**Happy Coding \\u2705**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, cts: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        d = {}\\n        n = len(ids)\\n        max_v = 0\\n        for i in range(n):\\n            if cts[i] not in d :\\n                d[cts[i]] = [views[i] , ids[i] , views[i]]\\n            \\n            else:\\n                d[cts[i]][0] += views[i]\\n                if views[i] > d[cts[i]][2] :\\n                    d[cts[i]][2] = views[i]\\n                    d[cts[i]][1] = ids[i]\\n                elif views[i] == d[cts[i]][2] :\\n                    d[cts[i]][1] = min(d[cts[i]][1] , ids[i])\\n\\n            if d[cts[i]][0] > max_v:\\n                max_v = d[cts[i]][0]\\n\\n        ans = []\\n        for c in d:\\n            if d[c][0] == max_v:\\n                ans.append([c , d[c][1]])\\n        return ans\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789014,
                "title": "hash-by-creator",
                "content": "# Intuition\\nWe need three hash tables:\\n1. `view` : Maps `creator` and the total number of views of that creator.\\n2. `tops` : Maps `creator` and the view of their top video.\\n3. `topid` : Maps `creator` and the id of the video with top views.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nOver a linear sacn we add values to `view`, `tops`, and `topid`.\\nAfter we iterate over view and make a vector of all `creators` with max views on the platform.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, int> view, tops;\\n        unordered_map<string, string> topid;\\n        \\n        int n = ids.size();\\n        for(int i = 0; i < n; i++) {\\n            view[creators[i]] += views[i];\\n            if(tops[creators[i]] < views[i]) {\\n                tops[creators[i]] = views[i];\\n                topid[creators[i]] = ids[i];\\n            }\\n            if(tops[creators[i]] == views[i]) {\\n                if(topid[creators[i]].length() == 0)\\n                    topid[creators[i]] = ids[i];\\n                else\\n                    topid[creators[i]] = min(topid[creators[i]], ids[i]);\\n            }\\n        }\\n        \\n        int top = 0;\\n        vector<vector<string>> topCreators;\\n        \\n        for(auto it: view) {\\n            // cout<<it.first<<\" \"<<it.second<<endl;\\n            if(it.second > top) {\\n                topCreators.clear();\\n                top = it.second;\\n            }\\n            if(top == it.second)\\n                topCreators.push_back({it.first, topid[it.first]});\\n        }\\n        \\n        return topCreators;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, int> view, tops;\\n        unordered_map<string, string> topid;\\n        \\n        int n = ids.size();\\n        for(int i = 0; i < n; i++) {\\n            view[creators[i]] += views[i];\\n            if(tops[creators[i]] < views[i]) {\\n                tops[creators[i]] = views[i];\\n                topid[creators[i]] = ids[i];\\n            }\\n            if(tops[creators[i]] == views[i]) {\\n                if(topid[creators[i]].length() == 0)\\n                    topid[creators[i]] = ids[i];\\n                else\\n                    topid[creators[i]] = min(topid[creators[i]], ids[i]);\\n            }\\n        }\\n        \\n        int top = 0;\\n        vector<vector<string>> topCreators;\\n        \\n        for(auto it: view) {\\n            // cout<<it.first<<\" \"<<it.second<<endl;\\n            if(it.second > top) {\\n                topCreators.clear();\\n                top = it.second;\\n            }\\n            if(top == it.second)\\n                topCreators.push_back({it.first, topid[it.first]});\\n        }\\n        \\n        return topCreators;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2767023,
                "title": "more-than-90-efficient-and-100-space-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& id, vector<int>& v) {\\n        unordered_map<string,int> p;\\n        unordered_map<string,pair<string,int>> mv;\\n        unordered_map<string,bool> vis;\\n        int mx=0;\\n        for(int i=0;i<v.size();i++){\\n            p[c[i]] += v[i];\\n            mx = max(mx,p[c[i]]);\\n            if(vis[c[i]] and mv[c[i]].second == v[i]){\\n                mv[c[i]].first = mv[c[i]].first < id[i]?mv[c[i]].first:id[i];\\n            }else if(vis[c[i]] and mv[c[i]].second < v[i]){\\n                mv[c[i]].first = id[i];\\n                mv[c[i]].second = v[i];\\n            }\\n            \\n            if(!vis[c[i]]){\\n                mv[c[i]].first = id[i];\\n                mv[c[i]].second = v[i];\\n            }\\n            vis[c[i]] = 1;\\n        }\\n        vector<vector<string>> ans;\\n        for(auto it:p){\\n            if(it.second==mx){\\n                ans.push_back({it.first,mv[it.first].first});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& id, vector<int>& v) {\\n        unordered_map<string,int> p;\\n        unordered_map<string,pair<string,int>> mv;\\n        unordered_map<string,bool> vis;\\n        int mx=0;\\n        for(int i=0;i<v.size();i++){\\n            p[c[i]] += v[i];\\n            mx = max(mx,p[c[i]]);\\n            if(vis[c[i]] and mv[c[i]].second == v[i]){\\n                mv[c[i]].first = mv[c[i]].first < id[i]?mv[c[i]].first:id[i];\\n            }else if(vis[c[i]] and mv[c[i]].second < v[i]){\\n                mv[c[i]].first = id[i];\\n                mv[c[i]].second = v[i];\\n            }\\n            \\n            if(!vis[c[i]]){\\n                mv[c[i]].first = id[i];\\n                mv[c[i]].second = v[i];\\n            }\\n            vis[c[i]] = 1;\\n        }\\n        vector<vector<string>> ans;\\n        for(auto it:p){\\n            if(it.second==mx){\\n                ans.push_back({it.first,mv[it.first].first});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760903,
                "title": "using-3-maps-no-sorting",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        map<string,ll> view;\\n        map<string,string> id;\\n        map<string,ll> maxx;\\n        vector<vector<string>> ans;\\n        ll mx=-1;\\n        for(int i=0;i<creators.size();i++){\\n            view[creators[i]]+=views[i];\\n            mx=max(mx,view[creators[i]]);\\n            if(maxx.find(creators[i])!=maxx.end()){\\n                ll temp = maxx[creators[i]];\\n                if(temp>views[i]) continue;\\n                else if(temp<views[i]){\\n                    maxx[creators[i]] = views[i];\\n                    id[creators[i]] = ids[i];\\n                }\\n                else{\\n                    id[creators[i]] = min(id[creators[i]],ids[i]);\\n                }\\n            }\\n            else{\\n                id[creators[i]] = ids[i];\\n                maxx[creators[i]] = views[i];\\n            }\\n            \\n        }\\n        \\n        for(auto i:view){\\n            if(i.second==mx){\\n                ans.push_back({i.first,id[i.first]});\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        map<string,ll> view;\\n        map<string,string> id;\\n        map<string,ll> maxx;\\n        vector<vector<string>> ans;\\n        ll mx=-1;\\n        for(int i=0;i<creators.size();i++){\\n            view[creators[i]]+=views[i];\\n            mx=max(mx,view[creators[i]]);\\n            if(maxx.find(creators[i])!=maxx.end()){\\n                ll temp = maxx[creators[i]];\\n                if(temp>views[i]) continue;\\n                else if(temp<views[i]){\\n                    maxx[creators[i]] = views[i];\\n                    id[creators[i]] = ids[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2758457,
                "title": "my-easy-to-understand-java-code-using-hashmaps",
                "content": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        HashMap<String, Integer> map = new HashMap<>(); //total views\\n        HashMap<String, String> mostViewed = new HashMap<>(); //most viewed video\\n        HashMap<String, Integer> mostViews = new HashMap<>(); //max views in a single video\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        int n = creators.length;\\n        \\n        for(int i=0; i<n; i++){\\n            String creator = creators[i];\\n            \\n            //total Views\\n            map.put(creator, map.getOrDefault(creator, 0)+views[i]);\\n            \\n            //most viewed\\n            if(mostViewed.containsKey(creator)){\\n                if(views[i] > mostViews.get(creator)) {\\n                    mostViewed.put(creator, ids[i]);\\n                    mostViews.put(creator, views[i]);\\n                }\\n                else if(views[i] == mostViews.get(creator)){\\n                    if(mostViewed.get(creator).compareTo(ids[i]) > 0) mostViewed.put(creator, ids[i]);\\n\\t\\t\\t\\t}\\n            }\\n\\t\\t\\t\\n            else{\\n                mostViewed.put(creator, ids[i]); \\n                mostViews.put(creator, views[i]);\\n            }\\n        }\\n        \\n        int max=-1;\\n        \\n        for(String key:map.keySet()){\\n            if(map.get(key) > max) max = map.get(key);\\n        }\\n        \\n        for(String key:map.keySet()){\\n            if(map.get(key) == max){\\n                List<String> sub = new ArrayList<>();\\n                sub.add(key);\\n                sub.add(mostViewed.get(key));\\n                ans.add(sub);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        HashMap<String, Integer> map = new HashMap<>(); //total views\\n        HashMap<String, String> mostViewed = new HashMap<>(); //most viewed video\\n        HashMap<String, Integer> mostViews = new HashMap<>(); //max views in a single video\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        int n = creators.length;\\n        \\n        for(int i=0; i<n; i++){\\n            String creator = creators[i];\\n            \\n            //total Views\\n            map.put(creator, map.getOrDefault(creator, 0)+views[i]);\\n            \\n            //most viewed\\n            if(mostViewed.containsKey(creator)){\\n                if(views[i] > mostViews.get(creator)) {\\n                    mostViewed.put(creator, ids[i]);\\n                    mostViews.put(creator, views[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2758101,
                "title": "javascript-map-tc-o-n-sc-o-n",
                "content": "```\\n/**\\n * @param {string[]} creators\\n * @param {string[]} ids\\n * @param {number[]} views\\n * @return {string[][]}\\n */\\nvar mostPopularCreator = function(creators, ids, views) {\\n    const map = {};\\n\\n    for (let i = 0; i < ids.length; i++) {\\n        if (map[creators[i]]) {\\n            let {\\n                popularity,\\n                maxPopularity,\\n                mostViewed\\n            } = map[creators[i]];\\n            \\n            if (views[i] > maxPopularity) {\\n                maxPopularity = views[i];\\n                mostViewed = ids[i];\\n            } else if (views[i] === maxPopularity) {\\n                mostViewed = ids[i] < mostViewed ? ids[i] : mostViewed;\\n            }\\n            \\n            map[creators[i]] = {\\n                popularity: popularity + views[i],\\n                maxPopularity,\\n                mostViewed\\n            }\\n        } else {\\n            map[creators[i]] = {\\n                popularity: views[i],\\n                maxPopularity: views[i],\\n                mostViewed: ids[i]\\n            }\\n        }\\n    }\\n    \\n    let maxP = 0;\\n    \\n    Object.keys(map).forEach(e => {\\n        if (map[e].popularity > maxP) {\\n            maxP = map[e].popularity;\\n        }\\n    });\\n    \\n    const ans = [];\\n    \\n    Object.keys(map).forEach(e => {\\n        if (map[e].popularity === maxP) {\\n            ans.push([e, map[e].mostViewed]);\\n        }\\n    });\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} creators\\n * @param {string[]} ids\\n * @param {number[]} views\\n * @return {string[][]}\\n */\\nvar mostPopularCreator = function(creators, ids, views) {\\n    const map = {};\\n\\n    for (let i = 0; i < ids.length; i++) {\\n        if (map[creators[i]]) {\\n            let {\\n                popularity,\\n                maxPopularity,\\n                mostViewed\\n            } = map[creators[i]];\\n            \\n            if (views[i] > maxPopularity) {\\n                maxPopularity = views[i];\\n                mostViewed = ids[i];\\n            } else if (views[i] === maxPopularity) {\\n                mostViewed = ids[i] < mostViewed ? ids[i] : mostViewed;\\n            }\\n            \\n            map[creators[i]] = {\\n                popularity: popularity + views[i],\\n                maxPopularity,\\n                mostViewed\\n            }\\n        } else {\\n            map[creators[i]] = {\\n                popularity: views[i],\\n                maxPopularity: views[i],\\n                mostViewed: ids[i]\\n            }\\n        }\\n    }\\n    \\n    let maxP = 0;\\n    \\n    Object.keys(map).forEach(e => {\\n        if (map[e].popularity > maxP) {\\n            maxP = map[e].popularity;\\n        }\\n    });\\n    \\n    const ans = [];\\n    \\n    Object.keys(map).forEach(e => {\\n        if (map[e].popularity === maxP) {\\n            ans.push([e, map[e].mostViewed]);\\n        }\\n    });\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758040,
                "title": "c-three-map-s",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        map<string,long> mp;\\n        int i=0;\\n        for(auto it : creators){\\n            mp[it] += views[i++];\\n        }\\n        map<long,vector<string>> mpp;\\n        for(auto it : mp){\\n            mpp[it.second].push_back(it.first);\\n        }\\n        vector<string> popular = mpp.rbegin()->second;\\n        map<string,map<int,set<string>>> m;\\n        for(int j=0;j<creators.size();j++){\\n            m[creators[j]][views[j]].insert(ids[j]);\\n        }\\n        vector<vector<string>> ans;\\n        for(int j=0;j<popular.size();j++){\\n            auto it = m[popular[j]].rbegin()->second;\\n            // cout<<*it.begin()<<\"\\\\n\";\\n            ans.push_back({popular[j],*it.begin()});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        map<string,long> mp;\\n        int i=0;\\n        for(auto it : creators){\\n            mp[it] += views[i++];\\n        }\\n        map<long,vector<string>> mpp;\\n        for(auto it : mp){\\n            mpp[it.second].push_back(it.first);\\n        }\\n        vector<string> popular = mpp.rbegin()->second;\\n        map<string,map<int,set<string>>> m;\\n        for(int j=0;j<creators.size();j++){\\n            m[creators[j]][views[j]].insert(ids[j]);\\n        }\\n        vector<vector<string>> ans;\\n        for(int j=0;j<popular.size();j++){\\n            auto it = m[popular[j]].rbegin()->second;\\n            // cout<<*it.begin()<<\"\\\\n\";\\n            ans.push_back({popular[j],*it.begin()});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4008024,
                "title": "java-easy-100-ood-solution",
                "content": "```java\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(final String[] creators, final String[] ids, final int[] views) {\\n        final List<List<String>> result = new ArrayList<>();\\n        final Map<String, Creator> totalViews = new HashMap<>();\\n        final PriorityQueue<Creator> maxHeap = new PriorityQueue<>((a, b) -> b.totalViews() - a.totalViews());\\n\\n        final int n = creators.length;\\n\\n        for(int i = 0; i < n; ++i) {\\n            totalViews.putIfAbsent(creators[i], new Creator(creators[i], views[i], ids[i]));\\n\\n            Creator creator = totalViews.get(creators[i]);\\n\\n            creator.totalViews(creator.totalViews() + views[i]);\\n\\n            if(views[i] > creator.maxViewsVideo() || (views[i] == creator.maxViewsVideo() && ids[i].compareTo(creator.maxViewsVideoId()) < 0))\\n                creator.maxViewsVideo(views[i]).maxViewsVideoId(ids[i]);\\n        }\\n\\n        for(Creator creator : totalViews.values())\\n            maxHeap.offer(creator);\\n\\n        int prev = maxHeap.peek().totalViews();\\n\\n        while(!maxHeap.isEmpty() && prev == maxHeap.peek().totalViews()) {\\n            Creator creator = maxHeap.poll();\\n\\n            prev = creator.totalViews();\\n            result.add(Arrays.asList(creator.name(), creator.maxViewsVideoId()));\\n        }\\n\\n        return result;\\n    }\\n\\n    private final class Creator {\\n        private String name;\\n        private int totalViews;\\n        private int maxViewsVideo;\\n        private String maxViewsVideoId;\\n\\n        public Creator(final String name, final int maxViewsVideo, final String maxViewsVideoId) {\\n            this.name = name;\\n            this.totalViews = 0;\\n            this.maxViewsVideo = maxViewsVideo;\\n            this.maxViewsVideoId = maxViewsVideoId;\\n        }\\n\\n        public Creator name(final String name) {\\n            this.name = name;\\n            return this;\\n        }\\n\\n        public String name() {\\n            return this.name;\\n        }\\n\\n        public Creator totalViews(final int totalViews) {\\n            this.totalViews = totalViews;\\n            return this;\\n        }\\n\\n        public int totalViews() {\\n            return this.totalViews;\\n        }\\n\\n        public Creator maxViewsVideo(final int maxViewsVideo) {\\n            this.maxViewsVideo = maxViewsVideo;\\n            return this;\\n        }\\n\\n        public int maxViewsVideo() {\\n            return this.maxViewsVideo;\\n        }\\n\\n        public Creator maxViewsVideoId(final String maxViewsVideoId) {\\n            this.maxViewsVideoId = maxViewsVideoId;\\n            return this;\\n        }\\n\\n        public String maxViewsVideoId() {\\n            return this.maxViewsVideoId;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(final String[] creators, final String[] ids, final int[] views) {\\n        final List<List<String>> result = new ArrayList<>();\\n        final Map<String, Creator> totalViews = new HashMap<>();\\n        final PriorityQueue<Creator> maxHeap = new PriorityQueue<>((a, b) -> b.totalViews() - a.totalViews());\\n\\n        final int n = creators.length;\\n\\n        for(int i = 0; i < n; ++i) {\\n            totalViews.putIfAbsent(creators[i], new Creator(creators[i], views[i], ids[i]));\\n\\n            Creator creator = totalViews.get(creators[i]);\\n\\n            creator.totalViews(creator.totalViews() + views[i]);\\n\\n            if(views[i] > creator.maxViewsVideo() || (views[i] == creator.maxViewsVideo() && ids[i].compareTo(creator.maxViewsVideoId()) < 0))\\n                creator.maxViewsVideo(views[i]).maxViewsVideoId(ids[i]);\\n        }\\n\\n        for(Creator creator : totalViews.values())\\n            maxHeap.offer(creator);\\n\\n        int prev = maxHeap.peek().totalViews();\\n\\n        while(!maxHeap.isEmpty() && prev == maxHeap.peek().totalViews()) {\\n            Creator creator = maxHeap.poll();\\n\\n            prev = creator.totalViews();\\n            result.add(Arrays.asList(creator.name(), creator.maxViewsVideoId()));\\n        }\\n\\n        return result;\\n    }\\n\\n    private final class Creator {\\n        private String name;\\n        private int totalViews;\\n        private int maxViewsVideo;\\n        private String maxViewsVideoId;\\n\\n        public Creator(final String name, final int maxViewsVideo, final String maxViewsVideoId) {\\n            this.name = name;\\n            this.totalViews = 0;\\n            this.maxViewsVideo = maxViewsVideo;\\n            this.maxViewsVideoId = maxViewsVideoId;\\n        }\\n\\n        public Creator name(final String name) {\\n            this.name = name;\\n            return this;\\n        }\\n\\n        public String name() {\\n            return this.name;\\n        }\\n\\n        public Creator totalViews(final int totalViews) {\\n            this.totalViews = totalViews;\\n            return this;\\n        }\\n\\n        public int totalViews() {\\n            return this.totalViews;\\n        }\\n\\n        public Creator maxViewsVideo(final int maxViewsVideo) {\\n            this.maxViewsVideo = maxViewsVideo;\\n            return this;\\n        }\\n\\n        public int maxViewsVideo() {\\n            return this.maxViewsVideo;\\n        }\\n\\n        public Creator maxViewsVideoId(final String maxViewsVideoId) {\\n            this.maxViewsVideoId = maxViewsVideoId;\\n            return this;\\n        }\\n\\n        public String maxViewsVideoId() {\\n            return this.maxViewsVideoId;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326180,
                "title": "c-most-popular-video-creator-easy-fast",
                "content": "# Approach:\\nThe Code is self-explanatory.\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<string>> MostPopularCreator(string[] creators, string[] ids, int[] views) \\n    {\\n        IList<IList<string>> answer = new List<IList<string>>();\\n        Dictionary<string, Creator> creatorList = new Dictionary<string, Creator>();\\n        long highestView = 0;\\n\\n        for(int i = 0; i < ids.Length; i++)\\n        {\\n            if(creatorList.ContainsKey(creators[i]) == false)\\n            {\\n                creatorList.Add(creators[i], new Creator());\\n            }\\n\\n            long view = creatorList[creators[i]].FindHiggest(ids[i], views[i]);\\n\\n            if(view > highestView) highestView = view;\\n        }\\n\\n        foreach(KeyValuePair<string, Creator> pair in creatorList)\\n        {\\n            if(pair.Value.totalView == highestView)\\n            {\\n                IList<string> info = new List<string>();\\n                info.Add(pair.Key);\\n                info.Add(pair.Value.highestID);\\n\\n                answer.Add(info);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    public class Creator\\n    {\\n        public long highestView = -1;\\n        public string highestID;\\n        public long totalView = 0;\\n\\n        public long FindHiggest(string id, int view)\\n        {\\n            if(view > highestView || (view == highestView && string.Compare(id, highestID) == -1))\\n            {\\n                highestView = view;\\n                highestID = id;\\n            }\\n\\n            totalView += view;\\n\\n            return totalView;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> MostPopularCreator(string[] creators, string[] ids, int[] views) \\n    {\\n        IList<IList<string>> answer = new List<IList<string>>();\\n        Dictionary<string, Creator> creatorList = new Dictionary<string, Creator>();\\n        long highestView = 0;\\n\\n        for(int i = 0; i < ids.Length; i++)\\n        {\\n            if(creatorList.ContainsKey(creators[i]) == false)\\n            {\\n                creatorList.Add(creators[i], new Creator());\\n            }\\n\\n            long view = creatorList[creators[i]].FindHiggest(ids[i], views[i]);\\n\\n            if(view > highestView) highestView = view;\\n        }\\n\\n        foreach(KeyValuePair<string, Creator> pair in creatorList)\\n        {\\n            if(pair.Value.totalView == highestView)\\n            {\\n                IList<string> info = new List<string>();\\n                info.Add(pair.Key);\\n                info.Add(pair.Value.highestID);\\n\\n                answer.Add(info);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    public class Creator\\n    {\\n        public long highestView = -1;\\n        public string highestID;\\n        public long totalView = 0;\\n\\n        public long FindHiggest(string id, int view)\\n        {\\n            if(view > highestView || (view == highestView && string.Compare(id, highestID) == -1))\\n            {\\n                highestView = view;\\n                highestID = id;\\n            }\\n\\n            totalView += view;\\n\\n            return totalView;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107655,
                "title": "easy-solution-using-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        res={}\\n        total = -1\\n        for i in range(len(creators)):\\n            if creators[i] in res:\\n                res[creators[i]][0] += views[i]\\n                if res[creators[i]][2] < views[i]:\\n                    res[creators[i]][1] = ids[i]\\n                    res[creators[i]][2] = views[i]\\n                elif res[creators[i]][2] == views[i]:\\n                    res[creators[i]][1] = min(res[creators[i]][1],ids[i])\\n            else:\\n                res[creators[i]] = [views[i],ids[i],views[i]]\\n            total = max(res[creators[i]][0],total)\\n        \\n        result = []\\n        for i in res:\\n            if res[i][0] == total:\\n                result.append([i,res[i][1]])\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        res={}\\n        total = -1\\n        for i in range(len(creators)):\\n            if creators[i] in res:\\n                res[creators[i]][0] += views[i]\\n                if res[creators[i]][2] < views[i]:\\n                    res[creators[i]][1] = ids[i]\\n                    res[creators[i]][2] = views[i]\\n                elif res[creators[i]][2] == views[i]:\\n                    res[creators[i]][1] = min(res[creators[i]][1],ids[i])\\n            else:\\n                res[creators[i]] = [views[i],ids[i],views[i]]\\n            total = max(res[creators[i]][0],total)\\n        \\n        result = []\\n        for i in res:\\n            if res[i][0] == total:\\n                result.append([i,res[i][1]])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863333,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators, ids, views):\\n        dict1, dict2, result = defaultdict(list), defaultdict(int), []\\n\\n        for i,j,k in zip(creators,ids,views):\\n            dict1[i].append((k,j))\\n            dict2[i] += k\\n\\n        max_val = max(dict2.values())\\n\\n        ans = [key for key,val in dict2.items() if val == max_val]\\n\\n        for i in ans:\\n            val = sorted(dict1[i], key = lambda x: (-x[0],x[1]))[:1][0]\\n            result.append([i,val[1]])\\n\\n        return result\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators, ids, views):\\n        dict1, dict2, result = defaultdict(list), defaultdict(int), []\\n\\n        for i,j,k in zip(creators,ids,views):\\n            dict1[i].append((k,j))\\n            dict2[i] += k\\n\\n        max_val = max(dict2.values())\\n\\n        ans = [key for key,val in dict2.items() if val == max_val]\\n\\n        for i in ans:\\n            val = sorted(dict1[i], key = lambda x: (-x[0],x[1]))[:1][0]\\n            result.append([i,val[1]])\\n\\n        return result\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846405,
                "title": "java-solution-using-treeset",
                "content": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        HashMap<String, Long> creatorViews = new HashMap<>();\\n        HashMap<String, Integer> movieViews = new HashMap<>();\\n        HashMap<String, TreeSet<String>> creatorVideos = new HashMap<>();\\n        int n = creators.length;\\n        long max = 0;\\n        for (int i = 0; i < n; i++) {\\n            String creator = creators[i];\\n            int view = views[i];\\n            String video = ids[i];\\n            \\n            creatorViews.put(creator, creatorViews.getOrDefault(creator, (long)0) + view);\\n            movieViews.put(video, view);\\n            TreeSet<String> set = creatorVideos.getOrDefault(creator, new TreeSet<String>(\\n            (a,b) -> (movieViews.get(a)).equals(movieViews.get(b))? a.compareTo(b):movieViews.get(b)-movieViews.get(a)));\\n            set.add(video);\\n            creatorVideos.put(creator, set);\\n            max = Math.max(max, creatorViews.get(creator));\\n        }\\n        List<List<String>> result = new ArrayList<>();\\n        // Can improve this loop further\\n        for (Map.Entry<String, Long> entry: creatorViews.entrySet()) {\\n            if (entry.getValue() == max) {\\n                List<String> list = new ArrayList<>();\\n                list.add(entry.getKey());\\n                list.add(creatorVideos.get(entry.getKey()).first());\\n                result.add(list);\\n            }\\n        }\\n                \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        HashMap<String, Long> creatorViews = new HashMap<>();\\n        HashMap<String, Integer> movieViews = new HashMap<>();\\n        HashMap<String, TreeSet<String>> creatorVideos = new HashMap<>();\\n        int n = creators.length;\\n        long max = 0;\\n        for (int i = 0; i < n; i++) {\\n            String creator = creators[i];\\n            int view = views[i];\\n            String video = ids[i];\\n            \\n            creatorViews.put(creator, creatorViews.getOrDefault(creator, (long)0) + view);\\n            movieViews.put(video, view);\\n            TreeSet<String> set = creatorVideos.getOrDefault(creator, new TreeSet<String>(\\n            (a,b) -> (movieViews.get(a)).equals(movieViews.get(b))? a.compareTo(b):movieViews.get(b)-movieViews.get(a)));\\n            set.add(video);\\n            creatorVideos.put(creator, set);\\n            max = Math.max(max, creatorViews.get(creator));\\n        }\\n        List<List<String>> result = new ArrayList<>();\\n        // Can improve this loop further\\n        for (Map.Entry<String, Long> entry: creatorViews.entrySet()) {\\n            if (entry.getValue() == max) {\\n                List<String> list = new ArrayList<>();\\n                list.add(entry.getKey());\\n                list.add(creatorVideos.get(entry.getKey()).first());\\n                result.add(list);\\n            }\\n        }\\n                \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821880,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,long long> m;\\n        vector<pair<pair<long long,string>,string>> v;\\n        long long mx = -1;\\n        int n = ids.size();\\n        for(int i=0; i<n; ++i){\\n            v.push_back({{views[i],ids[i]},creators[i]});\\n            m[creators[i]] += views[i];\\n            mx = max(mx,m[creators[i]]);\\n        }\\n        sort(begin(v),end(v),[](pair<pair<long long,string>,string>&a,pair<pair<long long,string>,string>&b){if(a.first.first == b.first.first) return a < b; return a > b;});\\n        unordered_set<string> st;\\n        for(auto &_v: v){\\n            if(m[_v.second] != mx) continue;\\n            if(st.count(_v.second)) continue;\\n            st.insert(_v.second);\\n            ans.push_back({_v.second,_v.first.second});\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,long long> m;\\n        vector<pair<pair<long long,string>,string>> v;\\n        long long mx = -1;\\n        int n = ids.size();\\n        for(int i=0; i<n; ++i){\\n            v.push_back({{views[i],ids[i]},creators[i]});\\n            m[creators[i]] += views[i];\\n            mx = max(mx,m[creators[i]]);\\n        }\\n        sort(begin(v),end(v),[](pair<pair<long long,string>,string>&a,pair<pair<long long,string>,string>&b){if(a.first.first == b.first.first) return a < b; return a > b;});\\n        unordered_set<string> st;\\n        for(auto &_v: v){\\n            if(m[_v.second] != mx) continue;\\n            if(st.count(_v.second)) continue;\\n            st.insert(_v.second);\\n            ans.push_back({_v.second,_v.first.second});\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819404,
                "title": "simple-using-unordered-maps-beats-89",
                "content": "# Complexity\\n- Time complexity:o(n)\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,unsigned long long> viewcount;\\n        unordered_map<string,pair<string,unsigned long>> max_id;\\n        vector<vector<string>> ans;\\n        unsigned long  max_views=0;\\n        int n=creators.size();\\n        for(int i=0;i<n;i++){\\n            //counting total views of each creator\\n            viewcount[creators[i]]=viewcount[creators[i]]+views[i];\\n            //finding max views\\n            if(max_views<viewcount[creators[i]]){\\n                max_views=viewcount[creators[i]];\\n            }\\n            //finding creators id with max views and lexicographically smallest\\n            if(max_id.find(creators[i])==max_id.end()){\\n                max_id[creators[i]]=make_pair(ids[i],views[i]);\\n            }\\n            else if(max_id[creators[i]].second<views[i]){\\n                max_id[creators[i]]=make_pair(ids[i],views[i]);\\n            }\\n            else if(max_id[creators[i]].second==views[i]){\\n                if(max_id[creators[i]].first>ids[i]){\\n                   max_id[creators[i]].first=ids[i]; \\n                }\\n            }\\n\\n        }\\n        //finding ans;\\n        for(auto i:viewcount){\\n            if(max_views==i.second){\\n                ans.push_back({i.first,max_id[i.first].first});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n## PLEASE UPVOTE IF YOU LIKE THE SOLUTION \\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,unsigned long long> viewcount;\\n        unordered_map<string,pair<string,unsigned long>> max_id;\\n        vector<vector<string>> ans;\\n        unsigned long  max_views=0;\\n        int n=creators.size();\\n        for(int i=0;i<n;i++){\\n            //counting total views of each creator\\n            viewcount[creators[i]]=viewcount[creators[i]]+views[i];\\n            //finding max views\\n            if(max_views<viewcount[creators[i]]){\\n                max_views=viewcount[creators[i]];\\n            }\\n            //finding creators id with max views and lexicographically smallest\\n            if(max_id.find(creators[i])==max_id.end()){\\n                max_id[creators[i]]=make_pair(ids[i],views[i]);\\n            }\\n            else if(max_id[creators[i]].second<views[i]){\\n                max_id[creators[i]]=make_pair(ids[i],views[i]);\\n            }\\n            else if(max_id[creators[i]].second==views[i]){\\n                if(max_id[creators[i]].first>ids[i]){\\n                   max_id[creators[i]].first=ids[i]; \\n                }\\n            }\\n\\n        }\\n        //finding ans;\\n        for(auto i:viewcount){\\n            if(max_views==i.second){\\n                ans.push_back({i.first,max_id[i.first].first});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782631,
                "title": "c-2-maps-single-pass-solution-325ms-118-5mb",
                "content": "This is a nice warmup problem, one we can solve multiple ways; my approach was initially to use a single map, then I went for two as it was more readable and easier to use, not to mention cleaner to show in an interview.\\n\\nWe will start declaring a few support variables for this problem:\\n* `bestVideos` is our first map, in the `creator => {id, view}` format, matching the best video found so far for each creator;\\n* `creatorTotal` is our second map, matching `creator => overall views`;\\n* `len` will store the length of our input arrays (guaranteed to be the same for all of them);\\n* `maxViews` will store the maximum views seen so far, initially set to be `0`;\\n* `res` is our usual accumulator variable.\\n\\nWe will then loop with `i` through each element in our input and:\\n* assign `creators[i]` to `currCreator`;\\n* assign `ids[i]` to `currIds`;\\n* assign `views[i]` to `currViews`;\\n* assign the pointer to `currCreator` in `bestVideos` to `videoData`;\\n* handle three different cases:\\n    * if we never saw a video from this author (ie: `videoData == end(bestVideos)`) we will just store `{currId, currViews}` in `bestVideos[currCreator]`;\\n    * if we encountered it with less views than the current ones (ie: `videoData->second.second < currViews`), we will replace the value of `videoData->second` with `{currId, currViews}`;\\n    * if we encountered it with the same amount of views of the current ones (ie: `videoData->second.second == currViews`), we will replace the value of `videoData->second.first` (the id of the video) with the minim between its current value and `currId`;\\n* increase `creatorTotal[currCreator]` by `currViews`;\\n* set `currTotal` to the new value of `creatorTotal[currCreator]`;\\n* now again we have three cases:\\n    * if `currViews != 0` (ie: we actually increased the total for this creator) and we found the same total as the maximum (ie: `currTotal == maxViews`), then we will just push the new element `{currCreator, bestVideos[currCreator].first}` in `res`;\\n    * if we found the a newmaximum (ie: `currTotal > maxViews`), then we will:\\n        * set `maxViews` to the new value `currTotal`;\\n        * empty `res` of all its previous elements;\\n        * push the new element `{currCreator, bestVideos[currCreator].first}` in `res`;\\n    * now, the painful edge case: if we had no `currViews`, but the maximum seen so far (`maxViews`) is also `0`, then we need to check if we already inserted `currCreator` in `res` and in case update its second value with the minimum between the previous one and the current one (`currCreator`); otherwise, we again just push new element `{currCreator, bestVideos[currCreator].first}` in `res`.\\n\\nI am aware, particularly with the third case, that my code would underperform and have issues if we get a tons of creators with `0` views, but luckily this does not seem to happen :)\\n\\nOnce done, we can just `return` `res` :)\\n\\n# Complexity\\n- Time complexity: `O(n)` [except some edge cases with all the views to `0`]\\n\\n- Space complexity: `O(n)`\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        // support variables\\n        unordered_map<string, pair<string, int>> bestVideos;\\n        unordered_map<string, int> creatorTotal;\\n        int len = ids.size(), maxViews = 0;\\n        vector<vector<string>> res;\\n        // parsing each creator\\n        for (int i = 0, currTotal, resPos, currViews; i < len; i++) {\\n            // initialising loop variables\\n            auto &currCreator = creators[i], &currId = ids[i];\\n            currViews = views[i];\\n            // updating bestVideos entry for currCreator\\n            auto videoData = bestVideos.find(currCreator);\\n            // case 1: first video for this author\\n            if (videoData == end(bestVideos)) bestVideos[currCreator] = {currId, currViews};\\n            // case 2: already seen and with lower best views\\n            else if (videoData->second.second < currViews) videoData->second = {currId, currViews};\\n            // case 3: already seen and with same best views\\n            else if (videoData->second.second == currViews) videoData->second.first = min(videoData->second.first, currId);\\n            // updating total views for the user and checking if we have a new maximum\\n            currTotal = creatorTotal[currCreator] += currViews;\\n            // case 1: current views == maxViews\\n            if (currViews && currTotal == maxViews) {\\n                res.push_back({currCreator, bestVideos[currCreator].first});\\n            }\\n            // case 2: current views > maxViews\\n            else if (currTotal > maxViews) {\\n                maxViews = currTotal;\\n                res.clear();\\n                res.push_back({currCreator, bestVideos[currCreator].first});\\n            }\\n            // case 3: currViews == 0 and maxViews == 0 \\n            else if (!currViews && !maxViews) {\\n                bool alreadyInRes = false;\\n                for (int j = 0, lmt = res.size(); j < lmt; j++) {\\n                    if (res[j][0] == currCreator) {\\n                        res[j] = {currCreator, bestVideos[currCreator].first};\\n                        alreadyInRes = true;\\n                        break;\\n                    }\\n                }\\n                if (!alreadyInRes) res.push_back({currCreator, bestVideos[currCreator].first});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        // support variables\\n        unordered_map<string, pair<string, int>> bestVideos;\\n        unordered_map<string, int> creatorTotal;\\n        int len = ids.size(), maxViews = 0;\\n        vector<vector<string>> res;\\n        // parsing each creator\\n        for (int i = 0, currTotal, resPos, currViews; i < len; i++) {\\n            // initialising loop variables\\n            auto &currCreator = creators[i], &currId = ids[i];\\n            currViews = views[i];\\n            // updating bestVideos entry for currCreator\\n            auto videoData = bestVideos.find(currCreator);\\n            // case 1: first video for this author\\n            if (videoData == end(bestVideos)) bestVideos[currCreator] = {currId, currViews};\\n            // case 2: already seen and with lower best views\\n            else if (videoData->second.second < currViews) videoData->second = {currId, currViews};\\n            // case 3: already seen and with same best views\\n            else if (videoData->second.second == currViews) videoData->second.first = min(videoData->second.first, currId);\\n            // updating total views for the user and checking if we have a new maximum\\n            currTotal = creatorTotal[currCreator] += currViews;\\n            // case 1: current views == maxViews\\n            if (currViews && currTotal == maxViews) {\\n                res.push_back({currCreator, bestVideos[currCreator].first});\\n            }\\n            // case 2: current views > maxViews\\n            else if (currTotal > maxViews) {\\n                maxViews = currTotal;\\n                res.clear();\\n                res.push_back({currCreator, bestVideos[currCreator].first});\\n            }\\n            // case 3: currViews == 0 and maxViews == 0 \\n            else if (!currViews && !maxViews) {\\n                bool alreadyInRes = false;\\n                for (int j = 0, lmt = res.size(); j < lmt; j++) {\\n                    if (res[j][0] == currCreator) {\\n                        res[j] = {currCreator, bestVideos[currCreator].first};\\n                        alreadyInRes = true;\\n                        break;\\n                    }\\n                }\\n                if (!alreadyInRes) res.push_back({currCreator, bestVideos[currCreator].first});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772661,
                "title": "easy-to-understand-hashmap-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class ob{\\n        public:\\n        int tv;\\n        int mxv;\\n        string mvs;\\n    };\\n\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        map<string,ob> m;\\n        vector<vector<string>> ans;\\n        \\n        int amcv=-1;\\n        \\n        for(int i=0;i<creators.size();i++){\\n            if(m[creators[i]].mxv == views[i] ){\\n                if(m[creators[i]].mvs > ids[i] || views[i]==0) m[creators[i]].mvs = ids[i];\\n            }\\n            if(m[creators[i]].mxv < views[i]){\\n                m[creators[i]].mxv = views[i];\\n                m[creators[i]].mvs = ids[i];\\n            }\\n            m[creators[i]].tv += views[i];\\n            amcv = max(amcv,m[creators[i]].tv);\\n        }\\n        \\n        for(auto &it : m){\\n            if(it.second.tv == amcv){\\n                ans.push_back({it.first,it.second.mvs});\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class ob{\\n        public:\\n        int tv;\\n        int mxv;\\n        string mvs;\\n    };\\n\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        map<string,ob> m;\\n        vector<vector<string>> ans;\\n        \\n        int amcv=-1;\\n        \\n        for(int i=0;i<creators.size();i++){\\n            if(m[creators[i]].mxv == views[i] ){\\n                if(m[creators[i]].mvs > ids[i] || views[i]==0) m[creators[i]].mvs = ids[i];\\n            }\\n            if(m[creators[i]].mxv < views[i]){\\n                m[creators[i]].mxv = views[i];\\n                m[creators[i]].mvs = ids[i];\\n            }\\n            m[creators[i]].tv += views[i];\\n            amcv = max(amcv,m[creators[i]].tv);\\n        }\\n        \\n        for(auto &it : m){\\n            if(it.second.tv == amcv){\\n                ans.push_back({it.first,it.second.mvs});\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765763,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, pair<int, map<int,set<string>>>> mp;\\n        long maxval=0;\\n        for(int i=0; i<ids.size(); i++){\\n            mp[creators[i]].first+= views[i];\\n            if(mp[creators[i]].first>maxval) maxval= mp[creators[i]].first;\\n            mp[creators[i]].second[views[i]].insert(ids[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto i: mp){\\n            if(i.second.first==maxval){\\n                auto x= i.second.second.end();\\n                --x;\\n                auto t= x->second.begin();\\n                ans.push_back({i.first, *t});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, pair<int, map<int,set<string>>>> mp;\\n        long maxval=0;\\n        for(int i=0; i<ids.size(); i++){\\n            mp[creators[i]].first+= views[i];\\n            if(mp[creators[i]].first>maxval) maxval= mp[creators[i]].first;\\n            mp[creators[i]].second[views[i]].insert(ids[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto i: mp){\\n            if(i.second.first==maxval){\\n                auto x= i.second.second.end();\\n                --x;\\n                auto t= x->second.begin();\\n                ans.push_back({i.first, *t});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764725,
                "title": "one-hashmap-o-n-best-time-almost-and-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        vector<vector<string>> res;\\n        struct info{\\n            int mp_video; //Stores the count of most Popular video of a creator\\n            string id; //Stores the lexicographical smallest id of the creator\\n            int total; //Stores the total views of a creator\\n        };\\n        int max_tillnow = 0; //To keep track of the video with most views\\n        map<string, info> m;\\n        for (int i = 0; i < views.size(); i++){ //Creating map with all required values\\n            if(m.count(creators[i]) == 0){\\n                m[creators[i]].mp_video = views[i];\\n                m[creators[i]].id = ids[i];\\n                m[creators[i]].total = views[i];\\n                max_tillnow = max(max_tillnow, m[creators[i]].total);\\n            }\\n            else{\\n                if (views[i] > m.at(creators[i]).mp_video){\\n                    m.at(creators[i]).total += views[i];\\n                    m.at(creators[i]).id = ids[i];\\n                    m.at(creators[i]).mp_video = views[i];\\n                }\\n                else if(views[i] == m.at(creators[i]).mp_video){\\n                    if (m.at(creators[i]).id > ids[i])\\n                        m.at(creators[i]).id = ids[i];\\n                    m.at(creators[i]).total += views[i];\\n                }\\n                else {\\n                   m.at(creators[i]).total += views[i]; \\n                }\\n                max_tillnow = max(max_tillnow, m[creators[i]].total);\\n            }\\n        }\\n\\t\\t//Inserting  name and id in the result array\\n        for (auto x : m){ \\n            if(x.second.total == max_tillnow){\\n                res.push_back({x.first, x.second.id});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        vector<vector<string>> res;\\n        struct info{\\n            int mp_video; //Stores the count of most Popular video of a creator\\n            string id; //Stores the lexicographical smallest id of the creator\\n            int total; //Stores the total views of a creator\\n        };\\n        int max_tillnow = 0; //To keep track of the video with most views\\n        map<string, info> m;\\n        for (int i = 0; i < views.size(); i++){ //Creating map with all required values\\n            if(m.count(creators[i]) == 0){\\n                m[creators[i]].mp_video = views[i];\\n                m[creators[i]].id = ids[i];\\n                m[creators[i]].total = views[i];\\n                max_tillnow = max(max_tillnow, m[creators[i]].total);\\n            }\\n            else{\\n                if (views[i] > m.at(creators[i]).mp_video){\\n                    m.at(creators[i]).total += views[i];\\n                    m.at(creators[i]).id = ids[i];\\n                    m.at(creators[i]).mp_video = views[i];\\n                }\\n                else if(views[i] == m.at(creators[i]).mp_video){\\n                    if (m.at(creators[i]).id > ids[i])\\n                        m.at(creators[i]).id = ids[i];\\n                    m.at(creators[i]).total += views[i];\\n                }\\n                else {\\n                   m.at(creators[i]).total += views[i]; \\n                }\\n                max_tillnow = max(max_tillnow, m[creators[i]].total);\\n            }\\n        }\\n\\t\\t//Inserting  name and id in the result array\\n        for (auto x : m){ \\n            if(x.second.total == max_tillnow){\\n                res.push_back({x.first, x.second.id});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762251,
                "title": "just-implementation-o-n-solution-c",
                "content": "1. finding the total views for each creator, as well as also keeping the track of their highesh viewed video.\\n2. To reduce the complexity, traversing the map to find the max freq (could have sort or used map).\\n3. finding frequencies equal to maxFreq and adding them to ans\\n\\nhere iMap is used to keep the track of index of the most viewed video of the creator\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, long> mp, iMap;\\n        int n =  ids.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            mp[creators[i]] += views[i];\\n            \\n            if (iMap.find(creators[i]) == iMap.end()) {\\n                iMap[creators[i]] = i;\\n            }\\n            else {\\n                int index = iMap[creators[i]];\\n                if (views[i] > views[index]) {\\n                    iMap[creators[i]] = i;\\n                }\\n                if (views[i] == views[index] and ids[i] < ids[index]) {\\n                    iMap[creators[i]] = i;\\n                }\\n            }\\n        }\\n        \\n        long maxFreq = 0;\\n        for (auto &i: mp) {\\n            maxFreq = max(maxFreq, i.second);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        \\n        for (auto &[c, f]: mp) {\\n            if (f == maxFreq) {\\n                int index = iMap[c];\\n                ans.push_back({c, ids[index]});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, long> mp, iMap;\\n        int n =  ids.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            mp[creators[i]] += views[i];\\n            \\n            if (iMap.find(creators[i]) == iMap.end()) {\\n                iMap[creators[i]] = i;\\n            }\\n            else {\\n                int index = iMap[creators[i]];\\n                if (views[i] > views[index]) {\\n                    iMap[creators[i]] = i;\\n                }\\n                if (views[i] == views[index] and ids[i] < ids[index]) {\\n                    iMap[creators[i]] = i;\\n                }\\n            }\\n        }\\n        \\n        long maxFreq = 0;\\n        for (auto &i: mp) {\\n            maxFreq = max(maxFreq, i.second);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        \\n        for (auto &[c, f]: mp) {\\n            if (f == maxFreq) {\\n                int index = iMap[c];\\n                ans.push_back({c, ids[index]});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762244,
                "title": "java-using-map-o-n-time-no-sorting-no-priority-queue-easy-understable",
                "content": "if u like it kindly upvote \\n```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] cr, String[] ids, int[] vw) {\\n        HashMap<String, Integer> h = new HashMap<>();\\n\\n        for (int i = 0; i < cr.length; i++) {\\n            h.put(cr[i], h.getOrDefault(cr[i], 0) + vw[i]);\\n        }\\n        HashMap<String, String> h1 = new HashMap<>();\\n        HashMap<String, Integer> h2 = new HashMap<>();\\n        for (int i = 0; i < cr.length; i++) {\\n            if (!h1.containsKey(cr[i])) {\\n                h1.put(cr[i], ids[i]);\\n                h2.put(cr[i], vw[i]);\\n            } else {\\n                if (vw[i] == h2.get(cr[i])) {\\n                    int j = ids[i].compareTo(h1.get(cr[i]));\\n                    if (j < 0) {\\n                        h1.put(cr[i], ids[i]);\\n                    }\\n                } else if (vw[i] > h2.get(cr[i])) {\\n                    h1.put(cr[i], ids[i]);\\n                    h2.put(cr[i], vw[i]);\\n                }\\n            }\\n        }\\n        List<List<String>> l = new ArrayList<List<String>>();\\n\\n        int max = 0;\\n        for (int i = 0; i < h.size(); i++) {\\n            max = Math.max(h.get(cr[i]), max);\\n        }\\n        int size = h.size();\\n        for (int i = 0; i < size; i++) {\\n            if (h.get(cr[i]) == null) {\\n                break;\\n            }\\n            if (h.get(cr[i]) == max) {\\n                l.add(new ArrayList<>());\\n                l.get(l.size() - 1).add(cr[i]);\\n                l.get(l.size() - 1).add(h1.get(cr[i]));\\n                h.remove(cr[i]);\\n            }\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] cr, String[] ids, int[] vw) {\\n        HashMap<String, Integer> h = new HashMap<>();\\n\\n        for (int i = 0; i < cr.length; i++) {\\n            h.put(cr[i], h.getOrDefault(cr[i], 0) + vw[i]);\\n        }\\n        HashMap<String, String> h1 = new HashMap<>();\\n        HashMap<String, Integer> h2 = new HashMap<>();\\n        for (int i = 0; i < cr.length; i++) {\\n            if (!h1.containsKey(cr[i])) {\\n                h1.put(cr[i], ids[i]);\\n                h2.put(cr[i], vw[i]);\\n            } else {\\n                if (vw[i] == h2.get(cr[i])) {\\n                    int j = ids[i].compareTo(h1.get(cr[i]));\\n                    if (j < 0) {\\n                        h1.put(cr[i], ids[i]);\\n                    }\\n                } else if (vw[i] > h2.get(cr[i])) {\\n                    h1.put(cr[i], ids[i]);\\n                    h2.put(cr[i], vw[i]);\\n                }\\n            }\\n        }\\n        List<List<String>> l = new ArrayList<List<String>>();\\n\\n        int max = 0;\\n        for (int i = 0; i < h.size(); i++) {\\n            max = Math.max(h.get(cr[i]), max);\\n        }\\n        int size = h.size();\\n        for (int i = 0; i < size; i++) {\\n            if (h.get(cr[i]) == null) {\\n                break;\\n            }\\n            if (h.get(cr[i]) == max) {\\n                l.add(new ArrayList<>());\\n                l.get(l.size() - 1).add(cr[i]);\\n                l.get(l.size() - 1).add(h1.get(cr[i]));\\n                h.remove(cr[i]);\\n            }\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762201,
                "title": "short-python-solution",
                "content": "keep one counter for the sum of views of each creator.\\nanother hashmap for keeping track of the [id, view] of the most popular movie of each creator.\\n2 conditions must be checked:\\n\\t* the view of the movie and the alphabetical order of their id\\n\\nin both hashmaps the key is the creator.\\n```\\n    def mostPopularCreator(self, creators, ids, views):\\n        pop = Counter()\\n        most = {}\\n        most_views = 0\\n        for creator, id, view in zip(creators, ids, views):\\n            pop[creator] += view\\n            most_views = max(most_views, pop[creator])\\n            if creator not in most or view > most[creator][1] or (view == most[creator][1] and id < most[creator][0]):\\n                most[creator] = [id, view]\\n        \\n        return [[creator, most[creator][0]] for creator, view in pop.items() if view == most_views]\\n```",
                "solutionTags": [],
                "code": "```\\n    def mostPopularCreator(self, creators, ids, views):\\n        pop = Counter()\\n        most = {}\\n        most_views = 0\\n        for creator, id, view in zip(creators, ids, views):\\n            pop[creator] += view\\n            most_views = max(most_views, pop[creator])\\n            if creator not in most or view > most[creator][1] or (view == most[creator][1] and id < most[creator][0]):\\n                most[creator] = [id, view]\\n        \\n        return [[creator, most[creator][0]] for creator, view in pop.items() if view == most_views]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2759139,
                "title": "java-one-hashmap-solution-easy-solution",
                "content": "Please let me know if any explaination needed!\\n```\\nclass Pair{\\n    String name=\"\";\\n    String id=\"\";\\n    long view=0L;\\n    long maxi=0;\\n    Pair(String name,String id,int vi){\\n        this.name=name;\\n        this.id=id;\\n        view=vi;\\n        maxi=Math.max(maxi,vi); // to get to know whether the pariticular creator\\'s id has the maximum view so as to get lexicographically smallest id.\\n    }\\n}\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String,Pair> map=new TreeMap<>();\\n        long max=0L;\\n   \\n        for(int i=0;i<creators.length;i++){\\n            if(!map.containsKey(creators[i])){\\n             Pair temp=new Pair(creators[i],ids[i],views[i]);\\n                map.put(creators[i],temp);\\n            }\\n            else{\\n                Pair temp=map.get(creators[i]);\\n               \\n                if(temp.maxi<views[i] || (temp.maxi==views[i] && ids[i].compareTo(temp.id)<0)){\\n                    temp.id=ids[i];\\n                    temp.maxi=views[i];\\n                }\\n                 temp.view=temp.view+views[i];\\n            }\\n            max=Math.max(max,map.get(creators[i]).view);\\n        }\\n       \\n        List<List<String>>res=new ArrayList<>();\\n        for(Map.Entry<String,Pair> en:map.entrySet()){\\n           if(en.getValue().view==max){\\n               List<String> ls=new ArrayList<>();\\n               ls.add(en.getKey());\\n               ls.add(en.getValue().id);\\n               res.add(new ArrayList<>(ls));\\n           }\\n        }\\n\\n        return res;\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String,Pair> map=new TreeMap<>();\\n        long max=0L;\\n   \\n        for(int i=0;i<creators.length;i++){\\n            if(!map.containsKey(creators[i])){\\n             Pair temp=new Pair(creators[i],ids[i],views[i]);\\n                map.put(creators[i],temp);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2759120,
                "title": "c-dirty-code-map-multiset-priority-queue",
                "content": "**Time Taken : 1700 ms Faster than 20.5%**\\n\\n```\\nclass Solution {\\npublic:  \\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        vector<vector<string>>ans;\\n        map<string,unordered_map<int,multiset<string>>>m;\\n        for(int i=0;i<creators.size();i++){            \\n            m[creators[i]][views[i]].insert(ids[i]);\\n        }\\n       int prevView=0;\\n        priority_queue<pair<int,vector<string>>>pq;\\n        for(auto i:m){\\n            int s=0,maxView=0;\\n            for(auto j:i.second){//Popularity : sum of views               \\n                s+=(j.first*(j.second.size()));\\n                maxView=max(maxView,j.first);//Maximum view of video\\n            }          \\n                \\n                string tmp=*(i.second[maxView].begin());\\n                //cout<<maxView<<\" \";                \\n                pq.push({s,{i.first,tmp}});              \\n                prevView=max(s,prevView);\\n            \\n        }\\n        while(!pq.empty()){\\n            if(prevView==pq.top().first)\\n                ans.push_back(pq.top().second);            \\n            else\\n                break;            \\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        vector<vector<string>>ans;\\n        map<string,unordered_map<int,multiset<string>>>m;\\n        for(int i=0;i<creators.size();i++){            \\n            m[creators[i]][views[i]].insert(ids[i]);\\n        }\\n       int prevView=0;\\n        priority_queue<pair<int,vector<string>>>pq;\\n        for(auto i:m){\\n            int s=0,maxView=0;\\n            for(auto j:i.second){//Popularity : sum of views               \\n                s+=(j.first*(j.second.size()));\\n                maxView=max(maxView,j.first);//Maximum view of video\\n            }          \\n                \\n                string tmp=*(i.second[maxView].begin());\\n                //cout<<maxView<<\" \";                \\n                pq.push({s,{i.first,tmp}});              \\n                prevView=max(s,prevView);\\n            \\n        }\\n        while(!pq.empty()){\\n            if(prevView==pq.top().first)\\n                ans.push_back(pq.top().second);            \\n            else\\n                break;            \\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2759033,
                "title": "python3-2-dictionary",
                "content": "<iframe src=\"https://leetcode.com/playground/LUz6ERpj/shared\" frameBorder=\"0\" width=\"1000\" height=\"600\"></iframe>",
                "solutionTags": [],
                "code": "<iframe src=\"https://leetcode.com/playground/LUz6ERpj/shared\" frameBorder=\"0\" width=\"1000\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2759029,
                "title": "pandas",
                "content": "Doesn\\'t actually work since leetcode doesn\\'t support pandas\\n\\n\\n# Approach\\nUse pandas\\n\\n# Code\\n```\\nimport pandas as pd \\nimport numpy as np \\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        df = pd.DataFrame({\"creators\": creators, \"ids\": ids, \"views\": views})\\n        view_df = df.groupby(by=\"creators\").sum()[\"views\"]\\n        max_count = view_df.max()\\n        popular_creators = set(view_df[view_df == max_count].index)\\n        \\n        view_gb = df.groupby(by=\"creators\").max()[\"views\"]\\n        df[\"max_view\"] = [view_gb[name] for name in df[\"creators\"]]\\n        df[\"most_popular\"] = df[\"creators\"].apply(lambda x: x in popular_creators)\\n        \\n        answer_df = df[(df[\"max_view\"] == df[\"views\"]) & df[\"most_popular\"]]\\n        answer_gb = answer_df.groupby(\"creators\").min()[\"ids\"]\\n        return list(zip(answer_gb.index, answer_gb))\\n            \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport pandas as pd \\nimport numpy as np \\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        df = pd.DataFrame({\"creators\": creators, \"ids\": ids, \"views\": views})\\n        view_df = df.groupby(by=\"creators\").sum()[\"views\"]\\n        max_count = view_df.max()\\n        popular_creators = set(view_df[view_df == max_count].index)\\n        \\n        view_gb = df.groupby(by=\"creators\").max()[\"views\"]\\n        df[\"max_view\"] = [view_gb[name] for name in df[\"creators\"]]\\n        df[\"most_popular\"] = df[\"creators\"].apply(lambda x: x in popular_creators)\\n        \\n        answer_df = df[(df[\"max_view\"] == df[\"views\"]) & df[\"most_popular\"]]\\n        answer_gb = answer_df.groupby(\"creators\").min()[\"ids\"]\\n        return list(zip(answer_gb.index, answer_gb))\\n            \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758864,
                "title": "python-easy-solution-counter",
                "content": "SOLUTION -->\\n\\nINTUTION (STEPS) -->\\n\\n1. We have to first find the count of each and every creator.\\n2. We make use of a Counter to find the count of number of views of each creator.\\n3. We have another dicitonary best to store the values in key, value pair.\\n4. We then zip all the lists so that we can work with them.\\n5. Then we design the Counter --> total --> based on total[crator] += view\\n6. Then we check if the creator ie. name is present in the best dictionary or not.\\n7. If it is not present then we store it in the dictionary.\\n8. Storage --> key: value pair\\n9. key --> best[creator] and value: (view, i) # touple.\\n10. if we have the value greater than  best[creator[0]] ie. view then we have to have best[creator] = (view, i)\\n11. If we have view == best[creator][0]] and i < best[creator][1] then we have to have best[creator]\\n= (view, i)\\n12. We have to take the highest as max(total.values()).\\n13. then we take a list res to store our final results.\\n14. We loop through the total.keys().\\n15. We check if total[creator] ie. keys has value == highest.\\n16. If yes then we have to append into the result.\\n17. Append --> [creator--> keys, best[creator][1] --> values]\\n18. At last return res\\n\\n![image](https://assets.leetcode.com/users/images/a6e07533-f910-4ced-b9b7-8ac2dc8e4844_1667112654.262991.png)\\n\\n\\n        total = Counter()\\n        best = {}\\n        \\n        print(list(zip(creators, ids, views)))\\n        \\n        for creator, i, view in zip(creators, ids, views):\\n            total[creator] += view\\n        # print(total)\\n            if creator not in best:\\n                best[creator] = (view, i)\\n        # print(best)\\n            if view > best[creator][0]:\\n                best[creator] = (view, i)\\n        # print(best)\\n            elif view == best[creator][0] and i < best[creator][1]:\\n                best[creator] = (view,i)\\n        print(best)\\n        \\n        print(\\'total\\',total)\\n        \\n        highest = max(total.values())\\n        print(highest)\\n        \\n        res = []\\n        for creator in total.keys():\\n            if total[creator] == highest:\\n                #res.append([creator, i]) # [[\\'alice\\', \\'four\\'], [\\'bob\\', \\'four\\']]\\n                res.append([creator, best[creator][1]])\\n        print(res)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "SOLUTION -->\\n\\nINTUTION (STEPS) -->\\n\\n1. We have to first find the count of each and every creator.\\n2. We make use of a Counter to find the count of number of views of each creator.\\n3. We have another dicitonary best to store the values in key, value pair.\\n4. We then zip all the lists so that we can work with them.\\n5. Then we design the Counter --> total --> based on total[crator] += view\\n6. Then we check if the creator ie. name is present in the best dictionary or not.\\n7. If it is not present then we store it in the dictionary.\\n8. Storage --> key: value pair\\n9. key --> best[creator] and value: (view, i) # touple.\\n10. if we have the value greater than  best[creator[0]] ie. view then we have to have best[creator] = (view, i)\\n11. If we have view == best[creator][0]] and i < best[creator][1] then we have to have best[creator]\\n= (view, i)\\n12. We have to take the highest as max(total.values()).\\n13. then we take a list res to store our final results.\\n14. We loop through the total.keys().\\n15. We check if total[creator] ie. keys has value == highest.\\n16. If yes then we have to append into the result.\\n17. Append --> [creator--> keys, best[creator][1] --> values]\\n18. At last return res\\n\\n![image](https://assets.leetcode.com/users/images/a6e07533-f910-4ced-b9b7-8ac2dc8e4844_1667112654.262991.png)\\n\\n\\n        total = Counter()\\n        best = {}\\n        \\n        print(list(zip(creators, ids, views)))\\n        \\n        for creator, i, view in zip(creators, ids, views):\\n            total[creator] += view\\n        # print(total)\\n            if creator not in best:\\n                best[creator] = (view, i)\\n        # print(best)\\n            if view > best[creator][0]:\\n                best[creator] = (view, i)\\n        # print(best)\\n            elif view == best[creator][0] and i < best[creator][1]:\\n                best[creator] = (view,i)\\n        print(best)\\n        \\n        print(\\'total\\',total)\\n        \\n        highest = max(total.values())\\n        print(highest)\\n        \\n        res = []\\n        for creator in total.keys():\\n            if total[creator] == highest:\\n                #res.append([creator, i]) # [[\\'alice\\', \\'four\\'], [\\'bob\\', \\'four\\']]\\n                res.append([creator, best[creator][1]])\\n        print(res)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2758617,
                "title": "single-hashmap-o-n-no-sorting-commented",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate in all strings of creators.\\n2. Map is used to map Creator with => Pair of (total views  , Min Index of Highest Views in views[] array)\\n3. 2 checks while adding entries in Map:\\n    If map doesnt contain creator, put int map (creator, views , current ith inde)\\n    If map contains - > Give 3 Checks\\n        a. if current views is greater than views of min index stored in map for that creator, update min indx to curr ith index\\n        b. If cur views == views[min index] , select index of lexicographically smaller id.\\n        c. Map will contain same min index with views count added.\\n\\n4. Maintain a max to keep track of maximum views.\\n5. Lastly, iterate in map, get all the creators with their ids having views count == max. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) used for Map\\n\\n# Code\\n```\\nclass Pair{\\n    long viewsCnt;\\n    int ind;\\n    \\n    public Pair(long a, int b){\\n        viewsCnt = a;\\n        ind = b;\\n    }\\n}\\n\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String , Pair> mp = new HashMap<>();  // Creator -> Views, min index of views[] with highest views\\n        // Map<String , String> cid = new HashMap<>();  // Creator -> Lexigr. smallest Id with highest views      \\n        \\n        int n = creators.length;\\n        long max = 0;\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            \\n            if(mp.containsKey(creators[i])){\\n                long count = mp.get(creators[i]).viewsCnt;\\n                int vindex = mp.get(creators[i]).ind;\\n                \\n                if(views[i] > views[vindex]){\\n                    mp.put(creators[i] , new Pair(count+views[i] , i));\\n                }\\n                else if(views[i] == views[vindex]){\\n                    if(ids[i].compareTo(ids[vindex])>0)\\n                         mp.put(creators[i] , new Pair(count + views[i] , vindex));\\n                    else\\n                         mp.put(creators[i] , new Pair(count + views[i] ,i));\\n                }\\n                else{\\n                    mp.put(creators[i] , new Pair(count + views[i] , vindex));\\n                }                \\n            }          \\n            else{\\n                mp.put( creators[i] , new Pair(views[i] , i) );                \\n            }\\n            max = Math.max(max , mp.get(creators[i]).viewsCnt);            \\n           \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        \\n        for(Map.Entry<String, Pair> it : mp.entrySet()){\\n            if(it.getValue().viewsCnt == max){\\n                int index = it.getValue().ind;\\n                List<String> temp = new ArrayList<>();\\n                temp.add(it.getKey());\\n                temp.add(ids[index]);\\n                ans.add(temp);\\n            }\\n        }\\n        return ans;               \\n           \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    long viewsCnt;\\n    int ind;\\n    \\n    public Pair(long a, int b){\\n        viewsCnt = a;\\n        ind = b;\\n    }\\n}\\n\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String , Pair> mp = new HashMap<>();  // Creator -> Views, min index of views[] with highest views\\n        // Map<String , String> cid = new HashMap<>();  // Creator -> Lexigr. smallest Id with highest views      \\n        \\n        int n = creators.length;\\n        long max = 0;\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            \\n            if(mp.containsKey(creators[i])){\\n                long count = mp.get(creators[i]).viewsCnt;\\n                int vindex = mp.get(creators[i]).ind;\\n                \\n                if(views[i] > views[vindex]){\\n                    mp.put(creators[i] , new Pair(count+views[i] , i));\\n                }\\n                else if(views[i] == views[vindex]){\\n                    if(ids[i].compareTo(ids[vindex])>0)\\n                         mp.put(creators[i] , new Pair(count + views[i] , vindex));\\n                    else\\n                         mp.put(creators[i] , new Pair(count + views[i] ,i));\\n                }\\n                else{\\n                    mp.put(creators[i] , new Pair(count + views[i] , vindex));\\n                }                \\n            }          \\n            else{\\n                mp.put( creators[i] , new Pair(views[i] , i) );                \\n            }\\n            max = Math.max(max , mp.get(creators[i]).viewsCnt);            \\n           \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        \\n        for(Map.Entry<String, Pair> it : mp.entrySet()){\\n            if(it.getValue().viewsCnt == max){\\n                int index = it.getValue().ind;\\n                List<String> temp = new ArrayList<>();\\n                temp.add(it.getKey());\\n                temp.add(ids[index]);\\n                ans.add(temp);\\n            }\\n        }\\n        return ans;               \\n           \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758591,
                "title": "go-solution",
                "content": "```\\nfunc mostPopularCreator(A []string, B []string, C []int) [][]string {\\n    N, m1, m2, mx := len(A), make(map[string]int), make(map[string]int), 0\\n    result := make([][]string, 0)\\n    for i := 0; i < N; i++ {\\n        m1[A[i]] += C[i]\\n        if m1[A[i]] > mx {\\n            mx = m1[A[i]]\\n        }\\n    }\\n    for i := 0; i < N; i++ {\\n        if m1[A[i]] == mx {\\n            if v, ok := m2[A[i]]; ok {\\n                if (C[i] > C[v]) || (C[i] == C[v] && B[i] < B[v]) {\\n                    m2[A[i]] = i\\n                }\\n            } else {\\n                m2[A[i]] = i\\n            }\\n        }\\n    }\\n    for _, v := range m2 {\\n        result = append(result, []string{A[v], B[v]})\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mostPopularCreator(A []string, B []string, C []int) [][]string {\\n    N, m1, m2, mx := len(A), make(map[string]int), make(map[string]int), 0\\n    result := make([][]string, 0)\\n    for i := 0; i < N; i++ {\\n        m1[A[i]] += C[i]\\n        if m1[A[i]] > mx {\\n            mx = m1[A[i]]\\n        }\\n    }\\n    for i := 0; i < N; i++ {\\n        if m1[A[i]] == mx {\\n            if v, ok := m2[A[i]]; ok {\\n                if (C[i] > C[v]) || (C[i] == C[v] && B[i] < B[v]) {\\n                    m2[A[i]] = i\\n                }\\n            } else {\\n                m2[A[i]] = i\\n            }\\n        }\\n    }\\n    for _, v := range m2 {\\n        result = append(result, []string{A[v], B[v]})\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758509,
                "title": "java-hashmap",
                "content": "**The implementation took a long time and I completed after the contest ended. Due to this I missed the other questions of the contest. Only was able to do 1 question in the contest due to this complicated implementation.**\\n```\\nclass Pair{\\n    int views;\\n    String id;\\n    int sum;\\n    Pair(int views,String id,int sum){\\n        this.views=views;\\n        this.id=id;\\n        this.sum=sum;\\n    }\\n}\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        List<List<String>> res=new ArrayList<>();\\n        HashMap<String,Pair> hm=new HashMap<>();             \\n        for(int i=0;i<creators.length;i++){\\n            if(!hm.containsKey(creators[i])){\\n                hm.put(creators[i],new Pair(views[i],ids[i],views[i]));\\n            }\\n            else{\\n                Pair p=hm.get(creators[i]);\\n                p.sum+=views[i];\\n                if(views[i]>p.views){\\n                    p.views=views[i];\\n                    p.id=ids[i];\\n                }\\n                else if(p.views==views[i]){\\n                    if(p.id.compareTo(ids[i])>0)\\n                        p.id=ids[i];\\n                }\\n            }\\n        }\\n        int max=-1;\\n        for(String str:hm.keySet()){\\n            max=Math.max(max,hm.get(str).sum);\\n        }\\n        for(String str:hm.keySet()){\\n            if(hm.get(str).sum==max){\\n                List<String> li=new ArrayList<>();\\n                li.add(str);\\n                li.add(hm.get(str).id);\\n                res.add(li);\\n            }\\n        }\\n        return res;        \\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Pair{\\n    int views;\\n    String id;\\n    int sum;\\n    Pair(int views,String id,int sum){\\n        this.views=views;\\n        this.id=id;\\n        this.sum=sum;\\n    }\\n}\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        List<List<String>> res=new ArrayList<>();\\n        HashMap<String,Pair> hm=new HashMap<>();             \\n        for(int i=0;i<creators.length;i++){\\n            if(!hm.containsKey(creators[i])){\\n                hm.put(creators[i],new Pair(views[i],ids[i],views[i]));\\n            }\\n            else{\\n                Pair p=hm.get(creators[i]);\\n                p.sum+=views[i];\\n                if(views[i]>p.views){\\n                    p.views=views[i];\\n                    p.id=ids[i];\\n                }\\n                else if(p.views==views[i]){\\n                    if(p.id.compareTo(ids[i])>0)\\n                        p.id=ids[i];\\n                }\\n            }\\n        }\\n        int max=-1;\\n        for(String str:hm.keySet()){\\n            max=Math.max(max,hm.get(str).sum);\\n        }\\n        for(String str:hm.keySet()){\\n            if(hm.get(str).sum==max){\\n                List<String> li=new ArrayList<>();\\n                li.add(str);\\n                li.add(hm.get(str).id);\\n                res.add(li);\\n            }\\n        }\\n        return res;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758505,
                "title": "faster-than-100-00-java-solution-using-hashmap-and-custom-object-tc-o-n-tc-o-n",
                "content": "```\\nclass Solution {\\n\\n    private class PopularVideo {\\n\\t\\tprivate String id;\\n\\t\\tprivate int views;\\n\\t\\tprivate long viewSum;\\n\\n\\t\\tpublic PopularVideo(String id, int view) {\\n\\t\\t\\tthis.id = id;\\n\\t\\t\\tthis.views = view;\\n\\t\\t\\tthis.viewSum = view;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n\\t\\tlong maxView = 0;\\n\\t\\tMap<String, PopularVideo> map = new HashMap<>();\\n\\t\\tfor (int i = 0; i < creators.length; i++) {\\n\\t\\t\\tString creator = creators[i];\\n\\t\\t\\tString id = ids[i];\\n\\t\\t\\tint view = views[i];\\n\\t\\t\\tif (!map.containsKey(creator)) {\\n\\t\\t\\t\\tPopularVideo popularVideo = new PopularVideo(id, view);\\n\\t\\t\\t\\tmap.put(creator, popularVideo);\\n                maxView = Math.max(maxView, popularVideo.viewSum);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPopularVideo popularVideo = map.get(creator);\\n\\t\\t\\t\\tpopularVideo.viewSum += view;\\n\\t\\t\\t\\tif (popularVideo.views < view || (popularVideo.views == view && id.compareTo(popularVideo.id) < 0)) {\\n\\t\\t\\t\\t\\tpopularVideo.views = view;\\n\\t\\t\\t\\t\\tpopularVideo.id = id;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxView = Math.max(maxView, popularVideo.viewSum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tList<List<String>> ans = new ArrayList<>();\\n\\t\\tfor (String key : map.keySet()) {\\n\\t\\t\\tPopularVideo popularVideo = map.get(key);\\n\\t\\t\\tif (popularVideo.viewSum == maxView) {\\n\\t\\t\\t\\tList<String> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(key);\\n\\t\\t\\t\\tlist.add(popularVideo.id);\\n\\t\\t\\t\\tans.add(list);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private class PopularVideo {\\n\\t\\tprivate String id;\\n\\t\\tprivate int views;\\n\\t\\tprivate long viewSum;\\n\\n\\t\\tpublic PopularVideo(String id, int view) {\\n\\t\\t\\tthis.id = id;\\n\\t\\t\\tthis.views = view;\\n\\t\\t\\tthis.viewSum = view;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n\\t\\tlong maxView = 0;\\n\\t\\tMap<String, PopularVideo> map = new HashMap<>();\\n\\t\\tfor (int i = 0; i < creators.length; i++) {\\n\\t\\t\\tString creator = creators[i];\\n\\t\\t\\tString id = ids[i];\\n\\t\\t\\tint view = views[i];\\n\\t\\t\\tif (!map.containsKey(creator)) {\\n\\t\\t\\t\\tPopularVideo popularVideo = new PopularVideo(id, view);\\n\\t\\t\\t\\tmap.put(creator, popularVideo);\\n                maxView = Math.max(maxView, popularVideo.viewSum);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPopularVideo popularVideo = map.get(creator);\\n\\t\\t\\t\\tpopularVideo.viewSum += view;\\n\\t\\t\\t\\tif (popularVideo.views < view || (popularVideo.views == view && id.compareTo(popularVideo.id) < 0)) {\\n\\t\\t\\t\\t\\tpopularVideo.views = view;\\n\\t\\t\\t\\t\\tpopularVideo.id = id;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxView = Math.max(maxView, popularVideo.viewSum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tList<List<String>> ans = new ArrayList<>();\\n\\t\\tfor (String key : map.keySet()) {\\n\\t\\t\\tPopularVideo popularVideo = map.get(key);\\n\\t\\t\\tif (popularVideo.viewSum == maxView) {\\n\\t\\t\\t\\tList<String> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(key);\\n\\t\\t\\t\\tlist.add(popularVideo.id);\\n\\t\\t\\t\\tans.add(list);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758472,
                "title": "failing-the-last-test-case-passing-81-82-explained",
                "content": "My submission fails the very last test case, and the test case is hidden, so I can only figure it out after the contest is over! \\n\\nThe accepted solution only considers the viewing # from one entry of (Creator, ID) pair from the input, so it does not expect viewing numbers to be accumulated for the same video from the same creator. \\n\\n[\"alice\", \"alice\", \"alice\"]\\n[\"a\", \"b\", \"a\"]\\n[15, 20, 15]  \\n\\nThe expected answer from above is [[\"alice\", \"b\"]].  In my opinion, this is incorrect, at least not clearly stated.",
                "solutionTags": [],
                "code": "My submission fails the very last test case, and the test case is hidden, so I can only figure it out after the contest is over! \\n\\nThe accepted solution only considers the viewing # from one entry of (Creator, ID) pair from the input, so it does not expect viewing numbers to be accumulated for the same video from the same creator. \\n\\n[\"alice\", \"alice\", \"alice\"]\\n[\"a\", \"b\", \"a\"]\\n[15, 20, 15]  \\n\\nThe expected answer from above is [[\"alice\", \"b\"]].  In my opinion, this is incorrect, at least not clearly stated.",
                "codeTag": "Unknown"
            },
            {
                "id": 2758424,
                "title": "test-case-wrong-question-not-clearly-state-the-condition-for-the-same-video-id-from-same-creator",
                "content": "solution does not consider the case where same creator with same video id  were inputs\\n\\nit only ask individual video\\'s most view not cumulative one\\n\\nplease check below solution and test case\\n\\nBelow test case \\ncreator \"l\"\\nmost viewed video is should be \"a\" , NOT \"vy\"\\nbecause cumulative sum follows\\n```\\na, 785689\\nvy, 99983\\n```\\n\\nhttps://leetcode.com/submissions/detail/833128793/testcase/\\n\\n\\n```\\nclass Solution {\\n    \\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n                             \\n        Map<String,Map<String,Long>> map=new HashMap<>();        \\n        Map<String,Long> viewMap=new HashMap<>();\\n        int n=creators.length;\\n        long maxView=0;\\n        \\n        for(int i=0;i<n;i++){\\n            String name=creators[i],id=ids[i];\\n            long view=views[i];\\n            \\n            map.putIfAbsent(name,new HashMap<>());            \\n            map.get(name).put(id,map.get(name).getOrDefault(id,0L)+view);              \\n            \\n            viewMap.put(name,viewMap.getOrDefault(name,0L)+view);                                    \\n            maxView=Math.max(maxView,viewMap.get(name));\\n        }\\n                 \\n        List<List<String>> res = new ArrayList<>();\\n        \\n        for(Map.Entry<String,Map<String,Long>> et:map.entrySet()){\\n            \\n            String name=et.getKey();\\n            long view=viewMap.get(name);\\n                        \\n            if(view<maxView) continue;\\n            \\n            Map<String,Long> map2=et.getValue();\\n            List<Map.Entry<String,Long>> list=map2.entrySet().stream().collect(Collectors.toList());\\n            \\n            Collections.sort(list,(a,b)->{\\n                if(a.getValue().equals(b.getValue())){\\n                    return a.getKey().compareTo(b.getKey());\\n                }                \\n                return Long.compare(b.getValue(),a.getValue());\\n            });\\n            \\n                        \\n            res.add(Arrays.asList(name,list.get(0).getKey()));\\n        }        \\n        \\n        return res;\\n    }\\n}\\n\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\na, 785689\\nvy, 99983\\n```\n```\\nclass Solution {\\n    \\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n                             \\n        Map<String,Map<String,Long>> map=new HashMap<>();        \\n        Map<String,Long> viewMap=new HashMap<>();\\n        int n=creators.length;\\n        long maxView=0;\\n        \\n        for(int i=0;i<n;i++){\\n            String name=creators[i],id=ids[i];\\n            long view=views[i];\\n            \\n            map.putIfAbsent(name,new HashMap<>());            \\n            map.get(name).put(id,map.get(name).getOrDefault(id,0L)+view);              \\n            \\n            viewMap.put(name,viewMap.getOrDefault(name,0L)+view);                                    \\n            maxView=Math.max(maxView,viewMap.get(name));\\n        }\\n                 \\n        List<List<String>> res = new ArrayList<>();\\n        \\n        for(Map.Entry<String,Map<String,Long>> et:map.entrySet()){\\n            \\n            String name=et.getKey();\\n            long view=viewMap.get(name);\\n                        \\n            if(view<maxView) continue;\\n            \\n            Map<String,Long> map2=et.getValue();\\n            List<Map.Entry<String,Long>> list=map2.entrySet().stream().collect(Collectors.toList());\\n            \\n            Collections.sort(list,(a,b)->{\\n                if(a.getValue().equals(b.getValue())){\\n                    return a.getKey().compareTo(b.getKey());\\n                }                \\n                return Long.compare(b.getValue(),a.getValue());\\n            });\\n            \\n                        \\n            res.add(Arrays.asList(name,list.get(0).getKey()));\\n        }        \\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758289,
                "title": "python-answer-heap-dict-solution",
                "content": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n\\n        pop = defaultdict(int)\\n\\n        pop_small = defaultdict(list)\\n\\n        for i,creator in enumerate(creators):\\n            \\n            pop[creator] += views[i]\\n            \\n            heappush(pop_small[creator], [-views[i],ids[i]])\\n        \\n        m = max(pop.values())\\n        \\n        res = []\\n        for creator in pop:\\n            if pop[creator] == m:\\n                res.append([creator, pop_small[creator][0][1]])\\n\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n\\n        pop = defaultdict(int)\\n\\n        pop_small = defaultdict(list)\\n\\n        for i,creator in enumerate(creators):\\n            \\n            pop[creator] += views[i]\\n            \\n            heappush(pop_small[creator], [-views[i],ids[i]])\\n        \\n        m = max(pop.values())\\n        \\n        res = []\\n        for creator in pop:\\n            if pop[creator] == m:\\n                res.append([creator, pop_small[creator][0][1]])\\n\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758179,
                "title": "simple-cpp-solution-map-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& id, vector<int>& views) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,set<pair<int,string>>> maxid;\\n        unordered_map<string,long long> sum;\\n        int n=c.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sum[c[i]]+=views[i];\\n            maxid[c[i]].insert({-views[i],id[i]});\\n        }\\n        long long res=0;\\n        for(auto x:sum)\\n        {\\n            if(x.second>res)\\n            {\\n                res=x.second;\\n            }\\n        }\\n        for(auto x:sum)\\n        {\\n            if(x.second==res)\\n            {\\n                auto it = *(maxid[x.first].begin());\\n                auto y=it.second;\\n                \\n                ans.push_back({x.first,y});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& id, vector<int>& views) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,set<pair<int,string>>> maxid;\\n        unordered_map<string,long long> sum;\\n        int n=c.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sum[c[i]]+=views[i];\\n            maxid[c[i]].insert({-views[i],id[i]});\\n        }\\n        long long res=0;\\n        for(auto x:sum)\\n        {\\n            if(x.second>res)\\n            {\\n                res=x.second;\\n            }\\n        }\\n        for(auto x:sum)\\n        {\\n            if(x.second==res)\\n            {\\n                auto it = *(maxid[x.first].begin());\\n                auto y=it.second;\\n                \\n                ans.push_back({x.first,y});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758176,
                "title": "two-hashmap",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<string>arr;\\n    vector<vector<string>>ans;\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views,long long mx=-1) {\\n        unordered_map<string, vector<pair<string, int>>>mp;\\n        unordered_map<string, long long>mp1;\\n        \\n        for(int i=0;i<creators.size();i++)mp[creators[i]].push_back({ids[i], views[i]}), mp1[creators[i]]+=views[i];\\n        \\n        for(auto ele:mp1)mx= max(mx, ele.second);\\n        for(auto ele:mp1)if(ele.second==mx)arr.push_back(ele.first);\\n        \\n        for(auto ele:arr){\\n            sort(mp[ele].begin(), mp[ele].end(),[&](auto a ,auto b){\\n                 if(a.second!=b.second) return a.second>b.second; \\n                return a.first<b.first;\\n            });\\n            ans.push_back({ele,mp[ele][0].first});\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>arr;\\n    vector<vector<string>>ans;\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views,long long mx=-1) {\\n        unordered_map<string, vector<pair<string, int>>>mp;\\n        unordered_map<string, long long>mp1;\\n        \\n        for(int i=0;i<creators.size();i++)mp[creators[i]].push_back({ids[i], views[i]}), mp1[creators[i]]+=views[i];\\n        \\n        for(auto ele:mp1)mx= max(mx, ele.second);\\n        for(auto ele:mp1)if(ele.second==mx)arr.push_back(ele.first);\\n        \\n        for(auto ele:arr){\\n            sort(mp[ele].begin(), mp[ele].end(),[&](auto a ,auto b){\\n                 if(a.second!=b.second) return a.second>b.second; \\n                return a.first<b.first;\\n            });\\n            ans.push_back({ele,mp[ele][0].first});\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758109,
                "title": "map-pq-cpp-code",
                "content": "```\\n//Jai Shree Ram\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        priority_queue< pair<long long, pair<string, string>>>pq;\\n        unordered_map<string, vector<pair<long long, string>>>mp;\\n        vector<vector<string>>ans;\\n        int i = 0;\\n        unordered_map<string, long long>di;\\n        for(auto it : creators)\\n        {\\n            mp[it].push_back({-views[i],ids[i]});\\n            di[it] += views[i];\\n            i++;\\n        }\\n        for(auto it : di)\\n        {\\n            sort(mp[it.first].begin(), mp[it.first].end());\\n            string s = mp[it.first][0].second;\\n            // cout << it.first << \" \" << it.second.first << \" \" << it.second.second << endl;\\n            pq.push({di[it.first], {it.first, s}});\\n        }\\n        int mx = pq.top().first;\\n        while(!pq.empty())\\n        {\\n            pair<int, pair<string, string>>pr = pq.top();\\n            pq.pop();\\n            int f = pr.first;\\n            if(f == mx)\\n            {\\n                ans.push_back({pr.second.first, pr.second.second});\\n            }\\n            else\\n                break;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Jai Shree Ram\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        priority_queue< pair<long long, pair<string, string>>>pq;\\n        unordered_map<string, vector<pair<long long, string>>>mp;\\n        vector<vector<string>>ans;\\n        int i = 0;\\n        unordered_map<string, long long>di;\\n        for(auto it : creators)\\n        {\\n            mp[it].push_back({-views[i],ids[i]});\\n            di[it] += views[i];\\n            i++;\\n        }\\n        for(auto it : di)\\n        {\\n            sort(mp[it.first].begin(), mp[it.first].end());\\n            string s = mp[it.first][0].second;\\n            // cout << it.first << \" \" << it.second.first << \" \" << it.second.second << endl;\\n            pq.push({di[it.first], {it.first, s}});\\n        }\\n        int mx = pq.top().first;\\n        while(!pq.empty())\\n        {\\n            pair<int, pair<string, string>>pr = pq.top();\\n            pq.pop();\\n            int f = pr.first;\\n            if(f == mx)\\n            {\\n                ans.push_back({pr.second.first, pr.second.second});\\n            }\\n            else\\n                break;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2758093,
                "title": "2-hashmaps-custom-comparator-commented",
                "content": "**Steps:**\\n**1. Maintain 2 HashMaps. One for finding the creators with highest views. The other for keeping track of creators with [ their movie id and views ].\\n2. Now find the creators with highest views (from first map). Either iterate over them or use a TreeMap instead.\\n3. Now for each popular creator, sort their movies by views in decreasing order. If 2 movies have same views, sort them by id lexicographically.\\n4. Return the ans.**\\n```java\\nclass Solution {\\n    class Pair {\\n        String id;\\n        int views;\\n        Pair(String i, int v) {\\n            this.id = i;\\n            this.views = v;\\n        }\\n    }\\n    \\n    class Custom_comparator implements Comparator<Pair>{\\n        @Override\\n        public int compare(Pair p1, Pair p2) {\\n            if (p1.views == p2.views) return p1.id.compareTo(p2.id);\\n            return p2.views-p1.views;\\n        }\\n    }\\n    \\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, Integer> viewsMap = new HashMap<>();    // [creator, total_views]\\n        Map<String, List<Pair>> map = new HashMap<>();      // [creator, [(id, view)]]\\n        \\n        int n = ids.length;\\n        for (int i = 0; i < n; i++) {\\n            String creator = creators[i];\\n            viewsMap.put(creator, viewsMap.getOrDefault(creator, 0) + views[i]);   // calculate total views for a creator\\n            \\n            if (!map.containsKey(creator)) {\\n                map.put(creator, new ArrayList<Pair>()); \\n            }\\n            map.get(creator).add(new Pair(ids[i], views[i]));                  // keep track of creator with [id, views]\\n        }\\n        \\n        int maxViews = (Collections.max(viewsMap.values()));                  // get max views\\n        List<String> popularCreators = new ArrayList<>();                     // stores creators with max views\\n        for (var entry : viewsMap.entrySet()) {\\n            if (entry.getValue()==maxViews) {\\n                popularCreators.add(entry.getKey());  \\n            }\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        for (String creator : popularCreators) {\\n            List<Pair> list = map.get(creator);\\n            Collections.sort(list, new Custom_comparator());           // sort by views in decreasing order. If 2 movies have same views, sort them by id lexicographically.\\n            List<String> ansList = new ArrayList<>();\\n            ansList.add(creator);\\n            ansList.add(list.get(0).id);                               // popular creator with movie id having highest views\\n            ans.add(ansList);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n````",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    class Pair {\\n        String id;\\n        int views;\\n        Pair(String i, int v) {\\n            this.id = i;\\n            this.views = v;\\n        }\\n    }\\n    \\n    class Custom_comparator implements Comparator<Pair>{\\n        @Override\\n        public int compare(Pair p1, Pair p2) {\\n            if (p1.views == p2.views) return p1.id.compareTo(p2.id);\\n            return p2.views-p1.views;\\n        }\\n    }\\n    \\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, Integer> viewsMap = new HashMap<>();    // [creator, total_views]\\n        Map<String, List<Pair>> map = new HashMap<>();      // [creator, [(id, view)]]\\n        \\n        int n = ids.length;\\n        for (int i = 0; i < n; i++) {\\n            String creator = creators[i];\\n            viewsMap.put(creator, viewsMap.getOrDefault(creator, 0) + views[i]);   // calculate total views for a creator\\n            \\n            if (!map.containsKey(creator)) {\\n                map.put(creator, new ArrayList<Pair>()); \\n            }\\n            map.get(creator).add(new Pair(ids[i], views[i]));                  // keep track of creator with [id, views]\\n        }\\n        \\n        int maxViews = (Collections.max(viewsMap.values()));                  // get max views\\n        List<String> popularCreators = new ArrayList<>();                     // stores creators with max views\\n        for (var entry : viewsMap.entrySet()) {\\n            if (entry.getValue()==maxViews) {\\n                popularCreators.add(entry.getKey());  \\n            }\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        for (String creator : popularCreators) {\\n            List<Pair> list = map.get(creator);\\n            Collections.sort(list, new Custom_comparator());           // sort by views in decreasing order. If 2 movies have same views, sort them by id lexicographically.\\n            List<String> ansList = new ArrayList<>();\\n            ansList.add(creator);\\n            ansList.add(list.get(0).id);                               // popular creator with movie id having highest views\\n            ans.add(ansList);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758092,
                "title": "ugly-hashmap-set-sorting-solution",
                "content": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        hashmap=dict()\\n        for i in range(len(creators)):\\n            if creators[i] not in hashmap:\\n                hashmap[creators[i]]=[[views[i]]]\\n                hashmap[creators[i]].append(ids[i])\\n            else:\\n                hashmap[creators[i]][0].append(views[i])\\n                hashmap[creators[i]].append(ids[i])\\n                \\n        \\n        maxsum=0\\n        for i in hashmap:\\n            maxsum=max((sum(hashmap[i][0])),maxsum)\\n            \\n        popcreator=set()\\n        for i in hashmap:\\n            if sum(hashmap[i][0])==maxsum:\\n                popcreator.add(i)\\n        \\n        popids=[]\\n        for i in hashmap:\\n            if i in popcreator:\\n                temp=[]\\n                tempmax=max(hashmap[i][0])\\n                for j in range(len(hashmap[i][0])):\\n                    if hashmap[i][0][j]==tempmax:\\n                        \\n                        temp.append(hashmap[i][j+1])\\n                temp.sort()\\n                popids.append([temp[0],i])\\n        popids.sort()\\n        for i in popids:\\n            i[0],i[1]=i[1],i[0]\\n            \\n        return(popids)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        hashmap=dict()\\n        for i in range(len(creators)):\\n            if creators[i] not in hashmap:\\n                hashmap[creators[i]]=[[views[i]]]\\n                hashmap[creators[i]].append(ids[i])\\n            else:\\n                hashmap[creators[i]][0].append(views[i])\\n                hashmap[creators[i]].append(ids[i])\\n                \\n        \\n        maxsum=0\\n        for i in hashmap:\\n            maxsum=max((sum(hashmap[i][0])),maxsum)\\n            \\n        popcreator=set()\\n        for i in hashmap:\\n            if sum(hashmap[i][0])==maxsum:\\n                popcreator.add(i)\\n        \\n        popids=[]\\n        for i in hashmap:\\n            if i in popcreator:\\n                temp=[]\\n                tempmax=max(hashmap[i][0])\\n                for j in range(len(hashmap[i][0])):\\n                    if hashmap[i][0][j]==tempmax:\\n                        \\n                        temp.append(hashmap[i][j+1])\\n                temp.sort()\\n                popids.append([temp[0],i])\\n        popids.sort()\\n        for i in popids:\\n            i[0],i[1]=i[1],i[0]\\n            \\n        return(popids)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758054,
                "title": "c-dictionary",
                "content": "```\\n    public IList<IList<string>> MostPopularCreator(string[] creators, string[] ids, int[] views) \\n    {\\n        // key: Creator     -  value TotalView - HighestView - HighestId\\n        Dictionary<string, (int, int, string)> freq = new Dictionary<string, (int, int, string)>();\\n        for (int i = 0; i < creators.Length; i++)\\n        {\\n            if (freq.ContainsKey(creators[i]))\\n            {\\n                int totalView = freq[creators[i]].Item1 + views[i];\\n                int highestView = freq[creators[i]].Item2;\\n                string highestId = freq[creators[i]].Item3;\\n                if (views[i] > freq[creators[i]].Item2 || (views[i] == freq[creators[i]].Item2 && string.Compare(ids[i], freq[creators[i]].Item3) < 0))\\n                {\\n                    highestView = views[i];\\n                    highestId = ids[i];\\n                }\\n                freq[creators[i]] = (totalView, highestView, highestId);\\n            }\\n            else\\n            {\\n                freq.Add(creators[i], (views[i], views[i], ids[i]));\\n            }\\n        }\\n        int max = freq.Max(f => f.Value.Item1);\\n\\n        IList<IList<string>> result = new List<IList<string>>();\\n        foreach (var kv in freq.Where(f => f.Value.Item1 == max))\\n        {\\n            result.Add(new List<string> { kv.Key, kv.Value.Item3 });\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<IList<string>> MostPopularCreator(string[] creators, string[] ids, int[] views) \\n    {\\n        // key: Creator     -  value TotalView - HighestView - HighestId\\n        Dictionary<string, (int, int, string)> freq = new Dictionary<string, (int, int, string)>();\\n        for (int i = 0; i < creators.Length; i++)\\n        {\\n            if (freq.ContainsKey(creators[i]))\\n            {\\n                int totalView = freq[creators[i]].Item1 + views[i];\\n                int highestView = freq[creators[i]].Item2;\\n                string highestId = freq[creators[i]].Item3;\\n                if (views[i] > freq[creators[i]].Item2 || (views[i] == freq[creators[i]].Item2 && string.Compare(ids[i], freq[creators[i]].Item3) < 0))\\n                {\\n                    highestView = views[i];\\n                    highestId = ids[i];\\n                }\\n                freq[creators[i]] = (totalView, highestView, highestId);\\n            }\\n            else\\n            {\\n                freq.Add(creators[i], (views[i], views[i], ids[i]));\\n            }\\n        }\\n        int max = freq.Max(f => f.Value.Item1);\\n\\n        IList<IList<string>> result = new List<IList<string>>();\\n        foreach (var kv in freq.Where(f => f.Value.Item1 == max))\\n        {\\n            result.Add(new List<string> { kv.Key, kv.Value.Item3 });\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758048,
                "title": "c-unordered-map-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, string>m;\\n        unordered_map<string, int>m1;\\n        unordered_map<string, vector<int>>m2;\\n        for(int i=0; i<creators.size(); i++){\\n            m1[creators[i]]=views[i];\\n            m[creators[i]]=ids[i];\\n            m2[creators[i]].push_back(views[i]);\\n        }\\n        map<string, int>chk;\\n        \\n        for(auto it: m2){\\n            long long int sum=0;\\n            //cout<<it.first<<endl;\\n            for(auto it1: it.second){\\n                //cout<<it1<<\" \";\\n                sum+=it1;\\n            }\\n            // cout<<\" \"<<sum<<endl;\\n            // cout<<endl;\\n            chk[it.first]=sum;\\n            //maxi=max(maxi, sum);\\n        }\\n        for(int i=0; i<creators.size(); i++){\\n            int num=m1[creators[i]];\\n            if(num<views[i]){\\n                \\n                m1[creators[i]]=views[i];\\n                m[creators[i]]=ids[i];\\n            }\\n            else if(num==views[i]){\\n                string x=min(ids[i], m[creators[i]]);\\n                m[creators[i]]=x;\\n            }\\n        }\\n        // for(auto it: m1){\\n        //     cout<<it.first<<\" \"<<it.second<<endl;\\n        // }\\n        // for(auto it: m){\\n        //     cout<<it.first<<\" \"<<it.second<<endl;;\\n        // }\\n        vector<vector<string>>ans;\\n        vector<pair<long long int, string>>v;\\n        for(auto it: chk){\\n            //cout<<maxi<<endl;\\n            //cout<<chk[it.first]<<\" \"<<it.first<<endl;\\n            //if(chk[it.first]==maxi){\\n                v.push_back({it.second, it.first});\\n            // }\\n        }\\n        sort(v.begin(), v.end());\\n        // for(int i=0; i<v.size(); i++){\\n        //     cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n        // }\\n        // if(v.size()>1){\\n        //     if(v[0].first!=v[1].first){\\n        //         v.erase(v.begin());\\n        //     }\\n        // }\\n        reverse(v.begin(), v.end());\\n        long long int maxi=v[0].first;\\n        // for(int i=0; i<v.size(); i++){\\n        //     cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n        // }\\n        \\n        for(int i=0; i<v.size(); i++){\\n            if(maxi==v[i].first){\\n            vector<string>temp;\\n            temp.push_back(v[i].second);\\n            temp.push_back(m[v[i].second]);\\n            ans.push_back(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, string>m;\\n        unordered_map<string, int>m1;\\n        unordered_map<string, vector<int>>m2;\\n        for(int i=0; i<creators.size(); i++){\\n            m1[creators[i]]=views[i];\\n            m[creators[i]]=ids[i];\\n            m2[creators[i]].push_back(views[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2758019,
                "title": "easy-java-solution",
                "content": "link-> https://www.pbtelugusite.xyz/2022/10/solution-6221most-popular-video-creator.html",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2757994,
                "title": "java-treemap-solution",
                "content": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, Integer> totalViews = new HashMap<>();\\n        for (int i = 0; i < creators.length; i++) {\\n            String creator = creators[i];\\n            String id = ids[i];\\n            int viewsForId = views[i];\\n            totalViews.put(creator, totalViews.getOrDefault(creator, 0) + viewsForId);\\n        }\\n        int maxViews = Integer.MIN_VALUE;\\n        for (Map.Entry<String, Integer> entry : totalViews.entrySet()) {\\n            String creator = entry.getKey();\\n            int totalViewsForCreator = entry.getValue();\\n            if (totalViewsForCreator > maxViews) {\\n                maxViews = totalViewsForCreator;\\n            }\\n        }\\n        List<String> creatorsWithMaxViews = new ArrayList<>();\\n        for (Map.Entry<String, Integer> entry : totalViews.entrySet()) {\\n            String creator = entry.getKey();\\n            int totalViewsForCreator = entry.getValue();\\n            if (totalViewsForCreator == maxViews) {\\n                creatorsWithMaxViews.add(creator);\\n            }\\n        }\\n        Map<String, TreeMap<Integer, TreeSet<String>>> map = new HashMap<>();\\n        for (int i = 0; i < creators.length; i++) {\\n            String creator = creators[i];\\n            String id = ids[i];\\n            int viewsForId = views[i];\\n            if (map.containsKey(creator)) {\\n                TreeMap<Integer, TreeSet<String>> treeMap = map.get(creator);\\n                if (treeMap.containsKey(viewsForId)) {\\n                    TreeSet<String> treeSet = treeMap.get(viewsForId);\\n                    treeSet.add(id);\\n                    treeMap.put(viewsForId, treeSet);\\n                } else {\\n                    TreeSet<String> treeSet = new TreeSet<>();\\n                    treeSet.add(id);\\n                    treeMap.put(viewsForId, treeSet);\\n                }\\n                map.put(creator, treeMap);\\n            } else {\\n                TreeMap<Integer, TreeSet<String>> treeMap = new TreeMap<>();\\n                TreeSet<String> treeSet = new TreeSet<>();\\n                treeSet.add(id);\\n                treeMap.put(viewsForId, treeSet);\\n                map.put(creator, treeMap); \\n            } \\n        }\\n        List<List<String>> result = new ArrayList<>();\\n        for (int i = 0; i < creatorsWithMaxViews.size(); i++) {\\n            String creatorWithMaxViews = creatorsWithMaxViews.get(i);\\n            String maxId = map.get(creatorWithMaxViews).lastEntry().getValue().first();\\n            List<String> creatorResult = new ArrayList<>();\\n            creatorResult.add(creatorWithMaxViews);\\n            creatorResult.add(maxId);\\n            result.add(creatorResult);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, Integer> totalViews = new HashMap<>();\\n        for (int i = 0; i < creators.length; i++) {\\n            String creator = creators[i];\\n            String id = ids[i];\\n            int viewsForId = views[i];\\n            totalViews.put(creator, totalViews.getOrDefault(creator, 0) + viewsForId);\\n        }\\n        int maxViews = Integer.MIN_VALUE;\\n        for (Map.Entry<String, Integer> entry : totalViews.entrySet()) {\\n            String creator = entry.getKey();\\n            int totalViewsForCreator = entry.getValue();\\n            if (totalViewsForCreator > maxViews) {\\n                maxViews = totalViewsForCreator;\\n            }\\n        }\\n        List<String> creatorsWithMaxViews = new ArrayList<>();\\n        for (Map.Entry<String, Integer> entry : totalViews.entrySet()) {\\n            String creator = entry.getKey();\\n            int totalViewsForCreator = entry.getValue();\\n            if (totalViewsForCreator == maxViews) {\\n                creatorsWithMaxViews.add(creator);\\n            }\\n        }\\n        Map<String, TreeMap<Integer, TreeSet<String>>> map = new HashMap<>();\\n        for (int i = 0; i < creators.length; i++) {\\n            String creator = creators[i];\\n            String id = ids[i];\\n            int viewsForId = views[i];\\n            if (map.containsKey(creator)) {\\n                TreeMap<Integer, TreeSet<String>> treeMap = map.get(creator);\\n                if (treeMap.containsKey(viewsForId)) {\\n                    TreeSet<String> treeSet = treeMap.get(viewsForId);\\n                    treeSet.add(id);\\n                    treeMap.put(viewsForId, treeSet);\\n                } else {\\n                    TreeSet<String> treeSet = new TreeSet<>();\\n                    treeSet.add(id);\\n                    treeMap.put(viewsForId, treeSet);\\n                }\\n                map.put(creator, treeMap);\\n            } else {\\n                TreeMap<Integer, TreeSet<String>> treeMap = new TreeMap<>();\\n                TreeSet<String> treeSet = new TreeSet<>();\\n                treeSet.add(id);\\n                treeMap.put(viewsForId, treeSet);\\n                map.put(creator, treeMap); \\n            } \\n        }\\n        List<List<String>> result = new ArrayList<>();\\n        for (int i = 0; i < creatorsWithMaxViews.size(); i++) {\\n            String creatorWithMaxViews = creatorsWithMaxViews.get(i);\\n            String maxId = map.get(creatorWithMaxViews).lastEntry().getValue().first();\\n            List<String> creatorResult = new ArrayList<>();\\n            creatorResult.add(creatorWithMaxViews);\\n            creatorResult.add(maxId);\\n            result.add(creatorResult);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094509,
                "title": "rust-73ms",
                "content": "# Code\\n```\\nuse std::collections::BTreeMap;\\n\\nimpl Solution {\\n    pub fn most_popular_creator(\\n        creators: Vec<String>,\\n        ids: Vec<String>,\\n        views: Vec<i32>,\\n    ) -> Vec<Vec<String>> {\\n        let mut max_views = -1;\\n        // Creator Map = \\n        //     { Creator: (Total Views, Most Viewed Video ID, Most Views on Video) }\\n        let mut creator_map: BTreeMap<String, (i64, String, i64)> = BTreeMap::new();\\n        creators\\n            .into_iter()\\n            .zip(ids.into_iter().zip(views.into_iter().map(|v| v as i64)))\\n            // (Streamer, (Video Id, Video Views))\\n            .for_each(|(n, (i, v))| {\\n                creator_map\\n                    .entry(n)\\n                    .and_modify(|(t, id, m)| {\\n                        *t += v;\\n                        max_views = max_views.max(*t);\\n\\n                        if v == *m && id.bytes().gt(i.bytes()) {\\n                            *id = i.clone()\\n                        }\\n\\n                        if v > *m {\\n                            *m = v;\\n                            *id = i.clone()\\n                        }\\n                    })\\n                    .or_insert({\\n                        max_views = max_views.max(v);\\n                        (v, i, v)\\n                    });\\n            });\\n\\n        creator_map\\n            .into_iter()\\n            .filter_map(|(n, (v, i, _))| (v == max_views).then(|| vec![n, i]))\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BTreeMap;\\n\\nimpl Solution {\\n    pub fn most_popular_creator(\\n        creators: Vec<String>,\\n        ids: Vec<String>,\\n        views: Vec<i32>,\\n    ) -> Vec<Vec<String>> {\\n        let mut max_views = -1;\\n        // Creator Map = \\n        //     { Creator: (Total Views, Most Viewed Video ID, Most Views on Video) }\\n        let mut creator_map: BTreeMap<String, (i64, String, i64)> = BTreeMap::new();\\n        creators\\n            .into_iter()\\n            .zip(ids.into_iter().zip(views.into_iter().map(|v| v as i64)))\\n            // (Streamer, (Video Id, Video Views))\\n            .for_each(|(n, (i, v))| {\\n                creator_map\\n                    .entry(n)\\n                    .and_modify(|(t, id, m)| {\\n                        *t += v;\\n                        max_views = max_views.max(*t);\\n\\n                        if v == *m && id.bytes().gt(i.bytes()) {\\n                            *id = i.clone()\\n                        }\\n\\n                        if v > *m {\\n                            *m = v;\\n                            *id = i.clone()\\n                        }\\n                    })\\n                    .or_insert({\\n                        max_views = max_views.max(v);\\n                        (v, i, v)\\n                    });\\n            });\\n\\n        creator_map\\n            .into_iter()\\n            .filter_map(|(n, (v, i, _))| (v == max_views).then(|| vec![n, i]))\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080443,
                "title": "c-simple-explanation-o-n-time-beats-99",
                "content": "# Approach\\nFirst, accumulate all the views for each creator and determine their most popular video. If there are multiple videos with the same highest view count, select the one with the lexicographically smallest ID. Additionally, track the overall highest popularity across all creators.\\n\\nAfter this, identify the creators who have the highest popularity and store them, along with the ID of their most popular video, in the final_data vector.\\n\\nThis process can be accomplished in linear time.\\n\\nWe utilize long long data type since there are test cases with large numbers, although there might be potential for optimization.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of videos. We iterate once over the list of videos and once over the unique creators, which in the worst case could be O(n). Therefore, the overall complexity remains linear.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct CreatorInfo {\\n        long long totalViews = 0;\\n        string mostViewedId = \"\";\\n        long long mostViewedViews = 0;\\n    };\\n\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, CreatorInfo> creatorStats;\\n        long long maxPop = -1;\\n\\n        for (int i = 0; i < creators.size(); i++) {\\n            auto &currentCreatorStats = creatorStats[creators[i]];\\n\\n            currentCreatorStats.totalViews += views[i];\\n\\n            if (currentCreatorStats.totalViews > maxPop)\\n                maxPop = currentCreatorStats.totalViews;\\n\\n            if (views[i] > currentCreatorStats.mostViewedViews || \\n                (views[i] == currentCreatorStats.mostViewedViews && \\n                (currentCreatorStats.mostViewedId == \"\" || ids[i] < currentCreatorStats.mostViewedId))) {\\n                currentCreatorStats.mostViewedId = ids[i];\\n                currentCreatorStats.mostViewedViews = views[i];\\n            }\\n        }\\n\\n        vector<vector<string>> final_data;\\n        for (const auto [creator, info] : creatorStats){\\n            if (info.totalViews == maxPop)\\n                final_data.push_back({creator, info.mostViewedId});\\n        }\\n\\n        return final_data;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct CreatorInfo {\\n        long long totalViews = 0;\\n        string mostViewedId = \"\";\\n        long long mostViewedViews = 0;\\n    };\\n\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, CreatorInfo> creatorStats;\\n        long long maxPop = -1;\\n\\n        for (int i = 0; i < creators.size(); i++) {\\n            auto &currentCreatorStats = creatorStats[creators[i]];\\n\\n            currentCreatorStats.totalViews += views[i];\\n\\n            if (currentCreatorStats.totalViews > maxPop)\\n                maxPop = currentCreatorStats.totalViews;\\n\\n            if (views[i] > currentCreatorStats.mostViewedViews || \\n                (views[i] == currentCreatorStats.mostViewedViews && \\n                (currentCreatorStats.mostViewedId == \"\" || ids[i] < currentCreatorStats.mostViewedId))) {\\n                currentCreatorStats.mostViewedId = ids[i];\\n                currentCreatorStats.mostViewedViews = views[i];\\n            }\\n        }\\n\\n        vector<vector<string>> final_data;\\n        for (const auto [creator, info] : creatorStats){\\n            if (info.totalViews == maxPop)\\n                final_data.push_back({creator, info.mostViewedId});\\n        }\\n\\n        return final_data;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079831,
                "title": "beats-100-00-of-users-with-go",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunc mostPopularCreator(creators []string, ids []string, views []int) [][]string {\\n\\t// map creator -> count, min id\\n\\t// max count\\n\\ntype creator string\\ntype id string\\n\\ntype meta struct {\\n\\ttView int\\n\\n\\tmaxView int\\n\\tminId   id\\n}\\n\\n\\tidx := make(map[creator]meta, len(creators))\\n\\n\\tmaxTView := 0\\n\\tfor i := 0; i < len(ids); i++ {\\n\\t\\tm, ok := idx[creator(creators[i])]\\n\\t\\tif !ok {\\n\\t\\t\\tm = meta{\\n\\t\\t\\t\\ttView: views[i],\\n\\n\\t\\t\\t\\tmaxView: views[i],\\n\\t\\t\\t\\tminId:   id(ids[i]),\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tm.tView += views[i]\\n\\t\\t\\tif views[i] == m.maxView {\\n\\t\\t\\t\\tif id(ids[i]) < m.minId {\\n\\t\\t\\t\\t\\tm.minId = id(ids[i])\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if views[i] > m.maxView {\\n\\t\\t\\t\\tm.minId = id(ids[i])\\n\\t\\t\\t\\tm.maxView = views[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tidx[creator(creators[i])] = m\\n\\t\\tif m.tView > maxTView {\\n\\t\\t\\tmaxTView = m.tView\\n\\t\\t}\\n\\t}\\n\\n\\tvar result [][]string\\n\\tfor c, m := range idx {\\n\\t\\tif m.tView == maxTView {\\n\\t\\t\\tresult = append(result, []string{string(c), string(m.minId)})\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```\\nfunc mostPopularCreator(creators []string, ids []string, views []int) [][]string {\\n\\t// map creator -> count, min id\\n\\t// max count\\n\\ntype creator string\\ntype id string\\n\\ntype meta struct {\\n\\ttView int\\n\\n\\tmaxView int\\n\\tminId   id\\n}\\n\\n\\tidx := make(map[creator]meta, len(creators))\\n\\n\\tmaxTView := 0\\n\\tfor i := 0; i < len(ids); i++ {\\n\\t\\tm, ok := idx[creator(creators[i])]\\n\\t\\tif !ok {\\n\\t\\t\\tm = meta{\\n\\t\\t\\t\\ttView: views[i],\\n\\n\\t\\t\\t\\tmaxView: views[i],\\n\\t\\t\\t\\tminId:   id(ids[i]),\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tm.tView += views[i]\\n\\t\\t\\tif views[i] == m.maxView {\\n\\t\\t\\t\\tif id(ids[i]) < m.minId {\\n\\t\\t\\t\\t\\tm.minId = id(ids[i])\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if views[i] > m.maxView {\\n\\t\\t\\t\\tm.minId = id(ids[i])\\n\\t\\t\\t\\tm.maxView = views[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tidx[creator(creators[i])] = m\\n\\t\\tif m.tView > maxTView {\\n\\t\\t\\tmaxTView = m.tView\\n\\t\\t}\\n\\t}\\n\\n\\tvar result [][]string\\n\\tfor c, m := range idx {\\n\\t\\tif m.tView == maxTView {\\n\\t\\t\\tresult = append(result, []string{string(c), string(m.minId)})\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047434,
                "title": "easy-and-self-explanatory-java-solution",
                "content": "\\n# Approach\\nJava Easy and self explanatory solution\\n# Language\\nJava\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n       class IdViews{\\n        String id;\\n        int views;\\n        public IdViews(String id, int views){\\n            this.id = id;\\n            this.views = views;\\n        }\\n    }\\n     class CretorCount{\\n         String creator;\\n         long total;\\n         public CretorCount(String creator, long total){\\n             this.creator = creator;\\n             this.total = total;\\n         }\\n    }\\n    public  List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, List<IdViews>> mp = new HashMap<>();\\n        Map<String, Long> cmap = new HashMap<>();\\n        PriorityQueue<CretorCount> pq = new PriorityQueue<>((o1,o2)->-Long.compare(o1.total,o2.total));\\n        List<List<String>> res = new ArrayList<>();\\n        int n = creators.length;\\n        for(int i=0;i<n;i++){\\n\\n            if(mp.containsKey(creators[i])){\\n                List<IdViews> idViewsList = mp.get(creators[i]);\\n                long total = cmap.get(creators[i]);\\n                cmap.put(creators[i],total+views[i]);\\n                idViewsList.add(new IdViews(ids[i],views[i]));\\n                mp.put(creators[i],idViewsList);\\n                pq.add(new CretorCount(creators[i],cmap.get(creators[i])));\\n\\n            }else{\\n                List<IdViews> lt = new ArrayList<>();\\n                lt.add(new IdViews(ids[i],views[i]));\\n                mp.put(creators[i],lt);\\n                cmap.put(creators[i],(long)views[i]);\\n                pq.add(new CretorCount(creators[i],cmap.get(creators[i])));\\n            }\\n\\n        }\\n        long previous = -1;\\n        String preCreator = \"\";\\n        while(!pq.isEmpty()){\\n            CretorCount cretorCount = pq.poll();\\n            if(previous ==-1 || (cretorCount.total==previous && !preCreator.equals(cretorCount.creator))){\\n                List<String> lt = new ArrayList<>();\\n                List<IdViews> idViewsList = mp.get(cretorCount.creator);\\n                Collections.sort(idViewsList, new Comparator<IdViews>(){\\n\\n                    @Override\\n                    public int compare(IdViews o1, IdViews o2) {\\n                        if(o1.views==o2.views){\\n                            return -o1.id.compareTo(o2.id);\\n                        }\\n                        return Integer.compare(o1.views,o2.views);\\n                    }\\n                });\\n                String id = idViewsList.get(idViewsList.size()-1).id;\\n                lt.add(cretorCount.creator);\\n                lt.add(id);\\n                res.add(lt);\\n                previous = cretorCount.total;\\n                preCreator = cretorCount.creator;\\n\\n            }else{\\n                break;\\n            }\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       class IdViews{\\n        String id;\\n        int views;\\n        public IdViews(String id, int views){\\n            this.id = id;\\n            this.views = views;\\n        }\\n    }\\n     class CretorCount{\\n         String creator;\\n         long total;\\n         public CretorCount(String creator, long total){\\n             this.creator = creator;\\n             this.total = total;\\n         }\\n    }\\n    public  List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, List<IdViews>> mp = new HashMap<>();\\n        Map<String, Long> cmap = new HashMap<>();\\n        PriorityQueue<CretorCount> pq = new PriorityQueue<>((o1,o2)->-Long.compare(o1.total,o2.total));\\n        List<List<String>> res = new ArrayList<>();\\n        int n = creators.length;\\n        for(int i=0;i<n;i++){\\n\\n            if(mp.containsKey(creators[i])){\\n                List<IdViews> idViewsList = mp.get(creators[i]);\\n                long total = cmap.get(creators[i]);\\n                cmap.put(creators[i],total+views[i]);\\n                idViewsList.add(new IdViews(ids[i],views[i]));\\n                mp.put(creators[i],idViewsList);\\n                pq.add(new CretorCount(creators[i],cmap.get(creators[i])));\\n\\n            }else{\\n                List<IdViews> lt = new ArrayList<>();\\n                lt.add(new IdViews(ids[i],views[i]));\\n                mp.put(creators[i],lt);\\n                cmap.put(creators[i],(long)views[i]);\\n                pq.add(new CretorCount(creators[i],cmap.get(creators[i])));\\n            }\\n\\n        }\\n        long previous = -1;\\n        String preCreator = \"\";\\n        while(!pq.isEmpty()){\\n            CretorCount cretorCount = pq.poll();\\n            if(previous ==-1 || (cretorCount.total==previous && !preCreator.equals(cretorCount.creator))){\\n                List<String> lt = new ArrayList<>();\\n                List<IdViews> idViewsList = mp.get(cretorCount.creator);\\n                Collections.sort(idViewsList, new Comparator<IdViews>(){\\n\\n                    @Override\\n                    public int compare(IdViews o1, IdViews o2) {\\n                        if(o1.views==o2.views){\\n                            return -o1.id.compareTo(o2.id);\\n                        }\\n                        return Integer.compare(o1.views,o2.views);\\n                    }\\n                });\\n                String id = idViewsList.get(idViewsList.size()-1).id;\\n                lt.add(cretorCount.creator);\\n                lt.add(id);\\n                res.add(lt);\\n                previous = cretorCount.total;\\n                preCreator = cretorCount.creator;\\n\\n            }else{\\n                break;\\n            }\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037783,
                "title": "java-0-n-solution-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, Creator> map = new HashMap<>();\\n        for (int i = 0; i < creators.length; i++) {\\n            if (!map.containsKey(creators[i])) {\\n                Creator creator = new Creator(ids[i], creators[i]);\\n                creator.increasePopularity(views[i]);\\n                creator.changeId(views[i], ids[i]);\\n                map.put(creators[i], creator);\\n            } else {\\n                Creator creator = map.get(creators[i]);\\n                creator.changeId(views[i], ids[i]);\\n                creator.increasePopularity(views[i]);\\n            }\\n        }\\n\\n        PriorityQueue<Creator> queue = new PriorityQueue();\\n        for (String name: map.keySet()) queue.add(map.get(name));\\n\\n        Creator mostPopular = queue.poll();\\n        List<String> inner = new ArrayList<>();\\n        inner.add(mostPopular.name);\\n        inner.add(mostPopular.id);\\n        List<List<String>> result = new ArrayList<>();\\n        result.add(inner);\\n        while (!queue.isEmpty()) {\\n            Creator current = queue.poll();\\n            if (mostPopular.popularity > current.popularity) break;\\n            mostPopular = current;\\n            inner = new ArrayList<>();\\n            inner.add(mostPopular.name);\\n            inner.add(mostPopular.id);\\n            result.add(inner);\\n        }\\n\\n        return result;\\n    }\\n\\n    private class Creator implements Comparable<Creator> {\\n        public String id;\\n        public String name;\\n        public long popularity;\\n        public int mostViewedVideo;\\n\\n        public Creator(String id, String name) {\\n            this.id = id;\\n            this.name = name;\\n            this.popularity = 0;\\n            this.mostViewedVideo = Integer.MIN_VALUE;\\n        }\\n\\n        public void increasePopularity(int views) {\\n            this.popularity += views;\\n        }\\n\\n        public void changeId(int views, String id) {\\n            if (views > this.mostViewedVideo) {\\n                this.id = id;\\n                this.mostViewedVideo = views;\\n            } else if (views == this.mostViewedVideo && this.id.compareTo(id) > 0) {\\n                this.id = id;\\n            }\\n        }\\n        \\n\\n        @Override\\n        public int compareTo(Creator other) {\\n            return (int)(other.popularity - this.popularity);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"{id: \" + this.id + \", name: \" + this.name + \", popularity: \" + this.popularity +  \"}\";\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, Creator> map = new HashMap<>();\\n        for (int i = 0; i < creators.length; i++) {\\n            if (!map.containsKey(creators[i])) {\\n                Creator creator = new Creator(ids[i], creators[i]);\\n                creator.increasePopularity(views[i]);\\n                creator.changeId(views[i], ids[i]);\\n                map.put(creators[i], creator);\\n            } else {\\n                Creator creator = map.get(creators[i]);\\n                creator.changeId(views[i], ids[i]);\\n                creator.increasePopularity(views[i]);\\n            }\\n        }\\n\\n        PriorityQueue<Creator> queue = new PriorityQueue();\\n        for (String name: map.keySet()) queue.add(map.get(name));\\n\\n        Creator mostPopular = queue.poll();\\n        List<String> inner = new ArrayList<>();\\n        inner.add(mostPopular.name);\\n        inner.add(mostPopular.id);\\n        List<List<String>> result = new ArrayList<>();\\n        result.add(inner);\\n        while (!queue.isEmpty()) {\\n            Creator current = queue.poll();\\n            if (mostPopular.popularity > current.popularity) break;\\n            mostPopular = current;\\n            inner = new ArrayList<>();\\n            inner.add(mostPopular.name);\\n            inner.add(mostPopular.id);\\n            result.add(inner);\\n        }\\n\\n        return result;\\n    }\\n\\n    private class Creator implements Comparable<Creator> {\\n        public String id;\\n        public String name;\\n        public long popularity;\\n        public int mostViewedVideo;\\n\\n        public Creator(String id, String name) {\\n            this.id = id;\\n            this.name = name;\\n            this.popularity = 0;\\n            this.mostViewedVideo = Integer.MIN_VALUE;\\n        }\\n\\n        public void increasePopularity(int views) {\\n            this.popularity += views;\\n        }\\n\\n        public void changeId(int views, String id) {\\n            if (views > this.mostViewedVideo) {\\n                this.id = id;\\n                this.mostViewedVideo = views;\\n            } else if (views == this.mostViewedVideo && this.id.compareTo(id) > 0) {\\n                this.id = id;\\n            }\\n        }\\n        \\n\\n        @Override\\n        public int compareTo(Creator other) {\\n            return (int)(other.popularity - this.popularity);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"{id: \" + this.id + \", name: \" + this.name + \", popularity: \" + this.popularity +  \"}\";\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991052,
                "title": "unodered-map-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& id, vector<int>& views) {\\n        unordered_map<string,pair<string,pair<long long,int>>>m;\\n        for(int i=0;i<c.size();i++){\\n            if(!m.count(c[i])){\\n                m[c[i]]={id[i],{views[i],views[i]}};\\n            }\\n            else{\\n                auto t=m[c[i]];\\n                auto d=t.first;\\n                long long sum=t.second.first;\\n                int h=t.second.second;\\n                if(views[i]>h){\\n                    // cout<<d<<\" \"<<c[i]<<\" \"<<h<<\" \"<<views[i]<<endl;\\n                    d=id[i];\\n                    h=views[i];\\n                }\\n                else if(views[i]==h){\\n                    d=min(d,id[i]);\\n                }\\n                sum+=views[i];\\n                m[c[i]]={d,{sum,h}};\\n            }\\n        }\\n        vector<vector<string>>v;\\n        long long t=0;\\n        for(auto &i:m){\\n            if(i.second.second.first>t){\\n                v.clear();\\n                v.push_back({i.first,i.second.first});\\n                t=i.second.second.first;\\n            }\\n            else if(i.second.second.first==t){\\n                v.push_back({i.first,i.second.first});\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& id, vector<int>& views) {\\n        unordered_map<string,pair<string,pair<long long,int>>>m;\\n        for(int i=0;i<c.size();i++){\\n            if(!m.count(c[i])){\\n                m[c[i]]={id[i],{views[i],views[i]}};\\n            }\\n            else{\\n                auto t=m[c[i]];\\n                auto d=t.first;\\n                long long sum=t.second.first;\\n                int h=t.second.second;\\n                if(views[i]>h){\\n                    // cout<<d<<\" \"<<c[i]<<\" \"<<h<<\" \"<<views[i]<<endl;\\n                    d=id[i];\\n                    h=views[i];\\n                }\\n                else if(views[i]==h){\\n                    d=min(d,id[i]);\\n                }\\n                sum+=views[i];\\n                m[c[i]]={d,{sum,h}};\\n            }\\n        }\\n        vector<vector<string>>v;\\n        long long t=0;\\n        for(auto &i:m){\\n            if(i.second.second.first>t){\\n                v.clear();\\n                v.push_back({i.first,i.second.first});\\n                t=i.second.second.first;\\n            }\\n            else if(i.second.second.first==t){\\n                v.push_back({i.first,i.second.first});\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3980736,
                "title": "java-o-n-using-3-hashmaps",
                "content": "# Intuition\\nI used 3 maps for:\\n- map - for storing max views of a video of each creator\\n- mapSum - for storing sum of views for each creator\\n- mapIds - to store name of a video with max views of each creator\\n\\nIn the end, I just create a result list.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, Long> map = new HashMap<>();\\n        Map<String, String> mapIds = new HashMap<>();\\n        Map<String, Long> mapSum = new HashMap<>();\\n        for (int i = 0; i < views.length; i++) {\\n            long v = map.getOrDefault(creators[i], -1L);\\n            if (views[i] > v) {\\n                mapIds.put(creators[i], ids[i]);\\n            } else if (views[i] == v) {\\n                String s = mapIds.get(creators[i]);\\n                if (s != null && ids[i].compareTo(s) < 0) mapIds.put(creators[i], ids[i]);\\n            }\\n            map.put(creators[i], Math.max(v, views[i]));\\n            mapSum.put(creators[i], mapSum.getOrDefault(creators[i], 0L) + views[i]);\\n        }\\n        long max = 0;\\n        for (String key : mapSum.keySet()) max = Math.max(max, mapSum.get(key));\\n        List<List<String>> list = new ArrayList<>();\\n        for (String key : mapSum.keySet()) if (mapSum.get(key) == max) list.add(Arrays.asList(key, mapIds.get(key)));\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, Long> map = new HashMap<>();\\n        Map<String, String> mapIds = new HashMap<>();\\n        Map<String, Long> mapSum = new HashMap<>();\\n        for (int i = 0; i < views.length; i++) {\\n            long v = map.getOrDefault(creators[i], -1L);\\n            if (views[i] > v) {\\n                mapIds.put(creators[i], ids[i]);\\n            } else if (views[i] == v) {\\n                String s = mapIds.get(creators[i]);\\n                if (s != null && ids[i].compareTo(s) < 0) mapIds.put(creators[i], ids[i]);\\n            }\\n            map.put(creators[i], Math.max(v, views[i]));\\n            mapSum.put(creators[i], mapSum.getOrDefault(creators[i], 0L) + views[i]);\\n        }\\n        long max = 0;\\n        for (String key : mapSum.keySet()) max = Math.max(max, mapSum.get(key));\\n        List<List<String>> list = new ArrayList<>();\\n        for (String key : mapSum.keySet()) if (mapSum.get(key) == max) list.add(Arrays.asList(key, mapIds.get(key)));\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961865,
                "title": "easy-c-soln",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& cr, vector<string>& id, vector<int>& vw) {\\n        vector<vector<string>>ans;\\n        unordered_map<string,ll>score;\\n        unordered_map<string,pair<int,string>>mp;\\n        ll maxi = 0;\\n        for(int i=0;i<cr.size();i++){\\n            score[cr[i]]+=vw[i];\\n            maxi = max(maxi , score[cr[i]]);\\n            if(mp.find(cr[i]) == mp.end()){\\n                mp[cr[i]] = {vw[i],id[i]};\\n            }else if(mp[cr[i]].first < vw[i]){\\n                mp[cr[i]] = {vw[i],id[i]};\\n            }else if(mp[cr[i]].first == vw[i] and id[i] < mp[cr[i]].second){\\n                mp[cr[i]] = {vw[i],id[i]};\\n            }\\n        }\\n        for(auto it:mp){\\n            if(score[it.first] == maxi){\\n                ans.push_back({it.first,mp[it.first].second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& cr, vector<string>& id, vector<int>& vw) {\\n        vector<vector<string>>ans;\\n        unordered_map<string,ll>score;\\n        unordered_map<string,pair<int,string>>mp;\\n        ll maxi = 0;\\n        for(int i=0;i<cr.size();i++){\\n            score[cr[i]]+=vw[i];\\n            maxi = max(maxi , score[cr[i]]);\\n            if(mp.find(cr[i]) == mp.end()){\\n                mp[cr[i]] = {vw[i],id[i]};\\n            }else if(mp[cr[i]].first < vw[i]){\\n                mp[cr[i]] = {vw[i],id[i]};\\n            }else if(mp[cr[i]].first == vw[i] and id[i] < mp[cr[i]].second){\\n                mp[cr[i]] = {vw[i],id[i]};\\n            }\\n        }\\n        for(auto it:mp){\\n            if(score[it.first] == maxi){\\n                ans.push_back({it.first,mp[it.first].second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951095,
                "title": "hashmap-fast-solution-beats-100",
                "content": "# Intuition\\n`\\u26A1\\uFE0F Don\\'t forget to UpVote \\u26A1\\uFE0F`\\n\\n# Approach\\n1. Initialize an empty vector `ans` to store the final result.\\n2. Initialize an unordered map mp where the keys are the creators\\' names, and the values are pairs containing the index of the most viewed video and the total views of the creator.\\n3. Iterate through the input vectors `creators`, `ids`, and `views`.\\n    1. For each video, if the creator\\'s name is already in the `mp`:\\n        -> Check if the current video has more views than the previously recorded most viewed video of the same creator.\\n        -> If views are the same, compare the IDs of the videos to determine the lexicographically smaller one.\\n        -> Update the creator\\'s most viewed video index and add the current video\\'s views to their total.\\n    2. If the creator\\'s name is not in the `mp`, add their information to the map.\\n4. Find the maximum total views (mx) among all creators in the `mp`.\\n5. Iterate through the `mp` to identify creators with the maximum total views.\\n6. If a creator\\'s total views match `mx`, add their name and the ID of their most viewed video to the result `ans`.\\n7. Return the final `ans`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        int n = creators.size();\\n        vector<vector<string>> ans;\\n        unordered_map<string, pair<int, long long>> mp;\\n        for(int i=0; i<n; i++) {\\n            if(mp.find(creators[i]) != mp.end()) {\\n                if(views[mp[creators[i]].first]<views[i] || (views[mp[creators[i]].first] == views[i] && ids[mp[creators[i]].first]>ids[i])) mp[creators[i]].first = i;\\n                mp[creators[i]].second += views[i];\\n            } else {\\n                mp[creators[i]] = {i, views[i]};\\n            }\\n        }\\n        long long mx = -1;\\n        for(auto const& el : mp) {\\n            if(el.second.second > mx) mx = el.second.second;\\n        }\\n        vector<string> vec(2);\\n        for(auto const& el : mp) {\\n            pair<int, long long> x = el.second;\\n            if(x.second == mx) {\\n                vec[0] = el.first;\\n                vec[1] = ids[x.first];\\n                ans.push_back(vec);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        int n = creators.size();\\n        vector<vector<string>> ans;\\n        unordered_map<string, pair<int, long long>> mp;\\n        for(int i=0; i<n; i++) {\\n            if(mp.find(creators[i]) != mp.end()) {\\n                if(views[mp[creators[i]].first]<views[i] || (views[mp[creators[i]].first] == views[i] && ids[mp[creators[i]].first]>ids[i])) mp[creators[i]].first = i;\\n                mp[creators[i]].second += views[i];\\n            } else {\\n                mp[creators[i]] = {i, views[i]};\\n            }\\n        }\\n        long long mx = -1;\\n        for(auto const& el : mp) {\\n            if(el.second.second > mx) mx = el.second.second;\\n        }\\n        vector<string> vec(2);\\n        for(auto const& el : mp) {\\n            pair<int, long long> x = el.second;\\n            if(x.second == mx) {\\n                vec[0] = el.first;\\n                vec[1] = ids[x.first];\\n                ans.push_back(vec);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919805,
                "title": "c-simulated-easy-understanding",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        // Intution\\n        // The idea in here is really very simple. We will maintain the id of the creater along with the total number of views and also the creator and then id of the creator along with the name of the creator.\\n\\n        unordered_map<string, long long> mp1;\\n        unordered_map<string, pair<string, long long>> mp2;\\n\\n        int n = creators.size();\\n\\n        for(int i = 0 ; i < n ; i++){\\n            string creator = creators[i];\\n            string id = ids[i];\\n            int view = views[i];\\n\\n            if(mp1.find(creator) == mp1.end()){\\n                mp1[creator] = view;\\n                mp2[creator] = {id, view};\\n            }\\n\\n            else{\\n                if(view > mp2[creator].second){\\n                    mp2[creator] = {id, view};\\n                }\\n                else if(view == mp2[creator].second){\\n                    string currentId = mp2[creator].first >= id ? id : mp2[creator].first;\\n                    mp2[creator] = {currentId, view};\\n                }\\n                mp1[creator] += view;\\n            }\\n        }\\n\\n        long long maxViews = INT_MIN;\\n        for(auto itr = mp1.begin() ; itr != mp1.end() ; itr++)\\n            maxViews = max(maxViews, itr->second);\\n\\n        vector<vector<string>> answer;\\n\\n        for(auto itr = mp1.begin() ; itr != mp1.end() ; itr++){\\n            if(itr->second == maxViews){\\n                answer.push_back({itr->first, mp2[itr->first].first});\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        // Intution\\n        // The idea in here is really very simple. We will maintain the id of the creater along with the total number of views and also the creator and then id of the creator along with the name of the creator.\\n\\n        unordered_map<string, long long> mp1;\\n        unordered_map<string, pair<string, long long>> mp2;\\n\\n        int n = creators.size();\\n\\n        for(int i = 0 ; i < n ; i++){\\n            string creator = creators[i];\\n            string id = ids[i];\\n            int view = views[i];\\n\\n            if(mp1.find(creator) == mp1.end()){\\n                mp1[creator] = view;\\n                mp2[creator] = {id, view};\\n            }\\n\\n            else{\\n                if(view > mp2[creator].second){\\n                    mp2[creator] = {id, view};\\n                }\\n                else if(view == mp2[creator].second){\\n                    string currentId = mp2[creator].first >= id ? id : mp2[creator].first;\\n                    mp2[creator] = {currentId, view};\\n                }\\n                mp1[creator] += view;\\n            }\\n        }\\n\\n        long long maxViews = INT_MIN;\\n        for(auto itr = mp1.begin() ; itr != mp1.end() ; itr++)\\n            maxViews = max(maxViews, itr->second);\\n\\n        vector<vector<string>> answer;\\n\\n        for(auto itr = mp1.begin() ; itr != mp1.end() ; itr++){\\n            if(itr->second == maxViews){\\n                answer.push_back({itr->first, mp2[itr->first].first});\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904961,
                "title": "beats-99-1-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Using one unordered_map where key is the creator name and value is pair : int, another pair.\\n2. This inner pair will have first value as int and second as string.\\n3. The int in inner pair is max view for the creator for which map is created and the corresponding id for it.\\n4. The in for outer pair is the total views.\\n5. Now,each time we update the total views and check lexographical order using compare function which updates id if new id is smaller than current.\\n6. finally we just store it in vector.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,pair<long long,pair<long long,string>>>m;\\n        for(int i=0;i<ids.size();i++){\\n            if(m.find(creators[i])==m.end()){\\n                m[creators[i]]={views[i],{views[i],ids[i]}};\\n            }\\n            else{\\n                if(m[creators[i]].second.first<views[i]){\\n                    m[creators[i]]={m[creators[i]].first+views[i],{views[i],ids[i]}};\\n                }\\n                else if(m[creators[i]].second.first==views[i]&&(m[creators[i]].second.second.compare(ids[i])>0)){\\n                    m[creators[i]]={m[creators[i]].first+views[i],{views[i],ids[i]}};\\n                }\\n                else{\\n                    m[creators[i]].first=m[creators[i]].first+views[i];\\n                }\\n            }\\n        }\\n        long long mn=INT_MIN;\\n        for(auto x:m){\\n            if(x.second.first>mn){\\n                mn=x.second.first;\\n            }\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x:m){\\n            if(x.second.first==mn){\\n                ans.push_back({x.first,x.second.second.second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,pair<long long,pair<long long,string>>>m;\\n        for(int i=0;i<ids.size();i++){\\n            if(m.find(creators[i])==m.end()){\\n                m[creators[i]]={views[i],{views[i],ids[i]}};\\n            }\\n            else{\\n                if(m[creators[i]].second.first<views[i]){\\n                    m[creators[i]]={m[creators[i]].first+views[i],{views[i],ids[i]}};\\n                }\\n                else if(m[creators[i]].second.first==views[i]&&(m[creators[i]].second.second.compare(ids[i])>0)){\\n                    m[creators[i]]={m[creators[i]].first+views[i],{views[i],ids[i]}};\\n                }\\n                else{\\n                    m[creators[i]].first=m[creators[i]].first+views[i];\\n                }\\n            }\\n        }\\n        long long mn=INT_MIN;\\n        for(auto x:m){\\n            if(x.second.first>mn){\\n                mn=x.second.first;\\n            }\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x:m){\\n            if(x.second.first==mn){\\n                ans.push_back({x.first,x.second.second.second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896745,
                "title": "c-complex-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& id, vector<int>& v) {\\n        map<string,long long int> p;\\n        map<string,vector<pair<int,string>>> q;\\n        long long int m=0;\\n         vector<vector<string>> b;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            p[c[i]]+=v[i];\\n            m=max(m,p[c[i]]);\\n            q[c[i]].push_back({v[i],id[i]});\\n        }\\n        for(auto i : p)\\n        if(i.second==m)\\n        {\\n            vector<pair<int,string>> g=q[i.first];\\n             vector<pair<string,int>> f;\\n             int n=0;\\n             for(auto k : g)\\n              n=max(n,k.first);\\n\\n             for(auto k : g)\\n             if(k.first==n)\\n             f.push_back({k.second,k.first}); \\n\\n             sort(f.begin(),f.end());\\n             b.push_back({i.first,f[0].first});\\n        } \\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& id, vector<int>& v) {\\n        map<string,long long int> p;\\n        map<string,vector<pair<int,string>>> q;\\n        long long int m=0;\\n         vector<vector<string>> b;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            p[c[i]]+=v[i];\\n            m=max(m,p[c[i]]);\\n            q[c[i]].push_back({v[i],id[i]});\\n        }\\n        for(auto i : p)\\n        if(i.second==m)\\n        {\\n            vector<pair<int,string>> g=q[i.first];\\n             vector<pair<string,int>> f;\\n             int n=0;\\n             for(auto k : g)\\n              n=max(n,k.first);\\n\\n             for(auto k : g)\\n             if(k.first==n)\\n             f.push_back({k.second,k.first}); \\n\\n             sort(f.begin(),f.end());\\n             b.push_back({i.first,f[0].first});\\n        } \\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851988,
                "title": "two-maps-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,long long> mpp;\\n        unordered_map<string,pair<string,int>> maxView;\\n        vector<string> check; long long maxi = 0;\\n        for(int i=0;i<views.size();i++){\\n            mpp[creators[i]] += views[i];\\n            maxi = max(maxi,mpp[creators[i]]);\\n        } \\n        for(int i=0;i<views.size();i++){\\n            if(!maxView.count(creators[i])){\\n                maxView[creators[i]] = {ids[i],views[i]};\\n            }else if(maxView[creators[i]].second <= views[i]){\\n                if(maxView[creators[i]].second < views[i]) maxView[creators[i]] = {ids[i],views[i]};\\n                else if(maxView[creators[i]].second == views[i] && maxView[creators[i]].first > ids[i]){\\n                    maxView[creators[i]] = {ids[i],views[i]};\\n                }\\n            }\\n        }\\n        for(auto it: mpp) if(it.second == maxi) check.push_back(it.first);\\n        vector<vector<string>> ans(check.size());\\n        for(int i=0;i<check.size();i++){\\n            ans[i].push_back(check[i]);\\n            ans[i].push_back(maxView[check[i]].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,long long> mpp;\\n        unordered_map<string,pair<string,int>> maxView;\\n        vector<string> check; long long maxi = 0;\\n        for(int i=0;i<views.size();i++){\\n            mpp[creators[i]] += views[i];\\n            maxi = max(maxi,mpp[creators[i]]);\\n        } \\n        for(int i=0;i<views.size();i++){\\n            if(!maxView.count(creators[i])){\\n                maxView[creators[i]] = {ids[i],views[i]};\\n            }else if(maxView[creators[i]].second <= views[i]){\\n                if(maxView[creators[i]].second < views[i]) maxView[creators[i]] = {ids[i],views[i]};\\n                else if(maxView[creators[i]].second == views[i] && maxView[creators[i]].first > ids[i]){\\n                    maxView[creators[i]] = {ids[i],views[i]};\\n                }\\n            }\\n        }\\n        for(auto it: mpp) if(it.second == maxi) check.push_back(it.first);\\n        vector<vector<string>> ans(check.size());\\n        for(int i=0;i<check.size();i++){\\n            ans[i].push_back(check[i]);\\n            ans[i].push_back(maxView[check[i]].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851006,
                "title": "c-short-and-easy-map-implementation-beats-99",
                "content": "\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        \\n        unordered_map<string,long long>mp;\\n        long long maxi=0;\\n        for(int i=0;i<ids.size();i++){\\n            mp[creators[i]]+=views[i];\\n            maxi=max(maxi,mp[creators[i]]);\\n        }\\n        \\n        unordered_map<string,pair<int,string>>ans;\\n        for(int i=0;i<ids.size();i++){\\n            if(mp[creators[i]]==maxi){\\n                if(ans.find(creators[i])==ans.end()){\\n                    ans[creators[i]]={views[i],ids[i]};\\n                }else{\\n                    if(views[i]>=ans[creators[i]].first){\\n                        if(views[i]>ans[creators[i]].first){\\n                            ans[creators[i]].first=views[i];\\n                            ans[creators[i]].second=ids[i];\\n                        }\\n                        else{\\n                            ans[creators[i]].second=min(ids[i],ans[creators[i]].second);\\n                        }\\n                        }\\n                    }\\n                }\\n            }\\n\\n    vector<vector<string>>final;\\n    for(auto val:ans){\\n        final.push_back({val.first,val.second.second});\\n    }\\n\\n    return final;\\n\\n        }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        \\n        unordered_map<string,long long>mp;\\n        long long maxi=0;\\n        for(int i=0;i<ids.size();i++){\\n            mp[creators[i]]+=views[i];\\n            maxi=max(maxi,mp[creators[i]]);\\n        }\\n        \\n        unordered_map<string,pair<int,string>>ans;\\n        for(int i=0;i<ids.size();i++){\\n            if(mp[creators[i]]==maxi){\\n                if(ans.find(creators[i])==ans.end()){\\n                    ans[creators[i]]={views[i],ids[i]};\\n                }else{\\n                    if(views[i]>=ans[creators[i]].first){\\n                        if(views[i]>ans[creators[i]].first){\\n                            ans[creators[i]].first=views[i];\\n                            ans[creators[i]].second=ids[i];\\n                        }\\n                        else{\\n                            ans[creators[i]].second=min(ids[i],ans[creators[i]].second);\\n                        }\\n                        }\\n                    }\\n                }\\n            }\\n\\n    vector<vector<string>>final;\\n    for(auto val:ans){\\n        final.push_back({val.first,val.second.second});\\n    }\\n\\n    return final;\\n\\n        }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845739,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        map<string,long long>mp;\\n        vector<vector<string>>ans;\\n        long long maxi=0;\\n        map<string,vector<int>>ind;\\n       for (int i=0;i<creators.size();i++)\\n       {\\n           mp[creators[i]]+=views[i];\\n           if (mp[creators[i]]>maxi) maxi=mp[creators[i]];\\n           ind[creators[i]].push_back(i);\\n       }\\n       for (auto it: mp)\\n       {\\n          if (it.second==maxi) \\n          {\\n              ans.push_back({it.first});\\n          }\\n       }\\n       for (int i=0;i<ans.size();i++)\\n       {\\n           int temp=0;\\n           for (auto it2:ind[ans[i][0]])\\n           {\\n              if (views[it2]>temp)\\n              {\\n                  temp=views[it2];\\n                  if (ans[i].size()==1)\\n                  {\\n                      ans[i].push_back(ids[it2]);\\n                  }\\n                  else{\\n                      ans[i][1]=ids[it2];\\n                  }\\n                  \\n              }\\n              else if (views[it2]==temp)\\n              {\\n                  if (ans[i].size()==1)\\n                  {\\n                      ans[i].push_back(ids[it2]);\\n                  }\\n                  else if (ans[i][1]>ids[it2]){\\n                      ans[i][1]=ids[it2];\\n                  }\\n              }\\n           }\\n       }\\n       return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        map<string,long long>mp;\\n        vector<vector<string>>ans;\\n        long long maxi=0;\\n        map<string,vector<int>>ind;\\n       for (int i=0;i<creators.size();i++)\\n       {\\n           mp[creators[i]]+=views[i];\\n           if (mp[creators[i]]>maxi) maxi=mp[creators[i]];\\n           ind[creators[i]].push_back(i);\\n       }\\n       for (auto it: mp)\\n       {\\n          if (it.second==maxi) \\n          {\\n              ans.push_back({it.first});\\n          }\\n       }\\n       for (int i=0;i<ans.size();i++)\\n       {\\n           int temp=0;\\n           for (auto it2:ind[ans[i][0]])\\n           {\\n              if (views[it2]>temp)\\n              {\\n                  temp=views[it2];\\n                  if (ans[i].size()==1)\\n                  {\\n                      ans[i].push_back(ids[it2]);\\n                  }\\n                  else{\\n                      ans[i][1]=ids[it2];\\n                  }\\n                  \\n              }\\n              else if (views[it2]==temp)\\n              {\\n                  if (ans[i].size()==1)\\n                  {\\n                      ans[i].push_back(ids[it2]);\\n                  }\\n                  else if (ans[i][1]>ids[it2]){\\n                      ans[i][1]=ids[it2];\\n                  }\\n              }\\n           }\\n       }\\n       return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839155,
                "title": "two-hash-table-solution",
                "content": "# Intuition\\nUse two hash table to store:\\n1. To track creator->sum of total views\\n2. To track creator-->ids of videos\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        hash1,hash2 = collections.defaultdict(int),collections.defaultdict(list)\\n        n,highest,ans = len(creators),0,[]\\n        for i in range(n):\\n            creator,id_,view=creators[i],ids[i],views[i]\\n            hash1[creator]+=view\\n            hash2[creator].append([view,id_])\\n            highest=max(highest,hash1[creator])\\n        #sort the 2nd directory using a lambda\\n        for key,values in hash2.items():\\n            hash2[key]=sorted(values,key=lambda x:(-x[0],x[1]))\\n        for key,val in hash1.items():\\n            if val==highest:\\n                id_=hash2[key][0][1]\\n                ans.append([key,id_])\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        hash1,hash2 = collections.defaultdict(int),collections.defaultdict(list)\\n        n,highest,ans = len(creators),0,[]\\n        for i in range(n):\\n            creator,id_,view=creators[i],ids[i],views[i]\\n            hash1[creator]+=view\\n            hash2[creator].append([view,id_])\\n            highest=max(highest,hash1[creator])\\n        #sort the 2nd directory using a lambda\\n        for key,values in hash2.items():\\n            hash2[key]=sorted(values,key=lambda x:(-x[0],x[1]))\\n        for key,val in hash1.items():\\n            if val==highest:\\n                id_=hash2[key][0][1]\\n                ans.append([key,id_])\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785899,
                "title": "most-popular-video-creator-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        vector<vector < string>> mostPopularCreator(vector<string> &creators, vector<string> &ids, vector< int > &views)\\n        {\\n            int n = creators.size();\\n            unordered_map<string, long long > creatorViews;\\n            unordered_map<string, pair<int, string>> creatorMinID;\\n            long long mxViews = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                creatorViews[creators[i]] += views[i];\\n                if (creatorMinID.count(creators[i]))\\n                {\\n                    if (creatorMinID[creators[i]].first == views[i])\\n                    {\\n                        creatorMinID[creators[i]].second = min(creatorMinID[creators[i]].second, ids[i]);\\n                    }\\n                    else if (creatorMinID[creators[i]].first < views[i])\\n                        creatorMinID[creators[i]] = { views[i],\\n                            ids[i]\\n                        };\\n                }\\n                else\\n                {\\n                    creatorMinID[creators[i]] = { views[i],\\n                        ids[i]\\n                    };\\n                }\\n                mxViews = max(mxViews, creatorViews[creators[i]]);\\n            }\\n            vector<vector < string>> res;\\n            for (auto p: creatorViews)\\n            {\\n                if (p.second == mxViews)\\n                {\\n                    res.push_back({ p.first,\\n                        creatorMinID[p.first].second });\\n                }\\n            }\\n            return res;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<vector < string>> mostPopularCreator(vector<string> &creators, vector<string> &ids, vector< int > &views)\\n        {\\n            int n = creators.size();\\n            unordered_map<string, long long > creatorViews;\\n            unordered_map<string, pair<int, string>> creatorMinID;\\n            long long mxViews = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                creatorViews[creators[i]] += views[i];\\n                if (creatorMinID.count(creators[i]))\\n                {\\n                    if (creatorMinID[creators[i]].first == views[i])\\n                    {\\n                        creatorMinID[creators[i]].second = min(creatorMinID[creators[i]].second, ids[i]);\\n                    }\\n                    else if (creatorMinID[creators[i]].first < views[i])\\n                        creatorMinID[creators[i]] = { views[i],\\n                            ids[i]\\n                        };\\n                }\\n                else\\n                {\\n                    creatorMinID[creators[i]] = { views[i],\\n                        ids[i]\\n                    };\\n                }\\n                mxViews = max(mxViews, creatorViews[creators[i]]);\\n            }\\n            vector<vector < string>> res;\\n            for (auto p: creatorViews)\\n            {\\n                if (p.second == mxViews)\\n                {\\n                    res.push_back({ p.first,\\n                        creatorMinID[p.first].second });\\n                }\\n            }\\n            return res;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759999,
                "title": "most-difficult-question-ever",
                "content": "# Intuition\\n\\nJust simulated what the question asked for.\\n\\n# Approach\\n\\nJust simulate the entire process. But make sure you encapsulate things well. High probability of making a bug. So created a class.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Creator {\\n        String maxId ;\\n        long sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        String name;\\n        \\n        public Creator(String name) {\\n            this.name = name;\\n        }\\n        \\n        public void add(String id, int view) {\\n            sum+=view;\\n            if (max < view) {\\n                max = view;\\n                maxId = id;\\n            } else if (max == view && id.compareTo(maxId) < 0) {\\n                maxId = id;\\n            }\\n        }\\n        \\n        public String toString() {\\n            return \"name: \" + name + \" sum: \" + sum + \" maxId: \" + maxId; \\n        }\\n    }\\n    \\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        \\n        int n = ids.length;\\n        Map<String, Creator> map = new HashMap<>();\\n        \\n        for (int i=0; i<n; i++) {\\n            Creator cr = map.getOrDefault(creators[i], new Creator(creators[i]));\\n            cr.add(ids[i], views[i]);\\n            map.put(creators[i], cr);\\n        }\\n        \\n        long max = Integer.MIN_VALUE;\\n        \\n        for (Map.Entry<String, Creator> e: map.entrySet()) {\\n            max = Math.max(max, e.getValue().sum);    \\n        }\\n        \\n        //System.out.println(map);\\n        \\n        List<List<String>> solution = new ArrayList<>();\\n        for (Map.Entry<String, Creator> e: map.entrySet()) {\\n            if (e.getValue().sum == max) {\\n                List<String> one = new ArrayList<>();\\n                one.add(e.getKey());\\n                one.add(e.getValue().maxId);\\n                \\n                solution.add(one);\\n            }\\n        } \\n        \\n        return solution;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Creator {\\n        String maxId ;\\n        long sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        String name;\\n        \\n        public Creator(String name) {\\n            this.name = name;\\n        }\\n        \\n        public void add(String id, int view) {\\n            sum+=view;\\n            if (max < view) {\\n                max = view;\\n                maxId = id;\\n            } else if (max == view && id.compareTo(maxId) < 0) {\\n                maxId = id;\\n            }\\n        }\\n        \\n        public String toString() {\\n            return \"name: \" + name + \" sum: \" + sum + \" maxId: \" + maxId; \\n        }\\n    }\\n    \\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        \\n        int n = ids.length;\\n        Map<String, Creator> map = new HashMap<>();\\n        \\n        for (int i=0; i<n; i++) {\\n            Creator cr = map.getOrDefault(creators[i], new Creator(creators[i]));\\n            cr.add(ids[i], views[i]);\\n            map.put(creators[i], cr);\\n        }\\n        \\n        long max = Integer.MIN_VALUE;\\n        \\n        for (Map.Entry<String, Creator> e: map.entrySet()) {\\n            max = Math.max(max, e.getValue().sum);    \\n        }\\n        \\n        //System.out.println(map);\\n        \\n        List<List<String>> solution = new ArrayList<>();\\n        for (Map.Entry<String, Creator> e: map.entrySet()) {\\n            if (e.getValue().sum == max) {\\n                List<String> one = new ArrayList<>();\\n                one.add(e.getKey());\\n                one.add(e.getValue().maxId);\\n                \\n                solution.add(one);\\n            }\\n        } \\n        \\n        return solution;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698189,
                "title": "solution-using-dictionary-beat-50-runtime",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: [str], ids: [str], views: [int]) -> [str]:\\n        pop_score = {}\\n        pop_id = {}\\n        max_score = 0\\n        result_list = []\\n\\n        for i in range(len(creators)):\\n            if creators[i] not in pop_id:\\n                pop_id[creators[i]] = {\\n                                        \\'Views\\': views[i],\\n                                        \\'Id\\': ids[i]\\n                                      }\\n            elif pop_id[creators[i]][\\'Views\\'] < views[i]:\\n                pop_id[creators[i]][\\'Views\\'] = views[i]\\n                pop_id[creators[i]][\\'Id\\'] = ids[i]\\n\\n            elif pop_id[creators[i]][\\'Views\\'] == views[i] and pop_id[creators[i]][\\'Id\\'] > ids[i]:\\n                pop_id[creators[i]][\\'Id\\'] = ids[i]\\n\\n        for i in range(len(creators)):\\n            if creators[i] not in pop_score:\\n                pop_score[creators[i]] = {\\n                                            \\'Views\\': views[i],\\n                                            \\'Id\\': ids[i]\\n                                         }\\n            else:\\n                pop_score[creators[i]][\\'Views\\'] += views[i]\\n\\n            if pop_score[creators[i]][\\'Views\\'] > max_score:\\n                max_score = pop_score[creators[i]][\\'Views\\']\\n\\n        for creator in pop_score:\\n            if pop_score[creator][\\'Views\\'] == max_score:\\n                result_list.append([creator, pop_id[creator][\\'Id\\']])\\n\\n        return result_list\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: [str], ids: [str], views: [int]) -> [str]:\\n        pop_score = {}\\n        pop_id = {}\\n        max_score = 0\\n        result_list = []\\n\\n        for i in range(len(creators)):\\n            if creators[i] not in pop_id:\\n                pop_id[creators[i]] = {\\n                                        \\'Views\\': views[i],\\n                                        \\'Id\\': ids[i]\\n                                      }\\n            elif pop_id[creators[i]][\\'Views\\'] < views[i]:\\n                pop_id[creators[i]][\\'Views\\'] = views[i]\\n                pop_id[creators[i]][\\'Id\\'] = ids[i]\\n\\n            elif pop_id[creators[i]][\\'Views\\'] == views[i] and pop_id[creators[i]][\\'Id\\'] > ids[i]:\\n                pop_id[creators[i]][\\'Id\\'] = ids[i]\\n\\n        for i in range(len(creators)):\\n            if creators[i] not in pop_score:\\n                pop_score[creators[i]] = {\\n                                            \\'Views\\': views[i],\\n                                            \\'Id\\': ids[i]\\n                                         }\\n            else:\\n                pop_score[creators[i]][\\'Views\\'] += views[i]\\n\\n            if pop_score[creators[i]][\\'Views\\'] > max_score:\\n                max_score = pop_score[creators[i]][\\'Views\\']\\n\\n        for creator in pop_score:\\n            if pop_score[creator][\\'Views\\'] == max_score:\\n                result_list.append([creator, pop_id[creator][\\'Id\\']])\\n\\n        return result_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694111,
                "title": "java-easy-hashmap-solution-o-n-time-space",
                "content": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String,UserStat>stat = new HashMap<>();\\n        long max = 0;\\n        for (int i=0;i<creators.length;i++){\\n            stat.putIfAbsent(creators[i],new UserStat());\\n            UserStat us = stat.get(creators[i]);\\n            us.allViews+=views[i];\\n            max = Math.max(max,us.allViews);\\n            if (us.maxViews<views[i] || (us.maxViews==views[i] && us.topVideo.compareTo(ids[i])>0)){\\n                us.maxViews=views[i];\\n                us.topVideo = ids[i];\\n            }\\n        }\\n        List<List<String>>res = new ArrayList<>();\\n        for (String user: stat.keySet()){\\n            if (stat.get(user).allViews==max){\\n                List<String>userRes = new ArrayList<>();\\n                userRes.add(user);\\n                userRes.add(stat.get(user).topVideo);\\n                res.add(userRes);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass UserStat{\\n    long allViews = 0;\\n    long maxViews = -1;\\n    String topVideo = \"\";\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String,UserStat>stat = new HashMap<>();\\n        long max = 0;\\n        for (int i=0;i<creators.length;i++){\\n            stat.putIfAbsent(creators[i],new UserStat());\\n            UserStat us = stat.get(creators[i]);\\n            us.allViews+=views[i];\\n            max = Math.max(max,us.allViews);\\n            if (us.maxViews<views[i] || (us.maxViews==views[i] && us.topVideo.compareTo(ids[i])>0)){\\n                us.maxViews=views[i];\\n                us.topVideo = ids[i];\\n            }\\n        }\\n        List<List<String>>res = new ArrayList<>();\\n        for (String user: stat.keySet()){\\n            if (stat.get(user).allViews==max){\\n                List<String>userRes = new ArrayList<>();\\n                userRes.add(user);\\n                userRes.add(stat.get(user).topVideo);\\n                res.add(userRes);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass UserStat{\\n    long allViews = 0;\\n    long maxViews = -1;\\n    String topVideo = \"\";\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688619,
                "title": "fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,pair<long long,pair<string,int>>>mp;\\n        int n = ids.size();\\n        long long maxx = INT_MIN;\\n        for(int i = 0;i<n;i++){\\n            if(mp.find(creators[i])==mp.end()){\\n                mp[creators[i]] = {views[i],{ids[i],views[i]}};\\n                maxx = max(maxx,1ll*views[i]);\\n            }\\n            else{\\n                mp[creators[i]].first += views[i];\\n                if(mp[creators[i]].second.second<views[i]){\\n                    mp[creators[i]].second.second = views[i];\\n                    mp[creators[i]].second.first = ids[i];\\n                }\\n                else if(mp[creators[i]].second.second==views[i]){\\n                    mp[creators[i]].second.first = min(ids[i],mp[creators[i]].second.first);\\n                }\\n                maxx = max(maxx,mp[creators[i]].first);\\n            }\\n        }\\n        vector<vector<string>>ans;\\n        for(auto it:mp){\\n            if(it.second.first==maxx){\\n                ans.push_back({it.first,it.second.second.first});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,pair<long long,pair<string,int>>>mp;\\n        int n = ids.size();\\n        long long maxx = INT_MIN;\\n        for(int i = 0;i<n;i++){\\n            if(mp.find(creators[i])==mp.end()){\\n                mp[creators[i]] = {views[i],{ids[i],views[i]}};\\n                maxx = max(maxx,1ll*views[i]);\\n            }\\n            else{\\n                mp[creators[i]].first += views[i];\\n                if(mp[creators[i]].second.second<views[i]){\\n                    mp[creators[i]].second.second = views[i];\\n                    mp[creators[i]].second.first = ids[i];\\n                }\\n                else if(mp[creators[i]].second.second==views[i]){\\n                    mp[creators[i]].second.first = min(ids[i],mp[creators[i]].second.first);\\n                }\\n                maxx = max(maxx,mp[creators[i]].first);\\n            }\\n        }\\n        vector<vector<string>>ans;\\n        for(auto it:mp){\\n            if(it.second.first==maxx){\\n                ans.push_back({it.first,it.second.second.first});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668930,
                "title": "easy-c-solution-using-two-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,pair<long long,long long>> mp;\\n        unordered_map<string,string> tt;\\n        long long maxi = -1;\\n        for(int i = 0;i<creators.size();i++){\\n            if(mp.find(creators[i]) != mp.end()){\\n                if(views[i]>mp[creators[i]].first)\\n                    tt[creators[i]] = ids[i];\\n                else if(views[i] == mp[creators[i]].first){\\n                    tt[creators[i]] = min(ids[i],tt[creators[i]]);\\n                }\\n                if(views[i]>mp[creators[i]].first)\\n                    mp[creators[i]].first = views[i];\\n                //mp[creators[i]].first = max(mp[creators[i]].first,views[i]);\\n                mp[creators[i]].second+=views[i];\\n                maxi = max(maxi,mp[creators[i]].second);\\n            }\\n            else{\\n                tt[creators[i]] = ids[i];\\n                mp[creators[i]] = {views[i],views[i]};\\n                 maxi = max(maxi,mp[creators[i]].second);\\n            }\\n        }\\n        //cout<<maxi<<\" \";\\n        vector<string> temp;\\n        for(auto e:mp)\\n            if(e.second.second == maxi)\\n                temp.push_back(e.first);\\n        for(auto e:temp){\\n            ans.push_back({e,tt[e]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,pair<long long,long long>> mp;\\n        unordered_map<string,string> tt;\\n        long long maxi = -1;\\n        for(int i = 0;i<creators.size();i++){\\n            if(mp.find(creators[i]) != mp.end()){\\n                if(views[i]>mp[creators[i]].first)\\n                    tt[creators[i]] = ids[i];\\n                else if(views[i] == mp[creators[i]].first){\\n                    tt[creators[i]] = min(ids[i],tt[creators[i]]);\\n                }\\n                if(views[i]>mp[creators[i]].first)\\n                    mp[creators[i]].first = views[i];\\n                //mp[creators[i]].first = max(mp[creators[i]].first,views[i]);\\n                mp[creators[i]].second+=views[i];\\n                maxi = max(maxi,mp[creators[i]].second);\\n            }\\n            else{\\n                tt[creators[i]] = ids[i];\\n                mp[creators[i]] = {views[i],views[i]};\\n                 maxi = max(maxi,mp[creators[i]].second);\\n            }\\n        }\\n        //cout<<maxi<<\" \";\\n        vector<string> temp;\\n        for(auto e:mp)\\n            if(e.second.second == maxi)\\n                temp.push_back(e.first);\\n        for(auto e:temp){\\n            ans.push_back({e,tt[e]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3664335,
                "title": "easy-solution-with-dictionary-and-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        popularity = dict()\\n        maps = defaultdict(list)\\n        \\n        for c, i, v in zip(creators, ids, views):\\n            maps[c].append((i, v))\\n            if c in popularity:\\n                popularity[c] += v\\n            else:\\n                popularity[c] = v\\n\\n        m = max(popularity.values()) # max views for creator, 10\\n\\n        res = []\\n        for k, v in popularity.items():\\n            if v == m:\\n                videos = sorted(maps[k], key=lambda x: (-x[1], x[0]))\\n                res.append([k, videos[0][0]])\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        popularity = dict()\\n        maps = defaultdict(list)\\n        \\n        for c, i, v in zip(creators, ids, views):\\n            maps[c].append((i, v))\\n            if c in popularity:\\n                popularity[c] += v\\n            else:\\n                popularity[c] = v\\n\\n        m = max(popularity.values()) # max views for creator, 10\\n\\n        res = []\\n        for k, v in popularity.items():\\n            if v == m:\\n                videos = sorted(maps[k], key=lambda x: (-x[1], x[0]))\\n                res.append([k, videos[0][0]])\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634235,
                "title": "swift-python-named-tuple-single-hash-map-concise-solution",
                "content": "# Swift\\n```\\nclass Solution {\\n    func mostPopularCreator(_ creators: [String], _ ids: [String], _ views: [Int]) -> [[String]] {\\n        var creatorStat: [String: (popularity: Int, mostPopular: (Int, String))] = [:]\\n        for (creator, (id, view)) in zip(creators, zip(ids, views)) {\\n            if let stat = creatorStat[creator] {\\n                creatorStat[creator] = (stat.popularity + view, stat.mostPopular < (-view, id) ? stat.mostPopular : (-view, id))\\n            } else {\\n                creatorStat[creator] = (view, (-view, id))\\n            }\\n        }\\n        let highestPopularity = creatorStat.values.map { $0.popularity }.max()!\\n        return creatorStat.filter { $0.1.popularity == highestPopularity }.map { [$0.key, $0.value.mostPopular.1] }\\n    }\\n}\\n```\\n\\n# Python\\n\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators, ids, views):\\n        CreatorStat = namedtuple(\\'CreatorStat\\', [\\'popularity\\', \\'mostPopular\\'])\\n        creatorStat = {}\\n\\n        for creator, id, view in zip(creators, ids, views):\\n            if creator in creatorStat:\\n                stat = creatorStat[creator]\\n                new_popularity = stat.popularity + view\\n                new_most_popular = min(stat.mostPopular, (-view, id))\\n                creatorStat[creator] = CreatorStat(new_popularity, new_most_popular)\\n            else:\\n                creatorStat[creator] = CreatorStat(view, (-view, id))\\n\\n        highestPopularity = max(creatorStat.values(), key=lambda stat: stat.popularity).popularity\\n        return [[key, value.mostPopular[1]] for key, value in creatorStat.items() if value.popularity == highestPopularity]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Swift",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    func mostPopularCreator(_ creators: [String], _ ids: [String], _ views: [Int]) -> [[String]] {\\n        var creatorStat: [String: (popularity: Int, mostPopular: (Int, String))] = [:]\\n        for (creator, (id, view)) in zip(creators, zip(ids, views)) {\\n            if let stat = creatorStat[creator] {\\n                creatorStat[creator] = (stat.popularity + view, stat.mostPopular < (-view, id) ? stat.mostPopular : (-view, id))\\n            } else {\\n                creatorStat[creator] = (view, (-view, id))\\n            }\\n        }\\n        let highestPopularity = creatorStat.values.map { $0.popularity }.max()!\\n        return creatorStat.filter { $0.1.popularity == highestPopularity }.map { [$0.key, $0.value.mostPopular.1] }\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators, ids, views):\\n        CreatorStat = namedtuple(\\'CreatorStat\\', [\\'popularity\\', \\'mostPopular\\'])\\n        creatorStat = {}\\n\\n        for creator, id, view in zip(creators, ids, views):\\n            if creator in creatorStat:\\n                stat = creatorStat[creator]\\n                new_popularity = stat.popularity + view\\n                new_most_popular = min(stat.mostPopular, (-view, id))\\n                creatorStat[creator] = CreatorStat(new_popularity, new_most_popular)\\n            else:\\n                creatorStat[creator] = CreatorStat(view, (-view, id))\\n\\n        highestPopularity = max(creatorStat.values(), key=lambda stat: stat.popularity).popularity\\n        return [[key, value.mostPopular[1]] for key, value in creatorStat.items() if value.popularity == highestPopularity]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632823,
                "title": "java-solution-using-hashmap-arraylist-difficult-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        List<List<String>> al = new ArrayList<>();\\n        HashMap<String, Long> hm = new HashMap<>();\\n        HashMap<String, ArrayList<String>> hm2 = new HashMap<>();\\n        for(int i = 0; i < creators.length; i++){\\n            if(hm.containsKey(creators[i])){\\n                Long temp = hm.get(creators[i]);\\n                temp = temp + views[i];\\n                hm.put(creators[i], temp);\\n                ArrayList<String> v = new ArrayList<>(hm2.get(creators[i]));\\n                if(views[i]> Integer.parseInt(v.get(2))){\\n                    v.set(1, ids[i]);\\n                    v.set(2, Integer.toString(views[i]));\\n                }\\n                if(views[i]==Integer.parseInt(v.get(2))){\\n                    String[] st = new String[]{ids[i], v.get(1)};\\n                    Arrays.sort(st);\\n                    v.set(1, st[0]);\\n                    v.set(2, Integer.toString(views[i]));\\n                }\\n                hm2.put(creators[i], v);\\n            }\\n            else{\\n                hm.put(creators[i], Long.valueOf(views[i]));\\n                ArrayList<String> t= new ArrayList<>();\\n                t.add(creators[i]);\\n                t.add(ids[i]);\\n                t.add(Integer.toString(views[i]));\\n                hm2.put(creators[i], t);\\n            }\\n        }\\n       \\n        List<Map.Entry<String, Long>> mn = new ArrayList<>(hm.entrySet());\\n        Collections.sort(mn, new Comparator<Map.Entry<String, Long>>(){\\n            public int compare(Map.Entry<String, Long> o1, Map.Entry<String, Long> o2){\\n                return o2.getValue().compareTo(o1.getValue());\\n            }\\n        });\\n        String[] creator = new String[hm.size()];\\n        Long[] view = new Long[hm.size()];\\n        int k = 0;\\n        for(Map.Entry<String, Long> entry : mn){\\n            creator[k] = entry.getKey();\\n            view[k] = entry.getValue();\\n    \\n            k++;\\n        }\\n        ArrayList<String> ans = new ArrayList<>();\\n        ArrayList<String> ans2 = new ArrayList<>(hm2.get(creator[0]));\\n        ans.add(creator[0]);\\n        ans.add(ans2.get(1));\\n        al.add(ans);\\n    \\n        for(int i = 1; i < creator.length; i++){\\n\\n            if(view[i].equals(view[i-1])){\\n                ArrayList<String> finalans2 = new ArrayList<>();\\n                ArrayList<String> ans3 = new ArrayList<>(hm2.get(creator[i]));\\n                finalans2.add(creator[i]);\\n                finalans2.add(ans3.get(1));\\n                al.add(finalans2);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        List<List<String>> al = new ArrayList<>();\\n        HashMap<String, Long> hm = new HashMap<>();\\n        HashMap<String, ArrayList<String>> hm2 = new HashMap<>();\\n        for(int i = 0; i < creators.length; i++){\\n            if(hm.containsKey(creators[i])){\\n                Long temp = hm.get(creators[i]);\\n                temp = temp + views[i];\\n                hm.put(creators[i], temp);\\n                ArrayList<String> v = new ArrayList<>(hm2.get(creators[i]));\\n                if(views[i]> Integer.parseInt(v.get(2))){\\n                    v.set(1, ids[i]);\\n                    v.set(2, Integer.toString(views[i]));\\n                }\\n                if(views[i]==Integer.parseInt(v.get(2))){\\n                    String[] st = new String[]{ids[i], v.get(1)};\\n                    Arrays.sort(st);\\n                    v.set(1, st[0]);\\n                    v.set(2, Integer.toString(views[i]));\\n                }\\n                hm2.put(creators[i], v);\\n            }\\n            else{\\n                hm.put(creators[i], Long.valueOf(views[i]));\\n                ArrayList<String> t= new ArrayList<>();\\n                t.add(creators[i]);\\n                t.add(ids[i]);\\n                t.add(Integer.toString(views[i]));\\n                hm2.put(creators[i], t);\\n            }\\n        }\\n       \\n        List<Map.Entry<String, Long>> mn = new ArrayList<>(hm.entrySet());\\n        Collections.sort(mn, new Comparator<Map.Entry<String, Long>>(){\\n            public int compare(Map.Entry<String, Long> o1, Map.Entry<String, Long> o2){\\n                return o2.getValue().compareTo(o1.getValue());\\n            }\\n        });\\n        String[] creator = new String[hm.size()];\\n        Long[] view = new Long[hm.size()];\\n        int k = 0;\\n        for(Map.Entry<String, Long> entry : mn){\\n            creator[k] = entry.getKey();\\n            view[k] = entry.getValue();\\n    \\n            k++;\\n        }\\n        ArrayList<String> ans = new ArrayList<>();\\n        ArrayList<String> ans2 = new ArrayList<>(hm2.get(creator[0]));\\n        ans.add(creator[0]);\\n        ans.add(ans2.get(1));\\n        al.add(ans);\\n    \\n        for(int i = 1; i < creator.length; i++){\\n\\n            if(view[i].equals(view[i-1])){\\n                ArrayList<String> finalans2 = new ArrayList<>();\\n                ArrayList<String> ans3 = new ArrayList<>(hm2.get(creator[i]));\\n                finalans2.add(creator[i]);\\n                finalans2.add(ans3.get(1));\\n                al.add(finalans2);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629627,
                "title": "hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the maximum views directors first and and then find the most viewed movies of that particular director. \\n85 out of 86 testcases will be passed if int datatype is taken to count total number of views of each director and so Long is taken to extend the range.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String,Long> map = new HashMap<>();\\n        for(int i=0;i<views.length;i++){\\n            map.put(creators[i],map.getOrDefault(creators[i],(long)0)+(long)views[i]);\\n        }\\n        Map<String,Pair<String,Integer>> count = new HashMap<>();\\n        for(int i=0;i<views.length;i++){\\n            if(count.containsKey(creators[i])){\\n                if(count.get(creators[i]).getValue()<views[i]){\\n                    count.put(creators[i],new Pair<>(ids[i],views[i]));\\n                }else if(count.get(creators[i]).getValue()==views[i]){\\n                    if(isSmall(ids[i],count.get(creators[i]).getKey())){\\n                        count.put(creators[i],new Pair<>(ids[i],views[i]));\\n                    }\\n                }\\n            }else{\\n                count.put(creators[i], new Pair<>(ids[i],views[i]));\\n            }\\n        }\\n        long maxViews = map.values().stream().mapToLong(Long::longValue).max().orElse(0);\\n        List<String> directors = new ArrayList<>();\\n        for(String key : map.keySet()){\\n            if(map.get(key)==maxViews){\\n                directors.add(key);\\n            }\\n        }\\n        System.out.println(map.get(\"a\")+\" \"+map.get(\"b\"));\\n        List<List<String>> ans = new ArrayList<>();\\n        for(String dir : directors){\\n            List<String> temp = new ArrayList<>();\\n            temp.add(dir);\\n            temp.add(count.get(dir).getKey());\\n            ans.add(new ArrayList<>(temp));\\n        }\\n        return ans;\\n    }\\n    public boolean isSmall(String a, String b){\\n        for(int i=0;i<Math.min(a.length(),b.length());i++){\\n            if((int)a.charAt(i)<(int)b.charAt(i)) return true;\\n            if((int)a.charAt(i)>(int)b.charAt(i)) return false;\\n        }\\n        return a.length()<b.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String,Long> map = new HashMap<>();\\n        for(int i=0;i<views.length;i++){\\n            map.put(creators[i],map.getOrDefault(creators[i],(long)0)+(long)views[i]);\\n        }\\n        Map<String,Pair<String,Integer>> count = new HashMap<>();\\n        for(int i=0;i<views.length;i++){\\n            if(count.containsKey(creators[i])){\\n                if(count.get(creators[i]).getValue()<views[i]){\\n                    count.put(creators[i],new Pair<>(ids[i],views[i]));\\n                }else if(count.get(creators[i]).getValue()==views[i]){\\n                    if(isSmall(ids[i],count.get(creators[i]).getKey())){\\n                        count.put(creators[i],new Pair<>(ids[i],views[i]));\\n                    }\\n                }\\n            }else{\\n                count.put(creators[i], new Pair<>(ids[i],views[i]));\\n            }\\n        }\\n        long maxViews = map.values().stream().mapToLong(Long::longValue).max().orElse(0);\\n        List<String> directors = new ArrayList<>();\\n        for(String key : map.keySet()){\\n            if(map.get(key)==maxViews){\\n                directors.add(key);\\n            }\\n        }\\n        System.out.println(map.get(\"a\")+\" \"+map.get(\"b\"));\\n        List<List<String>> ans = new ArrayList<>();\\n        for(String dir : directors){\\n            List<String> temp = new ArrayList<>();\\n            temp.add(dir);\\n            temp.add(count.get(dir).getKey());\\n            ans.add(new ArrayList<>(temp));\\n        }\\n        return ans;\\n    }\\n    public boolean isSmall(String a, String b){\\n        for(int i=0;i<Math.min(a.length(),b.length());i++){\\n            if((int)a.charAt(i)<(int)b.charAt(i)) return true;\\n            if((int)a.charAt(i)>(int)b.charAt(i)) return false;\\n        }\\n        return a.length()<b.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617428,
                "title": "c-easy-to-understand-intuitive-solution",
                "content": "# Intuition\\nCode along with what you think , no other way. I \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n 4 maps and 2 vectors.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        int n=creators.size();\\n        vector<vector<string>>ans;\\n        map<string,long long int>m;\\n        for(int i=0;i<n;i++){\\n            m[creators[i]]+=views[i];\\n        }\\n        long long maxi=0;\\n        vector<string>cr;\\n        for(auto pr:m){\\n            maxi=max(maxi,pr.second);\\n        }\\n        for(auto pr:m){\\n            if(pr.second==maxi){\\n                cr.push_back(pr.first);\\n            }\\n        }\\n        map<string,long long int>mp;\\n        map<string,long long int>tmp=mp;\\n        map<string,string>tp;\\n        for(auto x:cr){\\n        mp[x]++;\\n        tmp[x]=-1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp[creators[i]]){\\n                if(views[i]>tmp[creators[i]]){\\n                    tmp[creators[i]]=views[i];\\n                    tp[creators[i]]=ids[i];\\n                }\\n                if(views[i]==tmp[creators[i]]){\\n                    tp[creators[i]]=min(ids[i],tp[creators[i]]);\\n                }\\n            }\\n        }\\n        for(auto x:tp){\\n            ans.push_back({x.first,x.second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        int n=creators.size();\\n        vector<vector<string>>ans;\\n        map<string,long long int>m;\\n        for(int i=0;i<n;i++){\\n            m[creators[i]]+=views[i];\\n        }\\n        long long maxi=0;\\n        vector<string>cr;\\n        for(auto pr:m){\\n            maxi=max(maxi,pr.second);\\n        }\\n        for(auto pr:m){\\n            if(pr.second==maxi){\\n                cr.push_back(pr.first);\\n            }\\n        }\\n        map<string,long long int>mp;\\n        map<string,long long int>tmp=mp;\\n        map<string,string>tp;\\n        for(auto x:cr){\\n        mp[x]++;\\n        tmp[x]=-1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp[creators[i]]){\\n                if(views[i]>tmp[creators[i]]){\\n                    tmp[creators[i]]=views[i];\\n                    tp[creators[i]]=ids[i];\\n                }\\n                if(views[i]==tmp[creators[i]]){\\n                    tp[creators[i]]=min(ids[i],tp[creators[i]]);\\n                }\\n            }\\n        }\\n        for(auto x:tp){\\n            ans.push_back({x.first,x.second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590826,
                "title": "python3-freqtable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        freq  , count_ , ans = defaultdict(list) ,defaultdict(int) , []\\n        for creator , id , view in zip(creators , ids , views):\\n            \\n            count_[creator]+=view\\n            \\n            if creator not in freq or freq[creator][0] < view or freq[creator][0] == view and id < freq[creator][1]:\\n                freq[creator] = (view , id)\\n\\n        max_val = max(count_.values())\\n        for c , lst in freq.items():\\n            if count_[c] == max_val: ans.append((c , lst[1]))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        freq  , count_ , ans = defaultdict(list) ,defaultdict(int) , []\\n        for creator , id , view in zip(creators , ids , views):\\n            \\n            count_[creator]+=view\\n            \\n            if creator not in freq or freq[creator][0] < view or freq[creator][0] == view and id < freq[creator][1]:\\n                freq[creator] = (view , id)\\n\\n        max_val = max(count_.values())\\n        for c , lst in freq.items():\\n            if count_[c] == max_val: ans.append((c , lst[1]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581243,
                "title": "c-most-crappy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstatic bool cmp(const pair<string,pair<string,int>> &a,const pair<string,pair<string,int>> &b)\\n{\\n    if(a.second.second==b.second.second)\\n    {\\n        return a.second.first<b.second.first;\\n    }\\n       return a.second.second>b.second.second;\\n}\\nvector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n    map<string,long long> mp;\\n    vector<pair<string,pair<string,long long>>> q;\\n    for(int i=0;i<creators.size();i++)\\n    {\\n        mp[creators[i]]+=views[i];\\n        q.push_back({creators[i],{ids[i],views[i]}});\\n    }\\n    sort(q.begin(),q.end(), cmp);\\n    long long mx=0;\\n    for(auto it:mp)\\n    {\\n        if(it.second>mx)\\n        {\\n            mx=it.second;\\n        }\\n    }\\n    map<string,pair<string,long long>> pq;\\n    for(int i=0;i<q.size();i++)\\n    {\\n        string x=q[i].first;\\n        if (mp[x]==mx and pq.find(x)==pq.end())\\n        {\\n            pq[x]={q[i].second.first,q[i].second.second};\\n        }\\n    }\\n    vector<vector<string>> ans;\\n    for(auto it: pq)\\n    {\\n        ans.push_back({it.first,it.second.first});\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstatic bool cmp(const pair<string,pair<string,int>> &a,const pair<string,pair<string,int>> &b)\\n{\\n    if(a.second.second==b.second.second)\\n    {\\n        return a.second.first<b.second.first;\\n    }\\n       return a.second.second>b.second.second;\\n}\\nvector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n    map<string,long long> mp;\\n    vector<pair<string,pair<string,long long>>> q;\\n    for(int i=0;i<creators.size();i++)\\n    {\\n        mp[creators[i]]+=views[i];\\n        q.push_back({creators[i],{ids[i],views[i]}});\\n    }\\n    sort(q.begin(),q.end(), cmp);\\n    long long mx=0;\\n    for(auto it:mp)\\n    {\\n        if(it.second>mx)\\n        {\\n            mx=it.second;\\n        }\\n    }\\n    map<string,pair<string,long long>> pq;\\n    for(int i=0;i<q.size();i++)\\n    {\\n        string x=q[i].first;\\n        if (mp[x]==mx and pq.find(x)==pq.end())\\n        {\\n            pq[x]={q[i].second.first,q[i].second.second};\\n        }\\n    }\\n    vector<vector<string>> ans;\\n    for(auto it: pq)\\n    {\\n        ans.push_back({it.first,it.second.first});\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539064,
                "title": "c-easy-to-understand",
                "content": "```\\nclass creator {\\npublic:\\n    long long views = 0, best = -1;\\n    string bestID;\\n    map<string, int> ids;\\n    creator () {}\\n    \\n    void update(string id, int v) {\\n        views += v;\\n        ids[id] += v;\\n        if (ids[id] > best || (ids[id] == best && id < bestID))\\n            bestID = id, best = ids[id];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, creator> mp;\\n        long long best=0;\\n        for (int i=0; i<size(ids); ++i) {\\n            mp[creators[i]].update(ids[i], views[i]);\\n            best = max(best, mp[creators[i]].views);\\n        }\\n        vector<vector<string>> ans;\\n        for (auto [name, data] : mp) {\\n            if(data.views != best) continue;\\n            ans.push_back({name, data.bestID});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass creator {\\npublic:\\n    long long views = 0, best = -1;\\n    string bestID;\\n    map<string, int> ids;\\n    creator () {}\\n    \\n    void update(string id, int v) {\\n        views += v;\\n        ids[id] += v;\\n        if (ids[id] > best || (ids[id] == best && id < bestID))\\n            bestID = id, best = ids[id];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, creator> mp;\\n        long long best=0;\\n        for (int i=0; i<size(ids); ++i) {\\n            mp[creators[i]].update(ids[i], views[i]);\\n            best = max(best, mp[creators[i]].views);\\n        }\\n        vector<vector<string>> ans;\\n        for (auto [name, data] : mp) {\\n            if(data.views != best) continue;\\n            ans.push_back({name, data.bestID});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432155,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        most = {}\\n        best = {}\\n\\n        for i in range(len(views)):\\n            most[creators[i]] = most.get(creators[i], 0) + views[i]\\n            if creators[i] not in best or views[i] > views[best[creators[i]]]:\\n                best[creators[i]] = i\\n            elif views[i] == views[best[creators[i]]]:\\n                best[creators[i]] = i if ids[i] < ids[best[creators[i]]] else best[creators[i]]\\n\\n        maxx = max(most.values())\\n\\n        return [[k, ids[v]] for k,v in best.items() if most[k] == maxx]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        most = {}\\n        best = {}\\n\\n        for i in range(len(views)):\\n            most[creators[i]] = most.get(creators[i], 0) + views[i]\\n            if creators[i] not in best or views[i] > views[best[creators[i]]]:\\n                best[creators[i]] = i\\n            elif views[i] == views[best[creators[i]]]:\\n                best[creators[i]] = i if ids[i] < ids[best[creators[i]]] else best[creators[i]]\\n\\n        maxx = max(most.values())\\n\\n        return [[k, ids[v]] for k,v in best.items() if most[k] == maxx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415519,
                "title": "ruby-decision",
                "content": "\\n# Code\\n```\\n# @param {String[]} creators\\n# @param {String[]} ids\\n# @param {Integer[]} views\\n# @return {String[][]}\\n\\ndef most_popular_creator(creators, ids, views)\\n  creators_views = {}\\n  max_views = 0\\n  creators.each_with_index do |creator, i|\\n    max_view = creators_views[creator]&.dig(:max_view).to_i\\n    creator_id = creators_views[creator]&.dig(:id) || ids[i]\\n    if views[i] > max_view\\n      creator_id = ids[i]\\n      max_view = views[i]\\n    end\\n    creator_id = ids[i] if views[i] == max_view && ids[i] < creator_id\\n    sum_views = creators_views[creator]&.dig(:sum_views).to_i + views[i]\\n    creators_views[creator] = { sum_views: sum_views, max_view: max_view, id: creator_id }\\n    max_views = sum_views if sum_views > max_views\\n  end\\n  creators_views.select { |_creator, obj| obj[:sum_views] == max_views }\\n                .map { |creator, obj| [creator, obj[:id]] }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String[]} creators\\n# @param {String[]} ids\\n# @param {Integer[]} views\\n# @return {String[][]}\\n\\ndef most_popular_creator(creators, ids, views)\\n  creators_views = {}\\n  max_views = 0\\n  creators.each_with_index do |creator, i|\\n    max_view = creators_views[creator]&.dig(:max_view).to_i\\n    creator_id = creators_views[creator]&.dig(:id) || ids[i]\\n    if views[i] > max_view\\n      creator_id = ids[i]\\n      max_view = views[i]\\n    end\\n    creator_id = ids[i] if views[i] == max_view && ids[i] < creator_id\\n    sum_views = creators_views[creator]&.dig(:sum_views).to_i + views[i]\\n    creators_views[creator] = { sum_views: sum_views, max_view: max_view, id: creator_id }\\n    max_views = sum_views if sum_views > max_views\\n  end\\n  creators_views.select { |_creator, obj| obj[:sum_views] == max_views }\\n                .map { |creator, obj| [creator, obj[:id]] }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3400613,
                "title": "trie-100-212-ms-o-n-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nString length <= 5, use trie instead of map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEach node stores some information.\\nIn addition, use an array to store all the words that have appeared.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    Trie search = O(5*n)\\n    Other = O(n)\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    Trie = O(26*n)\\n    Other = O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct trie{\\n        trie* nxt[26];\\n        long long sum,ma=-1;\\n        bool isnw;\\n        string mw;\\n    };trie* root=new trie();\\n    vector<vector<string>> mostPopularCreator(vector<string>& cs, vector<string>& ids, vector<int>& vs) {\\n        long long mav=0;\\n        vector <string> st;\\n        for(int i=0;i<cs.size();++i){\\n            trie* t=root;\\n            for(int j=0;j<cs[i].size();++j){\\n                if(t->nxt[cs[i][j]-\\'a\\']==nullptr)\\n                    t->nxt[cs[i][j]-\\'a\\'] = new trie();\\n                t=t->nxt[cs[i][j]-\\'a\\'];\\n            }\\n            if(t->isnw==0)\\n                st.push_back(cs[i]),t->isnw=1;\\n            t->sum+=vs[i];\\n            mav=max(mav,t->sum);\\n            if(vs[i]>t->ma||(vs[i]==t->ma&&ids[i]<t->mw))t->mw=ids[i],t->ma=vs[i];\\n        }\\n        vector <vector <string>> ans;\\n        for(int i=0;i<st.size();++i){\\n            trie* t=root;\\n            for(int j=0;j<st[i].size();++j)\\n                t=t->nxt[st[i][j]-\\'a\\'];\\n            if(t->sum==mav){\\n                vector <string> tmp={st[i],t->mw};\\n                ans.push_back(tmp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct trie{\\n        trie* nxt[26];\\n        long long sum,ma=-1;\\n        bool isnw;\\n        string mw;\\n    };trie* root=new trie();\\n    vector<vector<string>> mostPopularCreator(vector<string>& cs, vector<string>& ids, vector<int>& vs) {\\n        long long mav=0;\\n        vector <string> st;\\n        for(int i=0;i<cs.size();++i){\\n            trie* t=root;\\n            for(int j=0;j<cs[i].size();++j){\\n                if(t->nxt[cs[i][j]-\\'a\\']==nullptr)\\n                    t->nxt[cs[i][j]-\\'a\\'] = new trie();\\n                t=t->nxt[cs[i][j]-\\'a\\'];\\n            }\\n            if(t->isnw==0)\\n                st.push_back(cs[i]),t->isnw=1;\\n            t->sum+=vs[i];\\n            mav=max(mav,t->sum);\\n            if(vs[i]>t->ma||(vs[i]==t->ma&&ids[i]<t->mw))t->mw=ids[i],t->ma=vs[i];\\n        }\\n        vector <vector <string>> ans;\\n        for(int i=0;i<st.size();++i){\\n            trie* t=root;\\n            for(int j=0;j<st[i].size();++j)\\n                t=t->nxt[st[i][j]-\\'a\\'];\\n            if(t->sum==mav){\\n                vector <string> tmp={st[i],t->mw};\\n                ans.push_back(tmp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374406,
                "title": "easy-c-solution-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        // creator ->view count\\n        // creator ->most viewed video\\n        unordered_map<string,long long int>mp1;\\n        unordered_map<string,int>mp2;\\n        long long int max_views=0;\\n        for(int i=0;i<creators.size();i++)\\n        {\\n            mp1[creators[i]]+=views[i];\\n            max_views=max(max_views,mp1[creators[i]]);\\n            if(mp2.find(creators[i])==mp2.end())\\n            {\\n                mp2[creators[i]]=i;\\n            }\\n            else\\n            {\\n                if(views[mp2[creators[i]]]<views[i])\\n                {\\n                    mp2[creators[i]]=i;\\n                }\\n                else if(views[mp2[creators[i]]]==views[i])\\n                {\\n                    if(ids[mp2[creators[i]]]>ids[i])\\n                    {\\n                        mp2[creators[i]]=i;\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<string>>ans;\\n        for(auto it=mp1.begin();it!=mp1.end();it++)\\n        {\\n            if(it->second==max_views)\\n            {\\n                ans.push_back({it->first,ids[mp2[it->first]]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        // creator ->view count\\n        // creator ->most viewed video\\n        unordered_map<string,long long int>mp1;\\n        unordered_map<string,int>mp2;\\n        long long int max_views=0;\\n        for(int i=0;i<creators.size();i++)\\n        {\\n            mp1[creators[i]]+=views[i];\\n            max_views=max(max_views,mp1[creators[i]]);\\n            if(mp2.find(creators[i])==mp2.end())\\n            {\\n                mp2[creators[i]]=i;\\n            }\\n            else\\n            {\\n                if(views[mp2[creators[i]]]<views[i])\\n                {\\n                    mp2[creators[i]]=i;\\n                }\\n                else if(views[mp2[creators[i]]]==views[i])\\n                {\\n                    if(ids[mp2[creators[i]]]>ids[i])\\n                    {\\n                        mp2[creators[i]]=i;\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<string>>ans;\\n        for(auto it=mp1.begin();it!=mp1.end();it++)\\n        {\\n            if(it->second==max_views)\\n            {\\n                ans.push_back({it->first,ids[mp2[it->first]]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324719,
                "title": "java-a-play-on-data-structures-maps-lists-and-sorts",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        int n = creators.length;\\n        Map<String, Aggregate> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            String creator = creators[i];\\n            String id = ids[i];\\n            int viewCount = views[i];\\n            Id_Views idv = new Id_Views(id, viewCount);\\n            if (map.get(creator) == null) {\\n                Aggregate agr = new Aggregate(creator, idv, viewCount);\\n                map.put(creator, agr);\\n            } else {\\n                Aggregate agr = map.get(creator);\\n                agr.videoIds.add(idv);\\n                agr.totalViews += viewCount;\\n                map.put(creator, agr);\\n            }\\n        }\\n\\n        List<Aggregate> aggrigates = new ArrayList<>();\\n        for (Aggregate agr : map.values()) {\\n            aggrigates.add(agr);\\n        }\\n        map.clear(); //not required\\n        Collections.sort(aggrigates, (A, B) -> B.totalViews - A.totalViews);\\n        int maxTotalViews = aggrigates.get(0).totalViews;\\n        List<List<String>> res = new ArrayList<>();\\n        for (Aggregate agr : aggrigates) {\\n            if (agr.totalViews != maxTotalViews) break;\\n            List<String> list = new ArrayList<>();\\n            list.add(agr.creator);\\n            List<Id_Views> videoIds = agr.videoIds;\\n            Collections.sort(videoIds, (A, B) -> B.views - A.views == 0? A.id.compareTo(B.id) : B.views - A.views);\\n            list.add(videoIds.get(0).id);\\n            res.add(list);\\n        }\\n        return res;\\n    }\\n\\n    class Id_Views {\\n        String id;\\n        Integer views;\\n\\n        Id_Views(String id, Integer views) {\\n            this.id = id;\\n            this.views = views;\\n        }\\n    }\\n\\n    class Aggregate {\\n        String creator = \"\";\\n        List<Id_Views> videoIds = new ArrayList<>();\\n        Integer totalViews = 0;\\n\\n        Aggregate(String creator, Id_Views idv, Integer totalViews) {\\n            this.creator = creator;\\n            videoIds.add(idv);\\n            this.totalViews = totalViews;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        int n = creators.length;\\n        Map<String, Aggregate> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            String creator = creators[i];\\n            String id = ids[i];\\n            int viewCount = views[i];\\n            Id_Views idv = new Id_Views(id, viewCount);\\n            if (map.get(creator) == null) {\\n                Aggregate agr = new Aggregate(creator, idv, viewCount);\\n                map.put(creator, agr);\\n            } else {\\n                Aggregate agr = map.get(creator);\\n                agr.videoIds.add(idv);\\n                agr.totalViews += viewCount;\\n                map.put(creator, agr);\\n            }\\n        }\\n\\n        List<Aggregate> aggrigates = new ArrayList<>();\\n        for (Aggregate agr : map.values()) {\\n            aggrigates.add(agr);\\n        }\\n        map.clear(); //not required\\n        Collections.sort(aggrigates, (A, B) -> B.totalViews - A.totalViews);\\n        int maxTotalViews = aggrigates.get(0).totalViews;\\n        List<List<String>> res = new ArrayList<>();\\n        for (Aggregate agr : aggrigates) {\\n            if (agr.totalViews != maxTotalViews) break;\\n            List<String> list = new ArrayList<>();\\n            list.add(agr.creator);\\n            List<Id_Views> videoIds = agr.videoIds;\\n            Collections.sort(videoIds, (A, B) -> B.views - A.views == 0? A.id.compareTo(B.id) : B.views - A.views);\\n            list.add(videoIds.get(0).id);\\n            res.add(list);\\n        }\\n        return res;\\n    }\\n\\n    class Id_Views {\\n        String id;\\n        Integer views;\\n\\n        Id_Views(String id, Integer views) {\\n            this.id = id;\\n            this.views = views;\\n        }\\n    }\\n\\n    class Aggregate {\\n        String creator = \"\";\\n        List<Id_Views> videoIds = new ArrayList<>();\\n        Integer totalViews = 0;\\n\\n        Aggregate(String creator, Id_Views idv, Integer totalViews) {\\n            this.creator = creator;\\n            videoIds.add(idv);\\n            this.totalViews = totalViews;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305342,
                "title": "unordered-map-with-array-as-value-of-specific-size-tc-o-n-simple",
                "content": "// Used Array due to static data structure\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        \\n        unordered_map<string,long long [2]> map;\\n        \\n        int n = creators.size();\\n        long long  maxi = INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            long long cal=map[creators[i]][0]+views[i];\\n            long long v = max(map[creators[i]][1],(long long)views[i]);\\n            map[creators[i]][0]=cal;\\n            map[creators[i]][1]=v;\\n            maxi=max(maxi,cal);\\n        }\\n        \\n        \\n        unordered_map<string,string> umap;\\n        \\n        for(int i=0;i<n;i++){\\n            if(map[creators[i]][0]==maxi && map[creators[i]][1]==views[i]){\\n                if(umap.count(creators[i]))\\n                umap[creators[i]]=min(ids[i],umap[creators[i]]);\\n                else \\n                    umap[creators[i]]=ids[i];\\n            }\\n        }\\n        \\n        vector<vector<string>> ans;\\n        \\n        for(auto [a,b]:umap){\\n            ans.push_back({a,b});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        \\n        unordered_map<string,long long [2]> map;\\n        \\n        int n = creators.size();\\n        long long  maxi = INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            long long cal=map[creators[i]][0]+views[i];\\n            long long v = max(map[creators[i]][1],(long long)views[i]);\\n            map[creators[i]][0]=cal;\\n            map[creators[i]][1]=v;\\n            maxi=max(maxi,cal);\\n        }\\n        \\n        \\n        unordered_map<string,string> umap;\\n        \\n        for(int i=0;i<n;i++){\\n            if(map[creators[i]][0]==maxi && map[creators[i]][1]==views[i]){\\n                if(umap.count(creators[i]))\\n                umap[creators[i]]=min(ids[i],umap[creators[i]]);\\n                else \\n                    umap[creators[i]]=ids[i];\\n            }\\n        }\\n        \\n        vector<vector<string>> ans;\\n        \\n        for(auto [a,b]:umap){\\n            ans.push_back({a,b});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302959,
                "title": "solution-based-on-given-hints-simple-and-easy-to-understand-detailed-explaination",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        int n = creators.size(); // Get size of creators vector\\n        long max_count = 0; // Variable to store maximum sum of views\\n        string max_creator = \"\"; // Variable to store creator having maximum sum of views\\n\\n        // Hashmaps\\n        unordered_map<string,long> view_count; // Store creator and their view counts\\n        unordered_map<string,int> highest_count; // Store creator and their maximum view count\\n        unordered_map<string,string> most_popular_id; // Store creator and id of their video having maximum view count\\n\\n        // Result vector\\n        vector<vector<string>> result;\\n\\n        // Iterate over the creators vector\\n        for(int i = 0; i < n; i++){\\n            // Check if hashmap contains the name of ith creator\\n            if(view_count.count(creators[i]) == 0){\\n                // Do following if hashmap doesn\\'t contains creators name\\n                view_count.insert({creators[i],views[i]}); // Insert name and corresponding views\\n                highest_count.insert({creators[i],views[i]}); // Insert name and corresponding views in highest_count (since this is the highest till now)\\n                most_popular_id.insert({creators[i],ids[i]}); // Insert name and id (since this is most popular id till now)\\n            } else {\\n                // Do following name already exists in hashmap\\n                view_count[creators[i]] = view_count[creators[i]] + views[i]; // Sum the current views and insert into hashmap\\n\\n                // Update the highest view and most popular id\\n                if(highest_count[creators[i]] < views[i]){\\n                    highest_count[creators[i]] = views[i];\\n                    most_popular_id[creators[i]] = ids[i];\\n                } else if(highest_count[creators[i]] == views[i]){\\n                    // Insert lexigraphically smallest id in hashmap\\n                    if(most_popular_id[creators[i]] > ids[i])\\n                        most_popular_id[creators[i]] = ids[i];\\n                }   \\n            }\\n            \\n            // Keep track of creator name having maximum views\\n            if(view_count[creators[i]] >= max_count){\\n                max_count = view_count[creators[i]];\\n                max_creator = creators[i];\\n            }\\n        }\\n\\n        // Insert creator and most popular id of creator in temporary vector\\n        vector<string>temp;\\n        temp.push_back(max_creator);\\n        temp.push_back(most_popular_id[max_creator]);\\n\\n        // Insert the values in result vector\\n        result.push_back(temp);\\n\\n        // Iterate over view_count hashmap\\n        for(auto x:view_count){\\n            // Insert values in result vector only if the creator is not added earlier\\n            if(x.first != max_creator && x.second >= max_count){\\n                temp.clear();\\n                temp.push_back(x.first);\\n                temp.push_back(most_popular_id[x.first]);\\n                result.push_back(temp);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        int n = creators.size(); // Get size of creators vector\\n        long max_count = 0; // Variable to store maximum sum of views\\n        string max_creator = \"\"; // Variable to store creator having maximum sum of views\\n\\n        // Hashmaps\\n        unordered_map<string,long> view_count; // Store creator and their view counts\\n        unordered_map<string,int> highest_count; // Store creator and their maximum view count\\n        unordered_map<string,string> most_popular_id; // Store creator and id of their video having maximum view count\\n\\n        // Result vector\\n        vector<vector<string>> result;\\n\\n        // Iterate over the creators vector\\n        for(int i = 0; i < n; i++){\\n            // Check if hashmap contains the name of ith creator\\n            if(view_count.count(creators[i]) == 0){\\n                // Do following if hashmap doesn\\'t contains creators name\\n                view_count.insert({creators[i],views[i]}); // Insert name and corresponding views\\n                highest_count.insert({creators[i],views[i]}); // Insert name and corresponding views in highest_count (since this is the highest till now)\\n                most_popular_id.insert({creators[i],ids[i]}); // Insert name and id (since this is most popular id till now)\\n            } else {\\n                // Do following name already exists in hashmap\\n                view_count[creators[i]] = view_count[creators[i]] + views[i]; // Sum the current views and insert into hashmap\\n\\n                // Update the highest view and most popular id\\n                if(highest_count[creators[i]] < views[i]){\\n                    highest_count[creators[i]] = views[i];\\n                    most_popular_id[creators[i]] = ids[i];\\n                } else if(highest_count[creators[i]] == views[i]){\\n                    // Insert lexigraphically smallest id in hashmap\\n                    if(most_popular_id[creators[i]] > ids[i])\\n                        most_popular_id[creators[i]] = ids[i];\\n                }   \\n            }\\n            \\n            // Keep track of creator name having maximum views\\n            if(view_count[creators[i]] >= max_count){\\n                max_count = view_count[creators[i]];\\n                max_creator = creators[i];\\n            }\\n        }\\n\\n        // Insert creator and most popular id of creator in temporary vector\\n        vector<string>temp;\\n        temp.push_back(max_creator);\\n        temp.push_back(most_popular_id[max_creator]);\\n\\n        // Insert the values in result vector\\n        result.push_back(temp);\\n\\n        // Iterate over view_count hashmap\\n        for(auto x:view_count){\\n            // Insert values in result vector only if the creator is not added earlier\\n            if(x.first != max_creator && x.second >= max_count){\\n                temp.clear();\\n                temp.push_back(x.first);\\n                temp.push_back(most_popular_id[x.first]);\\n                result.push_back(temp);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256056,
                "title": "easy-solution-using-hashmaps-and-hashset-java",
                "content": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views)\\n    {\\n        Map<String, Long> viewcount=new HashMap<>();\\n        Map<String, Long> maxcount=new HashMap<>();\\n        \\n        for(int i=0;i<creators.length;i++)\\n        {\\n            if(viewcount.containsKey(creators[i])==false)\\n            {\\n                viewcount.put(creators[i],Long.valueOf(views[i]));\\n                maxcount.put(creators[i],Long.valueOf(views[i]));\\n               \\n            }\\n            else\\n            {\\n                viewcount.put(creators[i],viewcount.get(creators[i])+views[i]);\\n                long max=Math.max(maxcount.get(creators[i]),views[i]);\\n                maxcount.put(creators[i],max);\\n               \\n            }\\n        }\\n        \\n        List<Long> list=new ArrayList<>(viewcount.values());\\n        long maxvalue=Collections.max(list);\\n        \\n        Set<String> maxcreator=new HashSet<>();\\n        \\n        for(String name:viewcount.keySet())\\n        {\\n            if(viewcount.get(name)==maxvalue)\\n            {\\n                maxcreator.add(name);\\n            }\\n        }\\n        \\n        Map<String,List<String>> maps=new HashMap<>();\\n        \\n        for(int i=0;i<creators.length;i++)\\n        {\\n            if(maxcreator.contains(creators[i]) && views[i]==maxcount.get(creators[i]))\\n            {\\n                if(maps.containsKey(creators[i])==false)\\n                {\\n                    List<String> result=new ArrayList<>();\\n                    result.add(ids[i]);\\n                    maps.put(creators[i],result);\\n                }\\n                else\\n                {\\n                    maps.get(creators[i]).add(ids[i]);\\n                }\\n            }\\n        }\\n        \\n        List<List<String>> ans=new ArrayList<>();\\n        for(String s:maps.keySet())\\n        {\\n            Collections.sort(maps.get(s));\\n            List<String> names=new ArrayList<>();\\n            names.add(s);\\n            names.add(maps.get(s).get(0));\\n            ans.add(names);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views)\\n    {\\n        Map<String, Long> viewcount=new HashMap<>();\\n        Map<String, Long> maxcount=new HashMap<>();\\n        \\n        for(int i=0;i<creators.length;i++)\\n        {\\n            if(viewcount.containsKey(creators[i])==false)\\n            {\\n                viewcount.put(creators[i],Long.valueOf(views[i]));\\n                maxcount.put(creators[i],Long.valueOf(views[i]));\\n               \\n            }\\n            else\\n            {\\n                viewcount.put(creators[i],viewcount.get(creators[i])+views[i]);\\n                long max=Math.max(maxcount.get(creators[i]),views[i]);\\n                maxcount.put(creators[i],max);\\n               \\n            }\\n        }\\n        \\n        List<Long> list=new ArrayList<>(viewcount.values());\\n        long maxvalue=Collections.max(list);\\n        \\n        Set<String> maxcreator=new HashSet<>();\\n        \\n        for(String name:viewcount.keySet())\\n        {\\n            if(viewcount.get(name)==maxvalue)\\n            {\\n                maxcreator.add(name);\\n            }\\n        }\\n        \\n        Map<String,List<String>> maps=new HashMap<>();\\n        \\n        for(int i=0;i<creators.length;i++)\\n        {\\n            if(maxcreator.contains(creators[i]) && views[i]==maxcount.get(creators[i]))\\n            {\\n                if(maps.containsKey(creators[i])==false)\\n                {\\n                    List<String> result=new ArrayList<>();\\n                    result.add(ids[i]);\\n                    maps.put(creators[i],result);\\n                }\\n                else\\n                {\\n                    maps.get(creators[i]).add(ids[i]);\\n                }\\n            }\\n        }\\n        \\n        List<List<String>> ans=new ArrayList<>();\\n        for(String s:maps.keySet())\\n        {\\n            Collections.sort(maps.get(s));\\n            List<String> names=new ArrayList<>();\\n            names.add(s);\\n            names.add(maps.get(s).get(0));\\n            ans.add(names);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251465,
                "title": "treeset-treemap-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views){\\n        int n = ids.length;\\n        HashMap<String,Long> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            long k = (long)views[i];\\n            long z = 0;\\n        map.put(creators[i],map.getOrDefault(creators[i],z)+k);\\n        }\\n        HashMap<String,TreeMap<Integer,TreeSet<String>>> set = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(!set.containsKey(creators[i])){\\n                TreeMap<Integer,TreeSet<String>> tree = new TreeMap<>();\\n                TreeSet<String> str = new TreeSet<>();\\n                tree.put(views[i],str);\\n                set.put(creators[i],tree);\\n            }\\n            if(!set.get(creators[i]).containsKey(views[i])){\\n                TreeSet<String> st = new TreeSet<>();\\n                set.get(creators[i]).put(views[i],st);\\n            }\\n            set.get(creators[i]).get(views[i]).add(ids[i]);\\n        }\\n        long maxViews = Long.MIN_VALUE;\\n        for(long x : map.values()) maxViews = Math.max(x,maxViews);\\n        List<List<String>> list = new ArrayList<>();\\n        for(String str : set.keySet()){\\n            if(map.get(str)==maxViews){\\n                List<String>lst = new ArrayList<>();\\n                lst.add(str);\\n                int y = set.get(str).lastKey();\\n                lst.add(set.get(str).get(y).first());\\n                list.add(lst);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views){\\n        int n = ids.length;\\n        HashMap<String,Long> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            long k = (long)views[i];\\n            long z = 0;\\n        map.put(creators[i],map.getOrDefault(creators[i],z)+k);\\n        }\\n        HashMap<String,TreeMap<Integer,TreeSet<String>>> set = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(!set.containsKey(creators[i])){\\n                TreeMap<Integer,TreeSet<String>> tree = new TreeMap<>();\\n                TreeSet<String> str = new TreeSet<>();\\n                tree.put(views[i],str);\\n                set.put(creators[i],tree);\\n            }\\n            if(!set.get(creators[i]).containsKey(views[i])){\\n                TreeSet<String> st = new TreeSet<>();\\n                set.get(creators[i]).put(views[i],st);\\n            }\\n            set.get(creators[i]).get(views[i]).add(ids[i]);\\n        }\\n        long maxViews = Long.MIN_VALUE;\\n        for(long x : map.values()) maxViews = Math.max(x,maxViews);\\n        List<List<String>> list = new ArrayList<>();\\n        for(String str : set.keySet()){\\n            if(map.get(str)==maxViews){\\n                List<String>lst = new ArrayList<>();\\n                lst.add(str);\\n                int y = set.get(str).lastKey();\\n                lst.add(set.get(str).get(y).first());\\n                list.add(lst);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229252,
                "title": "javascript-new-map",
                "content": "```\\nconst mostPopularCreator = (creators, ids, views) => {\\n  let mostPop = 0;\\n\\n  let map = creators.reduce((map, creator, i) => {\\n    let [curId, curViews] = [ids[i], views[i]];\\n\\n    if (map.has(creator)) {\\n      let user = map.get(creator);\\n      user.pop += curViews;\\n      mostPop = Math.max(user.pop, mostPop);\\n\\n      if (curViews > user.bestVid[1]) user.bestVid = [curId, curViews];\\n      else if (curViews == user.bestVid[1] && curId < user.bestVid[0]) user.bestVid[0] = curId;\\n    } \\n    else {\\n      map.set(creator, { pop: curViews, bestVid: [curId, curViews] });\\n      mostPop = Math.max(curViews, mostPop);\\n    }\\n\\n    return map;\\n  }, new Map());\\n\\n  return [...map.entries()].reduce((res, creator) => {\\n    if (creator[1].pop == mostPop) res.push([creator[0], creator[1].bestVid[0]]);\\n    return res;\\n  }, []);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mostPopularCreator = (creators, ids, views) => {\\n  let mostPop = 0;\\n\\n  let map = creators.reduce((map, creator, i) => {\\n    let [curId, curViews] = [ids[i], views[i]];\\n\\n    if (map.has(creator)) {\\n      let user = map.get(creator);\\n      user.pop += curViews;\\n      mostPop = Math.max(user.pop, mostPop);\\n\\n      if (curViews > user.bestVid[1]) user.bestVid = [curId, curViews];\\n      else if (curViews == user.bestVid[1] && curId < user.bestVid[0]) user.bestVid[0] = curId;\\n    } \\n    else {\\n      map.set(creator, { pop: curViews, bestVid: [curId, curViews] });\\n      mostPop = Math.max(curViews, mostPop);\\n    }\\n\\n    return map;\\n  }, new Map());\\n\\n  return [...map.entries()].reduce((res, creator) => {\\n    if (creator[1].pop == mostPop) res.push([creator[0], creator[1].bestVid[0]]);\\n    return res;\\n  }, []);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3229199,
                "title": "c",
                "content": "```\\nstruct Creator {\\n  long popularity;  // Popularity sum.\\n  string Id;        // Id that has max view.\\n  int curView;      // Cur view of the creator.\\n};\\n\\nclass Solution {\\n public:\\n  vector<vector<string>> mostPopularCreator(vector<string>& creators,\\n                                            vector<string>& ids,\\n                                            vector<int>& views) {\\n    vector<vector<string>> ret;\\n    unordered_map<string, Creator> Map;  //{name, Creator}\\n    long maxPopularity = 0;\\n\\n    for (int i = 0; i < creators.size(); ++i) {\\n      if (Map.count(creators[i]) == 0) {\\n        Map[creators[i]] = Creator{\\n            .popularity = views[i],\\n            .Id = ids[i],\\n            .curView = views[i],\\n        };\\n        maxPopularity = max(maxPopularity, (long)views[i]);\\n        continue;\\n      }\\n      Creator& c = Map[creators[i]];\\n      c.popularity += views[i];\\n      maxPopularity = max(maxPopularity, c.popularity);\\n      if (c.curView < views[i] ||\\n          c.curView == views[i] && ids[i] < c.Id) {\\n        c.Id = ids[i];\\n        c.curView = views[i];\\n      }\\n    }\\n\\n    for (auto& [name, creator] : Map)\\n      if (creator.popularity == maxPopularity)\\n        ret.push_back({name, creator.Id});\\n\\n    return ret;\\n  }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Creator {\\n  long popularity;  // Popularity sum.\\n  string Id;        // Id that has max view.\\n  int curView;      // Cur view of the creator.\\n};\\n\\nclass Solution {\\n public:\\n  vector<vector<string>> mostPopularCreator(vector<string>& creators,\\n                                            vector<string>& ids,\\n                                            vector<int>& views) {\\n    vector<vector<string>> ret;\\n    unordered_map<string, Creator> Map;  //{name, Creator}\\n    long maxPopularity = 0;\\n\\n    for (int i = 0; i < creators.size(); ++i) {\\n      if (Map.count(creators[i]) == 0) {\\n        Map[creators[i]] = Creator{\\n            .popularity = views[i],\\n            .Id = ids[i],\\n            .curView = views[i],\\n        };\\n        maxPopularity = max(maxPopularity, (long)views[i]);\\n        continue;\\n      }\\n      Creator& c = Map[creators[i]];\\n      c.popularity += views[i];\\n      maxPopularity = max(maxPopularity, c.popularity);\\n      if (c.curView < views[i] ||\\n          c.curView == views[i] && ids[i] < c.Id) {\\n        c.Id = ids[i];\\n        c.curView = views[i];\\n      }\\n    }\\n\\n    for (auto& [name, creator] : Map)\\n      if (creator.popularity == maxPopularity)\\n        ret.push_back({name, creator.Id});\\n\\n    return ret;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212382,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Create a graph of user -> [(video_id, views)]\\n2. Simultaenously, create a Counter for all views of a user\\n3. Get most popular creator by sorting the counter\\n4. get the most popular video ids of all most popular creator\\n5. Done\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n\\n        #creators = [\"alice\",\"bob\",\"alice\",\"chris\"]\\n        #ids = [\"one\",\"two\",\"three\",\"four\"]\\n        #views = [5,10,5,4]\\n\\n        graph = defaultdict(list)\\n        popularityCounter = Counter()\\n        for c, i, v in sorted(zip(creators, ids, views)):\\n            graph[c].append((i,v))\\n            popularityCounter[c] += v\\n        \\n        populars = popularityCounter.most_common()\\n        \\n        maxViews = populars[0][1]\\n        res = []\\n        for c, views in populars:\\n            if maxViews == views:\\n                # videos = sorted(graph[c])\\n                videos = sorted(graph[c], key=lambda x: (-x[1], x[0]))\\n                res.append([c, videos[0][0]])\\n                maxViews = views\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n\\n        #creators = [\"alice\",\"bob\",\"alice\",\"chris\"]\\n        #ids = [\"one\",\"two\",\"three\",\"four\"]\\n        #views = [5,10,5,4]\\n\\n        graph = defaultdict(list)\\n        popularityCounter = Counter()\\n        for c, i, v in sorted(zip(creators, ids, views)):\\n            graph[c].append((i,v))\\n            popularityCounter[c] += v\\n        \\n        populars = popularityCounter.most_common()\\n        \\n        maxViews = populars[0][1]\\n        res = []\\n        for c, views in populars:\\n            if maxViews == views:\\n                # videos = sorted(graph[c])\\n                videos = sorted(graph[c], key=lambda x: (-x[1], x[0]))\\n                res.append([c, videos[0][0]])\\n                maxViews = views\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170946,
                "title": "rust-hashmap-solution",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn most_popular_creator(creators: Vec<String>, ids: Vec<String>, views: Vec<i32>) -> Vec<Vec<String>> {\\n        let mut popular: HashMap<String, (i32, u128, String)> = HashMap::new();\\n        let mut max_view = 0;\\n\\n        creators.into_iter().zip(ids.into_iter().zip(views.into_iter()))\\n            .for_each(|(cr, (mut id, vw))| {\\n                popular.entry(cr).and_modify(|(prev_mv, v, i)| {\\n                    *v += vw as u128;\\n                    max_view = max_view.max(*v);\\n\\n                    if *prev_mv == vw {\\n                        *i = (i.min(&mut id)).clone();\\n                    } else if *prev_mv < vw {\\n                        *i = id.clone();\\n                        *prev_mv = vw;\\n                    }\\n                }).or_insert_with(|| { max_view = max_view.max(vw as u128); (vw, vw as u128, id) });\\n            });\\n\\n        popular.into_iter().fold(vec![], |mut res, (k, v)| {\\n            if v.1 == max_view {\\n                res.push(vec![k, v.2]);\\n            }\\n            res\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn most_popular_creator(creators: Vec<String>, ids: Vec<String>, views: Vec<i32>) -> Vec<Vec<String>> {\\n        let mut popular: HashMap<String, (i32, u128, String)> = HashMap::new();\\n        let mut max_view = 0;\\n\\n        creators.into_iter().zip(ids.into_iter().zip(views.into_iter()))\\n            .for_each(|(cr, (mut id, vw))| {\\n                popular.entry(cr).and_modify(|(prev_mv, v, i)| {\\n                    *v += vw as u128;\\n                    max_view = max_view.max(*v);\\n\\n                    if *prev_mv == vw {\\n                        *i = (i.min(&mut id)).clone();\\n                    } else if *prev_mv < vw {\\n                        *i = id.clone();\\n                        *prev_mv = vw;\\n                    }\\n                }).or_insert_with(|| { max_view = max_view.max(vw as u128); (vw, vw as u128, id) });\\n            });\\n\\n        popular.into_iter().fold(vec![], |mut res, (k, v)| {\\n            if v.1 == max_view {\\n                res.push(vec![k, v.2]);\\n            }\\n            res\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3166805,
                "title": "simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\none map\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    struct node\\n    {\\n        int maxi=INT_MIN;\\n        long long total=0;\\n        string id=\"a\";\\n    };\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        map<string,node> store;\\n        long long maxi=INT_MIN;\\n        for(int i=0;i<views.size();i++)\\n        {\\n            if(store.find(creators[i])!=store.end())\\n            {\\n                store[creators[i]].total+=views[i];\\n                if(store[creators[i]].maxi<views[i])\\n                {\\n                    store[creators[i]].maxi=views[i];\\n                    store[creators[i]].id=ids[i];\\n                }\\n                else if(store[creators[i]].maxi==views[i]  )\\n                {\\n                    store[creators[i]].id=min(store[creators[i]].id,ids[i]);\\n                }\\n                maxi=max(maxi, store[creators[i]].total);\\n            }\\n            else\\n            {\\n                node t;\\n                t.maxi=views[i];\\n                t.total=views[i];\\n                t.id=ids[i];\\n                store[creators[i]]=t;\\n                maxi=max(maxi,t.total);\\n            }\\n\\n        }\\n        vector<vector<string>> ans;\\n        for(auto it:store)\\n        {\\n            if(it.second.total==maxi)\\n            {\\n                ans.push_back({it.first,it.second.id});\\n            }\\n        }\\n        // cout<<maxi;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    struct node\\n    {\\n        int maxi=INT_MIN;\\n        long long total=0;\\n        string id=\"a\";\\n    };\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        map<string,node> store;\\n        long long maxi=INT_MIN;\\n        for(int i=0;i<views.size();i++)\\n        {\\n            if(store.find(creators[i])!=store.end())\\n            {\\n                store[creators[i]].total+=views[i];\\n                if(store[creators[i]].maxi<views[i])\\n                {\\n                    store[creators[i]].maxi=views[i];\\n                    store[creators[i]].id=ids[i];\\n                }\\n                else if(store[creators[i]].maxi==views[i]  )\\n                {\\n                    store[creators[i]].id=min(store[creators[i]].id,ids[i]);\\n                }\\n                maxi=max(maxi, store[creators[i]].total);\\n            }\\n            else\\n            {\\n                node t;\\n                t.maxi=views[i];\\n                t.total=views[i];\\n                t.id=ids[i];\\n                store[creators[i]]=t;\\n                maxi=max(maxi,t.total);\\n            }\\n\\n        }\\n        vector<vector<string>> ans;\\n        for(auto it:store)\\n        {\\n            if(it.second.total==maxi)\\n            {\\n                ans.push_back({it.first,it.second.id});\\n            }\\n        }\\n        // cout<<maxi;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3164237,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(pair<pair<int,string>,string>&a,pair<pair<int,string>,string>&b)\\n    {\\n        if(a.first.first==b.first.first)\\n        return a<b;\\n        return a>b;\\n    }\\n    public:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n       using ll=long long;\\n        vector<pair<pair<int,string>,string>>vec;\\n        unordered_map<string,ll>mp;\\n        unordered_set<string>s;\\n         ll maxi=0;\\n        for(int i=0;i<ids.size();i++)\\n        {\\n            vec.push_back({{views[i],ids[i]},creators[i]});\\n            mp[creators[i]]+=views[i];\\n             maxi=max(maxi,mp[creators[i]]);\\n        }\\n        vector<vector<string>>ans;\\n        sort(vec.begin(),vec.end(),comp);\\n        for(auto &x:vec)\\n        {\\n            if(mp[x.second]==maxi)\\n            {\\n                if(s.count(x.second)==0)\\n                {\\n                ans.push_back({x.second,x.first.second});\\n                //cout<<x.second;\\n                s.insert(x.second);\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<pair<int,string>,string>&a,pair<pair<int,string>,string>&b)\\n    {\\n        if(a.first.first==b.first.first)\\n        return a<b;\\n        return a>b;\\n    }\\n    public:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n       using ll=long long;\\n        vector<pair<pair<int,string>,string>>vec;\\n        unordered_map<string,ll>mp;\\n        unordered_set<string>s;\\n         ll maxi=0;\\n        for(int i=0;i<ids.size();i++)\\n        {\\n            vec.push_back({{views[i],ids[i]},creators[i]});\\n            mp[creators[i]]+=views[i];\\n             maxi=max(maxi,mp[creators[i]]);\\n        }\\n        vector<vector<string>>ans;\\n        sort(vec.begin(),vec.end(),comp);\\n        for(auto &x:vec)\\n        {\\n            if(mp[x.second]==maxi)\\n            {\\n                if(s.count(x.second)==0)\\n                {\\n                ans.push_back({x.second,x.first.second});\\n                //cout<<x.second;\\n                s.insert(x.second);\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3162759,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& crt, vector<string>& ids, vector<int>& vws) \\n    {\\n        unordered_map<string,long> tot;\\n        unordered_map<string,vector<pair<long,string>>> vid;\\n        \\n        long m = 0;\\n        for (int i = 0; i < crt.size(); ++i)\\n        {\\n            tot[crt[i]] += vws[i]; \\n            m = max(m, tot[crt[i]]);\\n            vid[crt[i]].emplace_back(-vws[i], ids[i]);\\n        }\\n        \\n        vector<vector<string>> result;\\n        for (auto&[c,vv] : vid)\\n        {\\n            if (tot[c] != m) continue;\\n            result.push_back({c, min_element(vv.begin(),vv.end())->second});\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& crt, vector<string>& ids, vector<int>& vws) \\n    {\\n        unordered_map<string,long> tot;\\n        unordered_map<string,vector<pair<long,string>>> vid;\\n        \\n        long m = 0;\\n        for (int i = 0; i < crt.size(); ++i)\\n        {\\n            tot[crt[i]] += vws[i]; \\n            m = max(m, tot[crt[i]]);\\n            vid[crt[i]].emplace_back(-vws[i], ids[i]);\\n        }\\n        \\n        vector<vector<string>> result;\\n        for (auto&[c,vv] : vid)\\n        {\\n            if (tot[c] != m) continue;\\n            result.push_back({c, min_element(vv.begin(),vv.end())->second});\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151061,
                "title": "java-with-classes-implements-comparable",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        HashMap<String, Author> map = new HashMap<>();\\n        for (int i = 0; i < creators.length; i++) {\\n            if (map.containsKey(creators[i])) {\\n                map.get(creators[i]).addVideo(new Video(ids[i], views[i]));\\n            } else {\\n                Author author = new Author(creators[i]);\\n                author.addVideo(new Video(ids[i], views[i]));\\n                map.put(creators[i], author);\\n            }\\n        }\\n\\n        int maxPopularity = Collections.max(map.values()).popularity;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        for (Author a : map.values()) {\\n            if (a.popularity == maxPopularity) {\\n                res.add(List.of(\\n                        a.name,\\n                        a.getMostPopularVideoId()\\n                ));\\n            }\\n        }\\n        return res;\\n    }\\n\\n    class Author implements Comparable<Author> {\\n        String name;\\n        int popularity;\\n        List<Video> video;\\n\\n        public Author(String name) {\\n            this.name = name;\\n            this.video = new ArrayList<>();\\n        }\\n\\n        void addVideo(Video video) {\\n            this.video.add(video);\\n            this.popularity += video.view;\\n        }\\n\\n        String getMostPopularVideoId() {\\n            return Collections.max(this.video).id;\\n        }\\n\\n        @Override\\n        public int compareTo(Author o) {\\n            return this.popularity - o.popularity;\\n        }\\n    }\\n\\n    class Video implements Comparable<Video> {\\n        String id;\\n        int view;\\n\\n        public Video(String id, int view) {\\n            this.id = id;\\n            this.view = view;\\n        }\\n\\n        @Override\\n        public int compareTo(Video v2) {\\n            return this.view - v2.view == 0\\n                    ? v2.id.compareTo(this.id)\\n                    : this.view - v2.view;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        HashMap<String, Author> map = new HashMap<>();\\n        for (int i = 0; i < creators.length; i++) {\\n            if (map.containsKey(creators[i])) {\\n                map.get(creators[i]).addVideo(new Video(ids[i], views[i]));\\n            } else {\\n                Author author = new Author(creators[i]);\\n                author.addVideo(new Video(ids[i], views[i]));\\n                map.put(creators[i], author);\\n            }\\n        }\\n\\n        int maxPopularity = Collections.max(map.values()).popularity;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        for (Author a : map.values()) {\\n            if (a.popularity == maxPopularity) {\\n                res.add(List.of(\\n                        a.name,\\n                        a.getMostPopularVideoId()\\n                ));\\n            }\\n        }\\n        return res;\\n    }\\n\\n    class Author implements Comparable<Author> {\\n        String name;\\n        int popularity;\\n        List<Video> video;\\n\\n        public Author(String name) {\\n            this.name = name;\\n            this.video = new ArrayList<>();\\n        }\\n\\n        void addVideo(Video video) {\\n            this.video.add(video);\\n            this.popularity += video.view;\\n        }\\n\\n        String getMostPopularVideoId() {\\n            return Collections.max(this.video).id;\\n        }\\n\\n        @Override\\n        public int compareTo(Author o) {\\n            return this.popularity - o.popularity;\\n        }\\n    }\\n\\n    class Video implements Comparable<Video> {\\n        String id;\\n        int view;\\n\\n        public Video(String id, int view) {\\n            this.id = id;\\n            this.view = view;\\n        }\\n\\n        @Override\\n        public int compareTo(Video v2) {\\n            return this.view - v2.view == 0\\n                    ? v2.id.compareTo(this.id)\\n                    : this.view - v2.view;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140505,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n\\n        List<List<String>> ans=new ArrayList<>();\\n\\n        Map<String,Integer> map=new HashMap<>();\\n        Map<String,Integer> hmap=new HashMap<>();\\n\\n        int n=ids.length;\\n        int maxi=0;  // This will store the max value of creator\\n        for(int i=0;i<n;i++){\\n            map.put(creators[i],map.getOrDefault(creators[i],0)+views[i]);\\n            maxi=Math.max(maxi,map.get(creators[i]));\\n        }\\n\\n        System.out.println(map+\" \"+maxi);\\n\\n        for(String it:map.keySet()){\\n            if(map.get(it)==maxi || map.get(it)<0)\\n            hmap.put(it,maxi);\\n        }\\n        System.out.println(hmap);\\n\\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n\\n        for(int i=0;i<n;i++){\\n           if(hmap.containsKey(creators[i]))\\n           pq.offer(new Pair(creators[i],ids[i],views[i]));\\n        }\\n\\n        for(int i=0;i<hmap.size();i++){\\n            ans.add(new ArrayList<>());\\n        }\\n        int indx=0;\\n\\n        while(hmap.size()!=0){ \\n            Pair top=pq.poll();\\n            if(hmap.containsKey(top.name)){\\n                ans.get(indx).add(top.name);\\n                ans.get(indx++).add(top.ids);\\n                hmap.remove(top.name);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public boolean smaller(String a,String b){\\n\\n        for(int i=0;i<Math.min(a.length(),b.length());i++){\\n            if(a.charAt(i)-b.charAt(i)>0)\\n            return false;\\n        }\\n        if(a.length()>b.length()) return false;\\n\\n        return true;\\n    }\\n\\n    class Pair implements Comparable<Pair>{\\n        String name,ids;\\n        int views;\\n\\n        Pair(String _name,String _ids,int _views){\\n            name=_name;\\n            ids=_ids;\\n            views=_views;\\n        }\\n\\n        public int compareTo(Pair old){\\n  if(this.views==old.views) {\\n      if(smaller(this.ids,old.ids)==true) // this will swap if current id is small\\n      return -1;  // -1 denote swap\\n      else return 1;\\n  }\\n          // else i store id with most views\\n          return old.views-this.views;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n\\n        List<List<String>> ans=new ArrayList<>();\\n\\n        Map<String,Integer> map=new HashMap<>();\\n        Map<String,Integer> hmap=new HashMap<>();\\n\\n        int n=ids.length;\\n        int maxi=0;  // This will store the max value of creator\\n        for(int i=0;i<n;i++){\\n            map.put(creators[i],map.getOrDefault(creators[i],0)+views[i]);\\n            maxi=Math.max(maxi,map.get(creators[i]));\\n        }\\n\\n        System.out.println(map+\" \"+maxi);\\n\\n        for(String it:map.keySet()){\\n            if(map.get(it)==maxi || map.get(it)<0)\\n            hmap.put(it,maxi);\\n        }\\n        System.out.println(hmap);\\n\\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n\\n        for(int i=0;i<n;i++){\\n           if(hmap.containsKey(creators[i]))\\n           pq.offer(new Pair(creators[i],ids[i],views[i]));\\n        }\\n\\n        for(int i=0;i<hmap.size();i++){\\n            ans.add(new ArrayList<>());\\n        }\\n        int indx=0;\\n\\n        while(hmap.size()!=0){ \\n            Pair top=pq.poll();\\n            if(hmap.containsKey(top.name)){\\n                ans.get(indx).add(top.name);\\n                ans.get(indx++).add(top.ids);\\n                hmap.remove(top.name);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public boolean smaller(String a,String b){\\n\\n        for(int i=0;i<Math.min(a.length(),b.length());i++){\\n            if(a.charAt(i)-b.charAt(i)>0)\\n            return false;\\n        }\\n        if(a.length()>b.length()) return false;\\n\\n        return true;\\n    }\\n\\n    class Pair implements Comparable<Pair>{\\n        String name,ids;\\n        int views;\\n\\n        Pair(String _name,String _ids,int _views){\\n            name=_name;\\n            ids=_ids;\\n            views=_views;\\n        }\\n\\n        public int compareTo(Pair old){\\n  if(this.views==old.views) {\\n      if(smaller(this.ids,old.ids)==true) // this will swap if current id is small\\n      return -1;  // -1 denote swap\\n      else return 1;\\n  }\\n          // else i store id with most views\\n          return old.views-this.views;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138136,
                "title": "java-using-treemap-and-treeset",
                "content": "Very boring and lengthy problem ( \\u02D8\\uFE39\\u02D8 )\\n# Code\\n```\\nclass Solution{\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        int n  = creators.length;\\n        List<List<String>> res = new ArrayList<>();\\n        TreeMap<String, Long> map = new TreeMap<>();\\n        TreeMap<String, Integer> maxViews = new TreeMap<>();\\n        HashMap<String,TreeSet<String>> ts = new HashMap<>();\\n\\t\\t\\n        for (int i = 0; i < n; i++) {\\n            String g = creators[i];\\n            map.put(g, map.getOrDefault(g, (long)0) + views[i]);\\n            maxViews.put(g, Math.max(maxViews.getOrDefault(g, 0), views[i]));\\n        }\\n        // If the two videos of the same creator have equal no of views than we have to store both the ids in the TreeSet \\n        // and find the lexicographically smallest id but if one video has 5 views and other has 7 views than we store \\n        // the id of the video that has 7 views because we want to find the id of their most viewed video.\\n        for(int i = 0; i < n; i++){\\n            String g = creators[i];\\n            if(!ts.containsKey(g))\\n                ts.put(g,new TreeSet<String>());\\n\\t\\t\\t\\t\\n            if(maxViews.get(g) == views[i])\\n                ts.get(g).add(ids[i]);\\n        }\\n        // find the video having maximum no of views from map.\\n        long max = Collections.max(map.values());\\n\\t\\t\\n        // finding the id for the maximum viewed video using map & ts.\\n        // storing it in f List [creator , id] and than in final List res.\\n        for(Map.Entry<String,Long> entry : map.entrySet()){\\n            if(entry.getValue() == max){\\n                List<String> f = new ArrayList<>();\\n                f.add(entry.getKey());\\n                f.add(ts.get(entry.getKey()).first());\\n                res.add(f);\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        int n  = creators.length;\\n        List<List<String>> res = new ArrayList<>();\\n        TreeMap<String, Long> map = new TreeMap<>();\\n        TreeMap<String, Integer> maxViews = new TreeMap<>();\\n        HashMap<String,TreeSet<String>> ts = new HashMap<>();\\n\\t\\t\\n        for (int i = 0; i < n; i++) {\\n            String g = creators[i];\\n            map.put(g, map.getOrDefault(g, (long)0) + views[i]);\\n            maxViews.put(g, Math.max(maxViews.getOrDefault(g, 0), views[i]));\\n        }\\n        // If the two videos of the same creator have equal no of views than we have to store both the ids in the TreeSet \\n        // and find the lexicographically smallest id but if one video has 5 views and other has 7 views than we store \\n        // the id of the video that has 7 views because we want to find the id of their most viewed video.\\n        for(int i = 0; i < n; i++){\\n            String g = creators[i];\\n            if(!ts.containsKey(g))\\n                ts.put(g,new TreeSet<String>());\\n\\t\\t\\t\\t\\n            if(maxViews.get(g) == views[i])\\n                ts.get(g).add(ids[i]);\\n        }\\n        // find the video having maximum no of views from map.\\n        long max = Collections.max(map.values());\\n\\t\\t\\n        // finding the id for the maximum viewed video using map & ts.\\n        // storing it in f List [creator , id] and than in final List res.\\n        for(Map.Entry<String,Long> entry : map.entrySet()){\\n            if(entry.getValue() == max){\\n                List<String> f = new ArrayList<>();\\n                f.add(entry.getKey());\\n                f.add(ts.get(entry.getKey()).first());\\n                res.add(f);\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122384,
                "title": "simple-solution-hash-map-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,pair<string,long>>c_mx;\\n        unordered_map<string,long>mp;\\n\\n        int n = c.size();\\n        long mx = 0;\\n\\n        for(int i=0;i<n;i++){\\n            mp[c[i]] += views[i];\\n            if(c_mx.count(c[i]) == 0 || (c_mx[c[i]].second < views[i] ) || ( c_mx[c[i]].second == views[i] && c_mx[c[i]].first > ids[i])){\\n                c_mx[c[i]] = {ids[i],views[i]};\\n            }\\n            mx = max(mx,mp[c[i]]);\\n        }\\n\\n        vector<vector<string>>v;\\n        for(auto it : mp){\\n            if(it.second == mx){\\n                v.push_back({it.first,c_mx[it.first].first});\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n# Upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,pair<string,long>>c_mx;\\n        unordered_map<string,long>mp;\\n\\n        int n = c.size();\\n        long mx = 0;\\n\\n        for(int i=0;i<n;i++){\\n            mp[c[i]] += views[i];\\n            if(c_mx.count(c[i]) == 0 || (c_mx[c[i]].second < views[i] ) || ( c_mx[c[i]].second == views[i] && c_mx[c[i]].first > ids[i])){\\n                c_mx[c[i]] = {ids[i],views[i]};\\n            }\\n            mx = max(mx,mp[c[i]]);\\n        }\\n\\n        vector<vector<string>>v;\\n        for(auto it : mp){\\n            if(it.second == mx){\\n                v.push_back({it.first,c_mx[it.first].first});\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117855,
                "title": "go-faster-than-91-o-n-map-based",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nfunc mostPopularCreator(creators []string, ids []string, views []int) [][]string {\\n  l := len(ids)\\n  totalViews := map[string]int{}\\n\\n  maxViews := map[string]int{}\\n\\n  maxTotal := 0\\n\\n  for i := 0; i < l; i++{\\n      totalViews[creators[i]] += views[i]\\n      if _,found := maxViews[creators[i]]; !found || views[maxViews[creators[i]]] < views[i] || (views[maxViews[creators[i]]] == views[i] && ids[maxViews[creators[i]]] > ids[i]){\\n          maxViews[creators[i]] = i\\n      }\\n\\n      if totalViews[creators[i]] > maxTotal {\\n          maxTotal = totalViews[creators[i]]\\n      }\\n  }\\n\\n  ans := make([][]string, 0)\\n\\n  for creator := range totalViews{\\n      if totalViews[creator] == maxTotal{\\n          ans = append(ans, []string{creator, ids[maxViews[creator]]})\\n      }\\n  }\\n\\n  return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mostPopularCreator(creators []string, ids []string, views []int) [][]string {\\n  l := len(ids)\\n  totalViews := map[string]int{}\\n\\n  maxViews := map[string]int{}\\n\\n  maxTotal := 0\\n\\n  for i := 0; i < l; i++{\\n      totalViews[creators[i]] += views[i]\\n      if _,found := maxViews[creators[i]]; !found || views[maxViews[creators[i]]] < views[i] || (views[maxViews[creators[i]]] == views[i] && ids[maxViews[creators[i]]] > ids[i]){\\n          maxViews[creators[i]] = i\\n      }\\n\\n      if totalViews[creators[i]] > maxTotal {\\n          maxTotal = totalViews[creators[i]]\\n      }\\n  }\\n\\n  ans := make([][]string, 0)\\n\\n  for creator := range totalViews{\\n      if totalViews[creator] == maxTotal{\\n          ans = append(ans, []string{creator, ids[maxViews[creator]]})\\n      }\\n  }\\n\\n  return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3112881,
                "title": "simple-c-tc-0-n-full-algorithm-explained",
                "content": "\\n\\n# Approach\\nI\\'m pretty sure you know how to solve this problem, using hashmap.\\nBut even you know it, it\\'s hard to pass this problem, because its poor and ambiguous description of problem. If you don\\'t know why you fails this problem. Don\\'t worry, it is the fault of this problem, not your ability to apply hashmap to solve the problems.\\n\\nHere are some points to pay attention but not in description clearly.\\n\\nAll videos are unique, there are n videos, whatever the id or creator of the video, they are unique, which means we don\\'t need to add them up for the records with the same creator and id.\\nid and creator are not unique, for the replicated creator name, it refers to the same creator, the old one or a new creator. For the replicated id, it refers to a new video.\\nFor each creator, their views are cumulative.\\nSo to solve this problem, we need 2 hashmap, one is to record the videos info of each creator.\\n\\nAnother is to record the views of a creator have in total.\\n\\n\\nFirstly, we count up the max views for creators(may be more one creators), at the same time, we get the videos info list for each creator.\\n\\nAnd then, we get the video with max views(may be more than one) for the creators we just picked up based on creator2ids. For multiple videos, we picked up the videos with the highest views and then sort them as lexicographical order\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,unsigned long long> viewcount;\\n        unordered_map<string,pair<string,unsigned long>> max_id;\\n        vector<vector<string>> ans;\\n        unsigned long  max_views=0;\\n        int n=creators.size();\\n        for(int i=0;i<n;i++){\\n            //counting total views of each creator\\n            viewcount[creators[i]]=viewcount[creators[i]]+views[i];\\n            //finding max views\\n            if(max_views<viewcount[creators[i]]){\\n                max_views=viewcount[creators[i]];\\n            }\\n            //finding creators id with max views and lexicographically smallest\\n            if(max_id.find(creators[i])==max_id.end()){\\n                max_id[creators[i]]=make_pair(ids[i],views[i]);\\n            }\\n            else if(max_id[creators[i]].second<views[i]){\\n                max_id[creators[i]]=make_pair(ids[i],views[i]);\\n            }\\n            else if(max_id[creators[i]].second==views[i]){\\n                if(max_id[creators[i]].first>ids[i]){\\n                   max_id[creators[i]].first=ids[i]; \\n                }\\n            }\\n\\n        }\\n        //finding ans;\\n        for(auto i:viewcount){\\n            if(max_views==i.second){\\n                ans.push_back({i.first,max_id[i.first].first});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,unsigned long long> viewcount;\\n        unordered_map<string,pair<string,unsigned long>> max_id;\\n        vector<vector<string>> ans;\\n        unsigned long  max_views=0;\\n        int n=creators.size();\\n        for(int i=0;i<n;i++){\\n            //counting total views of each creator\\n            viewcount[creators[i]]=viewcount[creators[i]]+views[i];\\n            //finding max views\\n            if(max_views<viewcount[creators[i]]){\\n                max_views=viewcount[creators[i]];\\n            }\\n            //finding creators id with max views and lexicographically smallest\\n            if(max_id.find(creators[i])==max_id.end()){\\n                max_id[creators[i]]=make_pair(ids[i],views[i]);\\n            }\\n            else if(max_id[creators[i]].second<views[i]){\\n                max_id[creators[i]]=make_pair(ids[i],views[i]);\\n            }\\n            else if(max_id[creators[i]].second==views[i]){\\n                if(max_id[creators[i]].first>ids[i]){\\n                   max_id[creators[i]].first=ids[i]; \\n                }\\n            }\\n\\n        }\\n        //finding ans;\\n        for(auto i:viewcount){\\n            if(max_views==i.second){\\n                ans.push_back({i.first,max_id[i.first].first});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096052,
                "title": "easy-to-understand",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& id, vector<int>& v) \\n    {\\n        vector<vector<string>>ans;\\n        long long ma=-1;\\n        map<string,pair<long long,pair<int,string>>>m;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            if(m.find(c[i])==m.end())\\n            {\\n                m[c[i]].first=v[i];\\n                m[c[i]].second.first=(v[i]);\\n                m[c[i]].second.second=(id[i]);\\n            }\\n            else\\n            {\\n                m[c[i]].first=m[c[i]].first+v[i];\\n                if(m[c[i]].second.first<(v[i]))\\n                {\\n                    m[c[i]].second.first=(v[i]);\\n                    m[c[i]].second.second=(id[i]);\\n                }\\n                else\\n                {\\n                    if(m[c[i]].second.first==(v[i]))\\n                    {\\n                        m[c[i]].second.second=min(m[c[i]].second.second,(id[i]));\\n                    }\\n                }\\n                \\n            }\\n            ma=max(ma,m[c[i]].first);\\n        }\\n        for(auto x:m)\\n        {\\n            \\n            if(x.second.first==ma)\\n                ans.push_back({x.first,x.second.second.second});\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\"\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& id, vector<int>& v) \\n    {\\n        vector<vector<string>>ans;\\n        long long ma=-1;\\n        map<string,pair<long long,pair<int,string>>>m;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            if(m.find(c[i])==m.end())\\n            {\\n                m[c[i]].first=v[i];\\n                m[c[i]].second.first=(v[i]);\\n                m[c[i]].second.second=(id[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3084539,
                "title": "python-hashmap-heap",
                "content": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators, ids, views):\\n        popularityByCreator = defaultdict(int)\\n        viewCountByCreator = defaultdict(list)\\n        for i, creator in enumerate(creators):\\n            popularityByCreator[creator] += views[i]\\n            heappush(viewCountByCreator[creator], (-views[i], ids[i]))\\n        maxPopularity = max(popularityByCreator.values())\\n        ans = []\\n        for key, value in popularityByCreator.items():\\n            if value == maxPopularity:\\n                ans.append([key, heappop(viewCountByCreator[key])[1]])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators, ids, views):\\n        popularityByCreator = defaultdict(int)\\n        viewCountByCreator = defaultdict(list)\\n        for i, creator in enumerate(creators):\\n            popularityByCreator[creator] += views[i]\\n            heappush(viewCountByCreator[creator], (-views[i], ids[i]))\\n        maxPopularity = max(popularityByCreator.values())\\n        ans = []\\n        for key, value in popularityByCreator.items():\\n            if value == maxPopularity:\\n                ans.append([key, heappop(viewCountByCreator[key])[1]])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080761,
                "title": "c-hashmap-of-creators",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    struct Creator\\n    {\\n        int64_t m_numViews = 0;\\n        int m_highestViewedIdx = 0;\\n    };\\n\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n\\n        unordered_map<string, Creator> c;\\n\\n        int n = creators.size();\\n        int64_t highestViews = -1;\\n        unordered_set<string> popularCreators;\\n        for(int i=0; i<n; ++i)\\n        {\\n            auto it = c.insert({creators[i], {0,i}}).first;\\n      \\n            Creator& curr = it->second;\\n            int v = views[i];\\n            curr.m_numViews += v;\\n    \\n            if(curr.m_numViews > highestViews)\\n            {\\n                // Current creator\\'s total views is higher than highest running total\\n                highestViews = curr.m_numViews;\\n\\n                // Reset popular creator set to only hold current creator\\n                if(popularCreators.size() != 1 || *popularCreators.begin() != creators[i])\\n                {\\n                    popularCreators.clear();\\n                    popularCreators.insert(creators[i]);\\n                }\\n            }\\n            else if(curr.m_numViews == highestViews)\\n            {\\n                // Current creator is as popular as most popular encountered so far, so add it too\\n                popularCreators.insert(creators[i]);\\n            }\\n           \\n            // Update most popular video for this creator \\n            if(v > views[curr.m_highestViewedIdx] ||\\n                ((v == views[curr.m_highestViewedIdx]) && (ids[i] < ids[curr.m_highestViewedIdx])))\\n                curr.m_highestViewedIdx = i;\\n        }\\n\\n        vector<vector<string>> ans;\\n        for(string const& popularCreator : popularCreators)\\n            ans.push_back({popularCreator, ids[c[popularCreator].m_highestViewedIdx]});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    struct Creator\\n    {\\n        int64_t m_numViews = 0;\\n        int m_highestViewedIdx = 0;\\n    };\\n\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n\\n        unordered_map<string, Creator> c;\\n\\n        int n = creators.size();\\n        int64_t highestViews = -1;\\n        unordered_set<string> popularCreators;\\n        for(int i=0; i<n; ++i)\\n        {\\n            auto it = c.insert({creators[i], {0,i}}).first;\\n      \\n            Creator& curr = it->second;\\n            int v = views[i];\\n            curr.m_numViews += v;\\n    \\n            if(curr.m_numViews > highestViews)\\n            {\\n                // Current creator\\'s total views is higher than highest running total\\n                highestViews = curr.m_numViews;\\n\\n                // Reset popular creator set to only hold current creator\\n                if(popularCreators.size() != 1 || *popularCreators.begin() != creators[i])\\n                {\\n                    popularCreators.clear();\\n                    popularCreators.insert(creators[i]);\\n                }\\n            }\\n            else if(curr.m_numViews == highestViews)\\n            {\\n                // Current creator is as popular as most popular encountered so far, so add it too\\n                popularCreators.insert(creators[i]);\\n            }\\n           \\n            // Update most popular video for this creator \\n            if(v > views[curr.m_highestViewedIdx] ||\\n                ((v == views[curr.m_highestViewedIdx]) && (ids[i] < ids[curr.m_highestViewedIdx])))\\n                curr.m_highestViewedIdx = i;\\n        }\\n\\n        vector<vector<string>> ans;\\n        for(string const& popularCreator : popularCreators)\\n            ans.push_back({popularCreator, ids[c[popularCreator].m_highestViewedIdx]});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062953,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n     public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, List<String>> creatorsWithIds = new HashMap<>();\\n        Map<String, Long> creatorsWithViews = new HashMap<>();\\n        Map<String, Map<String, Integer>> creatorsWithSeparate = new HashMap<>();\\n        int count = creators.length;\\n\\n        for(int i = 0; i < count; i++){\\n            creatorsWithIds.putIfAbsent(creators[i],new ArrayList<>());\\n            creatorsWithIds.get(creators[i]).add(ids[i]);\\n            creatorsWithViews.put(creators[i], creatorsWithViews.getOrDefault(creators[i], 0l)+ views[i]);\\n            creatorsWithSeparate.putIfAbsent(creators[i], new HashMap<>());\\n            creatorsWithSeparate.get(creators[i]).put(ids[i], views[i]);\\n        }\\n\\n        long highestView = creatorsWithViews.entrySet().stream().sorted(Map.Entry.<String, Long>comparingByValue().reversed())\\n                .findFirst().get().getValue();\\n\\n        List<String> keys = creatorsWithViews.entrySet().stream().filter(x -> x.getValue() == highestView).map(Map.Entry::getKey)\\n                .collect(Collectors.toList());\\n\\n        List<List<String>> finalList = new ArrayList<>();\\n\\n        keys.forEach(x -> {\\n            List<String> l = new ArrayList<>();\\n            l.add(x);\\n            int val = creatorsWithSeparate.get(x).entrySet().stream().sorted(Map.Entry.<String, Integer>comparingByValue().reversed())\\n                            .findFirst().get().getValue();\\n            l.add(creatorsWithSeparate.get(x).entrySet().stream().filter(y -> y.getValue() == val)\\n                    .map(Map.Entry::getKey)\\n                    .sorted().findFirst().get());\\n            //l.add(creatorsWithIds.get(x).stream().sorted(Comparator.reverseOrder()).findFirst().get());\\n            finalList.add(l);\\n        });\\n        return finalList;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, List<String>> creatorsWithIds = new HashMap<>();\\n        Map<String, Long> creatorsWithViews = new HashMap<>();\\n        Map<String, Map<String, Integer>> creatorsWithSeparate = new HashMap<>();\\n        int count = creators.length;\\n\\n        for(int i = 0; i < count; i++){\\n            creatorsWithIds.putIfAbsent(creators[i],new ArrayList<>());\\n            creatorsWithIds.get(creators[i]).add(ids[i]);\\n            creatorsWithViews.put(creators[i], creatorsWithViews.getOrDefault(creators[i], 0l)+ views[i]);\\n            creatorsWithSeparate.putIfAbsent(creators[i], new HashMap<>());\\n            creatorsWithSeparate.get(creators[i]).put(ids[i], views[i]);\\n        }\\n\\n        long highestView = creatorsWithViews.entrySet().stream().sorted(Map.Entry.<String, Long>comparingByValue().reversed())\\n                .findFirst().get().getValue();\\n\\n        List<String> keys = creatorsWithViews.entrySet().stream().filter(x -> x.getValue() == highestView).map(Map.Entry::getKey)\\n                .collect(Collectors.toList());\\n\\n        List<List<String>> finalList = new ArrayList<>();\\n\\n        keys.forEach(x -> {\\n            List<String> l = new ArrayList<>();\\n            l.add(x);\\n            int val = creatorsWithSeparate.get(x).entrySet().stream().sorted(Map.Entry.<String, Integer>comparingByValue().reversed())\\n                            .findFirst().get().getValue();\\n            l.add(creatorsWithSeparate.get(x).entrySet().stream().filter(y -> y.getValue() == val)\\n                    .map(Map.Entry::getKey)\\n                    .sorted().findFirst().get());\\n            //l.add(creatorsWithIds.get(x).stream().sorted(Comparator.reverseOrder()).findFirst().get());\\n            finalList.add(l);\\n        });\\n        return finalList;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058193,
                "title": "cpp-easy-solution-o-n-using-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& cre, vector<string>& ids, vector<int>& v) {\\n        int n = ids.size();\\n        unordered_map<string,pair<long long int,string>>mp;\\n        unordered_map<string,long long int>mf;\\n        long long int mx = INT_MIN; \\n        for(int i=0;i<n;i++){\\n            long long int val = v[i];\\n            string c = cre[i];\\n            string id = ids[i];\\n            if(mp.find(c)==mp.end()){\\n                mp.insert({c,{val,id}});\\n            }else{\\n                if(mp[c].first < val){\\n                    mp[c].first = val;\\n                    mp[c].second = id;\\n                }else if(mp[c].first == val){\\n                    if(mp[c].second > id){\\n                        mp[c].second = id;\\n                    }\\n                }\\n            }\\n\\n\\n            mf[cre[i]]+=v[i];\\n            mx = max(mx,mf[cre[i]]);\\n        }\\n        vector<vector<string>>ans;\\n        for(auto x:mf){\\n            if(x.second == mx){\\n                ans.push_back({x.first,mp[x.first].second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& cre, vector<string>& ids, vector<int>& v) {\\n        int n = ids.size();\\n        unordered_map<string,pair<long long int,string>>mp;\\n        unordered_map<string,long long int>mf;\\n        long long int mx = INT_MIN; \\n        for(int i=0;i<n;i++){\\n            long long int val = v[i];\\n            string c = cre[i];\\n            string id = ids[i];\\n            if(mp.find(c)==mp.end()){\\n                mp.insert({c,{val,id}});\\n            }else{\\n                if(mp[c].first < val){\\n                    mp[c].first = val;\\n                    mp[c].second = id;\\n                }else if(mp[c].first == val){\\n                    if(mp[c].second > id){\\n                        mp[c].second = id;\\n                    }\\n                }\\n            }\\n\\n\\n            mf[cre[i]]+=v[i];\\n            mx = max(mx,mf[cre[i]]);\\n        }\\n        vector<vector<string>>ans;\\n        for(auto x:mf){\\n            if(x.second == mx){\\n                ans.push_back({x.first,mp[x.first].second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026667,
                "title": "javascript-hashmap-343ms-100",
                "content": "```\\nvar mostPopularCreator = function(creators, ids, views) {\\n    \\n    const creatorsSum = {}, mostViewed = {};\\n    \\n    let maxViews = 0;\\n    \\n    for(let i = 0; i < creators.length; i++) {\\n        \\n        const creator = creators[i];\\n        creatorsSum[creator] = (creatorsSum[creator] || 0) + views[i];\\n        maxViews = Math.max(maxViews, creatorsSum[creator]);\\n        \\n        if(mostViewed[creator] === undefined) mostViewed[creator] = i; \\n        \\n        const j = mostViewed[creator];\\n        \\n        if(views[i] > views[j] || (views[i] === views[j] && ids[i] < ids[j])) {\\n            mostViewed[creator] = i;\\n        }\\n    }\\n    \\n    const res = [];\\n    \\n    for(const creator in creatorsSum) {\\n        if(creatorsSum[creator] === maxViews) {\\n            \\n            res.push([creator, ids[mostViewed[creator]]]);\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar mostPopularCreator = function(creators, ids, views) {\\n    \\n    const creatorsSum = {}, mostViewed = {};\\n    \\n    let maxViews = 0;\\n    \\n    for(let i = 0; i < creators.length; i++) {\\n        \\n        const creator = creators[i];\\n        creatorsSum[creator] = (creatorsSum[creator] || 0) + views[i];\\n        maxViews = Math.max(maxViews, creatorsSum[creator]);\\n        \\n        if(mostViewed[creator] === undefined) mostViewed[creator] = i; \\n        \\n        const j = mostViewed[creator];\\n        \\n        if(views[i] > views[j] || (views[i] === views[j] && ids[i] < ids[j])) {\\n            mostViewed[creator] = i;\\n        }\\n    }\\n    \\n    const res = [];\\n    \\n    for(const creator in creatorsSum) {\\n        if(creatorsSum[creator] === maxViews) {\\n            \\n            res.push([creator, ids[mostViewed[creator]]]);\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3020981,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        \\n       //creator -> [ttl_views, CurrMax_views, id] \\n       unordered_map<string,vector<long long>> mp;\\n       vector<vector<string>> ans;\\n       int i=0;\\n       long long maxi = -1;\\n\\n      for(auto str:creators)\\n       {\\n        if(mp.find(str)==mp.end()){\\n          mp[str].push_back(views[i]); //ttl\\n          mp[str].push_back(views[i]); //currMax\\n          mp[str].push_back(i);       //id \\n        } \\n        else{\\n          mp[str][0] += views[i];\\n          if( mp[str][1]<views[i]){ \\n             mp[str][1] = views[i]; \\n             mp[str][2] = i;\\n          }\\n          else if( mp[str][1]==views[i]){\\n               string temp = min(ids[i],ids[ mp[str][2]]) ; \\n               if(ids[ mp[str][2]]!=temp)\\n                mp[str][2] = i;\\n          }\\n        }\\n        \\n        if(mp[str][0]>maxi)\\n            maxi = mp[str][0];\\n\\n        i++;  \\n      }\\n\\n       for (auto m:mp)\\n         if(maxi==m.second[0])  \\n          ans.push_back({m.first,ids[m.second[2]]});\\n       \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        \\n       //creator -> [ttl_views, CurrMax_views, id] \\n       unordered_map<string,vector<long long>> mp;\\n       vector<vector<string>> ans;\\n       int i=0;\\n       long long maxi = -1;\\n\\n      for(auto str:creators)\\n       {\\n        if(mp.find(str)==mp.end()){\\n          mp[str].push_back(views[i]); //ttl\\n          mp[str].push_back(views[i]); //currMax\\n          mp[str].push_back(i);       //id \\n        } \\n        else{\\n          mp[str][0] += views[i];\\n          if( mp[str][1]<views[i]){ \\n             mp[str][1] = views[i]; \\n             mp[str][2] = i;\\n          }\\n          else if( mp[str][1]==views[i]){\\n               string temp = min(ids[i],ids[ mp[str][2]]) ; \\n               if(ids[ mp[str][2]]!=temp)\\n                mp[str][2] = i;\\n          }\\n        }\\n        \\n        if(mp[str][0]>maxi)\\n            maxi = mp[str][0];\\n\\n        i++;  \\n      }\\n\\n       for (auto m:mp)\\n         if(maxi==m.second[0])  \\n          ans.push_back({m.first,ids[m.second[2]]});\\n       \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019094,
                "title": "eassy-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct video{\\n    long sum=0;\\n    string small;\\n    int max_view=0;\\n};\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& ids, vector<int>& views) {\\n     unordered_map<string,video> mpp;\\n     long count=0;\\n     for(int i=0;i<c.size();i++){\\n         if(!mpp.count(c[i])){\\n             mpp[c[i]]={views[i],ids[i],views[i]};\\n             count=max(count,mpp[c[i]].sum);\\n             continue;\\n         }\\n         mpp[c[i]].sum+=views[i];\\n         if(mpp[c[i]].max_view < views[i]|| mpp[c[i]].max_view==views[i] && mpp[c[i]].small > ids[i]){\\n             mpp[c[i]].small=ids[i];\\n             mpp[c[i]].max_view=views[i];\\n         }\\n         count=max(count,mpp[c[i]].sum);\\n     }   \\n     vector<vector<string>> ans;\\n     for(auto &r:mpp){\\n         if(r.second.sum==count){\\n             ans.push_back({r.first,r.second.small});\\n         }\\n     }\\n     return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct video{\\n    long sum=0;\\n    string small;\\n    int max_view=0;\\n};\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& c, vector<string>& ids, vector<int>& views) {\\n     unordered_map<string,video> mpp;\\n     long count=0;\\n     for(int i=0;i<c.size();i++){\\n         if(!mpp.count(c[i])){\\n             mpp[c[i]]={views[i],ids[i],views[i]};\\n             count=max(count,mpp[c[i]].sum);\\n             continue;\\n         }\\n         mpp[c[i]].sum+=views[i];\\n         if(mpp[c[i]].max_view < views[i]|| mpp[c[i]].max_view==views[i] && mpp[c[i]].small > ids[i]){\\n             mpp[c[i]].small=ids[i];\\n             mpp[c[i]].max_view=views[i];\\n         }\\n         count=max(count,mpp[c[i]].sum);\\n     }   \\n     vector<vector<string>> ans;\\n     for(auto &r:mpp){\\n         if(r.second.sum==count){\\n             ans.push_back({r.first,r.second.small});\\n         }\\n     }\\n     return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014875,
                "title": "c-1sec",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        if(size(views)==1) return{{creators[0],ids[0]}};\\n\\n        map<string,long long> viewMp;\\n        map<string,pair<string,int>> idMp;\\n        priority_queue<pair<long long,string>> pq;\\n        queue<string> names;\\n        vector<vector<string>> ans;\\n        int i=0;\\n\\n        for(string c : creators){\\n            viewMp[c]+=views[i];\\n            i++;\\n        }\\n        //op\\n        for(auto p:viewMp) cout<<p.first<<\" : \"<<p.second<<endl;\\n\\n        for(auto p:viewMp){\\n            pq.push({p.second,p.first});\\n        } \\n        long long currMax = pq.top().first;\\n\\n        while(pq.size()) {\\n              if(currMax==pq.top().first){\\n                 names.push(pq.top().second);\\n                 pq.pop();\\n                 }\\n              else break;   \\n        }\\n\\n        i=0;\\n        for(string c : creators){\\n            if(idMp.find(c)==idMp.end()){\\n                idMp[c] = {ids[i],views[i]};\\n            }\\n            else{\\n                 if(idMp[c].second<views[i])\\n                    idMp[c] = {ids[i],views[i]};\\n                 else if(idMp[c].second==views[i]){\\n                     priority_queue<string, vector<string>, greater<string> > gq;\\n                     gq.push(ids[i]);\\n                     gq.push(idMp[c].first);\\n                     if(gq.top()!=idMp[c].first)\\n                       idMp[c] = {ids[i],views[i]};\\n                 }   \\n            }\\n            i++;\\n        }\\n       \\n       \\n\\n        while(names.size()){\\n          vector<string> temp;\\n          temp.push_back(names.front());\\n          temp.push_back(idMp[names.front()].first);\\n          names.pop();\\n          ans.push_back(temp); \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        if(size(views)==1) return{{creators[0],ids[0]}};\\n\\n        map<string,long long> viewMp;\\n        map<string,pair<string,int>> idMp;\\n        priority_queue<pair<long long,string>> pq;\\n        queue<string> names;\\n        vector<vector<string>> ans;\\n        int i=0;\\n\\n        for(string c : creators){\\n            viewMp[c]+=views[i];\\n            i++;\\n        }\\n        //op\\n        for(auto p:viewMp) cout<<p.first<<\" : \"<<p.second<<endl;\\n\\n        for(auto p:viewMp){\\n            pq.push({p.second,p.first});\\n        } \\n        long long currMax = pq.top().first;\\n\\n        while(pq.size()) {\\n              if(currMax==pq.top().first){\\n                 names.push(pq.top().second);\\n                 pq.pop();\\n                 }\\n              else break;   \\n        }\\n\\n        i=0;\\n        for(string c : creators){\\n            if(idMp.find(c)==idMp.end()){\\n                idMp[c] = {ids[i],views[i]};\\n            }\\n            else{\\n                 if(idMp[c].second<views[i])\\n                    idMp[c] = {ids[i],views[i]};\\n                 else if(idMp[c].second==views[i]){\\n                     priority_queue<string, vector<string>, greater<string> > gq;\\n                     gq.push(ids[i]);\\n                     gq.push(idMp[c].first);\\n                     if(gq.top()!=idMp[c].first)\\n                       idMp[c] = {ids[i],views[i]};\\n                 }   \\n            }\\n            i++;\\n        }\\n       \\n       \\n\\n        while(names.size()){\\n          vector<string> temp;\\n          temp.push_back(names.front());\\n          temp.push_back(idMp[names.front()].first);\\n          names.pop();\\n          ans.push_back(temp); \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3009402,
                "title": "scala-two-liner",
                "content": "# Approach\\ngroupBy, sort, takeWhile\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n  def mostPopularCreator(creators: Array[String], ids: Array[String], views: Array[Int]): List[List[String]] = {\\n    lazy val sorted = (creators, ids, views).zipped.toList\\n      .groupMap(_._1){x => x._2 -> x._3}.toList\\n      .map{case (c,l) => (c, l, l.map(_._2.toLong).sum)}\\n      .sortBy{case (c,l,s) => -s}\\n    sorted.takeWhile(_._3 == sorted.head._3)\\n      .map{case (c,l,s) => List(c,l.minBy{case (a,b) => (-b, a)}._1)}\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n  def mostPopularCreator(creators: Array[String], ids: Array[String], views: Array[Int]): List[List[String]] = {\\n    lazy val sorted = (creators, ids, views).zipped.toList\\n      .groupMap(_._1){x => x._2 -> x._3}.toList\\n      .map{case (c,l) => (c, l, l.map(_._2.toLong).sum)}\\n      .sortBy{case (c,l,s) => -s}\\n    sorted.takeWhile(_._3 == sorted.head._3)\\n      .map{case (c,l,s) => List(c,l.minBy{case (a,b) => (-b, a)}._1)}\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2966651,
                "title": "easiest-solution-c-easy-to-understand-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass cmp{\\n    public:\\n    bool operator()(pair<string,ll> &p1,pair<string,ll> &p2){\\n        if(p1.second==p2.second) return p1.first>p2.first;\\n        return p1.second<p2.second;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,ll> mp1;\\n        unordered_map<string,priority_queue<pair<string,ll>,vector<pair<string,ll>>,cmp>> mp2;\\n        ll maxi = INT_MIN;\\n        for(int i=0;i<creators.size();i++){\\n            mp1[creators[i]]+=views[i];\\n            maxi=max(maxi,mp1[creators[i]]);\\n            mp2[creators[i]].push({ids[i],views[i]});\\n        }\\n        vector<vector<string>> ans;\\n        for(auto i:mp2){\\n            if(mp1[i.first]==maxi) ans.push_back({i.first,mp2[i.first].top().first});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass cmp{\\n    public:\\n    bool operator()(pair<string,ll> &p1,pair<string,ll> &p2){\\n        if(p1.second==p2.second) return p1.first>p2.first;\\n        return p1.second<p2.second;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string,ll> mp1;\\n        unordered_map<string,priority_queue<pair<string,ll>,vector<pair<string,ll>>,cmp>> mp2;\\n        ll maxi = INT_MIN;\\n        for(int i=0;i<creators.size();i++){\\n            mp1[creators[i]]+=views[i];\\n            maxi=max(maxi,mp1[creators[i]]);\\n            mp2[creators[i]].push({ids[i],views[i]});\\n        }\\n        vector<vector<string>> ans;\\n        for(auto i:mp2){\\n            if(mp1[i.first]==maxi) ans.push_back({i.first,mp2[i.first].top().first});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926881,
                "title": "tedious-but-fast-c-oop-solution-using-a-creator-struct",
                "content": "# First, and foremost, a criticism:\\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\nThis should be a design problem. \\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is one of those rare situations where it actually makes sense to contain data pertaining to a common index in an object. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI\\'m a masochist, so I decided maps and such were insufficient and made a custom structure with member functions. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nDon\\'t know, don\\'t care. The description was insufficient and coding this was stupidly tedious. This should be a design problem. I\\'m an algebraist at heart and don\\'t really care for object-oriented approaches, but based on the distribution of results, this looks like it\\'s close to optimal for both time and space. I used ```std::sort,``` which is n log n, so I\\'m guessing it\\'s $$O(n log n),$$ but my contempt for this problem compels me to refuse to check this on principle. Thankfully, the sort function comes with an optional third argument consisting of a function specifying how to actually sort the data. Lambdas come in handy here. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIDK, IDC, probably linear. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        int sz = ids.size();\\n        unordered_map<string, Creator*> data;\\n        vector<Creator*> ranking;\\n        for (int a = 0; a < sz; a++)\\n        {\\n            if (data.find(creators[a]) == data.end())\\n            {\\n                Creator* c = new Creator(creators[a], ids[a], views[a]);\\n                data[creators[a]] = c;\\n                ranking.push_back(c);\\n            }\\n            else \\n            {\\n                data[creators[a]]->add(ids[a], views[a]);\\n            }\\n        }\\n        for (Creator* c: ranking) c->adjustViews();\\n        vector<vector<string>> top;\\n        sort(ranking.begin(), ranking.end(), [](Creator* a, Creator* b){return a->views > b->views;});\\n        long long int topViews = ranking[0]->views;\\n        for (int a = 0; a < ranking.size() && ranking[a]->views == topViews; a++) top.push_back({ranking[a]->name, ranking[a]->getTopVid()});\\n        return top;\\n    }\\n    private:\\n    struct Creator\\n    {\\n        string name;\\n        long long int views;\\n        vector<pair<string, int>> videos;\\n        Creator(string name, string video, long long int views): views(views), name(name), videos({{video, views}})\\n        {} \\n        void add(string s, int i)\\n        {\\n            videos.push_back({s, i});\\n        }\\n        void adjustViews()\\n        {\\n            long long int sum = 0;\\n            for (pair<string, int> video: videos) sum += video.second;\\n            views = sum;\\n        } \\n        string getTopVid()\\n        {\\n            sort(videos.begin(), videos.end(), [](pair<string, int> a, pair<string, int> b){return (a.second > b.second) || (a.second == b.second && a.first < b.first);});\\n            return videos[0].first;\\n        }  \\n    };\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Design"
                ],
                "code": "```std::sort,```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        int sz = ids.size();\\n        unordered_map<string, Creator*> data;\\n        vector<Creator*> ranking;\\n        for (int a = 0; a < sz; a++)\\n        {\\n            if (data.find(creators[a]) == data.end())\\n            {\\n                Creator* c = new Creator(creators[a], ids[a], views[a]);\\n                data[creators[a]] = c;\\n                ranking.push_back(c);\\n            }\\n            else \\n            {\\n                data[creators[a]]->add(ids[a], views[a]);\\n            }\\n        }\\n        for (Creator* c: ranking) c->adjustViews();\\n        vector<vector<string>> top;\\n        sort(ranking.begin(), ranking.end(), [](Creator* a, Creator* b){return a->views > b->views;});\\n        long long int topViews = ranking[0]->views;\\n        for (int a = 0; a < ranking.size() && ranking[a]->views == topViews; a++) top.push_back({ranking[a]->name, ranking[a]->getTopVid()});\\n        return top;\\n    }\\n    private:\\n    struct Creator\\n    {\\n        string name;\\n        long long int views;\\n        vector<pair<string, int>> videos;\\n        Creator(string name, string video, long long int views): views(views), name(name), videos({{video, views}})\\n        {} \\n        void add(string s, int i)\\n        {\\n            videos.push_back({s, i});\\n        }\\n        void adjustViews()\\n        {\\n            long long int sum = 0;\\n            for (pair<string, int> video: videos) sum += video.second;\\n            views = sum;\\n        } \\n        string getTopVid()\\n        {\\n            sort(videos.begin(), videos.end(), [](pair<string, int> a, pair<string, int> b){return (a.second > b.second) || (a.second == b.second && a.first < b.first);});\\n            return videos[0].first;\\n        }  \\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926572,
                "title": "c-hashmap-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        struct helper_video {\\n            string video_id;\\n            int views{INT_MIN};\\n        };\\n        \\n        struct helper {\\n            helper_video hv;\\n            long long total{0LL};\\n        };\\n        \\n        unordered_map<string, helper> pop;\\n        const int N = creators.size();\\n        long long mx = INT_MIN;\\n        \\n        for(int i = 0; i < N; ++i) {\\n            const auto &c = creators[i];\\n            const auto &id = ids[i];\\n            const long long v = views[i];\\n            pop[c].total += v;\\n            mx = max(pop[c].total, mx);\\n            if(pop[c].hv.views <= v) {\\n                if(pop[c].hv.views == v) {\\n                    pop[c].hv.video_id = min(pop[c].hv.video_id, id);\\n                } else {\\n                    pop[c].hv.video_id = id;\\n                    pop[c].hv.views = v;\\n                }\\n            }\\n        }\\n        vector<vector<string>> ret;\\n        for(const auto &v : pop) {\\n            if(v.second.total != mx)\\n                continue;\\n            ret.push_back({v.first, v.second.hv.video_id});            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        struct helper_video {\\n            string video_id;\\n            int views{INT_MIN};\\n        };\\n        \\n        struct helper {\\n            helper_video hv;\\n            long long total{0LL};\\n        };\\n        \\n        unordered_map<string, helper> pop;\\n        const int N = creators.size();\\n        long long mx = INT_MIN;\\n        \\n        for(int i = 0; i < N; ++i) {\\n            const auto &c = creators[i];\\n            const auto &id = ids[i];\\n            const long long v = views[i];\\n            pop[c].total += v;\\n            mx = max(pop[c].total, mx);\\n            if(pop[c].hv.views <= v) {\\n                if(pop[c].hv.views == v) {\\n                    pop[c].hv.video_id = min(pop[c].hv.video_id, id);\\n                } else {\\n                    pop[c].hv.video_id = id;\\n                    pop[c].hv.views = v;\\n                }\\n            }\\n        }\\n        vector<vector<string>> ret;\\n        for(const auto &v : pop) {\\n            if(v.second.total != mx)\\n                continue;\\n            ret.push_back({v.first, v.second.hv.video_id});            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923452,
                "title": "soln-using-dictionaries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        from sortedcontainers import SortedList\\n        s = set()\\n        for c in creators:\\n            s.add(c)\\n\\n        if len(s) ==1:\\n            dp1 = defaultdict(int)\\n            dp2 = defaultdict(SortedList)\\n            v = -1\\n            i = \"\"\\n            pc = \"\"\\n            for c,id,view in zip(creators, ids, views):\\n                if v < view: \\n                    v = view\\n                    i  = id\\n                    pc = c\\n                elif v == view:\\n                    print(v,i, view, id)\\n                    if id < i:\\n                        v = view\\n                        i = id\\n                        pc = c\\n                #dp2[c].add([view,id])\\n            ans = [[pc,i]]\\n            return ans \\n\\n        \\n        dp1 = defaultdict(int)\\n        dp2 = defaultdict(SortedList)\\n        dp3 = defaultdict(SortedList)\\n        for c,id,view in zip(creators, ids, views):\\n            dp1[c] += view\\n            dp2[c].add(id)\\n            dp3[c].add([view,id])\\n\\n        dp1 = dict(sorted(dp1.items(), key=lambda item: item[1], reverse=True))\\n        highestV  = 0\\n        popularC = \"\"\\n        res = []\\n        ans = []\\n        first = True\\n        popularID = \"\"\\n        \\n        for c in dp1:\\n            res = []\\n            if first: \\n                highestV = dp1[c]\\n                popularC =  c\\n                popularID = dp2[c][0]\\n                res.append(popularC)\\n                res.append(popularID)\\n                ans.append(res)\\n                first = False\\n            else:\\n                if highestV == dp1[c]:\\n                    popularC =  c\\n                    popularID = dp2[c][0]\\n                    res.append(popularC)\\n                    res.append(popularID)\\n                    ans.append(res)\\n                #elif highestV < dp1[c]:\\n                #    return ans\\n        \\n        #print(dp1)\\n        #print(dp3[\"f\"])\\n        res = []\\n        for v in ans:\\n            #print (v)\\n\\n            c = v[0]\\n            lst = dp3[c]\\n            v = -1\\n            i = \"\"\\n            pc = \"\"\\n            \\n            for view,id in lst:\\n                if v < view: \\n                    v = view\\n                    i  = id\\n                    pc = c\\n                elif v == view:\\n                    print(v,i, view, id)\\n                    if id < i:\\n                        v = view\\n                        i = id\\n                        pc = c\\n                #dp2[c].add([view,id])\\n            res.append([pc,i])\\n        #return [[pc,i]]\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        from sortedcontainers import SortedList\\n        s = set()\\n        for c in creators:\\n            s.add(c)\\n\\n        if len(s) ==1:\\n            dp1 = defaultdict(int)\\n            dp2 = defaultdict(SortedList)\\n            v = -1\\n            i = \"\"\\n            pc = \"\"\\n            for c,id,view in zip(creators, ids, views):\\n                if v < view: \\n                    v = view\\n                    i  = id\\n                    pc = c\\n                elif v == view:\\n                    print(v,i, view, id)\\n                    if id < i:\\n                        v = view\\n                        i = id\\n                        pc = c\\n                #dp2[c].add([view,id])\\n            ans = [[pc,i]]\\n            return ans \\n\\n        \\n        dp1 = defaultdict(int)\\n        dp2 = defaultdict(SortedList)\\n        dp3 = defaultdict(SortedList)\\n        for c,id,view in zip(creators, ids, views):\\n            dp1[c] += view\\n            dp2[c].add(id)\\n            dp3[c].add([view,id])\\n\\n        dp1 = dict(sorted(dp1.items(), key=lambda item: item[1], reverse=True))\\n        highestV  = 0\\n        popularC = \"\"\\n        res = []\\n        ans = []\\n        first = True\\n        popularID = \"\"\\n        \\n        for c in dp1:\\n            res = []\\n            if first: \\n                highestV = dp1[c]\\n                popularC =  c\\n                popularID = dp2[c][0]\\n                res.append(popularC)\\n                res.append(popularID)\\n                ans.append(res)\\n                first = False\\n            else:\\n                if highestV == dp1[c]:\\n                    popularC =  c\\n                    popularID = dp2[c][0]\\n                    res.append(popularC)\\n                    res.append(popularID)\\n                    ans.append(res)\\n                #elif highestV < dp1[c]:\\n                #    return ans\\n        \\n        #print(dp1)\\n        #print(dp3[\"f\"])\\n        res = []\\n        for v in ans:\\n            #print (v)\\n\\n            c = v[0]\\n            lst = dp3[c]\\n            v = -1\\n            i = \"\"\\n            pc = \"\"\\n            \\n            for view,id in lst:\\n                if v < view: \\n                    v = view\\n                    i  = id\\n                    pc = c\\n                elif v == view:\\n                    print(v,i, view, id)\\n                    if id < i:\\n                        v = view\\n                        i = id\\n                        pc = c\\n                #dp2[c].add([view,id])\\n            res.append([pc,i])\\n        #return [[pc,i]]\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914094,
                "title": "java-hashmap-no-sorting-beats-99-both-execution-and-memory",
                "content": "# Intuition\\nPer each user Keep a total counter and the most watched video\\n\\n# Approach\\nPlace users on a HashMap. Create a class ViewCounter to handle the total and keep track of the highest watched video.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, ViewsCounter> totalCounter = new HashMap<>();\\n        //build map\\n        for(int i=0; i<ids.length; i++){\\n            totalCounter.putIfAbsent(creators[i], new ViewsCounter());\\n            totalCounter.get(creators[i]).addVideo(ids[i], views[i]);\\n        }\\n\\n        List<List<String>> result = new ArrayList<>();\\n        long nViews = 0;\\n\\n        for(var entry: totalCounter.entrySet()){\\n            //we found a new more popular user\\n            if(entry.getValue().total>nViews){\\n                nViews = entry.getValue().total;\\n                result.clear(); // we clear the users found so far, since our standard is higher now\\n                result.add(List.of(entry.getKey(), entry.getValue().mostPopularVideoId));\\n            }\\n            // we found and equally famous user\\n            else if(entry.getValue().total==nViews){\\n                result.add(List.of(entry.getKey(), entry.getValue().mostPopularVideoId));\\n            }\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    class ViewsCounter{\\n        long total = 0;\\n        String mostPopularVideoId=\"\";\\n        int videoViews = -1;\\n\\n        ViewsCounter(){}\\n\\n        void addVideo(String videoId, int nViews){\\n            //update total\\n            total=total+nViews;\\n            if(nViews==videoViews){\\n                //make sure to keep the smallest\\n                if(mostPopularVideoId.compareTo(videoId)>0)\\n                    mostPopularVideoId=videoId;\\n            } else if(nViews>videoViews){\\n                //we found a new more popular video, keep this one instead\\n                mostPopularVideoId = videoId;\\n                videoViews = nViews;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        Map<String, ViewsCounter> totalCounter = new HashMap<>();\\n        //build map\\n        for(int i=0; i<ids.length; i++){\\n            totalCounter.putIfAbsent(creators[i], new ViewsCounter());\\n            totalCounter.get(creators[i]).addVideo(ids[i], views[i]);\\n        }\\n\\n        List<List<String>> result = new ArrayList<>();\\n        long nViews = 0;\\n\\n        for(var entry: totalCounter.entrySet()){\\n            //we found a new more popular user\\n            if(entry.getValue().total>nViews){\\n                nViews = entry.getValue().total;\\n                result.clear(); // we clear the users found so far, since our standard is higher now\\n                result.add(List.of(entry.getKey(), entry.getValue().mostPopularVideoId));\\n            }\\n            // we found and equally famous user\\n            else if(entry.getValue().total==nViews){\\n                result.add(List.of(entry.getKey(), entry.getValue().mostPopularVideoId));\\n            }\\n        }\\n\\n        return result;\\n\\n    }\\n\\n    class ViewsCounter{\\n        long total = 0;\\n        String mostPopularVideoId=\"\";\\n        int videoViews = -1;\\n\\n        ViewsCounter(){}\\n\\n        void addVideo(String videoId, int nViews){\\n            //update total\\n            total=total+nViews;\\n            if(nViews==videoViews){\\n                //make sure to keep the smallest\\n                if(mostPopularVideoId.compareTo(videoId)>0)\\n                    mostPopularVideoId=videoId;\\n            } else if(nViews>videoViews){\\n                //we found a new more popular video, keep this one instead\\n                mostPopularVideoId = videoId;\\n                videoViews = nViews;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904678,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        \\n        vector <vector<string>> res ; int n = creators.size();\\n        map< string, long long > mp1, maxm_views;\\n        map< string, string > max_viewed_id;\\n        long long maxm = 0;\\n\\n        for(int i = 0 ; i < n ; ++i){\\n\\n            mp1[ creators[i] ] += views[i];\\n            if( maxm_views[ creators[i] ] < views[i] ){\\n\\n                maxm_views[ creators[i] ] = views[i];\\n                max_viewed_id[ creators[i] ] = ids[i];\\n            }\\n            else if( maxm_views[ creators[i] ] == views[i] ){\\n\\n                if(max_viewed_id[ creators[i] ] == \"\" ) max_viewed_id[ creators[i] ] = ids[i];\\n                else max_viewed_id[ creators[i] ] = min( max_viewed_id[ creators[i] ] , ids[i] );\\n            }\\n\\n            maxm = max( maxm , mp1[ creators[i] ] );\\n\\n        } \\n        for( auto x: mp1){\\n\\n            if( x.second == maxm ) res.push_back( { x.first , max_viewed_id[ x.first ] } );\\n            \\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        \\n        vector <vector<string>> res ; int n = creators.size();\\n        map< string, long long > mp1, maxm_views;\\n        map< string, string > max_viewed_id;\\n        long long maxm = 0;\\n\\n        for(int i = 0 ; i < n ; ++i){\\n\\n            mp1[ creators[i] ] += views[i];\\n            if( maxm_views[ creators[i] ] < views[i] ){\\n\\n                maxm_views[ creators[i] ] = views[i];\\n                max_viewed_id[ creators[i] ] = ids[i];\\n            }\\n            else if( maxm_views[ creators[i] ] == views[i] ){\\n\\n                if(max_viewed_id[ creators[i] ] == \"\" ) max_viewed_id[ creators[i] ] = ids[i];\\n                else max_viewed_id[ creators[i] ] = min( max_viewed_id[ creators[i] ] , ids[i] );\\n            }\\n\\n            maxm = max( maxm , mp1[ creators[i] ] );\\n\\n        } \\n        for( auto x: mp1){\\n\\n            if( x.second == maxm ) res.push_back( { x.first , max_viewed_id[ x.first ] } );\\n            \\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899782,
                "title": "smartest-shortest-python-solution",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        ans = []\\n        d = defaultdict(int)\\n        g = {x : [0, \\'z\\'] for x in creators}\\n\\n        for i, x in enumerate(creators):\\n            d[x] += views[i]\\n            g[x] = min(g[x], [-views[i], ids[i]])\\n\\n        m = max(list(d.values()))\\n        print(d)\\n        for x in d:\\n            if d[x] == m:\\n                ans.append([x, g[x][1]])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        ans = []\\n        d = defaultdict(int)\\n        g = {x : [0, \\'z\\'] for x in creators}\\n\\n        for i, x in enumerate(creators):\\n            d[x] += views[i]\\n            g[x] = min(g[x], [-views[i], ids[i]])\\n\\n        m = max(list(d.values()))\\n        print(d)\\n        for x in d:\\n            if d[x] == m:\\n                ans.append([x, g[x][1]])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898963,
                "title": "c-pure-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, vector<pair<string, int>>> my_map;\\n        unordered_map<string, long long> views_count;\\n        for(int i=0;i<ids.size();i++)\\n        {   \\n            my_map[creators[i]].push_back({ids[i], views[i]});\\n            views_count[creators[i]] += views[i];\\n        }\\n\\n        long long m_popularity = 0;\\n        for(auto& ele: views_count){\\n            m_popularity = max(m_popularity, ele.second);\\n        }\\n\\n        vector<string> res_strings;\\n        for(auto& ele: views_count){\\n            if(ele.second == m_popularity){\\n                res_strings.push_back(ele.first);\\n            }\\n        }\\n\\n\\n        vector<vector<string>> res;\\n        for(auto& name: res_strings){\\n            auto& extract_info = my_map[name];\\n            sort(extract_info.begin(), extract_info.end(), [&](pair<string, int>& a, pair<string, int>& b){\\n                if(a.second != b.second){\\n                    return a.second > b.second;\\n                }else{\\n                    return (a.first).compare(b.first) < 0;\\n                }\\n            });\\n\\n            res.push_back({name, extract_info[0].first});\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, vector<pair<string, int>>> my_map;\\n        unordered_map<string, long long> views_count;\\n        for(int i=0;i<ids.size();i++)\\n        {   \\n            my_map[creators[i]].push_back({ids[i], views[i]});\\n            views_count[creators[i]] += views[i];\\n        }\\n\\n        long long m_popularity = 0;\\n        for(auto& ele: views_count){\\n            m_popularity = max(m_popularity, ele.second);\\n        }\\n\\n        vector<string> res_strings;\\n        for(auto& ele: views_count){\\n            if(ele.second == m_popularity){\\n                res_strings.push_back(ele.first);\\n            }\\n        }\\n\\n\\n        vector<vector<string>> res;\\n        for(auto& name: res_strings){\\n            auto& extract_info = my_map[name];\\n            sort(extract_info.begin(), extract_info.end(), [&](pair<string, int>& a, pair<string, int>& b){\\n                if(a.second != b.second){\\n                    return a.second > b.second;\\n                }else{\\n                    return (a.first).compare(b.first) < 0;\\n                }\\n            });\\n\\n            res.push_back({name, extract_info[0].first});\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893795,
                "title": "p3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        \\n        d2 = defaultdict(int)\\n        for i in range(len(creators)):\\n            d2[creators[i]]+=views[i]\\n       \\n        ans = defaultdict(int)\\n        mx = max(d2.values())\\n        d2 = {i:d2[i] for i in d2 if d2[i] == mx}\\n       \\n    \\n        for i in range(len(creators)):\\n            if creators[i] in d2.keys():\\n                if views[i] >= ans[creators[i]] :\\n                    ans[creators[i]] = views[i]\\n        res = defaultdict(list)\\n       \\n\\n        for i in range(len(creators)):\\n            if creators[i] in ans.keys() and ans[creators[i]] == views[i]:\\n                    res[creators[i]].append(ids[i])\\n\\n        return [[a,sorted(b)[0]] for a,b in res.items()]\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        \\n        d2 = defaultdict(int)\\n        for i in range(len(creators)):\\n            d2[creators[i]]+=views[i]\\n       \\n        ans = defaultdict(int)\\n        mx = max(d2.values())\\n        d2 = {i:d2[i] for i in d2 if d2[i] == mx}\\n       \\n    \\n        for i in range(len(creators)):\\n            if creators[i] in d2.keys():\\n                if views[i] >= ans[creators[i]] :\\n                    ans[creators[i]] = views[i]\\n        res = defaultdict(list)\\n       \\n\\n        for i in range(len(creators)):\\n            if creators[i] in ans.keys() and ans[creators[i]] == views[i]:\\n                    res[creators[i]].append(ids[i])\\n\\n        return [[a,sorted(b)[0]] for a,b in res.items()]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881456,
                "title": "c-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        // find the most views for first popular creators\\n        unordered_map<string, long> vmap;\\n        for(long i=0; i<creators.size(); i++)\\n            vmap[creators[i]]+=views[i];\\n        long mostPopular = 0;\\n        for(auto p : vmap)\\n            mostPopular = max(mostPopular, p.second);\\n       \\n        // select the most popular creators out\\n         unordered_map<string, pair<int, string>> mmap;\\n        for(int i=0; i<creators.size(); i++)\\n            if(vmap[creators[i]] == mostPopular &&( mmap.count(creators[i]) == 0 || mmap[creators[i]] > pair{-views[i], ids[i]}))\\n                    mmap[creators[i]] = {-views[i], ids[i]};\\n        \\n        // put it into a string vector\\n        vector<vector<string>> ans;\\n        for(auto p : mmap)\\n            ans.push_back(vector<string>{p.first, p.second.second});\\n        return ans;\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        // find the most views for first popular creators\\n        unordered_map<string, long> vmap;\\n        for(long i=0; i<creators.size(); i++)\\n            vmap[creators[i]]+=views[i];\\n        long mostPopular = 0;\\n        for(auto p : vmap)\\n            mostPopular = max(mostPopular, p.second);\\n       \\n        // select the most popular creators out\\n         unordered_map<string, pair<int, string>> mmap;\\n        for(int i=0; i<creators.size(); i++)\\n            if(vmap[creators[i]] == mostPopular &&( mmap.count(creators[i]) == 0 || mmap[creators[i]] > pair{-views[i], ids[i]}))\\n                    mmap[creators[i]] = {-views[i], ids[i]};\\n        \\n        // put it into a string vector\\n        vector<vector<string>> ans;\\n        for(auto p : mmap)\\n            ans.push_back(vector<string>{p.first, p.second.second});\\n        return ans;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880878,
                "title": "99-faster-and-99-memory-safe-code-java-hashmap-nosorting",
                "content": "```\\nclass data{\\n    long count ;\\n    int highest ;\\n    String max_id ;\\n    \\n    data(int cnt , int hi , String max) {\\n        this.count = cnt;\\n        this.highest = hi;\\n        this.max_id = max;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        \\n        \\n        HashMap<String , data> map = new HashMap<String , data>();\\n        \\n        \\n        data temp;\\n        for (int i = 0 ; i < ids.length ; i++) {\\n            \\n            if (map.containsKey(creators[i])){\\n                 temp = map.get(creators[i]);\\n                 temp.count += views[i];\\n                \\n                if (views[i] > temp.highest) {\\n                    temp.highest = views[i];\\n                    temp.max_id = ids[i];\\n                    \\n                }else if(views[i] == temp.highest) {\\n                    \\n                    if (ids[i].compareTo(temp.max_id) < 0) {\\n                        temp.max_id = ids[i];\\n                    }\\n                    \\n                }\\n                map.put(creators[i] , temp);\\n                \\n            }else {\\n                \\n                temp = new data(views[i] , views[i] , ids[i]);\\n                map.put(creators[i] , temp);\\n            }\\n        }\\n        \\n        \\n        List<List<String>> result = new ArrayList<>();\\n        long max = Integer.MIN_VALUE;\\n     \\n        for (Map.Entry<String,data> entry : map.entrySet()) \\n            max = Math.max(entry.getValue().count , max);\\n        \\n        for (Map.Entry<String,data> entry : map.entrySet()) {\\n            if (entry.getValue().count == max ) {\\n                List<String> tempoo = new ArrayList<>();\\n                tempoo.add(entry.getKey());\\n                tempoo.add(entry.getValue().max_id);\\n                result.add(tempoo);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass data{\\n    long count ;\\n    int highest ;\\n    String max_id ;\\n    \\n    data(int cnt , int hi , String max) {\\n        this.count = cnt;\\n        this.highest = hi;\\n        this.max_id = max;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        \\n        \\n        HashMap<String , data> map = new HashMap<String , data>();\\n        \\n        \\n        data temp;\\n        for (int i = 0 ; i < ids.length ; i++) {\\n            \\n            if (map.containsKey(creators[i])){\\n                 temp = map.get(creators[i]);\\n                 temp.count += views[i];\\n                \\n                if (views[i] > temp.highest) {\\n                    temp.highest = views[i];\\n                    temp.max_id = ids[i];\\n                    \\n                }else if(views[i] == temp.highest) {\\n                    \\n                    if (ids[i].compareTo(temp.max_id) < 0) {\\n                        temp.max_id = ids[i];\\n                    }\\n                    \\n                }\\n                map.put(creators[i] , temp);\\n                \\n            }else {\\n                \\n                temp = new data(views[i] , views[i] , ids[i]);\\n                map.put(creators[i] , temp);\\n            }\\n        }\\n        \\n        \\n        List<List<String>> result = new ArrayList<>();\\n        long max = Integer.MIN_VALUE;\\n     \\n        for (Map.Entry<String,data> entry : map.entrySet()) \\n            max = Math.max(entry.getValue().count , max);\\n        \\n        for (Map.Entry<String,data> entry : map.entrySet()) {\\n            if (entry.getValue().count == max ) {\\n                List<String> tempoo = new ArrayList<>();\\n                tempoo.add(entry.getKey());\\n                tempoo.add(entry.getValue().max_id);\\n                result.add(tempoo);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877779,
                "title": "using-map",
                "content": "# Complexity\\n- Time complexity: $$O(2N)$$\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        var map = new HashMap<String, Data>();\\n        long maxViewCount = 0;\\n        for (int i=0; i<views.length; i++) {\\n            var data = map.getOrDefault(creators[i], new Data());\\n            maxViewCount = Math.max(data.add(ids[i], views[i]), maxViewCount);\\n            map.putIfAbsent(creators[i], data);\\n        }\\n        \\n        List<List<String>> result = new ArrayList<List<String>>();\\n        for (var entry : map.entrySet()) {\\n            if (entry.getValue().totalViewCount == maxViewCount) {\\n                result.add(List.of(entry.getKey(), entry.getValue().videoId));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\nclass Data {\\n    String videoId;\\n    long totalViewCount;\\n    int singleMax;\\n    \\n    public Data() {\\n        totalViewCount =  0;\\n        singleMax = 0;\\n        videoId = null;\\n    }\\n    \\n    public long add(String id, int viewCount) {\\n        if (singleMax < viewCount) {\\n            singleMax = viewCount;\\n            videoId = id;\\n        } else if (singleMax == viewCount && (videoId == null || videoId.compareTo(id) > 0)) {\\n            videoId = id;\\n        }\\n        totalViewCount += viewCount;\\n        return totalViewCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n        var map = new HashMap<String, Data>();\\n        long maxViewCount = 0;\\n        for (int i=0; i<views.length; i++) {\\n            var data = map.getOrDefault(creators[i], new Data());\\n            maxViewCount = Math.max(data.add(ids[i], views[i]), maxViewCount);\\n            map.putIfAbsent(creators[i], data);\\n        }\\n        \\n        List<List<String>> result = new ArrayList<List<String>>();\\n        for (var entry : map.entrySet()) {\\n            if (entry.getValue().totalViewCount == maxViewCount) {\\n                result.add(List.of(entry.getKey(), entry.getValue().videoId));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\nclass Data {\\n    String videoId;\\n    long totalViewCount;\\n    int singleMax;\\n    \\n    public Data() {\\n        totalViewCount =  0;\\n        singleMax = 0;\\n        videoId = null;\\n    }\\n    \\n    public long add(String id, int viewCount) {\\n        if (singleMax < viewCount) {\\n            singleMax = viewCount;\\n            videoId = id;\\n        } else if (singleMax == viewCount && (videoId == null || videoId.compareTo(id) > 0)) {\\n            videoId = id;\\n        }\\n        totalViewCount += viewCount;\\n        return totalViewCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871258,
                "title": "oop-solution-very-clear-beats-97-in-speed-and-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public class TwoValues{\\n        public long Item1;\\n        public string Item2;\\n        public int Item3;\\n\\n        public TwoValues(long i, string j, int k){\\n            Item1 = i;\\n            Item2 = j;\\n            Item3 = k;\\n        }\\n    }\\n    public IList<IList<string>> MostPopularCreator(string[] creators, string[] ids, int[] views) {\\n        var r = new List<IList<string>>();\\n        var hash = new Dictionary<string, TwoValues>();\\n        for(int i = 0; i < creators.Length; i++){\\n            string c = creators[i];\\n            if(hash.ContainsKey(c)){\\n                hash[c].Item1 += views[i];\\n                if(views[i] > hash[c].Item3 || (hash[c].Item3 == views[i]\\n                 && string.Compare(ids[i],hash[c].Item2) == -1)){\\n                    hash[c].Item2 = ids[i];\\n                    hash[c].Item3 = views[i];\\n                }\\n            }else{\\n                hash.Add(c, new TwoValues(views[i], ids[i], views[i]));\\n            }\\n        }\\n        long famous = hash.Values.Max(kv => kv.Item1);\\n        foreach(var kv in hash){\\n            if(kv.Value.Item1 == famous){\\n                r.Add(new List<string>{ kv.Key, kv.Value.Item2});\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public class TwoValues{\\n        public long Item1;\\n        public string Item2;\\n        public int Item3;\\n\\n        public TwoValues(long i, string j, int k){\\n            Item1 = i;\\n            Item2 = j;\\n            Item3 = k;\\n        }\\n    }\\n    public IList<IList<string>> MostPopularCreator(string[] creators, string[] ids, int[] views) {\\n        var r = new List<IList<string>>();\\n        var hash = new Dictionary<string, TwoValues>();\\n        for(int i = 0; i < creators.Length; i++){\\n            string c = creators[i];\\n            if(hash.ContainsKey(c)){\\n                hash[c].Item1 += views[i];\\n                if(views[i] > hash[c].Item3 || (hash[c].Item3 == views[i]\\n                 && string.Compare(ids[i],hash[c].Item2) == -1)){\\n                    hash[c].Item2 = ids[i];\\n                    hash[c].Item3 = views[i];\\n                }\\n            }else{\\n                hash.Add(c, new TwoValues(views[i], ids[i], views[i]));\\n            }\\n        }\\n        long famous = hash.Values.Max(kv => kv.Item1);\\n        foreach(var kv in hash){\\n            if(kv.Value.Item1 == famous){\\n                r.Add(new List<string>{ kv.Key, kv.Value.Item2});\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869109,
                "title": "c-75-faster-solution-easy-using-hashing",
                "content": "\\'\\'\\'\\nstatic bool comp( pair< int , string >a , pair< int , string >b )\\n    {\\n        if( a.first == b.first )\\n        {\\n            return a.second < b.second ;\\n        }\\n        \\n        return a.first > b.first ;\\n    }\\n    \\n    string solve( vector<pair< int , string >> v )\\n    {\\n        sort( v.begin() , v.end() , comp ) ;\\n        \\n        return v[0].second ;\\n    }\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        \\n        \\n        unordered_map< string , long long int >mp ;\\n        int n = ids.size() ;\\n        \\n        unordered_map< string , vector<pair<  int , string >>>mp2 ;\\n        \\n        for( int i = 0 ; i < n ; i++ )\\n        {\\n            mp[creators[i]] += views[i] ;\\n            \\n            mp2[creators[i]].push_back({ views[i] , ids[i]  }) ;\\n        }\\n        \\n        long long int mx = 0 ;\\n        \\n        for( auto i : mp )\\n        {\\n            mx = max( mx , i.second ) ;\\n        }\\n        \\n        \\n        vector<vector<string>>ans ;\\n        \\n        for( auto i : mp )\\n        {\\n            if( i.second == mx )\\n            {\\n                string temp = i.first ;\\n                string s = solve( mp2[temp] ) ;\\n                ans.push_back( { temp , s }) ;\\n            }\\n        }\\n        \\n        \\n        return ans ;\\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nstatic bool comp( pair< int , string >a , pair< int , string >b )\\n    {\\n        if( a.first == b.first )\\n        {\\n            return a.second < b.second ;\\n        }\\n        \\n        return a.first > b.first ;\\n    }\\n    \\n    string solve( vector<pair< int , string >> v )\\n    {\\n        sort( v.begin() , v.end() , comp ) ;\\n        \\n        return v[0].second ;\\n    }\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        \\n        \\n        unordered_map< string , long long int >mp ;\\n        int n = ids.size() ;\\n        \\n        unordered_map< string , vector<pair<  int , string >>>mp2 ;\\n        \\n        for( int i = 0 ; i < n ; i++ )\\n        {\\n            mp[creators[i]] += views[i] ;\\n            \\n            mp2[creators[i]].push_back({ views[i] , ids[i]  }) ;\\n        }\\n        \\n        long long int mx = 0 ;\\n        \\n        for( auto i : mp )\\n        {\\n            mx = max( mx , i.second ) ;\\n        }\\n        \\n        \\n        vector<vector<string>>ans ;\\n        \\n        for( auto i : mp )\\n        {\\n            if( i.second == mx )\\n            {\\n                string temp = i.first ;\\n                string s = solve( mp2[temp] ) ;\\n                ans.push_back( { temp , s }) ;\\n            }\\n        }\\n        \\n        \\n        return ans ;\\n    }\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2848560,
                "title": "simple-hashmap-solution-js",
                "content": "```\\n/**\\n * @param {string[]} creators\\n * @param {string[]} ids\\n * @param {number[]} views\\n * @return {string[][]}\\n */\\nvar mostPopularCreator = function(creators, ids, views) {\\n    dict = {}\\n    let maxViews = 0;\\n    let mostPopularCreators = [];\\n    let mostViewedVideos = [];\\n    for (let i = 0; i < creators.length; i++) {\\n        let name = creators[i]\\n        \\n        if (dict[name] === undefined) {    \\n            dict[name] = {\\n                totalViews: views[i],\\n                mostViewed: views[i],\\n                mostPopular: ids[i]\\n            };\\n        } else {\\n            dict[name].totalViews += views[i];\\n            if (views[i] > dict[name].mostViewed) {\\n                dict[name].mostPopular = ids[i]\\n            } else if (views[i] == dict[name].mostViewed) {\\n                console.log([dict[name].mostPopular, ids[i]].sort())\\n                dict[name].mostPopular = [dict[name].mostPopular, ids[i]].sort()[0]\\n            }\\n            dict[name].mostViewed = [Math.max(dict[name].mostViewed, views[i])]\\n        }\\n        maxViews = Math.max(dict[name].totalViews, maxViews);\\n    }\\n\\n    for (let name in dict) {\\n        if (dict[name].totalViews === maxViews) {\\n            mostPopularCreators.push(name);\\n            mostViewedVideos.push(dict[name].mostPopular)\\n        }\\n    }\\n\\n    let result = [];\\n    for (let i = 0; i < mostPopularCreators.length; i++) {\\n        result.push([mostPopularCreators[i], mostViewedVideos[i]])\\n    }\\n    return result;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} creators\\n * @param {string[]} ids\\n * @param {number[]} views\\n * @return {string[][]}\\n */\\nvar mostPopularCreator = function(creators, ids, views) {\\n    dict = {}\\n    let maxViews = 0;\\n    let mostPopularCreators = [];\\n    let mostViewedVideos = [];\\n    for (let i = 0; i < creators.length; i++) {\\n        let name = creators[i]\\n        \\n        if (dict[name] === undefined) {    \\n            dict[name] = {\\n                totalViews: views[i],\\n                mostViewed: views[i],\\n                mostPopular: ids[i]\\n            };\\n        } else {\\n            dict[name].totalViews += views[i];\\n            if (views[i] > dict[name].mostViewed) {\\n                dict[name].mostPopular = ids[i]\\n            } else if (views[i] == dict[name].mostViewed) {\\n                console.log([dict[name].mostPopular, ids[i]].sort())\\n                dict[name].mostPopular = [dict[name].mostPopular, ids[i]].sort()[0]\\n            }\\n            dict[name].mostViewed = [Math.max(dict[name].mostViewed, views[i])]\\n        }\\n        maxViews = Math.max(dict[name].totalViews, maxViews);\\n    }\\n\\n    for (let name in dict) {\\n        if (dict[name].totalViews === maxViews) {\\n            mostPopularCreators.push(name);\\n            mostViewedVideos.push(dict[name].mostPopular)\\n        }\\n    }\\n\\n    let result = [];\\n    for (let i = 0; i < mostPopularCreators.length; i++) {\\n        result.push([mostPopularCreators[i], mostViewedVideos[i]])\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2842036,
                "title": "python3-linear-hashmap-with-multiple-elements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe should use a hashmap as the information we are looking for is per creator, so this name should be a key in our structure.\\n\\nWe search for two things in parallel:\\n1) The amount of views per creator\\n2) the highest viewed video per creator\\n\\nOnce we have this information we can look for the highest viewed creator and attach their highest viewed video\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn order to solve the problem, we can use a defaultdict, which saves accumulated viewer count and the id of the highest viewed video. AS ids are unique we also need to compare the id in order to get the lexicographically lowest.\\n\\nIn a second pass through all the unique creators, we keep track of the maximum view count and append or clear to a list if we found a content creator with a similar or higher count.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N+K), where N is the amount of videos and K is the amount of creators\\n- Space complexity:\\nO(K) as we need to save information abot all creators\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n\\n        # make a dict to save the viwer count and the highest view count\\n        counter = collections.defaultdict(lambda: [0, \"\", -1])\\n\\n        # go through the content creators\\n        for creator, idd, view in zip(creators, ids, views):\\n\\n            # get the list with informations\\n            infos = counter[creator] \\n\\n            # increase the view\\n            infos[0] += view\\n\\n            # check if the video is the most viewed\\n            if view > infos[2] or (view == infos[2] and infos[1] > idd):\\n                infos[2] = view\\n                infos[1] = idd\\n        \\n        # go through the creators and keep the highes\\n        result = []\\n        max_count = -1\\n        for creator, infos in counter.items():\\n\\n            # check if we are higher or equal to current count\\n            if max_count <= infos[0]:\\n\\n                # check if we are higher than current max\\n                if max_count < infos[0]:\\n                    # clear the list\\n                    result.clear()\\n                    # update the max count\\n                    max_count = infos[0]\\n                \\n                # append our current content creator\\n                result.append([creator, infos[1]])\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n\\n        # make a dict to save the viwer count and the highest view count\\n        counter = collections.defaultdict(lambda: [0, \"\", -1])\\n\\n        # go through the content creators\\n        for creator, idd, view in zip(creators, ids, views):\\n\\n            # get the list with informations\\n            infos = counter[creator] \\n\\n            # increase the view\\n            infos[0] += view\\n\\n            # check if the video is the most viewed\\n            if view > infos[2] or (view == infos[2] and infos[1] > idd):\\n                infos[2] = view\\n                infos[1] = idd\\n        \\n        # go through the creators and keep the highes\\n        result = []\\n        max_count = -1\\n        for creator, infos in counter.items():\\n\\n            # check if we are higher or equal to current count\\n            if max_count <= infos[0]:\\n\\n                # check if we are higher than current max\\n                if max_count < infos[0]:\\n                    # clear the list\\n                    result.clear()\\n                    # update the max count\\n                    max_count = infos[0]\\n                \\n                # append our current content creator\\n                result.append([creator, infos[1]])\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841104,
                "title": "python-dictionary-beats-96-of-answers",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        \"\"\"\\n        summary : each creator will get to be a key in a  dictionary that contains\\n        the 1st item the sum of all the views so far\\n        the 2nd the id(in case if the value of max seen is the same the smallest one lexicographically)\\n        the 3rd item the maxviews so far\\n\\n        when we have all this data we look for the biggest sum and append the name of the creator and the id\\n        to the ans list\\n        \"\"\"\\n        data = {}\\n        for creator, id , view in zip(creators, ids, views):\\n            if creator in data:\\n                data[creator][0] += view\\n                if  view>data[creator][2]:\\n                    data[creator][2] = view\\n                    data[creator][1] = id\\n                    continue\\n                if  view==data[creator][2] and id< data[creator][1]:\\n                    data[creator][1] = id\\n                    continue\\n            else:\\n                data[creator] = [view,id,view]\\n        maxView = 0\\n        ans = []\\n        for k,v in data.items():\\n            if v[0]>maxView:\\n                ans =[]\\n                maxView =v[0]\\n            if v[0]==maxView:\\n                ans.append([k,v[1]])\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        \"\"\"\\n        summary : each creator will get to be a key in a  dictionary that contains\\n        the 1st item the sum of all the views so far\\n        the 2nd the id(in case if the value of max seen is the same the smallest one lexicographically)\\n        the 3rd item the maxviews so far\\n\\n        when we have all this data we look for the biggest sum and append the name of the creator and the id\\n        to the ans list\\n        \"\"\"\\n        data = {}\\n        for creator, id , view in zip(creators, ids, views):\\n            if creator in data:\\n                data[creator][0] += view\\n                if  view>data[creator][2]:\\n                    data[creator][2] = view\\n                    data[creator][1] = id\\n                    continue\\n                if  view==data[creator][2] and id< data[creator][1]:\\n                    data[creator][1] = id\\n                    continue\\n            else:\\n                data[creator] = [view,id,view]\\n        maxView = 0\\n        ans = []\\n        for k,v in data.items():\\n            if v[0]>maxView:\\n                ans =[]\\n                maxView =v[0]\\n            if v[0]==maxView:\\n                ans.append([k,v[1]])\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834488,
                "title": "c-efficient-hash-map-using-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        //             creator name          sum       maxV, name of maxV\\n        unordered_map<string, pair<long, pair<int, string>>> a;\\n        long maxPop = 0;\\n        for (int i = 0; i < creators.size(); ++i){\\n            a[creators[i]].first += views[i];\\n            maxPop = max(maxPop, a[creators[i]].first);\\n            if (views[i] > a[creators[i]].second.first || a[creators[i]].second.first == 0){\\n                a[creators[i]].second.first = views[i];\\n                a[creators[i]].second.second = ids[i];\\n            }\\n            else if (views[i] == a[creators[i]].second.first &&\\n                    ids[i] < a[creators[i]].second.second){\\n                a[creators[i]].second.second = ids[i];\\n            }\\n        }\\n        vector<vector<string>> ans;\\n        for (auto& [f,s] : a){\\n            if (s.first == maxPop){\\n                ans.push_back({f, s.second.second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        //             creator name          sum       maxV, name of maxV\\n        unordered_map<string, pair<long, pair<int, string>>> a;\\n        long maxPop = 0;\\n        for (int i = 0; i < creators.size(); ++i){\\n            a[creators[i]].first += views[i];\\n            maxPop = max(maxPop, a[creators[i]].first);\\n            if (views[i] > a[creators[i]].second.first || a[creators[i]].second.first == 0){\\n                a[creators[i]].second.first = views[i];\\n                a[creators[i]].second.second = ids[i];\\n            }\\n            else if (views[i] == a[creators[i]].second.first &&\\n                    ids[i] < a[creators[i]].second.second){\\n                a[creators[i]].second.second = ids[i];\\n            }\\n        }\\n        vector<vector<string>> ans;\\n        for (auto& [f,s] : a){\\n            if (s.first == maxPop){\\n                ans.push_back({f, s.second.second});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824988,
                "title": "java-easiest-solution-using-custom-class-and-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass view{\\nString idname;\\nint views;\\nview(String idname,int views){\\n    this.idname=idname;\\n    this.views=views;\\n}\\n}\\n\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n    \\n    ArrayList<List<String>>ans=new ArrayList<>();\\n\\n    HashMap<String,Long>mp=new HashMap<>();\\n\\n    HashMap<String,PriorityQueue<view>>hp=new HashMap<>();\\n\\n    long maxi=(long)-1;\\n\\n    for(int i=0;i<creators.length;i++){\\n    \\n    mp.put(creators[i],mp.getOrDefault(creators[i],(long)0)+(long)views[i]);\\n\\n    maxi=Math.max(mp.get(creators[i]),maxi);\\n\\n    if(!hp.containsKey(creators[i])){\\n        hp.put(creators[i],new PriorityQueue<view>((view a,view b)->\\n        a.views==b.views?a.idname.compareTo(b.idname):b.views-a.views));\\n    }\\n    \\n\\n    view curr=new view(ids[i],views[i]);\\n\\n    hp.get(creators[i]).add(curr);\\n\\n    }\\n\\n    for(String a:mp.keySet()){\\n\\n    ArrayList<String>arr=new ArrayList<>();\\n\\n    if(mp.get(a)==maxi){\\n\\n    arr.add(a);\\n\\n    arr.add(hp.get(a).peek().idname);\\n\\n    }\\n    if(arr.size()>0)\\n    ans.add(arr);\\n\\n    }\\n\\n    return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass view{\\nString idname;\\nint views;\\nview(String idname,int views){\\n    this.idname=idname;\\n    this.views=views;\\n}\\n}\\n\\nclass Solution {\\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\\n    \\n    ArrayList<List<String>>ans=new ArrayList<>();\\n\\n    HashMap<String,Long>mp=new HashMap<>();\\n\\n    HashMap<String,PriorityQueue<view>>hp=new HashMap<>();\\n\\n    long maxi=(long)-1;\\n\\n    for(int i=0;i<creators.length;i++){\\n    \\n    mp.put(creators[i],mp.getOrDefault(creators[i],(long)0)+(long)views[i]);\\n\\n    maxi=Math.max(mp.get(creators[i]),maxi);\\n\\n    if(!hp.containsKey(creators[i])){\\n        hp.put(creators[i],new PriorityQueue<view>((view a,view b)->\\n        a.views==b.views?a.idname.compareTo(b.idname):b.views-a.views));\\n    }\\n    \\n\\n    view curr=new view(ids[i],views[i]);\\n\\n    hp.get(creators[i]).add(curr);\\n\\n    }\\n\\n    for(String a:mp.keySet()){\\n\\n    ArrayList<String>arr=new ArrayList<>();\\n\\n    if(mp.get(a)==maxi){\\n\\n    arr.add(a);\\n\\n    arr.add(hp.get(a).peek().idname);\\n\\n    }\\n    if(arr.size()>0)\\n    ans.add(arr);\\n\\n    }\\n\\n    return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824294,
                "title": "simple-efficient-and-fast-hashing-in-python",
                "content": "# Intuition\\nStoring the data in a dictionary using lists while keeping track of the highest view count.\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        d = {}\\n        max_views = 0\\n\\n        for creator, view, id in zip(creators, views, ids):\\n            # views, max viewed, id\\n            if creator not in d:\\n                d[creator] = [0, view, id]  \\n            elif view == d[creator][1]:\\n                d[creator][2] = id if id < d[creator][2] else d[creator][2]\\n            elif view > d[creator][1]:\\n                d[creator][1] = view\\n                d[creator][2] = id\\n            \\n            d[creator][0] += view\\n            if d[creator][0] > max_views:\\n                max_views = d[creator][0]\\n        \\n        res = []\\n        for k, v in d.items():\\n            if v[0] == max_views:\\n                res.append([k, v[2]])\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\\n        d = {}\\n        max_views = 0\\n\\n        for creator, view, id in zip(creators, views, ids):\\n            # views, max viewed, id\\n            if creator not in d:\\n                d[creator] = [0, view, id]  \\n            elif view == d[creator][1]:\\n                d[creator][2] = id if id < d[creator][2] else d[creator][2]\\n            elif view > d[creator][1]:\\n                d[creator][1] = view\\n                d[creator][2] = id\\n            \\n            d[creator][0] += view\\n            if d[creator][0] > max_views:\\n                max_views = d[creator][0]\\n        \\n        res = []\\n        for k, v in d.items():\\n            if v[0] == max_views:\\n                res.append([k, v[2]])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823876,
                "title": "java-hashmap-priorityqueue-sorting-stream-objects",
                "content": "```\\nclass Solution {\\n    \\n    class Vedio{\\n        String id;\\n        int viewCount;\\n        public Vedio(String id, int viewCount){\\n            this.id = id;\\n            this.viewCount = viewCount;\\n        }\\n    }\\n    \\n    class Data{\\n        String creator;\\n        int popularity;\\n        PriorityQueue<Vedio> vedios;\\n        public Data(String creator){\\n            this.creator = creator;\\n            this.popularity = 0;\\n            vedios = new PriorityQueue<>((a, b) -> a.viewCount == b.viewCount\\n                                        ? a.id.compareTo(b.id)\\n                                        : b.viewCount - a.viewCount);\\n        }\\n    }\\n    \\n    public List<List<String>> mostPopularCreator(\\n        String[] creators, String[] ids, int[] views) {\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        \\n        int n = creators.length;\\n        Map<String, Data> map = new HashMap<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            String creator = creators[i];\\n            String id = ids[i];\\n            int view = views[i];\\n            \\n            if(map.containsKey(creator)){\\n                map.get(creator).popularity += view;\\n                map.get(creator).vedios.add(new Vedio(id, view));\\n            } else {\\n                Data data = new Data(creator);\\n                data.popularity = view;\\n                data.vedios.add(new Vedio(id, view));\\n                map.put(creator, data);\\n            }\\n        }\\n        \\n        List<Data> data = new ArrayList<>(map.values());\\n        Collections.sort(data, (a, b) -> b.popularity == a.popularity\\n                        ? a.creator.compareTo(b.creator)\\n                        : b.popularity - a.popularity);\\n        \\n        int mostPopularCount = data.get(0).popularity;\\n        \\n        data = data.stream()\\n            .filter((d) -> d.popularity == mostPopularCount)\\n            .collect(Collectors.toList());\\n        \\n        for(Data currData : data){\\n            result.add(Arrays.asList(currData.creator,\\n                                     currData.vedios.peek().id));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Vedio{\\n        String id;\\n        int viewCount;\\n        public Vedio(String id, int viewCount){\\n            this.id = id;\\n            this.viewCount = viewCount;\\n        }\\n    }\\n    \\n    class Data{\\n        String creator;\\n        int popularity;\\n        PriorityQueue<Vedio> vedios;\\n        public Data(String creator){\\n            this.creator = creator;\\n            this.popularity = 0;\\n            vedios = new PriorityQueue<>((a, b) -> a.viewCount == b.viewCount\\n                                        ? a.id.compareTo(b.id)\\n                                        : b.viewCount - a.viewCount);\\n        }\\n    }\\n    \\n    public List<List<String>> mostPopularCreator(\\n        String[] creators, String[] ids, int[] views) {\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        \\n        int n = creators.length;\\n        Map<String, Data> map = new HashMap<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            String creator = creators[i];\\n            String id = ids[i];\\n            int view = views[i];\\n            \\n            if(map.containsKey(creator)){\\n                map.get(creator).popularity += view;\\n                map.get(creator).vedios.add(new Vedio(id, view));\\n            } else {\\n                Data data = new Data(creator);\\n                data.popularity = view;\\n                data.vedios.add(new Vedio(id, view));\\n                map.put(creator, data);\\n            }\\n        }\\n        \\n        List<Data> data = new ArrayList<>(map.values());\\n        Collections.sort(data, (a, b) -> b.popularity == a.popularity\\n                        ? a.creator.compareTo(b.creator)\\n                        : b.popularity - a.popularity);\\n        \\n        int mostPopularCount = data.get(0).popularity;\\n        \\n        data = data.stream()\\n            .filter((d) -> d.popularity == mostPopularCount)\\n            .collect(Collectors.toList());\\n        \\n        for(Data currData : data){\\n            result.add(Arrays.asList(currData.creator,\\n                                     currData.vedios.peek().id));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822068,
                "title": "c-unordered-map",
                "content": "For each creator, maintain the total view count and the smallest id with the highest view count.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, vector<long long>> map;\\n        int len = creators.size();\\n        long long ma = 0;\\n        for (int i = 0; i < len; ++i) {\\n            string creator = creators[i];\\n            string id = ids[i];\\n            int view = views[i];\\n            if (!map.count(creator)) {\\n                map[creator] = {0, i};\\n            }\\n            map[creator][0] += view;\\n            if (views[map[creator][1]] < view || (views[map[creator][1]] == view && ids[map[creator][1]] > id)) {\\n                // cout << i << endl;\\n                map[creator][1] = i;\\n            }\\n            ma = max(ma, map[creator][0]);\\n        }\\n        vector<vector<string>> result;\\n        for (auto [key, value] : map) {\\n            if (value[0] == ma) {\\n                result.push_back({key, ids[value[1]]});\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\\n        unordered_map<string, vector<long long>> map;\\n        int len = creators.size();\\n        long long ma = 0;\\n        for (int i = 0; i < len; ++i) {\\n            string creator = creators[i];\\n            string id = ids[i];\\n            int view = views[i];\\n            if (!map.count(creator)) {\\n                map[creator] = {0, i};\\n            }\\n            map[creator][0] += view;\\n            if (views[map[creator][1]] < view || (views[map[creator][1]] == view && ids[map[creator][1]] > id)) {\\n                // cout << i << endl;\\n                map[creator][1] = i;\\n            }\\n            ma = max(ma, map[creator][0]);\\n        }\\n        vector<vector<string>> result;\\n        for (auto [key, value] : map) {\\n            if (value[0] == ma) {\\n                result.push_back({key, ids[value[1]]});\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1666064,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "Even though \"id\" stands for identity, the `id[i]` of a video is not its identity. Instead, the identity of a video is its index `i` and multiple distinct videos by the same creator can share the same id.\\n\\nPoor question design/description that just wastes time without teaching any valuable programming concepts."
                    },
                    {
                        "username": "celticrocks",
                        "content": "I ran the second testcase, the result I got for my solution is\n`\nOutput\n[[\"alice\",\"a\"]]\nExpected\n[[\"alice\",\"b\"]]\n`\n\nBut I ran my solution in IDE and it returned exactly same as expected answer. Any idea what cause this discrepancy?\n\nMy solution:\n \n    \n    public static void main(String[] args) {\n        Solution sol1 = new Solution();\n\n        String[] creators = {\"alice\",\"alice\",\"alice\"};\n        String[] ids = {\"a\",\"b\",\"c\"};\n        int[] views = {1,2,2};\n        System.out.println(sol1.mostPopularCreator(creators, ids, views ));\n    }\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\n        Map<String, Integer> creatorMap = new HashMap<>();\n        int n = ids.length;\n        for(int i = 0; i < n; i++) {\n            int curCreatorView = views[i];\n            if(creatorMap.containsKey(creators[i])) {\n                curCreatorView += creatorMap.get(creators[i]);\n            }\n            creatorMap.put(creators[i], curCreatorView);\n        }\n        List<String> creatorList = new ArrayList<>();\n        List<List<String>> res = new ArrayList<>();\n        int maxViews = 0;\n        for(Map.Entry<String, Integer> entry : creatorMap.entrySet()) {\n            if(entry.getValue() > maxViews) {\n                maxViews = entry.getValue();\n                creatorList.clear();\n                creatorList.add(entry.getKey());\n            } else if(entry.getValue() == maxViews) {\n                creatorList.add(entry.getKey());\n            }\n        }\n        for(String creator : creatorList) {\n            List<String> resList = new ArrayList<>();\n            int curMax = 0;\n            String maxId = null;\n            for(int i = 0; i < n; i++) {\n                if(creators[i] == creator) {\n                    if(views[i] > curMax) {\n                        curMax = views[i];\n                        maxId = ids[i];\n                    } else if(views[i] == curMax) {\n                        if(maxId.compareTo(ids[i]) == 1) {\n                            maxId = ids[i];\n                        }\n                    }\n                }\n            }\n            resList.add(creator);\n            resList.add(maxId);\n            res.add(resList);\n        }\n        return res;\n    }\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I am unhappy with author because he could put proper description. I had created this problem and asked him in interview."
                    },
                    {
                        "username": "Anos",
                        "content": "I have declared a hashmap to collect the following values,\\n\\ntotal number current views for the creator\\nstore the lexicographic id of the creator\\'s popular video\\ncurrent popular view of the creator\\nSo my final hashmap for the given basic test case looks like {\\'alice\\': [10, \\'one\\', 5], \\'bob\\': [10, \\'two\\', 10], \\'chris\\': [4, \\'four\\', 4]}\\nmemo[\"alice\"][0] = total number of views for alice\\nmemo[\"alice\"][1] = min lexicographic id for alice\\'s popular video\\nmemo[\"alice\"][2] = max popular video views for alice\\n\\nAlongside with these, I have also initiated overall_max_popular_video_count to track the max_total_number_of_views for a creator\\nOnce we collect all the above mentioned values,\\nI compare each and every creator\\'s total number of views with the current_popular_video_count and make my result array.\\nThanks for reading!"
                    }
                ]
            },
            {
                "id": 1664116,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "Even though \"id\" stands for identity, the `id[i]` of a video is not its identity. Instead, the identity of a video is its index `i` and multiple distinct videos by the same creator can share the same id.\\n\\nPoor question design/description that just wastes time without teaching any valuable programming concepts."
                    },
                    {
                        "username": "celticrocks",
                        "content": "I ran the second testcase, the result I got for my solution is\n`\nOutput\n[[\"alice\",\"a\"]]\nExpected\n[[\"alice\",\"b\"]]\n`\n\nBut I ran my solution in IDE and it returned exactly same as expected answer. Any idea what cause this discrepancy?\n\nMy solution:\n \n    \n    public static void main(String[] args) {\n        Solution sol1 = new Solution();\n\n        String[] creators = {\"alice\",\"alice\",\"alice\"};\n        String[] ids = {\"a\",\"b\",\"c\"};\n        int[] views = {1,2,2};\n        System.out.println(sol1.mostPopularCreator(creators, ids, views ));\n    }\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\n        Map<String, Integer> creatorMap = new HashMap<>();\n        int n = ids.length;\n        for(int i = 0; i < n; i++) {\n            int curCreatorView = views[i];\n            if(creatorMap.containsKey(creators[i])) {\n                curCreatorView += creatorMap.get(creators[i]);\n            }\n            creatorMap.put(creators[i], curCreatorView);\n        }\n        List<String> creatorList = new ArrayList<>();\n        List<List<String>> res = new ArrayList<>();\n        int maxViews = 0;\n        for(Map.Entry<String, Integer> entry : creatorMap.entrySet()) {\n            if(entry.getValue() > maxViews) {\n                maxViews = entry.getValue();\n                creatorList.clear();\n                creatorList.add(entry.getKey());\n            } else if(entry.getValue() == maxViews) {\n                creatorList.add(entry.getKey());\n            }\n        }\n        for(String creator : creatorList) {\n            List<String> resList = new ArrayList<>();\n            int curMax = 0;\n            String maxId = null;\n            for(int i = 0; i < n; i++) {\n                if(creators[i] == creator) {\n                    if(views[i] > curMax) {\n                        curMax = views[i];\n                        maxId = ids[i];\n                    } else if(views[i] == curMax) {\n                        if(maxId.compareTo(ids[i]) == 1) {\n                            maxId = ids[i];\n                        }\n                    }\n                }\n            }\n            resList.add(creator);\n            resList.add(maxId);\n            res.add(resList);\n        }\n        return res;\n    }\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I am unhappy with author because he could put proper description. I had created this problem and asked him in interview."
                    },
                    {
                        "username": "Anos",
                        "content": "I have declared a hashmap to collect the following values,\\n\\ntotal number current views for the creator\\nstore the lexicographic id of the creator\\'s popular video\\ncurrent popular view of the creator\\nSo my final hashmap for the given basic test case looks like {\\'alice\\': [10, \\'one\\', 5], \\'bob\\': [10, \\'two\\', 10], \\'chris\\': [4, \\'four\\', 4]}\\nmemo[\"alice\"][0] = total number of views for alice\\nmemo[\"alice\"][1] = min lexicographic id for alice\\'s popular video\\nmemo[\"alice\"][2] = max popular video views for alice\\n\\nAlongside with these, I have also initiated overall_max_popular_video_count to track the max_total_number_of_views for a creator\\nOnce we collect all the above mentioned values,\\nI compare each and every creator\\'s total number of views with the current_popular_video_count and make my result array.\\nThanks for reading!"
                    }
                ]
            },
            {
                "id": 1770764,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "Even though \"id\" stands for identity, the `id[i]` of a video is not its identity. Instead, the identity of a video is its index `i` and multiple distinct videos by the same creator can share the same id.\\n\\nPoor question design/description that just wastes time without teaching any valuable programming concepts."
                    },
                    {
                        "username": "celticrocks",
                        "content": "I ran the second testcase, the result I got for my solution is\n`\nOutput\n[[\"alice\",\"a\"]]\nExpected\n[[\"alice\",\"b\"]]\n`\n\nBut I ran my solution in IDE and it returned exactly same as expected answer. Any idea what cause this discrepancy?\n\nMy solution:\n \n    \n    public static void main(String[] args) {\n        Solution sol1 = new Solution();\n\n        String[] creators = {\"alice\",\"alice\",\"alice\"};\n        String[] ids = {\"a\",\"b\",\"c\"};\n        int[] views = {1,2,2};\n        System.out.println(sol1.mostPopularCreator(creators, ids, views ));\n    }\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\n        Map<String, Integer> creatorMap = new HashMap<>();\n        int n = ids.length;\n        for(int i = 0; i < n; i++) {\n            int curCreatorView = views[i];\n            if(creatorMap.containsKey(creators[i])) {\n                curCreatorView += creatorMap.get(creators[i]);\n            }\n            creatorMap.put(creators[i], curCreatorView);\n        }\n        List<String> creatorList = new ArrayList<>();\n        List<List<String>> res = new ArrayList<>();\n        int maxViews = 0;\n        for(Map.Entry<String, Integer> entry : creatorMap.entrySet()) {\n            if(entry.getValue() > maxViews) {\n                maxViews = entry.getValue();\n                creatorList.clear();\n                creatorList.add(entry.getKey());\n            } else if(entry.getValue() == maxViews) {\n                creatorList.add(entry.getKey());\n            }\n        }\n        for(String creator : creatorList) {\n            List<String> resList = new ArrayList<>();\n            int curMax = 0;\n            String maxId = null;\n            for(int i = 0; i < n; i++) {\n                if(creators[i] == creator) {\n                    if(views[i] > curMax) {\n                        curMax = views[i];\n                        maxId = ids[i];\n                    } else if(views[i] == curMax) {\n                        if(maxId.compareTo(ids[i]) == 1) {\n                            maxId = ids[i];\n                        }\n                    }\n                }\n            }\n            resList.add(creator);\n            resList.add(maxId);\n            res.add(resList);\n        }\n        return res;\n    }\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I am unhappy with author because he could put proper description. I had created this problem and asked him in interview."
                    },
                    {
                        "username": "Anos",
                        "content": "I have declared a hashmap to collect the following values,\\n\\ntotal number current views for the creator\\nstore the lexicographic id of the creator\\'s popular video\\ncurrent popular view of the creator\\nSo my final hashmap for the given basic test case looks like {\\'alice\\': [10, \\'one\\', 5], \\'bob\\': [10, \\'two\\', 10], \\'chris\\': [4, \\'four\\', 4]}\\nmemo[\"alice\"][0] = total number of views for alice\\nmemo[\"alice\"][1] = min lexicographic id for alice\\'s popular video\\nmemo[\"alice\"][2] = max popular video views for alice\\n\\nAlongside with these, I have also initiated overall_max_popular_video_count to track the max_total_number_of_views for a creator\\nOnce we collect all the above mentioned values,\\nI compare each and every creator\\'s total number of views with the current_popular_video_count and make my result array.\\nThanks for reading!"
                    }
                ]
            },
            {
                "id": 1672338,
                "content": [
                    {
                        "username": "jeffcamera",
                        "content": "Even though \"id\" stands for identity, the `id[i]` of a video is not its identity. Instead, the identity of a video is its index `i` and multiple distinct videos by the same creator can share the same id.\\n\\nPoor question design/description that just wastes time without teaching any valuable programming concepts."
                    },
                    {
                        "username": "celticrocks",
                        "content": "I ran the second testcase, the result I got for my solution is\n`\nOutput\n[[\"alice\",\"a\"]]\nExpected\n[[\"alice\",\"b\"]]\n`\n\nBut I ran my solution in IDE and it returned exactly same as expected answer. Any idea what cause this discrepancy?\n\nMy solution:\n \n    \n    public static void main(String[] args) {\n        Solution sol1 = new Solution();\n\n        String[] creators = {\"alice\",\"alice\",\"alice\"};\n        String[] ids = {\"a\",\"b\",\"c\"};\n        int[] views = {1,2,2};\n        System.out.println(sol1.mostPopularCreator(creators, ids, views ));\n    }\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\n        Map<String, Integer> creatorMap = new HashMap<>();\n        int n = ids.length;\n        for(int i = 0; i < n; i++) {\n            int curCreatorView = views[i];\n            if(creatorMap.containsKey(creators[i])) {\n                curCreatorView += creatorMap.get(creators[i]);\n            }\n            creatorMap.put(creators[i], curCreatorView);\n        }\n        List<String> creatorList = new ArrayList<>();\n        List<List<String>> res = new ArrayList<>();\n        int maxViews = 0;\n        for(Map.Entry<String, Integer> entry : creatorMap.entrySet()) {\n            if(entry.getValue() > maxViews) {\n                maxViews = entry.getValue();\n                creatorList.clear();\n                creatorList.add(entry.getKey());\n            } else if(entry.getValue() == maxViews) {\n                creatorList.add(entry.getKey());\n            }\n        }\n        for(String creator : creatorList) {\n            List<String> resList = new ArrayList<>();\n            int curMax = 0;\n            String maxId = null;\n            for(int i = 0; i < n; i++) {\n                if(creators[i] == creator) {\n                    if(views[i] > curMax) {\n                        curMax = views[i];\n                        maxId = ids[i];\n                    } else if(views[i] == curMax) {\n                        if(maxId.compareTo(ids[i]) == 1) {\n                            maxId = ids[i];\n                        }\n                    }\n                }\n            }\n            resList.add(creator);\n            resList.add(maxId);\n            res.add(resList);\n        }\n        return res;\n    }\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I am unhappy with author because he could put proper description. I had created this problem and asked him in interview."
                    },
                    {
                        "username": "Anos",
                        "content": "I have declared a hashmap to collect the following values,\\n\\ntotal number current views for the creator\\nstore the lexicographic id of the creator\\'s popular video\\ncurrent popular view of the creator\\nSo my final hashmap for the given basic test case looks like {\\'alice\\': [10, \\'one\\', 5], \\'bob\\': [10, \\'two\\', 10], \\'chris\\': [4, \\'four\\', 4]}\\nmemo[\"alice\"][0] = total number of views for alice\\nmemo[\"alice\"][1] = min lexicographic id for alice\\'s popular video\\nmemo[\"alice\"][2] = max popular video views for alice\\n\\nAlongside with these, I have also initiated overall_max_popular_video_count to track the max_total_number_of_views for a creator\\nOnce we collect all the above mentioned values,\\nI compare each and every creator\\'s total number of views with the current_popular_video_count and make my result array.\\nThanks for reading!"
                    }
                ]
            }
        ]
    }
]