[
    {
        "title": "Group Sold Products By The Date",
        "question_content": "Table Activities:\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| sell_date   | date    |\n| product     | varchar |\n+-------------+---------+\nThere is no primary key (column with unique values) for this table. It may contain duplicates.\nEach row of this table contains the product name and the date it was sold in a market.\n\n&nbsp;\nWrite a solution to find for each date the number of different products sold and their names.\nThe sold products names for each date should be sorted lexicographically.\nReturn the result table ordered by sell_date.\nThe&nbsp;result format is in the following example.\n&nbsp;\nExample 1:\n\nInput: \nActivities table:\n+------------+------------+\n| sell_date  | product     |\n+------------+------------+\n| 2020-05-30 | Headphone  |\n| 2020-06-01 | Pencil     |\n| 2020-06-02 | Mask       |\n| 2020-05-30 | Basketball |\n| 2020-06-01 | Bible      |\n| 2020-06-02 | Mask       |\n| 2020-05-30 | T-Shirt    |\n+------------+------------+\nOutput: \n+------------+----------+------------------------------+\n| sell_date  | num_sold | products                     |\n+------------+----------+------------------------------+\n| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |\n| 2020-06-01 | 2        | Bible,Pencil                 |\n| 2020-06-02 | 1        | Mask                         |\n+------------+----------+------------------------------+\nExplanation: \nFor 2020-05-30, Sold items were (Headphone, Basketball, T-shirt), we sort them lexicographically and separate them by a comma.\nFor 2020-06-01, Sold items were (Pencil, Bible), we sort them lexicographically and separate them by a comma.\nFor 2020-06-02, the Sold item is (Mask), we just return it.",
        "solutions": [
            {
                "id": 2139850,
                "title": "simple-explanation-easy",
                "content": "**<<<< Please Press upvote Button !!!!!**\\n\\nAlmost immediately detected, the only serious challange of this problem is how to aggregate the product names in one cell. In MySql, this can be done using GROUP_CONCAT, in which you can also specify the sorting mechanism for the group concatenation (aggregation). The rest is simple.\\n```\\nselect sell_date, count( DISTINCT product ) as num_sold ,\\n    \\n    GROUP_CONCAT( DISTINCT product order by product ASC separator \\',\\' ) as products\\n    \\n        FROM Activities GROUP BY sell_date order by sell_date ASC;\\n\\n```\\n![image](https://assets.leetcode.com/users/images/1a22513a-f19e-4338-b241-14a37d53c39d_1655656234.9439957.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date, count( DISTINCT product ) as num_sold ,\\n    \\n    GROUP_CONCAT( DISTINCT product order by product ASC separator \\',\\' ) as products\\n    \\n        FROM Activities GROUP BY sell_date order by sell_date ASC;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 692814,
                "title": "mysql-order-by-product-name-and-sell-date",
                "content": "Almost immediately detected, the only serious challange of this problem is how to aggregate the product names in one cell. In MySql, this can be done using GROUP_CONCAT, in which you can also specify the sorting mechanism for the group concatenation (aggregation). The rest is simple.\\n```\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "Almost immediately detected, the only serious challange of this problem is how to aggregate the product names in one cell. In MySql, this can be done using GROUP_CONCAT, in which you can also specify the sorting mechanism for the group concatenation (aggregation). The rest is simple.\\n```\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC",
                "codeTag": "Unknown"
            },
            {
                "id": 2497772,
                "title": "mysql-solution-clean-faster-than-92",
                "content": "* ***please UPVOTE ***\\n```\\nSELECT  \\n\\tsell_date,\\n\\t(COUNT(sell_date ) ) as num_sold ,\\n\\tGROUP_CONCAT(distinct product  ORDER BY product) as products \\nFROM \\n\\t(SELECT DISTINCT sell_date,product FROM Activities) as Activities\\nGROUP BY sell_date;\\n```\\n\\n* ***please UPVOTE ***\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT  \\n\\tsell_date,\\n\\t(COUNT(sell_date ) ) as num_sold ,\\n\\tGROUP_CONCAT(distinct product  ORDER BY product) as products \\nFROM \\n\\t(SELECT DISTINCT sell_date,product FROM Activities) as Activities\\nGROUP BY sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2510956,
                "title": "mysql-beginner-level-easy-to-understand-simple-short-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.***\\n*====================================================================*\\n\\u2705 **MySQL Code :**\\n```\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC\\n```\\n**Runtime:** 380 ms\\n**Memory Usage:**  0B\\n________________________________\\n__________________________________\\n\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863267,
                "title": "pandas-vs-sql-elegant-short-all-30-days-of-pandas-solutions",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python []\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    return activities.groupby(\\n        \\'sell_date\\'\\n    )[\\'product\\'].agg([\\n        (\\'num_sold\\', \\'nunique\\'),\\n        (\\'products\\', lambda x: \\',\\'.join(sorted(x.unique())))\\n    ]).reset_index()\\n```\\n```SQL []\\nSELECT sell_date,\\n       count(DISTINCT product) AS num_sold,\\n       group_concat(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') products\\n  FROM activities\\n GROUP BY sell_date\\n ORDER BY sell_date;\\n```\\n\\n# Important!\\n###### If you like the solution or find it useful, feel free to **upvote** for it, it will support me in creating high quality solutions)\\n\\n# 30 Days of Pandas solutions\\n\\n### Data Filtering \\u2705\\n- [Big Countries](https://leetcode.com/problems/big-countries/solutions/3848474/pandas-elegant-short-1-line/)\\n- [Recyclable and Low Fat Products](https://leetcode.com/problems/recyclable-and-low-fat-products/solutions/3848500/pandas-elegant-short-1-line/)\\n- [Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order/solutions/3848527/pandas-elegant-short-1-line/)\\n- [Article Views I](https://leetcode.com/problems/article-views-i/solutions/3867192/pandas-elegant-short-1-line/)\\n\\n\\n### String Methods \\u2705\\n- [Invalid Tweets](https://leetcode.com/problems/invalid-tweets/solutions/3849121/pandas-elegant-short-1-line/)\\n- [Calculate Special Bonus](https://leetcode.com/problems/calculate-special-bonus/solutions/3867209/pandas-elegant-short-1-line/)\\n- [Fix Names in a Table](https://leetcode.com/problems/fix-names-in-a-table/solutions/3849167/pandas-elegant-short-1-line/)\\n- [Find Users With Valid E-Mails](https://leetcode.com/problems/find-users-with-valid-e-mails/solutions/3849177/pandas-elegant-short-1-line/)\\n- [Patients With a Condition](https://leetcode.com/problems/patients-with-a-condition/solutions/3849196/pandas-elegant-short-1-line-regex/)\\n\\n\\n### Data Manipulation \\u2705\\n- [Nth Highest Salary](https://leetcode.com/problems/nth-highest-salary/solutions/3867257/pandas-elegant-short-1-line/)\\n- [Second Highest Salary](https://leetcode.com/problems/second-highest-salary/solutions/3867278/pandas-elegant-short/)\\n- [Department Highest Salary](https://leetcode.com/problems/department-highest-salary/solutions/3867312/pandas-elegant-short-1-line/)\\n- [Rank Scores](https://leetcode.com/problems/rank-scores/solutions/3872817/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails/solutions/3849211/pandas-elegant-short/)\\n- [Rearrange Products Table](https://leetcode.com/problems/rearrange-products-table/solutions/3849226/pandas-elegant-short-1-line/)\\n\\n\\n### Statistics \\u2705\\n- [The Number of Rich Customers](https://leetcode.com/problems/the-number-of-rich-customers/solutions/3849251/pandas-elegant-short-1-line/)\\n- [Immediate Food Delivery I](https://leetcode.com/problems/immediate-food-delivery-i/solutions/3872719/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Count Salary Categories](https://leetcode.com/problems/count-salary-categories/solutions/3872801/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Find Total Time Spent by Each Employee](https://leetcode.com/problems/find-total-time-spent-by-each-employee/solutions/3872715/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Game Play Analysis I](https://leetcode.com/problems/game-play-analysis-i/solutions/3863223/pandas-elegant-short-1-line/)\\n- [Number of Unique Subjects Taught by Each Teacher](https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/solutions/3863239/pandas-elegant-short-1-line/)\\n- [Classes More Than 5 Students](https://leetcode.com/problems/classes-more-than-5-students/solutions/3863249/pandas-elegant-short/)\\n- [Customer Placing the Largest Number of Orders](https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/solutions/3863257/pandas-elegant-short-1-line/)\\n- [Group Sold Products By The Date](https://leetcode.com/problems/group-sold-products-by-the-date/solutions/3863267/pandas-elegant-short-1-line/)\\n- [Daily Leads and Partners](https://leetcode.com/problems/daily-leads-and-partners/solutions/3863279/pandas-elegant-short-1-line/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Actors and Directors Who Cooperated At Least Three Times](https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times/solutions/3863309/pandas-elegant-short/)\\n- [Replace Employee ID With The Unique Identifier](https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/solutions/3872822/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Students and Examinations](https://leetcode.com/problems/students-and-examinations/solutions/3872699/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Managers with at Least 5 Direct Reports](https://leetcode.com/problems/managers-with-at-least-5-direct-reports/solutions/3872861/pandas-elegant-short/)\\n- [Sales Person](https://leetcode.com/problems/sales-person/solutions/3872712/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "MySQL",
                    "Pandas"
                ],
                "code": "```Python []\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    return activities.groupby(\\n        \\'sell_date\\'\\n    )[\\'product\\'].agg([\\n        (\\'num_sold\\', \\'nunique\\'),\\n        (\\'products\\', lambda x: \\',\\'.join(sorted(x.unique())))\\n    ]).reset_index()\\n```\n```SQL []\\nSELECT sell_date,\\n       count(DISTINCT product) AS num_sold,\\n       group_concat(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') products\\n  FROM activities\\n GROUP BY sell_date\\n ORDER BY sell_date;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 845705,
                "title": "all-dbs-simple-solution",
                "content": "Oracle\\n```\\nselect to_char(a.sell_date, \\'yyyy-mm-dd\\') sell_date\\n    , count(a.product) num_sold\\n    , listagg(a.product, \\',\\') within group(order by a.product) products\\nfrom (select distinct * from activities) a\\ngroup by a.sell_date\\norder by a.sell_date\\n```\\nMy SQL\\n```\\nselect sell_date\\n\\t, count(distinct product) num_sold\\n\\t, group_concat(distinct product order by product asc separator \\',\\') products\\nfrom activities\\ngroup by sell_date\\norder by sell_date\\n```\\nMS SQL\\n```\\nselect a.sell_date\\n   , count(a.product) num_sold\\n   , string_agg(a.product,\\',\\') within group (order by a.product) products\\nfrom (select distinct sell_date,product from activities) a\\ngroup by a.sell_date\\norder by a.sell_date\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nselect to_char(a.sell_date, \\'yyyy-mm-dd\\') sell_date\\n    , count(a.product) num_sold\\n    , listagg(a.product, \\',\\') within group(order by a.product) products\\nfrom (select distinct * from activities) a\\ngroup by a.sell_date\\norder by a.sell_date\\n```\n```\\nselect sell_date\\n\\t, count(distinct product) num_sold\\n\\t, group_concat(distinct product order by product asc separator \\',\\') products\\nfrom activities\\ngroup by sell_date\\norder by sell_date\\n```\n```\\nselect a.sell_date\\n   , count(a.product) num_sold\\n   , string_agg(a.product,\\',\\') within group (order by a.product) products\\nfrom (select distinct sell_date,product from activities) a\\ngroup by a.sell_date\\norder by a.sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043998,
                "title": "mysql-simple-n-concise-query",
                "content": "# Query\\n```\\n# Write your MySQL query statement below\\nSELECT sell_date,\\n       COUNT(DISTINCT(product), sell_date) AS num_sold, \\n       GROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities\\nGROUP BY sell_date\\n```\\n\\n\\n\\n*if the solution worked for you* ***please upvote***",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT sell_date,\\n       COUNT(DISTINCT(product), sell_date) AS num_sold, \\n       GROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities\\nGROUP BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2209482,
                "title": "sql-easy-to-understand-using-group-concat",
                "content": "```\\nSELECT sell_date, \\n    count(DISTINCT product) as num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date \\nORDER BY sell_date;\\n```\\nPlease upvote if you found this useful :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date, \\n    count(DISTINCT product) as num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date \\nORDER BY sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262267,
                "title": "easiest-solution",
                "content": "```\\nSELECT\\n    sell_date,\\n    COUNT(DISTINCT product) num_sold,\\n    GROUP_CONCAT(DISTINCT product) products\\nFROM activities\\nGROUP BY sell_date\\nORDER BY sell_date\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    sell_date,\\n    COUNT(DISTINCT product) num_sold,\\n    GROUP_CONCAT(DISTINCT product) products\\nFROM activities\\nGROUP BY sell_date\\nORDER BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946871,
                "title": "pandas-my-approach-with-clear-comments",
                "content": "\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    # Group the activities by sell_date and collect the unique products for each date\\n    grouped = activities.groupby(\\'sell_date\\')[\\'product\\'].agg([\\'nunique\\', lambda x: \\',\\'.join(sorted(set(x)))]).reset_index()\\n    \\n    # Rename the columns for clarity\\n    grouped.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    \\n    # Replace variations of \\'Mask\\' with just \\'Mask\\'\\n    grouped[\\'products\\'] = grouped[\\'products\\'].str.replace(r\\'(^|,)Mask(,|$)\\', r\\'\\\\1Mask\\\\2\\')\\n    \\n    # Sort the result table by sell_date\\n    result = grouped.sort_values(by=\\'sell_date\\')\\n    \\n    return result\\n\\n```\\n![upvote img.jpg](https://assets.leetcode.com/users/images/fe39393f-fae2-42ae-8f28-c486468073a2_1692727296.8042412.jpeg)\\n",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    # Group the activities by sell_date and collect the unique products for each date\\n    grouped = activities.groupby(\\'sell_date\\')[\\'product\\'].agg([\\'nunique\\', lambda x: \\',\\'.join(sorted(set(x)))]).reset_index()\\n    \\n    # Rename the columns for clarity\\n    grouped.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    \\n    # Replace variations of \\'Mask\\' with just \\'Mask\\'\\n    grouped[\\'products\\'] = grouped[\\'products\\'].str.replace(r\\'(^|,)Mask(,|$)\\', r\\'\\\\1Mask\\\\2\\')\\n    \\n    # Sort the result table by sell_date\\n    result = grouped.sort_values(by=\\'sell_date\\')\\n    \\n    return result\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2696570,
                "title": "faster-than-83-of-mysql-online-submissions",
                "content": "**<<<<upvote **\\n\\n\\tSELECT sell_date, COUNT( DISTINCT product ) AS num_sold ,    \\n    GROUP_CONCAT( DISTINCT product ORDER BY product ASC separator \\',\\' ) AS product   \\n    FROM Activities GROUP BY sell_date ORDER BY sell_date ASC;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**<<<<upvote **\\n\\n\\tSELECT sell_date, COUNT( DISTINCT product ) AS num_sold ,    \\n    GROUP_CONCAT( DISTINCT product ORDER BY product ASC separator \\',\\' ) AS product   \\n    FROM Activities GROUP BY sell_date ORDER BY sell_date ASC;",
                "codeTag": "Unknown"
            },
            {
                "id": 2012924,
                "title": "sql-query-with-detailed-explanation-sql",
                "content": "##### **GROUPCONCAT() is used to concatenat data from multiple rows into one field**\\n***step 1*: First we will count distinct products and name the column as num_sold\\n*step 2*: Next we use group concat to get the disctinct products and to display them in a column with a seperator(,) and order by products and name the column as products\\n*step 3*: We will group them by sell_date**\\n\\n\\n```\\nselect sell_date,count(distinct(product)) as num_sold, GROUP_CONCAT(distinct product order by product asc) as products\\nfrom Activities\\ngroup by sell_date\\n```\\n\\nUpvote this if you find it useful\\nThanks",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date,count(distinct(product)) as num_sold, GROUP_CONCAT(distinct product order by product asc) as products\\nfrom Activities\\ngroup by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074975,
                "title": "2-simple-sql-solutions-group-concat-and-string-agg",
                "content": "```\\nSELECT \\n  sell_date,\\n  COUNT(product) AS num_sold,\\n  STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product ASC) AS products\\nFROM (SELECT DISTINCT * FROM Activities) T\\nGROUP BY sell_date\\nORDER BY 1 ASC\\n```\\n\\n```\\nSELECT \\n    sell_date,\\n    COUNT(DISTINCT product) AS num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY 1 ASC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n  sell_date,\\n  COUNT(product) AS num_sold,\\n  STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product ASC) AS products\\nFROM (SELECT DISTINCT * FROM Activities) T\\nGROUP BY sell_date\\nORDER BY 1 ASC\\n```\n```\\nSELECT \\n    sell_date,\\n    COUNT(DISTINCT product) AS num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY 1 ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731869,
                "title": "mysql-easy-solution",
                "content": "# Code\\n```\\nSELECT \\n  sell_date, \\n  COUNT(DISTINCT(product)) AS num_sold, \\n  GROUP_CONCAT(DISTINCT(product)) AS products\\nFROM Activities\\nGROUP BY sell_date\\n```\\n![catty.png](https://assets.leetcode.com/users/images/00b619c4-a2b5-4df8-b722-4d15b667f177_1688727609.374941.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n  sell_date, \\n  COUNT(DISTINCT(product)) AS num_sold, \\n  GROUP_CONCAT(DISTINCT(product)) AS products\\nFROM Activities\\nGROUP BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2134094,
                "title": "ms-sql-solution-with-string-agg",
                "content": "Please note that this solution with `string_agg` will work only from SQL Server 2017 and above and SQL Azure\\n```\\nselect sell_date, count(product) as \\'num_sold\\', string_agg(product, \\',\\') as products\\nfrom\\n(\\n    select distinct *\\n    from Activities\\n) t\\ngroup by sell_date\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect sell_date, count(product) as \\'num_sold\\', string_agg(product, \\',\\') as products\\nfrom\\n(\\n    select distinct *\\n    from Activities\\n) t\\ngroup by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 752045,
                "title": "ms-sql-server-simple-solution",
                "content": "```\\nselect sell_date, \\n    COUNT(product) as num_sold,\\n    STRING_AGG(product,\\',\\') WITHIN GROUP (ORDER BY product) as products from\\n    (select distinct sell_date,product FROM Activities) Act\\n    GROUP BY sell_date\\n```",
                "solutionTags": [],
                "code": "```\\nselect sell_date, \\n    COUNT(product) as num_sold,\\n    STRING_AGG(product,\\',\\') WITHIN GROUP (ORDER BY product) as products from\\n    (select distinct sell_date,product FROM Activities) Act\\n    GROUP BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2291965,
                "title": "best-solution-using-group-by-group-concat",
                "content": "#### **Please Upvote if you Like it**\\n##### The GROUP BY statement groups rows that have the same values into summary rows.\\n#####  The GROUP BY statement is often used with aggregate functions (COUNT(), MAX(), MIN(), SUM(), AVG()) to group the result-set by one or more columns.\\n##### Another group method we use is **GROUP_CONCAT**, which concat items of grouped rows and joins them by using \",\" seperator. \\n```\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2264839,
                "title": "string-agg-explanation",
                "content": "This query will show the disired result: \\n select sell_date, count(distinct(product)) as num_sold,\\n STRING_AGG(product,\\',\\') within group (order by product) as products\\nfrom\\n(SELECT DISTINCT sell_date, product FROM Activities) T\\ngroup by sell_date\\norder by sell_date\\n\\nthe reason for using this part ((SELECT DISTINCT sell_date, product FROM Activities) T) is that \\nneed for bring distinct value on product name. (SQL server can not understand Distinct in the STRING_AGG, so need some query to send distinct value)\\n\\nin addition, postgres sql can understand Distinct in STRING_AGG, so you can use this query instead of top in postgrest sql:\\n\\n select sell_date, count(distinct(product)) as num_sold,\\n STRING_AGG(distinct(product), \\',\\'\\n order by product)\\n as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date\\nAlso you can check this link: \\nhttps://gregdodd.me/2021/08/24/distinct-list-in-string_agg/\\n\\nPlease UpVote if it was Helpful\\n\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "This query will show the disired result: \\n select sell_date, count(distinct(product)) as num_sold,\\n STRING_AGG(product,\\',\\') within group (order by product) as products\\nfrom\\n(SELECT DISTINCT sell_date, product FROM Activities) T\\ngroup by sell_date\\norder by sell_date\\n\\nthe reason for using this part ((SELECT DISTINCT sell_date, product FROM Activities) T) is that \\nneed for bring distinct value on product name. (SQL server can not understand Distinct in the STRING_AGG, so need some query to send distinct value)\\n\\nin addition, postgres sql can understand Distinct in STRING_AGG, so you can use this query instead of top in postgrest sql:\\n\\n select sell_date, count(distinct(product)) as num_sold,\\n STRING_AGG(distinct(product), \\',\\'\\n order by product)\\n as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date\\nAlso you can check this link: \\nhttps://gregdodd.me/2021/08/24/distinct-list-in-string_agg/\\n\\nPlease UpVote if it was Helpful\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2245118,
                "title": "simple-and-easy-solution-using-group-concat",
                "content": "```\\nSELECT \\n    sell_date,\\n    count(DISTINCT(product)) as num_sold,\\n    GROUP_CONCAT( DISTINCT product) as products\\nfrom Activities \\nGroup by sell_date;\\n```\\n\\n**Please UpVote if it was Helpful :)**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    sell_date,\\n    count(DISTINCT(product)) as num_sold,\\n    GROUP_CONCAT( DISTINCT product) as products\\nfrom Activities \\nGroup by sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997039,
                "title": "ms-sql-using-string-agg",
                "content": "```\\nwith t as (\\n    select distinct * from Activities)\\n\\nselect \\n     sell_date\\n    ,count(1) as num_sold\\n    ,string_agg(product,\\',\\') within group (order by product) as products\\nfrom t\\ngroup by sell_date\\norder by sell_date\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nwith t as (\\n    select distinct * from Activities)\\n\\nselect \\n     sell_date\\n    ,count(1) as num_sold\\n    ,string_agg(product,\\',\\') within group (order by product) as products\\nfrom t\\ngroup by sell_date\\norder by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2591930,
                "title": "sql-solution-using-group-concat-definition-and-syntax-of-group-concat",
                "content": "--GROUP_CONCAT() function in MySQL is used to concatenate data from multiple rows into one field\\n--Syntax: SELECT col1, col2, ..., colN\\n        GROUP_CONCAT ( [DISTINCT] col_name1 \\n        [ORDER BY clause]  [SEPARATOR str_val] ) \\n        FROM table_name GROUP BY col_name2;\\n\\n            SELECT sell_date,\\n            COUNT(DISTINCT(product)) AS num_sold,\\n            GROUP_CONCAT(DISTINCT(product) SEPARATOR \\',\\') AS products\\n            FROM Activities\\n            GROUP BY sell_date;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "--GROUP_CONCAT() function in MySQL is used to concatenate data from multiple rows into one field\\n--Syntax: SELECT col1, col2, ..., colN\\n        GROUP_CONCAT ( [DISTINCT] col_name1 \\n        [ORDER BY clause]  [SEPARATOR str_val] ) \\n        FROM table_name GROUP BY col_name2;\\n\\n            SELECT sell_date,\\n            COUNT(DISTINCT(product)) AS num_sold,\\n            GROUP_CONCAT(DISTINCT(product) SEPARATOR \\',\\') AS products\\n            FROM Activities\\n            GROUP BY sell_date;",
                "codeTag": "Unknown"
            },
            {
                "id": 3896640,
                "title": "grouping-with-aggregations",
                "content": "# My SQL\\n\\nFirst, we group the data by the `sell_date` column. This allows us to count the number of unique products sold on each sell date, which we store in the `num_sold` column.\\n\\nThe most challenging part is to sort and join all unique product names in each group to get the products column. We can use the `GROUP_CONCAT()` function to combine multiple values from multiple rows into a single string. The syntax of the `GROUP_CONCAT()` function is as follows:\\n```\\nGROUP_CONCAT(DISTINCT [column_name] [separator])\\n```\\nThe `DISTINCT` keyword ensures that only unique values are concatenated. The separator parameter specifies the character that should be used to separate the values.\\n\\n``` sql []\\n# Write your MySQL query statement below\\nSELECT sell_date, COUNT(DISTINCT(product)) as num_sold,\\nGROUP_CONCAT(\\n    DISTINCT product \\n    ORDER BY product \\n    SEPARATOR \\',\\'\\n) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC\\n```\\n\\n# Pandas\\n\\nThe question asks us to group and summarize data by date. To do this, we first use the `groupby` function to group the `DataFrame` activities by date. This creates a new object called `groups`, which is a `DataFrameGroupBy` object.\\n\\nOnce we have the `DataFrameGroupBy` object, we can use the `agg()` function to perform aggregation operations on each group. The `agg()` function takes a list of aggregation tasks to perform. In this case, we are specifying two aggregation tasks:\\n- Creating num_solid column with the number of unique products sold on each sell date. \\n`num_sold=(\\'product\\', \\'nunique\\')`\\n- Join all unique names within each group. \\n`products=(\\'product\\', lambda x: \\',\\'.join(sorted(set(x))))`\\n\\n``` python3 []\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n  groups = activities.groupby(\\'sell_date\\')\\n\\n  stats = groups.agg(\\n    num_sold=(\\'product\\', \\'nunique\\'),\\n    products=(\\'product\\', lambda x: \\',\\'.join(sorted(set(x))))\\n  ).reset_index()\\n  stats.sort_values(\\'sell_date\\', inplace=True)\\n  return stats\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "MySQL",
                    "Pandas"
                ],
                "code": "```\\nGROUP_CONCAT(DISTINCT [column_name] [separator])\\n```\n``` sql []\\n# Write your MySQL query statement below\\nSELECT sell_date, COUNT(DISTINCT(product)) as num_sold,\\nGROUP_CONCAT(\\n    DISTINCT product \\n    ORDER BY product \\n    SEPARATOR \\',\\'\\n) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC\\n```\n``` python3 []\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n  groups = activities.groupby(\\'sell_date\\')\\n\\n  stats = groups.agg(\\n    num_sold=(\\'product\\', \\'nunique\\'),\\n    products=(\\'product\\', lambda x: \\',\\'.join(sorted(set(x))))\\n  ).reset_index()\\n  stats.sort_values(\\'sell_date\\', inplace=True)\\n  return stats\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3426731,
                "title": "superb-logic-mysql",
                "content": "\\n# Logic is to use distinct and group_concat\\n```\\nselect sell_date,\\ncount(distinct product) as num_sold,\\nGroup_concat(distinct product) as products from activities\\ngroup by sell_date;\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date,\\ncount(distinct product) as num_sold,\\nGroup_concat(distinct product) as products from activities\\ngroup by sell_date;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3145587,
                "title": "group-concat",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT sell_date, COUNT(DISTINCT product) as num_sold, GROUP_CONCAT(\\n    DISTINCT product \\n    ORDER BY product ASC \\n    separator \\',\\') AS Products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT sell_date, COUNT(DISTINCT product) as num_sold, GROUP_CONCAT(\\n    DISTINCT product \\n    ORDER BY product ASC \\n    separator \\',\\') AS Products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522870,
                "title": "mysql-easy-solution",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT sell_date,COUNT(DISTINCT(product)) AS num_sold,\\nGROUP_CONCAT(DISTINCT product SEPARATOR \",\" ) AS products FROM Activities\\nGroup by sell_date\\nORDER BY sell_date;\\n```\\n# upvote if u find it useful",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT sell_date,COUNT(DISTINCT(product)) AS num_sold,\\nGROUP_CONCAT(DISTINCT product SEPARATOR \",\" ) AS products FROM Activities\\nGroup by sell_date\\nORDER BY sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246482,
                "title": "oracle-sql-solution-and-explanation",
                "content": "# Solution & explanation -\\nThe below code is not working but as per the oracle it should work.\\nClick this [link](https://livesql.oracle.com/apex/livesql/file/content_HT1O85E4BHSBWN93G1B3M8SI2.html) to check on oracle website.\\n\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT TO_CHAR(sell_date, \\'YYYY-MM-DD\\') AS \"sell_date\", \\nCOUNT(DISTINCT(product)) AS \"num_sold\",\\nLISTAGG(DISTINCT(product), \\',\\') WITHIN GROUP (ORDER BY product) AS \"products\"\\nFROM activities \\nGROUP BY sell_date \\nORDER BY sell_date;\\n```\\n\\nIn question description, it is mentioned as **\"There is no primary key for this table, it may contain duplicates\"** and it contains duplicate values. So just fetch unqiue values of product & sell_date columns from activities table instead of fetching directly from the activities table. Check the below code.\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT TO_CHAR(sell_date, \\'YYYY-MM-DD\\') AS \"sell_date\", \\nCOUNT(DISTINCT(product)) AS \"num_sold\",\\nLISTAGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS \"products\"\\nFROM (\\n    SELECT DISTINCT product, sell_date \\n    FROM activities\\n) \\nGROUP BY sell_date \\nORDER BY sell_date;\\n```\\n\\nI hope it is helpful to you.\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT TO_CHAR(sell_date, \\'YYYY-MM-DD\\') AS \"sell_date\", \\nCOUNT(DISTINCT(product)) AS \"num_sold\",\\nLISTAGG(DISTINCT(product), \\',\\') WITHIN GROUP (ORDER BY product) AS \"products\"\\nFROM activities \\nGROUP BY sell_date \\nORDER BY sell_date;\\n```\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT TO_CHAR(sell_date, \\'YYYY-MM-DD\\') AS \"sell_date\", \\nCOUNT(DISTINCT(product)) AS \"num_sold\",\\nLISTAGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS \"products\"\\nFROM (\\n    SELECT DISTINCT product, sell_date \\n    FROM activities\\n) \\nGROUP BY sell_date \\nORDER BY sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2082472,
                "title": "sql-very-easy-solution",
                "content": "```\\nselect sell_date,\\ncount(distinct(product)) num_sold,\\ngroup_concat(distinct(product)) products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date;```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date,\\ncount(distinct(product)) num_sold,\\ngroup_concat(distinct(product)) products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date;```",
                "codeTag": "Unknown"
            },
            {
                "id": 1707967,
                "title": "simple-solution",
                "content": "SELECT sell_date, count(DISTINCT product) as num_sold, group_concat(DISTINCT product separator \\',\\') as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date",
                "solutionTags": [],
                "code": "SELECT sell_date, count(DISTINCT product) as num_sold, group_concat(DISTINCT product separator \\',\\') as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date",
                "codeTag": "Unknown"
            },
            {
                "id": 692809,
                "title": "easy-mysql-solution",
                "content": "```\\nselect sell_date, count(distinct product) as num_sold , \\ngroup_concat(distinct product order by product asc separator \\',\\') as products               \\nfrom activities  \\ngroup by sell_date\\norder by sell_date\\n```",
                "solutionTags": [],
                "code": "```\\nselect sell_date, count(distinct product) as num_sold , \\ngroup_concat(distinct product order by product asc separator \\',\\') as products               \\nfrom activities  \\ngroup by sell_date\\norder by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903980,
                "title": "easy-solution",
                "content": "# SQL\\n```\\nselect sell_date, count(distinct product) as num_sold,group_concat(distinct product) as products from Activities group by sell_date\\n```\\n# Python\\n```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n  return activities.groupby(\\'sell_date\\')[\\'product\\'].agg([(\\'num_sold\\',\\'nunique\\'),(\\'products\\',lambda x: \\',\\'.join(sorted(x.unique())))]).reset_index()\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nselect sell_date, count(distinct product) as num_sold,group_concat(distinct product) as products from Activities group by sell_date\\n```\n```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n  return activities.groupby(\\'sell_date\\')[\\'product\\'].agg([(\\'num_sold\\',\\'nunique\\'),(\\'products\\',lambda x: \\',\\'.join(sorted(x.unique())))]).reset_index()\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3647996,
                "title": "group-concat-explanation-mysql-pandas-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- In order to agrregate the product into a single row grouped by sell_date, we use **GROUP_CONCAT()** function.\\n- We can also specify the sorting condition in GROUP_CONCAT() as \\n`GROUP_CONCAT(DISTINCT product ORDER BY product) as products`\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT sell_date, COUNT(DISTINCT product) as num_sold, \\n  GROUP_CONCAT(DISTINCT product ORDER BY product) as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n```\\n```\\nimport pandas as pd\\n\\ndef group_sold_products_by_the_date(activities: pd.DataFrame) -> pd.DataFrame:\\n    df = activities.groupby(\\'sell_date\\')[\\'product\\'].agg([\\n        (\\'num_sold\\', \\'nunique\\'),\\n        (\\'products\\', lambda x: \\',\\'.join(sorted(x.unique())))]).reset_index()\\n\\n    return df\\n```",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT sell_date, COUNT(DISTINCT product) as num_sold, \\n  GROUP_CONCAT(DISTINCT product ORDER BY product) as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n```\n```\\nimport pandas as pd\\n\\ndef group_sold_products_by_the_date(activities: pd.DataFrame) -> pd.DataFrame:\\n    df = activities.groupby(\\'sell_date\\')[\\'product\\'].agg([\\n        (\\'num_sold\\', \\'nunique\\'),\\n        (\\'products\\', lambda x: \\',\\'.join(sorted(x.unique())))]).reset_index()\\n\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2564749,
                "title": "easiest-and-understandable-solution",
                "content": "# Write your MySQL query statement below\\nSELECT \\n    sell_date,\\n    COUNT(DISTINCT product) AS num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date",
                "solutionTags": [],
                "code": "# Write your MySQL query statement below\\nSELECT \\n    sell_date,\\n    COUNT(DISTINCT product) AS num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date",
                "codeTag": "Unknown"
            },
            {
                "id": 2501716,
                "title": "sql-server-easy-solution",
                "content": "**Key points - **\\n1. Remove duplicates from the table using CTE\\n2. Group by sell_date, count each sell date\\n3. Use string_agg function and order within group by product.\\n\\n```\\nwith cteactivity AS \\n    (SELECT DISTINCT *\\n    FROM activities)\\nSELECT sell_date,\\n\\t\\t count(product) AS num_sold,\\n\\t\\t string_agg(product, \\',\\') within group (order by product) AS products\\nFROM cteactivity\\nGROUP BY  sell_date\\nORDER BY  sell_date",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "**Key points - **\\n1. Remove duplicates from the table using CTE\\n2. Group by sell_date, count each sell date\\n3. Use string_agg function and order within group by product.\\n\\n```\\nwith cteactivity AS \\n    (SELECT DISTINCT *\\n    FROM activities)\\nSELECT sell_date,\\n\\t\\t count(product) AS num_sold,\\n\\t\\t string_agg(product, \\',\\') within group (order by product) AS products\\nFROM cteactivity\\nGROUP BY  sell_date\\nORDER BY  sell_date",
                "codeTag": "Unknown"
            },
            {
                "id": 2078939,
                "title": "mysql-easy-solution",
                "content": "**Pls Upvote if you like the solution!**\\n```\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Pls Upvote if you like the solution!**\\n```\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC",
                "codeTag": "Unknown"
            },
            {
                "id": 2063222,
                "title": "simple-mysql-solution-beats-100",
                "content": "```\\nSELECT\\n\\tsell_date,\\n\\tCOUNT(DISTINCT (product)) AS num_sold, \\n\\tGROUP_CONCAT(DISTINCT(product)) AS products \\nFROM Activities \\nGROUP BY sell_date \\nORDER BY sell_date ASC;\\n```\\nEdit : As someone pointed out in the comments, we could use ```GROUP_CONCAT(DISTINCT(product) ORDER BY product ASC)``` to sort the products, but the above query works just as fine.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n\\tsell_date,\\n\\tCOUNT(DISTINCT (product)) AS num_sold, \\n\\tGROUP_CONCAT(DISTINCT(product)) AS products \\nFROM Activities \\nGROUP BY sell_date \\nORDER BY sell_date ASC;\\n```\n```GROUP_CONCAT(DISTINCT(product) ORDER BY product ASC)```",
                "codeTag": "Unknown"
            },
            {
                "id": 2050476,
                "title": "quickest-solution",
                "content": "select sell_date, \\ncount(distinct product) as num_sold, \\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date,products",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select sell_date, \\ncount(distinct product) as num_sold, \\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date,products",
                "codeTag": "Unknown"
            },
            {
                "id": 693799,
                "title": "oracle-solution-listagg",
                "content": "```\\nWITH cte as(\\nselect distinct sell_date, product from Activities)\\n\\nselect TO_CHAR(sell_date,\\'YYYY-MM-DD\\') as sell_date, count(product) as num_sold,\\nLISTAGG(product, \\',\\') WITHIN GROUP (ORDER BY product) as products\\nfrom cte\\ngroup by sell_date\\norder by sell_date\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nWITH cte as(\\nselect distinct sell_date, product from Activities)\\n\\nselect TO_CHAR(sell_date,\\'YYYY-MM-DD\\') as sell_date, count(product) as num_sold,\\nLISTAGG(product, \\',\\') WITHIN GROUP (ORDER BY product) as products\\nfrom cte\\ngroup by sell_date\\norder by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600643,
                "title": "mysql-solution-for-group-sold-products-by-the-date-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to group the activities by sell date and then calculate the number of different products sold on each date. Additionally, we need to concatenate the names of the products and sort them lexicographically for each sell date.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use the SQL query provided, which utilizes the GROUP BY clause to group the activities by sell date. Within each group, the COUNT(DISTINCT product) function is used to count the number of different products sold, while the GROUP_CONCAT(DISTINCT product ORDER BY product) function is used to concatenate and sort the product names lexicographically.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution depends on the number of rows in the Activities table. Let\\'s denote this number as n. The query performs a grouping operation, which typically has a time complexity of O(n log n) or O(n) depending on the database implementation. Additionally, the query involves sorting the product names lexicographically for each sell date, which also contributes to the overall time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this solution depends on the number of distinct sell dates and the number of distinct products. Let\\'s denote these numbers as d and p respectively. The space complexity is O(d + p), as it requires storing the distinct sell dates and the distinct product names in memory for grouping and concatenation operations.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3279846,
                "title": "sql-server-clean-easy",
                "content": "```\\nWITH CTE AS (\\n  SELECT DISTINCT * FROM Activities\\n)\\n\\nSELECT \\nsell_date,\\nCOUNT(product) AS num_sold,\\nSTRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product ASC) AS products\\nFROM CTE\\nGROUP BY sell_date\\nORDER BY 1 ASC\\n```",
                "solutionTags": [],
                "code": "```\\nWITH CTE AS (\\n  SELECT DISTINCT * FROM Activities\\n)\\n\\nSELECT \\nsell_date,\\nCOUNT(product) AS num_sold,\\nSTRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product ASC) AS products\\nFROM CTE\\nGROUP BY sell_date\\nORDER BY 1 ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2546731,
                "title": "1484-group-sold-products-by-the-date",
                "content": "```\\nSELECT sell_date, COUNT(DISTINCT(product)) as num_sold, \\nGroup_Concat(distinct(product)\\nORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date ORDER BY sell_date;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date, COUNT(DISTINCT(product)) as num_sold, \\nGroup_Concat(distinct(product)\\nORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date ORDER BY sell_date;",
                "codeTag": "Unknown"
            },
            {
                "id": 2442281,
                "title": "simple-solution",
                "content": "```\\nSELECT sell_date, \\nCOUNT(DISTINCT(product)) AS num_sold, \\nGROUP_CONCAT(DISTINCT(product)) AS products \\nFROM Activities \\nGROUP BY sell_date \\nORDER BY sell_date;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT sell_date, \\nCOUNT(DISTINCT(product)) AS num_sold, \\nGROUP_CONCAT(DISTINCT(product)) AS products \\nFROM Activities \\nGROUP BY sell_date \\nORDER BY sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2392750,
                "title": "mysql-easy-solution-using-group-concat",
                "content": "##### GROUP_CONCAT() function\\n\\nMySQL GROUP_CONCAT() function eturns a string with concatenated non-NULL value from a group.\\nReturns NULL when there are no non-NULL values.\\n\\n\\n```\\nselect sell_date, \\n\\tcount(distinct(product)) as num_sold, \\n\\t\\tgroup_concat(distinct(product)) as products\\nfrom activities\\ngroup by sell_date order by sell_date;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date, \\n\\tcount(distinct(product)) as num_sold, \\n\\t\\tgroup_concat(distinct(product)) as products\\nfrom activities\\ngroup by sell_date order by sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2335072,
                "title": "simple-readable-group-by-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect sell_date, count(distinct product) num_sold, \\ngroup_concat(distinct product) as products from Activities group by sell_date\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect sell_date, count(distinct product) num_sold, \\ngroup_concat(distinct product) as products from Activities group by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2271739,
                "title": "mysql-easy-understanding-beginner-friendly",
                "content": "```\\nselect  sell_date,\\n\\t    count(distinct product) as num_sold,\\n        group_concat(distinct product) as products\\nfrom activities\\ngroup by sell_date\\norder by sell_date\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect  sell_date,\\n\\t    count(distinct product) as num_sold,\\n        group_concat(distinct product) as products\\nfrom activities\\ngroup by sell_date\\norder by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2265965,
                "title": "1484-group-sold-products-by-the-date",
                "content": "```\\nselect sell_date,\\ncount(distinct product)as num_sold,\\ngroup_concat(distinct product order by product) as products\\nfrom Activities \\ngroup by sell_date\\norder by sell_date;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nselect sell_date,\\ncount(distinct product)as num_sold,\\ngroup_concat(distinct product order by product) as products\\nfrom Activities \\ngroup by sell_date\\norder by sell_date;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2161143,
                "title": "group-concat-faster-than-95",
                "content": "```\\nSELECT sell_date, \\nCOUNT(DISTINCT product) num_sold, \\nGROUP_CONCAT(DISTINCT product) as products\\nFROM Activities\\nGROUP BY 1\\n```\\n\\nI am not sure if we have to use ORDER BY within GROUP_CONCAT as it returns the order lexicographically on its own. My assumption is that ---> ASC order is by default if you dont mention the ORDER BY in this clause. And also we dont need a SEPARATOR as the GROUP_CONCAT adds a \\',\\' between values by default. \\n\\nI can be wrong so please correct me if anyone knows more about this.",
                "solutionTags": [],
                "code": "```\\nSELECT sell_date, \\nCOUNT(DISTINCT product) num_sold, \\nGROUP_CONCAT(DISTINCT product) as products\\nFROM Activities\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105157,
                "title": "easy-mysql-query-beginner-friendly",
                "content": "```sql\\nselect \\n    sell_date, \\n    count(distinct product) as num_sold, \\n    group_concat(distinct product) as products\\nfrom activities\\ngroup by sell_date\\norder by sell_date;\\n```",
                "solutionTags": [],
                "code": "```sql\\nselect \\n    sell_date, \\n    count(distinct product) as num_sold, \\n    group_concat(distinct product) as products\\nfrom activities\\ngroup by sell_date\\norder by sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1974783,
                "title": "mysql-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1974660,
                "title": "mysql-solution-distict-group-concat-group-by",
                "content": "```\\nselect \\n    sell_date,\\n    count(distinct(product)) as num_sold,\\n    group_concat(distinct(product)) as products \\nfrom Activities  \\n    group by sell_date \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect \\n    sell_date,\\n    count(distinct(product)) as num_sold,\\n    group_concat(distinct(product)) as products \\nfrom Activities  \\n    group by sell_date \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938564,
                "title": "oracle-listagg-group-by",
                "content": "Please upvote, if it helps\\n\\n```\\nselect to_char(sell_date) sell_date,count(1)num_sold,LISTAGG(product,\\',\\') within group (order by product) products from (select distinct * from Activities) group by sell_date order by sell_date\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect to_char(sell_date) sell_date,count(1)num_sold,LISTAGG(product,\\',\\') within group (order by product) products from (select distinct * from Activities) group by sell_date order by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519970,
                "title": "ms-sql",
                "content": "#### Question\\n```\\n1484. Group Sold Products By The Date\\nEasy\\n\\nSQL Schema\\nTable Activities:\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| sell_date   | date    |\\n| product     | varchar |\\n+-------------+---------+\\nThere is no primary key for this table, it may contains duplicates.\\nEach row of this table contains the product name and the date it was sold in a market.\\n \\n\\nWrite an SQL query to find for each date, the number of distinct products sold and their names.\\n\\nThe sold-products names for each date should be sorted lexicographically. \\n\\nReturn the result table ordered by sell_date.\\n\\nThe query result format is in the following example.\\n\\nActivities table:\\n+------------+-------------+\\n| sell_date  | product     |\\n+------------+-------------+\\n| 2020-05-30 | Headphone   |\\n| 2020-06-01 | Pencil      |\\n| 2020-06-02 | Mask        |\\n| 2020-05-30 | Basketball  |\\n| 2020-06-01 | Bible       |\\n| 2020-06-02 | Mask        |\\n| 2020-05-30 | T-Shirt     |\\n+------------+-------------+\\n\\nResult table:\\n+------------+----------+------------------------------+\\n| sell_date  | num_sold | products                     |\\n+------------+----------+------------------------------+\\n| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |\\n| 2020-06-01 | 2        | Bible,Pencil                 |\\n| 2020-06-02 | 1        | Mask                         |\\n+------------+----------+------------------------------+\\nFor 2020-05-30, Sold items were (Headphone, Basketball, T-shirt), we sort them lexicographically and separate them by comma.\\nFor 2020-06-01, Sold items were (Pencil, Bible), we sort them lexicographically and separate them by comma.\\nFor 2020-06-02, Sold item is (Mask), we just return it.\\n\\n```\\n\\n\\n#### Answer\\n```SQL\\n\\n/* Write your T-SQL query statement below */\\nselect sell_date, count(product) num_sold, STRING_AGG(product,\\',\\') WITHIN GROUP(order by product) as products from (select distinct * from Activities) as a \\ngroup by sell_date\\norder by sell_date\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n1484. Group Sold Products By The Date\\nEasy\\n\\nSQL Schema\\nTable Activities:\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| sell_date   | date    |\\n| product     | varchar |\\n+-------------+---------+\\nThere is no primary key for this table, it may contains duplicates.\\nEach row of this table contains the product name and the date it was sold in a market.\\n \\n\\nWrite an SQL query to find for each date, the number of distinct products sold and their names.\\n\\nThe sold-products names for each date should be sorted lexicographically. \\n\\nReturn the result table ordered by sell_date.\\n\\nThe query result format is in the following example.\\n\\nActivities table:\\n+------------+-------------+\\n| sell_date  | product     |\\n+------------+-------------+\\n| 2020-05-30 | Headphone   |\\n| 2020-06-01 | Pencil      |\\n| 2020-06-02 | Mask        |\\n| 2020-05-30 | Basketball  |\\n| 2020-06-01 | Bible       |\\n| 2020-06-02 | Mask        |\\n| 2020-05-30 | T-Shirt     |\\n+------------+-------------+\\n\\nResult table:\\n+------------+----------+------------------------------+\\n| sell_date  | num_sold | products                     |\\n+------------+----------+------------------------------+\\n| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |\\n| 2020-06-01 | 2        | Bible,Pencil                 |\\n| 2020-06-02 | 1        | Mask                         |\\n+------------+----------+------------------------------+\\nFor 2020-05-30, Sold items were (Headphone, Basketball, T-shirt), we sort them lexicographically and separate them by comma.\\nFor 2020-06-01, Sold items were (Pencil, Bible), we sort them lexicographically and separate them by comma.\\nFor 2020-06-02, Sold item is (Mask), we just return it.\\n\\n```\n```SQL\\n\\n/* Write your T-SQL query statement below */\\nselect sell_date, count(product) num_sold, STRING_AGG(product,\\',\\') WITHIN GROUP(order by product) as products from (select distinct * from Activities) as a \\ngroup by sell_date\\norder by sell_date\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1028641,
                "title": "mysql",
                "content": "\\n```\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM Activities\\nGROUP BY sell_date\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM Activities\\nGROUP BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 694193,
                "title": "easy-oracle-solution-using-listagg",
                "content": "```\\nselect \\n(to_char(sell_date,\\'YYYY-MM-DD\\')) as sell_date,\\ncount(product) as num_sold,listagg(product,\\',\\') WITHIN GROUP (ORDER BY product) as products\\nfrom (select distinct sell_date,product from Activities)\\ngroup by sell_date\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n(to_char(sell_date,\\'YYYY-MM-DD\\')) as sell_date,\\ncount(product) as num_sold,listagg(product,\\',\\') WITHIN GROUP (ORDER BY product) as products\\nfrom (select distinct sell_date,product from Activities)\\ngroup by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3269844,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect sell_date, count(distinct(product)) as num_sold, \\ngroup_concat(distinct(product) order by product) as products\\nfrom Activities group by sell_date order by sell_date;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect sell_date, count(distinct(product)) as num_sold, \\ngroup_concat(distinct(product) order by product) as products\\nfrom Activities group by sell_date order by sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2793643,
                "title": "mysql-89-2-faster",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe challange of this problem is how to aggregate the product names in one cell. So we use `GROUP_CONCAT()` to aggregate distinct product names with a separator \\',\\' and also sort the product names. The rest is simple, we group by sell_date and COUNT DISTINCT product.\\n\\n# Code\\n```\\nSELECT \\n    sell_date, \\n    COUNT(DISTINCT product) as num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    sell_date, \\n    COUNT(DISTINCT product) as num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738697,
                "title": "sql-server-solution",
                "content": "it works well, and **Don\\'t forgot to upvote**\\n\\nthis below line do magic\\n\\n**string_agg(product,\\',\\') within group (order by product asc) as products **\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect sell_date, \\n        count(distinct product) as num_sold,\\n        string_agg(product,\\',\\') within group (order by product asc) as products\\nfrom(select distinct sell_date,product from Activities)sq \\ngroup by sell_date \\norder by sell_date\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect sell_date, \\n        count(distinct product) as num_sold,\\n        string_agg(product,\\',\\') within group (order by product asc) as products\\nfrom(select distinct sell_date,product from Activities)sq \\ngroup by sell_date \\norder by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2611951,
                "title": "just-use-group-concat",
                "content": "```\\nselect \\n\\tsell_date, \\n\\tcount(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n\\tsell_date, \\n\\tcount(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2558791,
                "title": "group-products-using-new-string-agg-funtion",
                "content": "**Upvote if you feel it easy :)**\\n\\nThis solution uses latest function STRING_AGG introduced by sql server\\n```\\nSELECT x.sell_date, SUM(x.num_sold) AS num_sold, STRING_AGG(x.product,\\',\\') as products\\nFROM (\\n\\tSELECT top 100 percent sell_date, COUNT(DISTINCT product) as num_sold, product\\n\\tFROM Activities\\n\\tGROUP BY sell_date, product\\n\\tORDER BY sell_date, product\\n) X\\nGROUP BY x.sell_date\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT x.sell_date, SUM(x.num_sold) AS num_sold, STRING_AGG(x.product,\\',\\') as products\\nFROM (\\n\\tSELECT top 100 percent sell_date, COUNT(DISTINCT product) as num_sold, product\\n\\tFROM Activities\\n\\tGROUP BY sell_date, product\\n\\tORDER BY sell_date, product\\n) X\\nGROUP BY x.sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2548241,
                "title": "simple-and-easy",
                "content": "select sell_date,count(distinct product) num_sold,group_concat(distinct product) products from activities group by sell_date order by sell_date",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select sell_date,count(distinct product) num_sold,group_concat(distinct product) products from activities group by sell_date order by sell_date",
                "codeTag": "Unknown"
            },
            {
                "id": 2306463,
                "title": "group-concat-function-easy-to-understand-mysql-solution",
                "content": "```\\nSELECT\\n    sell_date,\\n    COUNT(DISTINCT product) AS \"num_sold\",\\n    GROUP_CONCAT(\\n        DISTINCT product\\n        ORDER BY\\n            product\\n    ) AS \"products\"\\nFROM\\n    activities\\nGROUP BY\\n    sell_date;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    sell_date,\\n    COUNT(DISTINCT product) AS \"num_sold\",\\n    GROUP_CONCAT(\\n        DISTINCT product\\n        ORDER BY\\n            product\\n    ) AS \"products\"\\nFROM\\n    activities\\nGROUP BY\\n    sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2285569,
                "title": "sql-query-using-string-agg",
                "content": "```\\nSELECT sell_date, \\n    COUNT(product) AS num_sold, \\n    STRING_AGG(product,\\',\\') WITHIN GROUP ( ORDER BY product ASC) AS products\\nFROM (SELECT DISTINCT sell_date, product FROM Activities)A\\nGROUP BY sell_date\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT sell_date, \\n    COUNT(product) AS num_sold, \\n    STRING_AGG(product,\\',\\') WITHIN GROUP ( ORDER BY product ASC) AS products\\nFROM (SELECT DISTINCT sell_date, product FROM Activities)A\\nGROUP BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2223011,
                "title": "group-sold-products-by-the-date",
                "content": "```\\nSELECT sell_date,\\nCOUNT(distinct(product)) AS num_sold,\\nGROUP_CONCAT(DISTINCT(product) ORDER BY product SEPARATOR \\',\\') as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,product;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date,\\nCOUNT(distinct(product)) AS num_sold,\\nGROUP_CONCAT(DISTINCT(product) ORDER BY product SEPARATOR \\',\\') as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,product;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2173362,
                "title": "mysql-solution-group-sold-products-by-the-date",
                "content": "In this question , we need to group our data based on the selling date  and we need to provide date and number of product sell at that day in the output :\\n              \\n\\t\\t\\t  SELECT \\n                         sell_date , \\n                         COUNT(DISTINCT product) AS num_sold , \\n              FROM activities\\n              GROUP BY sell_date \\n\\t\\n\\nNow as we need to order the output table based on selling_date so , \\n              \\n\\t\\t\\t  SELECT \\n                        sell_date , \\n                        COUNT(DISTINCT product) AS num_sold , \\n               FROM activities\\n               GROUP BY sell_date \\n               ORDER BY sell_date\\n     \\nAt last we are left with one column where we need to display the name of products which were sold at that day , products need to be display by adding \" , \" between them for that we had used a fuction :\\n\\n**Group_concat( column name)** : Function is used to contcat the values and inclued \\',\\' between them . \\n\\t\\n\\t  SELECT \\n                 sell_date , \\n                 COUNT(DISTINCT product) AS num_sold , \\n                 GROUP_CONCAT(DISTINCT product) AS products\\n      FROM activities\\n      GROUP BY sell_date \\n      ORDER BY sell_date",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "In this question , we need to group our data based on the selling date  and we need to provide date and number of product sell at that day in the output :\\n              \\n\\t\\t\\t  SELECT \\n                         sell_date , \\n                         COUNT(DISTINCT product) AS num_sold , \\n              FROM activities\\n              GROUP BY sell_date \\n\\t\\n\\nNow as we need to order the output table based on selling_date so , \\n              \\n\\t\\t\\t  SELECT \\n                        sell_date , \\n                        COUNT(DISTINCT product) AS num_sold , \\n               FROM activities\\n               GROUP BY sell_date \\n               ORDER BY sell_date\\n     \\nAt last we are left with one column where we need to display the name of products which were sold at that day , products need to be display by adding \" , \" between them for that we had used a fuction :\\n\\n**Group_concat( column name)** : Function is used to contcat the values and inclued \\',\\' between them . \\n\\t\\n\\t  SELECT \\n                 sell_date , \\n                 COUNT(DISTINCT product) AS num_sold , \\n                 GROUP_CONCAT(DISTINCT product) AS products\\n      FROM activities\\n      GROUP BY sell_date \\n      ORDER BY sell_date",
                "codeTag": "Unknown"
            },
            {
                "id": 2145382,
                "title": "you-got-it",
                "content": "select sell_date , Count(distinct product) \\'num_sold\\' ,\\nGroup_concat(Distinct product order by product) \\'products\\'\\nfrom activities group by sell_date;",
                "solutionTags": [],
                "code": "select sell_date , Count(distinct product) \\'num_sold\\' ,\\nGroup_concat(Distinct product order by product) \\'products\\'\\nfrom activities group by sell_date;",
                "codeTag": "Unknown"
            },
            {
                "id": 2039241,
                "title": "concat-95",
                "content": "```\\nselect\\n    sell_date, \\n    count(distinct product) as num_sold, \\n    group_concat(distinct product order by product asc) as products \\nfrom \\n    activities \\ngroup by \\n    sell_date\\norder by \\n    sell_date \\n```\\n\\nif you like this, please upvote.",
                "solutionTags": [],
                "code": "```\\nselect\\n    sell_date, \\n    count(distinct product) as num_sold, \\n    group_concat(distinct product order by product asc) as products \\nfrom \\n    activities \\ngroup by \\n    sell_date\\norder by \\n    sell_date \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031482,
                "title": "tsql-string-agg-statement",
                "content": "```\\nSELECT sell_date, COUNT(DISTINCT(product)) AS num_sold, \\n    STRING_AGG(product,\\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM \\n(SELECT DISTINCT sell_date, product FROM Activities) T\\nGROUP BY sell_date\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT sell_date, COUNT(DISTINCT(product)) AS num_sold, \\n    STRING_AGG(product,\\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM \\n(SELECT DISTINCT sell_date, product FROM Activities) T\\nGROUP BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980629,
                "title": "easy-solution-distinct-group-concat-group-by",
                "content": "SELECT sell_date, count(distinct product) as num_sold, group_concat(distinct product) as products\\nFROM activities\\nGROUP BY sell_date;",
                "solutionTags": [],
                "code": "SELECT sell_date, count(distinct product) as num_sold, group_concat(distinct product) as products\\nFROM activities\\nGROUP BY sell_date;",
                "codeTag": "Unknown"
            },
            {
                "id": 1936549,
                "title": "using-group-concat-easy-understanding-sql",
                "content": "The main problem here is to concatenate the distinct products that were sold on a particular date. \\n\\nWe can do that by using ```GROUP_CONCAT``` keyword.\\nWe provide the `DISTINCT` keyword in both count and group_concat functions because we don\\'t want any duplicate records to mess with our counts. (Question does mention that duplicate entries might be present).\\n\\n## Query:\\n\\n```sql\\n\\nselect sell_date, count(distinct product) as num_sold, group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```GROUP_CONCAT```\n```sql\\n\\nselect sell_date, count(distinct product) as num_sold, group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1882323,
                "title": "mysql-using-count-group-contact",
                "content": "```\\nselect sell_date, count(distinct product) num_sold, \\ngroup_concat(distinct product order by product) \\nproducts from Activities group by sell_date;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date, count(distinct product) num_sold, \\ngroup_concat(distinct product order by product) \\nproducts from Activities group by sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1810821,
                "title": "simple-solution-using-group-concat-in-mysql",
                "content": "```\\nselect sell_date, \\n        count(distinct product) as num_sold,\\n        group_concat(distinct product order by product) as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date\\n```",
                "solutionTags": [],
                "code": "```\\nselect sell_date, \\n        count(distinct product) as num_sold,\\n        group_concat(distinct product order by product) as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604982,
                "title": "mysql",
                "content": "```\\nselect distinct sell_date, count(distinct product) as num_sold, \\ngroup_concat(distinct product order by product) as products\\nfrom activities \\ngroup by sell_date\\norder by sell_date\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct sell_date, count(distinct product) as num_sold, \\ngroup_concat(distinct product order by product) as products\\nfrom activities \\ngroup by sell_date\\norder by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720664,
                "title": "simple-mysql-answer",
                "content": "# answer 1\\n> Runtime: 729 ms, faster than 25.00% of MySQL online submissions for Group Sold Products By The Date.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Group Sold Products By The Date.\\n\\n```sql\\nselect \\n\\tsell_date, \\n\\tCOUNT(product) num_sold,  \\n\\tgroup_concat(product order by product) products \\nfrom (SELECT DISTINCT * FROM Activities) Activities\\ngroup by sell_date\\norder by sell_date\\n```\\n# answer 2\\n> Runtime: 656 ms, faster than 35.06% of MySQL online submissions for Group Sold Products By The Date.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Group Sold Products By The Date.\\n\\n```sql\\nselect \\n    sell_date, COUNT(DISTINCT product) num_sold, \\n    group_concat(DISTINCT product) products \\nfrom Activities\\ngroup by sell_date\\norder by sell_date\\n```",
                "solutionTags": [],
                "code": "```sql\\nselect \\n\\tsell_date, \\n\\tCOUNT(product) num_sold,  \\n\\tgroup_concat(product order by product) products \\nfrom (SELECT DISTINCT * FROM Activities) Activities\\ngroup by sell_date\\norder by sell_date\\n```\n```sql\\nselect \\n    sell_date, COUNT(DISTINCT product) num_sold, \\n    group_concat(DISTINCT product) products \\nfrom Activities\\ngroup by sell_date\\norder by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 711161,
                "title": "mssql-xml-path",
                "content": "```\\n1. Distinct Rows\\n\\t\\tselect distinct * from activities\\n```\\n```\\n2. XML Path\\n\\t\\tselect \\',\\' + tb1.product from (select distinct * from activities) tb1 for XML path(\\'\\')\\n```\\n```\\n3. Add Stuff\\n\\t\\tselect products = stuff((select \\',\\' + a.product from (select distinct * from activities) a for XML path(\\'\\')),1,1,\\'\\')\\n```\\n```\\n4. Subquery\\n\\t\\tselect sell_date, count(distinct product) \\'num_sold\\', \\n\\t\\tproducts = stuff((select \\',\\' + a.product from (select distinct * from activities) a \\n\\t\\twhere a.sell_date = aa.sell_date for XMl path(\\'\\')),1,1,\\'\\')\\n\\t\\tfrom Activities aa group by aa.sell_date\\n```",
                "solutionTags": [],
                "code": "```\\n1. Distinct Rows\\n\\t\\tselect distinct * from activities\\n```\n```\\n2. XML Path\\n\\t\\tselect \\',\\' + tb1.product from (select distinct * from activities) tb1 for XML path(\\'\\')\\n```\n```\\n3. Add Stuff\\n\\t\\tselect products = stuff((select \\',\\' + a.product from (select distinct * from activities) a for XML path(\\'\\')),1,1,\\'\\')\\n```\n```\\n4. Subquery\\n\\t\\tselect sell_date, count(distinct product) \\'num_sold\\', \\n\\t\\tproducts = stuff((select \\',\\' + a.product from (select distinct * from activities) a \\n\\t\\twhere a.sell_date = aa.sell_date for XMl path(\\'\\')),1,1,\\'\\')\\n\\t\\tfrom Activities aa group by aa.sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891154,
                "title": "eassy-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect sell_date,\\ncount(distinct product) as num_sold,\\nGroup_concat(distinct product) as products from activities\\ngroup by sell_date;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect sell_date,\\ncount(distinct product) as num_sold,\\nGroup_concat(distinct product) as products from activities\\ngroup by sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3578692,
                "title": "simple-mysql-solution-group-concat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect sell_date, \\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product order by product separator \\',\\') as products\\nfrom activities\\ngroup by sell_date\\norder by sell_date;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect sell_date, \\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product order by product separator \\',\\') as products\\nfrom activities\\ngroup by sell_date\\norder by sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514785,
                "title": "simple-and-easy-to-understand-mysql-query",
                "content": "\\n\\n# Code\\n```\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold, \\n       GROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold, \\n       GROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514732,
                "title": "t-sql-string-agg-function-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect \\n  sell_date, \\n  count(distinct product) as num_sold, \\n  string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product) as products\\nfrom (select distinct sell_date, product from activities) ac\\ngroup by ac.sell_date\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect \\n  sell_date, \\n  count(distinct product) as num_sold, \\n  string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product) as products\\nfrom (select distinct sell_date, product from activities) ac\\ngroup by ac.sell_date\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260625,
                "title": "solution-with-string-agg-function-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n-- /* SOLUTION 1: \\r\\nSELECT\\r\\n\\tsell_date,\\r\\n\\tCOUNT(product) num_sold,\\r\\n\\tSTRING_AGG(product,\\',\\') WITHIN GROUP(ORDER BY product ) products \\r\\nFROM\\r\\n    (\\r\\n\\r\\n        SELECT\\r\\n            DISTINCT\\r\\n            sell_date,\\r\\n            product\\r\\n        FROM\\r\\n            Activities\\r\\n    )TBL\\r\\n\\t\\r\\nGROUP BY\\r\\n\\tsell_date\\r\\n--SOLUTION 1: */\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n-- /* SOLUTION 1: \\r\\nSELECT\\r\\n\\tsell_date,\\r\\n\\tCOUNT(product) num_sold,\\r\\n\\tSTRING_AGG(product,\\',\\') WITHIN GROUP(ORDER BY product ) products \\r\\nFROM\\r\\n    (\\r\\n\\r\\n        SELECT\\r\\n            DISTINCT\\r\\n            sell_date,\\r\\n            product\\r\\n        FROM\\r\\n            Activities\\r\\n    )TBL\\r\\n\\t\\r\\nGROUP BY\\r\\n\\tsell_date\\r\\n--SOLUTION 1: */\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2677051,
                "title": "mysql-solution",
                "content": "```\\nSELECT sell_date, count(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product SEPARATOR \\',\\') AS products\\n\\tFROM Activities\\n\\tGROUP BY sell_date\\n\\tORDER BY sell_date\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date, count(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product SEPARATOR \\',\\') AS products\\n\\tFROM Activities\\n\\tGROUP BY sell_date\\n\\tORDER BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2671711,
                "title": "products-sold-in-each-day-solved-using-groupconcat",
                "content": "\\nHere we simply selecting the date , number of unique products sold and then we are displaying those products sold in each day using a keyword called \"GROUP_CONCAT\"\\n\\nGROUP CONCAT:\\nGROUP_CONCAT() function returns a string with concatenated non-NULL value from a group.\\n\\nQUERY:\\n\\nSELECT sell_date, \\n    count(DISTINCT product) as num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date \\nORDER BY sell_date;",
                "solutionTags": [],
                "code": "\\nHere we simply selecting the date , number of unique products sold and then we are displaying those products sold in each day using a keyword called \"GROUP_CONCAT\"\\n\\nGROUP CONCAT:\\nGROUP_CONCAT() function returns a string with concatenated non-NULL value from a group.\\n\\nQUERY:\\n\\nSELECT sell_date, \\n    count(DISTINCT product) as num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date \\nORDER BY sell_date;",
                "codeTag": "Unknown"
            },
            {
                "id": 2594165,
                "title": "sql-server-using-stuff-for-xml-path",
                "content": "select \\n    sell_date,\\n    Count(distinct product) num_sold,\\n    stuff(\\n        (\\n            select distinct\\n                \\',\\'+ a1.Product\\n            from\\n                Activities a1\\n            where\\n                a1.sell_date = a.sell_date\\n            for xml path(\\'\\')\\n        ),1,1,\\'\\'\\n    ) products\\nfrom\\n    Activities a\\ngroup by Sell_date",
                "solutionTags": [],
                "code": "select \\n    sell_date,\\n    Count(distinct product) num_sold,\\n    stuff(\\n        (\\n            select distinct\\n                \\',\\'+ a1.Product\\n            from\\n                Activities a1\\n            where\\n                a1.sell_date = a.sell_date\\n            for xml path(\\'\\')\\n        ),1,1,\\'\\'\\n    ) products\\nfrom\\n    Activities a\\ngroup by Sell_date",
                "codeTag": "Unknown"
            },
            {
                "id": 2563048,
                "title": "easy-mysql-solution-with-explanation",
                "content": "Rate me up if my solution was useful for you :)\\n\\n```\\nSELECT\\n    a.sell_date, #1\\n    COUNT(DISTINCT a.product) AS num_sold, #2\\n    GROUP_CONCAT(\\n        DISTINCT a.product ORDER BY a.product SEPARATOR \\',\\' #3\\n    ) AS products\\nFROM Activities a\\nGROUP BY a.sell_date #4\\nORDER BY a.sell_date; #5\\n```\\n\\n1. We simply select *sale date* because it nedeed by problem description.\\n2. We sould count only all **distinct** products in group by *sell date*.\\n3. Now we should query all **distinct** products names by *sell date*  and combine it in a string by comma without spaces in lexicographical order by *product name*. All rows who we combinating already groupped by *sell date* (see point #4).\\n4. Group all selected rows by *sell date*.\\n5. And order all rows by *sell date*.\\n\\nThank you! %)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    a.sell_date, #1\\n    COUNT(DISTINCT a.product) AS num_sold, #2\\n    GROUP_CONCAT(\\n        DISTINCT a.product ORDER BY a.product SEPARATOR \\',\\' #3\\n    ) AS products\\nFROM Activities a\\nGROUP BY a.sell_date #4\\nORDER BY a.sell_date; #5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2499159,
                "title": "solution-in-mysql",
                "content": "```\\nselect sell_date, \\ncount(distinct product) as num_sold, \\n    group_concat(distinct product order by product) as products\\nfrom Activities\\ngroup by sell_date;\\n```",
                "solutionTags": [],
                "code": "```\\nselect sell_date, \\ncount(distinct product) as num_sold, \\n    group_concat(distinct product order by product) as products\\nfrom Activities\\ngroup by sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2493429,
                "title": "mysql-simple-and-clean-solution",
                "content": "**Please Upvote if it helped you !!!**\\n```\\nselect sell_date,\\ncount(distinct product) as num_sold ,\\ngroup_concat(distinct product order by product) as products\\nfrom Activities\\ngroup by sell_date \\norder by sell_date;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date,\\ncount(distinct product) as num_sold ,\\ngroup_concat(distinct product order by product) as products\\nfrom Activities\\ngroup by sell_date \\norder by sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2483556,
                "title": "mysql-solution-faster-than-100-group-concat",
                "content": "```\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464227,
                "title": "mysql-solution-using-group-concat",
                "content": "```\\nselect sell_date,count(distinct product) as num_sold,\\ngroup_concat(distinct product order by product separator \\',\\') as products\\nfrom activities\\ngroup by sell_date\\norder by sell_date;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date,count(distinct product) as num_sold,\\ngroup_concat(distinct product order by product separator \\',\\') as products\\nfrom activities\\ngroup by sell_date\\norder by sell_date;",
                "codeTag": "Unknown"
            },
            {
                "id": 2405525,
                "title": "oracle-using-listagg",
                "content": "SELECT \\n    TO_CHAR(sell_date,\\'yyyy-mm-dd\\') AS sell_date,\\n    COUNT(DISTINCT product) AS num_sold,\\n    LISTAGG(product,\\',\\') WITHIN GROUP (ORDER BY product) AS products \\nFROM (SELECT \\n        DISTINCT sell_date, product FROM activities) \\nGROUP BY sell_date \\nORDER BY sell_date;\\n\\n**Please upvote if you liked the solution**",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "SELECT \\n    TO_CHAR(sell_date,\\'yyyy-mm-dd\\') AS sell_date,\\n    COUNT(DISTINCT product) AS num_sold,\\n    LISTAGG(product,\\',\\') WITHIN GROUP (ORDER BY product) AS products \\nFROM (SELECT \\n        DISTINCT sell_date, product FROM activities) \\nGROUP BY sell_date \\nORDER BY sell_date;\\n\\n**Please upvote if you liked the solution**",
                "codeTag": "Unknown"
            },
            {
                "id": 2390153,
                "title": "mysql-easy-to-read-solution-group-concat-and-count-distinct",
                "content": "```\\nSELECT sell_date,\\nCOUNT(DISTINCT(product)) as num_sold,\\nGROUP_CONCAT(DISTINCT product ORDER BY product SEPARATOR \\',\\') as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date\\n```\\n\\nFirst time using the GROUP_CONCAT function so this answer was tough and required some googling.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date,\\nCOUNT(DISTINCT(product)) as num_sold,\\nGROUP_CONCAT(DISTINCT product ORDER BY product SEPARATOR \\',\\') as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386432,
                "title": "mysql-easy-to-understand-group-concat-distinct",
                "content": "```\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product) AS products FROM Activities GROUP BY sell_date;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product) AS products FROM Activities GROUP BY sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2359160,
                "title": "mysql-group-concat-group-by-count-easy-to-understand",
                "content": "```\\nselect sell_date,\\ncount(distinct(product)) as num_sold,\\ngroup_concat(distinct(product)) as products\\nfrom Activities \\ngroup by sell_date order by sell_date;\\n```",
                "solutionTags": [],
                "code": "```\\nselect sell_date,\\ncount(distinct(product)) as num_sold,\\ngroup_concat(distinct(product)) as products\\nfrom Activities \\ngroup by sell_date order by sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2354721,
                "title": "easiest-solution-with-explanation-mysql-postgresql",
                "content": "```\\n# select sell_data, distinct count of products, concatenate the products in ascending order using a separator\\n# group the data by sell_data in ascending order\\n\\n# MySQL solution\\nSELECT sell_date, count(distinct(product)) as num_sold,\\nGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products \\nFROM activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC;\\n\\n# PostgreSQL solution\\nSELECT sell_date, count(distinct(product)) as num_sold,\\narray_to_string(array_agg(DISTINCT product ORDER BY product ASC), \\',\\') AS products \\nFROM activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# select sell_data, distinct count of products, concatenate the products in ascending order using a separator\\n# group the data by sell_data in ascending order\\n\\n# MySQL solution\\nSELECT sell_date, count(distinct(product)) as num_sold,\\nGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products \\nFROM activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC;\\n\\n# PostgreSQL solution\\nSELECT sell_date, count(distinct(product)) as num_sold,\\narray_to_string(array_agg(DISTINCT product ORDER BY product ASC), \\',\\') AS products \\nFROM activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2272923,
                "title": "mysql-3-lines",
                "content": "```\\nSELECT sell_date, COUNT(DISTINCT(product)) AS num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM Activities\\nGROUP BY sell_date\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT sell_date, COUNT(DISTINCT(product)) AS num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM Activities\\nGROUP BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2243995,
                "title": "funny-solution",
                "content": "```\\n\\nSELECT \\n    sell_date, \\n    COUNT(DISTINCT(product)) AS num_sold, \\n    GROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM \\n    Activities \\nGROUP BY\\n    sell_date;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Go"
                ],
                "code": "```\\n\\nSELECT \\n    sell_date, \\n    COUNT(DISTINCT(product)) AS num_sold, \\n    GROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM \\n    Activities \\nGROUP BY\\n    sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2206666,
                "title": "easy-to-understand-simple-solution",
                "content": "SELECT sell_date, count(DISTINCT product) num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product) products\\nFROM Activities\\nGROUP BY sell_date",
                "solutionTags": [],
                "code": "SELECT sell_date, count(DISTINCT product) num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product) products\\nFROM Activities\\nGROUP BY sell_date",
                "codeTag": "Unknown"
            },
            {
                "id": 2185059,
                "title": "mysql-using-group-concat-group-by-distinct",
                "content": "```\\n# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product order by product) as products\\nfrom activities\\ngroup by sell_date;\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product order by product) as products\\nfrom activities\\ngroup by sell_date;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171881,
                "title": "sql-solution",
                "content": "```\\nselect sell_date, \\ncount(distinct product) as num_sold ,\\ngroup_concat(distinct product) as products\\nfrom activities \\ngroup by sell_date; \\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date, \\ncount(distinct product) as num_sold ,\\ngroup_concat(distinct product) as products\\nfrom activities \\ngroup by sell_date; \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2104409,
                "title": "using-group-concat-and-distinct",
                "content": "select sell_date, count(distinct product) as num_sold, group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date\\n\\ngroup_concat : https://www.w3resource.com/mysql/aggregate-functions-and-grouping/aggregate-functions-and-grouping-group_concat.php\\ndistinct get rid of the duplicate.",
                "solutionTags": [],
                "code": "select sell_date, count(distinct product) as num_sold, group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date\\n\\ngroup_concat : https://www.w3resource.com/mysql/aggregate-functions-and-grouping/aggregate-functions-and-grouping-group_concat.php\\ndistinct get rid of the duplicate.",
                "codeTag": "Unknown"
            },
            {
                "id": 2100743,
                "title": "beginner-friendly-solutions",
                "content": "```\\n# Write your MySQL query statement below\\nselect\\n    sell_date,\\n     count(distinct product) as num_sold,\\n     group_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n    sell_date,\\n     count(distinct product) as num_sold,\\n     group_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053447,
                "title": "using-cte-common-table-expression",
                "content": "/* Write your T-SQL query statement below */\\n\\n\\nWITH a (product, sell_date) AS (\\n    SELECT    \\n        distinct product, sell_date\\n    FROM    \\n        activities)\\n\\n\\nselect sell_date,count(distinct product) as num_sold,\\nSTRING_AGG(product,\\',\\') within group (order by product asc) products\\nfrom a \\ngroup by sell_date\\norder by sell_date asc",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "/* Write your T-SQL query statement below */\\n\\n\\nWITH a (product, sell_date) AS (\\n    SELECT    \\n        distinct product, sell_date\\n    FROM    \\n        activities)\\n\\n\\nselect sell_date,count(distinct product) as num_sold,\\nSTRING_AGG(product,\\',\\') within group (order by product asc) products\\nfrom a \\ngroup by sell_date\\norder by sell_date asc",
                "codeTag": "Unknown"
            },
            {
                "id": 2050076,
                "title": "simple-mysql-solution",
                "content": "Select sell_date, Count(Distinct product) As num_sold, Group_Concat(Distinct product Order By product Separator \\',\\') As products From Activities \\nGroup By sell_date\\nOrder By sell_date;\\n",
                "solutionTags": [],
                "code": "Select sell_date, Count(Distinct product) As num_sold, Group_Concat(Distinct product Order By product Separator \\',\\') As products From Activities \\nGroup By sell_date\\nOrder By sell_date;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2049870,
                "title": "simple-sql-solution",
                "content": "```\\n/* Write your T-SQL query statement below */\\nSELECT \\n  A.sell_date, \\n  COUNT(DISTINCT A.product) num_sold, \\n  STUFF(\\n    (\\n      SELECT \\n        DISTINCT \\',\\' + product \\n      FROM \\n        Activities IA \\n      WHERE \\n        IA.sell_date = A.sell_date FOR XML PATH(\\'\\')\\n    ), \\n    1, \\n    1, \\n    \\'\\'\\n  ) products \\nFROM \\n  Activities A \\nGROUP BY \\n  A.sell_date \\nORDER BY \\n  A.sell_date;\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT \\n  A.sell_date, \\n  COUNT(DISTINCT A.product) num_sold, \\n  STUFF(\\n    (\\n      SELECT \\n        DISTINCT \\',\\' + product \\n      FROM \\n        Activities IA \\n      WHERE \\n        IA.sell_date = A.sell_date FOR XML PATH(\\'\\')\\n    ), \\n    1, \\n    1, \\n    \\'\\'\\n  ) products \\nFROM \\n  Activities A \\nGROUP BY \\n  A.sell_date \\nORDER BY \\n  A.sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032990,
                "title": "mysql-simple",
                "content": "``` \\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product order by product asc) as products\\n\\nfrom Activities\\ngroup by sell_date\\norder by sell_date  \\n``` \\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "``` \\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product order by product asc) as products\\n\\nfrom Activities\\ngroup by sell_date\\norder by sell_date  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2029270,
                "title": "1484-group-sold-products-by-the-date",
                "content": "```\\nSELECT sell_date,\\n       Count(DISTINCT( product ))        AS num_sold,\\n       Group_concat(DISTINCT( product )) AS products\\nFROM   activities\\nGROUP  BY sell_date; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date,\\n       Count(DISTINCT( product ))        AS num_sold,\\n       Group_concat(DISTINCT( product )) AS products\\nFROM   activities\\nGROUP  BY sell_date; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1999654,
                "title": "simple-mysql-solution",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1972352,
                "title": "ms-sql-simple-solution-using-string-agg",
                "content": "```\\nselect sell_date, count(distinct product) as num_sold\\n,(select string_agg(product, \\',\\') within group(order by product) from \\n  (select distinct product from Activities where sell_date = y.sell_date) x) as products    \\nfrom Activities y\\ngroup by sell_date \\norder by sell_date \\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect sell_date, count(distinct product) as num_sold\\n,(select string_agg(product, \\',\\') within group(order by product) from \\n  (select distinct product from Activities where sell_date = y.sell_date) x) as products    \\nfrom Activities y\\ngroup by sell_date \\norder by sell_date \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1964814,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nselect sell_date, count(*) as num_sold, STRING_AGG( product,\\',\\') WITHIN GROUP ( ORDER BY product ASC) as products\\nfrom (select distinct sell_date,product from Activities) as tab\\ngroup by sell_date\\norder by sell_date\\n```\\n**STRING_AGG** is an aggregate function that takes all expressions from rows and concatenates them into a single string.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date, count(*) as num_sold, STRING_AGG( product,\\',\\') WITHIN GROUP ( ORDER BY product ASC) as products\\nfrom (select distinct sell_date,product from Activities) as tab\\ngroup by sell_date\\norder by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1951209,
                "title": "easy-solution-with-explanation",
                "content": "```\\nselect sell_date,\\ncount(distinct(product)) as num_sold,#counting the number of products sold that day sepretly \\ngroup_concat(distinct (product))  as products# to group the product that sold in the same day\\nfrom activities\\ngroup by sell_date\\norder by sell_date\\n```",
                "solutionTags": [],
                "code": "```\\nselect sell_date,\\ncount(distinct(product)) as num_sold,#counting the number of products sold that day sepretly \\ngroup_concat(distinct (product))  as products# to group the product that sold in the same day\\nfrom activities\\ngroup by sell_date\\norder by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488017,
                "title": "using-group-concat",
                "content": "SELECT \\n      sell_date, \\n      COUNT(DISTINCT(product)) AS num_sold,\\n      GROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY 1;",
                "solutionTags": [],
                "code": "SELECT \\n      sell_date, \\n      COUNT(DISTINCT(product)) AS num_sold,\\n      GROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1212779,
                "title": "mysql-never-in-my-life-have-i-needed-group-concat-lol",
                "content": "```sql\\nwith\\n\\n  cte_agg as (\\n    select\\n      sell_date,\\n      count(distinct product) as num_sold,\\n      group_concat(distinct product order by product separator \\',\\') as products\\n    from Activities\\n    group by 1\\n    order by 1\\n  )\\n  \\nselect * from cte_agg\\n```",
                "solutionTags": [],
                "code": "```sql\\nwith\\n\\n  cte_agg as (\\n    select\\n      sell_date,\\n      count(distinct product) as num_sold,\\n      group_concat(distinct product order by product separator \\',\\') as products\\n    from Activities\\n    group by 1\\n    order by 1\\n  )\\n  \\nselect * from cte_agg\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 907776,
                "title": "99-84-faster",
                "content": "SELECT\\n    sell_date, \\n\\tCOUNT(DISTINCT product) AS num_sold, \\n\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM\\n    Activities\\nGROUP BY 1\\nORDER BY 1 ASC\\n",
                "solutionTags": [],
                "code": "SELECT\\n    sell_date, \\n\\tCOUNT(DISTINCT product) AS num_sold, \\n\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM\\n    Activities\\nGROUP BY 1\\nORDER BY 1 ASC\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 830730,
                "title": "mssql-solution-using-string-agg",
                "content": "Select sell_date, count(distinct product) as num_sold , string_agg(product, \\',\\') as products\\nfrom(\\nSelect distinct product, sell_date\\nfrom Activities) a\\ngroup by sell_date",
                "solutionTags": [],
                "code": "Select sell_date, count(distinct product) as num_sold , string_agg(product, \\',\\') as products\\nfrom(\\nSelect distinct product, sell_date\\nfrom Activities) a\\ngroup by sell_date",
                "codeTag": "Unknown"
            },
            {
                "id": 762490,
                "title": "mysql-group-concat-function",
                "content": "```\\n# Write your MySQL query statement below\\nselect sell_date, count(distinct product) as num_sold, \\ngroup_concat(distinct product order by product ASC separator \\',\\') as products from Activities \\ngroup by sell_date\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect sell_date, count(distinct product) as num_sold, \\ngroup_concat(distinct product order by product ASC separator \\',\\') as products from Activities \\ngroup by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 708479,
                "title": "simple-solution-by-using-group-concat",
                "content": "select sell_date, \\ncount(distinct product) as num_sold, \\ngroup_concat(distinct product order by product ASC separator \\',\\') as products from activities\\ngroup by sell_date;",
                "solutionTags": [],
                "code": "select sell_date, \\ncount(distinct product) as num_sold, \\ngroup_concat(distinct product order by product ASC separator \\',\\') as products from activities\\ngroup by sell_date;",
                "codeTag": "Unknown"
            },
            {
                "id": 692982,
                "title": "2-approches-for-mssql-string-agg-and-xml",
                "content": "1. Using the `string_agg` function, this approach is rather straightforward.\\n\\n```\\nselect\\nsell_date\\n, num_sold = count(product)\\n, products = string_agg(product, \\',\\') within group(order by product)\\nfrom \\n(select distinct sell_date, product from Activities) t\\ngroup by sell_date\\norder by sell_date\\n```\\n\\n2. Using the built-in XML syntax.\\nThe tricky part is to \"concatenate\" the sold products on the same day.\\n* Using XML to push all the products into one single row\\n* Using LEFT(XXX, len(XXX)-1) to remove the last comma.\\n\\n\\n```\\nselect\\nsell_date\\n, num_sold = count(distinct product)\\n, products = left(\\n\\t\\t\\t\\t(select distinct product + \\',\\' from Activities A2 where A1.sell_date = A2.sell_date order by 1  for xml path (\\'\\')) \\n\\t\\t\\t\\t,\\n\\t\\t\\t\\tlen((select distinct product + \\',\\' from Activities A2 where A1.sell_date = A2.sell_date order by 1  for xml path (\\'\\'))) -1\\n\\t\\t\\t    )\\nfrom Activities A1\\ngroup by sell_date\\norder by sell_date\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect\\nsell_date\\n, num_sold = count(product)\\n, products = string_agg(product, \\',\\') within group(order by product)\\nfrom \\n(select distinct sell_date, product from Activities) t\\ngroup by sell_date\\norder by sell_date\\n```\n```\\nselect\\nsell_date\\n, num_sold = count(distinct product)\\n, products = left(\\n\\t\\t\\t\\t(select distinct product + \\',\\' from Activities A2 where A1.sell_date = A2.sell_date order by 1  for xml path (\\'\\')) \\n\\t\\t\\t\\t,\\n\\t\\t\\t\\tlen((select distinct product + \\',\\' from Activities A2 where A1.sell_date = A2.sell_date order by 1  for xml path (\\'\\'))) -1\\n\\t\\t\\t    )\\nfrom Activities A1\\ngroup by sell_date\\norder by sell_date\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 692799,
                "title": "mysql-solution-group-concat",
                "content": "select sell_date, \\n    count(distinct product) as num_sold, \\n    group_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date",
                "solutionTags": [],
                "code": "select sell_date, \\n    count(distinct product) as num_sold, \\n    group_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date",
                "codeTag": "Unknown"
            },
            {
                "id": 692797,
                "title": "simple-mysql-solution-most-optimal-faster-than-100",
                "content": "SELECT sell_date, COUNT(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product SEPARATOR \\',\\') AS products\\nFROM Activities \\nGROUP BY sell_date\\nORDER BY sell_date ASC",
                "solutionTags": [],
                "code": "SELECT sell_date, COUNT(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product SEPARATOR \\',\\') AS products\\nFROM Activities \\nGROUP BY sell_date\\nORDER BY sell_date ASC",
                "codeTag": "Unknown"
            },
            {
                "id": 4066344,
                "title": "pandas-easy-explained-step-by-step-group-sold-products-by-the-date",
                "content": "[see the successfully Accepted Solution](https://leetcode.com/submissions/detail/1054010892/)\\n\\n```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    grouped_table = activities.groupby(\\'sell_date\\')\\n    statistics_product =grouped_table.agg(\\n    num_sold=(\\'product\\', \\'nunique\\'),\\n    products=(\\'product\\', lambda x: \\',\\'.join(sorted(x.unique())))\\n)\\n     \\n    statistics_product_index = statistics_product.reset_index()\\n    \\n    return statistics_product_index\\n```\\n\\n\\n\\n**Intuition Explained**\\nFirst, we group the \\'activities\\' DataFrame by the \\'sell_date\\' column. It effectively splits the DataFrame into multiple groups, each corresponding to a unique \\'sell_date\\' value.\\n```\\n    grouped_table = activities.groupby(\\'sell_date\\')\\n```\\n\\nThen we perform aggregation operations on each group created by the \\'sell_date\\'.\\n```\\n    statistics_product =grouped_table.agg(\\n```\\n\\nWe must calculate the number of unique products sold within each group. The result is a new column named \\'num_sold\\' in the statistics_product DataFrame, which represents the count of unique products sold on each \\'sell_date\\'.\\n```\\n    num_sold=(\\'product\\', \\'nunique\\'),\\n```\\n\\nWe must also create a new column named \\'products\\' in the statistics_product which gets the unique values of the \\'product\\' column within each group, sorts the unique product values. and joins the sorted unique product values into a single comma-separated string.\\n```\\n    products=(\\'product\\', lambda x: \\',\\'.join(sorted(x.unique()))))\\n```\\n\\nThen, we remove the current index and assigns a new default integer index to the DataFrame.\\n```\\n    statistics_product_index = statistics_product.reset_index()\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/658b38cc-c1d4-48c7-b194-a10d15fe7b04_1695164239.1172192.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    grouped_table = activities.groupby(\\'sell_date\\')\\n    statistics_product =grouped_table.agg(\\n    num_sold=(\\'product\\', \\'nunique\\'),\\n    products=(\\'product\\', lambda x: \\',\\'.join(sorted(x.unique())))\\n)\\n     \\n    statistics_product_index = statistics_product.reset_index()\\n    \\n    return statistics_product_index\\n```\n```\\n    grouped_table = activities.groupby(\\'sell_date\\')\\n```\n```\\n    statistics_product =grouped_table.agg(\\n```\n```\\n    num_sold=(\\'product\\', \\'nunique\\'),\\n```\n```\\n    products=(\\'product\\', lambda x: \\',\\'.join(sorted(x.unique()))))\\n```\n```\\n    statistics_product_index = statistics_product.reset_index()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4054424,
                "title": "ms-sql-string-agg-within-group",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT\\n    sell_date,\\n    COUNT(DISTINCT product) AS num_sold,\\n    STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n    (SELECT DISTINCT\\n        *\\n    FROM\\n        Activities) subquery\\nGROUP BY\\n    sell_date\\nORDER BY\\n    sell_date\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT\\n    sell_date,\\n    COUNT(DISTINCT product) AS num_sold,\\n    STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n    (SELECT DISTINCT\\n        *\\n    FROM\\n        Activities) subquery\\nGROUP BY\\n    sell_date\\nORDER BY\\n    sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973237,
                "title": "some-shit-beats-86-65-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    activities = activities.drop_duplicates()\\n    size = activities.groupby(\"sell_date\").size().reset_index(name=\\'num_sold\\')\\n    products = activities.groupby(\"sell_date\")[\"product\"].apply(lambda x: \\',\\'.join(sorted(x))).reset_index(name=\\'products\\')\\n    result = pd.merge(size, products, on=\\'sell_date\\')\\n    return result.rename(columns={\"product\": \"products\"}).sort_values(by=\"sell_date\")\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    activities = activities.drop_duplicates()\\n    size = activities.groupby(\"sell_date\").size().reset_index(name=\\'num_sold\\')\\n    products = activities.groupby(\"sell_date\")[\"product\"].apply(lambda x: \\',\\'.join(sorted(x))).reset_index(name=\\'products\\')\\n    result = pd.merge(size, products, on=\\'sell_date\\')\\n    return result.rename(columns={\"product\": \"products\"}).sort_values(by=\"sell_date\")\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3967400,
                "title": "pandas-simple-step-by-step-solution-for-beginners",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    grouped = activities.groupby(\\'sell_date\\')[\\'product\\'].agg([\\'nunique\\', lambda x: \\',\\'.join(sorted(set(x)))]).reset_index()\\n    \\n    grouped.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    \\n    grouped[\\'products\\'] = grouped[\\'products\\'].str.replace(r\\'(^|,)Mask(,|$)\\', r\\'\\\\1Mask\\\\2\\')\\n    \\n    result = grouped.sort_values(by=\\'sell_date\\')\\n    \\n    return result\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    grouped = activities.groupby(\\'sell_date\\')[\\'product\\'].agg([\\'nunique\\', lambda x: \\',\\'.join(sorted(set(x)))]).reset_index()\\n    \\n    grouped.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    \\n    grouped[\\'products\\'] = grouped[\\'products\\'].str.replace(r\\'(^|,)Mask(,|$)\\', r\\'\\\\1Mask\\\\2\\')\\n    \\n    result = grouped.sort_values(by=\\'sell_date\\')\\n    \\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3954766,
                "title": "pandas-vs-sql-easiest-comparison-out-there",
                "content": "I have posted this type of comparison solution for all questions in 30 days of Pandas solutions\\n\\nPandas Code\\n```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    # Group the activities by sell_date and collect the unique products for each date\\n    grouped = activities.groupby(\\'sell_date\\')[\\'product\\'].agg([\\'nunique\\', lambda x: \\',\\'.join(sorted(set(x)))]).reset_index()\\n    \\n    # Rename the columns for clarity\\n    grouped.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    \\n    # Replace variations of \\'Mask\\' with just \\'Mask\\'\\n    grouped[\\'products\\'] = grouped[\\'products\\'].str.replace(r\\'(^|,)Mask(,|$)\\', r\\'\\\\1Mask\\\\2\\')\\n    \\n    # Sort the result table by sell_date\\n    result = grouped.sort_values(by=\\'sell_date\\')\\n    \\n    return result\\n ```\\nSQL Code\\n```\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    # Group the activities by sell_date and collect the unique products for each date\\n    grouped = activities.groupby(\\'sell_date\\')[\\'product\\'].agg([\\'nunique\\', lambda x: \\',\\'.join(sorted(set(x)))]).reset_index()\\n    \\n    # Rename the columns for clarity\\n    grouped.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    \\n    # Replace variations of \\'Mask\\' with just \\'Mask\\'\\n    grouped[\\'products\\'] = grouped[\\'products\\'].str.replace(r\\'(^|,)Mask(,|$)\\', r\\'\\\\1Mask\\\\2\\')\\n    \\n    # Sort the result table by sell_date\\n    result = grouped.sort_values(by=\\'sell_date\\')\\n    \\n    return result\\n ```\n```\\nSELECT sell_date, COUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3953503,
                "title": "t-sql-simple-solution-with-count-string-agg-within",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```sql\\nWITH t AS (SELECT DISTINCT * FROM Activities)\\n\\nSELECT \\n    t.sell_date,\\n    COUNT(t.product) AS num_sold,\\n    STRING_AGG(t.product, \\',\\') WITHIN GROUP (ORDER BY t.product) as products\\nFROM t\\nGROUP BY sell_date\\nORDER BY sell_date\\n```\\n",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```sql\\nWITH t AS (SELECT DISTINCT * FROM Activities)\\n\\nSELECT \\n    t.sell_date,\\n    COUNT(t.product) AS num_sold,\\n    STRING_AGG(t.product, \\',\\') WITHIN GROUP (ORDER BY t.product) as products\\nFROM t\\nGROUP BY sell_date\\nORDER BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946360,
                "title": "using-group-by-and-agg-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n   act_df = activities.groupby(\\'sell_date\\')[\\'product\\'].agg([(\\'num_sold\\', \\'nunique\\'),\\n   (\\'products\\', lambda x: \\',\\'.join(sorted(x.unique())))]).reset_index()\\n   return act_df\\n   \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n   act_df = activities.groupby(\\'sell_date\\')[\\'product\\'].agg([(\\'num_sold\\', \\'nunique\\'),\\n   (\\'products\\', lambda x: \\',\\'.join(sorted(x.unique())))]).reset_index()\\n   return act_df\\n   \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3913822,
                "title": "pandas-solution-3-steps",
                "content": "# Approach\\nGroup by `sell_date`, and join the resulting strings with the comma character `\\',\\'`.\\n\\nAdd a new column `num_sold`, which counts the different strings between commas.\\n\\nRename the `product` column to `products`, sort by `sell_date` and return the DataFrame with the required ordered columns.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    acts = activities.groupby(\\'sell_date\\')[\\'product\\'].apply(lambda x: \\',\\'.join(sorted(x.unique()))).reset_index()\\n    acts[\\'num_sold\\'] = acts[\\'product\\'].apply(lambda x: len(x.split(\\',\\')))\\n    acts = acts.rename(columns={\\'product\\': \\'products\\'}).sort_values(by=[\\'sell_date\\'], ascending=True)\\n    return acts[[\\'sell_date\\', \\'num_sold\\', \\'products\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    acts = activities.groupby(\\'sell_date\\')[\\'product\\'].apply(lambda x: \\',\\'.join(sorted(x.unique()))).reset_index()\\n    acts[\\'num_sold\\'] = acts[\\'product\\'].apply(lambda x: len(x.split(\\',\\')))\\n    acts = acts.rename(columns={\\'product\\': \\'products\\'}).sort_values(by=[\\'sell_date\\'], ascending=True)\\n    return acts[[\\'sell_date\\', \\'num_sold\\', \\'products\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3890569,
                "title": "slow-but-with-relatively-low-memory-usage",
                "content": "# Intuition\\nWe need to find the number of different products sold and their names for each date. To achieve this, we group the `Activities` table by `sell_date` and aggregate the products as a set to ensure uniqueness. Then, we calculate the number of sold products and sort the products within each set lexicographically.\\n\\n# Approach\\n1. Group the `activities` dataframe by `sell_date`.\\n2. For each group, aggregate the products as a set using the `apply(set)` function on the \\'product\\' column.\\n3. Reset the index of the resulting dataframe to include the \\'sell_date\\' column.\\n4. Calculate the number of sold products by applying the `len` function on the \\'product\\' sets.\\n5. Sort the products within each set lexicographically by applying the `sorted` function and joining them with a comma using the `join` function.\\n6. Return the resulting dataframe with the \\'sell_date\\', \\'num_sold\\', and \\'product\\' columns.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity depends on the size of the `activities` dataframe and the group and aggregate operations. The overall complexity is linear with respect to the number of rows in the dataframe.\\n\\n- Space complexity:\\nThe space complexity is linear as we create intermediate dataframes and the resulting dataframe that depend on the input size.\\n# Code\\n```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    # Group the activities dataframe by sell_date and aggregate the products as unique set\\n    grouped = activities.groupby(\\'sell_date\\')[\\'product\\'].apply(set).reset_index()\\n    \\n    # Calculate the number of sold products for each date\\n    grouped[\\'num_sold\\'] = grouped[\\'product\\'].apply(len)\\n    \\n    # Sort the products within each set\\n    grouped[\\'products\\'] = grouped[\\'product\\'].apply(lambda x: \\',\\'.join(sorted(x)))\\n    \\n    # Return the result with only the required columns\\n    return grouped[[\\'sell_date\\', \\'num_sold\\', \\'products\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    # Group the activities dataframe by sell_date and aggregate the products as unique set\\n    grouped = activities.groupby(\\'sell_date\\')[\\'product\\'].apply(set).reset_index()\\n    \\n    # Calculate the number of sold products for each date\\n    grouped[\\'num_sold\\'] = grouped[\\'product\\'].apply(len)\\n    \\n    # Sort the products within each set\\n    grouped[\\'products\\'] = grouped[\\'product\\'].apply(lambda x: \\',\\'.join(sorted(x)))\\n    \\n    # Return the result with only the required columns\\n    return grouped[[\\'sell_date\\', \\'num_sold\\', \\'products\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3806677,
                "title": "using-group-concat",
                "content": "# Approach\\nThe query first groups the `Activities` table by the `sell_date` column. This means that the query will produce one row for each unique date in the `Activities` table.\\n\\nThe query then uses the `COUNT()` function to count the number of `distinct` products sold on each date. The `DISTINCT` keyword ensures that the query only counts each product once.\\n\\nThe query then uses the GROUP_CONCAT() function to concatenate a list of the `distinct `products sold on each date. The `ORDER BY` clause ensures that the list of products is sorted alphabetically. The separator parameter specifies that the products should be separated by `commas`.\\n\\nFinally, the query orders the results by the sell_date column in ascending order.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT sell_date, COUNT( DISTINCT product ) AS num_sold ,    \\nGROUP_CONCAT( DISTINCT product ORDER BY product ASC   ) AS products   \\nFROM Activities GROUP BY sell_date ORDER BY sell_date ASC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT sell_date, COUNT( DISTINCT product ) AS num_sold ,    \\nGROUP_CONCAT( DISTINCT product ORDER BY product ASC   ) AS products   \\nFROM Activities GROUP BY sell_date ORDER BY sell_date ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786579,
                "title": "sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect sell_date, count(distinct product) as num_sold, \\nGROUP_CONCAT(distinct product order by product ASC separator \\',\\') products\\nfrom Activities\\ngroup by sell_date order by sell_Date ASC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect sell_date, count(distinct product) as num_sold, \\nGROUP_CONCAT(distinct product order by product ASC separator \\',\\') products\\nfrom Activities\\ngroup by sell_date order by sell_Date ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587176,
                "title": "attention-coders-optimum-approach-step-by-step-explanation-with-beats-85",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe goal of the problem is to group the sold products based on the date they were sold. We need to count the number of distinct products sold on each sell_date and create a list of distinct products for each sell_date.\\n\\n# Approach\\n1. The first step is to specify the columns we want to include in the result. In this case, we need the sell_date, the number of distinct products sold on each sell_date (num_sold), and a list of distinct products sold on each sell_date (products).\\n\\n1. To calculate the number of distinct products sold on each sell_date, we use the **COUNT(DISTINCT product)** function. This function counts the number of unique (distinct) values in the \"product\" column. We assign this count the alias \"num_sold\" so that we can refer to it later.\\n\\n1. To create a list of distinct products sold on each sell_date, we use the **GROUP_CONCAT(DISTINCT product)** function. This function concatenates the distinct values in the \"product\" column into a comma-separated string. We assign this string the alias \"products\".\\n\\n1. We specify the \"FROM\" clause to indicate the table from which we want to retrieve the data. In this case, the table is \"Activities\".\\n\\n1. To group the result by sell_date, we use the \"GROUP BY\" clause. This means that the rows with the same sell_date will be grouped together.\\n\\n1. Finally, we use the \"ORDER BY\" clause to sort the result in ascending order based on the sell_date. This ensures that the output is arranged in chronological order.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of your solution depends on the size of the Activities table and the number of distinct sell_dates. The query needs to scan through the Activities table to calculate the counts and concatenate the products for each sell_date. Therefore, the time complexity is typically $$O(n)$$, where n is the number of rows in the Activities table.\\n\\n- Space complexity:\\nThe space complexity is influenced by the number of distinct sell_dates and the number of distinct products sold. The query uses additional memory to store the intermediate results, including the distinct products and their counts. Therefore, the space complexity is $$O(m)$$, where m is the number of distinct sell_dates.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n`SELECT sell_date, \\n  count(distinct product) AS num_sold,\\n  group_concat(distinct product) AS products \\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date`\\n\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/38b9ca96-481f-43db-b597-728d5f94ccfb_1685647313.7010021.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n`SELECT sell_date, \\n  count(distinct product) AS num_sold,\\n  group_concat(distinct product) AS products \\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date`\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3077601,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT  \\n\\tsell_date,\\n\\t(COUNT(sell_date ) ) as num_sold ,\\n\\tGROUP_CONCAT(distinct product  ORDER BY product) as products \\nFROM \\n\\t(SELECT DISTINCT sell_date,product FROM Activities) as Activities\\nGROUP BY sell_date;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT  \\n\\tsell_date,\\n\\t(COUNT(sell_date ) ) as num_sold ,\\n\\tGROUP_CONCAT(distinct product  ORDER BY product) as products \\nFROM \\n\\t(SELECT DISTINCT sell_date,product FROM Activities) as Activities\\nGROUP BY sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937351,
                "title": "89-faster-clean-2-ways-solution",
                "content": "### UPVOTE if like\\n\\n\\n### way 1\\n```\\n\\nselect sell_date, count( DISTINCT product ) as num_sold ,\\n    \\n    GROUP_CONCAT( DISTINCT product order by product ASC separator \\',\\' ) as products\\n    \\n        FROM Activities GROUP BY sell_date order by sell_date ASC;\\n\\n```\\n\\n### way 2\\n\\n``` \\nSELECT \\n    sell_date, \\n    COUNT(DISTINCT product) as num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n```\\n![60d33be8cf4ba7565123c8bc_YPD3ulQQAGQpOcnqIm3QzSTRgzmr1SexpW9ZjMpJ1mAnUxx4iF05XOTu44sk0qQG-8XgBcYmGZGAD-5SAZvJl3TjtmhgWnn-w0C2XKwhBscV78RVvhwZfyp0v_Pa6sNj5zxpOvRW.png](https://assets.leetcode.com/users/images/b1c219d7-60a7-4386-86cd-ccd57a7bcc56_1671676735.14143.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nselect sell_date, count( DISTINCT product ) as num_sold ,\\n    \\n    GROUP_CONCAT( DISTINCT product order by product ASC separator \\',\\' ) as products\\n    \\n        FROM Activities GROUP BY sell_date order by sell_date ASC;\\n\\n```\n``` \\nSELECT \\n    sell_date, \\n    COUNT(DISTINCT product) as num_sold,\\n    GROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2917714,
                "title": "easy-understanding-beginners-method-mysql",
                "content": "The key is using group_concat function\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect sell_date, count(distinct product) \\'num_sold\\', group_concat(distinct product) \\'products\\' from activities group by 1 order by 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect sell_date, count(distinct product) \\'num_sold\\', group_concat(distinct product) \\'products\\' from activities group by 1 order by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2841016,
                "title": "mysql-solution",
                "content": "```\\nselect sell_date, count(DISTINCT product) as num_sold ,\\n    GROUP_CONCAT(DISTINCT product order by product ASC separator \\',\\') as products\\nFROM Activities GROUP BY sell_date order by sell_date ASC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date, count(DISTINCT product) as num_sold ,\\n    GROUP_CONCAT(DISTINCT product order by product ASC separator \\',\\') as products\\nFROM Activities GROUP BY sell_date order by sell_date ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2746614,
                "title": "group-sold-products-by-the-date-mysql",
                "content": "```\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2682580,
                "title": "mysql-solution-using-group-concat-keyword-simple-and-easy",
                "content": "```\\nselect sell_date,\\ncount(distinct(product)) as num_sold, \\nGROUP_CONCAT(distinct(product) order by product SEPARATOR \\',\\') as products\\nfrom activities\\ngroup by sell_date\\norder by sell_date;\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date,\\ncount(distinct(product)) as num_sold, \\nGROUP_CONCAT(distinct(product) order by product SEPARATOR \\',\\') as products\\nfrom activities\\ngroup by sell_date\\norder by sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2634369,
                "title": "fast-easy-solution",
                "content": "select distinct sell_date, count(distinct product) as num_sold,  group_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date",
                "solutionTags": [],
                "code": "select distinct sell_date, count(distinct product) as num_sold,  group_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date\\norder by sell_date",
                "codeTag": "Unknown"
            },
            {
                "id": 2634099,
                "title": "group-concat-separator",
                "content": "SELECT sell_date, COUNT(DISTINCT product) AS num_sold , \\nGROUP_CONCAT(DISTINCT product ORDER BY product separator \",\") AS products\\n\\n\\nFROM Activities\\n\\nGROUP BY sell_date",
                "solutionTags": [],
                "code": "SELECT sell_date, COUNT(DISTINCT product) AS num_sold , \\nGROUP_CONCAT(DISTINCT product ORDER BY product separator \",\") AS products\\n\\n\\nFROM Activities\\n\\nGROUP BY sell_date",
                "codeTag": "Unknown"
            },
            {
                "id": 2611410,
                "title": "group-concat",
                "content": "### This can be solved using group concat\\n\\n```\\nselect sell_date, count(distinct product) as num_sold, GROUP_CONCAT(DISTINCT product order by product ASC) as products from Activities  group by sell_date;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date, count(distinct product) as num_sold, GROUP_CONCAT(DISTINCT product order by product ASC) as products from Activities  group by sell_date;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607397,
                "title": "leetcode-1484-learn-the-concept-with-the-answer",
                "content": "In MySQL, you can concatenate data from numerous rows into a single field using the GROUP CONCAT() function.\\n\\n```\\nselect sell_date, count(distinct product) as num_sold, group_concat(distinct product order by product) as products from activities group by sell_date; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect sell_date, count(distinct product) as num_sold, group_concat(distinct product order by product) as products from activities group by sell_date; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2604305,
                "title": "simple-solution-using-group-by",
                "content": "SELECT sell_date,count(distinct product) as num_sold ,GROUP_CONCAT(distinct product ORDER BY product) as products From Activities \\ngroup by sell_date\\norder by sell_date;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT sell_date,count(distinct product) as num_sold ,GROUP_CONCAT(distinct product ORDER BY product) as products From Activities \\ngroup by sell_date\\norder by sell_date;",
                "codeTag": "Unknown"
            },
            {
                "id": 2565071,
                "title": "mysql-group-concat-with-group-by-63",
                "content": "```\\nselect  \\nsell_date, count( distinct product) as num_sold, group_concat(distinct product) as products \\nfrom activities \\ngroup by sell_date;           \\n```",
                "solutionTags": [],
                "code": "```\\nselect  \\nsell_date, count( distinct product) as num_sold, group_concat(distinct product) as products \\nfrom activities \\ngroup by sell_date;           \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555820,
                "title": "easy-solution-with-group-concat-group-by",
                "content": "![image](https://assets.leetcode.com/users/images/8045b875-d2e3-4393-aa3f-e714b85c77b5_1662925653.5336535.png)\\n\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/8045b875-d2e3-4393-aa3f-e714b85c77b5_1662925653.5336535.png)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2555771,
                "title": "simple-solution-using-string-agg-sql-server",
                "content": "```\\nselect t.sell_date, count(t.product) as num_sold, \\nSTRING_AGG(t.product, \\',\\') within group(order by t.product) as products \\nfrom (select distinct product, sell_date from Activities) t \\ngroup by t.sell_date order by t.sell_date;\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect t.sell_date, count(t.product) as num_sold, \\nSTRING_AGG(t.product, \\',\\') within group(order by t.product) as products \\nfrom (select distinct product, sell_date from Activities) t \\ngroup by t.sell_date order by t.sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552246,
                "title": "mysql-solution",
                "content": "```\\n# Write your MySQL query statement below\\n# GROUP_CONCAT( DISTINCT product order by product ASC separator \\',\\' ) \\n# function is used to concatenate data from multiple rows into one field\\n\\n\\nselect sell_date, count( DISTINCT product ) as num_sold ,\\nGROUP_CONCAT( DISTINCT product ORDER BY product ASC SEPARATOR \\',\\' ) AS products\\nFROM Activities \\nGROUP BY sell_date \\nORDER BY sell_date ASC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# GROUP_CONCAT( DISTINCT product order by product ASC separator \\',\\' ) \\n# function is used to concatenate data from multiple rows into one field\\n\\n\\nselect sell_date, count( DISTINCT product ) as num_sold ,\\nGROUP_CONCAT( DISTINCT product ORDER BY product ASC SEPARATOR \\',\\' ) AS products\\nFROM Activities \\nGROUP BY sell_date \\nORDER BY sell_date ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551962,
                "title": "mysql-easy",
                "content": "```\\nselect\\n    sell_date, \\n    count(distinct product) as num_sold, \\n    group_concat(distinct product order by product) as products\\nfrom Activities\\ngroup by sell_date\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    sell_date, \\n    count(distinct product) as num_sold, \\n    group_concat(distinct product order by product) as products\\nfrom Activities\\ngroup by sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531043,
                "title": "mysql-simple-solution",
                "content": "***\\nSELECT a.sell_date, COUNT(DISTINCT a.product) AS num_sold,\\nGROUP_CONCAT(DISTINCT a.product ORDER BY a.product) as products\\nFROM Activities a\\nGROUP By sell_date\\nORDER BY sell_date\\n***",
                "solutionTags": [],
                "code": "***\\nSELECT a.sell_date, COUNT(DISTINCT a.product) AS num_sold,\\nGROUP_CONCAT(DISTINCT a.product ORDER BY a.product) as products\\nFROM Activities a\\nGROUP By sell_date\\nORDER BY sell_date\\n***",
                "codeTag": "Unknown"
            },
            {
                "id": 2521999,
                "title": "neat-and-easy-solution",
                "content": "**#Solution**\\n\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**#Solution**\\n\\nSELECT sell_date,\\n\\t\\tCOUNT(DISTINCT(product)) AS num_sold, \\n\\t\\tGROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR \\',\\') AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC;",
                "codeTag": "Unknown"
            },
            {
                "id": 2517931,
                "title": "mysql-using-group-concat",
                "content": "**MY SQL:**\\n\\n```\\nSELECT sell_date, count(distinct(product)) as num_sold, \\nGroup_Concat(distinct(product) order by product) as products\\nFROM Activities \\nGroup by sell_date \\nOrder by sell_date;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT sell_date, count(distinct(product)) as num_sold, \\nGroup_Concat(distinct(product) order by product) as products\\nFROM Activities \\nGroup by sell_date \\nOrder by sell_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492329,
                "title": "faster-than-90-75-of-mysql-online-submissions",
                "content": "```\\nSELECT sell_date, \\nCOUNT(DISTINCT product) AS num_sold, \\nGROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM activities\\nGROUP BY sell_date ORDER BY sell_date ASC;",
                "solutionTags": [],
                "code": "```\\nSELECT sell_date, \\nCOUNT(DISTINCT product) AS num_sold, \\nGROUP_CONCAT(DISTINCT product ORDER BY product ASC) AS products\\nFROM activities\\nGROUP BY sell_date ORDER BY sell_date ASC;",
                "codeTag": "Unknown"
            },
            {
                "id": 2472864,
                "title": "mysql",
                "content": "```\\nSELECT sell_date, \\nCOUNT(DISTINCT(product)) AS num_sold,\\nGROUP_CONCAT(DISTINCT(product))AS products\\nFROM Activities\\nGROUP BY sell_date\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT sell_date, \\nCOUNT(DISTINCT(product)) AS num_sold,\\nGROUP_CONCAT(DISTINCT(product))AS products\\nFROM Activities\\nGROUP BY sell_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2472332,
                "title": "group-sold-products-by-date",
                "content": "# Write your MySQL query statement below\\n```\\nselect sell_date, count(distinct(product)) as num_sold, group_concat(distinct(product) order by product) as products\\nfrom Activities\\ngroup by sell_date\\n```",
                "solutionTags": [],
                "code": "```\\nselect sell_date, count(distinct(product)) as num_sold, group_concat(distinct(product) order by product) as products\\nfrom Activities\\ngroup by sell_date\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1577002,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1567768,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1729660,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1684046,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 2017214,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 2004774,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1576946,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 2008235,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1576784,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1576881,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1577002,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1567768,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1729660,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1684046,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 2017214,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 2004774,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1576946,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 2008235,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1576784,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1576881,
                "content": [
                    {
                        "username": "25ajeet",
                        "content": "EXPLANATION\\nGROUP CONCAT is the function in mySQL which returns the row values in the comma separated fashion. Rest of the idea is pretty conventional.\\nPlease post your query/concerns/doubts over here in the comment section, will try to respond.\\nPLEASE UPVOTE.\\n\\nQuery, you may find below:\\n\\nSELECT sell_date, COUNT(DISTINCT product) as \\'num_sold\\', \\nGROUP_CONCAT(DISTINCT product ORDER BY product) AS \\'products\\'\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "user7938G",
                        "content": "[@cafe28](/cafe28)  because in query it is said that we need to find the number of product sold by sell_date. So, we need to group all the item sold on that Particular date. I hope u got it. "
                    },
                    {
                        "username": "cafe28",
                        "content": "Hey this is great, can you just explain why the GROUP BY at the end?"
                    },
                    {
                        "username": "htiwari313",
                        "content": "The solution is:\\n\\n\\tselect \\n\\tsell_date, count(distinct product) as num_sold, \\n\\tgroup_concat(distinct product) as products \\n\\tfrom activities \\n\\tgroup by sell_date;"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "Please don\\'t post solutions in the discussions."
                    },
                    {
                        "username": "stalsams",
                        "content": "Solution in MS SQL Server:\\n\\nwith cte_distinct as\\n(\\n    select distinct sell_date, product\\n    from activities\\n)\\nselect sell_date,\\n       count(product) as num_sold,\\n       string_agg(product, \\',\\') WITHIN GROUP (ORDER BY product)  as products\\nfrom cte_distinct\\ngroup by sell_date\\norder by sell_date"
                    },
                    {
                        "username": "rohitsharma740431",
                        "content": "How to implement the query in MS SQL Server ?\\n"
                    },
                    {
                        "username": "krishnamohanvr",
                        "content": "SELECT sell_date,\\n    COUNT(1) AS num_sold,\\n    STRING_AGG(product,\\',\\') as products\\nFROM (\\nSELECT sell_date,\\n    product\\nFROM Activities\\nGROUP BY sell_date,\\n    product\\n) AS T1\\nGROUP BY sell_date"
                    },
                    {
                        "username": "saiiitkgp713",
                        "content": "SELECT  sell_date,\\n        COUNT(product) AS num_sold,\\n        STRING_AGG(product, \\',\\') WITHIN GROUP (ORDER BY product) AS products\\nFROM\\n(SELECT DISTINCT sell_date, product\\nFROM Activities) t\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "With this code I\\'m getting identical output to the expected output in the test case given by the question, however it is marked as wrong, what could be going on? \\n\\n```def categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    lists = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].unique()\\n    lists[\\'product\\'] = lists[\\'product\\'].apply(lambda x: sorted(x))\\n    counts = activities.groupby([\\'sell_date\\'], as_index = False)[\\'product\\'].nunique()\\n    return pd.DataFrame({\"sell_date\": counts[\\'sell_date\\'], \\'num_sold\\':counts[\\'product\\'], \\'products\\':lists[\\'product\\']})```\\n\\n"
                    },
                    {
                        "username": "JuanKarim",
                        "content": "[@mshao](/mshao) Thank you, that was it. "
                    },
                    {
                        "username": "mshao",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "therealchainman",
                        "content": "I\\'m getting same issue, same output but says it is wrong answer."
                    },
                    {
                        "username": "APTUUU",
                        "content": "Help!\\nIt keeps giving me Wrong Answer but the Output matches exactly the Expected.\\nHere\\'s the code:\\n\\ndef sort(val):\\n    return sorted(val)\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    \\n    activities = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\', \\'unique\\']}).reset_index()\\n    activities.columns = [\\'sell_date\\', \\'num_sold\\', \\'products\\']\\n    activities.products = activities.products.apply(sort)\\n    return activities.sort_values(\\'sell_date\\', ascending=True)\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Here is a trouble with type of column \\'products\\'. This column should has type list<str>"
                    },
                    {
                        "username": "Anchal_Gupta04",
                        "content": "# Write your MySQL query statement below\\n\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;"
                    },
                    {
                        "username": "rds95",
                        "content": "Does anyone know why the following solution is not accepted? The output seems to match the expected output exactly.\\n\\n    activities = activities.sort_values(\"product\")\\n\\n    df = activities.groupby(\"sell_date\", as_index=False).agg({\"product\":[\"nunique\",\"unique\"]})\\n\\n    df.columns =[[\"sell_date\",\"num_sold\",\"products\"]]\\n\\n    return df`"
                    },
                    {
                        "username": "BeCharge",
                        "content": "the type of \\'products\\' should be string instead of list of string use \\',\\'.join() for \\'products\\' column"
                    },
                    {
                        "username": "nkalash",
                        "content": "GROUP_CONCAT() fn returns a string with non-null value from a group.\\n\\'\\'\\'\\nSELECT sell_date,\\nCOUNT(DISTINCT product) AS num_sold,\\nGROUP_CONCAT(DISTINCT product) AS products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date,products\\n\\'\\'\\'"
                    },
                    {
                        "username": "kumarakash",
                        "content": "# Write your MySQL query statement below\\nselect sell_date,count(distinct product) as num_sold,GROUP_CONCAT(distinct product) products from Activities group by sell_date order by sell_date;"
                    }
                ]
            },
            {
                "id": 1576690,
                "content": [
                    {
                        "username": "ankitabagaria",
                        "content": "# Write your MySQL query statement below\\nSELECT sell_date, COUNT(distinct product) AS num_sold, \\nGROUP_CONCAT(distinct product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date;"
                    },
                    {
                        "username": "Anthonysutherland21",
                        "content": "\\'\\'\\'\\nselect b.sell_date, b.num_sold, GROUP_CONCAT(DISTINCT product) as products from Activities as a \\njoin\\n(select sell_date, count(DISTINCT product) as \\'num_sold\\' from Activities\\ngroup by sell_date) as b\\non a.sell_date = b.sell_date\\ngroup by b.sell_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "manojrk28",
                        "content": "import pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    df= activities\\n    df=df.groupby(\\'sell_date\\')[\\'product\\'].agg(num_sold=\\'nunique\\',products=\\'unique\\').reset_index()\\n    df[\\'products\\']=df[\\'products\\'].apply(lambda x: sorted(x))\\n    return df\\n\\n\\ncan anyone tell why this cod is not correct in testcase even giving correct reasult\\n"
                    },
                    {
                        "username": "naldoyohardi992",
                        "content": "Is there another solution for MYSQL without using STRING_AGG() or GROUP_CONCAT() ?"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "If I don\\'t add the DISTINCT clause in GROUP_CONCAT, it returns multiple records repeated, even if the count is just one.\\nExample : \"Mask,Mask\", when there\\'s just 1 Mask sold on that date.\\nCan anyone explaiin why does it behaves so"
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "OUTPUT = Expected but still wrong?  WHY?\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    gr = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\',\\'unique\\']}).reset_index()\\n    gr.columns = [\\'sell_date\\',\\'num_sold\\',\\'products\\']\\n    gr[\\'products\\'] = gr[\\'products\\'].apply(sorted)\\n    return gr\\n\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Some troubles with pandas:\\nColumn \\'products\\' has type list<str>, but if yours output dataframe has different type then you will get exception and tests will not let you go. To fix this just a cast \\'products\\' to list<str>)"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. \"products\" must be a sring!"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the groupby() function along with the agg() function to group the data by \\'sell_date\\' and then aggregate the product names into a list. After that, you can calculate the number of different products sold using the length of the list. Finally, sort the product names lexicographically and join them using commas. Make sure to sort the result by \\'sell_date\\'"
                    },
                    {
                        "username": "geetika_shekhawat",
                        "content": "Use GROUP_CONCAT function to get comma separated product list as products :\n\nselect sell_date , count(distinct product) as num_sold , group_concat(distinct product ) as products\nfrom activities\ngroup by sell_date\norder by sell_date"
                    }
                ]
            },
            {
                "id": 1574288,
                "content": [
                    {
                        "username": "ankitabagaria",
                        "content": "# Write your MySQL query statement below\\nSELECT sell_date, COUNT(distinct product) AS num_sold, \\nGROUP_CONCAT(distinct product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date;"
                    },
                    {
                        "username": "Anthonysutherland21",
                        "content": "\\'\\'\\'\\nselect b.sell_date, b.num_sold, GROUP_CONCAT(DISTINCT product) as products from Activities as a \\njoin\\n(select sell_date, count(DISTINCT product) as \\'num_sold\\' from Activities\\ngroup by sell_date) as b\\non a.sell_date = b.sell_date\\ngroup by b.sell_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "manojrk28",
                        "content": "import pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    df= activities\\n    df=df.groupby(\\'sell_date\\')[\\'product\\'].agg(num_sold=\\'nunique\\',products=\\'unique\\').reset_index()\\n    df[\\'products\\']=df[\\'products\\'].apply(lambda x: sorted(x))\\n    return df\\n\\n\\ncan anyone tell why this cod is not correct in testcase even giving correct reasult\\n"
                    },
                    {
                        "username": "naldoyohardi992",
                        "content": "Is there another solution for MYSQL without using STRING_AGG() or GROUP_CONCAT() ?"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "If I don\\'t add the DISTINCT clause in GROUP_CONCAT, it returns multiple records repeated, even if the count is just one.\\nExample : \"Mask,Mask\", when there\\'s just 1 Mask sold on that date.\\nCan anyone explaiin why does it behaves so"
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "OUTPUT = Expected but still wrong?  WHY?\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    gr = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\',\\'unique\\']}).reset_index()\\n    gr.columns = [\\'sell_date\\',\\'num_sold\\',\\'products\\']\\n    gr[\\'products\\'] = gr[\\'products\\'].apply(sorted)\\n    return gr\\n\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Some troubles with pandas:\\nColumn \\'products\\' has type list<str>, but if yours output dataframe has different type then you will get exception and tests will not let you go. To fix this just a cast \\'products\\' to list<str>)"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. \"products\" must be a sring!"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the groupby() function along with the agg() function to group the data by \\'sell_date\\' and then aggregate the product names into a list. After that, you can calculate the number of different products sold using the length of the list. Finally, sort the product names lexicographically and join them using commas. Make sure to sort the result by \\'sell_date\\'"
                    },
                    {
                        "username": "geetika_shekhawat",
                        "content": "Use GROUP_CONCAT function to get comma separated product list as products :\n\nselect sell_date , count(distinct product) as num_sold , group_concat(distinct product ) as products\nfrom activities\ngroup by sell_date\norder by sell_date"
                    }
                ]
            },
            {
                "id": 2059979,
                "content": [
                    {
                        "username": "ankitabagaria",
                        "content": "# Write your MySQL query statement below\\nSELECT sell_date, COUNT(distinct product) AS num_sold, \\nGROUP_CONCAT(distinct product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date;"
                    },
                    {
                        "username": "Anthonysutherland21",
                        "content": "\\'\\'\\'\\nselect b.sell_date, b.num_sold, GROUP_CONCAT(DISTINCT product) as products from Activities as a \\njoin\\n(select sell_date, count(DISTINCT product) as \\'num_sold\\' from Activities\\ngroup by sell_date) as b\\non a.sell_date = b.sell_date\\ngroup by b.sell_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "manojrk28",
                        "content": "import pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    df= activities\\n    df=df.groupby(\\'sell_date\\')[\\'product\\'].agg(num_sold=\\'nunique\\',products=\\'unique\\').reset_index()\\n    df[\\'products\\']=df[\\'products\\'].apply(lambda x: sorted(x))\\n    return df\\n\\n\\ncan anyone tell why this cod is not correct in testcase even giving correct reasult\\n"
                    },
                    {
                        "username": "naldoyohardi992",
                        "content": "Is there another solution for MYSQL without using STRING_AGG() or GROUP_CONCAT() ?"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "If I don\\'t add the DISTINCT clause in GROUP_CONCAT, it returns multiple records repeated, even if the count is just one.\\nExample : \"Mask,Mask\", when there\\'s just 1 Mask sold on that date.\\nCan anyone explaiin why does it behaves so"
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "OUTPUT = Expected but still wrong?  WHY?\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    gr = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\',\\'unique\\']}).reset_index()\\n    gr.columns = [\\'sell_date\\',\\'num_sold\\',\\'products\\']\\n    gr[\\'products\\'] = gr[\\'products\\'].apply(sorted)\\n    return gr\\n\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Some troubles with pandas:\\nColumn \\'products\\' has type list<str>, but if yours output dataframe has different type then you will get exception and tests will not let you go. To fix this just a cast \\'products\\' to list<str>)"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. \"products\" must be a sring!"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the groupby() function along with the agg() function to group the data by \\'sell_date\\' and then aggregate the product names into a list. After that, you can calculate the number of different products sold using the length of the list. Finally, sort the product names lexicographically and join them using commas. Make sure to sort the result by \\'sell_date\\'"
                    },
                    {
                        "username": "geetika_shekhawat",
                        "content": "Use GROUP_CONCAT function to get comma separated product list as products :\n\nselect sell_date , count(distinct product) as num_sold , group_concat(distinct product ) as products\nfrom activities\ngroup by sell_date\norder by sell_date"
                    }
                ]
            },
            {
                "id": 2048549,
                "content": [
                    {
                        "username": "ankitabagaria",
                        "content": "# Write your MySQL query statement below\\nSELECT sell_date, COUNT(distinct product) AS num_sold, \\nGROUP_CONCAT(distinct product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date;"
                    },
                    {
                        "username": "Anthonysutherland21",
                        "content": "\\'\\'\\'\\nselect b.sell_date, b.num_sold, GROUP_CONCAT(DISTINCT product) as products from Activities as a \\njoin\\n(select sell_date, count(DISTINCT product) as \\'num_sold\\' from Activities\\ngroup by sell_date) as b\\non a.sell_date = b.sell_date\\ngroup by b.sell_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "manojrk28",
                        "content": "import pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    df= activities\\n    df=df.groupby(\\'sell_date\\')[\\'product\\'].agg(num_sold=\\'nunique\\',products=\\'unique\\').reset_index()\\n    df[\\'products\\']=df[\\'products\\'].apply(lambda x: sorted(x))\\n    return df\\n\\n\\ncan anyone tell why this cod is not correct in testcase even giving correct reasult\\n"
                    },
                    {
                        "username": "naldoyohardi992",
                        "content": "Is there another solution for MYSQL without using STRING_AGG() or GROUP_CONCAT() ?"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "If I don\\'t add the DISTINCT clause in GROUP_CONCAT, it returns multiple records repeated, even if the count is just one.\\nExample : \"Mask,Mask\", when there\\'s just 1 Mask sold on that date.\\nCan anyone explaiin why does it behaves so"
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "OUTPUT = Expected but still wrong?  WHY?\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    gr = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\',\\'unique\\']}).reset_index()\\n    gr.columns = [\\'sell_date\\',\\'num_sold\\',\\'products\\']\\n    gr[\\'products\\'] = gr[\\'products\\'].apply(sorted)\\n    return gr\\n\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Some troubles with pandas:\\nColumn \\'products\\' has type list<str>, but if yours output dataframe has different type then you will get exception and tests will not let you go. To fix this just a cast \\'products\\' to list<str>)"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. \"products\" must be a sring!"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the groupby() function along with the agg() function to group the data by \\'sell_date\\' and then aggregate the product names into a list. After that, you can calculate the number of different products sold using the length of the list. Finally, sort the product names lexicographically and join them using commas. Make sure to sort the result by \\'sell_date\\'"
                    },
                    {
                        "username": "geetika_shekhawat",
                        "content": "Use GROUP_CONCAT function to get comma separated product list as products :\n\nselect sell_date , count(distinct product) as num_sold , group_concat(distinct product ) as products\nfrom activities\ngroup by sell_date\norder by sell_date"
                    }
                ]
            },
            {
                "id": 2039630,
                "content": [
                    {
                        "username": "ankitabagaria",
                        "content": "# Write your MySQL query statement below\\nSELECT sell_date, COUNT(distinct product) AS num_sold, \\nGROUP_CONCAT(distinct product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date;"
                    },
                    {
                        "username": "Anthonysutherland21",
                        "content": "\\'\\'\\'\\nselect b.sell_date, b.num_sold, GROUP_CONCAT(DISTINCT product) as products from Activities as a \\njoin\\n(select sell_date, count(DISTINCT product) as \\'num_sold\\' from Activities\\ngroup by sell_date) as b\\non a.sell_date = b.sell_date\\ngroup by b.sell_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "manojrk28",
                        "content": "import pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    df= activities\\n    df=df.groupby(\\'sell_date\\')[\\'product\\'].agg(num_sold=\\'nunique\\',products=\\'unique\\').reset_index()\\n    df[\\'products\\']=df[\\'products\\'].apply(lambda x: sorted(x))\\n    return df\\n\\n\\ncan anyone tell why this cod is not correct in testcase even giving correct reasult\\n"
                    },
                    {
                        "username": "naldoyohardi992",
                        "content": "Is there another solution for MYSQL without using STRING_AGG() or GROUP_CONCAT() ?"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "If I don\\'t add the DISTINCT clause in GROUP_CONCAT, it returns multiple records repeated, even if the count is just one.\\nExample : \"Mask,Mask\", when there\\'s just 1 Mask sold on that date.\\nCan anyone explaiin why does it behaves so"
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "OUTPUT = Expected but still wrong?  WHY?\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    gr = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\',\\'unique\\']}).reset_index()\\n    gr.columns = [\\'sell_date\\',\\'num_sold\\',\\'products\\']\\n    gr[\\'products\\'] = gr[\\'products\\'].apply(sorted)\\n    return gr\\n\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Some troubles with pandas:\\nColumn \\'products\\' has type list<str>, but if yours output dataframe has different type then you will get exception and tests will not let you go. To fix this just a cast \\'products\\' to list<str>)"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. \"products\" must be a sring!"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the groupby() function along with the agg() function to group the data by \\'sell_date\\' and then aggregate the product names into a list. After that, you can calculate the number of different products sold using the length of the list. Finally, sort the product names lexicographically and join them using commas. Make sure to sort the result by \\'sell_date\\'"
                    },
                    {
                        "username": "geetika_shekhawat",
                        "content": "Use GROUP_CONCAT function to get comma separated product list as products :\n\nselect sell_date , count(distinct product) as num_sold , group_concat(distinct product ) as products\nfrom activities\ngroup by sell_date\norder by sell_date"
                    }
                ]
            },
            {
                "id": 2039387,
                "content": [
                    {
                        "username": "ankitabagaria",
                        "content": "# Write your MySQL query statement below\\nSELECT sell_date, COUNT(distinct product) AS num_sold, \\nGROUP_CONCAT(distinct product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date;"
                    },
                    {
                        "username": "Anthonysutherland21",
                        "content": "\\'\\'\\'\\nselect b.sell_date, b.num_sold, GROUP_CONCAT(DISTINCT product) as products from Activities as a \\njoin\\n(select sell_date, count(DISTINCT product) as \\'num_sold\\' from Activities\\ngroup by sell_date) as b\\non a.sell_date = b.sell_date\\ngroup by b.sell_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "manojrk28",
                        "content": "import pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    df= activities\\n    df=df.groupby(\\'sell_date\\')[\\'product\\'].agg(num_sold=\\'nunique\\',products=\\'unique\\').reset_index()\\n    df[\\'products\\']=df[\\'products\\'].apply(lambda x: sorted(x))\\n    return df\\n\\n\\ncan anyone tell why this cod is not correct in testcase even giving correct reasult\\n"
                    },
                    {
                        "username": "naldoyohardi992",
                        "content": "Is there another solution for MYSQL without using STRING_AGG() or GROUP_CONCAT() ?"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "If I don\\'t add the DISTINCT clause in GROUP_CONCAT, it returns multiple records repeated, even if the count is just one.\\nExample : \"Mask,Mask\", when there\\'s just 1 Mask sold on that date.\\nCan anyone explaiin why does it behaves so"
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "OUTPUT = Expected but still wrong?  WHY?\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    gr = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\',\\'unique\\']}).reset_index()\\n    gr.columns = [\\'sell_date\\',\\'num_sold\\',\\'products\\']\\n    gr[\\'products\\'] = gr[\\'products\\'].apply(sorted)\\n    return gr\\n\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Some troubles with pandas:\\nColumn \\'products\\' has type list<str>, but if yours output dataframe has different type then you will get exception and tests will not let you go. To fix this just a cast \\'products\\' to list<str>)"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. \"products\" must be a sring!"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the groupby() function along with the agg() function to group the data by \\'sell_date\\' and then aggregate the product names into a list. After that, you can calculate the number of different products sold using the length of the list. Finally, sort the product names lexicographically and join them using commas. Make sure to sort the result by \\'sell_date\\'"
                    },
                    {
                        "username": "geetika_shekhawat",
                        "content": "Use GROUP_CONCAT function to get comma separated product list as products :\n\nselect sell_date , count(distinct product) as num_sold , group_concat(distinct product ) as products\nfrom activities\ngroup by sell_date\norder by sell_date"
                    }
                ]
            },
            {
                "id": 2038665,
                "content": [
                    {
                        "username": "ankitabagaria",
                        "content": "# Write your MySQL query statement below\\nSELECT sell_date, COUNT(distinct product) AS num_sold, \\nGROUP_CONCAT(distinct product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date;"
                    },
                    {
                        "username": "Anthonysutherland21",
                        "content": "\\'\\'\\'\\nselect b.sell_date, b.num_sold, GROUP_CONCAT(DISTINCT product) as products from Activities as a \\njoin\\n(select sell_date, count(DISTINCT product) as \\'num_sold\\' from Activities\\ngroup by sell_date) as b\\non a.sell_date = b.sell_date\\ngroup by b.sell_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "manojrk28",
                        "content": "import pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    df= activities\\n    df=df.groupby(\\'sell_date\\')[\\'product\\'].agg(num_sold=\\'nunique\\',products=\\'unique\\').reset_index()\\n    df[\\'products\\']=df[\\'products\\'].apply(lambda x: sorted(x))\\n    return df\\n\\n\\ncan anyone tell why this cod is not correct in testcase even giving correct reasult\\n"
                    },
                    {
                        "username": "naldoyohardi992",
                        "content": "Is there another solution for MYSQL without using STRING_AGG() or GROUP_CONCAT() ?"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "If I don\\'t add the DISTINCT clause in GROUP_CONCAT, it returns multiple records repeated, even if the count is just one.\\nExample : \"Mask,Mask\", when there\\'s just 1 Mask sold on that date.\\nCan anyone explaiin why does it behaves so"
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "OUTPUT = Expected but still wrong?  WHY?\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    gr = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\',\\'unique\\']}).reset_index()\\n    gr.columns = [\\'sell_date\\',\\'num_sold\\',\\'products\\']\\n    gr[\\'products\\'] = gr[\\'products\\'].apply(sorted)\\n    return gr\\n\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Some troubles with pandas:\\nColumn \\'products\\' has type list<str>, but if yours output dataframe has different type then you will get exception and tests will not let you go. To fix this just a cast \\'products\\' to list<str>)"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. \"products\" must be a sring!"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the groupby() function along with the agg() function to group the data by \\'sell_date\\' and then aggregate the product names into a list. After that, you can calculate the number of different products sold using the length of the list. Finally, sort the product names lexicographically and join them using commas. Make sure to sort the result by \\'sell_date\\'"
                    },
                    {
                        "username": "geetika_shekhawat",
                        "content": "Use GROUP_CONCAT function to get comma separated product list as products :\n\nselect sell_date , count(distinct product) as num_sold , group_concat(distinct product ) as products\nfrom activities\ngroup by sell_date\norder by sell_date"
                    }
                ]
            },
            {
                "id": 2023841,
                "content": [
                    {
                        "username": "ankitabagaria",
                        "content": "# Write your MySQL query statement below\\nSELECT sell_date, COUNT(distinct product) AS num_sold, \\nGROUP_CONCAT(distinct product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date;"
                    },
                    {
                        "username": "Anthonysutherland21",
                        "content": "\\'\\'\\'\\nselect b.sell_date, b.num_sold, GROUP_CONCAT(DISTINCT product) as products from Activities as a \\njoin\\n(select sell_date, count(DISTINCT product) as \\'num_sold\\' from Activities\\ngroup by sell_date) as b\\non a.sell_date = b.sell_date\\ngroup by b.sell_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "manojrk28",
                        "content": "import pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    df= activities\\n    df=df.groupby(\\'sell_date\\')[\\'product\\'].agg(num_sold=\\'nunique\\',products=\\'unique\\').reset_index()\\n    df[\\'products\\']=df[\\'products\\'].apply(lambda x: sorted(x))\\n    return df\\n\\n\\ncan anyone tell why this cod is not correct in testcase even giving correct reasult\\n"
                    },
                    {
                        "username": "naldoyohardi992",
                        "content": "Is there another solution for MYSQL without using STRING_AGG() or GROUP_CONCAT() ?"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "If I don\\'t add the DISTINCT clause in GROUP_CONCAT, it returns multiple records repeated, even if the count is just one.\\nExample : \"Mask,Mask\", when there\\'s just 1 Mask sold on that date.\\nCan anyone explaiin why does it behaves so"
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "OUTPUT = Expected but still wrong?  WHY?\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    gr = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\',\\'unique\\']}).reset_index()\\n    gr.columns = [\\'sell_date\\',\\'num_sold\\',\\'products\\']\\n    gr[\\'products\\'] = gr[\\'products\\'].apply(sorted)\\n    return gr\\n\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Some troubles with pandas:\\nColumn \\'products\\' has type list<str>, but if yours output dataframe has different type then you will get exception and tests will not let you go. To fix this just a cast \\'products\\' to list<str>)"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. \"products\" must be a sring!"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the groupby() function along with the agg() function to group the data by \\'sell_date\\' and then aggregate the product names into a list. After that, you can calculate the number of different products sold using the length of the list. Finally, sort the product names lexicographically and join them using commas. Make sure to sort the result by \\'sell_date\\'"
                    },
                    {
                        "username": "geetika_shekhawat",
                        "content": "Use GROUP_CONCAT function to get comma separated product list as products :\n\nselect sell_date , count(distinct product) as num_sold , group_concat(distinct product ) as products\nfrom activities\ngroup by sell_date\norder by sell_date"
                    }
                ]
            },
            {
                "id": 2010143,
                "content": [
                    {
                        "username": "ankitabagaria",
                        "content": "# Write your MySQL query statement below\\nSELECT sell_date, COUNT(distinct product) AS num_sold, \\nGROUP_CONCAT(distinct product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date;"
                    },
                    {
                        "username": "Anthonysutherland21",
                        "content": "\\'\\'\\'\\nselect b.sell_date, b.num_sold, GROUP_CONCAT(DISTINCT product) as products from Activities as a \\njoin\\n(select sell_date, count(DISTINCT product) as \\'num_sold\\' from Activities\\ngroup by sell_date) as b\\non a.sell_date = b.sell_date\\ngroup by b.sell_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "manojrk28",
                        "content": "import pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    df= activities\\n    df=df.groupby(\\'sell_date\\')[\\'product\\'].agg(num_sold=\\'nunique\\',products=\\'unique\\').reset_index()\\n    df[\\'products\\']=df[\\'products\\'].apply(lambda x: sorted(x))\\n    return df\\n\\n\\ncan anyone tell why this cod is not correct in testcase even giving correct reasult\\n"
                    },
                    {
                        "username": "naldoyohardi992",
                        "content": "Is there another solution for MYSQL without using STRING_AGG() or GROUP_CONCAT() ?"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "If I don\\'t add the DISTINCT clause in GROUP_CONCAT, it returns multiple records repeated, even if the count is just one.\\nExample : \"Mask,Mask\", when there\\'s just 1 Mask sold on that date.\\nCan anyone explaiin why does it behaves so"
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "OUTPUT = Expected but still wrong?  WHY?\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    gr = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\',\\'unique\\']}).reset_index()\\n    gr.columns = [\\'sell_date\\',\\'num_sold\\',\\'products\\']\\n    gr[\\'products\\'] = gr[\\'products\\'].apply(sorted)\\n    return gr\\n\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Some troubles with pandas:\\nColumn \\'products\\' has type list<str>, but if yours output dataframe has different type then you will get exception and tests will not let you go. To fix this just a cast \\'products\\' to list<str>)"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. \"products\" must be a sring!"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the groupby() function along with the agg() function to group the data by \\'sell_date\\' and then aggregate the product names into a list. After that, you can calculate the number of different products sold using the length of the list. Finally, sort the product names lexicographically and join them using commas. Make sure to sort the result by \\'sell_date\\'"
                    },
                    {
                        "username": "geetika_shekhawat",
                        "content": "Use GROUP_CONCAT function to get comma separated product list as products :\n\nselect sell_date , count(distinct product) as num_sold , group_concat(distinct product ) as products\nfrom activities\ngroup by sell_date\norder by sell_date"
                    }
                ]
            },
            {
                "id": 1990298,
                "content": [
                    {
                        "username": "ankitabagaria",
                        "content": "# Write your MySQL query statement below\\nSELECT sell_date, COUNT(distinct product) AS num_sold, \\nGROUP_CONCAT(distinct product ORDER BY product) AS products\\nFROM Activities \\nGROUP BY sell_date;"
                    },
                    {
                        "username": "Anthonysutherland21",
                        "content": "\\'\\'\\'\\nselect b.sell_date, b.num_sold, GROUP_CONCAT(DISTINCT product) as products from Activities as a \\njoin\\n(select sell_date, count(DISTINCT product) as \\'num_sold\\' from Activities\\ngroup by sell_date) as b\\non a.sell_date = b.sell_date\\ngroup by b.sell_date\\n\\'\\'\\'"
                    },
                    {
                        "username": "manojrk28",
                        "content": "import pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    df= activities\\n    df=df.groupby(\\'sell_date\\')[\\'product\\'].agg(num_sold=\\'nunique\\',products=\\'unique\\').reset_index()\\n    df[\\'products\\']=df[\\'products\\'].apply(lambda x: sorted(x))\\n    return df\\n\\n\\ncan anyone tell why this cod is not correct in testcase even giving correct reasult\\n"
                    },
                    {
                        "username": "naldoyohardi992",
                        "content": "Is there another solution for MYSQL without using STRING_AGG() or GROUP_CONCAT() ?"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "If I don\\'t add the DISTINCT clause in GROUP_CONCAT, it returns multiple records repeated, even if the count is just one.\\nExample : \"Mask,Mask\", when there\\'s just 1 Mask sold on that date.\\nCan anyone explaiin why does it behaves so"
                    },
                    {
                        "username": "ArtemBaykov",
                        "content": "OUTPUT = Expected but still wrong?  WHY?\\nimport pandas as pd\\n\\ndef categorize_products(activities: pd.DataFrame) -> pd.DataFrame:\\n    gr = activities.groupby(\\'sell_date\\').agg({\\'product\\':[\\'nunique\\',\\'unique\\']}).reset_index()\\n    gr.columns = [\\'sell_date\\',\\'num_sold\\',\\'products\\']\\n    gr[\\'products\\'] = gr[\\'products\\'].apply(sorted)\\n    return gr\\n\\n"
                    },
                    {
                        "username": "marcenavuc",
                        "content": "Some troubles with pandas:\\nColumn \\'products\\' has type list<str>, but if yours output dataframe has different type then you will get exception and tests will not let you go. To fix this just a cast \\'products\\' to list<str>)"
                    },
                    {
                        "username": "uaoiuaoi",
                        "content": "For pandasman. \"products\" must be a sring!"
                    },
                    {
                        "username": "edithi",
                        "content": "You can use the groupby() function along with the agg() function to group the data by \\'sell_date\\' and then aggregate the product names into a list. After that, you can calculate the number of different products sold using the length of the list. Finally, sort the product names lexicographically and join them using commas. Make sure to sort the result by \\'sell_date\\'"
                    },
                    {
                        "username": "geetika_shekhawat",
                        "content": "Use GROUP_CONCAT function to get comma separated product list as products :\n\nselect sell_date , count(distinct product) as num_sold , group_concat(distinct product ) as products\nfrom activities\ngroup by sell_date\norder by sell_date"
                    }
                ]
            },
            {
                "id": 1913567,
                "content": [
                    {
                        "username": "Arin_Maity",
                        "content": "SELECT sell_date,count(*) AS \\'num_sold\\' ,STRING_AGG(product,\\',\\') AS \\'Products\\' \\nFROM( SELECT DISTINCT * FROM Activities)A\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT sell_date, COUNT(DISTINCT(product)) as num_sold, group_concat(distinct product) as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the code worked for me,\\nselect ac.sell_date,count(distinct ac.product) as num_sold,group_concat(distinct ac.product order by ac.product asc) as products from Activities as ac group by ac.sell_date"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date;\\nit\\'s working properly.\\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "In MSSQL this is very much not easy at all. "
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "```\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;\\n```\\nThis query is the solution of this problem !"
                    },
                    {
                        "username": "nvpolyakova",
                        "content": "oracle: listagg(product,\\',\\') within group (order by product) as products"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "in Mysql try group_concat to build the list of product names in alphabetical order\\n\\nhttps://devdocs.io/mariadb/group_concat/index\\n\\n`group_concat(distinct col order by col) as products`"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi Leetcode team,\\n I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. Hence I have cast the column to date but still the issue is not getting same timestamps adding to date. NB; the column type of sell_date is date type I am not sure why leetcode adding timestamp to it.\\n\\nSELECT cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM\\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query:\\n\\nOutput\\nSELL_DATE\\tNUM_SOLD\\tPRODUCTS\\n2020-05-30 00:00:00\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01 00:00:00\\t2\\tBible,Pencil\\n2020-06-02 00:00:00\\t1\\tMask\\nExpected\\t\\t\\nsell_date\\tnum_sold\\tproducts\\n2020-05-30\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01\\t2\\tBible,Pencil\\n2020-06-02\\t1\\tMask"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. NB; the column type of sell_date is date type I am not sure why leet code adding timestamp to it.\\n\\nSELECT  cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM \\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query: \\n\\nOutput\\n| SELL_DATE           | NUM_SOLD | PRODUCTS                     |\\n| ------------------- | -------- | ---------------------------- |\\n| 2020-05-30 00:00:00 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 00:00:00 | 2        | Bible,Pencil                 |\\n| 2020-06-02 00:00:00 | 1        | Mask                         |\\nExpected\\n| sell_date  | num_sold | products                     |\\n| ---------- | -------- | ---------------------------- |\\n| 2020-05-30 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 | 2        | Bible,Pencil                 |\\n| 2020-06-02 | 1        | Mask                         |"
                    }
                ]
            },
            {
                "id": 1886066,
                "content": [
                    {
                        "username": "Arin_Maity",
                        "content": "SELECT sell_date,count(*) AS \\'num_sold\\' ,STRING_AGG(product,\\',\\') AS \\'Products\\' \\nFROM( SELECT DISTINCT * FROM Activities)A\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT sell_date, COUNT(DISTINCT(product)) as num_sold, group_concat(distinct product) as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the code worked for me,\\nselect ac.sell_date,count(distinct ac.product) as num_sold,group_concat(distinct ac.product order by ac.product asc) as products from Activities as ac group by ac.sell_date"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date;\\nit\\'s working properly.\\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "In MSSQL this is very much not easy at all. "
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "```\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;\\n```\\nThis query is the solution of this problem !"
                    },
                    {
                        "username": "nvpolyakova",
                        "content": "oracle: listagg(product,\\',\\') within group (order by product) as products"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "in Mysql try group_concat to build the list of product names in alphabetical order\\n\\nhttps://devdocs.io/mariadb/group_concat/index\\n\\n`group_concat(distinct col order by col) as products`"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi Leetcode team,\\n I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. Hence I have cast the column to date but still the issue is not getting same timestamps adding to date. NB; the column type of sell_date is date type I am not sure why leetcode adding timestamp to it.\\n\\nSELECT cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM\\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query:\\n\\nOutput\\nSELL_DATE\\tNUM_SOLD\\tPRODUCTS\\n2020-05-30 00:00:00\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01 00:00:00\\t2\\tBible,Pencil\\n2020-06-02 00:00:00\\t1\\tMask\\nExpected\\t\\t\\nsell_date\\tnum_sold\\tproducts\\n2020-05-30\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01\\t2\\tBible,Pencil\\n2020-06-02\\t1\\tMask"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. NB; the column type of sell_date is date type I am not sure why leet code adding timestamp to it.\\n\\nSELECT  cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM \\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query: \\n\\nOutput\\n| SELL_DATE           | NUM_SOLD | PRODUCTS                     |\\n| ------------------- | -------- | ---------------------------- |\\n| 2020-05-30 00:00:00 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 00:00:00 | 2        | Bible,Pencil                 |\\n| 2020-06-02 00:00:00 | 1        | Mask                         |\\nExpected\\n| sell_date  | num_sold | products                     |\\n| ---------- | -------- | ---------------------------- |\\n| 2020-05-30 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 | 2        | Bible,Pencil                 |\\n| 2020-06-02 | 1        | Mask                         |"
                    }
                ]
            },
            {
                "id": 1860135,
                "content": [
                    {
                        "username": "Arin_Maity",
                        "content": "SELECT sell_date,count(*) AS \\'num_sold\\' ,STRING_AGG(product,\\',\\') AS \\'Products\\' \\nFROM( SELECT DISTINCT * FROM Activities)A\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT sell_date, COUNT(DISTINCT(product)) as num_sold, group_concat(distinct product) as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the code worked for me,\\nselect ac.sell_date,count(distinct ac.product) as num_sold,group_concat(distinct ac.product order by ac.product asc) as products from Activities as ac group by ac.sell_date"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date;\\nit\\'s working properly.\\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "In MSSQL this is very much not easy at all. "
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "```\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;\\n```\\nThis query is the solution of this problem !"
                    },
                    {
                        "username": "nvpolyakova",
                        "content": "oracle: listagg(product,\\',\\') within group (order by product) as products"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "in Mysql try group_concat to build the list of product names in alphabetical order\\n\\nhttps://devdocs.io/mariadb/group_concat/index\\n\\n`group_concat(distinct col order by col) as products`"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi Leetcode team,\\n I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. Hence I have cast the column to date but still the issue is not getting same timestamps adding to date. NB; the column type of sell_date is date type I am not sure why leetcode adding timestamp to it.\\n\\nSELECT cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM\\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query:\\n\\nOutput\\nSELL_DATE\\tNUM_SOLD\\tPRODUCTS\\n2020-05-30 00:00:00\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01 00:00:00\\t2\\tBible,Pencil\\n2020-06-02 00:00:00\\t1\\tMask\\nExpected\\t\\t\\nsell_date\\tnum_sold\\tproducts\\n2020-05-30\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01\\t2\\tBible,Pencil\\n2020-06-02\\t1\\tMask"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. NB; the column type of sell_date is date type I am not sure why leet code adding timestamp to it.\\n\\nSELECT  cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM \\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query: \\n\\nOutput\\n| SELL_DATE           | NUM_SOLD | PRODUCTS                     |\\n| ------------------- | -------- | ---------------------------- |\\n| 2020-05-30 00:00:00 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 00:00:00 | 2        | Bible,Pencil                 |\\n| 2020-06-02 00:00:00 | 1        | Mask                         |\\nExpected\\n| sell_date  | num_sold | products                     |\\n| ---------- | -------- | ---------------------------- |\\n| 2020-05-30 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 | 2        | Bible,Pencil                 |\\n| 2020-06-02 | 1        | Mask                         |"
                    }
                ]
            },
            {
                "id": 1858140,
                "content": [
                    {
                        "username": "Arin_Maity",
                        "content": "SELECT sell_date,count(*) AS \\'num_sold\\' ,STRING_AGG(product,\\',\\') AS \\'Products\\' \\nFROM( SELECT DISTINCT * FROM Activities)A\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT sell_date, COUNT(DISTINCT(product)) as num_sold, group_concat(distinct product) as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the code worked for me,\\nselect ac.sell_date,count(distinct ac.product) as num_sold,group_concat(distinct ac.product order by ac.product asc) as products from Activities as ac group by ac.sell_date"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date;\\nit\\'s working properly.\\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "In MSSQL this is very much not easy at all. "
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "```\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;\\n```\\nThis query is the solution of this problem !"
                    },
                    {
                        "username": "nvpolyakova",
                        "content": "oracle: listagg(product,\\',\\') within group (order by product) as products"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "in Mysql try group_concat to build the list of product names in alphabetical order\\n\\nhttps://devdocs.io/mariadb/group_concat/index\\n\\n`group_concat(distinct col order by col) as products`"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi Leetcode team,\\n I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. Hence I have cast the column to date but still the issue is not getting same timestamps adding to date. NB; the column type of sell_date is date type I am not sure why leetcode adding timestamp to it.\\n\\nSELECT cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM\\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query:\\n\\nOutput\\nSELL_DATE\\tNUM_SOLD\\tPRODUCTS\\n2020-05-30 00:00:00\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01 00:00:00\\t2\\tBible,Pencil\\n2020-06-02 00:00:00\\t1\\tMask\\nExpected\\t\\t\\nsell_date\\tnum_sold\\tproducts\\n2020-05-30\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01\\t2\\tBible,Pencil\\n2020-06-02\\t1\\tMask"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. NB; the column type of sell_date is date type I am not sure why leet code adding timestamp to it.\\n\\nSELECT  cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM \\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query: \\n\\nOutput\\n| SELL_DATE           | NUM_SOLD | PRODUCTS                     |\\n| ------------------- | -------- | ---------------------------- |\\n| 2020-05-30 00:00:00 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 00:00:00 | 2        | Bible,Pencil                 |\\n| 2020-06-02 00:00:00 | 1        | Mask                         |\\nExpected\\n| sell_date  | num_sold | products                     |\\n| ---------- | -------- | ---------------------------- |\\n| 2020-05-30 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 | 2        | Bible,Pencil                 |\\n| 2020-06-02 | 1        | Mask                         |"
                    }
                ]
            },
            {
                "id": 1857181,
                "content": [
                    {
                        "username": "Arin_Maity",
                        "content": "SELECT sell_date,count(*) AS \\'num_sold\\' ,STRING_AGG(product,\\',\\') AS \\'Products\\' \\nFROM( SELECT DISTINCT * FROM Activities)A\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT sell_date, COUNT(DISTINCT(product)) as num_sold, group_concat(distinct product) as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the code worked for me,\\nselect ac.sell_date,count(distinct ac.product) as num_sold,group_concat(distinct ac.product order by ac.product asc) as products from Activities as ac group by ac.sell_date"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date;\\nit\\'s working properly.\\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "In MSSQL this is very much not easy at all. "
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "```\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;\\n```\\nThis query is the solution of this problem !"
                    },
                    {
                        "username": "nvpolyakova",
                        "content": "oracle: listagg(product,\\',\\') within group (order by product) as products"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "in Mysql try group_concat to build the list of product names in alphabetical order\\n\\nhttps://devdocs.io/mariadb/group_concat/index\\n\\n`group_concat(distinct col order by col) as products`"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi Leetcode team,\\n I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. Hence I have cast the column to date but still the issue is not getting same timestamps adding to date. NB; the column type of sell_date is date type I am not sure why leetcode adding timestamp to it.\\n\\nSELECT cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM\\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query:\\n\\nOutput\\nSELL_DATE\\tNUM_SOLD\\tPRODUCTS\\n2020-05-30 00:00:00\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01 00:00:00\\t2\\tBible,Pencil\\n2020-06-02 00:00:00\\t1\\tMask\\nExpected\\t\\t\\nsell_date\\tnum_sold\\tproducts\\n2020-05-30\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01\\t2\\tBible,Pencil\\n2020-06-02\\t1\\tMask"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. NB; the column type of sell_date is date type I am not sure why leet code adding timestamp to it.\\n\\nSELECT  cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM \\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query: \\n\\nOutput\\n| SELL_DATE           | NUM_SOLD | PRODUCTS                     |\\n| ------------------- | -------- | ---------------------------- |\\n| 2020-05-30 00:00:00 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 00:00:00 | 2        | Bible,Pencil                 |\\n| 2020-06-02 00:00:00 | 1        | Mask                         |\\nExpected\\n| sell_date  | num_sold | products                     |\\n| ---------- | -------- | ---------------------------- |\\n| 2020-05-30 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 | 2        | Bible,Pencil                 |\\n| 2020-06-02 | 1        | Mask                         |"
                    }
                ]
            },
            {
                "id": 1855923,
                "content": [
                    {
                        "username": "Arin_Maity",
                        "content": "SELECT sell_date,count(*) AS \\'num_sold\\' ,STRING_AGG(product,\\',\\') AS \\'Products\\' \\nFROM( SELECT DISTINCT * FROM Activities)A\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT sell_date, COUNT(DISTINCT(product)) as num_sold, group_concat(distinct product) as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the code worked for me,\\nselect ac.sell_date,count(distinct ac.product) as num_sold,group_concat(distinct ac.product order by ac.product asc) as products from Activities as ac group by ac.sell_date"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date;\\nit\\'s working properly.\\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "In MSSQL this is very much not easy at all. "
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "```\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;\\n```\\nThis query is the solution of this problem !"
                    },
                    {
                        "username": "nvpolyakova",
                        "content": "oracle: listagg(product,\\',\\') within group (order by product) as products"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "in Mysql try group_concat to build the list of product names in alphabetical order\\n\\nhttps://devdocs.io/mariadb/group_concat/index\\n\\n`group_concat(distinct col order by col) as products`"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi Leetcode team,\\n I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. Hence I have cast the column to date but still the issue is not getting same timestamps adding to date. NB; the column type of sell_date is date type I am not sure why leetcode adding timestamp to it.\\n\\nSELECT cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM\\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query:\\n\\nOutput\\nSELL_DATE\\tNUM_SOLD\\tPRODUCTS\\n2020-05-30 00:00:00\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01 00:00:00\\t2\\tBible,Pencil\\n2020-06-02 00:00:00\\t1\\tMask\\nExpected\\t\\t\\nsell_date\\tnum_sold\\tproducts\\n2020-05-30\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01\\t2\\tBible,Pencil\\n2020-06-02\\t1\\tMask"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. NB; the column type of sell_date is date type I am not sure why leet code adding timestamp to it.\\n\\nSELECT  cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM \\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query: \\n\\nOutput\\n| SELL_DATE           | NUM_SOLD | PRODUCTS                     |\\n| ------------------- | -------- | ---------------------------- |\\n| 2020-05-30 00:00:00 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 00:00:00 | 2        | Bible,Pencil                 |\\n| 2020-06-02 00:00:00 | 1        | Mask                         |\\nExpected\\n| sell_date  | num_sold | products                     |\\n| ---------- | -------- | ---------------------------- |\\n| 2020-05-30 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 | 2        | Bible,Pencil                 |\\n| 2020-06-02 | 1        | Mask                         |"
                    }
                ]
            },
            {
                "id": 1833374,
                "content": [
                    {
                        "username": "Arin_Maity",
                        "content": "SELECT sell_date,count(*) AS \\'num_sold\\' ,STRING_AGG(product,\\',\\') AS \\'Products\\' \\nFROM( SELECT DISTINCT * FROM Activities)A\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT sell_date, COUNT(DISTINCT(product)) as num_sold, group_concat(distinct product) as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the code worked for me,\\nselect ac.sell_date,count(distinct ac.product) as num_sold,group_concat(distinct ac.product order by ac.product asc) as products from Activities as ac group by ac.sell_date"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date;\\nit\\'s working properly.\\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "In MSSQL this is very much not easy at all. "
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "```\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;\\n```\\nThis query is the solution of this problem !"
                    },
                    {
                        "username": "nvpolyakova",
                        "content": "oracle: listagg(product,\\',\\') within group (order by product) as products"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "in Mysql try group_concat to build the list of product names in alphabetical order\\n\\nhttps://devdocs.io/mariadb/group_concat/index\\n\\n`group_concat(distinct col order by col) as products`"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi Leetcode team,\\n I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. Hence I have cast the column to date but still the issue is not getting same timestamps adding to date. NB; the column type of sell_date is date type I am not sure why leetcode adding timestamp to it.\\n\\nSELECT cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM\\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query:\\n\\nOutput\\nSELL_DATE\\tNUM_SOLD\\tPRODUCTS\\n2020-05-30 00:00:00\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01 00:00:00\\t2\\tBible,Pencil\\n2020-06-02 00:00:00\\t1\\tMask\\nExpected\\t\\t\\nsell_date\\tnum_sold\\tproducts\\n2020-05-30\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01\\t2\\tBible,Pencil\\n2020-06-02\\t1\\tMask"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. NB; the column type of sell_date is date type I am not sure why leet code adding timestamp to it.\\n\\nSELECT  cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM \\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query: \\n\\nOutput\\n| SELL_DATE           | NUM_SOLD | PRODUCTS                     |\\n| ------------------- | -------- | ---------------------------- |\\n| 2020-05-30 00:00:00 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 00:00:00 | 2        | Bible,Pencil                 |\\n| 2020-06-02 00:00:00 | 1        | Mask                         |\\nExpected\\n| sell_date  | num_sold | products                     |\\n| ---------- | -------- | ---------------------------- |\\n| 2020-05-30 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 | 2        | Bible,Pencil                 |\\n| 2020-06-02 | 1        | Mask                         |"
                    }
                ]
            },
            {
                "id": 1811189,
                "content": [
                    {
                        "username": "Arin_Maity",
                        "content": "SELECT sell_date,count(*) AS \\'num_sold\\' ,STRING_AGG(product,\\',\\') AS \\'Products\\' \\nFROM( SELECT DISTINCT * FROM Activities)A\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT sell_date, COUNT(DISTINCT(product)) as num_sold, group_concat(distinct product) as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the code worked for me,\\nselect ac.sell_date,count(distinct ac.product) as num_sold,group_concat(distinct ac.product order by ac.product asc) as products from Activities as ac group by ac.sell_date"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date;\\nit\\'s working properly.\\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "In MSSQL this is very much not easy at all. "
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "```\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;\\n```\\nThis query is the solution of this problem !"
                    },
                    {
                        "username": "nvpolyakova",
                        "content": "oracle: listagg(product,\\',\\') within group (order by product) as products"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "in Mysql try group_concat to build the list of product names in alphabetical order\\n\\nhttps://devdocs.io/mariadb/group_concat/index\\n\\n`group_concat(distinct col order by col) as products`"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi Leetcode team,\\n I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. Hence I have cast the column to date but still the issue is not getting same timestamps adding to date. NB; the column type of sell_date is date type I am not sure why leetcode adding timestamp to it.\\n\\nSELECT cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM\\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query:\\n\\nOutput\\nSELL_DATE\\tNUM_SOLD\\tPRODUCTS\\n2020-05-30 00:00:00\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01 00:00:00\\t2\\tBible,Pencil\\n2020-06-02 00:00:00\\t1\\tMask\\nExpected\\t\\t\\nsell_date\\tnum_sold\\tproducts\\n2020-05-30\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01\\t2\\tBible,Pencil\\n2020-06-02\\t1\\tMask"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. NB; the column type of sell_date is date type I am not sure why leet code adding timestamp to it.\\n\\nSELECT  cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM \\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query: \\n\\nOutput\\n| SELL_DATE           | NUM_SOLD | PRODUCTS                     |\\n| ------------------- | -------- | ---------------------------- |\\n| 2020-05-30 00:00:00 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 00:00:00 | 2        | Bible,Pencil                 |\\n| 2020-06-02 00:00:00 | 1        | Mask                         |\\nExpected\\n| sell_date  | num_sold | products                     |\\n| ---------- | -------- | ---------------------------- |\\n| 2020-05-30 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 | 2        | Bible,Pencil                 |\\n| 2020-06-02 | 1        | Mask                         |"
                    }
                ]
            },
            {
                "id": 1798158,
                "content": [
                    {
                        "username": "Arin_Maity",
                        "content": "SELECT sell_date,count(*) AS \\'num_sold\\' ,STRING_AGG(product,\\',\\') AS \\'Products\\' \\nFROM( SELECT DISTINCT * FROM Activities)A\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT sell_date, COUNT(DISTINCT(product)) as num_sold, group_concat(distinct product) as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the code worked for me,\\nselect ac.sell_date,count(distinct ac.product) as num_sold,group_concat(distinct ac.product order by ac.product asc) as products from Activities as ac group by ac.sell_date"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date;\\nit\\'s working properly.\\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "In MSSQL this is very much not easy at all. "
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "```\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;\\n```\\nThis query is the solution of this problem !"
                    },
                    {
                        "username": "nvpolyakova",
                        "content": "oracle: listagg(product,\\',\\') within group (order by product) as products"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "in Mysql try group_concat to build the list of product names in alphabetical order\\n\\nhttps://devdocs.io/mariadb/group_concat/index\\n\\n`group_concat(distinct col order by col) as products`"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi Leetcode team,\\n I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. Hence I have cast the column to date but still the issue is not getting same timestamps adding to date. NB; the column type of sell_date is date type I am not sure why leetcode adding timestamp to it.\\n\\nSELECT cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM\\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query:\\n\\nOutput\\nSELL_DATE\\tNUM_SOLD\\tPRODUCTS\\n2020-05-30 00:00:00\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01 00:00:00\\t2\\tBible,Pencil\\n2020-06-02 00:00:00\\t1\\tMask\\nExpected\\t\\t\\nsell_date\\tnum_sold\\tproducts\\n2020-05-30\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01\\t2\\tBible,Pencil\\n2020-06-02\\t1\\tMask"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. NB; the column type of sell_date is date type I am not sure why leet code adding timestamp to it.\\n\\nSELECT  cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM \\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query: \\n\\nOutput\\n| SELL_DATE           | NUM_SOLD | PRODUCTS                     |\\n| ------------------- | -------- | ---------------------------- |\\n| 2020-05-30 00:00:00 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 00:00:00 | 2        | Bible,Pencil                 |\\n| 2020-06-02 00:00:00 | 1        | Mask                         |\\nExpected\\n| sell_date  | num_sold | products                     |\\n| ---------- | -------- | ---------------------------- |\\n| 2020-05-30 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 | 2        | Bible,Pencil                 |\\n| 2020-06-02 | 1        | Mask                         |"
                    }
                ]
            },
            {
                "id": 1798154,
                "content": [
                    {
                        "username": "Arin_Maity",
                        "content": "SELECT sell_date,count(*) AS \\'num_sold\\' ,STRING_AGG(product,\\',\\') AS \\'Products\\' \\nFROM( SELECT DISTINCT * FROM Activities)A\\nGROUP BY sell_date\\nORDER BY sell_date"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT sell_date, COUNT(DISTINCT(product)) as num_sold, group_concat(distinct product) as products\\nFROM Activities\\nGROUP BY sell_date\\nORDER BY sell_date ASC"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the code worked for me,\\nselect ac.sell_date,count(distinct ac.product) as num_sold,group_concat(distinct ac.product order by ac.product asc) as products from Activities as ac group by ac.sell_date"
                    },
                    {
                        "username": "ankit_gusain",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date order by sell_date;\\nit\\'s working properly.\\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "In MSSQL this is very much not easy at all. "
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "```\\nselect sell_date,\\ncount(distinct product) as num_sold,\\ngroup_concat(distinct product) as products\\nfrom Activities\\ngroup by sell_date;\\n```\\nThis query is the solution of this problem !"
                    },
                    {
                        "username": "nvpolyakova",
                        "content": "oracle: listagg(product,\\',\\') within group (order by product) as products"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "in Mysql try group_concat to build the list of product names in alphabetical order\\n\\nhttps://devdocs.io/mariadb/group_concat/index\\n\\n`group_concat(distinct col order by col) as products`"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi Leetcode team,\\n I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. Hence I have cast the column to date but still the issue is not getting same timestamps adding to date. NB; the column type of sell_date is date type I am not sure why leetcode adding timestamp to it.\\n\\nSELECT cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM\\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query:\\n\\nOutput\\nSELL_DATE\\tNUM_SOLD\\tPRODUCTS\\n2020-05-30 00:00:00\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01 00:00:00\\t2\\tBible,Pencil\\n2020-06-02 00:00:00\\t1\\tMask\\nExpected\\t\\t\\nsell_date\\tnum_sold\\tproducts\\n2020-05-30\\t3\\tBasketball,Headphone,T-Shirt\\n2020-06-01\\t2\\tBible,Pencil\\n2020-06-02\\t1\\tMask"
                    },
                    {
                        "username": "LaughingLamb6",
                        "content": "Hi I have prepared this query but it is not giving right results. the Leetcode is adding timestamps to the date while run the query. When I try the same query in my local oracle instance it is giving right result. NB; the column type of sell_date is date type I am not sure why leet code adding timestamp to it.\\n\\nSELECT  cast(sell_date as date)sell_date, COUNT(PRODUCT)num_sold,listagg(product, \\',\\')within group\\n( order by 1)products\\nfrom (\\nSELECT SELL_DATE ,PRODUCT FROM ( SELECT A.*, ROW_NUMBER() OVER(PARTITION BY SELL_DATE,product ORDER BY 1)TOP FROM \\nACTIVITIES A\\n) WHERE TOP = 1\\n)\\nGROUP BY sell_date\\norder by sell_date\\n\\nWhile running the query: \\n\\nOutput\\n| SELL_DATE           | NUM_SOLD | PRODUCTS                     |\\n| ------------------- | -------- | ---------------------------- |\\n| 2020-05-30 00:00:00 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 00:00:00 | 2        | Bible,Pencil                 |\\n| 2020-06-02 00:00:00 | 1        | Mask                         |\\nExpected\\n| sell_date  | num_sold | products                     |\\n| ---------- | -------- | ---------------------------- |\\n| 2020-05-30 | 3        | Basketball,Headphone,T-Shirt |\\n| 2020-06-01 | 2        | Bible,Pencil                 |\\n| 2020-06-02 | 1        | Mask                         |"
                    }
                ]
            },
            {
                "id": 1796820,
                "content": [
                    {
                        "username": "CoolCoder99",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date;\\n\\nselect sell_date,count(distinct product) as num_sold,group_concat(distinct product) as products from Activities group by sell_date order by sell_date,products;\\n\\nWhy is the second query faster than the first one?\\n"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select sell_date,Count(Distinct(product)) as num_sold,\\nString_agg(product,\\',\\') as products from (\\nselect sell_date,product from activities group by sell_date,product) as temp\\ngroup by sell_date;"
                    },
                    {
                        "username": "Rosanguyen263",
                        "content": "My solution is \\nSELECT\\nsell_date,\\nCount(Distinct product) As num_sold,\\nGroup_concat(product) as Products\\nFROM Activities\\nGroup by sell_date\\n\\n\\nHowever, I dont know why my table gave out the extra count for mask, mask in the colum group_concat \\n"
                    },
                    {
                        "username": "The_Desert_Fox",
                        "content": "Group_concat(product) ------>Group_concat( distinct product)"
                    },
                    {
                        "username": "aymendj",
                        "content": "Why does is say that this query is incorrect, even though the result is almost the same, with the exception of the order of the items in the products column?\\n\\nSELECT \\n        sell_date,\\n        COUNT(DISTINCT product) AS num_sold,\\n        GROUP_CONCAT(product) products\\nFROM \\n        Activities\\nGROUP BY \\n        sell_date\\nORDER BY \\n        sell_date "
                    },
                    {
                        "username": "nayakbhishek",
                        "content": "`can anybody pls tell me whats wrong with my code it is running perfectly fine but while submitting in the test case the format of the dates get\\'s changed to yyyy-m-d due to which i am not able to submit.\\n`\\nselect sell_date ,count(*) as num_sold ,group_concat(product) as products from (\\nselect * , row_number() over(partition by product) as rn from Activities) as x where rn = 1 group by sell_date;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t know how it\\'s acceptance rate is > 80%. It\\'s not easy in MS SQL Server.\\n\\nWITH cte AS (\\n    SELECT DISTINCT sell_date, product\\n    FROM activities\\n)\\nSELECT sell_date, count(1) num_sold, STRING_AGG( product, \\',\\') products\\nFROM cte\\nGROUP BY sell_date\\norder by sell_date;"
                    },
                    {
                        "username": "priyabrata_",
                        "content": "why i am getting run time error\\n MY code\\nselect sell_date , count( distinct product ) as num_sold , \\ngroup_concat ( distinct product order by product ) as products  from Activities group by sell_date order by sell_date;\\n\\nRuntime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'distinct product order by product ) as products  from Activities group by sell_d\\' at line 3\\n "
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi ,\n\nYour code logic is right , just try to avoid putting unnecessary spaces \" \" between the code and also try to put allias name of the column in Quotation Mark like \"num_sold\" .\nThis should solve the issue.\n\nyour code below with correction for reference.\n\n`\nselect sell_date , count(distinct product) as \"num_sold\" , \ngroup_concat(distinct product order by product) as \"products\" from Activities group by sell_date order by sell_date;\n`"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select \\nr.sell_date,max(r.rn) as num_sold , group_concat(distinct r.product) as products  \\nfrom \\n    (\\n        select DISTINCT product, ROW_NUMBER() OVER(partition by sell_date order by product) as rn,\\n              Product as ss, sell_date   \\n        from \\n            Activities  \\n        group by \\n            product \\n        order by \\n            sell_date\\n    ) as r \\ngroup by \\n    r.sell_date \\norder by \\n    r.sell_date \\n\\n\\n"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL SERVER\n\n```WITH [groupped] ([sell_date], [product]) AS \n(SELECT [sell_date], [product]\nFROM [Activities]\nGROUP BY [sell_date], [product])\n\nSELECT \n    [G].[sell_date],\n    COUNT([G].[product]) AS [num_sold],\n    STRING_AGG([G].[product], ',') WITHIN GROUP (ORDER BY [G].[product] ASC) AS [products]\nFROM [groupped] AS [G]\nGROUP BY [sell_date]\nORDER BY [G].[sell_date]"
                    },
                    {
                        "username": "EricaWanja",
                        "content": " `select  sell_date, count(product) as num_sold, string_Agg(product, \\',\\') as products from Activities group by sell_date\\norder by sell_date `\\n\\nWhen i execute above code it causes a repetition in the last row i.e outputs two masks and there is only one, yo can run the code what i mean, anyone who can help me figure this out"
                    }
                ]
            },
            {
                "id": 1793750,
                "content": [
                    {
                        "username": "CoolCoder99",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date;\\n\\nselect sell_date,count(distinct product) as num_sold,group_concat(distinct product) as products from Activities group by sell_date order by sell_date,products;\\n\\nWhy is the second query faster than the first one?\\n"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select sell_date,Count(Distinct(product)) as num_sold,\\nString_agg(product,\\',\\') as products from (\\nselect sell_date,product from activities group by sell_date,product) as temp\\ngroup by sell_date;"
                    },
                    {
                        "username": "Rosanguyen263",
                        "content": "My solution is \\nSELECT\\nsell_date,\\nCount(Distinct product) As num_sold,\\nGroup_concat(product) as Products\\nFROM Activities\\nGroup by sell_date\\n\\n\\nHowever, I dont know why my table gave out the extra count for mask, mask in the colum group_concat \\n"
                    },
                    {
                        "username": "The_Desert_Fox",
                        "content": "Group_concat(product) ------>Group_concat( distinct product)"
                    },
                    {
                        "username": "aymendj",
                        "content": "Why does is say that this query is incorrect, even though the result is almost the same, with the exception of the order of the items in the products column?\\n\\nSELECT \\n        sell_date,\\n        COUNT(DISTINCT product) AS num_sold,\\n        GROUP_CONCAT(product) products\\nFROM \\n        Activities\\nGROUP BY \\n        sell_date\\nORDER BY \\n        sell_date "
                    },
                    {
                        "username": "nayakbhishek",
                        "content": "`can anybody pls tell me whats wrong with my code it is running perfectly fine but while submitting in the test case the format of the dates get\\'s changed to yyyy-m-d due to which i am not able to submit.\\n`\\nselect sell_date ,count(*) as num_sold ,group_concat(product) as products from (\\nselect * , row_number() over(partition by product) as rn from Activities) as x where rn = 1 group by sell_date;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t know how it\\'s acceptance rate is > 80%. It\\'s not easy in MS SQL Server.\\n\\nWITH cte AS (\\n    SELECT DISTINCT sell_date, product\\n    FROM activities\\n)\\nSELECT sell_date, count(1) num_sold, STRING_AGG( product, \\',\\') products\\nFROM cte\\nGROUP BY sell_date\\norder by sell_date;"
                    },
                    {
                        "username": "priyabrata_",
                        "content": "why i am getting run time error\\n MY code\\nselect sell_date , count( distinct product ) as num_sold , \\ngroup_concat ( distinct product order by product ) as products  from Activities group by sell_date order by sell_date;\\n\\nRuntime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'distinct product order by product ) as products  from Activities group by sell_d\\' at line 3\\n "
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi ,\n\nYour code logic is right , just try to avoid putting unnecessary spaces \" \" between the code and also try to put allias name of the column in Quotation Mark like \"num_sold\" .\nThis should solve the issue.\n\nyour code below with correction for reference.\n\n`\nselect sell_date , count(distinct product) as \"num_sold\" , \ngroup_concat(distinct product order by product) as \"products\" from Activities group by sell_date order by sell_date;\n`"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select \\nr.sell_date,max(r.rn) as num_sold , group_concat(distinct r.product) as products  \\nfrom \\n    (\\n        select DISTINCT product, ROW_NUMBER() OVER(partition by sell_date order by product) as rn,\\n              Product as ss, sell_date   \\n        from \\n            Activities  \\n        group by \\n            product \\n        order by \\n            sell_date\\n    ) as r \\ngroup by \\n    r.sell_date \\norder by \\n    r.sell_date \\n\\n\\n"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL SERVER\n\n```WITH [groupped] ([sell_date], [product]) AS \n(SELECT [sell_date], [product]\nFROM [Activities]\nGROUP BY [sell_date], [product])\n\nSELECT \n    [G].[sell_date],\n    COUNT([G].[product]) AS [num_sold],\n    STRING_AGG([G].[product], ',') WITHIN GROUP (ORDER BY [G].[product] ASC) AS [products]\nFROM [groupped] AS [G]\nGROUP BY [sell_date]\nORDER BY [G].[sell_date]"
                    },
                    {
                        "username": "EricaWanja",
                        "content": " `select  sell_date, count(product) as num_sold, string_Agg(product, \\',\\') as products from Activities group by sell_date\\norder by sell_date `\\n\\nWhen i execute above code it causes a repetition in the last row i.e outputs two masks and there is only one, yo can run the code what i mean, anyone who can help me figure this out"
                    }
                ]
            },
            {
                "id": 1783875,
                "content": [
                    {
                        "username": "CoolCoder99",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date;\\n\\nselect sell_date,count(distinct product) as num_sold,group_concat(distinct product) as products from Activities group by sell_date order by sell_date,products;\\n\\nWhy is the second query faster than the first one?\\n"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select sell_date,Count(Distinct(product)) as num_sold,\\nString_agg(product,\\',\\') as products from (\\nselect sell_date,product from activities group by sell_date,product) as temp\\ngroup by sell_date;"
                    },
                    {
                        "username": "Rosanguyen263",
                        "content": "My solution is \\nSELECT\\nsell_date,\\nCount(Distinct product) As num_sold,\\nGroup_concat(product) as Products\\nFROM Activities\\nGroup by sell_date\\n\\n\\nHowever, I dont know why my table gave out the extra count for mask, mask in the colum group_concat \\n"
                    },
                    {
                        "username": "The_Desert_Fox",
                        "content": "Group_concat(product) ------>Group_concat( distinct product)"
                    },
                    {
                        "username": "aymendj",
                        "content": "Why does is say that this query is incorrect, even though the result is almost the same, with the exception of the order of the items in the products column?\\n\\nSELECT \\n        sell_date,\\n        COUNT(DISTINCT product) AS num_sold,\\n        GROUP_CONCAT(product) products\\nFROM \\n        Activities\\nGROUP BY \\n        sell_date\\nORDER BY \\n        sell_date "
                    },
                    {
                        "username": "nayakbhishek",
                        "content": "`can anybody pls tell me whats wrong with my code it is running perfectly fine but while submitting in the test case the format of the dates get\\'s changed to yyyy-m-d due to which i am not able to submit.\\n`\\nselect sell_date ,count(*) as num_sold ,group_concat(product) as products from (\\nselect * , row_number() over(partition by product) as rn from Activities) as x where rn = 1 group by sell_date;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t know how it\\'s acceptance rate is > 80%. It\\'s not easy in MS SQL Server.\\n\\nWITH cte AS (\\n    SELECT DISTINCT sell_date, product\\n    FROM activities\\n)\\nSELECT sell_date, count(1) num_sold, STRING_AGG( product, \\',\\') products\\nFROM cte\\nGROUP BY sell_date\\norder by sell_date;"
                    },
                    {
                        "username": "priyabrata_",
                        "content": "why i am getting run time error\\n MY code\\nselect sell_date , count( distinct product ) as num_sold , \\ngroup_concat ( distinct product order by product ) as products  from Activities group by sell_date order by sell_date;\\n\\nRuntime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'distinct product order by product ) as products  from Activities group by sell_d\\' at line 3\\n "
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi ,\n\nYour code logic is right , just try to avoid putting unnecessary spaces \" \" between the code and also try to put allias name of the column in Quotation Mark like \"num_sold\" .\nThis should solve the issue.\n\nyour code below with correction for reference.\n\n`\nselect sell_date , count(distinct product) as \"num_sold\" , \ngroup_concat(distinct product order by product) as \"products\" from Activities group by sell_date order by sell_date;\n`"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select \\nr.sell_date,max(r.rn) as num_sold , group_concat(distinct r.product) as products  \\nfrom \\n    (\\n        select DISTINCT product, ROW_NUMBER() OVER(partition by sell_date order by product) as rn,\\n              Product as ss, sell_date   \\n        from \\n            Activities  \\n        group by \\n            product \\n        order by \\n            sell_date\\n    ) as r \\ngroup by \\n    r.sell_date \\norder by \\n    r.sell_date \\n\\n\\n"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL SERVER\n\n```WITH [groupped] ([sell_date], [product]) AS \n(SELECT [sell_date], [product]\nFROM [Activities]\nGROUP BY [sell_date], [product])\n\nSELECT \n    [G].[sell_date],\n    COUNT([G].[product]) AS [num_sold],\n    STRING_AGG([G].[product], ',') WITHIN GROUP (ORDER BY [G].[product] ASC) AS [products]\nFROM [groupped] AS [G]\nGROUP BY [sell_date]\nORDER BY [G].[sell_date]"
                    },
                    {
                        "username": "EricaWanja",
                        "content": " `select  sell_date, count(product) as num_sold, string_Agg(product, \\',\\') as products from Activities group by sell_date\\norder by sell_date `\\n\\nWhen i execute above code it causes a repetition in the last row i.e outputs two masks and there is only one, yo can run the code what i mean, anyone who can help me figure this out"
                    }
                ]
            },
            {
                "id": 1773059,
                "content": [
                    {
                        "username": "CoolCoder99",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date;\\n\\nselect sell_date,count(distinct product) as num_sold,group_concat(distinct product) as products from Activities group by sell_date order by sell_date,products;\\n\\nWhy is the second query faster than the first one?\\n"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select sell_date,Count(Distinct(product)) as num_sold,\\nString_agg(product,\\',\\') as products from (\\nselect sell_date,product from activities group by sell_date,product) as temp\\ngroup by sell_date;"
                    },
                    {
                        "username": "Rosanguyen263",
                        "content": "My solution is \\nSELECT\\nsell_date,\\nCount(Distinct product) As num_sold,\\nGroup_concat(product) as Products\\nFROM Activities\\nGroup by sell_date\\n\\n\\nHowever, I dont know why my table gave out the extra count for mask, mask in the colum group_concat \\n"
                    },
                    {
                        "username": "The_Desert_Fox",
                        "content": "Group_concat(product) ------>Group_concat( distinct product)"
                    },
                    {
                        "username": "aymendj",
                        "content": "Why does is say that this query is incorrect, even though the result is almost the same, with the exception of the order of the items in the products column?\\n\\nSELECT \\n        sell_date,\\n        COUNT(DISTINCT product) AS num_sold,\\n        GROUP_CONCAT(product) products\\nFROM \\n        Activities\\nGROUP BY \\n        sell_date\\nORDER BY \\n        sell_date "
                    },
                    {
                        "username": "nayakbhishek",
                        "content": "`can anybody pls tell me whats wrong with my code it is running perfectly fine but while submitting in the test case the format of the dates get\\'s changed to yyyy-m-d due to which i am not able to submit.\\n`\\nselect sell_date ,count(*) as num_sold ,group_concat(product) as products from (\\nselect * , row_number() over(partition by product) as rn from Activities) as x where rn = 1 group by sell_date;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t know how it\\'s acceptance rate is > 80%. It\\'s not easy in MS SQL Server.\\n\\nWITH cte AS (\\n    SELECT DISTINCT sell_date, product\\n    FROM activities\\n)\\nSELECT sell_date, count(1) num_sold, STRING_AGG( product, \\',\\') products\\nFROM cte\\nGROUP BY sell_date\\norder by sell_date;"
                    },
                    {
                        "username": "priyabrata_",
                        "content": "why i am getting run time error\\n MY code\\nselect sell_date , count( distinct product ) as num_sold , \\ngroup_concat ( distinct product order by product ) as products  from Activities group by sell_date order by sell_date;\\n\\nRuntime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'distinct product order by product ) as products  from Activities group by sell_d\\' at line 3\\n "
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi ,\n\nYour code logic is right , just try to avoid putting unnecessary spaces \" \" between the code and also try to put allias name of the column in Quotation Mark like \"num_sold\" .\nThis should solve the issue.\n\nyour code below with correction for reference.\n\n`\nselect sell_date , count(distinct product) as \"num_sold\" , \ngroup_concat(distinct product order by product) as \"products\" from Activities group by sell_date order by sell_date;\n`"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select \\nr.sell_date,max(r.rn) as num_sold , group_concat(distinct r.product) as products  \\nfrom \\n    (\\n        select DISTINCT product, ROW_NUMBER() OVER(partition by sell_date order by product) as rn,\\n              Product as ss, sell_date   \\n        from \\n            Activities  \\n        group by \\n            product \\n        order by \\n            sell_date\\n    ) as r \\ngroup by \\n    r.sell_date \\norder by \\n    r.sell_date \\n\\n\\n"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL SERVER\n\n```WITH [groupped] ([sell_date], [product]) AS \n(SELECT [sell_date], [product]\nFROM [Activities]\nGROUP BY [sell_date], [product])\n\nSELECT \n    [G].[sell_date],\n    COUNT([G].[product]) AS [num_sold],\n    STRING_AGG([G].[product], ',') WITHIN GROUP (ORDER BY [G].[product] ASC) AS [products]\nFROM [groupped] AS [G]\nGROUP BY [sell_date]\nORDER BY [G].[sell_date]"
                    },
                    {
                        "username": "EricaWanja",
                        "content": " `select  sell_date, count(product) as num_sold, string_Agg(product, \\',\\') as products from Activities group by sell_date\\norder by sell_date `\\n\\nWhen i execute above code it causes a repetition in the last row i.e outputs two masks and there is only one, yo can run the code what i mean, anyone who can help me figure this out"
                    }
                ]
            },
            {
                "id": 1771209,
                "content": [
                    {
                        "username": "CoolCoder99",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date;\\n\\nselect sell_date,count(distinct product) as num_sold,group_concat(distinct product) as products from Activities group by sell_date order by sell_date,products;\\n\\nWhy is the second query faster than the first one?\\n"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select sell_date,Count(Distinct(product)) as num_sold,\\nString_agg(product,\\',\\') as products from (\\nselect sell_date,product from activities group by sell_date,product) as temp\\ngroup by sell_date;"
                    },
                    {
                        "username": "Rosanguyen263",
                        "content": "My solution is \\nSELECT\\nsell_date,\\nCount(Distinct product) As num_sold,\\nGroup_concat(product) as Products\\nFROM Activities\\nGroup by sell_date\\n\\n\\nHowever, I dont know why my table gave out the extra count for mask, mask in the colum group_concat \\n"
                    },
                    {
                        "username": "The_Desert_Fox",
                        "content": "Group_concat(product) ------>Group_concat( distinct product)"
                    },
                    {
                        "username": "aymendj",
                        "content": "Why does is say that this query is incorrect, even though the result is almost the same, with the exception of the order of the items in the products column?\\n\\nSELECT \\n        sell_date,\\n        COUNT(DISTINCT product) AS num_sold,\\n        GROUP_CONCAT(product) products\\nFROM \\n        Activities\\nGROUP BY \\n        sell_date\\nORDER BY \\n        sell_date "
                    },
                    {
                        "username": "nayakbhishek",
                        "content": "`can anybody pls tell me whats wrong with my code it is running perfectly fine but while submitting in the test case the format of the dates get\\'s changed to yyyy-m-d due to which i am not able to submit.\\n`\\nselect sell_date ,count(*) as num_sold ,group_concat(product) as products from (\\nselect * , row_number() over(partition by product) as rn from Activities) as x where rn = 1 group by sell_date;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t know how it\\'s acceptance rate is > 80%. It\\'s not easy in MS SQL Server.\\n\\nWITH cte AS (\\n    SELECT DISTINCT sell_date, product\\n    FROM activities\\n)\\nSELECT sell_date, count(1) num_sold, STRING_AGG( product, \\',\\') products\\nFROM cte\\nGROUP BY sell_date\\norder by sell_date;"
                    },
                    {
                        "username": "priyabrata_",
                        "content": "why i am getting run time error\\n MY code\\nselect sell_date , count( distinct product ) as num_sold , \\ngroup_concat ( distinct product order by product ) as products  from Activities group by sell_date order by sell_date;\\n\\nRuntime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'distinct product order by product ) as products  from Activities group by sell_d\\' at line 3\\n "
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi ,\n\nYour code logic is right , just try to avoid putting unnecessary spaces \" \" between the code and also try to put allias name of the column in Quotation Mark like \"num_sold\" .\nThis should solve the issue.\n\nyour code below with correction for reference.\n\n`\nselect sell_date , count(distinct product) as \"num_sold\" , \ngroup_concat(distinct product order by product) as \"products\" from Activities group by sell_date order by sell_date;\n`"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select \\nr.sell_date,max(r.rn) as num_sold , group_concat(distinct r.product) as products  \\nfrom \\n    (\\n        select DISTINCT product, ROW_NUMBER() OVER(partition by sell_date order by product) as rn,\\n              Product as ss, sell_date   \\n        from \\n            Activities  \\n        group by \\n            product \\n        order by \\n            sell_date\\n    ) as r \\ngroup by \\n    r.sell_date \\norder by \\n    r.sell_date \\n\\n\\n"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL SERVER\n\n```WITH [groupped] ([sell_date], [product]) AS \n(SELECT [sell_date], [product]\nFROM [Activities]\nGROUP BY [sell_date], [product])\n\nSELECT \n    [G].[sell_date],\n    COUNT([G].[product]) AS [num_sold],\n    STRING_AGG([G].[product], ',') WITHIN GROUP (ORDER BY [G].[product] ASC) AS [products]\nFROM [groupped] AS [G]\nGROUP BY [sell_date]\nORDER BY [G].[sell_date]"
                    },
                    {
                        "username": "EricaWanja",
                        "content": " `select  sell_date, count(product) as num_sold, string_Agg(product, \\',\\') as products from Activities group by sell_date\\norder by sell_date `\\n\\nWhen i execute above code it causes a repetition in the last row i.e outputs two masks and there is only one, yo can run the code what i mean, anyone who can help me figure this out"
                    }
                ]
            },
            {
                "id": 1769384,
                "content": [
                    {
                        "username": "CoolCoder99",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date;\\n\\nselect sell_date,count(distinct product) as num_sold,group_concat(distinct product) as products from Activities group by sell_date order by sell_date,products;\\n\\nWhy is the second query faster than the first one?\\n"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select sell_date,Count(Distinct(product)) as num_sold,\\nString_agg(product,\\',\\') as products from (\\nselect sell_date,product from activities group by sell_date,product) as temp\\ngroup by sell_date;"
                    },
                    {
                        "username": "Rosanguyen263",
                        "content": "My solution is \\nSELECT\\nsell_date,\\nCount(Distinct product) As num_sold,\\nGroup_concat(product) as Products\\nFROM Activities\\nGroup by sell_date\\n\\n\\nHowever, I dont know why my table gave out the extra count for mask, mask in the colum group_concat \\n"
                    },
                    {
                        "username": "The_Desert_Fox",
                        "content": "Group_concat(product) ------>Group_concat( distinct product)"
                    },
                    {
                        "username": "aymendj",
                        "content": "Why does is say that this query is incorrect, even though the result is almost the same, with the exception of the order of the items in the products column?\\n\\nSELECT \\n        sell_date,\\n        COUNT(DISTINCT product) AS num_sold,\\n        GROUP_CONCAT(product) products\\nFROM \\n        Activities\\nGROUP BY \\n        sell_date\\nORDER BY \\n        sell_date "
                    },
                    {
                        "username": "nayakbhishek",
                        "content": "`can anybody pls tell me whats wrong with my code it is running perfectly fine but while submitting in the test case the format of the dates get\\'s changed to yyyy-m-d due to which i am not able to submit.\\n`\\nselect sell_date ,count(*) as num_sold ,group_concat(product) as products from (\\nselect * , row_number() over(partition by product) as rn from Activities) as x where rn = 1 group by sell_date;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t know how it\\'s acceptance rate is > 80%. It\\'s not easy in MS SQL Server.\\n\\nWITH cte AS (\\n    SELECT DISTINCT sell_date, product\\n    FROM activities\\n)\\nSELECT sell_date, count(1) num_sold, STRING_AGG( product, \\',\\') products\\nFROM cte\\nGROUP BY sell_date\\norder by sell_date;"
                    },
                    {
                        "username": "priyabrata_",
                        "content": "why i am getting run time error\\n MY code\\nselect sell_date , count( distinct product ) as num_sold , \\ngroup_concat ( distinct product order by product ) as products  from Activities group by sell_date order by sell_date;\\n\\nRuntime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'distinct product order by product ) as products  from Activities group by sell_d\\' at line 3\\n "
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi ,\n\nYour code logic is right , just try to avoid putting unnecessary spaces \" \" between the code and also try to put allias name of the column in Quotation Mark like \"num_sold\" .\nThis should solve the issue.\n\nyour code below with correction for reference.\n\n`\nselect sell_date , count(distinct product) as \"num_sold\" , \ngroup_concat(distinct product order by product) as \"products\" from Activities group by sell_date order by sell_date;\n`"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select \\nr.sell_date,max(r.rn) as num_sold , group_concat(distinct r.product) as products  \\nfrom \\n    (\\n        select DISTINCT product, ROW_NUMBER() OVER(partition by sell_date order by product) as rn,\\n              Product as ss, sell_date   \\n        from \\n            Activities  \\n        group by \\n            product \\n        order by \\n            sell_date\\n    ) as r \\ngroup by \\n    r.sell_date \\norder by \\n    r.sell_date \\n\\n\\n"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL SERVER\n\n```WITH [groupped] ([sell_date], [product]) AS \n(SELECT [sell_date], [product]\nFROM [Activities]\nGROUP BY [sell_date], [product])\n\nSELECT \n    [G].[sell_date],\n    COUNT([G].[product]) AS [num_sold],\n    STRING_AGG([G].[product], ',') WITHIN GROUP (ORDER BY [G].[product] ASC) AS [products]\nFROM [groupped] AS [G]\nGROUP BY [sell_date]\nORDER BY [G].[sell_date]"
                    },
                    {
                        "username": "EricaWanja",
                        "content": " `select  sell_date, count(product) as num_sold, string_Agg(product, \\',\\') as products from Activities group by sell_date\\norder by sell_date `\\n\\nWhen i execute above code it causes a repetition in the last row i.e outputs two masks and there is only one, yo can run the code what i mean, anyone who can help me figure this out"
                    }
                ]
            },
            {
                "id": 1765392,
                "content": [
                    {
                        "username": "CoolCoder99",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date;\\n\\nselect sell_date,count(distinct product) as num_sold,group_concat(distinct product) as products from Activities group by sell_date order by sell_date,products;\\n\\nWhy is the second query faster than the first one?\\n"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select sell_date,Count(Distinct(product)) as num_sold,\\nString_agg(product,\\',\\') as products from (\\nselect sell_date,product from activities group by sell_date,product) as temp\\ngroup by sell_date;"
                    },
                    {
                        "username": "Rosanguyen263",
                        "content": "My solution is \\nSELECT\\nsell_date,\\nCount(Distinct product) As num_sold,\\nGroup_concat(product) as Products\\nFROM Activities\\nGroup by sell_date\\n\\n\\nHowever, I dont know why my table gave out the extra count for mask, mask in the colum group_concat \\n"
                    },
                    {
                        "username": "The_Desert_Fox",
                        "content": "Group_concat(product) ------>Group_concat( distinct product)"
                    },
                    {
                        "username": "aymendj",
                        "content": "Why does is say that this query is incorrect, even though the result is almost the same, with the exception of the order of the items in the products column?\\n\\nSELECT \\n        sell_date,\\n        COUNT(DISTINCT product) AS num_sold,\\n        GROUP_CONCAT(product) products\\nFROM \\n        Activities\\nGROUP BY \\n        sell_date\\nORDER BY \\n        sell_date "
                    },
                    {
                        "username": "nayakbhishek",
                        "content": "`can anybody pls tell me whats wrong with my code it is running perfectly fine but while submitting in the test case the format of the dates get\\'s changed to yyyy-m-d due to which i am not able to submit.\\n`\\nselect sell_date ,count(*) as num_sold ,group_concat(product) as products from (\\nselect * , row_number() over(partition by product) as rn from Activities) as x where rn = 1 group by sell_date;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t know how it\\'s acceptance rate is > 80%. It\\'s not easy in MS SQL Server.\\n\\nWITH cte AS (\\n    SELECT DISTINCT sell_date, product\\n    FROM activities\\n)\\nSELECT sell_date, count(1) num_sold, STRING_AGG( product, \\',\\') products\\nFROM cte\\nGROUP BY sell_date\\norder by sell_date;"
                    },
                    {
                        "username": "priyabrata_",
                        "content": "why i am getting run time error\\n MY code\\nselect sell_date , count( distinct product ) as num_sold , \\ngroup_concat ( distinct product order by product ) as products  from Activities group by sell_date order by sell_date;\\n\\nRuntime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'distinct product order by product ) as products  from Activities group by sell_d\\' at line 3\\n "
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi ,\n\nYour code logic is right , just try to avoid putting unnecessary spaces \" \" between the code and also try to put allias name of the column in Quotation Mark like \"num_sold\" .\nThis should solve the issue.\n\nyour code below with correction for reference.\n\n`\nselect sell_date , count(distinct product) as \"num_sold\" , \ngroup_concat(distinct product order by product) as \"products\" from Activities group by sell_date order by sell_date;\n`"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select \\nr.sell_date,max(r.rn) as num_sold , group_concat(distinct r.product) as products  \\nfrom \\n    (\\n        select DISTINCT product, ROW_NUMBER() OVER(partition by sell_date order by product) as rn,\\n              Product as ss, sell_date   \\n        from \\n            Activities  \\n        group by \\n            product \\n        order by \\n            sell_date\\n    ) as r \\ngroup by \\n    r.sell_date \\norder by \\n    r.sell_date \\n\\n\\n"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL SERVER\n\n```WITH [groupped] ([sell_date], [product]) AS \n(SELECT [sell_date], [product]\nFROM [Activities]\nGROUP BY [sell_date], [product])\n\nSELECT \n    [G].[sell_date],\n    COUNT([G].[product]) AS [num_sold],\n    STRING_AGG([G].[product], ',') WITHIN GROUP (ORDER BY [G].[product] ASC) AS [products]\nFROM [groupped] AS [G]\nGROUP BY [sell_date]\nORDER BY [G].[sell_date]"
                    },
                    {
                        "username": "EricaWanja",
                        "content": " `select  sell_date, count(product) as num_sold, string_Agg(product, \\',\\') as products from Activities group by sell_date\\norder by sell_date `\\n\\nWhen i execute above code it causes a repetition in the last row i.e outputs two masks and there is only one, yo can run the code what i mean, anyone who can help me figure this out"
                    }
                ]
            },
            {
                "id": 1763246,
                "content": [
                    {
                        "username": "CoolCoder99",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date;\\n\\nselect sell_date,count(distinct product) as num_sold,group_concat(distinct product) as products from Activities group by sell_date order by sell_date,products;\\n\\nWhy is the second query faster than the first one?\\n"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select sell_date,Count(Distinct(product)) as num_sold,\\nString_agg(product,\\',\\') as products from (\\nselect sell_date,product from activities group by sell_date,product) as temp\\ngroup by sell_date;"
                    },
                    {
                        "username": "Rosanguyen263",
                        "content": "My solution is \\nSELECT\\nsell_date,\\nCount(Distinct product) As num_sold,\\nGroup_concat(product) as Products\\nFROM Activities\\nGroup by sell_date\\n\\n\\nHowever, I dont know why my table gave out the extra count for mask, mask in the colum group_concat \\n"
                    },
                    {
                        "username": "The_Desert_Fox",
                        "content": "Group_concat(product) ------>Group_concat( distinct product)"
                    },
                    {
                        "username": "aymendj",
                        "content": "Why does is say that this query is incorrect, even though the result is almost the same, with the exception of the order of the items in the products column?\\n\\nSELECT \\n        sell_date,\\n        COUNT(DISTINCT product) AS num_sold,\\n        GROUP_CONCAT(product) products\\nFROM \\n        Activities\\nGROUP BY \\n        sell_date\\nORDER BY \\n        sell_date "
                    },
                    {
                        "username": "nayakbhishek",
                        "content": "`can anybody pls tell me whats wrong with my code it is running perfectly fine but while submitting in the test case the format of the dates get\\'s changed to yyyy-m-d due to which i am not able to submit.\\n`\\nselect sell_date ,count(*) as num_sold ,group_concat(product) as products from (\\nselect * , row_number() over(partition by product) as rn from Activities) as x where rn = 1 group by sell_date;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t know how it\\'s acceptance rate is > 80%. It\\'s not easy in MS SQL Server.\\n\\nWITH cte AS (\\n    SELECT DISTINCT sell_date, product\\n    FROM activities\\n)\\nSELECT sell_date, count(1) num_sold, STRING_AGG( product, \\',\\') products\\nFROM cte\\nGROUP BY sell_date\\norder by sell_date;"
                    },
                    {
                        "username": "priyabrata_",
                        "content": "why i am getting run time error\\n MY code\\nselect sell_date , count( distinct product ) as num_sold , \\ngroup_concat ( distinct product order by product ) as products  from Activities group by sell_date order by sell_date;\\n\\nRuntime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'distinct product order by product ) as products  from Activities group by sell_d\\' at line 3\\n "
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi ,\n\nYour code logic is right , just try to avoid putting unnecessary spaces \" \" between the code and also try to put allias name of the column in Quotation Mark like \"num_sold\" .\nThis should solve the issue.\n\nyour code below with correction for reference.\n\n`\nselect sell_date , count(distinct product) as \"num_sold\" , \ngroup_concat(distinct product order by product) as \"products\" from Activities group by sell_date order by sell_date;\n`"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select \\nr.sell_date,max(r.rn) as num_sold , group_concat(distinct r.product) as products  \\nfrom \\n    (\\n        select DISTINCT product, ROW_NUMBER() OVER(partition by sell_date order by product) as rn,\\n              Product as ss, sell_date   \\n        from \\n            Activities  \\n        group by \\n            product \\n        order by \\n            sell_date\\n    ) as r \\ngroup by \\n    r.sell_date \\norder by \\n    r.sell_date \\n\\n\\n"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL SERVER\n\n```WITH [groupped] ([sell_date], [product]) AS \n(SELECT [sell_date], [product]\nFROM [Activities]\nGROUP BY [sell_date], [product])\n\nSELECT \n    [G].[sell_date],\n    COUNT([G].[product]) AS [num_sold],\n    STRING_AGG([G].[product], ',') WITHIN GROUP (ORDER BY [G].[product] ASC) AS [products]\nFROM [groupped] AS [G]\nGROUP BY [sell_date]\nORDER BY [G].[sell_date]"
                    },
                    {
                        "username": "EricaWanja",
                        "content": " `select  sell_date, count(product) as num_sold, string_Agg(product, \\',\\') as products from Activities group by sell_date\\norder by sell_date `\\n\\nWhen i execute above code it causes a repetition in the last row i.e outputs two masks and there is only one, yo can run the code what i mean, anyone who can help me figure this out"
                    }
                ]
            },
            {
                "id": 1762076,
                "content": [
                    {
                        "username": "CoolCoder99",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date;\\n\\nselect sell_date,count(distinct product) as num_sold,group_concat(distinct product) as products from Activities group by sell_date order by sell_date,products;\\n\\nWhy is the second query faster than the first one?\\n"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select sell_date,Count(Distinct(product)) as num_sold,\\nString_agg(product,\\',\\') as products from (\\nselect sell_date,product from activities group by sell_date,product) as temp\\ngroup by sell_date;"
                    },
                    {
                        "username": "Rosanguyen263",
                        "content": "My solution is \\nSELECT\\nsell_date,\\nCount(Distinct product) As num_sold,\\nGroup_concat(product) as Products\\nFROM Activities\\nGroup by sell_date\\n\\n\\nHowever, I dont know why my table gave out the extra count for mask, mask in the colum group_concat \\n"
                    },
                    {
                        "username": "The_Desert_Fox",
                        "content": "Group_concat(product) ------>Group_concat( distinct product)"
                    },
                    {
                        "username": "aymendj",
                        "content": "Why does is say that this query is incorrect, even though the result is almost the same, with the exception of the order of the items in the products column?\\n\\nSELECT \\n        sell_date,\\n        COUNT(DISTINCT product) AS num_sold,\\n        GROUP_CONCAT(product) products\\nFROM \\n        Activities\\nGROUP BY \\n        sell_date\\nORDER BY \\n        sell_date "
                    },
                    {
                        "username": "nayakbhishek",
                        "content": "`can anybody pls tell me whats wrong with my code it is running perfectly fine but while submitting in the test case the format of the dates get\\'s changed to yyyy-m-d due to which i am not able to submit.\\n`\\nselect sell_date ,count(*) as num_sold ,group_concat(product) as products from (\\nselect * , row_number() over(partition by product) as rn from Activities) as x where rn = 1 group by sell_date;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t know how it\\'s acceptance rate is > 80%. It\\'s not easy in MS SQL Server.\\n\\nWITH cte AS (\\n    SELECT DISTINCT sell_date, product\\n    FROM activities\\n)\\nSELECT sell_date, count(1) num_sold, STRING_AGG( product, \\',\\') products\\nFROM cte\\nGROUP BY sell_date\\norder by sell_date;"
                    },
                    {
                        "username": "priyabrata_",
                        "content": "why i am getting run time error\\n MY code\\nselect sell_date , count( distinct product ) as num_sold , \\ngroup_concat ( distinct product order by product ) as products  from Activities group by sell_date order by sell_date;\\n\\nRuntime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'distinct product order by product ) as products  from Activities group by sell_d\\' at line 3\\n "
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi ,\n\nYour code logic is right , just try to avoid putting unnecessary spaces \" \" between the code and also try to put allias name of the column in Quotation Mark like \"num_sold\" .\nThis should solve the issue.\n\nyour code below with correction for reference.\n\n`\nselect sell_date , count(distinct product) as \"num_sold\" , \ngroup_concat(distinct product order by product) as \"products\" from Activities group by sell_date order by sell_date;\n`"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select \\nr.sell_date,max(r.rn) as num_sold , group_concat(distinct r.product) as products  \\nfrom \\n    (\\n        select DISTINCT product, ROW_NUMBER() OVER(partition by sell_date order by product) as rn,\\n              Product as ss, sell_date   \\n        from \\n            Activities  \\n        group by \\n            product \\n        order by \\n            sell_date\\n    ) as r \\ngroup by \\n    r.sell_date \\norder by \\n    r.sell_date \\n\\n\\n"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL SERVER\n\n```WITH [groupped] ([sell_date], [product]) AS \n(SELECT [sell_date], [product]\nFROM [Activities]\nGROUP BY [sell_date], [product])\n\nSELECT \n    [G].[sell_date],\n    COUNT([G].[product]) AS [num_sold],\n    STRING_AGG([G].[product], ',') WITHIN GROUP (ORDER BY [G].[product] ASC) AS [products]\nFROM [groupped] AS [G]\nGROUP BY [sell_date]\nORDER BY [G].[sell_date]"
                    },
                    {
                        "username": "EricaWanja",
                        "content": " `select  sell_date, count(product) as num_sold, string_Agg(product, \\',\\') as products from Activities group by sell_date\\norder by sell_date `\\n\\nWhen i execute above code it causes a repetition in the last row i.e outputs two masks and there is only one, yo can run the code what i mean, anyone who can help me figure this out"
                    }
                ]
            },
            {
                "id": 1758037,
                "content": [
                    {
                        "username": "CoolCoder99",
                        "content": "select sell_date,count(distinct product) as num_sold,group_concat(distinct product order by product) as products from Activities group by sell_date;\\n\\nselect sell_date,count(distinct product) as num_sold,group_concat(distinct product) as products from Activities group by sell_date order by sell_date,products;\\n\\nWhy is the second query faster than the first one?\\n"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select sell_date,Count(Distinct(product)) as num_sold,\\nString_agg(product,\\',\\') as products from (\\nselect sell_date,product from activities group by sell_date,product) as temp\\ngroup by sell_date;"
                    },
                    {
                        "username": "Rosanguyen263",
                        "content": "My solution is \\nSELECT\\nsell_date,\\nCount(Distinct product) As num_sold,\\nGroup_concat(product) as Products\\nFROM Activities\\nGroup by sell_date\\n\\n\\nHowever, I dont know why my table gave out the extra count for mask, mask in the colum group_concat \\n"
                    },
                    {
                        "username": "The_Desert_Fox",
                        "content": "Group_concat(product) ------>Group_concat( distinct product)"
                    },
                    {
                        "username": "aymendj",
                        "content": "Why does is say that this query is incorrect, even though the result is almost the same, with the exception of the order of the items in the products column?\\n\\nSELECT \\n        sell_date,\\n        COUNT(DISTINCT product) AS num_sold,\\n        GROUP_CONCAT(product) products\\nFROM \\n        Activities\\nGROUP BY \\n        sell_date\\nORDER BY \\n        sell_date "
                    },
                    {
                        "username": "nayakbhishek",
                        "content": "`can anybody pls tell me whats wrong with my code it is running perfectly fine but while submitting in the test case the format of the dates get\\'s changed to yyyy-m-d due to which i am not able to submit.\\n`\\nselect sell_date ,count(*) as num_sold ,group_concat(product) as products from (\\nselect * , row_number() over(partition by product) as rn from Activities) as x where rn = 1 group by sell_date;"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t know how it\\'s acceptance rate is > 80%. It\\'s not easy in MS SQL Server.\\n\\nWITH cte AS (\\n    SELECT DISTINCT sell_date, product\\n    FROM activities\\n)\\nSELECT sell_date, count(1) num_sold, STRING_AGG( product, \\',\\') products\\nFROM cte\\nGROUP BY sell_date\\norder by sell_date;"
                    },
                    {
                        "username": "priyabrata_",
                        "content": "why i am getting run time error\\n MY code\\nselect sell_date , count( distinct product ) as num_sold , \\ngroup_concat ( distinct product order by product ) as products  from Activities group by sell_date order by sell_date;\\n\\nRuntime Error\\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'distinct product order by product ) as products  from Activities group by sell_d\\' at line 3\\n "
                    },
                    {
                        "username": "ajay203",
                        "content": "Hi ,\n\nYour code logic is right , just try to avoid putting unnecessary spaces \" \" between the code and also try to put allias name of the column in Quotation Mark like \"num_sold\" .\nThis should solve the issue.\n\nyour code below with correction for reference.\n\n`\nselect sell_date , count(distinct product) as \"num_sold\" , \ngroup_concat(distinct product order by product) as \"products\" from Activities group by sell_date order by sell_date;\n`"
                    },
                    {
                        "username": "abdelrahmanmah",
                        "content": "select \\nr.sell_date,max(r.rn) as num_sold , group_concat(distinct r.product) as products  \\nfrom \\n    (\\n        select DISTINCT product, ROW_NUMBER() OVER(partition by sell_date order by product) as rn,\\n              Product as ss, sell_date   \\n        from \\n            Activities  \\n        group by \\n            product \\n        order by \\n            sell_date\\n    ) as r \\ngroup by \\n    r.sell_date \\norder by \\n    r.sell_date \\n\\n\\n"
                    },
                    {
                        "username": "linuxchata",
                        "content": "MS SQL SERVER\n\n```WITH [groupped] ([sell_date], [product]) AS \n(SELECT [sell_date], [product]\nFROM [Activities]\nGROUP BY [sell_date], [product])\n\nSELECT \n    [G].[sell_date],\n    COUNT([G].[product]) AS [num_sold],\n    STRING_AGG([G].[product], ',') WITHIN GROUP (ORDER BY [G].[product] ASC) AS [products]\nFROM [groupped] AS [G]\nGROUP BY [sell_date]\nORDER BY [G].[sell_date]"
                    },
                    {
                        "username": "EricaWanja",
                        "content": " `select  sell_date, count(product) as num_sold, string_Agg(product, \\',\\') as products from Activities group by sell_date\\norder by sell_date `\\n\\nWhen i execute above code it causes a repetition in the last row i.e outputs two masks and there is only one, yo can run the code what i mean, anyone who can help me figure this out"
                    }
                ]
            }
        ]
    },
    {
        "title": "Clone Binary Tree With Random Pointer",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1833536,
                "content": [
                    {
                        "username": "IliaOzhmegov",
                        "content": "I spend too much on this due to not being careful enough, hopefully my hint save somebody time: \\nMake sure that you return a `NodeCopy` instance and not just a `Node` instance.\\n\\nI solved it in Python and a `NodeCopy` class defined somewhere outside, but they show the definition only for `Node` class, which were slightly confusing. So I was creating the instances of the `Node` class instead of `NodeCopy`, it could\\'t understand what was the problem which is funny because I thought that there is something wrong with my deep copy approach, hehe."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint 1</span>\\n\\nKeep a hash map of cloned nodes\\n\\n# <span style=\\'color:green\\'>Hint 2</span>\\nUse a function to create a cloned node if it\\'s not in the hash map or return it if it is"
                    },
                    {
                        "username": "TangHao1987",
                        "content": "The most important condition is missing in the description:\\nThe Node and NodeCopy class is hashable. "
                    },
                    {
                        "username": "samdcodes",
                        "content": "shouldn\\'t really matter at least in the java case, memory signatures is enough in this problem no?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Frankly I despise this question. The whole point of a graph structure like a tree is that the nodes and their pointers define the structure. There IS no natural implied index. We arent supposed to think of the nodes as being stored in an array that can be accessed via index. Now you could make a node class where the nodes have unique IDs, but this would be a stored property of the node. I guess that would make this problem too simple. Instead we have to discern that there IS an implied sort of indexing here and I guess map that? This seems so unusual, and not in good or clever way, but obtuse and obnoxious. \n\nFurthermore, I dont know what is up with the implementation of the checker, but this questions seems to have weirdly fragile results. I CANNOT get the debugger to behave properly. It just exits early, even when stepping through line by line and will terminate at random lines, include some that are VERY basic operations. This whole thing needs to be reevaluated. "
                    },
                    {
                        "username": "XuLuYue",
                        "content": "Two DFS methods solved the problem."
                    }
                ]
            },
            {
                "id": 1804711,
                "content": [
                    {
                        "username": "IliaOzhmegov",
                        "content": "I spend too much on this due to not being careful enough, hopefully my hint save somebody time: \\nMake sure that you return a `NodeCopy` instance and not just a `Node` instance.\\n\\nI solved it in Python and a `NodeCopy` class defined somewhere outside, but they show the definition only for `Node` class, which were slightly confusing. So I was creating the instances of the `Node` class instead of `NodeCopy`, it could\\'t understand what was the problem which is funny because I thought that there is something wrong with my deep copy approach, hehe."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint 1</span>\\n\\nKeep a hash map of cloned nodes\\n\\n# <span style=\\'color:green\\'>Hint 2</span>\\nUse a function to create a cloned node if it\\'s not in the hash map or return it if it is"
                    },
                    {
                        "username": "TangHao1987",
                        "content": "The most important condition is missing in the description:\\nThe Node and NodeCopy class is hashable. "
                    },
                    {
                        "username": "samdcodes",
                        "content": "shouldn\\'t really matter at least in the java case, memory signatures is enough in this problem no?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Frankly I despise this question. The whole point of a graph structure like a tree is that the nodes and their pointers define the structure. There IS no natural implied index. We arent supposed to think of the nodes as being stored in an array that can be accessed via index. Now you could make a node class where the nodes have unique IDs, but this would be a stored property of the node. I guess that would make this problem too simple. Instead we have to discern that there IS an implied sort of indexing here and I guess map that? This seems so unusual, and not in good or clever way, but obtuse and obnoxious. \n\nFurthermore, I dont know what is up with the implementation of the checker, but this questions seems to have weirdly fragile results. I CANNOT get the debugger to behave properly. It just exits early, even when stepping through line by line and will terminate at random lines, include some that are VERY basic operations. This whole thing needs to be reevaluated. "
                    },
                    {
                        "username": "XuLuYue",
                        "content": "Two DFS methods solved the problem."
                    }
                ]
            },
            {
                "id": 1834017,
                "content": [
                    {
                        "username": "IliaOzhmegov",
                        "content": "I spend too much on this due to not being careful enough, hopefully my hint save somebody time: \\nMake sure that you return a `NodeCopy` instance and not just a `Node` instance.\\n\\nI solved it in Python and a `NodeCopy` class defined somewhere outside, but they show the definition only for `Node` class, which were slightly confusing. So I was creating the instances of the `Node` class instead of `NodeCopy`, it could\\'t understand what was the problem which is funny because I thought that there is something wrong with my deep copy approach, hehe."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint 1</span>\\n\\nKeep a hash map of cloned nodes\\n\\n# <span style=\\'color:green\\'>Hint 2</span>\\nUse a function to create a cloned node if it\\'s not in the hash map or return it if it is"
                    },
                    {
                        "username": "TangHao1987",
                        "content": "The most important condition is missing in the description:\\nThe Node and NodeCopy class is hashable. "
                    },
                    {
                        "username": "samdcodes",
                        "content": "shouldn\\'t really matter at least in the java case, memory signatures is enough in this problem no?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Frankly I despise this question. The whole point of a graph structure like a tree is that the nodes and their pointers define the structure. There IS no natural implied index. We arent supposed to think of the nodes as being stored in an array that can be accessed via index. Now you could make a node class where the nodes have unique IDs, but this would be a stored property of the node. I guess that would make this problem too simple. Instead we have to discern that there IS an implied sort of indexing here and I guess map that? This seems so unusual, and not in good or clever way, but obtuse and obnoxious. \n\nFurthermore, I dont know what is up with the implementation of the checker, but this questions seems to have weirdly fragile results. I CANNOT get the debugger to behave properly. It just exits early, even when stepping through line by line and will terminate at random lines, include some that are VERY basic operations. This whole thing needs to be reevaluated. "
                    },
                    {
                        "username": "XuLuYue",
                        "content": "Two DFS methods solved the problem."
                    }
                ]
            },
            {
                "id": 1833057,
                "content": [
                    {
                        "username": "IliaOzhmegov",
                        "content": "I spend too much on this due to not being careful enough, hopefully my hint save somebody time: \\nMake sure that you return a `NodeCopy` instance and not just a `Node` instance.\\n\\nI solved it in Python and a `NodeCopy` class defined somewhere outside, but they show the definition only for `Node` class, which were slightly confusing. So I was creating the instances of the `Node` class instead of `NodeCopy`, it could\\'t understand what was the problem which is funny because I thought that there is something wrong with my deep copy approach, hehe."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint 1</span>\\n\\nKeep a hash map of cloned nodes\\n\\n# <span style=\\'color:green\\'>Hint 2</span>\\nUse a function to create a cloned node if it\\'s not in the hash map or return it if it is"
                    },
                    {
                        "username": "TangHao1987",
                        "content": "The most important condition is missing in the description:\\nThe Node and NodeCopy class is hashable. "
                    },
                    {
                        "username": "samdcodes",
                        "content": "shouldn\\'t really matter at least in the java case, memory signatures is enough in this problem no?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Frankly I despise this question. The whole point of a graph structure like a tree is that the nodes and their pointers define the structure. There IS no natural implied index. We arent supposed to think of the nodes as being stored in an array that can be accessed via index. Now you could make a node class where the nodes have unique IDs, but this would be a stored property of the node. I guess that would make this problem too simple. Instead we have to discern that there IS an implied sort of indexing here and I guess map that? This seems so unusual, and not in good or clever way, but obtuse and obnoxious. \n\nFurthermore, I dont know what is up with the implementation of the checker, but this questions seems to have weirdly fragile results. I CANNOT get the debugger to behave properly. It just exits early, even when stepping through line by line and will terminate at random lines, include some that are VERY basic operations. This whole thing needs to be reevaluated. "
                    },
                    {
                        "username": "XuLuYue",
                        "content": "Two DFS methods solved the problem."
                    }
                ]
            },
            {
                "id": 1835362,
                "content": [
                    {
                        "username": "IliaOzhmegov",
                        "content": "I spend too much on this due to not being careful enough, hopefully my hint save somebody time: \\nMake sure that you return a `NodeCopy` instance and not just a `Node` instance.\\n\\nI solved it in Python and a `NodeCopy` class defined somewhere outside, but they show the definition only for `Node` class, which were slightly confusing. So I was creating the instances of the `Node` class instead of `NodeCopy`, it could\\'t understand what was the problem which is funny because I thought that there is something wrong with my deep copy approach, hehe."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint 1</span>\\n\\nKeep a hash map of cloned nodes\\n\\n# <span style=\\'color:green\\'>Hint 2</span>\\nUse a function to create a cloned node if it\\'s not in the hash map or return it if it is"
                    },
                    {
                        "username": "TangHao1987",
                        "content": "The most important condition is missing in the description:\\nThe Node and NodeCopy class is hashable. "
                    },
                    {
                        "username": "samdcodes",
                        "content": "shouldn\\'t really matter at least in the java case, memory signatures is enough in this problem no?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Frankly I despise this question. The whole point of a graph structure like a tree is that the nodes and their pointers define the structure. There IS no natural implied index. We arent supposed to think of the nodes as being stored in an array that can be accessed via index. Now you could make a node class where the nodes have unique IDs, but this would be a stored property of the node. I guess that would make this problem too simple. Instead we have to discern that there IS an implied sort of indexing here and I guess map that? This seems so unusual, and not in good or clever way, but obtuse and obnoxious. \n\nFurthermore, I dont know what is up with the implementation of the checker, but this questions seems to have weirdly fragile results. I CANNOT get the debugger to behave properly. It just exits early, even when stepping through line by line and will terminate at random lines, include some that are VERY basic operations. This whole thing needs to be reevaluated. "
                    },
                    {
                        "username": "XuLuYue",
                        "content": "Two DFS methods solved the problem."
                    }
                ]
            }
        ]
    },
    {
        "title": "XOR Operation in an Array",
        "question_content": "<p>You are given an integer <code>n</code> and an integer <code>start</code>.</p>\n\n<p>Define an array <code>nums</code> where <code>nums[i] = start + 2 * i</code> (<strong>0-indexed</strong>) and <code>n == nums.length</code>.</p>\n\n<p>Return <em>the bitwise XOR of all elements of</em> <code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, start = 0\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.\nWhere &quot;^&quot; corresponds to bitwise XOR operator.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, start = 3\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= start &lt;= 1000</code></li>\n\t<li><code>n == nums.length</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 699141,
                "title": "visual-solution-python-o-1-time-o-1-space",
                "content": "The trivial solution to this problem is the brute force approach. \\nThis solution uses O(n) Time and O(n) Space\\n\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        \\n        ans = 0\\n        nums = [start + n * 2 for n in range(n)]\\n        \\n        for n in nums:\\n            ans = ans ^ n\\n        return ans \\n        \\n```\\n\\nWhile this solution is easy let\\'s try to find something better. Let\\'s print some examples using the previous algorithm by adding in the following line in the for loop.\\n\\n```\\nprint(f\"Nums: {n} Ans: {ans}\")\\n```\\n\\n.\\n**Example:**\\nStart  = 0 ,1 \\nn = 1...8 \\n\\n![image](https://assets.leetcode.com/users/images/30d64e34-4ca0-4451-a5ab-d751e192c272_1592771245.7420313.png)\\n\\nLooking at these charts it is easy to spot a pattern for some of the rows.\\nThe pattern repeats after every 4th number\\n\\n[N % 4 == 1] Green Row: Ans = Number[N]\\n[N % 4 == 2] Yellow Row: Ans = 2\\n[N % 4 == 3] Red Row: Ans = Number[N] ^ 2\\n[N % 4 == 0] Blue Row: Ans = 0\\n\\n.\\n**Next Example:**\\nStart  = 2 , 3\\nn = 1...8 \\n\\n![image](https://assets.leetcode.com/users/images/5aad9815-00c3-44de-85c3-56fe028921a0_1592770409.9596157.png)\\n\\nLooking at these charts it is easy to spot a pattern for some of the rows.\\nHere, the pattern also repeats after every 4th number.\\n\\n[N % 4 == 1] Green Row: Ans = Number[1]\\n[N % 4 == 2] Yellow Row: Ans = Number[N] ^ Number[1]\\n[N % 4 == 3] Red Row: Ans = Number[1] ^ 2\\n[N % 4 == 0] Blue Row: Ans = Number[N] ^ Number[1] ^ 2\\n\\nThese patterns are a bit trickier to find. Start with the obvious one (Green). We know that each value is based on being xOr with the previous number. For yellow, just the number xOr with Green.\\n\\nRed value is constant so that one is also easy to find. For blue just follow the same logic used to find yellow. \\n\\nIf you were to continue this you would see that the examples would repeat themselves\\n\\n.\\n**Code Solution:**\\n\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        \\n        last = start + 2 * (n-1)\\n\\n        if start % 4 <= 1:\\n            if n % 4 == 1: \\n                return last\\n            elif n % 4 == 2: \\n                return 2\\n            elif n % 4 == 3: \\n                return 2 ^ last\\n            else: \\n                return 0\\n\\n        else:\\n            if n % 4 == 1: \\n                return start\\n            elif n % 4 == 2: \\n                return start ^ last\\n            elif n % 4 == 3: \\n                return start ^ 2\\n            else: \\n                return start ^ 2 ^ last\\n```\\n        \\nArgent \\nLike if this helped \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        \\n        ans = 0\\n        nums = [start + n * 2 for n in range(n)]\\n        \\n        for n in nums:\\n            ans = ans ^ n\\n        return ans \\n        \\n```\n```\\nprint(f\"Nums: {n} Ans: {ans}\")\\n```\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        \\n        last = start + 2 * (n-1)\\n\\n        if start % 4 <= 1:\\n            if n % 4 == 1: \\n                return last\\n            elif n % 4 == 2: \\n                return 2\\n            elif n % 4 == 3: \\n                return 2 ^ last\\n            else: \\n                return 0\\n\\n        else:\\n            if n % 4 == 1: \\n                return start\\n            elif n % 4 == 2: \\n                return start ^ last\\n            elif n % 4 == 3: \\n                return start ^ 2\\n            else: \\n                return start ^ 2 ^ last\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697849,
                "title": "o-1-time",
                "content": "```\\nclass Solution\\n{\\n    int xorOperationB(int n, int start)\\n    {\\n        if (n % 2 == 0)\\n            return (n / 2) & 1;\\n        else\\n            return ((n / 2) & 1) ^ (start + n - 1);\\n    }\\n    int xorOperationA(int n, int start)\\n    {\\n        if (start & 1)\\n            return (start - 1) ^ xorOperationB(n + 1, start - 1);\\n        else\\n            return xorOperationB(n, start);\\n    }\\npublic:\\n    int xorOperation(int n, int start)\\n    {\\n        int ret = 2 * xorOperationA(n, start / 2);\\n        if (n & start & 1) ret++;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    int xorOperationB(int n, int start)\\n    {\\n        if (n % 2 == 0)\\n            return (n / 2) & 1;\\n        else\\n            return ((n / 2) & 1) ^ (start + n - 1);\\n    }\\n    int xorOperationA(int n, int start)\\n    {\\n        if (start & 1)\\n            return (start - 1) ^ xorOperationB(n + 1, start - 1);\\n        else\\n            return xorOperationB(n, start);\\n    }\\npublic:\\n    int xorOperation(int n, int start)\\n    {\\n        int ret = 2 * xorOperationA(n, start / 2);\\n        if (n & start & 1) ret++;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796508,
                "title": "o-1-time",
                "content": "Trust me, the code looks complicated, but the concept isn\\'t that complicated.\\n```\\nint XORforN(int val)\\n{\\n    switch(val & 3)\\n    {\\n        case 0:\\n            return val;\\n        case 1:\\n            return 1;\\n        case 2:\\n            return (val + 1);\\n        case 3:\\n            return 0;\\n    }\\n    // printf(\"\\\\n\\\\tshouldn\\'t reach here!\");\\n    return 0;\\n}\\n\\nint xorOperation(int n, int start){\\n    \\n        return (start & 1 & n) | ((XORforN((start >> 1) + n - 1) ^ XORforN((start >> 1) - 1)) << 1);\\n}\\n```\\nBasically, we have to first understand how to XOR \\'n\\' Whole numbers. To understand how to XOR \\'n\\' natural numbers in O(1) time, we need to look at the pattern, here is a table,\\n\\t\\t\\t\\t  ![image](https://assets.leetcode.com/users/images/5bdc1b3b-01f9-4afc-aae0-742be0218f9e_1597649670.3145618.png)\\nIf we look closely at the pattern of the XOR output, we see that the pattern seems to repeat every 4th iteration. If we try to correlate the answers based on the 2 lowest bits on the input, we can see that for every 00 bit, the output is equal to the provided input (0 gives 0, 4 gives 4, 8 gives 8, 12 gives 12 etc), the output is equal to 0 for bits 11 ( 3 gives 0, 7 gives 0, 11 gives 0, 15 gives 0 etc), the output is equal to 1 for 01 bits(1 gives 1, 5 gives 1, 9 gives 1, 13 gives 1 etc), and finally for 10 bits, the output is always 1 higher than the input value ( 2 gives 3, 6 gives 7, 10 gives 11, 14 gives 15 etc). \\nLooking at this pattern, we can create a simple switch case based function to calculate the XOR for \\'n\\' whole numbers. I have used the function name \"XORforN\" for this purpose.\\n\\nNow, if we look at the main equation provided in the question, \"start + 2*i\", we see that stepping ahead every 2 values is like stepping ahead 1 value at a time, if we divide the start value by 2( right shift once) and iterate with 1 step. Looking at the binary representation of the (start + 2i) and (start + 2i)/2 makes this clear.\\n![image](https://assets.leetcode.com/users/images/3154283b-0333-4782-8b52-bb6a02ebfd28_1597651123.2951663.png)\\n\\nWe can see that (start + 2i)/2 is still going ahead by 1, we need to find the XOR of values between start/2 and (start + 2(n-1))/2 (inclusive) and then multiply them by 2 (or left shift once) and then add the remaining 1 bit that\\'s left (this 1 bit was removed from the calculation when we divided start by 2). The lowest bit of the answer will 1, if the start value has a 1 bit at the lowest index AND if the \\'n\\' value is odd. (in other words, the XOR\\'s value is 1, if the number of 1\\'s are odd), hence to add that 1 bit in, I used a equation (start & 1 & n), 1 is the masking value, if start\\'s first bit is 1 and if n\\'s first bit is 1, then the answer will 1. We OR this value to the remaining solution. \\n\\nNow, we already understood, how to find the answer for XORing values from 0 to (n-1), now to understand how to find out XOR of values within the range of [a,b] (both inclusive), we simply XOR XORforN(b) with XORforN(a-1). So the answer for XORing values within the range [a,b] (both inclusive) whole numbers, is to first calculate (0 ^ 1 ^ 2 ^ .... ^b) and then XOR this value with (0 ^ 1 ^ 2 ^ .... ^(a-1)). (This comes from the concept that XORing a series of numbers removes the duplicates(in pairs) and preserves the unique value (that appears once))\\n\\nIn the context of the question asked, the start of the range \\'a\\' is (start / 2) or (start >> 1) , and the end of the range \\'b\\' is ((start / 2) + n - 1) or ((start >> 1) + n - 1).\\nYou may think that we are ignoring the lower most bit, but we make up for it, by first multiplying the above solution by 2 and then ORing the lower most bit using the (start & 1 & n) formulae explained above.\\n\\nI think, I have explained pretty well, if you have any questions, please post them in the comments, I would answer them in my leisure time.\\nThank you for reading upto this point.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nint XORforN(int val)\\n{\\n    switch(val & 3)\\n    {\\n        case 0:\\n            return val;\\n        case 1:\\n            return 1;\\n        case 2:\\n            return (val + 1);\\n        case 3:\\n            return 0;\\n    }\\n    // printf(\"\\\\n\\\\tshouldn\\'t reach here!\");\\n    return 0;\\n}\\n\\nint xorOperation(int n, int start){\\n    \\n        return (start & 1 & n) | ((XORforN((start >> 1) + n - 1) ^ XORforN((start >> 1) - 1)) << 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697698,
                "title": "java-c-python-array-time-o-n-space-o-1",
                "content": "**Explanation**\\nLoop once, we start from the initial value (start + 2 * 0 = start) and calculate XOR Operations step by step until we reach n-1.\\n\\n**Complexity**\\n\\nTime ```O(N)```\\nSpace ```O(1)```\\n\\n**Java:**\\n```\\npublic int xorOperation(int n, int start) {\\n        int res = start;\\n        for (int i=1; i<n; i++){\\n            res = res ^ (start + 2 * i);\\n            }\\n        return res;\\n    }\\n```\\n**C++**\\n```\\n\\tint xorOperation(int n, int start) {   \\n\\t\\tint res = start;\\n\\t\\tfor (int i=1; i<n; i++){\\n\\t\\t\\tres = res ^ (start + 2 * i);\\n\\t\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n```\\n**Python**\\n```\\n    def xorOperation(self, n, start):\\n        res = start\\n        for i in range(1, n):\\n            res = res ^ (start + 2 * i)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```O(N)```\n```O(1)```\n```\\npublic int xorOperation(int n, int start) {\\n        int res = start;\\n        for (int i=1; i<n; i++){\\n            res = res ^ (start + 2 * i);\\n            }\\n        return res;\\n    }\\n```\n```\\n\\tint xorOperation(int n, int start) {   \\n\\t\\tint res = start;\\n\\t\\tfor (int i=1; i<n; i++){\\n\\t\\t\\tres = res ^ (start + 2 * i);\\n\\t\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n```\n```\\n    def xorOperation(self, n, start):\\n        res = start\\n        for i in range(1, n):\\n            res = res ^ (start + 2 * i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 939190,
                "title": "o-1-time-c-easy-to-understand",
                "content": "The core principle used is that x ^ (x + 1) = 1 if x is even.\\n\\nFirst, we also simplify by changing the problem from being:\\nstart ^ (start + 2) ^ (start + 4) ^ ... (start + 2*i)\\nto:\\nstart/2 ^(start/2 + 1)^...^(start + i)\\n\\nWe can do this by remembering the first bit of start, and then right shifting it. At the end, we can left shift our answer and add back the first bit where necessary.\\n\\nWe can derive for the even scenario by considering that start^(start+1)^(start+2)^(start+3) cancels out to 0 when start is even after right shifting. We can use a Switch block to return the answer, which we can figure out by considering n in chunks of 4.\\n\\nThe solution in the odd scenario when start is odd after right shifting can again be derived by using a Switch block, taking into consideration that (start+1)^(start+2)^(start+3)^(start+4) cancels out to 0. (start+1 is even, hence subsequent series is the same as the even scenario). We simply XOR a start to compensate for not considering the first start in the odd scenario.\\n\\nSimilarly, the first bit only has an effect when n is an odd number, as an even number of 1s XOR\\'d will cancel out to 0.\\n\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int first = start & 1;\\n        start = start >> 1;\\n        if(start % 2 == 0){\\n            switch(n % 4){\\n                case 0: return 0;\\n                case 1: return ((start + n - 1) << 1) + first;\\n                case 2: return 2;\\n                case 3: return ((1 ^ (start + n - 1)) << 1) + first;\\n            } \\n        } else {\\n            switch(n % 4){\\n                case 0: return (start ^ 1 ^ (start + n - 1)) << 1;\\n                case 1: return (start << 1) + first;\\n                case 2: return (start ^ (start + n - 1)) << 1;\\n                case 3: return ((start ^ 1) << 1) + first;\\n            } \\n        }\\n        return 0; //unreachable\\n    }\\n};\\n```\\n\\nThe solution was expressed in this way to simplify explanation, it can be shortened.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int first = start & 1;\\n        start = start >> 1;\\n        if(start % 2 == 0){\\n            switch(n % 4){\\n                case 0: return 0;\\n                case 1: return ((start + n - 1) << 1) + first;\\n                case 2: return 2;\\n                case 3: return ((1 ^ (start + n - 1)) << 1) + first;\\n            } \\n        } else {\\n            switch(n % 4){\\n                case 0: return (start ^ 1 ^ (start + n - 1)) << 1;\\n                case 1: return (start << 1) + first;\\n                case 2: return (start ^ (start + n - 1)) << 1;\\n                case 3: return ((start ^ 1) << 1) + first;\\n            } \\n        }\\n        return 0; //unreachable\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698854,
                "title": "python-o-1-time-o-1-space",
                "content": "It is intuitive to use a list to store all numbers, and use one loop to calculate them.\\nTime O(n)  Space O(n)\\n\\n```python\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        nums = [start + 2 * i for i in range(n)]\\n        return functools.reduce(lambda x, y: x ^ y, nums, 0)\\n```\\n\\nHowever, if we deal with the problem by considering different situations, the time complexity can be reduce to O(1).\\n\\nif` start % 4 == 0 or 1`, the second bit from right must be 0, so `start ^ (start+2) == 2`\\uFF0C`(start + 2) ^ (start + 4) == 2` .....\\nif `n % 4 == 0`, there will be an even number of 2, and the xor of them is 0.\\nif `n % 4 == 1`, you can exclude the last numebr which is `start + 2 * (n - 1)`. The xor of left numbers is 0, so the result is last.\\nif `n % 4 == 2`, you can exclude the last two numbers. The xor of left numbers is 0, so the result is the xor of last two numbers which is 2.\\nif `n % 4 == 3`, you can exclude the last three numbers. The xor of left numbers is 0, so the result is the xor of last three numbers which is 2 ^ last.\\n\\nif `start % 4 == 2 or 3`, the second bit from right is 1, but the `(start + 2) % 4 == 0 or 1`. So we can exclude the first number. So the solution to calculate the left numbers is the same as the solution above.\\n\\n```python\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        if n == 1: return start\\n\\n        last = start + 2 * (n - 1)\\n        if start % 4 <= 1:\\n            if n % 4 == 0:\\n                return 0\\n            elif n % 4 == 1:\\n                return last\\n            elif n % 4 == 2:\\n                return 2\\n            else:\\n                return 2 ^ last\\n        else:\\n            if (n - 1) % 4 == 0:\\n                return start\\n            elif (n - 1) % 4 == 1:\\n                return start ^ last\\n            elif (n - 1) % 4 == 2:\\n                return start ^ 2\\n            else:\\n                return start ^ 2 ^ last\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        nums = [start + 2 * i for i in range(n)]\\n        return functools.reduce(lambda x, y: x ^ y, nums, 0)\\n```\n```python\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        if n == 1: return start\\n\\n        last = start + 2 * (n - 1)\\n        if start % 4 <= 1:\\n            if n % 4 == 0:\\n                return 0\\n            elif n % 4 == 1:\\n                return last\\n            elif n % 4 == 2:\\n                return 2\\n            else:\\n                return 2 ^ last\\n        else:\\n            if (n - 1) % 4 == 0:\\n                return start\\n            elif (n - 1) % 4 == 1:\\n                return start ^ last\\n            elif (n - 1) % 4 == 2:\\n                return start ^ 2\\n            else:\\n                return start ^ 2 ^ last\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698327,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        ## RC ##\\n        ## APPROACH : MATH ##\\n        res = 0\\n        for i in range(n):\\n            res ^= start + 2 * i\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        ## RC ##\\n        ## APPROACH : MATH ##\\n        res = 0\\n        for i in range(n):\\n            res ^= start + 2 * i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862065,
                "title": "c-0ms-easy-solution",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint xorOperation(int n, int start) {\\n\\t\\t\\tint ans =0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tans ^= start + 2*i;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\nif you understand the solution, then do Upvote \\n\\'\\'\\'\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint xorOperation(int n, int start) {\\n\\t\\t\\tint ans =0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tans ^= start + 2*i;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 698704,
                "title": "javascript-100-100",
                "content": "````\\nvar xorOperation = function(n, start) {\\n    let xor = 0\\n    for (let i=0; i<n ; i++){\\n        xor ^= start + 2 * i\\n    }\\n    return xor\\n};\\n````",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\nvar xorOperation = function(n, start) {\\n    let xor = 0\\n    for (let i=0; i<n ; i++){\\n        xor ^= start + 2 * i\\n    }\\n    return xor\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751949,
                "title": "o-1-o-1-constant-memory-constant-space-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int startWithoutFirstBit = start >> 1; // remove first bit\\n        \\n        int from = startWithoutFirstBit;\\n        int to = startWithoutFirstBit + n - 1;\\n        \\n        int result = xorOfRange(from, to);\\n\\t\\t\\n\\t\\t// return first bit\\n        result = result << 1;\\n        if ((start % 2 == 1) && (n % 2 == 1)) result = result | 1;\\n        \\n        return result;\\n    }\\n    \\n    int xorOfRange(int from, int to) {\\n        return xorFromZeroTo(to) ^ xorFromZeroTo(from - 1);\\n    }\\n    \\n    int xorOfRangeFromZeroToN(int n) {\\n        int mod = n % 4;\\n        if (mod == 0) return n;\\n        if (mod == 1) return 1;\\n        if (mod == 2) return n + 1;\\n        if (mod == 3) return 0;\\n        return 0;\\n    }\\n}\\n```\\n \\n`xorOfRangeFromZeroToN` method is based on the following observation: for any range `0..N` XOR of all elements of this range will be equal to:\\n1. `N` if `N mod 4 == 0`\\n2. `1` if `N mod 4 == 1`\\n3. `N + 1` if `N mod 4 == 2`\\n4. `0` if `N mod 4 == 3`\\n\\nBased on this method we can build method `xorOfRange` which calculates XOR of all elements of range `A..B`:\\n1. XOR is a comutative operation: `X ^ Y = Y ^ X`\\n2. `X ^ X = 0`\\n2. `F(A) = xorOfRangeFromZeroToN(A) = 0 ^ 1 ^ 2 ... ^ A`\\n3. `F(B) =  0 ^ 1 ^ 2 ... ^ A ^ A+1 ^ ... ^ B`\\n4. `xorOfRange(A, B) = F(A - 1) ^ F(B) = (0 ^ 0) ^ (1 ^ 1) ^ (2 ^ 2) ^ ... (A-1 ^ A-1) ^ A ^ A+1 ^ ... ^ B = A ^ A+1 ^ ... ^ B`\\n\\nNow comming back to our problem. We need to calculate XOR of all elements in `start, start + 2, start + 4, ... start + 2n`. If we remove least significan bit from every number of this range, we will have a new range `start/2, start/2 + 1, start/2 + 2, ... start + n`. Example, lets say we have a range with start = 5 and n = 4, so we need to calculate `5 ^ 7 ^ 9 ^ 11`:\\n* 5 = **1**01\\n* 7 = **1**11\\n* 9 = **1**001\\n* 11 = **1**101\\n\\nAs you can see first bit never changes. If we remove least significat bit remaining part of number increments by 1 on each step:\\n* 2 = 01\\n* 3 = 11\\n* 4 = 001\\n* 5 = 101\\n\\nWe can calulate range like this, using method `xorOfRange(2, 5)`.\\n\\nThe last thing we need to do is to return bit that we removed. This bit will be 0, if `start` had least significant bit equal to 0. Otherwise if it was 1, value of this bit will be `1 ^ 1 ^ 1 ^ ... ^ 1` and if length of range(`n`) is odd it will be 1 and 0 otherwise.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int startWithoutFirstBit = start >> 1; // remove first bit\\n        \\n        int from = startWithoutFirstBit;\\n        int to = startWithoutFirstBit + n - 1;\\n        \\n        int result = xorOfRange(from, to);\\n\\t\\t\\n\\t\\t// return first bit\\n        result = result << 1;\\n        if ((start % 2 == 1) && (n % 2 == 1)) result = result | 1;\\n        \\n        return result;\\n    }\\n    \\n    int xorOfRange(int from, int to) {\\n        return xorFromZeroTo(to) ^ xorFromZeroTo(from - 1);\\n    }\\n    \\n    int xorOfRangeFromZeroToN(int n) {\\n        int mod = n % 4;\\n        if (mod == 0) return n;\\n        if (mod == 1) return 1;\\n        if (mod == 2) return n + 1;\\n        if (mod == 3) return 0;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124283,
                "title": "c-4-lines-code-beginner-friendly",
                "content": "Plz Upvote -\\n\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n            ans=ans^(start+2*i);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n            ans=ans^(start+2*i);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 897642,
                "title": "java-cool-one-line-solution-using-java-8-stream-api",
                "content": "If u liked my solution, please vote it up) thx)\\n```\\nclass Solution {\\n   public int xorOperation(int n, int start) {\\n\\t\\treturn Stream.iterate(0, integer -> integer+1)\\n\\t\\t\\t\\t.map(integer ->start+2*integer)\\n\\t\\t\\t\\t.limit(n)\\n\\t\\t\\t\\t.reduce((a,b)->a^b).orElse(0);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public int xorOperation(int n, int start) {\\n\\t\\treturn Stream.iterate(0, integer -> integer+1)\\n\\t\\t\\t\\t.map(integer ->start+2*integer)\\n\\t\\t\\t\\t.limit(n)\\n\\t\\t\\t\\t.reduce((a,b)->a^b).orElse(0);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703026,
                "title": "one-liner-o-1-time-with-no-recursion-and-detailed-explanation",
                "content": "Just for clarity, I marked three intermediate variables as end, a and b, \\nbut if you want, you can plug in these three numbers, and you\\'ll get bona fide one-liner solution.\\n\\n\\tclass Solution:\\n\\t\\t# O(1) solution, without recursion\\n\\t\\tdef xorOperation(self, n: int, start: int) -> int:\\n\\t\\t\\tend = start + n * 2\\n\\t\\t\\ta, b = start // 2, end // 2\\n\\t\\t\\treturn (start % 2) * (n % 2) + \\\\\\n\\t\\t\\t\\t\\t((((a - 1) * (a % 2)) ^ ((a // 2) % 2)) ^ ((b - 1) * (b % 2)) ^ ((b // 2) % 2)) * 2\\n\\t\\nExplanation:\\nWe can divide the results into two parts:\\n1) XOR for the last digits\\n2) XOR for all previous digits\\n\\n**Why do we do that?**\\nBecause as we are dealing with a sequence with a difference of 2.\\nThe last bit is 1 after all XOR operations iff start is odd and n is odd.\\nOtherwise, the last digit will be 0\\nSo, we write the XOR of all last digits as\\n\\n\\t(start % 2) * (n % 2)\\n\\nNow we focus on all other previous bits in the binary presentation.\\nNote that when we divide all numbers by 2,\\nwe are effectively calculating\\n\\n( 0^1^2^...^(a-1) ) ^ (0^1^2^...^b) if we want to get a^(a+1)^...^b\\nHere, a and b are the start and end position of the array divided by 2\\nSo, we have \\n\\t\\n\\ta, b = start // 2, end // 2\\nNote that we have already dealt with the last bit earlier, so we can directly use // here.\\n\\nOK. **Now how do we calculate (0^1^2^...^a) in O(1) time**?\\nIf we write all numbers in its binary form, we will notice that \\n\\n\\t0^1 = 000^001 = 1\\n\\t2^3 = 010^011 = 1 \\n\\t4^5 = 100^101 = 1\\nWe are almost there!\\n\\nSo, (0^1^2^...^a) would be 1 or 0 for the first a//2 pairs of numbers: (a//2)%2 will be 1, otherwise 0.\\nWe may have one term left over at the end, so the result becomes\\nThe last part (a-1) * (a%2) is for the remaining term\\n\\n\\t(a//2)%2 ^ (a-1)*(a%2)\\n\\t\\nGreat, so similarly, we can calculate (0^1^2...^b) as \\n\\t\\n\\t(b//2)%2 ^ (b-1)*(b%2)\\n\\nNow we combine the two parts together:\\n\\tPart1 + Part2*2 \\n\\twill be our final result\\n\\n(start % 2) * (n % 2) + ((((a - 1) * (a % 2)) ^ ((a // 2) % 2)) ^ ((b - 1) * (b % 2)) ^ ((b // 2) % 2)) * 2\\n\\nHope you like this one liner O(1) iterative solution! Please vote up if you like!\\nThis is just for fun. I wouldn\\'t suggest writing a solution like this in a contest though.",
                "solutionTags": [],
                "code": "Just for clarity, I marked three intermediate variables as end, a and b, \\nbut if you want, you can plug in these three numbers, and you\\'ll get bona fide one-liner solution.\\n\\n\\tclass Solution:\\n\\t\\t# O(1) solution, without recursion\\n\\t\\tdef xorOperation(self, n: int, start: int) -> int:\\n\\t\\t\\tend = start + n * 2\\n\\t\\t\\ta, b = start // 2, end // 2\\n\\t\\t\\treturn (start % 2) * (n % 2) + \\\\\\n\\t\\t\\t\\t\\t((((a - 1) * (a % 2)) ^ ((a // 2) % 2)) ^ ((b - 1) * (b % 2)) ^ ((b // 2) % 2)) * 2\\n\\t\\nExplanation:\\nWe can divide the results into two parts:\\n1) XOR for the last digits\\n2) XOR for all previous digits\\n\\n**Why do we do that?**\\nBecause as we are dealing with a sequence with a difference of 2.\\nThe last bit is 1 after all XOR operations iff start is odd and n is odd.\\nOtherwise, the last digit will be 0\\nSo, we write the XOR of all last digits as\\n\\n\\t(start % 2) * (n % 2)\\n\\nNow we focus on all other previous bits in the binary presentation.\\nNote that when we divide all numbers by 2,\\nwe are effectively calculating\\n\\n( 0^1^2^...^(a-1) ) ^ (0^1^2^...^b) if we want to get a^(a+1)^...^b\\nHere, a and b are the start and end position of the array divided by 2\\nSo, we have \\n\\t\\n\\ta, b = start // 2, end // 2\\nNote that we have already dealt with the last bit earlier, so we can directly use // here.\\n\\nOK. **Now how do we calculate (0^1^2^...^a) in O(1) time**?\\nIf we write all numbers in its binary form, we will notice that \\n\\n\\t0^1 = 000^001 = 1\\n\\t2^3 = 010^011 = 1 \\n\\t4^5 = 100^101 = 1\\nWe are almost there!\\n\\nSo, (0^1^2^...^a) would be 1 or 0 for the first a//2 pairs of numbers: (a//2)%2 will be 1, otherwise 0.\\nWe may have one term left over at the end, so the result becomes\\nThe last part (a-1) * (a%2) is for the remaining term\\n\\n\\t(a//2)%2 ^ (a-1)*(a%2)\\n\\t\\nGreat, so similarly, we can calculate (0^1^2...^b) as \\n\\t\\n\\t(b//2)%2 ^ (b-1)*(b%2)\\n\\nNow we combine the two parts together:\\n\\tPart1 + Part2*2 \\n\\twill be our final result\\n\\n(start % 2) * (n % 2) + ((((a - 1) * (a % 2)) ^ ((a // 2) % 2)) ^ ((b - 1) * (b % 2)) ^ ((b // 2) % 2)) * 2\\n\\nHope you like this one liner O(1) iterative solution! Please vote up if you like!\\nThis is just for fun. I wouldn\\'t suggest writing a solution like this in a contest though.",
                "codeTag": "Java"
            },
            {
                "id": 3419065,
                "title": "easy-c-code-beats-100-time",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndirectly use the given formula as it is, and simultaneously XOR the result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n            k=k^(start+2*i);\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n            k=k^(start+2*i);\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942598,
                "title": "simple-python-solutions",
                "content": "####  **Solution 1: Using Loop**\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        ans=0\\n        for i in range(n):\\n            ans^=start+(2*i)\\n        return ans\\n```\\n\\n#### **Solution 2: Using reduce**\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        return reduce(operator.xor,[start+(2*i) for i in range(n)])\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        ans=0\\n        for i in range(n):\\n            ans^=start+(2*i)\\n        return ans\\n```\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        return reduce(operator.xor,[start+(2*i) for i in range(n)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697822,
                "title": "clean-python-3-one-liner-and-o-1-solution",
                "content": "Time: `O(N)`\\nSpace: `O(1)`\\nThanks [_xavier_](https://leetcode.com/_xavier_/) for his suggestions.\\n```\\nimport functools\\nimport operator\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        return functools.reduce(operator.xor, range(start, start + 2 * n, 2))\\n```\\n\\nUpdate: O(1) time [solution](https://leetcode.com/problems/xor-operation-in-an-array/discuss/698854/PYTHON-O(1)-Time-O(1)-Space) by [lonely7yk](https://leetcode.com/lonely7yk/)\\nTime: `O(1)`\\nSpace: `O(1)`\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        last = start + 2 * (n - 1)\\n        if start % 4 < 2:\\n            start = 0\\n        else:\\n            n -= 1\\n        if n % 2 == 0: return start ^ (n & 2)\\n        return start ^ last ^ (n & 2)\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nimport operator\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        return functools.reduce(operator.xor, range(start, start + 2 * n, 2))\\n```\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        last = start + 2 * (n - 1)\\n        if start % 4 < 2:\\n            start = 0\\n        else:\\n            n -= 1\\n        if n % 2 == 0: return start ^ (n & 2)\\n        return start ^ last ^ (n & 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765051,
                "title": "javascript-1-line",
                "content": "```\\nvar xorOperation = function(n, start) {\\n  return Array(n)\\n    .fill()\\n    .map((x, i) => start + 2 * i)\\n    .reduce((c, x) => c ^ x);\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar xorOperation = function(n, start) {\\n  return Array(n)\\n    .fill()\\n    .map((x, i) => start + 2 * i)\\n    .reduce((c, x) => c ^ x);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 697815,
                "title": "easy-c-o-1-space-o-n-time",
                "content": "```\\nint xorOperation(int n, int start) {\\n        int res = start;\\n        for(int i =1; i < n; i++)\\n        {\\n            res ^= (start + 2*i);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\nint xorOperation(int n, int start) {\\n        int res = start;\\n        for(int i =1; i < n; i++)\\n        {\\n            res ^= (start + 2*i);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3505320,
                "title": "my-xoroperation",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} start\\n * @return {number}\\n */\\nvar xorOperation = function (n, start) {\\n\\tlet result = start;\\n\\n\\tfor (let i = 1; i < n; i++) {\\n\\t\\tresult ^= start + 2 * i;\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} start\\n * @return {number}\\n */\\nvar xorOperation = function (n, start) {\\n\\tlet result = start;\\n\\n\\tfor (let i = 1; i < n; i++) {\\n\\t\\tresult ^= start + 2 * i;\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 700800,
                "title": "a-few-solutions",
                "content": "Each value of the array of size `n` is monotonically increasing by `2`.  Thus, we can write naive solutions which calculate the xor, starting at `x`.\\n\\n---\\n\\n**Recursive Solutions:**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun xorOperation(n: Int, x: Int): Int { return if (0 < n) x xor xorOperation(n - 1, x + 2) else 0 }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet xorOperation = (n, x) => n ? x ^ xorOperation(n - 1, x + 2) : 0;\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    xorOperation = lambda self, n, x: x ^ self.xorOperation(n - 1, x + 2) if n else 0\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int x) { return n ? x ^ xorOperation(n - 1, x + 2) : 0; }\\n};\\n```\\n\\n---\\n\\n**Iterative Solutions:**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var xorOperation = { n: Int, x: Int -> (0 until n).map{ x + 2 * it }.reduce{ t: Int, x: Int -> t xor x } }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet xorOperation = (n, x) => [...Array(n)].map((_, i) => x + 2 * i).reduce((a, b) => a ^ b , 0);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, x: int) -> int:\\n        return reduce(lambda a, b: a ^ b, (map(lambda i: x + 2 * i, [i for i in range(n)])), 0)\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn xor_operation(n: i32, x: i32) -> i32 {\\n        let mut ans = 0;\\n        for i in 0..n {\\n            ans ^= x + 2 * i;\\n        }\\n        ans\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int x, int ans = 0) {\\n       for (auto i{ 0 }; i < n; ++i)\\n           ans ^= x + 2 * i;\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun xorOperation(n: Int, x: Int): Int { return if (0 < n) x xor xorOperation(n - 1, x + 2) else 0 }\\n}\\n```\n```\\nlet xorOperation = (n, x) => n ? x ^ xorOperation(n - 1, x + 2) : 0;\\n```\n```\\nclass Solution:\\n    xorOperation = lambda self, n, x: x ^ self.xorOperation(n - 1, x + 2) if n else 0\\n```\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int x) { return n ? x ^ xorOperation(n - 1, x + 2) : 0; }\\n};\\n```\n```\\nclass Solution {\\n    var xorOperation = { n: Int, x: Int -> (0 until n).map{ x + 2 * it }.reduce{ t: Int, x: Int -> t xor x } }\\n}\\n```\n```\\nlet xorOperation = (n, x) => [...Array(n)].map((_, i) => x + 2 * i).reduce((a, b) => a ^ b , 0);\\n```\n```\\nclass Solution:\\n    def xorOperation(self, n: int, x: int) -> int:\\n        return reduce(lambda a, b: a ^ b, (map(lambda i: x + 2 * i, [i for i in range(n)])), 0)\\n```\n```\\nimpl Solution {\\n    pub fn xor_operation(n: i32, x: i32) -> i32 {\\n        let mut ans = 0;\\n        for i in 0..n {\\n            ans ^= x + 2 * i;\\n        }\\n        ans\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int x, int ans = 0) {\\n       for (auto i{ 0 }; i < n; ++i)\\n           ans ^= x + 2 * i;\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074114,
                "title": "java-0ms-faster-than-100-00-solution",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            int num = start + 2 * i;\\n            result ^= num;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            int num = start + 2 * i;\\n            result ^= num;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023866,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int i=0;\\n        int xor_result=0;\\n        while(i<n){\\n            xor_result^=start+2*i;\\n            i++;\\n        }\\n        return xor_result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int i=0;\\n        int xor_result=0;\\n        while(i<n){\\n            xor_result^=start+2*i;\\n            i++;\\n        }\\n        return xor_result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334322,
                "title": "c-100-faster-easy-peasy",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n       vector<int> nums; int xorr=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            xorr=xorr ^ (start+(2*i));\\n        }\\n        \\n        return xorr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n       vector<int> nums; int xorr=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            xorr=xorr ^ (start+(2*i));\\n        }\\n        \\n        return xorr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119403,
                "title": "o-1-java-o-1-space",
                "content": "\\nLogic:\\nXor of every 4 consec even and 4 odd numbers are repeated with a pattern(irrespective of start).(even for 1..n every 4 consec number repeat a pattern)\\nAlso, a^b^a^b = 0\\n\\nSo 6^8^10^12 can be re written as 2^4^6^8^10^12 ^2 ^4(2^4^2^4 will result in 0)\\n\\nFor even numbers starting from 2\\n0^2->2 (2)\\n2^4->6 (n+2)\\n6^6->0 (0)\\n0^8->8 (n)\\n8^10->2 (2)\\n10^12->14 (n+2)\\n14^14->0 (0)\\n0^16->16 (n)\\n\\nSimilarly for odd:\\n1 -> 1 (n)\\n1^3->2(n-1)\\n3^5 -> 7 (n+2)\\n7^7 -> 0 (0)\\n\\nNow that we have the pattern for numbers starting from 2(for even) and 1(odd),\\nwe can always use this to get the result based on the end number.\\n\\nEx, n-4, start->6\\nend number = 12 . Using our pattern, for even numbers we would have the result as 14(n+2).\\nSince the start is from 6, and our pattern starts from 2, we  can xor this result with 2^4.\\nSo the final result will be 14^6 = 8\\n\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int result= 0;\\n        if(n==0 || n==1)\\n            return start;\\n        int end = start + 2*(n-1);\\n        int prevEnd = (start-2)<=0?0:(start-2);\\n        if(start%2==0){\\n            result = getEvenXor(end) ^ getEvenXor(prevEnd);\\n        \\n        }else{\\n            result = getOddXor(end) ^ getOddXor(prevEnd);\\n        }\\n        return result;\\n    }\\n    public int getEvenXor(int n){\\n        if(n==0)\\n            return 0;\\n        if(n%4==0){\\n            if((n/4)%2==0)\\n            {\\n                return n;\\n            }\\n            else{\\n                return n+2;\\n            }\\n        }\\n        else{\\n            if(((n-2)/4)%2 ==0)\\n            {\\n                return 2;\\n            }    \\n            else\\n            {\\n                return 0;\\n            }\\n                \\n        }\\n    }\\n    public int getOddXor(int n){\\n        if(n==0)\\n            return 0;\\n        if(n%4==1){\\n            if(((n-1)/4 %2)==0){\\n                return n;\\n            }\\n            else{\\n                return n+2;\\n            } \\n        }\\n        else{\\n            if(((n+1)/4)%2==0)\\n            {\\n                return 0;\\n            }\\n            else{\\n                return 2;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int result= 0;\\n        if(n==0 || n==1)\\n            return start;\\n        int end = start + 2*(n-1);\\n        int prevEnd = (start-2)<=0?0:(start-2);\\n        if(start%2==0){\\n            result = getEvenXor(end) ^ getEvenXor(prevEnd);\\n        \\n        }else{\\n            result = getOddXor(end) ^ getOddXor(prevEnd);\\n        }\\n        return result;\\n    }\\n    public int getEvenXor(int n){\\n        if(n==0)\\n            return 0;\\n        if(n%4==0){\\n            if((n/4)%2==0)\\n            {\\n                return n;\\n            }\\n            else{\\n                return n+2;\\n            }\\n        }\\n        else{\\n            if(((n-2)/4)%2 ==0)\\n            {\\n                return 2;\\n            }    \\n            else\\n            {\\n                return 0;\\n            }\\n                \\n        }\\n    }\\n    public int getOddXor(int n){\\n        if(n==0)\\n            return 0;\\n        if(n%4==1){\\n            if(((n-1)/4 %2)==0){\\n                return n;\\n            }\\n            else{\\n                return n+2;\\n            } \\n        }\\n        else{\\n            if(((n+1)/4)%2==0)\\n            {\\n                return 0;\\n            }\\n            else{\\n                return 2;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698902,
                "title": "c-o-1-no-recursion-using-range-xor-formula",
                "content": "```\\nclass Solution {\\npublic:\\n    //Geeks For Geeks - Calculate XOR from 1 to n\\n    int cx(int n) //function to compute xor from 1 to n\\n    { \\n        switch(n & 3)\\n        { \\n            case 0: return n;    \\n            case 1: return 1;    \\n            case 2: return n + 1;\\n            case 3: return 0;    \\n        } \\n        return 0; //dummy return to avoid warnings\\n    } \\n    \\n    int xorOperation(int n, int start) {\\n        int lbit= start&n&1 ?1:0;   //LSB(Unit digit bit)\\n        int nn=start/2;             //To convert question to gap of 1 instead of 2\\n        int onelr= cx(nn+n-1)^cx(nn-1);\\n        // l^(l+1)^...^r is equivalent to\\n        // (1^2^...^r)^(1^2^...^(l-1))\\n        \\n        int ans=(onelr<<1)+lbit;    //Appending LSB to answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Geeks For Geeks - Calculate XOR from 1 to n\\n    int cx(int n) //function to compute xor from 1 to n\\n    { \\n        switch(n & 3)\\n        { \\n            case 0: return n;    \\n            case 1: return 1;    \\n            case 2: return n + 1;\\n            case 3: return 0;    \\n        } \\n        return 0; //dummy return to avoid warnings\\n    } \\n    \\n    int xorOperation(int n, int start) {\\n        int lbit= start&n&1 ?1:0;   //LSB(Unit digit bit)\\n        int nn=start/2;             //To convert question to gap of 1 instead of 2\\n        int onelr= cx(nn+n-1)^cx(nn-1);\\n        // l^(l+1)^...^r is equivalent to\\n        // (1^2^...^r)^(1^2^...^(l-1))\\n        \\n        int ans=(onelr<<1)+lbit;    //Appending LSB to answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765679,
                "title": "python-faster-than-90-python-solution-beginner-friendly-explained",
                "content": "\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        arr = [None] * n #create a list with n elements\\n        target = 0\\n        for i in range(0,n):\\n            arr[i] = start + 2*i  #replace the value at i postion to the value of start + 2*i\\n        for i in arr:  # target is set 0 because 0 ^ n = n , so 0 ^ i will give us i at first. \\n            target ^= i  # xor the value in arr one by one \\n        return target\\n            \\n```\\n**Upvote if you like the solution.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        arr = [None] * n #create a list with n elements\\n        target = 0\\n        for i in range(0,n):\\n            arr[i] = start + 2*i  #replace the value at i postion to the value of start + 2*i\\n        for i in arr:  # target is set 0 because 0 ^ n = n , so 0 ^ i will give us i at first. \\n            target ^= i  # xor the value in arr one by one \\n        return target\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 850122,
                "title": "python-99-87-one-line",
                "content": "```python\\nfrom functools import reduce\\nfrom operator import xor\\n\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        return reduce(xor, range(start, start + n * 2 - 1, 2))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nfrom functools import reduce\\nfrom operator import xor\\n\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        return reduce(xor, range(start, start + n * 2 - 1, 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534773,
                "title": "this-is-easy-way-to-solve-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int [] nums = new int[n];\\n        for(int i = 0; i<n; i++){\\n            nums[i] = start + 2*i; \\n        }\\n\\n        int sum = nums[0];\\n\\n         for(int i = 1; i<n; i++){\\n            sum ^= nums[i];\\n        }\\n     \\n     return sum;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int [] nums = new int[n];\\n        for(int i = 0; i<n; i++){\\n            nums[i] = start + 2*i; \\n        }\\n\\n        int sum = nums[0];\\n\\n         for(int i = 1; i<n; i++){\\n            sum ^= nums[i];\\n        }\\n     \\n     return sum;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250809,
                "title": "python3-beats-94-67",
                "content": "![image.png](https://assets.leetcode.com/users/images/84b4c13f-dcee-4283-9527-009b2954a5d0_1677827043.7104824.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        s1=[]\\n        r = 0\\n        for i in range(n):\\n            s=start+(i*2)\\n            s1.append(s)\\n        for i in range(len(s1)):\\n            r = r ^ s1[i]\\n        return r\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        s1=[]\\n        r = 0\\n        for i in range(n):\\n            s=start+(i*2)\\n            s1.append(s)\\n        for i in range(len(s1)):\\n            r = r ^ s1[i]\\n        return r\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247115,
                "title": "100-runtime-beats-c-solution",
                "content": "# Intuition\\nLooping and XORing through the array.\\n\\n# Approach\\nJust we\\'ve defined a vector array called *ans* and pushed the values according to the equation that was given *nums[i] = start + 2 * i* in my case I named it as *ans* so the equation for me becomes *ans[i] = start + 2 * i*. Then I created another integer variable and named it as *\"ope\"* and stored the first value of the created array in it, so that we could start EXORing with the other values in the array. Then we ran a *for loop* from the *1st index to the size of the array* and just went on XORing all the elements, and meanwhile kept on storing it in *ope* variable. And finally returned *ope*.\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        vector<int>arr = {};\\n        for(int i = 0; i < n; i++) {\\n            arr.push_back(start + 2 * i);\\n        }\\n        int ope = arr[0];\\n        for(int i = 1; i < arr.size(); i++) {\\n            ope = ope ^ arr[i];\\n        }\\n        return ope;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        vector<int>arr = {};\\n        for(int i = 0; i < n; i++) {\\n            arr.push_back(start + 2 * i);\\n        }\\n        int ope = arr[0];\\n        for(int i = 1; i < arr.size(); i++) {\\n            ope = ope ^ arr[i];\\n        }\\n        return ope;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226372,
                "title": "o-1-time-space-without-ifs-cases-intuitive-proof-and-explanation",
                "content": "# Intuition\\nThe key observation is to notice that x^(x+2) == 2 when the second bit of x is set to 0, which makes the XOR-sum zero every four terms.\\n\\n\\n# Approach\\nExplanation:\\nIf x has the second bit set to 0 then it follows that x ^ (x + 2) == 2:\\n  From that we can conclude that the XOR sum becomes 0 for every 4 terms:\\n  x ^ (x + 2) ^ (x + 4) ^ (x + 6) == x ^ (x + 2) ^ (x + 4) ^ ( (x + 4) + 2) == 2 ^ 2 == 0\\n\\nSo in that case, we only care to XOR-add the n % 4 last terms\\n\\nIf x has the second bit set to 1, then we need to compute the following XOR-sum:\\nx ^ (x + 2) ^ (x + 4) ^ ... ^ (x + 2* (n-1))\\n\\nsince x has the second bit set to 1, x + 2 has the second bit set to 0. If we let y == x + 2,\\nwe can rewrite this XOR-sum as follows:\\nx ^ [ y ^ (y + 2) ^ ... ^ (y + 2* (n-2)) ]\\n\\nThe XOR-sum in the brackets is a XOR-sum where the first term (y) has the second bit set to 0,\\nwhich we have computed in the first case. So we compute that just like we do in the first case\\nand we XOR it with x.\\n\\nWritting cases/switches/ifs depending on the modulo result like the other solutions here doesn\\'t really matter since it\\'s only up to four terms we need to XOR-sum (so still O(1) if we ignore cases) and makes the solution easier to reason about and remember.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n\\nPython3:\\n\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        has2ndBitSet = bool(start & 2)\\n        end = start + 2*(n-1)\\n        k = (n - 1*has2ndBitSet) % 4\\n\\n        # This reduce is O(1) time and space because k < 4 \\n        return (start*has2ndBitSet) ^ reduce(operator.xor, [end - 2*i for i in range(k)], 0)\\n\\n```\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        bool has2ndBitSet = start & 2;\\n        int end = start + 2*(n-1);\\n        int k = (n - 1 * has2ndBitSet) % 4;\\n        int res = start*has2ndBitSet;\\n\\n        // This loop is O(1) time and space because k < 4\\n        for (int i = 0; i < k; i ++) {\\n            res ^= end - 2*i;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        has2ndBitSet = bool(start & 2)\\n        end = start + 2*(n-1)\\n        k = (n - 1*has2ndBitSet) % 4\\n\\n        # This reduce is O(1) time and space because k < 4 \\n        return (start*has2ndBitSet) ^ reduce(operator.xor, [end - 2*i for i in range(k)], 0)\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        bool has2ndBitSet = start & 2;\\n        int end = start + 2*(n-1);\\n        int k = (n - 1 * has2ndBitSet) % 4;\\n        int res = start*has2ndBitSet;\\n\\n        // This loop is O(1) time and space because k < 4\\n        for (int i = 0; i < k; i ++) {\\n            res ^= end - 2*i;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081505,
                "title": "java-easy-solution-beats-100-runtime-0ms",
                "content": "\\n\\n# Approach\\nUsing Bit Manipulation- \\nTo solve the question, we iterate all nos. from 0 to n-1 one by one using a for loop and calculate each value(of the hypoyhetical array without actually creating an array) using the formula given- (start + 2*i). Simultaneously, we calculate its XOR operation with the previous value(or 0 in case of the first number at index 0) and store it in the result variable. At last, we return the result.\\n\\nConcept behind performing XOR operation with 0 at first(i.e. keeping initial value of result=0):-\\n\\nPerforming XOR operation of any number gives back the same number.\\ne.g. 2^0 = 2\\nsince, 2= 0010 , 0=0000\\n(0010) ^ (0000) = 0010\\n\\nthis happens because, \\nXOR of 1 with 0 => 0^1 =1 ,and \\nXOR of 0 with 0 => 0^0 =0 \\n\\nHope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int val=0; \\n        int result=0; //since performing XOR operation of any number with 0 gives back the same number\\n        for(int i=0; i<n; i++){  //loop for iterating numbers from 0 to n-1 \\n            val= start+ 2*i; // calculating each value of the array(i.e. hypothetical array) without actually storing it in an array\\n            result^=val; // performing XOR operation one by for for each element of the array and storing it in result variable\\n\\n        }\\n        return result;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int val=0; \\n        int result=0; //since performing XOR operation of any number with 0 gives back the same number\\n        for(int i=0; i<n; i++){  //loop for iterating numbers from 0 to n-1 \\n            val= start+ 2*i; // calculating each value of the array(i.e. hypothetical array) without actually storing it in an array\\n            result^=val; // performing XOR operation one by for for each element of the array and storing it in result variable\\n\\n        }\\n        return result;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790634,
                "title": "python-simple-solution-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        xor = 0\\n        for i in range(n):\\n            xor = xor ^ start\\n            start+=2\\n        return xor\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        xor = 0\\n        for i in range(n):\\n            xor = xor ^ start\\n            start+=2\\n        return xor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696772,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        if(n==0){\\n            return 0;\\n        }\\n        int count = 0;\\n        for(int i = 0 ;i < n; i++){\\n            count ^= start + i*2;;\\n        }\\n        return count;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        if(n==0){\\n            return 0;\\n        }\\n        int count = 0;\\n        for(int i = 0 ;i < n; i++){\\n            count ^= start + i*2;;\\n        }\\n        return count;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425887,
                "title": "java-easiest-solution-0ms-runtime-faster-than-100-online-submission-4-liner",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans = ans ^ start+2*i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans = ans ^ start+2*i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837333,
                "title": "o-1-complexity-0ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans=0,nums[n];\\n        for(int i=0;i<n;++i)\\n        {\\n            nums[i]=start+(2*i);\\n            ans^=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans=0,nums[n];\\n        for(int i=0;i<n;++i)\\n        {\\n            nums[i]=start+(2*i);\\n            ans^=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228123,
                "title": "python3-time-o-n-space-o-1-reduce-function-explanation",
                "content": "## **How *xor* works**\\n**Exclusive or** -  *is a logical operation that is true if and only if its arguments differ (one is true, the other is false). **[Wiki Link](https://en.wikipedia.org/wiki/Exclusiveor)***\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c5ac-0679-4f70-9136-d5e3b93a08c7_1621876640.3559592.png)\\n\\n\\n\\n##### Simple case:\\n\\n*10 xor 12 = 1010 xor 1100 = 0110 = 6*\\n\\n\\n## **How *reduce* works**\\n```\\nfunctools.reduce(function, iterable)\\n```\\n* function: the first argument that defines the function to apply, also known as the predicate of reduce function\\n* the second argument with the values to be passed to function\\n\\n#### Example:\\nIn this example, we are summing all the elements of the list:\\n```\\narr = [1, 3, 4]\\nresult = reduce(lambda a,b : a+b, arr)\\narr // == 8\\n```\\n\\nYou can find more examples *[at this link](https://levelup.gitconnected.com/understanding-the-python-reduce-function-with-examples-ddfac8b078d4)*\\n\\n## **What is `__xor__`?**\\n```\\na ^ b\\n```\\nthis is an analogue of\\n```\\na.__xor__(b)\\n```\\nThis is called the *magic method*. You can read more about them on the *[medium at this link.](https://medium.com/fintechexplained/advanced-python-what-are-magic-methods-d21891cf9a08)*\\n\\n# **Solution:**\\n```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        return reduce(int.__xor__, range(start, start+n*2, 2))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfunctools.reduce(function, iterable)\\n```\n```\\narr = [1, 3, 4]\\nresult = reduce(lambda a,b : a+b, arr)\\narr // == 8\\n```\n```\\na ^ b\\n```\n```\\na.__xor__(b)\\n```\n```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        return reduce(int.__xor__, range(start, start+n*2, 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163962,
                "title": "python3-simple-44ms-solution",
                "content": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        ans = start\\n        for i in range(1 , n):\\n            ans ^= start + (2 * i)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        ans = start\\n        for i in range(1 , n):\\n            ans ^= start + (2 * i)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118640,
                "title": "o-1-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int start1 = start / 2;\\n        int end1 = start1 + n - 1;\\n        int xor = XOR(start1 - 1) ^ XOR(end1);\\n        int ans = 0;\\n        if(start % 2 == 0 || n % 2 == 0) {\\n            ans = xor * 2;\\n        } else {\\n            ans = xor * 2 + 1;\\n        }\\n        return ans;\\n    }\\n    public static int XOR(int x) {\\n        if(x % 4 == 0) {\\n            return x;\\n        }\\n        if(x % 4 == 1) {\\n            return 1;\\n        }\\n        if(x % 4 == 2) {\\n            return x + 1;\\n        }\\n        if(x % 4 == 3) {\\n            return 0;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int start1 = start / 2;\\n        int end1 = start1 + n - 1;\\n        int xor = XOR(start1 - 1) ^ XOR(end1);\\n        int ans = 0;\\n        if(start % 2 == 0 || n % 2 == 0) {\\n            ans = xor * 2;\\n        } else {\\n            ans = xor * 2 + 1;\\n        }\\n        return ans;\\n    }\\n    public static int XOR(int x) {\\n        if(x % 4 == 0) {\\n            return x;\\n        }\\n        if(x % 4 == 1) {\\n            return 1;\\n        }\\n        if(x % 4 == 2) {\\n            return x + 1;\\n        }\\n        if(x % 4 == 3) {\\n            return 0;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953921,
                "title": "my-simplest-o-n-c-solution-beats-100",
                "content": "```\\nint xorOperation(int n, int start) {\\n        vector<int> v;\\n        int i = 0, res = start;\\n        while(i < n){\\n            int temp = start + 2*i;\\n            if(i)res ^= temp;\\n            i++;\\n        }\\n        return res;\\n    }\\n```\\n***Please vote if it hepled you***",
                "solutionTags": [],
                "code": "```\\nint xorOperation(int n, int start) {\\n        vector<int> v;\\n        int i = 0, res = start;\\n        while(i < n){\\n            int temp = start + 2*i;\\n            if(i)res ^= temp;\\n            i++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 818290,
                "title": "c-simple-solution-0ms-runtime-100",
                "content": "Solution:\\n```\\nclass Solution\\n{\\npublic:\\n    int xorOperation(int n, int start)\\n    {\\n        int res = start, temp = 2;\\n        for (int i = 1; i < n; i++)\\n        {\\n            res ^= (start + temp);\\n            temp += 2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int xorOperation(int n, int start)\\n    {\\n        int res = start, temp = 2;\\n        for (int i = 1; i < n; i++)\\n        {\\n            res ^= (start + temp);\\n            temp += 2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704778,
                "title": "c",
                "content": "```\\npublic int XorOperation(int n, int start) =>\\n\\tEnumerable.Range(0, n)\\n\\t.Select(x => x * 2 + start)\\n\\t.Aggregate((x, y) => x ^ y);\\n```",
                "solutionTags": [],
                "code": "```\\npublic int XorOperation(int n, int start) =>\\n\\tEnumerable.Range(0, n)\\n\\t.Select(x => x * 2 + start)\\n\\t.Aggregate((x, y) => x ^ y);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702619,
                "title": "c-2-lines",
                "content": "```\\nint xorOperation(int n, int start){\\n    for (int x = 0x0 ; n || (start = x, 0) ; x ^= start + (--n << 1));\\n    return start;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint xorOperation(int n, int start){\\n    for (int x = 0x0 ; n || (start = x, 0) ; x ^= start + (--n << 1));\\n    return start;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698268,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans ^= start + i * 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans ^= start + i * 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697879,
                "title": "o-1-time-and-space-math",
                "content": "Let f(x)=0^1^2^...^x, by observation we see that f(x) can be simply decided by x%4, which you can prove by induction.\\nSince the step in this problem is 2, we can consider the last binary digit and the other digits separately. The last digit is 1 iff start is odd and n is odd. And with prefix-sum technique, we can get the rest digits.\\n```\\nclass Solution {\\npublic:\\n    int f(int x)\\n    {\\n        if(x<0)x=0;\\n        switch(x%4)\\n        {\\n            case 0:\\n                return x;\\n            case 1:\\n                return 1;\\n            case 2:\\n                return x+1;\\n            default:\\n                return 0;\\n        }\\n    }\\n    int xorOperation(int n, int start) {\\n        return 2*(f(start/2+n-1)^f(start/2-1))|(start&n&1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int x)\\n    {\\n        if(x<0)x=0;\\n        switch(x%4)\\n        {\\n            case 0:\\n                return x;\\n            case 1:\\n                return 1;\\n            case 2:\\n                return x+1;\\n            default:\\n                return 0;\\n        }\\n    }\\n    int xorOperation(int n, int start) {\\n        return 2*(f(start/2+n-1)^f(start/2-1))|(start&n&1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868979,
                "title": "beats-100-java-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int[] arr = new int[n];\\n        int ans = 0;\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = start+2*i;\\n            ans = ans^arr[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int[] arr = new int[n];\\n        int ans = 0;\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = start+2*i;\\n            ans = ans^arr[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662024,
                "title": "1486-xor-operation-in-an-array-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int x=0;\\n        int res=0;\\n        for(int i=0; i<n; i++){\\n            x = start+2*i;\\n            res ^=x;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int x=0;\\n        int res=0;\\n        for(int i=0; i<n; i++){\\n            x = start+2*i;\\n            res ^=x;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540912,
                "title": "c-easy-code-by-array-declaration-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n      int arr[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i] = start + 2*i;\\n        }\\n\\n        int ans  = 0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            ans = ans ^ arr[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n      int arr[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i] = start + 2*i;\\n        }\\n\\n        int ans  = 0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            ans = ans ^ arr[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525754,
                "title": "simplest-efficient-c-code-time-o-n-space-o-n",
                "content": "# Intuition\\nThe problem is asking to perform an XOR operation on an array of n elements starting from the given \"start\" value with a constant 2*i increment. The XOR operator can be easily implemented using a loop, by iterating through the array and performing the XOR operation on each element.\\n\\n# Approach\\nThe given code is using a loop to create the array of n elements and perform XOR operation on each element. The loop iterates n times and in each iteration, it computes the value of arr[i] as start + 2*i, and also performs the XOR operation on the current value of x with arr[i]. Finally, the code returns the final value of x as the result.\\n\\n# Complexity\\n- Time complexity: $O(n)$ because it iterates n times to create the array and perform the XOR operation.\\n\\n- Space complexity: $O(n)$ because it creates an array of n elements.\\n\\n# Code\\n```\\nint xorOperation(int n, int start)\\n{\\n    int arr[n],x=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        arr[i] = start + 2*i;\\n        x = x^arr[i];\\n    }\\n    return x;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint xorOperation(int n, int start)\\n{\\n    int arr[n],x=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        arr[i] = start + 2*i;\\n        x = x^arr[i];\\n    }\\n    return x;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467593,
                "title": "beats-100-very-simple-c-solution-using-array",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAccording to XOR operation :-\\nEx:- lets take a number 6, then 6^0=6 only.\\nSo i have taken a variable sum in my code for calculating xor value of elements stored in array.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n# Code\\n```\\nint xorOperation(int n, int start){\\n   int ans[n];\\n    int sum=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        ans[i]=start+2*i;\\n    }\\n    for(int j=0;j<n;j++)\\n    {\\n        sum=sum^ans[j];\\n    }\\n    return sum;\\n\\n}\\nPLEASE UPVOTE IF YOU FIND IT HELPFUL,THANKYOU :)",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAccording to XOR operation :-\\nEx:- lets take a number 6, then 6^0=6 only.\\nSo i have taken a variable sum in my code for calculating xor value of elements stored in array.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n# Code\\n```\\nint xorOperation(int n, int start){\\n   int ans[n];\\n    int sum=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        ans[i]=start+2*i;\\n    }\\n    for(int j=0;j<n;j++)\\n    {\\n        sum=sum^ans[j];\\n    }\\n    return sum;\\n\\n}\\nPLEASE UPVOTE IF YOU FIND IT HELPFUL,THANKYOU :)",
                "codeTag": "Unknown"
            },
            {
                "id": 3364943,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        vector<int> nums;\\n        for(int i=0;i<n;i++){\\n            nums.push_back(start + 2*i);\\n        }\\n        //int res = nums[0];\\n        int res = start;\\n        for(int i=1;i<n;i++){\\n            res ^= (start + 2 * i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        vector<int> nums;\\n        for(int i=0;i<n;i++){\\n            nums.push_back(start + 2*i);\\n        }\\n        //int res = nums[0];\\n        int res = start;\\n        for(int i=1;i<n;i++){\\n            res ^= (start + 2 * i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253564,
                "title": "easy-c-solution-for-beginners-runtime-beats-100-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int res=start;\\n        for(int i=start+2,j=2;j<=n;i+=2,j++)\\n            res=res^i;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int res=start;\\n        for(int i=start+2,j=2;j<=n;i+=2,j++)\\n            res=res^i;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236655,
                "title": "c-solution-easy-xor",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint xorOperation(int n, int start) {\\nint res = start;\\nfor (int i=1; i<n; i++){\\nres = res ^ (start + 2 * i);\\n}\\nreturn res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint xorOperation(int n, int start) {\\nint res = start;\\nfor (int i=1; i<n; i++){\\nres = res ^ (start + 2 * i);\\n}\\nreturn res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221226,
                "title": "beats-100-runtime",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int[] nums=new int[n];\\n        int xor=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=(start+2*i);\\n            xor=xor^nums[i];\\n        }\\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int[] nums=new int[n];\\n        int xor=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=(start+2*i);\\n            xor=xor^nums[i];\\n        }\\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194990,
                "title": "3-solution-list-lambda-one-liner-python-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. list Comprehension\\n2. lambda\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n\\n        # Approch 1  (list Comprehension)\\n\\n        nums = []   \\n        for i in range(n):              #1\\n            nums.append(start+2*i)      #2\\n        x = nums[0]\\n        for i in range(1, len(nums)):\\n            x ^= nums[i]\\n        return x \\n        \\n\\n        # Approch 2 (lambda Function )\\n\\n        Line 1 and 2 also written as:\\n        nums = [start+2*i for i in range(x)]\\n        x = nums[0]\\n        result = reduce(lambda x, y: x ^ y, arr)\\n        return result\\n\\n        # One-liner \\n        return reduce(lambda x, y: x ^ y, [start+2*i for i in range(x)])\\n\\n\\n        \\n\\n        \\n        \\n            \\n\\n\\n        \\n\\n        \\n        \\n            \\n\\n        \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n\\n        # Approch 1  (list Comprehension)\\n\\n        nums = []   \\n        for i in range(n):              #1\\n            nums.append(start+2*i)      #2\\n        x = nums[0]\\n        for i in range(1, len(nums)):\\n            x ^= nums[i]\\n        return x \\n        \\n\\n        # Approch 2 (lambda Function )\\n\\n        Line 1 and 2 also written as:\\n        nums = [start+2*i for i in range(x)]\\n        x = nums[0]\\n        result = reduce(lambda x, y: x ^ y, arr)\\n        return result\\n\\n        # One-liner \\n        return reduce(lambda x, y: x ^ y, [start+2*i for i in range(x)])\\n\\n\\n        \\n\\n        \\n        \\n            \\n\\n\\n        \\n\\n        \\n        \\n            \\n\\n        \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182072,
                "title": "3-line-super-easy-java-solution-0ms-100-faster",
                "content": "# Code\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int res = start + 2 * 0;\\n        for (int i = 1; i < n; i++) res ^= start + 2 * i;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int res = start + 2 * 0;\\n        for (int i = 1; i < n; i++) res ^= start + 2 * i;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128492,
                "title": "beats-54-91-xor-operation-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        nums=[]\\n        xor=0\\n        i=0\\n        while i!=n:\\n            nums.append(start+2*i)\\n            i+=1\\n        for i in range(len(nums)):\\n            xor^=nums[i]\\n        return xor\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        nums=[]\\n        xor=0\\n        i=0\\n        while i!=n:\\n            nums.append(start+2*i)\\n            i+=1\\n        for i in range(len(nums)):\\n            xor^=nums[i]\\n        return xor\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843201,
                "title": "swift-easy-one-line-100-speed",
                "content": "```\\nclass Solution {\\n    func xorOperation(_ n: Int, _ start: Int) -> Int {\\n        return (0..<n).map({ start + $0 * 2 }).reduce(0, ^)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func xorOperation(_ n: Int, _ start: Int) -> Int {\\n        return (0..<n).map({ start + $0 * 2 }).reduce(0, ^)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671871,
                "title": "cpp-solution-faster-than-100-c-submissions-easy-to-understand",
                "content": "```\\nint xorOperation(int n, int start) {\\n        if(n==0){\\n            return 0;\\n        }\\n        int arr[n];\\n        for(int i = 0; i < n; i++){\\n            arr[i] = start + 2*i;\\n        }\\n        int count = 0;\\n        for(int i = 0 ;i < n; i++){\\n            count = count^arr[i];\\n        }\\n        return count;\\n    }\\n\\t\\n\\t\\n\\tUpdated Code\\n\\t\\n\\t\\n\\tint xorOperation(int n, int start) {\\n        int count = 0;\\n        for(int i = 0 ;i < n; i++){\\n            count ^= start + i*2;;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint xorOperation(int n, int start) {\\n        if(n==0){\\n            return 0;\\n        }\\n        int arr[n];\\n        for(int i = 0; i < n; i++){\\n            arr[i] = start + 2*i;\\n        }\\n        int count = 0;\\n        for(int i = 0 ;i < n; i++){\\n            count = count^arr[i];\\n        }\\n        return count;\\n    }\\n\\t\\n\\t\\n\\tUpdated Code\\n\\t\\n\\t\\n\\tint xorOperation(int n, int start) {\\n        int count = 0;\\n        for(int i = 0 ;i < n; i++){\\n            count ^= start + i*2;;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2605941,
                "title": "simple-python3-solution-easiest-code",
                "content": "***UPVOTE*** if it is helpful\\n``` \\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        ans = 0\\n        for i in range(n):\\n            ans ^= start\\n            start+=2\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        ans = 0\\n        for i in range(n):\\n            ans ^= start\\n            start+=2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575489,
                "title": "java-easy-o-1-space",
                "content": "# Please Upvote guys \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n```\\n\\t\\tint ans = start;\\n        for(int i = 1; i < n; i++)\\n            ans ^= start + 2 * i;\\n        return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint ans = start;\\n        for(int i = 1; i < n; i++)\\n            ans ^= start + 2 * i;\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421169,
                "title": "cpp17-solution-100-faster",
                "content": "\\n```\\n/*** 1486. XOR Operation in an Array ***/\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int arr[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=start;\\n            start+=2;\\n        }\\n        long long ans =0;\\n        for(int i=0;i<n;i++){\\n            ans^=arr[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*** 1486. XOR Operation in an Array ***/\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int arr[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=start;\\n            start+=2;\\n        }\\n        long long ans =0;\\n        for(int i=0;i<n;i++){\\n            ans^=arr[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758111,
                "title": "100-faster-c-solution-0ms-runtime",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            int temp=start+ 2*i;\\n            res=res^temp;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            int temp=start+ 2*i;\\n            res=res^temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1698651,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        vector<int>arr(n);\\n        int ans=0;\\n        \\n       for(int i=0;i<n;i++)\\n           arr[i]=start + 2 * i;\\n        \\n        for(auto x:arr)\\n            ans^=x;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        vector<int>arr(n);\\n        int ans=0;\\n        \\n       for(int i=0;i<n;i++)\\n           arr[i]=start + 2 * i;\\n        \\n        for(auto x:arr)\\n            ans^=x;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1452278,
                "title": "c-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\t// Find XOR of first n numbers\\n    int XOR_of_n(int n)\\n    {\\n        int modVal = n % 4;\\n        \\n        if (modVal == 0)\\n        {\\n            return n;\\n        }\\n        if (modVal == 1)\\n        {\\n            return 1;\\n        }\\n        if (modVal == 2)\\n        {\\n            return n + 1;\\n        }\\n        if (modVal == 3)\\n        {\\n            return 0;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int xorOperation(int n, int start)\\n    {\\n \\xA0 \\xA0 \\xA0 \\xA0// First, understand that for the given sequence, the first bit depends on start being even. \\n \\xA0 \\xA0 \\xA0 \\xA0// First bit is 1 if start is odd and n is odd (because 2*i doesn\\'t contribute to the last bit)\\n        // Then find the remaining bits by shifting the bits right by 1. This converts the remaining problem\\n        // to XOR_of_n()\\n        \\n        // shift the sequence to right by 1\\n        int begin = start/2;\\n        int end = start/2 + n - 1;\\n        \\n        // find the XOR of remaining bits. XOR is associative so XOR of numbers\\n\\t\\t// between n1 and n2 is XOR(1, n1) ^ XOR(1, n2)\\n        int XOR_shifted = XOR_of_n(begin - 1) ^ XOR_of_n(end);\\n        \\n        // combine the last bit with the remaining bits and return\\n        return (XOR_shifted << 1) | (start & (n & 1));\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// Find XOR of first n numbers\\n    int XOR_of_n(int n)\\n    {\\n        int modVal = n % 4;\\n        \\n        if (modVal == 0)\\n        {\\n            return n;\\n        }\\n        if (modVal == 1)\\n        {\\n            return 1;\\n        }\\n        if (modVal == 2)\\n        {\\n            return n + 1;\\n        }\\n        if (modVal == 3)\\n        {\\n            return 0;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int xorOperation(int n, int start)\\n    {\\n \\xA0 \\xA0 \\xA0 \\xA0// First, understand that for the given sequence, the first bit depends on start being even. \\n \\xA0 \\xA0 \\xA0 \\xA0// First bit is 1 if start is odd and n is odd (because 2*i doesn\\'t contribute to the last bit)\\n        // Then find the remaining bits by shifting the bits right by 1. This converts the remaining problem\\n        // to XOR_of_n()\\n        \\n        // shift the sequence to right by 1\\n        int begin = start/2;\\n        int end = start/2 + n - 1;\\n        \\n        // find the XOR of remaining bits. XOR is associative so XOR of numbers\\n\\t\\t// between n1 and n2 is XOR(1, n1) ^ XOR(1, n2)\\n        int XOR_shifted = XOR_of_n(begin - 1) ^ XOR_of_n(end);\\n        \\n        // combine the last bit with the remaining bits and return\\n        return (XOR_shifted << 1) | (start & (n & 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449517,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        vector<int> v; \\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            v.push_back(start+2*i);     \\n        }\\n        for(int i=0; i<v.size();i++){\\n            sum=sum^v[i];\\n        }\\n        return sum; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        vector<int> v; \\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            v.push_back(start+2*i);     \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1432930,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int res = start;\\n        for(int i=1; i<n; i++){\\n            res^=start + 2*i;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nThat is all :)\\nfrom Uzbekistan\\uD83C\\uDDFA\\uD83C\\uDDFF",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int res = start;\\n        for(int i=1; i<n; i++){\\n            res^=start + 2*i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368844,
                "title": "java-clean-code-100-faster",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            ans ^= start + 2*i;;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            ans ^= start + 2*i;;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306618,
                "title": "easy-python-solution-99-17",
                "content": "Runtime: 20 ms, faster than 99.17% of Python3 online submissions for XOR Operation in an Array.\\nMemory Usage: 14.3 MB, less than 18.70% of Python3 online submissions for XOR Operation in an Array.\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        c=0\\n        for i in range(n):\\n            c^=(start+2*i)\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 20 ms, faster than 99.17% of Python3 online submissions for XOR Operation in an Array.\\nMemory Usage: 14.3 MB, less than 18.70% of Python3 online submissions for XOR Operation in an Array.\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        c=0\\n        for i in range(n):\\n            c^=(start+2*i)\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 1293178,
                "title": "1-line-java-solution",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        return IntStream.range(0,n).map(i -> start + 2 * i).reduce(0, (a,b) -> a ^ b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        return IntStream.range(0,n).map(i -> start + 2 * i).reduce(0, (a,b) -> a ^ b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272615,
                "title": "c-0ms-no-array-created-speedy-solution",
                "content": "```\\nint xorOperation(int n, int start) {\\n        int ans=start;\\n        for(int i=1;i<n;i++){\\n            ans^=(start+2*i);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint xorOperation(int n, int start) {\\n        int ans=start;\\n        for(int i=1;i<n;i++){\\n            ans^=(start+2*i);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1239005,
                "title": "python-solution-faster-than-95",
                "content": "\\n    def xorOperation(self, n: int, start: int) -> int:\\n        nums = []\\n        for i in range(n):\\n            nums.append(start + 2*i)\\n        return reduce(lambda x, y: x ^ y, nums)\\n",
                "solutionTags": [],
                "code": "\\n    def xorOperation(self, n: int, start: int) -> int:\\n        nums = []\\n        for i in range(n):\\n            nums.append(start + 2*i)\\n        return reduce(lambda x, y: x ^ y, nums)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1147864,
                "title": "a-simple-and-readable-solution-for-this-problem-4-lines",
                "content": "**Runtime Beats 94.28% of Python3 submissions**\\n\\n**Code**\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        ans = start\\n        for i in range(1 , n):\\n            ans ^= start + (2 * i)\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        ans = start\\n        for i in range(1 , n):\\n            ans ^= start + (2 * i)\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111030,
                "title": "one-line-javascript-faster-than-99-39",
                "content": "This possibly the most concise format for this solution\\n\\n```\\nvar xorOperation = (n, start) => new Array(n).fill(start).reduce((x,e,i)=>i!=0 ? x^(start +2*i) :x ,start)\\n```",
                "solutionTags": [],
                "code": "```\\nvar xorOperation = (n, start) => new Array(n).fill(start).reduce((x,e,i)=>i!=0 ? x^(start +2*i) :x ,start)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1111026,
                "title": "simple-js-solution-faster-than-95",
                "content": "```\\nvar xorOperation = function(n, start) {\\n    let nums = new Array(n)\\n    for(let i=1; i<n; i++) nums[i] = start+2*i\\n  \\n    return nums.reduce((x,e,i)=>i!=0 ? x^(start +2*i) :x ,start)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar xorOperation = function(n, start) {\\n    let nums = new Array(n)\\n    for(let i=1; i<n; i++) nums[i] = start+2*i\\n  \\n    return nums.reduce((x,e,i)=>i!=0 ? x^(start +2*i) :x ,start)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 959881,
                "title": "javascript-fast-solution",
                "content": "```\\nvar xorOperation = function(n, start) {\\n  let result = start;\\n  \\n  for (let i = 1; i < n; i ++) {\\n    result ^= start + i * 2;\\n  }\\n  \\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar xorOperation = function(n, start) {\\n  let result = start;\\n  \\n  for (let i = 1; i < n; i ++) {\\n    result ^= start + i * 2;\\n  }\\n  \\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 892607,
                "title": "1486-xor-operation-in-an-array-javascript-soluitons-time-o-1-space-o-1",
                "content": "Time: O(1)\\nSpace: O(1)\\nsolution by [lonely7yk](https://leetcode.com/lonely7yk/)\\n```\\nvar xorOperation = function(n, start) {\\n    let last = start + 2 * (n - 1)\\n    if (start % 4 < 2) {\\n        start = 0\\n    } else {\\n        n -= 1\\n    }\\n    if (n % 2 == 0) return start ^ (n & 2);\\n\\n    return start ^ last ^ (n & 2)\\n};\\n\\n```\\nMy solutions \\nTime O(n) \\nSpace O(1)\\n```\\nvar xorOperation = function(n, start) {\\n    let arr = [];\\n    for (let i = 0; i < n; i++) {\\n        arr[i] = start + 2 * i;\\n    }\\n    return arr.reduce((acc, cur) => acc ^ cur, 0);\\n};\\n```\\n```\\nvar xorOperation = function(n, start) {\\n    let bitwiseXor = 0;\\n    for (let i = 0; i < n; i++) {\\n        bitwiseXor ^= start + 2 * i;\\n    }\\n    return bitwiseXor;\\n};\\n```\\n```\\nvar xorOperation = function(n, start) {\\n    let bitwiseXor = start;\\n    for (let i = 1; i < n; i++) {\\n        bitwiseXor ^= start + 2 * i;\\n    }\\n    return bitwiseXor;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar xorOperation = function(n, start) {\\n    let last = start + 2 * (n - 1)\\n    if (start % 4 < 2) {\\n        start = 0\\n    } else {\\n        n -= 1\\n    }\\n    if (n % 2 == 0) return start ^ (n & 2);\\n\\n    return start ^ last ^ (n & 2)\\n};\\n\\n```\n```\\nvar xorOperation = function(n, start) {\\n    let arr = [];\\n    for (let i = 0; i < n; i++) {\\n        arr[i] = start + 2 * i;\\n    }\\n    return arr.reduce((acc, cur) => acc ^ cur, 0);\\n};\\n```\n```\\nvar xorOperation = function(n, start) {\\n    let bitwiseXor = 0;\\n    for (let i = 0; i < n; i++) {\\n        bitwiseXor ^= start + 2 * i;\\n    }\\n    return bitwiseXor;\\n};\\n```\n```\\nvar xorOperation = function(n, start) {\\n    let bitwiseXor = start;\\n    for (let i = 1; i < n; i++) {\\n        bitwiseXor ^= start + 2 * i;\\n    }\\n    return bitwiseXor;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 883412,
                "title": "python-xor-1-line",
                "content": "```\\n        from operator import xor \\n        return reduce(xor,[start+2*i for i in range(n)])\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n        from operator import xor \\n        return reduce(xor,[start+2*i for i in range(n)])\\n\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 836645,
                "title": "c-faster-than-100-solution",
                "content": "# C++ Solution\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int res = start;\\n        while(n > 1){\\n            start += 2;\\n            res = res ^ start; // compute XOR of res and start\\n            n--;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int res = start;\\n        while(n > 1){\\n            start += 2;\\n            res = res ^ start; // compute XOR of res and start\\n            n--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 765497,
                "title": "java-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "Any suggestions would be welcome. Cheers :)\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int nums[]=new int[n];\\n        int i,bit=0;\\n        for(i=0;i<nums.length;i++) nums[i]=start+2*i;\\n        for(i=0;i<nums.length;i++) bit^=nums[i];\\n        return bit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int nums[]=new int[n];\\n        int i,bit=0;\\n        for(i=0;i<nums.length;i++) nums[i]=start+2*i;\\n        for(i=0;i<nums.length;i++) bit^=nums[i];\\n        return bit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741364,
                "title": "java-o-1-100-runtime-and-memory",
                "content": "```java\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        /**\\n            First of all, we need to know (2^4^6^8^10) == 2^(4^6^8^10) == 2^((4^6)^(8^10)) = 2^(2^2) = 2\\n        \\n            (1) start >> 1, to match add 2*n as add n;\\n            (2) then &1 to check if start >> 1 is odd or even, so we will know last digit start with 0 or 1.\\n            (3) then &1 to figure out n is odd or even\\n            (4) start >> 1 is odd, then n is odd, result is (^pairs of 1)^ first one\\n                                   then n is even, result is (^pairs of 1)^ last one ^ first one\\n            (5) start >> 1 is even, then n is even, the result is (^pairs of 1)\\n                                    then n is odd, the result is (^pairs of 1)^last one.\\n            (6) the final result: (result from step 4, 5) * 2 + ss;  ss is the last digit XOR result.\\n        **/ \\n            int ss = 0;\\n            if( start % 2 == 1 && n % 2 == 1){\\n                ss = 1;\\n            }\\n            start = start>>1;\\n            if( (start & 1) == 1){\\n                if( (n & 1) == 1){\\n                    return (((n-1)/2 & 1) ^ start) * 2 + ss;\\n                }\\n                else{\\n                    return (((n-2)/2 & 1) ^ start ^ (start + n-1)) * 2 + ss;\\n                }\\n            }\\n            else{\\n                if( (n & 1) == 1){\\n                    return (((n-1)/2 & 1) ^ (start + n - 1)) * 2 + ss;\\n                }\\n                else{\\n                    return (n/2 & 1) * 2 + ss;\\n                }\\n            }     \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        /**\\n            First of all, we need to know (2^4^6^8^10) == 2^(4^6^8^10) == 2^((4^6)^(8^10)) = 2^(2^2) = 2\\n        \\n            (1) start >> 1, to match add 2*n as add n;\\n            (2) then &1 to check if start >> 1 is odd or even, so we will know last digit start with 0 or 1.\\n            (3) then &1 to figure out n is odd or even\\n            (4) start >> 1 is odd, then n is odd, result is (^pairs of 1)^ first one\\n                                   then n is even, result is (^pairs of 1)^ last one ^ first one\\n            (5) start >> 1 is even, then n is even, the result is (^pairs of 1)\\n                                    then n is odd, the result is (^pairs of 1)^last one.\\n            (6) the final result: (result from step 4, 5) * 2 + ss;  ss is the last digit XOR result.\\n        **/ \\n            int ss = 0;\\n            if( start % 2 == 1 && n % 2 == 1){\\n                ss = 1;\\n            }\\n            start = start>>1;\\n            if( (start & 1) == 1){\\n                if( (n & 1) == 1){\\n                    return (((n-1)/2 & 1) ^ start) * 2 + ss;\\n                }\\n                else{\\n                    return (((n-2)/2 & 1) ^ start ^ (start + n-1)) * 2 + ss;\\n                }\\n            }\\n            else{\\n                if( (n & 1) == 1){\\n                    return (((n-1)/2 & 1) ^ (start + n - 1)) * 2 + ss;\\n                }\\n                else{\\n                    return (n/2 & 1) * 2 + ss;\\n                }\\n            }     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738685,
                "title": "rust-1-line",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for XOR Operation in an Array.\\nMemory Usage: 2.1 MB, less than 100.00% of Rust online submissions for XOR Operation in an Array.\\n\\n```rust\\nimpl Solution {\\n    pub fn xor_operation(n: i32, start: i32) -> i32 {\\n        (start..)\\n            .step_by(2)\\n            .take(n as usize)\\n            .fold(0, |acc, x| acc ^ x)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n    #[test]\\n    fn test_xor_operation() {\\n        assert_eq!(Solution::xor_operation(5, 0), 8)\\n    }\\n\\n    #[test]\\n    fn test_xor_operation_02() {\\n        assert_eq!(Solution::xor_operation(4, 3), 8)\\n    }\\n\\n    #[test]\\n    fn test_xor_operation_03() {\\n        assert_eq!(Solution::xor_operation(1, 7), 7)\\n    }\\n\\n    #[test]\\n    fn test_xor_operation_04() {\\n        assert_eq!(Solution::xor_operation(10, 5), 2)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn xor_operation(n: i32, start: i32) -> i32 {\\n        (start..)\\n            .step_by(2)\\n            .take(n as usize)\\n            .fold(0, |acc, x| acc ^ x)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n    #[test]\\n    fn test_xor_operation() {\\n        assert_eq!(Solution::xor_operation(5, 0), 8)\\n    }\\n\\n    #[test]\\n    fn test_xor_operation_02() {\\n        assert_eq!(Solution::xor_operation(4, 3), 8)\\n    }\\n\\n    #[test]\\n    fn test_xor_operation_03() {\\n        assert_eq!(Solution::xor_operation(1, 7), 7)\\n    }\\n\\n    #[test]\\n    fn test_xor_operation_04() {\\n        assert_eq!(Solution::xor_operation(10, 5), 2)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731134,
                "title": "c-solution",
                "content": "Below is a simple c# solution. \\n```\\npublic class Solution {\\n    public int XorOperation(int n, int start) {\\n        int result = 0; int i =0;\\n        while (n > 0)\\n        {\\n            result = result ^ (start + 2 * i);\\n            i++; n--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int XorOperation(int n, int start) {\\n        int result = 0; int i =0;\\n        while (n > 0)\\n        {\\n            result = result ^ (start + 2 * i);\\n            i++; n--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724150,
                "title": "one-line-solution-in-ruby",
                "content": "```ruby\\ndef xor_operation(n, start)\\n  (1...n).inject(start) {|res, i| res ^ (start + 2*i) }\\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\ndef xor_operation(n, start)\\n  (1...n).inject(start) {|res, i| res ^ (start + 2*i) }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 712745,
                "title": "one-line-swift-solution",
                "content": "One-line Swift solution\\n```\\nclass Solution {\\n    func xorOperation(_ n: Int, _ start: Int) -> Int {\\n        return (0..<n).map({ start + $0 * 2 }).reduce(0, ^)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func xorOperation(_ n: Int, _ start: Int) -> Int {\\n        return (0..<n).map({ start + $0 * 2 }).reduce(0, ^)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710115,
                "title": "simple-c-speed-100-memory-100",
                "content": "```\\nint xorOperation(int n, int start) {\\n        \\n        int data = start;\\n        bitset<32> b1(data);\\n        for(int i=1;i<n;i++)\\n        {\\n            data = start + 2*i;\\n            bitset<32> b2(data);\\n            b1 = b1^b2;\\n        }\\n        \\n        return b1.to_ulong();\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint xorOperation(int n, int start) {\\n        \\n        int data = start;\\n        bitset<32> b1(data);\\n        for(int i=1;i<n;i++)\\n        {\\n            data = start + 2*i;\\n            bitset<32> b2(data);\\n            b1 = b1^b2;\\n        }\\n        \\n        return b1.to_ulong();\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699469,
                "title": "rust-one-line-functional-programming",
                "content": "```rust\\nimpl Solution {\\n    pub fn xor_operation(n: i32, start: i32) -> i32 {\\n        (0..n).fold(0, |mut ans, x| { ans ^= 2 * x + start; ans })\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn xor_operation(n: i32, start: i32) -> i32 {\\n        (0..n).fold(0, |mut ans, x| { ans ^= 2 * x + start; ans })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697901,
                "title": "1-line-python",
                "content": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        return reduce(lambda x,y:x^(start+2*y),range(n),0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        return reduce(lambda x,y:x^(start+2*y),range(n),0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697860,
                "title": "java-c-python3-clean-code",
                "content": "```\\nJava:-\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans ^= (start + 2 * i);            \\n        return ans;\\n    }\\n}\\n\\nC++:-\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans ^= (start + 2*i);\\n        return ans;\\n    }\\n};\\n\\nPython3:-\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        ans = 0\\n        for i in range(n):\\n            ans ^= (start + 2*i)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nJava:-\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans ^= (start + 2 * i);            \\n        return ans;\\n    }\\n}\\n\\nC++:-\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans ^= (start + 2*i);\\n        return ans;\\n    }\\n};\\n\\nPython3:-\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        ans = 0\\n        for i in range(n):\\n            ans ^= (start + 2*i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697764,
                "title": "java-easy-straightforward-linear-time-o-1-space",
                "content": "```\\npublic int xorOperation(int n, int start) {\\n        int xor=0;\\n        for (int i = 0; i<n; i++)\\n            xor ^= start + 2*i;\\n        return xor;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int xorOperation(int n, int start) {\\n        int xor=0;\\n        for (int i = 0; i<n; i++)\\n            xor ^= start + 2*i;\\n        return xor;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 697693,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} start\\n * @return {number}\\n */\\nvar xorOperation = function(n, start) {\\n    let arr = [],xor\\n    for(let i=0;i<n;i++){\\n        arr.push(start+(i*2))\\n    }\\n    xor = arr[0]\\n    for(let i=1;i<n;i++){\\n        xor = xor^arr[i]\\n    }\\n    return xor\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} start\\n * @return {number}\\n */\\nvar xorOperation = function(n, start) {\\n    let arr = [],xor\\n    for(let i=0;i<n;i++){\\n        arr.push(start+(i*2))\\n    }\\n    xor = arr[0]\\n    for(let i=1;i<n;i++){\\n        xor = xor^arr[i]\\n    }\\n    return xor\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009735,
                "title": "the-power-of-high-order-function-hof",
                "content": "It is always fun to avoid using explicit for-loop when we can try out HOF\\n# Code\\n```\\nfunction xorOperation(n: number, start: number): number {\\n    return Array.from({ length: n }, (_, index) => start + index * 2).reduce((acc, cur) => cur^acc, 0)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction xorOperation(n: number, start: number): number {\\n    return Array.from({ length: n }, (_, index) => start + index * 2).reduce((acc, cur) => cur^acc, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796329,
                "title": "fully-explained-c-easy-to-understand",
                "content": "# Intuition & Approach\\nThe given code defines a function ```xorOperation``` that takes *two integer parameters* ```n``` and ```start```. It calculates the XOR (exclusive OR) of n numbers starting from the value of start with a common difference of 2. The function then returns the final XOR result.\\n\\n##### Step-by-step explanation of how the function works:\\n\\n1. Initialize a variable ```num``` with the value of ```start```. This variable will hold the current XOR result.\\n2. Loop through the numbers ```i``` from ```1 to n-1``` (since the loop starts from 1, not 0).\\n\\n3. Inside the loop, calculate the next number in the sequence using ```start + 2*i```.\\n4. ```XOR``` the current value of ```num``` with the calculated number, and store the result back into ```num```. This operation updates the XOR result as we iterate through the sequence.\\n5. After the loop finishes, return the final value of ```num```, which will be the XOR of all ```n``` numbers.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n\\n        int num = start;\\n        \\n        for(int i = 1; i < n; i++){\\n\\n            num = num ^ (start + 2*i);\\n\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```xorOperation```\n```n```\n```start```\n```num```\n```start```\n```i```\n```1 to n-1```\n```start + 2*i```\n```XOR```\n```num```\n```num```\n```num```\n```n```\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n\\n        int num = start;\\n        \\n        for(int i = 1; i < n; i++){\\n\\n            num = num ^ (start + 2*i);\\n\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707839,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing for loop\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate in the array from 1 to n, storing it int answer variable which is intialize with start, then returning the answer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans = start;\\n        for(int i=1; i<n; i++){\\n            ans = ans ^ (start+2*i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans = start;\\n        for(int i=1; i<n; i++){\\n            ans = ans ^ (start+2*i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540904,
                "title": "c-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int nums[n];\\n        for(int i=0; i<n; i++){\\n            nums[i] = start + 2*i;\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n\\n            ans = ans ^ nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int nums[n];\\n        for(int i=0; i<n; i++){\\n            nums[i] = start + 2*i;\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n\\n            ans = ans ^ nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534779,
                "title": "this-is-very-easy-but-it-is-working-very-fast-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int []nums=new int[n];\\n        for(int i=0;i<n;i++){\\n            nums[i]=start+2*i;\\n        }\\n        int sum=nums[0];\\n        for(int i=1;i<n;i++){\\n            sum^=nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int []nums=new int[n];\\n        for(int i=0;i<n;i++){\\n            nums[i]=start+2*i;\\n        }\\n        int sum=nums[0];\\n        for(int i=1;i<n;i++){\\n            sum^=nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514935,
                "title": "answer-is-in-the-question",
                "content": "# Intuition\\nI Just Write the code as Question says!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans=0;\\n        int[] arr = new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]= start + (2*i);\\n            ans^=arr[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n![upvote.png](https://assets.leetcode.com/users/images/6aa6f8ce-120a-454e-ba81-ed004161d22e_1683800198.3876867.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans=0;\\n        int[] arr = new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]= start + (2*i);\\n            ans^=arr[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252212,
                "title": "constant-space",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int XorOperation(int n, int start) \\n    { \\n        int ans=start;\\n        for(var i=1; i<n;i++) \\n            ans=ans^(start+2*i); \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int XorOperation(int n, int start) \\n    { \\n        int ans=start;\\n        for(var i=1; i<n;i++) \\n            ans=ans^(start+2*i); \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232676,
                "title": "java-100-faster-than",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int x = start;\\n        for(int i = start+2; i <= n * 2 - 2 + start; i += 2){\\n            x ^= i;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int x = start;\\n        for(int i = start+2; i <= n * 2 - 2 + start; i += 2){\\n            x ^= i;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172640,
                "title": "xor-operation-in-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse a for loop to do multiple XOR operations\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor loop is used\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int i, j, num, x;\\n        for(i=0 ; i<n ; i++)\\n        {\\n            num = start + 2*i;\\n            if(i==0)\\n            {\\n                x = num;\\n            }\\n            else\\n            {\\n                x = x^num;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int i, j, num, x;\\n        for(i=0 ; i<n ; i++)\\n        {\\n            num = start + 2*i;\\n            if(i==0)\\n            {\\n                x = num;\\n            }\\n            else\\n            {\\n                x = x^num;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909030,
                "title": "c-simple-loop-21ms-97",
                "content": "```\\npublic class Solution {\\n    public int XorOperation(int n, int start) {\\n        var xor = 0;\\n\\n        for(var i=0; i<n; i++)\\n        {\\n            xor = xor ^ (start + 2 * i);\\n        }\\n\\n        return xor;\\n    }\\n}\\n```\\nor one liner with LINQ\\n```\\npublic class Solution {\\n    public int XorOperation(int n, int start) \\n        => Enumerable.Range(0, n).Aggregate(0, (r, i) => r ^ (start + i * 2));\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int XorOperation(int n, int start) {\\n        var xor = 0;\\n\\n        for(var i=0; i<n; i++)\\n        {\\n            xor = xor ^ (start + 2 * i);\\n        }\\n\\n        return xor;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int XorOperation(int n, int start) \\n        => Enumerable.Range(0, n).Aggregate(0, (r, i) => r ^ (start + i * 2));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819919,
                "title": "easiest-solution-c-plus-plus-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        vector<int> nums;\\n        nums.push_back(start);\\n        int ans = nums[0];\\n        for(int i=1;i<n;i++){\\n            nums.push_back(start+2*i);\\n            ans^=(start+2*i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        vector<int> nums;\\n        nums.push_back(start);\\n        int ans = nums[0];\\n        for(int i=1;i<n;i++){\\n            nums.push_back(start+2*i);\\n            ans^=(start+2*i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730508,
                "title": "very-easy-javascript-solution",
                "content": "var xorOperation = function (n, start) {\\nlet s = 0\\n  for(let j=0;j<n;j++){\\n     s = (start+2*j) ^s\\n  }\\nreturn s\\n};",
                "solutionTags": [],
                "code": "var xorOperation = function (n, start) {\\nlet s = 0\\n  for(let j=0;j<n;j++){\\n     s = (start+2*j) ^s\\n  }\\nreturn s\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2702867,
                "title": "xor-operation-in-an-array",
                "content": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {   \\n\\t\\tint res = start;\\n\\t\\tfor (int i=1; i<n; i++){\\n\\t\\t\\tres = res ^ (start + 2 * i);\\n\\t\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {   \\n\\t\\tint res = start;\\n\\t\\tfor (int i=1; i<n; i++){\\n\\t\\t\\tres = res ^ (start + 2 * i);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2676548,
                "title": "xor-operation-easy-solution-c-java-100-beats",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\nTo make an array .\\n# Code\\nC++ solution\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int a[n];\\n         for(int i=0;i<n;i++){\\n            a[i]=start+2*i;\\n        }\\n        int ans=start;\\n        for(int i=1;i<n;i++){\\n            ans=ans^a[i];\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\nJava solution\\n```\\nclass Solution {\\n    int xorOperation(int n, int start) {\\n        int[] a=new int[n];\\n         for(int i=0;i<n;i++){\\n            a[i]=start+2*i;\\n        }\\n        int ans=start;\\n        for(int i=1;i<n;i++){\\n            ans=ans^a[i];\\n        }\\n        return ans;\\n\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int a[n];\\n         for(int i=0;i<n;i++){\\n            a[i]=start+2*i;\\n        }\\n        int ans=start;\\n        for(int i=1;i<n;i++){\\n            ans=ans^a[i];\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int xorOperation(int n, int start) {\\n        int[] a=new int[n];\\n         for(int i=0;i<n;i++){\\n            a[i]=start+2*i;\\n        }\\n        int ans=start;\\n        for(int i=1;i<n;i++){\\n            ans=ans^a[i];\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675422,
                "title": "faster-than-100-c-clean-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int r=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            r^=(start+2*i);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int r=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            r^=(start+2*i);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576623,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]\\n```\\nint xorOperation(int n, int start) {\\n        vector<int> ans;\\n        int x=start+2*0;\\n        for(int i=1;i<n;i++){\\n            x=x^start+2*i;\\n        }\\n        return x;\\n    }\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]",
                "solutionTags": [],
                "code": "```\\nint xorOperation(int n, int start) {\\n        vector<int> ans;\\n        int x=start+2*0;\\n        for(int i=1;i<n;i++){\\n            x=x^start+2*i;\\n        }\\n        return x;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2548127,
                "title": "3ms-c-simple-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int &n, int &start) {\\n        int ans = 0;\\n        while(n--){\\n            ans ^= (start + 2*n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int &n, int &start) {\\n        int ans = 0;\\n        while(n--){\\n            ans ^= (start + 2*n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542191,
                "title": "c-naive-vs-math-solution-100-time-0ms-45-space-5-9mb",
                "content": "The first appproach is basically the interviewer asking you if you can\\n* loop;\\n* apply basic bitwise operators.\\n\\nAnd, yes: we can.\\n\\nWe will declare the support variable `res`, XOR it from `start` up to `lmt` (which is double `n` positions after `start`) excluded and then just `return` `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        // support variables\\n        int res = 0;\\n        for (int i = start, lmt = start + (n << 1); i < lmt; i += 2) res ^= i;\\n        return res;\\n    }\\n};\\n```\\nThe other approach, definitely not too doable in the few minutes of an interview, is to try and recognise patterns: you might try to take some pen and paper and spot that a few are recurring; particularly, you might spot that the results are somehow cyclical around `n`, in cycles of `4`.\\n\\nMore specifically, with a bit of trial and error we might recognise that when `start % 4 > 1`, then depending on `n % 4` (computed as `n % 3` for the sake of efficiency and called `nMod` from now on), we will have, with `lmt` now taking the value of the last number in the range, included:\\n\\n```cpp\\nnMod == 0 => start ^ lmt ^ 2\\nnMod == 1 => start\\nnMod == 2 => start ^ lmt\\nnMod == 3 => start ^ 2\\n```\\n\\nInstead, when `start % 4 < 2`:\\n\\n```cpp\\nnMod == 0 => 0\\nnMod == 1 => lmt\\nnMod == 2 => 3\\nnMod == 3 => lmt ^ 2\\n```\\n\\nNow, we can code it and get everything in constant time!\\n\\nThe code, which does not seem that much more performing with the given range:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        // support variables\\n        int lmt = start + ((n - 1) << 1), nMod = n & 3;\\n        // computing res, depending on start % 4 > 1\\n        if ((start & 3) > 1) {\\n            switch (nMod) {\\n                case 1: return start;\\n                case 2: return start ^ lmt;\\n                case 3: return 2 ^ start;\\n                default: return start ^ lmt ^ 2;\\n            }\\n        }\\n        switch (nMod) {\\n            case 1: return lmt;\\n            case 2: return 2;\\n            case 3: return 2 ^ lmt;\\n            default: return 0;\\n        }\\n    }\\n};\\n```\\nSpotting some similar patterns, we might actually compute a base value for `res` depending on the possible value of `n % 4`, then adjust if for when `start % 4 > 1`, XORing each element by `start ^ lmt` (so that they cancel each other out when already present) and also for `2` when `n % 4` is even.\\n\\nThe code, even a bit slower, but fun to write juggling all this info:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        // support variables\\n        int lmt = start + ((n - 1) << 1), nMod = n & 3, res;\\n        res = nMod == 1 ? lmt : nMod == 2 ? 2 : nMod == 3 ? 2 ^ lmt : 0;\\n        // adjusting for start % 4 > 1\\n        if ((start & 3) > 1) res ^= start ^ lmt ^ (!(n & 1) << 1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        // support variables\\n        int res = 0;\\n        for (int i = start, lmt = start + (n << 1); i < lmt; i += 2) res ^= i;\\n        return res;\\n    }\\n};\\n```\n```cpp\\nnMod == 0 => start ^ lmt ^ 2\\nnMod == 1 => start\\nnMod == 2 => start ^ lmt\\nnMod == 3 => start ^ 2\\n```\n```cpp\\nnMod == 0 => 0\\nnMod == 1 => lmt\\nnMod == 2 => 3\\nnMod == 3 => lmt ^ 2\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        // support variables\\n        int lmt = start + ((n - 1) << 1), nMod = n & 3;\\n        // computing res, depending on start % 4 > 1\\n        if ((start & 3) > 1) {\\n            switch (nMod) {\\n                case 1: return start;\\n                case 2: return start ^ lmt;\\n                case 3: return 2 ^ start;\\n                default: return start ^ lmt ^ 2;\\n            }\\n        }\\n        switch (nMod) {\\n            case 1: return lmt;\\n            case 2: return 2;\\n            case 3: return 2 ^ lmt;\\n            default: return 0;\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        // support variables\\n        int lmt = start + ((n - 1) << 1), nMod = n & 3, res;\\n        res = nMod == 1 ? lmt : nMod == 2 ? 2 : nMod == 3 ? 2 ^ lmt : 0;\\n        // adjusting for start % 4 > 1\\n        if ((start & 3) > 1) res ^= start ^ lmt ^ (!(n & 1) << 1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535563,
                "title": "beginner-friendly-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        vector<int> nums;\\n        int ans = 0;\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            nums.push_back(start + 2*i);\\n        }\\n        for(int i = 0 ; i < nums.size(); i++)\\n            ans = ans ^ nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        vector<int> nums;\\n        int ans = 0;\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            nums.push_back(start + 2*i);\\n        }\\n        for(int i = 0 ; i < nums.size(); i++)\\n            ans = ans ^ nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529801,
                "title": "simple-python-solution",
                "content": "Time Complexcity O(N)\\nSpace Complexcity O(1)\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        re=start\\n        for i in range(1,n):\\n            ne=start+2*i\\n            re^=ne\\n        return re\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        re=start\\n        for i in range(1,n):\\n            ne=start+2*i\\n            re^=ne\\n        return re\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527162,
                "title": "java-easy-solution-100-fast",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int c=0;\\n        for(int i=0;i<n;i++)c=c^(start+2*i);\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int c=0;\\n        for(int i=0;i<n;i++)c=c^(start+2*i);\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510754,
                "title": "xor-operation-in-an-array",
                "content": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n         vector<int> nums;\\n        for (int i =0;i<n;i++)\\n            nums.push_back(start + 2 * i);\\n        int ans = nums[0];\\n        for ( int a = 1; a<n;a++)\\n            ans ^= nums[a];\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n         vector<int> nums;\\n        for (int i =0;i<n;i++)\\n            nums.push_back(start + 2 * i);\\n        int ans = nums[0];\\n        for ( int a = 1; a<n;a++)\\n            ans ^= nums[a];\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2506602,
                "title": "java-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int xor=0;\\n        for(int i=0;i<n;i++){\\n            xor ^=start;\\n            start += 2;\\n        }\\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int xor=0;\\n        for(int i=0;i<n;i++){\\n            xor ^=start;\\n            start += 2;\\n        }\\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489458,
                "title": "python3",
                "content": "```\\n        res=[0]*n\\n        for i in range(n):\\n            res[i]=start+2*i\\n        f=res[0]\\n        for j in range(1,n):\\n            f=f^res[j]\\n        return f",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n        res=[0]*n\\n        for i in range(n):\\n            res[i]=start+2*i\\n        f=res[0]\\n        for j in range(1,n):\\n            f=f^res[j]\\n        return f",
                "codeTag": "Unknown"
            },
            {
                "id": 2483687,
                "title": "c-solution-0ms-100-fast",
                "content": "**C++ Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n      vector<int> vec;\\n      int ans = 0;\\n      for(int i = 0; i < n; i++)\\n      {\\n        vec.emplace_back(start + 2 * i);\\n        ans ^= vec[i];\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n      vector<int> vec;\\n      int ans = 0;\\n      for(int i = 0; i < n; i++)\\n      {\\n        vec.emplace_back(start + 2 * i);\\n        ans ^= vec[i];\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453495,
                "title": "0-ms-runtime-easy-solution",
                "content": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n    int count=start;\\n    for(int i=1;i<n;i++)\\n    {\\n        count=count^(start+2*i);\\n    }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n    int count=start;\\n    for(int i=1;i<n;i++)\\n    {\\n        count=count^(start+2*i);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2453490,
                "title": "java-runtime-0ms-faster-than-100-00-beginner-friendly-easy-fast-solution",
                "content": "```\\npublic int xorOperation(int n, int start) {\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            int num = start + 2 * i;\\n            total ^= num;\\n        }\\n        return total;\\n    }",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\npublic int xorOperation(int n, int start) {\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            int num = start + 2 * i;\\n            total ^= num;\\n        }\\n        return total;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2429957,
                "title": "java-fastest-solution-100-with-0ms",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            ans = ans^(start+2*i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            ans = ans^(start+2*i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277668,
                "title": "c-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int res=0;\\n        while(n--)\\n        {\\n            res^=start;\\n            start+=2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int res=0;\\n        while(n--)\\n        {\\n            res^=start;\\n            start+=2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267638,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans = start;\\n        for(int i = 1; i < n; i++) {\\n            ans ^= (start + 2 * i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans = start;\\n        for(int i = 1; i < n; i++) {\\n            ans ^= (start + 2 * i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237127,
                "title": "javascript-solution-one-liner-86-faster-66ms",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} start\\n * @return {number}\\n */\\nconst xorOperation = (n, start) => Array(n).fill().reduce((res, _, i) => (start + 2 * i) ^ res, 0);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} start\\n * @return {number}\\n */\\nconst xorOperation = (n, start) => Array(n).fill().reduce((res, _, i) => (start + 2 * i) ^ res, 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2236554,
                "title": "java-100-faster-0-ms",
                "content": "```\\npublic int xorOperation(int n, int start) {\\n        int temp = start;\\n        for(int i = 1 ; i < n ;i++){\\n            start = start ^ (temp + 2 * i);\\n        }\\n        return start;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int xorOperation(int n, int start) {\\n        int temp = start;\\n        for(int i = 1 ; i < n ;i++){\\n            start = start ^ (temp + 2 * i);\\n        }\\n        return start;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2229141,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int[] nums=new int[n];\\n        \\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=start+2*i;\\n        }\\n        \\n        int ans=0;\\n        for(int num:nums){\\n            ans ^=num;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int[] nums=new int[n];\\n        \\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=start+2*i;\\n        }\\n        \\n        int ans=0;\\n        for(int num:nums){\\n            ans ^=num;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221144,
                "title": "faang-interview-answer-optimized-ez-to-understand",
                "content": "**O(n) TC**\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int arr[n] , XOR=0;\\n        for(int i = 0 ; i < n ; i++){\\n            arr[i] = start + 2 * i;\\n            XOR ^= arr[i];\\n        }\\n        return XOR;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int arr[n] , XOR=0;\\n        for(int i = 0 ; i < n ; i++){\\n            arr[i] = start + 2 * i;\\n            XOR ^= arr[i];\\n        }\\n        return XOR;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196579,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ret = start;\\n        for(int i = 1; i<n; i++){\\n            ret ^= start + 2*i;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int ret = start;\\n        for(int i = 1; i<n; i++){\\n            ret ^= start + 2*i;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174143,
                "title": "java-0ms-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int[] num=new int[n];\\n        int res=0;\\n            for(int i=0;i<num.length;i++)\\n            {\\n                num[i]=start+(2 * i);\\n                res^=num[i];\\n            }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int[] num=new int[n];\\n        int res=0;\\n            for(int i=0;i<num.length;i++)\\n            {\\n                num[i]=start+(2 * i);\\n                res^=num[i];\\n            }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154360,
                "title": "xor-operation",
                "content": "\"\\'class Solution {\\n    public int xorOperation(int n, int start) {\\n        int arr[]=new int[n];\\n        int xor=0;\\n        for(int i=0;i<n;i++){\\n            arr[i]=start+2*i;\\n            xor=xor^arr[i];\\n        }return xor;\\n    }\\n}\"\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int xorOperation(int n, int start) {\\n        int arr[]=new int[n];\\n        int xor=0;\\n        for(int i=0;i<n;i++){\\n            arr[i]=start+2*i;\\n            xor=xor^arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2148970,
                "title": "c-recursive-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        if( n == 1)\\n            return start;\\n        \\n        return start ^ xorOperation( --n, start + 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        if( n == 1)\\n            return start;\\n        \\n        return start ^ xorOperation( --n, start + 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145941,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int[] a=new int[n];\\n        int sum=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            a[i]=start;\\n            start=start+2;\\n            sum=sum^a[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int[] a=new int[n];\\n        int sum=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            a[i]=start;\\n            start=start+2;\\n            sum=sum^a[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135844,
                "title": "c-solution-easy-to-understand-solution-with-comments",
                "content": "```class Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans = 0;                       // Initially ans is equal to zero\\n        \\n        for(int i = 0; i < n ; i++)        // Iterate through the loop\\n        {\\n            ans = ans ^ start;             // update ans to ans ^ start\\n            start = start + 2;             // Update the start to start + 2\\n        } \\n        return ans;                        //return ans\\n    }\\n};\\n\\nIf you uderstand this simple solution then please upvote...\\n\\nHappy Learning, Happy Coding....",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans = 0;                       // Initially ans is equal to zero\\n        \\n        for(int i = 0; i < n ; i++)        // Iterate through the loop\\n        {\\n            ans = ans ^ start;             // update ans to ans ^ start\\n            start = start + 2;             // Update the start to start + 2\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2118486,
                "title": "scala-solution",
                "content": "```\\n\\n    def xorOperation(n: Int, start: Int): Int = {\\n           (0 to n-1).map(start+_*2).reduce(_^_)\\n\\n    }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n\\n    def xorOperation(n: Int, start: Int): Int = {\\n           (0 to n-1).map(start+_*2).reduce(_^_)\\n\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2116762,
                "title": "extremely-basic-c-c-solution",
                "content": "int xorOperation(int n, int start){\\n    int xor = start;\\n    for (int i = 1; i < n; i++){\\n        xor ^= (start + 2 * i);\\n    }\\n    return xor;\\n}",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "int xorOperation(int n, int start){\\n    int xor = start;\\n    for (int i = 1; i < n; i++){\\n        xor ^= (start + 2 * i);\\n    }\\n    return xor;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2108949,
                "title": "simple-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans =0;\\n        int i = 0;\\n        while(n)\\n        {\\n            ans = ans ^ (start+(2*i));\\n            i++;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans =0;\\n        int i = 0;\\n        while(n)\\n        {\\n            ans = ans ^ (start+(2*i));\\n            i++;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073737,
                "title": "java-simple-clear-beginner",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        \\n        int[] nums = new int[n];\\n        int output = 0;\\n        \\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            nums[i] = start + 2 * i;\\n            output = output ^ nums[i];\\n        }\\n        \\n        return output;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        \\n        int[] nums = new int[n];\\n        int output = 0;\\n        \\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            nums[i] = start + 2 * i;\\n            output = output ^ nums[i];\\n        }\\n        \\n        return output;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073511,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int nums[] = new int[n];\\n        int xor = 0;\\n        for(int i =0;i<n;i++){\\n            nums[i] = start + 2 * i;\\n            xor ^= nums[i];\\n        }\\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int nums[] = new int[n];\\n        int xor = 0;\\n        for(int i =0;i<n;i++){\\n            nums[i] = start + 2 * i;\\n            xor ^= nums[i];\\n        }\\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048725,
                "title": "fast-python-solution",
                "content": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        new_list = [start + 2 * i for i in range(n)]\\n        output = 0\\n        for i in new_list:\\n            output = output ^ i\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        new_list = [start + 2 * i for i in range(n)]\\n        output = 0\\n        for i in new_list:\\n            output = output ^ i\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960446,
                "title": "without-array-constant-space-linear-time",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int xor = start;\\n        int j = start + 2;\\n            \\n        for (int i = 1; i < n; i++) {\\n            xor ^= j;\\n            j += 2;\\n        }\\n        \\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int xor = start;\\n        int j = start + 2;\\n            \\n        for (int i = 1; i < n; i++) {\\n            xor ^= j;\\n            j += 2;\\n        }\\n        \\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950431,
                "title": "one-line-solution-in-python",
                "content": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        return reduce(lambda x,y:x^y,[start+2*i for i in range(n)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        return reduce(lambda x,y:x^y,[start+2*i for i in range(n)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948270,
                "title": "java-both-solution-o-n-space-and-o-1-space-time-is-o-n",
                "content": "**Solution with create a n size array and space complexity is O(N) Time complexity is O(N)**\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int[] nums = new int[n];\\n        int bitOp = 0;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\tnums[i] = start + 2 * i;\\n            bitOp ^= nums[i];\\n        }\\n        return bitOp;\\n    }\\n}\\n```\\n**Without create any array so space will became O(1) and time is same as previous**\\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int bitOp = 0;\\n        for (int i = 0; i < n; i++) {\\n            bitOp ^= start + 2 * i;\\n        }\\n        return bitOp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int[] nums = new int[n];\\n        int bitOp = 0;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\tnums[i] = start + 2 * i;\\n            bitOp ^= nums[i];\\n        }\\n        return bitOp;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int bitOp = 0;\\n        for (int i = 0; i < n; i++) {\\n            bitOp ^= start + 2 * i;\\n        }\\n        return bitOp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901530,
                "title": "few-lines-of-code-0-ms-faster-than-100-00-of-c-for-xor-operation-in-an-array",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE**\\n```\\nint xorOperation(int n, int start) {\\n        int res = start;\\n\\t\\tfor (int i=1; i<n; i++){\\n\\t\\t\\tres = res ^ (start + 2 * i);\\n\\t\\t\\t}\\n\\t\\treturn res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint xorOperation(int n, int start) {\\n        int res = start;\\n\\t\\tfor (int i=1; i<n; i++){\\n\\t\\t\\tres = res ^ (start + 2 * i);\\n\\t\\t\\t}\\n\\t\\treturn res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1872878,
                "title": "c-bit-manipulation-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans = ans^(start+2*i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans = ans^(start+2*i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855024,
                "title": "c-0-ms-100-00-faster-o-n",
                "content": "The solution is very easy. We need to first create an array of size n and iterate through a loop and store value ```start + 2 * i```, then calculate the xor of all the elements.\\n\\nBut we actually don\\'t need to create an array and first store all values in it and calculate the ```xor```. We can directly solve it by storing the xor value in the ```ans```  variable  and keep on updating it till ```i <  n ```.\\nFinally, you calculate each index value by using bitwise operators ```i << 1``` instead of ```2 * i```.\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for(int i = 0; i < n; ++i) {\\n            ans ^= start + (i << 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you learned something new from my solution :) :) :)",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```start + 2 * i```\n```xor```\n```ans```\n```i <  n ```\n```i << 1```\n```2 * i```\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans = 0;\\n        for(int i = 0; i < n; ++i) {\\n            ans ^= start + (i << 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853781,
                "title": "python-4-diffrent-implimentation-brute-force-time-o-n-space-o-n",
                "content": "It is intuitive to use a list to store all numbers, and use one loop to calculate them.\\nTime O(n) Space O(n)\\n```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        \\n\\t\\t# 1st \\n        # return reduce(lambda x,y: x^y,[ start+2*i for i in range(n)])\\n        \\n        # 2nd\\n        # return eval(\"^\".join([str(start+2*i) for i in range(n)]))\\n        \\n        # 3rd\\n        # return reduce(operator.xor,[start+(2*i) for i in range(n)])\\n        \\n        # 4th     \\n        ans = 0\\n        nums = [start + n * 2 for n in range(n)]\\n        for n in nums:\\n            ans = ans ^ n\\n        return ans \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorOperation(self, n: int, start: int) -> int:\\n        \\n\\t\\t# 1st \\n        # return reduce(lambda x,y: x^y,[ start+2*i for i in range(n)])\\n        \\n        # 2nd\\n        # return eval(\"^\".join([str(start+2*i) for i in range(n)]))\\n        \\n        # 3rd\\n        # return reduce(operator.xor,[start+(2*i) for i in range(n)])\\n        \\n        # 4th     \\n        ans = 0\\n        nums = [start + n * 2 for n in range(n)]\\n        for n in nums:\\n            ans = ans ^ n\\n        return ans \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812655,
                "title": "100-faster-5-line-code-c",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans=0;\\n        int i=0;\\n        while(n--){\\n            ans^=start+i;\\n            i+=2;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int ans=0;\\n        int i=0;\\n        while(n--){\\n            ans^=start+i;\\n            i+=2;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756396,
                "title": "java-easy-100-0ms-faster-solution",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum ^= start + 2 * i;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum ^= start + 2 * i;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742013,
                "title": "xor-operation-in-array-in-c",
                "content": "**Approach:**\\n\\nIn order to find the XOR of all elements in the array, we simply iterate through the array and find the XOR using \\u2018^\\u2019 operator. Therefore, the following steps are followed to compute the answer: \\n \\n\\n* Create a variable to store the XOR of the array as a result.\\n* For each element in the array, find the XOR of the element and the result variable using \\u2018^\\u2019 operator.\\n* Finally, the result variable stores the XOR of all elements in the array.\\n\\nBelow is the implementation of the above approach: \\n```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int nums[n];\\n        int i;\\n        for(i=0;i<n;i++){\\n            nums[i]=start+(2*i);\\n        }\\n        int bitwise=0;\\n        for(i=0;i<n;i++){\\n            bitwise=bitwise^nums[i];\\n        }\\n        return bitwise;\\n    }\\n};\\n```\\n\\n***Time Complexity: O(N), where N is the size of the array.***\\n\\nPlease give an upvote!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int nums[n];\\n        int i;\\n        for(i=0;i<n;i++){\\n            nums[i]=start+(2*i);\\n        }\\n        int bitwise=0;\\n        for(i=0;i<n;i++){\\n            bitwise=bitwise^nums[i];\\n        }\\n        return bitwise;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726764,
                "title": "5-line-code-100-fast",
                "content": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int xOR = 0;\\n        for (int i = 0 ; i < n; i++){\\n            int x = start + (2*i);\\n            xOR ^= x;\\n        }\\n        return xOR;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int xOR = 0;\\n        for (int i = 0 ; i < n; i++){\\n            int x = start + (2*i);\\n            xOR ^= x;\\n        }\\n        return xOR;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720788,
                "title": "c-4-lines-0ms-faster-than-100-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int res=0;\\n        for(int i = 0; i< n; i++){\\n            res ^= start + 2*i;\\n        }\\n        return res;\\n    }\\n};\\n```\\nif it helps, please upvote :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int res=0;\\n        for(int i = 0; i< n; i++){\\n            res ^= start + 2*i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632989,
                "title": "0ms-100-faster-java-submission-no-array-needed",
                "content": "int result = 0;\\n    \\n    for(int i = 0; i < n ; i++)\\n    {\\n        result^= start + 2*i; \\n    }\\n     return result;\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "int result = 0;\\n    \\n    for(int i = 0; i < n ; i++)\\n    {\\n        result^= start + 2*i; \\n    }\\n     return result;\\n}",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1754074,
                "content": [
                    {
                        "username": "Gurdeep_Singh_3251",
                        "content": "in this type of problem you don\\'t even need to create an array\\nyou just need to start a loop and store the start + 2*i in a variable and simultaneously xor with answer"
                    },
                    {
                        "username": "whatabrain",
                        "content": "I spent a while trying to figure out whether the result had any predictable properties based on the input, so that output could be calculated with a single mathematical equasion (or two, separating even and odd values of `start`), but I couldn\\'t figure it out. Has anyone else?"
                    },
                    {
                        "username": "crosslives",
                        "content": "x xor (x + 2) = 111...11110 with base 2, number of \\'1\\' equals to the index of last \\'0\\' (execpt index 0).\\nFor example,\\n0110 (6) xor 1000 (8) = 1110\\n1100(12) xor 1110(14) = 10\\n110111110(446) xor 111000000(448) = 1111110\\n\\nNow we just need to care about the index of last \\'0\\' in each of list (start, start + 4, start + 8, start + 12, ...)\\nLets call x xor (x+2) Opration A\\nWhat we need to do is just to figure out how many element in above list after Operation A have same result. It\\'s a math problem.\\n\\nFor example, start = 4, n = 1000,  find number of elemets whose result are 11110 (30) after operatin A.\\n11110 means that (start + 4 * i) mod (10000) = (1111) or (1110)\\nTherefore, we need to find i that (4 + 4 * i) mod 16 = 15 or 14. when 1000> i >= 0. To solev this we need find first i that satisfy this condition, then i, i + 4, i + 8, i + 12... satisfy this condition. \\n(4 + 4 * i) mod 16 cannot be 15 so lets only consider 14.\\nTo find first \\'i\\', we need to change of above equation:\\n(4 + 4 * i) mod 16 = 14 -> (4 * i) mod 16 = 10 -> (16x +10) = 4i -> (8x + 5) = 2i -> no answer for i obviously in this case. But, generally here we can use Extended Euclidean algorithm to find i.\\n\\nAnyway, now we know how many elements after operation A is 10, 110, 1110, 11110, 111110,....\\nAccording to property of XOR, if number of elements is even, XOR result of these elements is 0. Otherwise is exact 111..110.\\n\\nAt last we xor them together and get the answer.\\n\\nConsidering number of 1 is less than log(N), and to find # of elements after operation A is a specfic result 11...10 cost constant, total time complexity is O(log(N)).\\n\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AdityaBhate](/AdityaBhate) You responded to an O(logn) time, O(1) space brilliant math answer with an O(n) O(n) simple answer. Please do not spam your own solutions. Sharing is great, but this person put a lot of effort into explaining a much better answer than what you\\'ve posted. Consider trying to learn from what they\\'ve posted rather than blasting your own solution. In no way is your answer optimized by the way.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    },
                    {
                        "username": "nikhilgargdrb",
                        "content": "//Simple Solution is :\\n\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int i=0;\\n        int ans=0;\\n\\n        for(int j=0;j<n;j++)\\n       {\\n        ans=ans^(start+(2*i));\\n        i++;\\n\\n        }\\nreturn ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "O(n) shall not pass the interview."
                    },
                    {
                        "username": "Shiv_45",
                        "content": "can you suggest with less than O(N) TC.\\n"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "1.no need to create an array\\n2.declare result =0; \\n3.just iterate from 0 to n using the for loop \\n4.perform xor operration with given num[i]=start+2*i;\\n5.return the answer"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/xor-operation-in-an-array/solutions/3191636/javascript-linear-time-const-space-2-solution-reduce-fn/\\n\\nLinear Time and Space Efficient "
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " int xorOperation(int n, int start) {\\n      int res =0;\\n      for(int i=0;i<n;i++)\\n      {\\n          int temp = start + 2*i;\\n          res^=temp;\\n      }\\n      return res;\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    }
                ]
            },
            {
                "id": 1574191,
                "content": [
                    {
                        "username": "Gurdeep_Singh_3251",
                        "content": "in this type of problem you don\\'t even need to create an array\\nyou just need to start a loop and store the start + 2*i in a variable and simultaneously xor with answer"
                    },
                    {
                        "username": "whatabrain",
                        "content": "I spent a while trying to figure out whether the result had any predictable properties based on the input, so that output could be calculated with a single mathematical equasion (or two, separating even and odd values of `start`), but I couldn\\'t figure it out. Has anyone else?"
                    },
                    {
                        "username": "crosslives",
                        "content": "x xor (x + 2) = 111...11110 with base 2, number of \\'1\\' equals to the index of last \\'0\\' (execpt index 0).\\nFor example,\\n0110 (6) xor 1000 (8) = 1110\\n1100(12) xor 1110(14) = 10\\n110111110(446) xor 111000000(448) = 1111110\\n\\nNow we just need to care about the index of last \\'0\\' in each of list (start, start + 4, start + 8, start + 12, ...)\\nLets call x xor (x+2) Opration A\\nWhat we need to do is just to figure out how many element in above list after Operation A have same result. It\\'s a math problem.\\n\\nFor example, start = 4, n = 1000,  find number of elemets whose result are 11110 (30) after operatin A.\\n11110 means that (start + 4 * i) mod (10000) = (1111) or (1110)\\nTherefore, we need to find i that (4 + 4 * i) mod 16 = 15 or 14. when 1000> i >= 0. To solev this we need find first i that satisfy this condition, then i, i + 4, i + 8, i + 12... satisfy this condition. \\n(4 + 4 * i) mod 16 cannot be 15 so lets only consider 14.\\nTo find first \\'i\\', we need to change of above equation:\\n(4 + 4 * i) mod 16 = 14 -> (4 * i) mod 16 = 10 -> (16x +10) = 4i -> (8x + 5) = 2i -> no answer for i obviously in this case. But, generally here we can use Extended Euclidean algorithm to find i.\\n\\nAnyway, now we know how many elements after operation A is 10, 110, 1110, 11110, 111110,....\\nAccording to property of XOR, if number of elements is even, XOR result of these elements is 0. Otherwise is exact 111..110.\\n\\nAt last we xor them together and get the answer.\\n\\nConsidering number of 1 is less than log(N), and to find # of elements after operation A is a specfic result 11...10 cost constant, total time complexity is O(log(N)).\\n\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AdityaBhate](/AdityaBhate) You responded to an O(logn) time, O(1) space brilliant math answer with an O(n) O(n) simple answer. Please do not spam your own solutions. Sharing is great, but this person put a lot of effort into explaining a much better answer than what you\\'ve posted. Consider trying to learn from what they\\'ve posted rather than blasting your own solution. In no way is your answer optimized by the way.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    },
                    {
                        "username": "nikhilgargdrb",
                        "content": "//Simple Solution is :\\n\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int i=0;\\n        int ans=0;\\n\\n        for(int j=0;j<n;j++)\\n       {\\n        ans=ans^(start+(2*i));\\n        i++;\\n\\n        }\\nreturn ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "O(n) shall not pass the interview."
                    },
                    {
                        "username": "Shiv_45",
                        "content": "can you suggest with less than O(N) TC.\\n"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "1.no need to create an array\\n2.declare result =0; \\n3.just iterate from 0 to n using the for loop \\n4.perform xor operration with given num[i]=start+2*i;\\n5.return the answer"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/xor-operation-in-an-array/solutions/3191636/javascript-linear-time-const-space-2-solution-reduce-fn/\\n\\nLinear Time and Space Efficient "
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " int xorOperation(int n, int start) {\\n      int res =0;\\n      for(int i=0;i<n;i++)\\n      {\\n          int temp = start + 2*i;\\n          res^=temp;\\n      }\\n      return res;\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    }
                ]
            },
            {
                "id": 1568360,
                "content": [
                    {
                        "username": "Gurdeep_Singh_3251",
                        "content": "in this type of problem you don\\'t even need to create an array\\nyou just need to start a loop and store the start + 2*i in a variable and simultaneously xor with answer"
                    },
                    {
                        "username": "whatabrain",
                        "content": "I spent a while trying to figure out whether the result had any predictable properties based on the input, so that output could be calculated with a single mathematical equasion (or two, separating even and odd values of `start`), but I couldn\\'t figure it out. Has anyone else?"
                    },
                    {
                        "username": "crosslives",
                        "content": "x xor (x + 2) = 111...11110 with base 2, number of \\'1\\' equals to the index of last \\'0\\' (execpt index 0).\\nFor example,\\n0110 (6) xor 1000 (8) = 1110\\n1100(12) xor 1110(14) = 10\\n110111110(446) xor 111000000(448) = 1111110\\n\\nNow we just need to care about the index of last \\'0\\' in each of list (start, start + 4, start + 8, start + 12, ...)\\nLets call x xor (x+2) Opration A\\nWhat we need to do is just to figure out how many element in above list after Operation A have same result. It\\'s a math problem.\\n\\nFor example, start = 4, n = 1000,  find number of elemets whose result are 11110 (30) after operatin A.\\n11110 means that (start + 4 * i) mod (10000) = (1111) or (1110)\\nTherefore, we need to find i that (4 + 4 * i) mod 16 = 15 or 14. when 1000> i >= 0. To solev this we need find first i that satisfy this condition, then i, i + 4, i + 8, i + 12... satisfy this condition. \\n(4 + 4 * i) mod 16 cannot be 15 so lets only consider 14.\\nTo find first \\'i\\', we need to change of above equation:\\n(4 + 4 * i) mod 16 = 14 -> (4 * i) mod 16 = 10 -> (16x +10) = 4i -> (8x + 5) = 2i -> no answer for i obviously in this case. But, generally here we can use Extended Euclidean algorithm to find i.\\n\\nAnyway, now we know how many elements after operation A is 10, 110, 1110, 11110, 111110,....\\nAccording to property of XOR, if number of elements is even, XOR result of these elements is 0. Otherwise is exact 111..110.\\n\\nAt last we xor them together and get the answer.\\n\\nConsidering number of 1 is less than log(N), and to find # of elements after operation A is a specfic result 11...10 cost constant, total time complexity is O(log(N)).\\n\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AdityaBhate](/AdityaBhate) You responded to an O(logn) time, O(1) space brilliant math answer with an O(n) O(n) simple answer. Please do not spam your own solutions. Sharing is great, but this person put a lot of effort into explaining a much better answer than what you\\'ve posted. Consider trying to learn from what they\\'ve posted rather than blasting your own solution. In no way is your answer optimized by the way.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    },
                    {
                        "username": "nikhilgargdrb",
                        "content": "//Simple Solution is :\\n\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int i=0;\\n        int ans=0;\\n\\n        for(int j=0;j<n;j++)\\n       {\\n        ans=ans^(start+(2*i));\\n        i++;\\n\\n        }\\nreturn ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "O(n) shall not pass the interview."
                    },
                    {
                        "username": "Shiv_45",
                        "content": "can you suggest with less than O(N) TC.\\n"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "1.no need to create an array\\n2.declare result =0; \\n3.just iterate from 0 to n using the for loop \\n4.perform xor operration with given num[i]=start+2*i;\\n5.return the answer"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/xor-operation-in-an-array/solutions/3191636/javascript-linear-time-const-space-2-solution-reduce-fn/\\n\\nLinear Time and Space Efficient "
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " int xorOperation(int n, int start) {\\n      int res =0;\\n      for(int i=0;i<n;i++)\\n      {\\n          int temp = start + 2*i;\\n          res^=temp;\\n      }\\n      return res;\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    }
                ]
            },
            {
                "id": 1714363,
                "content": [
                    {
                        "username": "Gurdeep_Singh_3251",
                        "content": "in this type of problem you don\\'t even need to create an array\\nyou just need to start a loop and store the start + 2*i in a variable and simultaneously xor with answer"
                    },
                    {
                        "username": "whatabrain",
                        "content": "I spent a while trying to figure out whether the result had any predictable properties based on the input, so that output could be calculated with a single mathematical equasion (or two, separating even and odd values of `start`), but I couldn\\'t figure it out. Has anyone else?"
                    },
                    {
                        "username": "crosslives",
                        "content": "x xor (x + 2) = 111...11110 with base 2, number of \\'1\\' equals to the index of last \\'0\\' (execpt index 0).\\nFor example,\\n0110 (6) xor 1000 (8) = 1110\\n1100(12) xor 1110(14) = 10\\n110111110(446) xor 111000000(448) = 1111110\\n\\nNow we just need to care about the index of last \\'0\\' in each of list (start, start + 4, start + 8, start + 12, ...)\\nLets call x xor (x+2) Opration A\\nWhat we need to do is just to figure out how many element in above list after Operation A have same result. It\\'s a math problem.\\n\\nFor example, start = 4, n = 1000,  find number of elemets whose result are 11110 (30) after operatin A.\\n11110 means that (start + 4 * i) mod (10000) = (1111) or (1110)\\nTherefore, we need to find i that (4 + 4 * i) mod 16 = 15 or 14. when 1000> i >= 0. To solev this we need find first i that satisfy this condition, then i, i + 4, i + 8, i + 12... satisfy this condition. \\n(4 + 4 * i) mod 16 cannot be 15 so lets only consider 14.\\nTo find first \\'i\\', we need to change of above equation:\\n(4 + 4 * i) mod 16 = 14 -> (4 * i) mod 16 = 10 -> (16x +10) = 4i -> (8x + 5) = 2i -> no answer for i obviously in this case. But, generally here we can use Extended Euclidean algorithm to find i.\\n\\nAnyway, now we know how many elements after operation A is 10, 110, 1110, 11110, 111110,....\\nAccording to property of XOR, if number of elements is even, XOR result of these elements is 0. Otherwise is exact 111..110.\\n\\nAt last we xor them together and get the answer.\\n\\nConsidering number of 1 is less than log(N), and to find # of elements after operation A is a specfic result 11...10 cost constant, total time complexity is O(log(N)).\\n\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AdityaBhate](/AdityaBhate) You responded to an O(logn) time, O(1) space brilliant math answer with an O(n) O(n) simple answer. Please do not spam your own solutions. Sharing is great, but this person put a lot of effort into explaining a much better answer than what you\\'ve posted. Consider trying to learn from what they\\'ve posted rather than blasting your own solution. In no way is your answer optimized by the way.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    },
                    {
                        "username": "nikhilgargdrb",
                        "content": "//Simple Solution is :\\n\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int i=0;\\n        int ans=0;\\n\\n        for(int j=0;j<n;j++)\\n       {\\n        ans=ans^(start+(2*i));\\n        i++;\\n\\n        }\\nreturn ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "O(n) shall not pass the interview."
                    },
                    {
                        "username": "Shiv_45",
                        "content": "can you suggest with less than O(N) TC.\\n"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "1.no need to create an array\\n2.declare result =0; \\n3.just iterate from 0 to n using the for loop \\n4.perform xor operration with given num[i]=start+2*i;\\n5.return the answer"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/xor-operation-in-an-array/solutions/3191636/javascript-linear-time-const-space-2-solution-reduce-fn/\\n\\nLinear Time and Space Efficient "
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " int xorOperation(int n, int start) {\\n      int res =0;\\n      for(int i=0;i<n;i++)\\n      {\\n          int temp = start + 2*i;\\n          res^=temp;\\n      }\\n      return res;\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    }
                ]
            },
            {
                "id": 1573951,
                "content": [
                    {
                        "username": "Gurdeep_Singh_3251",
                        "content": "in this type of problem you don\\'t even need to create an array\\nyou just need to start a loop and store the start + 2*i in a variable and simultaneously xor with answer"
                    },
                    {
                        "username": "whatabrain",
                        "content": "I spent a while trying to figure out whether the result had any predictable properties based on the input, so that output could be calculated with a single mathematical equasion (or two, separating even and odd values of `start`), but I couldn\\'t figure it out. Has anyone else?"
                    },
                    {
                        "username": "crosslives",
                        "content": "x xor (x + 2) = 111...11110 with base 2, number of \\'1\\' equals to the index of last \\'0\\' (execpt index 0).\\nFor example,\\n0110 (6) xor 1000 (8) = 1110\\n1100(12) xor 1110(14) = 10\\n110111110(446) xor 111000000(448) = 1111110\\n\\nNow we just need to care about the index of last \\'0\\' in each of list (start, start + 4, start + 8, start + 12, ...)\\nLets call x xor (x+2) Opration A\\nWhat we need to do is just to figure out how many element in above list after Operation A have same result. It\\'s a math problem.\\n\\nFor example, start = 4, n = 1000,  find number of elemets whose result are 11110 (30) after operatin A.\\n11110 means that (start + 4 * i) mod (10000) = (1111) or (1110)\\nTherefore, we need to find i that (4 + 4 * i) mod 16 = 15 or 14. when 1000> i >= 0. To solev this we need find first i that satisfy this condition, then i, i + 4, i + 8, i + 12... satisfy this condition. \\n(4 + 4 * i) mod 16 cannot be 15 so lets only consider 14.\\nTo find first \\'i\\', we need to change of above equation:\\n(4 + 4 * i) mod 16 = 14 -> (4 * i) mod 16 = 10 -> (16x +10) = 4i -> (8x + 5) = 2i -> no answer for i obviously in this case. But, generally here we can use Extended Euclidean algorithm to find i.\\n\\nAnyway, now we know how many elements after operation A is 10, 110, 1110, 11110, 111110,....\\nAccording to property of XOR, if number of elements is even, XOR result of these elements is 0. Otherwise is exact 111..110.\\n\\nAt last we xor them together and get the answer.\\n\\nConsidering number of 1 is less than log(N), and to find # of elements after operation A is a specfic result 11...10 cost constant, total time complexity is O(log(N)).\\n\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AdityaBhate](/AdityaBhate) You responded to an O(logn) time, O(1) space brilliant math answer with an O(n) O(n) simple answer. Please do not spam your own solutions. Sharing is great, but this person put a lot of effort into explaining a much better answer than what you\\'ve posted. Consider trying to learn from what they\\'ve posted rather than blasting your own solution. In no way is your answer optimized by the way.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    },
                    {
                        "username": "nikhilgargdrb",
                        "content": "//Simple Solution is :\\n\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int i=0;\\n        int ans=0;\\n\\n        for(int j=0;j<n;j++)\\n       {\\n        ans=ans^(start+(2*i));\\n        i++;\\n\\n        }\\nreturn ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "O(n) shall not pass the interview."
                    },
                    {
                        "username": "Shiv_45",
                        "content": "can you suggest with less than O(N) TC.\\n"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "1.no need to create an array\\n2.declare result =0; \\n3.just iterate from 0 to n using the for loop \\n4.perform xor operration with given num[i]=start+2*i;\\n5.return the answer"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/xor-operation-in-an-array/solutions/3191636/javascript-linear-time-const-space-2-solution-reduce-fn/\\n\\nLinear Time and Space Efficient "
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " int xorOperation(int n, int start) {\\n      int res =0;\\n      for(int i=0;i<n;i++)\\n      {\\n          int temp = start + 2*i;\\n          res^=temp;\\n      }\\n      return res;\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    }
                ]
            },
            {
                "id": 2051672,
                "content": [
                    {
                        "username": "Gurdeep_Singh_3251",
                        "content": "in this type of problem you don\\'t even need to create an array\\nyou just need to start a loop and store the start + 2*i in a variable and simultaneously xor with answer"
                    },
                    {
                        "username": "whatabrain",
                        "content": "I spent a while trying to figure out whether the result had any predictable properties based on the input, so that output could be calculated with a single mathematical equasion (or two, separating even and odd values of `start`), but I couldn\\'t figure it out. Has anyone else?"
                    },
                    {
                        "username": "crosslives",
                        "content": "x xor (x + 2) = 111...11110 with base 2, number of \\'1\\' equals to the index of last \\'0\\' (execpt index 0).\\nFor example,\\n0110 (6) xor 1000 (8) = 1110\\n1100(12) xor 1110(14) = 10\\n110111110(446) xor 111000000(448) = 1111110\\n\\nNow we just need to care about the index of last \\'0\\' in each of list (start, start + 4, start + 8, start + 12, ...)\\nLets call x xor (x+2) Opration A\\nWhat we need to do is just to figure out how many element in above list after Operation A have same result. It\\'s a math problem.\\n\\nFor example, start = 4, n = 1000,  find number of elemets whose result are 11110 (30) after operatin A.\\n11110 means that (start + 4 * i) mod (10000) = (1111) or (1110)\\nTherefore, we need to find i that (4 + 4 * i) mod 16 = 15 or 14. when 1000> i >= 0. To solev this we need find first i that satisfy this condition, then i, i + 4, i + 8, i + 12... satisfy this condition. \\n(4 + 4 * i) mod 16 cannot be 15 so lets only consider 14.\\nTo find first \\'i\\', we need to change of above equation:\\n(4 + 4 * i) mod 16 = 14 -> (4 * i) mod 16 = 10 -> (16x +10) = 4i -> (8x + 5) = 2i -> no answer for i obviously in this case. But, generally here we can use Extended Euclidean algorithm to find i.\\n\\nAnyway, now we know how many elements after operation A is 10, 110, 1110, 11110, 111110,....\\nAccording to property of XOR, if number of elements is even, XOR result of these elements is 0. Otherwise is exact 111..110.\\n\\nAt last we xor them together and get the answer.\\n\\nConsidering number of 1 is less than log(N), and to find # of elements after operation A is a specfic result 11...10 cost constant, total time complexity is O(log(N)).\\n\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AdityaBhate](/AdityaBhate) You responded to an O(logn) time, O(1) space brilliant math answer with an O(n) O(n) simple answer. Please do not spam your own solutions. Sharing is great, but this person put a lot of effort into explaining a much better answer than what you\\'ve posted. Consider trying to learn from what they\\'ve posted rather than blasting your own solution. In no way is your answer optimized by the way.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    },
                    {
                        "username": "nikhilgargdrb",
                        "content": "//Simple Solution is :\\n\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int i=0;\\n        int ans=0;\\n\\n        for(int j=0;j<n;j++)\\n       {\\n        ans=ans^(start+(2*i));\\n        i++;\\n\\n        }\\nreturn ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "O(n) shall not pass the interview."
                    },
                    {
                        "username": "Shiv_45",
                        "content": "can you suggest with less than O(N) TC.\\n"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "1.no need to create an array\\n2.declare result =0; \\n3.just iterate from 0 to n using the for loop \\n4.perform xor operration with given num[i]=start+2*i;\\n5.return the answer"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/xor-operation-in-an-array/solutions/3191636/javascript-linear-time-const-space-2-solution-reduce-fn/\\n\\nLinear Time and Space Efficient "
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " int xorOperation(int n, int start) {\\n      int res =0;\\n      for(int i=0;i<n;i++)\\n      {\\n          int temp = start + 2*i;\\n          res^=temp;\\n      }\\n      return res;\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    }
                ]
            },
            {
                "id": 1802896,
                "content": [
                    {
                        "username": "Gurdeep_Singh_3251",
                        "content": "in this type of problem you don\\'t even need to create an array\\nyou just need to start a loop and store the start + 2*i in a variable and simultaneously xor with answer"
                    },
                    {
                        "username": "whatabrain",
                        "content": "I spent a while trying to figure out whether the result had any predictable properties based on the input, so that output could be calculated with a single mathematical equasion (or two, separating even and odd values of `start`), but I couldn\\'t figure it out. Has anyone else?"
                    },
                    {
                        "username": "crosslives",
                        "content": "x xor (x + 2) = 111...11110 with base 2, number of \\'1\\' equals to the index of last \\'0\\' (execpt index 0).\\nFor example,\\n0110 (6) xor 1000 (8) = 1110\\n1100(12) xor 1110(14) = 10\\n110111110(446) xor 111000000(448) = 1111110\\n\\nNow we just need to care about the index of last \\'0\\' in each of list (start, start + 4, start + 8, start + 12, ...)\\nLets call x xor (x+2) Opration A\\nWhat we need to do is just to figure out how many element in above list after Operation A have same result. It\\'s a math problem.\\n\\nFor example, start = 4, n = 1000,  find number of elemets whose result are 11110 (30) after operatin A.\\n11110 means that (start + 4 * i) mod (10000) = (1111) or (1110)\\nTherefore, we need to find i that (4 + 4 * i) mod 16 = 15 or 14. when 1000> i >= 0. To solev this we need find first i that satisfy this condition, then i, i + 4, i + 8, i + 12... satisfy this condition. \\n(4 + 4 * i) mod 16 cannot be 15 so lets only consider 14.\\nTo find first \\'i\\', we need to change of above equation:\\n(4 + 4 * i) mod 16 = 14 -> (4 * i) mod 16 = 10 -> (16x +10) = 4i -> (8x + 5) = 2i -> no answer for i obviously in this case. But, generally here we can use Extended Euclidean algorithm to find i.\\n\\nAnyway, now we know how many elements after operation A is 10, 110, 1110, 11110, 111110,....\\nAccording to property of XOR, if number of elements is even, XOR result of these elements is 0. Otherwise is exact 111..110.\\n\\nAt last we xor them together and get the answer.\\n\\nConsidering number of 1 is less than log(N), and to find # of elements after operation A is a specfic result 11...10 cost constant, total time complexity is O(log(N)).\\n\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AdityaBhate](/AdityaBhate) You responded to an O(logn) time, O(1) space brilliant math answer with an O(n) O(n) simple answer. Please do not spam your own solutions. Sharing is great, but this person put a lot of effort into explaining a much better answer than what you\\'ve posted. Consider trying to learn from what they\\'ve posted rather than blasting your own solution. In no way is your answer optimized by the way.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    },
                    {
                        "username": "nikhilgargdrb",
                        "content": "//Simple Solution is :\\n\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int i=0;\\n        int ans=0;\\n\\n        for(int j=0;j<n;j++)\\n       {\\n        ans=ans^(start+(2*i));\\n        i++;\\n\\n        }\\nreturn ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "O(n) shall not pass the interview."
                    },
                    {
                        "username": "Shiv_45",
                        "content": "can you suggest with less than O(N) TC.\\n"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "1.no need to create an array\\n2.declare result =0; \\n3.just iterate from 0 to n using the for loop \\n4.perform xor operration with given num[i]=start+2*i;\\n5.return the answer"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/xor-operation-in-an-array/solutions/3191636/javascript-linear-time-const-space-2-solution-reduce-fn/\\n\\nLinear Time and Space Efficient "
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " int xorOperation(int n, int start) {\\n      int res =0;\\n      for(int i=0;i<n;i++)\\n      {\\n          int temp = start + 2*i;\\n          res^=temp;\\n      }\\n      return res;\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    }
                ]
            },
            {
                "id": 1764486,
                "content": [
                    {
                        "username": "Gurdeep_Singh_3251",
                        "content": "in this type of problem you don\\'t even need to create an array\\nyou just need to start a loop and store the start + 2*i in a variable and simultaneously xor with answer"
                    },
                    {
                        "username": "whatabrain",
                        "content": "I spent a while trying to figure out whether the result had any predictable properties based on the input, so that output could be calculated with a single mathematical equasion (or two, separating even and odd values of `start`), but I couldn\\'t figure it out. Has anyone else?"
                    },
                    {
                        "username": "crosslives",
                        "content": "x xor (x + 2) = 111...11110 with base 2, number of \\'1\\' equals to the index of last \\'0\\' (execpt index 0).\\nFor example,\\n0110 (6) xor 1000 (8) = 1110\\n1100(12) xor 1110(14) = 10\\n110111110(446) xor 111000000(448) = 1111110\\n\\nNow we just need to care about the index of last \\'0\\' in each of list (start, start + 4, start + 8, start + 12, ...)\\nLets call x xor (x+2) Opration A\\nWhat we need to do is just to figure out how many element in above list after Operation A have same result. It\\'s a math problem.\\n\\nFor example, start = 4, n = 1000,  find number of elemets whose result are 11110 (30) after operatin A.\\n11110 means that (start + 4 * i) mod (10000) = (1111) or (1110)\\nTherefore, we need to find i that (4 + 4 * i) mod 16 = 15 or 14. when 1000> i >= 0. To solev this we need find first i that satisfy this condition, then i, i + 4, i + 8, i + 12... satisfy this condition. \\n(4 + 4 * i) mod 16 cannot be 15 so lets only consider 14.\\nTo find first \\'i\\', we need to change of above equation:\\n(4 + 4 * i) mod 16 = 14 -> (4 * i) mod 16 = 10 -> (16x +10) = 4i -> (8x + 5) = 2i -> no answer for i obviously in this case. But, generally here we can use Extended Euclidean algorithm to find i.\\n\\nAnyway, now we know how many elements after operation A is 10, 110, 1110, 11110, 111110,....\\nAccording to property of XOR, if number of elements is even, XOR result of these elements is 0. Otherwise is exact 111..110.\\n\\nAt last we xor them together and get the answer.\\n\\nConsidering number of 1 is less than log(N), and to find # of elements after operation A is a specfic result 11...10 cost constant, total time complexity is O(log(N)).\\n\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AdityaBhate](/AdityaBhate) You responded to an O(logn) time, O(1) space brilliant math answer with an O(n) O(n) simple answer. Please do not spam your own solutions. Sharing is great, but this person put a lot of effort into explaining a much better answer than what you\\'ve posted. Consider trying to learn from what they\\'ve posted rather than blasting your own solution. In no way is your answer optimized by the way.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    },
                    {
                        "username": "nikhilgargdrb",
                        "content": "//Simple Solution is :\\n\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int i=0;\\n        int ans=0;\\n\\n        for(int j=0;j<n;j++)\\n       {\\n        ans=ans^(start+(2*i));\\n        i++;\\n\\n        }\\nreturn ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "O(n) shall not pass the interview."
                    },
                    {
                        "username": "Shiv_45",
                        "content": "can you suggest with less than O(N) TC.\\n"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "1.no need to create an array\\n2.declare result =0; \\n3.just iterate from 0 to n using the for loop \\n4.perform xor operration with given num[i]=start+2*i;\\n5.return the answer"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/xor-operation-in-an-array/solutions/3191636/javascript-linear-time-const-space-2-solution-reduce-fn/\\n\\nLinear Time and Space Efficient "
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " int xorOperation(int n, int start) {\\n      int res =0;\\n      for(int i=0;i<n;i++)\\n      {\\n          int temp = start + 2*i;\\n          res^=temp;\\n      }\\n      return res;\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    }
                ]
            },
            {
                "id": 1680309,
                "content": [
                    {
                        "username": "Gurdeep_Singh_3251",
                        "content": "in this type of problem you don\\'t even need to create an array\\nyou just need to start a loop and store the start + 2*i in a variable and simultaneously xor with answer"
                    },
                    {
                        "username": "whatabrain",
                        "content": "I spent a while trying to figure out whether the result had any predictable properties based on the input, so that output could be calculated with a single mathematical equasion (or two, separating even and odd values of `start`), but I couldn\\'t figure it out. Has anyone else?"
                    },
                    {
                        "username": "crosslives",
                        "content": "x xor (x + 2) = 111...11110 with base 2, number of \\'1\\' equals to the index of last \\'0\\' (execpt index 0).\\nFor example,\\n0110 (6) xor 1000 (8) = 1110\\n1100(12) xor 1110(14) = 10\\n110111110(446) xor 111000000(448) = 1111110\\n\\nNow we just need to care about the index of last \\'0\\' in each of list (start, start + 4, start + 8, start + 12, ...)\\nLets call x xor (x+2) Opration A\\nWhat we need to do is just to figure out how many element in above list after Operation A have same result. It\\'s a math problem.\\n\\nFor example, start = 4, n = 1000,  find number of elemets whose result are 11110 (30) after operatin A.\\n11110 means that (start + 4 * i) mod (10000) = (1111) or (1110)\\nTherefore, we need to find i that (4 + 4 * i) mod 16 = 15 or 14. when 1000> i >= 0. To solev this we need find first i that satisfy this condition, then i, i + 4, i + 8, i + 12... satisfy this condition. \\n(4 + 4 * i) mod 16 cannot be 15 so lets only consider 14.\\nTo find first \\'i\\', we need to change of above equation:\\n(4 + 4 * i) mod 16 = 14 -> (4 * i) mod 16 = 10 -> (16x +10) = 4i -> (8x + 5) = 2i -> no answer for i obviously in this case. But, generally here we can use Extended Euclidean algorithm to find i.\\n\\nAnyway, now we know how many elements after operation A is 10, 110, 1110, 11110, 111110,....\\nAccording to property of XOR, if number of elements is even, XOR result of these elements is 0. Otherwise is exact 111..110.\\n\\nAt last we xor them together and get the answer.\\n\\nConsidering number of 1 is less than log(N), and to find # of elements after operation A is a specfic result 11...10 cost constant, total time complexity is O(log(N)).\\n\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@AdityaBhate](/AdityaBhate) You responded to an O(logn) time, O(1) space brilliant math answer with an O(n) O(n) simple answer. Please do not spam your own solutions. Sharing is great, but this person put a lot of effort into explaining a much better answer than what you\\'ve posted. Consider trying to learn from what they\\'ve posted rather than blasting your own solution. In no way is your answer optimized by the way.  "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    },
                    {
                        "username": "nikhilgargdrb",
                        "content": "//Simple Solution is :\\n\\nclass Solution {\\n    public int xorOperation(int n, int start) {\\n        int i=0;\\n        int ans=0;\\n\\n        for(int j=0;j<n;j++)\\n       {\\n        ans=ans^(start+(2*i));\\n        i++;\\n\\n        }\\nreturn ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "SleepyFarmer",
                        "content": "O(n) shall not pass the interview."
                    },
                    {
                        "username": "Shiv_45",
                        "content": "can you suggest with less than O(N) TC.\\n"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "1.no need to create an array\\n2.declare result =0; \\n3.just iterate from 0 to n using the for loop \\n4.perform xor operration with given num[i]=start+2*i;\\n5.return the answer"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/xor-operation-in-an-array/solutions/3191636/javascript-linear-time-const-space-2-solution-reduce-fn/\\n\\nLinear Time and Space Efficient "
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " int xorOperation(int n, int start) {\\n      int res =0;\\n      for(int i=0;i<n;i++)\\n      {\\n          int temp = start + 2*i;\\n          res^=temp;\\n      }\\n      return res;\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG\\uD83D\\uDCA5 Interview Answer | Optimized | ez to understand\\nhttps://leetcode.com/problems/xor-operation-in-an-array/solutions/2221144/faang-interview-answer-optimized-ez-to-understand/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Making File Names Unique",
        "question_content": "<p>Given an array of strings <code>names</code> of size <code>n</code>. You will create <code>n</code> folders in your file system <strong>such that</strong>, at the <code>i<sup>th</sup></code> minute, you will create a folder with the name <code>names[i]</code>.</p>\n\n<p>Since two files <strong>cannot</strong> have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of <code>(k)</code>, where, <code>k</code> is the <strong>smallest positive integer</strong> such that the obtained name remains unique.</p>\n\n<p>Return <em>an array of strings of length </em><code>n</code> where <code>ans[i]</code> is the actual name the system will assign to the <code>i<sup>th</sup></code> folder when you create it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> names = [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]\n<strong>Output:</strong> [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]\n<strong>Explanation:</strong> Let&#39;s see how the file system creates folder names:\n&quot;pes&quot; --&gt; not assigned before, remains &quot;pes&quot;\n&quot;fifa&quot; --&gt; not assigned before, remains &quot;fifa&quot;\n&quot;gta&quot; --&gt; not assigned before, remains &quot;gta&quot;\n&quot;pes(2019)&quot; --&gt; not assigned before, remains &quot;pes(2019)&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> names = [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta&quot;,&quot;avalon&quot;]\n<strong>Output:</strong> [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta(2)&quot;,&quot;avalon&quot;]\n<strong>Explanation:</strong> Let&#39;s see how the file system creates folder names:\n&quot;gta&quot; --&gt; not assigned before, remains &quot;gta&quot;\n&quot;gta(1)&quot; --&gt; not assigned before, remains &quot;gta(1)&quot;\n&quot;gta&quot; --&gt; the name is reserved, system adds (k), since &quot;gta(1)&quot; is also reserved, systems put k = 2. it becomes &quot;gta(2)&quot;\n&quot;avalon&quot; --&gt; not assigned before, remains &quot;avalon&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> names = [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece&quot;]\n<strong>Output:</strong> [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece(4)&quot;]\n<strong>Explanation:</strong> When the last folder is created, the smallest positive valid k is 4, and it becomes &quot;onepiece(4)&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= names.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= names[i].length &lt;= 20</code></li>\n\t<li><code>names[i]</code> consists of lowercase English letters, digits, and/or round brackets.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 697689,
                "title": "java-using-hashmap",
                "content": "\\t   public String[] getFolderNames(String[] names) {\\n\\n        HashMap<String, Integer> map = new HashMap<>();\\n\\n        String res[] = new String[names.length];\\n\\n        for(int i = 0; i < names.length; i++) {\\n            if(map.containsKey(names[i])) {\\n                Integer val = map.get(names[i]);\\n                StringBuilder sb = new StringBuilder(names[i]);\\n                sb.append(\\'(\\');\\n                sb.append(val);\\n                sb.append(\\')\\');\\n                while (map.containsKey(sb.toString())) {\\n                    val++;\\n                    sb = new StringBuilder(names[i]);\\n                    sb.append(\\'(\\');\\n                    sb.append(val);\\n                    sb.append(\\')\\');\\n                }\\n                res[i] = sb.toString();\\n                map.put(sb.toString(), 1);\\n                map.put(names[i], val + 1);\\n            } else {\\n                res[i] = names[i];\\n                map.put(names[i], 1);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\t   public String[] getFolderNames(String[] names) {\\n\\n        HashMap<String, Integer> map = new HashMap<>();\\n\\n        String res[] = new String[names.length];\\n\\n        for(int i = 0; i < names.length; i++) {\\n            if(map.containsKey(names[i])) {\\n                Integer val = map.get(names[i]);\\n                StringBuilder sb = new StringBuilder(names[i]);\\n                sb.append(\\'(\\');\\n                sb.append(val);\\n                sb.append(\\')\\');\\n                while (map.containsKey(sb.toString())) {\\n                    val++;\\n                    sb = new StringBuilder(names[i]);\\n                    sb.append(\\'(\\');\\n                    sb.append(val);\\n                    sb.append(\\')\\');\\n                }\\n                res[i] = sb.toString();\\n                map.put(sb.toString(), 1);\\n                map.put(names[i], val + 1);\\n            } else {\\n                res[i] = names[i];\\n                map.put(names[i], 1);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 697712,
                "title": "clean-python-3-set-and-hashmap",
                "content": "Time: `O(N)`, although there is a `while` loop, all old names will be passed only once.\\nSpace: `O(N)`\\n```\\nimport collections\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        exists = set()\\n        last = collections.defaultdict(int)\\n        result = []\\n        for name in names:\\n            k = last[name]\\n            modified = name\\n            while modified in exists:\\n                k += 1\\n                modified = f\\'{name}({k})\\'\\n            last[name] = k\\n            result.append(modified)\\n            exists.add(modified)\\n        return result\\n```\\n\\nUpdate: Refer to [ye15](https://leetcode.com/ye15/)\\'s idea, it can be neater.\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        last = {}\\n        for name in names:\\n            modified = name\\n            if name in last:\\n                k = last[name]\\n                while modified in last:\\n                    k += 1\\n                    modified = f\\'{name}({k})\\'\\n                last[name] = k\\n            last[modified] = 0\\n        return last.keys()\\n```\\n",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        exists = set()\\n        last = collections.defaultdict(int)\\n        result = []\\n        for name in names:\\n            k = last[name]\\n            modified = name\\n            while modified in exists:\\n                k += 1\\n                modified = f\\'{name}({k})\\'\\n            last[name] = k\\n            result.append(modified)\\n            exists.add(modified)\\n        return result\\n```\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        last = {}\\n        for name in names:\\n            modified = name\\n            if name in last:\\n                k = last[name]\\n                while modified in last:\\n                    k += 1\\n                    modified = f\\'{name}({k})\\'\\n                last[name] = k\\n            last[modified] = 0\\n        return last.keys()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697727,
                "title": "simple-c-logic-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string,int> m;// A map to store whether the particular name occurs how many times already\\n        for(int i=0;i<names.size();i++)\\n        {\\n            if(m.find(names[i])!=m.end())// if the name already came\\n            {\\n                int k=m[names[i]];// it contains the number in brackets\\n                while(m.find(names[i]+\"(\"+to_string(k)+\")\")!=m.end())\\n                {\\n                    k++;// Increase number until that didn\\'t exist\\n                    m[names[i]]++;//mean while update in the map too\\n                }\\n                m[names[i]]++;// Recently we will use one more number so increment\\n                 names[i]=names[i]+\"(\"+to_string(k)+\")\";\\n            }\\n            m[names[i]]=1;// Here we are storing  for example ...abc(1)=1 and abc(2)=1 it means abc(1) occcured one time, and abc=2 it means abc occured 2 times.\\n\\t\\t\\t/*\\n\\t\\t\\tSuppose you have a file named ABC occurring twice, we will store ABC with occurrence =2 and ABC(1) with occurrence =1... It helps when we get another file with name ABC(1) we can store like ABC(1)(1)\\n\\t\\t\\t*/\\n\\t\\t\\t\\n        }\\n        return names;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string,int> m;// A map to store whether the particular name occurs how many times already\\n        for(int i=0;i<names.size();i++)\\n        {\\n            if(m.find(names[i])!=m.end())// if the name already came\\n            {\\n                int k=m[names[i]];// it contains the number in brackets\\n                while(m.find(names[i]+\"(\"+to_string(k)+\")\")!=m.end())\\n                {\\n                    k++;// Increase number until that didn\\'t exist\\n                    m[names[i]]++;//mean while update in the map too\\n                }\\n                m[names[i]]++;// Recently we will use one more number so increment\\n                 names[i]=names[i]+\"(\"+to_string(k)+\")\";\\n            }\\n            m[names[i]]=1;// Here we are storing  for example ...abc(1)=1 and abc(2)=1 it means abc(1) occcured one time, and abc=2 it means abc occured 2 times.\\n\\t\\t\\t/*\\n\\t\\t\\tSuppose you have a file named ABC occurring twice, we will store ABC with occurrence =2 and ABC(1) with occurrence =1... It helps when we get another file with name ABC(1) we can store like ABC(1)(1)\\n\\t\\t\\t*/\\n\\t\\t\\t\\n        }\\n        return names;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719962,
                "title": "easy-code-with-explanation-yes-diagram",
                "content": "![image](https://assets.leetcode.com/users/images/ffbd2838-5b99-4e3a-a514-dd8fc76442b0_1593908409.8776517.png)\\n\\n**Upvote would be appreciated! :)**\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> nameSuffix; // Folder name -> Next available value \\n                                        // for the suffix.\\n    \\n    string addSuffix(string name) {\\n        string newName = \"\";\\n        do {\\n            newName = name + \"(\" + to_string(nameSuffix[name]) + \")\"; // Generate a name.\\n            nameSuffix[name]++;                    // Increase the count by one\\n        } while (nameSuffix.find(newName) != nameSuffix.end()); // Until we get a used \\n                                                                // name for the folder.\\n        return newName;\\n    }\\n    \\n    string getFolderName(string name) {\\n        string finalName = name; // If the folder name doesn\\'t already exist, \\n                                 // no need of renaming.\\n        if (nameSuffix.find(name) != nameSuffix.end()) { // If folder already exists -\\n            finalName = addSuffix(name);           // Add suffix to the name.\\n        }\\n        nameSuffix[finalName]++; // Record that the name is already in use.\\n        return finalName;     // Finally return the name for the folder.\\n    }\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> ans;      // Hold all names of the folders after renaming.\\n        for (auto name: names) { // For each folder name -\\n            ans.push_back(getFolderName(name)); // Compute the name for the folder.\\n        }\\n        return ans; // Return answer.\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> nameSuffix; // Folder name -> Next available value \\n                                        // for the suffix.\\n    \\n    string addSuffix(string name) {\\n        string newName = \"\";\\n        do {\\n            newName = name + \"(\" + to_string(nameSuffix[name]) + \")\"; // Generate a name.\\n            nameSuffix[name]++;                    // Increase the count by one\\n        } while (nameSuffix.find(newName) != nameSuffix.end()); // Until we get a used \\n                                                                // name for the folder.\\n        return newName;\\n    }\\n    \\n    string getFolderName(string name) {\\n        string finalName = name; // If the folder name doesn\\'t already exist, \\n                                 // no need of renaming.\\n        if (nameSuffix.find(name) != nameSuffix.end()) { // If folder already exists -\\n            finalName = addSuffix(name);           // Add suffix to the name.\\n        }\\n        nameSuffix[finalName]++; // Record that the name is already in use.\\n        return finalName;     // Finally return the name for the folder.\\n    }\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> ans;      // Hold all names of the folders after renaming.\\n        for (auto name: names) { // For each folder name -\\n            ans.push_back(getFolderName(name)); // Compute the name for the folder.\\n        }\\n        return ans; // Return answer.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697825,
                "title": "python-accepted-solution-with-dictionary-hashmap-and-set",
                "content": "**Explanation**\\nUsing set we check the name which is already user or not, if not used we can keep name\\'s version k and increment k until we reach our version.\\nIn dictionary, key = name, value = version.\\n\\n**Complexity**\\nTime ```O(N)``` \\xA0\\nSpace ```O(N)```\\n\\n```\\n    from collections import defaultdict\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        used, hashmap = set(), defaultdict(int)\\n        result = []\\n        for name in names:\\n            k = hashmap[name]\\n            current = name\\n            while current in used:\\n                k += 1\\n                current = \\'%s(%d)\\' % (name, k)  # alternative to current = name+\\'(\\'+str(k)+\\')\\'\\n            hashmap[name] = k\\n            result.append(current)\\n            used.add(current)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```O(N)```\n```O(N)```\n```\\n    from collections import defaultdict\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        used, hashmap = set(), defaultdict(int)\\n        result = []\\n        for name in names:\\n            k = hashmap[name]\\n            current = name\\n            while current in used:\\n                k += 1\\n                current = \\'%s(%d)\\' % (name, k)  # alternative to current = name+\\'(\\'+str(k)+\\')\\'\\n            hashmap[name] = k\\n            result.append(current)\\n            used.add(current)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 697977,
                "title": "c-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> map;\\n        vector<string> output;\\n        for(auto name : names) {\\n            string val = name; int i = map[val];\\n            while(map[val] > 0) {\\n                val = name + \"(\" + to_string(i++) + \")\";\\n                map[name] = i;\\n            }\\n            map[val]++;\\n            output.push_back(val);\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> map;\\n        vector<string> output;\\n        for(auto name : names) {\\n            string val = name; int i = map[val];\\n            while(map[val] > 0) {\\n                val = name + \"(\" + to_string(i++) + \")\";\\n                map[name] = i;\\n            }\\n            map[val]++;\\n            output.push_back(val);\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697773,
                "title": "python-dict-no-set-self-explainable",
                "content": "```\\ndef getFolderNames(self, names: List[str]) -> List[str]:\\n        h = dict()\\n        ans = []\\n        \\n        for i in names:\\n            if i not in h :\\n                h[i] = 1\\n                ans.append(i)\\n            else:\\n                ct = h[i]\\n                tmp = i + \\'(\\' + str(ct) + \\')\\'\\n                while tmp in h:\\n                    ct +=1\\n                    tmp = i + \\'(\\' + str(ct) + \\')\\'\\n                h[tmp] = 1\\n                ans.append(tmp)\\n                h[i] = ct\\n        \\n        return ans\\n```\\nif you find good , upvot it",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef getFolderNames(self, names: List[str]) -> List[str]:\\n        h = dict()\\n        ans = []\\n        \\n        for i in names:\\n            if i not in h :\\n                h[i] = 1\\n                ans.append(i)\\n            else:\\n                ct = h[i]\\n                tmp = i + \\'(\\' + str(ct) + \\')\\'\\n                while tmp in h:\\n                    ct +=1\\n                    tmp = i + \\'(\\' + str(ct) + \\')\\'\\n                h[tmp] = 1\\n                ans.append(tmp)\\n                h[i] = ct\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 697763,
                "title": "java-hashmap",
                "content": "```\\n\\nclass Solution {\\n    \\n\\tpublic String[] getFolderNames(String[] names) {\\n        \\n        Map<String, Integer> map = new HashMap<>();        \\n        for (int i=0; i < names.length; i++){\\n            names[i] = getName(map, names[i]);\\n        }\\n        return names;\\n    }\\n    \\n    private String getName(Map<String, Integer> map, String name){\\n        if (map.containsKey(name)){                \\n            int n = map.get(name) + 1;\\n            \\n            while (map.containsKey(name + \"(\" + n + \")\")){\\n                n++;\\n            }\\n            map.put(name, n);    \\n            name = getName(map, name + \"(\" + n + \")\");\\n                        \\n        } else {\\n            map.put(name, 0);\\n        }\\n        return name;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n\\tpublic String[] getFolderNames(String[] names) {\\n        \\n        Map<String, Integer> map = new HashMap<>();        \\n        for (int i=0; i < names.length; i++){\\n            names[i] = getName(map, names[i]);\\n        }\\n        return names;\\n    }\\n    \\n    private String getName(Map<String, Integer> map, String name){\\n        if (map.containsKey(name)){                \\n            int n = map.get(name) + 1;\\n            \\n            while (map.containsKey(name + \"(\" + n + \")\")){\\n                n++;\\n            }\\n            map.put(name, n);    \\n            name = getName(map, name + \"(\" + n + \")\");\\n                        \\n        } else {\\n            map.put(name, 0);\\n        }\\n        return name;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848376,
                "title": "my-java-solution-using-hashmap-with-my-thought-process",
                "content": "```\\n/* My Thought Process\\nBefore looking into the hint, when I saw that the names obtained must be unique, the first thing that came to my mind was using a HashMap. \\nSo here we use a hash map inorder to keep track of the occurance of the names and to decide whether it is unique and how we have to name the file.\\n\\n-> SO we traverse through the string array,\\n-> Lets store the current name to a variable say current.\\n-> So if the current is not in the map, then we are cool, we just have the same number becuase its the lowest number unique name.\\n-> But when we again see the same name that we seen before, there occurs a duplicate and we have to check while map contaisn duplicate name, then\\n            - We get the current value of that key.\\n            - So now we have to increment the counter of that particular word.\\n            - Now we put that name into the map along with the updated count to say that it happends say n number of times.\\n            - Now I here use a string builder to create a new string with the current name, (, the count,).\\n            - Now the name from the String array will be updated with the new name.\\nHere insted of StringBuilder, we can make use of just + operator for concatenation, but I found this opportunity to get more familiar with the StrinBuilder I used it. Thats all.\\n*/\\n\\n\\n\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i=0; i<names.length; i++) {\\n            String current = names[i];\\n            while (map.containsKey(current)) {\\n                int count = map.get(names[i]);\\n                count += 1;\\n                map.put(names[i], count);\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(names[i]);\\n                sb.append(\"(\");\\n                sb.append(count);\\n                sb.append(\")\");\\n                current = sb.toString();\\n            }\\n            map.put(current, 0);\\n            names[i] = current;\\n        }\\n        return names;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n/* My Thought Process\\nBefore looking into the hint, when I saw that the names obtained must be unique, the first thing that came to my mind was using a HashMap. \\nSo here we use a hash map inorder to keep track of the occurance of the names and to decide whether it is unique and how we have to name the file.\\n\\n-> SO we traverse through the string array,\\n-> Lets store the current name to a variable say current.\\n-> So if the current is not in the map, then we are cool, we just have the same number becuase its the lowest number unique name.\\n-> But when we again see the same name that we seen before, there occurs a duplicate and we have to check while map contaisn duplicate name, then\\n            - We get the current value of that key.\\n            - So now we have to increment the counter of that particular word.\\n            - Now we put that name into the map along with the updated count to say that it happends say n number of times.\\n            - Now I here use a string builder to create a new string with the current name, (, the count,).\\n            - Now the name from the String array will be updated with the new name.\\nHere insted of StringBuilder, we can make use of just + operator for concatenation, but I found this opportunity to get more familiar with the StrinBuilder I used it. Thats all.\\n*/\\n\\n\\n\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i=0; i<names.length; i++) {\\n            String current = names[i];\\n            while (map.containsKey(current)) {\\n                int count = map.get(names[i]);\\n                count += 1;\\n                map.put(names[i], count);\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(names[i]);\\n                sb.append(\"(\");\\n                sb.append(count);\\n                sb.append(\")\");\\n                current = sb.toString();\\n            }\\n            map.put(current, 0);\\n            names[i] = current;\\n        }\\n        return names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707739,
                "title": "share-a-tricky-test-case",
                "content": "I have submitted 4 times to pass all the tests, and I think this test case may help to better understand the question.\\n\\nI have removed some trival data, and left as below:\\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r\\', \\'r\\', \\'r\\', \\'r\\', \\'r(1)\\', \\'r\\', \\'r\\', \\'r(2)\\', \\'r(2)(1)\\']\\n```\\nthe expected result should be:\\n```\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\', \\'r(3)\\', \\'r(4)\\', \\'r(5)\\', \\'r(1)(1)\\', \\'r(6)\\', \\'r(7)\\', \\'r(2)(2)\\', \\'r(2)(1)(1)\\']\\n```\\n\\nBelow I will show step by step why the result should be as above:\\n1 **r(1)**. there are no r(1), so output is:\\n```python\\n[\\'r(1)\\']\\n```\\n2 **r**. there are no r, so output is:\\n```python\\n[\\'r(1)\\', \\'r\\']\\n```\\n3 **r(2)(1)**, there are no r(2)(1), so output is:\\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\']\\n```\\n4, **r**, there already exist r, so rename it to r(some_number), and r(1) is also exist, so rename to r(2), output is:\\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\']\\n```\\n5-7 **r**,  like step 4, output is:\\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\', \\'r(3)\\', \\'r(4)\\', \\'r(5)\\']\\n```\\n8 **r(1)**, r(1) is already there, so output is :\\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\', \\'r(3)\\', \\'r(4)\\', \\'r(5)\\', \\'r(1)(1)\\']\\n```\\n9~10, **r**, r is already there, so output is:\\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\', \\'r(3)\\', \\'r(4)\\', \\'r(5)\\', \\'r(1)(1)\\', \\'r(6)\\', \\'r(7)\\']\\n```\\n11 **r(2)**. r(2) already there, so should rename to r(2)(some_number), r(2)(1) is arleady there, so some_number should be 2, rename to r(2)(2). now output is:\\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\', \\'r(3)\\', \\'r(4)\\', \\'r(5)\\', \\'r(1)(1)\\', \\'r(6)\\', \\'r(7)\\', \\'r(2)(2)\\']\\n```\\n12 **\\'r(2)(1)\\'**, already there, so should rename to r(2)(1)(1), now output is:\\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\', \\'r(3)\\', \\'r(4)\\', \\'r(5)\\', \\'r(1)(1)\\', \\'r(6)\\', \\'r(7)\\', \\'r(2)(2)\\', \\'r(2)(1)(1)\\']\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r\\', \\'r\\', \\'r\\', \\'r\\', \\'r(1)\\', \\'r\\', \\'r\\', \\'r(2)\\', \\'r(2)(1)\\']\\n```\n```\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\', \\'r(3)\\', \\'r(4)\\', \\'r(5)\\', \\'r(1)(1)\\', \\'r(6)\\', \\'r(7)\\', \\'r(2)(2)\\', \\'r(2)(1)(1)\\']\\n```\n```python\\n[\\'r(1)\\']\\n```\n```python\\n[\\'r(1)\\', \\'r\\']\\n```\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\']\\n```\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\']\\n```\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\', \\'r(3)\\', \\'r(4)\\', \\'r(5)\\']\\n```\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\', \\'r(3)\\', \\'r(4)\\', \\'r(5)\\', \\'r(1)(1)\\']\\n```\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\', \\'r(3)\\', \\'r(4)\\', \\'r(5)\\', \\'r(1)(1)\\', \\'r(6)\\', \\'r(7)\\']\\n```\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\', \\'r(3)\\', \\'r(4)\\', \\'r(5)\\', \\'r(1)(1)\\', \\'r(6)\\', \\'r(7)\\', \\'r(2)(2)\\']\\n```\n```python\\n[\\'r(1)\\', \\'r\\', \\'r(2)(1)\\', \\'r(2)\\', \\'r(3)\\', \\'r(4)\\', \\'r(5)\\', \\'r(1)(1)\\', \\'r(6)\\', \\'r(7)\\', \\'r(2)(2)\\', \\'r(2)(1)(1)\\']\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697894,
                "title": "javascript-comments-map",
                "content": "This solution uses a map to keep track of file names.\\n\\nIn the case of a collision, we need to find next available number for the file name, and update both old name as in input and new name with suffix `()` in the map.\\n\\n```\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nvar getFolderNames = function(names) {\\n  const map = new Map();\\n    \\n  for (const name of names) {\\n    if (!map.has(name)) {\\n\\t  // Store the next available number 1\\n      map.set(name, 1);\\n    } else {\\n      let count = map.get(name);\\n      let newName = `${name}(${count})`;  \\n\\t  \\n      // Find the next available number because the new file name with () may have already been taken\\n\\t  // e.g. map = {target: 1, target(1): 1}, name = target\\n      while (map.has(newName)) {\\n        count++;\\n        newName = `${name}(${count})`;\\n      }\\n      \\n\\t  // Update both old name and new name in the map\\n      map.set(name, count + 1);\\n      map.set(newName, 1);\\n    }\\n  }  \\n    \\n  // ES6 Map is LinkedHashMap so name keys are ordered when iterated \\n  return [...map.keys()];\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "This solution uses a map to keep track of file names.\\n\\nIn the case of a collision, we need to find next available number for the file name, and update both old name as in input and new name with suffix `()` in the map.\\n\\n```\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nvar getFolderNames = function(names) {\\n  const map = new Map();\\n    \\n  for (const name of names) {\\n    if (!map.has(name)) {\\n\\t  // Store the next available number 1\\n      map.set(name, 1);\\n    } else {\\n      let count = map.get(name);\\n      let newName = `${name}(${count})`;  \\n\\t  \\n      // Find the next available number because the new file name with () may have already been taken\\n\\t  // e.g. map = {target: 1, target(1): 1}, name = target\\n      while (map.has(newName)) {\\n        count++;\\n        newName = `${name}(${count})`;\\n      }\\n      \\n\\t  // Update both old name and new name in the map\\n      map.set(name, count + 1);\\n      map.set(newName, 1);\\n    }\\n  }  \\n    \\n  // ES6 Map is LinkedHashMap so name keys are ordered when iterated \\n  return [...map.keys()];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 697812,
                "title": "simple-java-solution-hashmap-with-explaination-comments",
                "content": "The idea here is simple - Track the fileName and corresponding frequency. \\n\\nIf a new file name is found, assign frequency as 1. \\n\\nIncase of duplicates, get the latest frequency value. So lets say if map has (\"a\", 1) then next time if \"a\" is encountered, we just append frequency(which is 1 here) and generate new string a(1). \\n\\nNow, we need to continuously check if a(1) is present or not in the HashMap. At the end, we put the newly generated string in the hashmap(say a(1)) and for original duplicate string(a) we update the frequency for future duplicate references.\\n\\n``` \\npublic String[] getFolderNames(String[] names) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int n = names.length;\\n        String ans[] = new String[n];\\n        for(int i=0;i<n;i++) {\\n            if(!map.containsKey(names[i])) { //normal case\\n                ans[i] = names[i];\\n                map.put(names[i], 1);\\n            }\\n            else {\\n                //duplicates found\\n                int count = map.get(names[i]); //first time count will be 1\\n                String temp = names[i] + \"(\" + count + \")\";\\n                while(map.containsKey(temp)) {\\n                    count++;\\n                    temp = names[i] + \"(\" + count + \")\";\\n                }\\n                map.put(temp, 1); //put the newly generated string in map as it might be used later \\n                map.put(names[i],count); //update the count so next time it won\\'t do extra calculations\\n                ans[i] = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "The idea here is simple - Track the fileName and corresponding frequency. \\n\\nIf a new file name is found, assign frequency as 1. \\n\\nIncase of duplicates, get the latest frequency value. So lets say if map has (\"a\", 1) then next time if \"a\" is encountered, we just append frequency(which is 1 here) and generate new string a(1). \\n\\nNow, we need to continuously check if a(1) is present or not in the HashMap. At the end, we put the newly generated string in the hashmap(say a(1)) and for original duplicate string(a) we update the frequency for future duplicate references.\\n\\n``` \\npublic String[] getFolderNames(String[] names) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int n = names.length;\\n        String ans[] = new String[n];\\n        for(int i=0;i<n;i++) {\\n            if(!map.containsKey(names[i])) { //normal case\\n                ans[i] = names[i];\\n                map.put(names[i], 1);\\n            }\\n            else {\\n                //duplicates found\\n                int count = map.get(names[i]); //first time count will be 1\\n                String temp = names[i] + \"(\" + count + \")\";\\n                while(map.containsKey(temp)) {\\n                    count++;\\n                    temp = names[i] + \"(\" + count + \")\";\\n                }\\n                map.put(temp, 1); //put the newly generated string in map as it might be used later \\n                map.put(names[i],count); //update the count so next time it won\\'t do extra calculations\\n                ans[i] = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 698136,
                "title": "elegant-hashmap-solution-time-and-space-100",
                "content": "Idea is to store all the strings with count and output strings as well with count. Iterate till no match starting from count and display.\\n\\n```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(int i=0; i<names.length; i++){\\n            String key = names[i];\\n            \\n            int count = map.containsKey(key) ? map.get(key) : 0;\\n            while(map.containsKey(key))                 //iterate till no match found\\n                key = names[i] + \"(\" + ++count + \")\";\\n            \\n            map.put(key, 0);                  //store key with brackets as well (modified string)\\n            map.put(names[i], count);         //store key without brackets (actual string)\\n            names[i] = key;                   //modify the same array and return\\n        }\\n        return names;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(int i=0; i<names.length; i++){\\n            String key = names[i];\\n            \\n            int count = map.containsKey(key) ? map.get(key) : 0;\\n            while(map.containsKey(key))                 //iterate till no match found\\n                key = names[i] + \"(\" + ++count + \")\";\\n            \\n            map.put(key, 0);                  //store key with brackets as well (modified string)\\n            map.put(names[i], count);         //store key without brackets (actual string)\\n            names[i] = key;                   //modify the same array and return\\n        }\\n        return names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697830,
                "title": "c-one-pass-with-explanation-beats-100",
                "content": "If the name is not already used, then push it into resultant vector.\\nIf it is already used, we get the last used version number of the name maintained in the hashmap.\\nIf that is also found in already used set, we simply increment till we find an entry not used.\\n\\n```\\nvector<string> getFolderNames(vector<string>& names) {\\n        unordered_set<string> s;\\n        unordered_map<string,int> m;\\n        vector<string> res(names.size());\\n        for(int i = 0; i < names.size(); ++i)\\n        {\\n            if(s.insert(names[i]).second)\\n            {\\n                res[i] = names[i];\\n            }\\n            else\\n            {\\n                int k = m[names[i]];\\n                bool found = false;\\n                while(!found)\\n                {\\n                    string x = names[i]+\\'(\\'+to_string(++k) + \\')\\';\\n                    if(s.insert(x).second)\\n                    {\\n                        res[i] = x;\\n                        m[names[i]] = k;\\n                        found = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;",
                "solutionTags": [
                    "C"
                ],
                "code": "If the name is not already used, then push it into resultant vector.\\nIf it is already used, we get the last used version number of the name maintained in the hashmap.\\nIf that is also found in already used set, we simply increment till we find an entry not used.\\n\\n```\\nvector<string> getFolderNames(vector<string>& names) {\\n        unordered_set<string> s;\\n        unordered_map<string,int> m;\\n        vector<string> res(names.size());\\n        for(int i = 0; i < names.size(); ++i)\\n        {\\n            if(s.insert(names[i]).second)\\n            {\\n                res[i] = names[i];\\n            }\\n            else\\n            {\\n                int k = m[names[i]];\\n                bool found = false;\\n                while(!found)\\n                {\\n                    string x = names[i]+\\'(\\'+to_string(++k) + \\')\\';\\n                    if(s.insert(x).second)\\n                    {\\n                        res[i] = x;\\n                        m[names[i]] = k;\\n                        found = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 697700,
                "title": "python-python-one-pass-hash-solution",
                "content": "```python\\n# memo records the number of a certain symbol we already have, so when we come across a symbol in memo\\'s keys,\\n# we append [name(str(memo[name]))], and set [name(str(memo[name]))]\\'s number to 1 (it\\'s new to memo)\\n# one thing to note is that name(str(memo[name])) may already exist because of directly add symbol like \"name(3)\"\\n# so we add a while loop to deal with it, everytime we need to increase the number of name itself.\\n\\nfrom collections import defaultdict\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        memo = defaultdict(int)\\n        res = []\\n        for n in names:\\n            if memo[n] > 0:\\n                while n+\\'(\\'+ str(memo[n]) +\\')\\' in memo.keys():\\n                    memo[n]+=1\\n                res.append(n+\\'(\\'+ str(memo[n]) +\\')\\')\\n                memo[n+\\'(\\'+ str(memo[n])+\\')\\']+=1\\n            else:\\n                res.append(n)\\n            memo[n]+=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n# memo records the number of a certain symbol we already have, so when we come across a symbol in memo\\'s keys,\\n# we append [name(str(memo[name]))], and set [name(str(memo[name]))]\\'s number to 1 (it\\'s new to memo)\\n# one thing to note is that name(str(memo[name])) may already exist because of directly add symbol like \"name(3)\"\\n# so we add a while loop to deal with it, everytime we need to increase the number of name itself.\\n\\nfrom collections import defaultdict\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        memo = defaultdict(int)\\n        res = []\\n        for n in names:\\n            if memo[n] > 0:\\n                while n+\\'(\\'+ str(memo[n]) +\\')\\' in memo.keys():\\n                    memo[n]+=1\\n                res.append(n+\\'(\\'+ str(memo[n]) +\\')\\')\\n                memo[n+\\'(\\'+ str(memo[n])+\\')\\']+=1\\n            else:\\n                res.append(n)\\n            memo[n]+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703485,
                "title": "1487-javascript-5-line-recursive-solution",
                "content": "This is the shortest working solution I could come up with.\\n\\n> Runtime: **1832 ms**, faster than *52.50%* of JavaScript online submissions\\n> Memory Usage: **58.1 MB**, less than *100.00%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nconst getFolderNames = (names, acts /* ACTual nameS */ = new Map()) => {\\n  if (!names.length) return [...acts.keys()];\\n  const n = names.shift();\\n  if (!acts.has(n)) return getFolderNames(names, acts.set(n, 1));\\n  while (acts.has(`${n}(${acts.get(n)})`)) acts.set(n, acts.get(n) + 1);\\n  return getFolderNames(names, acts.set(`${n}(${acts.get(n)})`, 1));\\n};\\n```\\n\\nThis (technically) 4 line solution didn\\'t work.\\n\\n> FATAL ERROR: Scavenger: semi-space copy Allocation failed - JavaScript heap out of memory\\n\\n```javascript\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nconst getFolderNames = (names, acts /* ACTual nameS */ = new Map()) => {\\n  if (!names.length) return [...acts.keys()];\\n  if (!acts.has(names[0]))\\n    return getFolderNames(names.slice(1), acts.set(names[0], 1));\\n  while (acts.has(`${names[0]}(${acts.get(names[0])})`))\\n    acts.set(names[0], acts.get(names[0]) + 1);\\n  return getFolderNames(\\n    names.slice(1),\\n    acts.set(`${names[0]}(${acts.get(names[0])})`, 1),\\n  );\\n};\\n```\\n\\nAnd yes, it\\'s faster without recursion.\\n\\n> Runtime: **188 ms**, faster than 80.00% of JavaScript online submissions\\n> Memory Usage: **53.3 MB**, less than 100.00% of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nconst getFolderNames = names => {\\n  const acts = new Map(); // ACTual nameS\\n  for (const n of names)\\n    if (!acts.has(n)) acts.set(n, 1);\\n    else {\\n      while (acts.has(`${n}(${acts.get(n)})`)) acts.set(n, acts.get(n) + 1);\\n      acts.set(`${n}(${acts.get(n)})`, 1);\\n    }\\n  return [...acts.keys()];\\n};\\n```\\n\\nAnd slower when using a Set instead of a Map.\\n\\n> Runtime: **3984 ms**, faster than *43.00%* of JavaScript online submissions\\n> Memory Usage: **54.3 MB**, less than *100.00%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nconst getFolderNames = names => {\\n  const acts = new Set(); // ACTual nameS\\n  for (const n of names)\\n    if (!acts.has(n)) acts.add(n);\\n    else {\\n      let i = 1;\\n      while (acts.has(`${n}(${i})`)) i++;\\n      acts.add(`${n}(${i})`);\\n    }\\n  return [...acts];\\n};\\n```\\n\\nAnd is far too slow when using an array.\\n\\n> Status: Time Limit Exceeded\\n\\n```javascript\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nconst getFolderNames = names => {\\n  const acts = []; // ACTual nameS\\n  for (const n of names)\\n    if (!acts.includes(n)) acts.push(n);\\n    else {\\n      let i = 1;\\n      while (acts.includes(`${n}(${i})`)) i++;\\n      acts.push(`${n}(${i})`);\\n    }\\n  return acts;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nconst getFolderNames = (names, acts /* ACTual nameS */ = new Map()) => {\\n  if (!names.length) return [...acts.keys()];\\n  const n = names.shift();\\n  if (!acts.has(n)) return getFolderNames(names, acts.set(n, 1));\\n  while (acts.has(`${n}(${acts.get(n)})`)) acts.set(n, acts.get(n) + 1);\\n  return getFolderNames(names, acts.set(`${n}(${acts.get(n)})`, 1));\\n};\\n```\n```javascript\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nconst getFolderNames = (names, acts /* ACTual nameS */ = new Map()) => {\\n  if (!names.length) return [...acts.keys()];\\n  if (!acts.has(names[0]))\\n    return getFolderNames(names.slice(1), acts.set(names[0], 1));\\n  while (acts.has(`${names[0]}(${acts.get(names[0])})`))\\n    acts.set(names[0], acts.get(names[0]) + 1);\\n  return getFolderNames(\\n    names.slice(1),\\n    acts.set(`${names[0]}(${acts.get(names[0])})`, 1),\\n  );\\n};\\n```\n```javascript\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nconst getFolderNames = names => {\\n  const acts = new Map(); // ACTual nameS\\n  for (const n of names)\\n    if (!acts.has(n)) acts.set(n, 1);\\n    else {\\n      while (acts.has(`${n}(${acts.get(n)})`)) acts.set(n, acts.get(n) + 1);\\n      acts.set(`${n}(${acts.get(n)})`, 1);\\n    }\\n  return [...acts.keys()];\\n};\\n```\n```javascript\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nconst getFolderNames = names => {\\n  const acts = new Set(); // ACTual nameS\\n  for (const n of names)\\n    if (!acts.has(n)) acts.add(n);\\n    else {\\n      let i = 1;\\n      while (acts.has(`${n}(${i})`)) i++;\\n      acts.add(`${n}(${i})`);\\n    }\\n  return [...acts];\\n};\\n```\n```javascript\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nconst getFolderNames = names => {\\n  const acts = []; // ACTual nameS\\n  for (const n of names)\\n    if (!acts.includes(n)) acts.push(n);\\n    else {\\n      let i = 1;\\n      while (acts.includes(`${n}(${i})`)) i++;\\n      acts.push(`${n}(${i})`);\\n    }\\n  return acts;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697835,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> m = new HashMap<>();\\n        for (int i = 0; i < names.length; i++) {\\n            String name = names[i];\\n            if (!m.containsKey(name)) {\\n                m.put(name, 1);\\n                continue;\\n            }\\n            int n = m.get(name);\\n            String candidate = name + \"(\" + n + \")\";\\n            while (m.containsKey(candidate)) {\\n                n++;\\n                candidate = name + \"(\" + n + \")\";\\n            }\\n            names[i] = candidate;\\n            m.put(name, n + 1);\\n            m.put(candidate, 1);\\n        }\\n        return names;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> m = new HashMap<>();\\n        for (int i = 0; i < names.length; i++) {\\n            String name = names[i];\\n            if (!m.containsKey(name)) {\\n                m.put(name, 1);\\n                continue;\\n            }\\n            int n = m.get(name);\\n            String candidate = name + \"(\" + n + \")\";\\n            while (m.containsKey(candidate)) {\\n                n++;\\n                candidate = name + \"(\" + n + \")\";\\n            }\\n            names[i] = candidate;\\n            m.put(name, n + 1);\\n            m.put(candidate, 1);\\n        }\\n        return names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697819,
                "title": "java-map-instead-of-set",
                "content": "\\n```\\npublic String[] getFolderNames(String[] names) {\\n        int n = names.length;\\n        String[] res = new String[n];\\n        int index = 0;\\n        \\n        HashMap<String,Integer> map = new HashMap<>(); \\n        for (String s : names) {\\n            StringBuilder newS = new StringBuilder(s);\\n            \\n            for (int i = map.getOrDefault(newS.toString(),1); i <= n; i++) {\\n                if (!map.containsKey(newS.toString())) {\\n                    res[index++] = newS.toString();\\n                    map.put(newS.toString(),0);\\n                    map.put(s, map.get(s) + 1);\\n                    break;\\n                } else {\\n                    newS = new StringBuilder(s); \\n                    newS.append(\"(\");\\n                    if (i == 0) i++;\\n                    newS.append(i);\\n                    newS.append(\")\");\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\npublic String[] getFolderNames(String[] names) {\\n        int n = names.length;\\n        String[] res = new String[n];\\n        int index = 0;\\n        \\n        HashMap<String,Integer> map = new HashMap<>(); \\n        for (String s : names) {\\n            StringBuilder newS = new StringBuilder(s);\\n            \\n            for (int i = map.getOrDefault(newS.toString(),1); i <= n; i++) {\\n                if (!map.containsKey(newS.toString())) {\\n                    res[index++] = newS.toString();\\n                    map.put(newS.toString(),0);\\n                    map.put(s, map.get(s) + 1);\\n                    break;\\n                } else {\\n                    newS = new StringBuilder(s); \\n                    newS.append(\"(\");\\n                    if (i == 0) i++;\\n                    newS.append(i);\\n                    newS.append(\")\");\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697788,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        \\n        int n = names.size();\\n        vector<string>res;\\n        unordered_map<string, int>hm;\\n        for (int i = 0; i < n; i++) {\\n            if (hm.find(names[i]) != hm.end()) {\\n                int j = hm[names[i]]+1;\\n                string p = \\'(\\' + to_string(j) + \\')\\';\\n                while (hm.find(names[i] + p) != hm.end()) {\\n                    j++;\\n                    p = \\'(\\' + to_string(j) + \\')\\';\\n                }\\n                hm[names[i]] = j;\\n                hm[names[i]+p] = 0;\\n                res.push_back(names[i]+p);\\n            } else {\\n                res.push_back(names[i]);\\n                hm[names[i]] = 0;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        \\n        int n = names.size();\\n        vector<string>res;\\n        unordered_map<string, int>hm;\\n        for (int i = 0; i < n; i++) {\\n            if (hm.find(names[i]) != hm.end()) {\\n                int j = hm[names[i]]+1;\\n                string p = \\'(\\' + to_string(j) + \\')\\';\\n                while (hm.find(names[i] + p) != hm.end()) {\\n                    j++;\\n                    p = \\'(\\' + to_string(j) + \\')\\';\\n                }\\n                hm[names[i]] = j;\\n                hm[names[i]+p] = 0;\\n                res.push_back(names[i]+p);\\n            } else {\\n                res.push_back(names[i]);\\n                hm[names[i]] = 0;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697782,
                "title": "java-python-3-count-using-hashmap-dict",
                "content": "1. Use a a HashMap to avoid duplicate and to count the suffix;\\n2. If never seen a name before, keep it intact; otherwise, use the HashMap to keep increase the suffix by one till find a name never seen before;\\n\\n```java\\n    public String[] getFolderNames(String[] names) {\\n        String[] ans = new String[names.length];\\n        Map<String, Integer> suffixNum = new HashMap<>();\\n        int i = 0;\\n        for (String name : names) {\\n            if (!suffixNum.containsKey(name)) { // not duplicate.\\n                ans[i] = name; // no change.\\n            }else { // duplicate found.\\n                while (suffixNum.containsKey(name + \"(\" + suffixNum.get(name) + \")\")) { // Still duplicate with suffix addition?\\n                    suffixNum.put(name, 1 + suffixNum.get(name)); // Increase the number in suffix by 1.\\n                }\\n                ans[i] = name + \"(\" + suffixNum.get(name) + \")\"; // append the smallest positive integer.\\n            }\\n            suffixNum.put(ans[i], 1 + suffixNum.getOrDefault(ans[i++], 0)); // put it into Map to avoid duplicate.\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        ans, suffixNum = [], Counter()\\n        for name in names:\\n            if name in suffixNum:\\n                while name + \\'(\\' + str(suffixNum[name]) + \\')\\' in suffixNum:\\n                    suffixNum[name] += 1\\n                ans.append(name + \\'(\\' + str(suffixNum[name]) + \\')\\')\\n            else:\\n                ans.append(name)\\n            suffixNum[ans[-1]] += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```java\\n    public String[] getFolderNames(String[] names) {\\n        String[] ans = new String[names.length];\\n        Map<String, Integer> suffixNum = new HashMap<>();\\n        int i = 0;\\n        for (String name : names) {\\n            if (!suffixNum.containsKey(name)) { // not duplicate.\\n                ans[i] = name; // no change.\\n            }else { // duplicate found.\\n                while (suffixNum.containsKey(name + \"(\" + suffixNum.get(name) + \")\")) { // Still duplicate with suffix addition?\\n                    suffixNum.put(name, 1 + suffixNum.get(name)); // Increase the number in suffix by 1.\\n                }\\n                ans[i] = name + \"(\" + suffixNum.get(name) + \")\"; // append the smallest positive integer.\\n            }\\n            suffixNum.put(ans[i], 1 + suffixNum.getOrDefault(ans[i++], 0)); // put it into Map to avoid duplicate.\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        ans, suffixNum = [], Counter()\\n        for name in names:\\n            if name in suffixNum:\\n                while name + \\'(\\' + str(suffixNum[name]) + \\')\\' in suffixNum:\\n                    suffixNum[name] += 1\\n                ans.append(name + \\'(\\' + str(suffixNum[name]) + \\')\\')\\n            else:\\n                ans.append(name)\\n            suffixNum[ans[-1]] += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 697723,
                "title": "what-the-hell-is-this-seriously",
                "content": "Took a use of HashSet but got a `TLE`, what is fxxk of this problem!\\n\\nI will say this is not a good problem unless Lxxtcode can show your better official solution to this problem.\\n\\n```\\n    public String[] getFolderNames(String[] na) {\\n        String[] res = new String[na.length];\\n        \\n        Set<String> set = new HashSet<>();\\n        for (int i=0; i<na.length; i++) {\\n            if (!set.contains(na[i])) {\\n                res[i] = na[i];\\n                set.add(na[i]);\\n            } else {\\n                int k = 1;\\n                String name = na[i] + String.format(\"(%s)\", k);\\n                while(set.contains(name)) {\\n                    k++;\\n                    name = na[i] + String.format(\"(%s)\", k);\\n                }\\n                res[i] = name;\\n                set.add(name);\\n            }\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String[] getFolderNames(String[] na) {\\n        String[] res = new String[na.length];\\n        \\n        Set<String> set = new HashSet<>();\\n        for (int i=0; i<na.length; i++) {\\n            if (!set.contains(na[i])) {\\n                res[i] = na[i];\\n                set.add(na[i]);\\n            } else {\\n                int k = 1;\\n                String name = na[i] + String.format(\"(%s)\", k);\\n                while(set.contains(name)) {\\n                    k++;\\n                    name = na[i] + String.format(\"(%s)\", k);\\n                }\\n                res[i] = name;\\n                set.add(name);\\n            }\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1700003,
                "title": "easy-c-solution-using-map",
                "content": "If you encounter same string just add suffix starting from (1) until it is unique. But this will give TLE\\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> mp;\\n        for(int i=0; i<names.size(); i++)\\n        {\\n            int count = 1;\\n            string temp=names[i];\\n            while(mp.find(temp)!=mp.end())\\n            {\\n                temp=names[i]+\\'(\\'+to_string(count)+\\')\\';\\n                count++;\\n            }\\n            names[i] = temp;\\n            mp[temp]=1;\\n        }\\n        return names;\\n    }\\n};\\n```\\n\\nTherefore you can store value in map for that string, so that if you encounter same string again, start from the value instead of checking all way from (1)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> mp;\\n        for(int i=0; i<names.size(); i++)\\n        {\\n            int count = 1;\\n            string temp=names[i];\\n            if(mp.find(temp)!=mp.end())\\n                count = mp[temp];\\n            while(mp.find(temp)!=mp.end())\\n            {\\n                temp=names[i]+\\'(\\'+to_string(count)+\\')\\';\\n                count++;\\n            }\\n            mp[names[i]] = count;\\n            names[i] = temp;\\n            mp[names[i]] = 1;\\n        }\\n        return names;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> mp;\\n        for(int i=0; i<names.size(); i++)\\n        {\\n            int count = 1;\\n            string temp=names[i];\\n            while(mp.find(temp)!=mp.end())\\n            {\\n                temp=names[i]+\\'(\\'+to_string(count)+\\')\\';\\n                count++;\\n            }\\n            names[i] = temp;\\n            mp[temp]=1;\\n        }\\n        return names;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> mp;\\n        for(int i=0; i<names.size(); i++)\\n        {\\n            int count = 1;\\n            string temp=names[i];\\n            if(mp.find(temp)!=mp.end())\\n                count = mp[temp];\\n            while(mp.find(temp)!=mp.end())\\n            {\\n                temp=names[i]+\\'(\\'+to_string(count)+\\')\\';\\n                count++;\\n            }\\n            mp[names[i]] = count;\\n            names[i] = temp;\\n            mp[names[i]] = 1;\\n        }\\n        return names;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646944,
                "title": "very-simple-python3-solution-using-hashmap-and-comments",
                "content": "Very simple and commented solution: \\n\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        # names : array of names\\n        # n : size of names\\n        \\n        # create folders at the i\\'th minute for each name = names[i]\\n        # If name was used previously, append a suffix \"(k)\" - note parenthesis - where k is the smallest pos int\\n        \\n        # return an array of strings where ans[i] is the actual saved variant of names[i]\\n        \\n        n = len(names)\\n        \\n        dictNames = {}\\n        ans = [\\'\\']*n\\n        \\n        # enumerate to grab index so we can return ans list in order\\n        for idx, name in enumerate(names):\\n            # check if we have seen this name before\\n            if name in dictNames:\\n                # if we have grab the next k using last successful low (k) suffix\\n                k = dictNames[name]\\n                # track the name we started so we can update the dict\\n                namestart = name\\n                # cycle through values of increasing k until we are not in a previously used name\\n                while name in dictNames:\\n                    name = namestart + f\"({k})\"\\n                    k += 1\\n                # update the name we started with to the new lowest value of k\\n                dictNames[namestart] = k\\n                # add the new name with k = 1 so if we see this name with the suffix\\n                dictNames[name] = 1\\n            else:\\n                # we havent seen this name so lets start with 1\\n                dictNames[name] = 1\\n            # build the solution\\n            ans[idx] = name\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        # names : array of names\\n        # n : size of names\\n        \\n        # create folders at the i\\'th minute for each name = names[i]\\n        # If name was used previously, append a suffix \"(k)\" - note parenthesis - where k is the smallest pos int\\n        \\n        # return an array of strings where ans[i] is the actual saved variant of names[i]\\n        \\n        n = len(names)\\n        \\n        dictNames = {}\\n        ans = [\\'\\']*n\\n        \\n        # enumerate to grab index so we can return ans list in order\\n        for idx, name in enumerate(names):\\n            # check if we have seen this name before\\n            if name in dictNames:\\n                # if we have grab the next k using last successful low (k) suffix\\n                k = dictNames[name]\\n                # track the name we started so we can update the dict\\n                namestart = name\\n                # cycle through values of increasing k until we are not in a previously used name\\n                while name in dictNames:\\n                    name = namestart + f\"({k})\"\\n                    k += 1\\n                # update the name we started with to the new lowest value of k\\n                dictNames[namestart] = k\\n                # add the new name with k = 1 so if we see this name with the suffix\\n                dictNames[name] = 1\\n            else:\\n                # we havent seen this name so lets start with 1\\n                dictNames[name] = 1\\n            # build the solution\\n            ans[idx] = name\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712905,
                "title": "python-70-faster-100-less-memory-use",
                "content": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        seen = {}\\n        arr = []\\n        for i in range(len(names)):\\n            if names[i] not in seen:\\n                seen[names[i]] = 1\\n                arr.append(names[i])\\n            else:\\n                n = seen[names[i]]\\n                new_name = names[i] + \"(\" + str(n) + \")\"\\n                while new_name in seen:\\n                    n += 1\\n                    new_name = names[i] + \"(\" + str(n) + \")\"\\n                arr.append(new_name)\\n                seen[names[i]] += 1\\n                seen[new_name] = 1\\n        \\n        return arr\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        seen = {}\\n        arr = []\\n        for i in range(len(names)):\\n            if names[i] not in seen:\\n                seen[names[i]] = 1\\n                arr.append(names[i])\\n            else:\\n                n = seen[names[i]]\\n                new_name = names[i] + \"(\" + str(n) + \")\"\\n                while new_name in seen:\\n                    n += 1\\n                    new_name = names[i] + \"(\" + str(n) + \")\"\\n                arr.append(new_name)\\n                seen[names[i]] += 1\\n                seen[new_name] = 1\\n        \\n        return arr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698393,
                "title": "c-solution-with-proper-explanation",
                "content": "This question is tricky. But we can solve it using unordered_maps. We will declare an unordered_map in which we will store a string and an integer which denotes the number of occurences of that string.\\n\\nWe start iterating over the array. We add our string to unordered_map and increase the count as mp[names[i]]++.\\nIf  the count is equal to 1, which signifies that we are ecountering that name for first time, so we add it as it is to our solution array. \\n\\nBut if they are appearing for greater than 1 time, we need to check whether the number we are gonna give it is not already present.\\n\\nFor e.g.: If string is orange and its count is 2 (appearing for second time) so naturally we we give it orange(1) which is by orange(count-1). But imagine if a file name is there with the name of orange(1), we need to name our\\'s as orange(2) so as to avoid the conflict.\\n\\nSo, we can see that the count is the lower possible value but value can be bigger and we need to check. So, we form the orange(1) and check for it in the map, if we get it we increase k by 1 and recheck it until it has become unique. So, for this we initialise k with count-1 since its the minimum possible value for the suffix.\\n\\nSo, after checking finally we form the required filename by appending the value of k as suffix in the prescirbed manner. Then we add that string to our answer array and add the new string to our unordered_map.\\n\\nAfter all this, we return the answer array. We have done it. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string>v;\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            mp[names[i]]++;\\n            if(mp[names[i]]==1)\\n                v.push_back(names[i]);\\n            else\\n            {\\n                int k=mp[names[i]]-1;\\n                while(true)\\n                {\\n                    string t = names[i]+\"(\"+to_string(k)+\")\";\\n                    if(mp.find(t)!=mp.end())\\n                        k++;\\n                    else\\n                        break;\\n                }\\n                string temp = names[i]+\"(\"+to_string(k)+\")\";\\n                v.push_back(temp);\\n                mp[temp]++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string>v;\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            mp[names[i]]++;\\n            if(mp[names[i]]==1)\\n                v.push_back(names[i]);\\n            else\\n            {\\n                int k=mp[names[i]]-1;\\n                while(true)\\n                {\\n                    string t = names[i]+\"(\"+to_string(k)+\")\";\\n                    if(mp.find(t)!=mp.end())\\n                        k++;\\n                    else\\n                        break;\\n                }\\n                string temp = names[i]+\"(\"+to_string(k)+\")\";\\n                v.push_back(temp);\\n                mp[temp]++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697863,
                "title": "c-using-only-dictionary",
                "content": "```csharp\\npublic string[] GetFolderNames(string[] names)\\n{\\n\\tstring[] result = new string[names.Length];       \\n\\tDictionary<string, int> suffixMap = new Dictionary<string, int>();\\n\\n\\tfor(int i = 0; i < names.Length; i++)\\n\\t{\\n\\t\\tstring name = names[i];\\n\\n\\t\\tif(suffixMap.ContainsKey(name))\\n\\t\\t{\\n\\t\\t\\tint next = suffixMap[name] + 1;\\n\\t\\t\\tname = $\"{names[i]}({next})\";\\n\\n\\t\\t\\twhile(suffixMap.ContainsKey(name))\\n\\t\\t\\t{\\n\\t\\t\\t\\tnext++;\\n\\t\\t\\t\\tname = $\"{names[i]}({next})\";                                       \\n\\t\\t\\t}\\n\\n\\t\\t\\tsuffixMap[names[i]] = next;\\n\\t\\t\\tsuffixMap[name] = 0;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tsuffixMap.Add(name, 0);                    \\n\\t\\t}\\n\\n\\t\\tresult[i] = name;\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic string[] GetFolderNames(string[] names)\\n{\\n\\tstring[] result = new string[names.Length];       \\n\\tDictionary<string, int> suffixMap = new Dictionary<string, int>();\\n\\n\\tfor(int i = 0; i < names.Length; i++)\\n\\t{\\n\\t\\tstring name = names[i];\\n\\n\\t\\tif(suffixMap.ContainsKey(name))\\n\\t\\t{\\n\\t\\t\\tint next = suffixMap[name] + 1;\\n\\t\\t\\tname = $\"{names[i]}({next})\";\\n\\n\\t\\t\\twhile(suffixMap.ContainsKey(name))\\n\\t\\t\\t{\\n\\t\\t\\t\\tnext++;\\n\\t\\t\\t\\tname = $\"{names[i]}({next})\";                                       \\n\\t\\t\\t}\\n\\n\\t\\t\\tsuffixMap[names[i]] = next;\\n\\t\\t\\tsuffixMap[name] = 0;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tsuffixMap.Add(name, 0);                    \\n\\t\\t}\\n\\n\\t\\tresult[i] = name;\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697814,
                "title": "c-just-map",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> getFolderNames(vector<string>& names) {\\n\\t\\t\\tunordered_map<string, int> mp;\\n\\t\\t\\tfor(int i = 0; i < names.size(); ++i){\\n\\t\\t\\t\\tif(mp.count(names[i])){\\n\\t\\t\\t\\t\\tstring tmp = names[i] + \"(\" + to_string(mp[names[i]]++)+\")\";\\n\\t\\t\\t\\t\\twhile(mp.count(tmp)){\\n\\t\\t\\t\\t\\t\\ttmp = names[i] + \"(\" + to_string(mp[names[i]]++)+\")\";\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnames[i] = tmp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmp[names[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn names;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> getFolderNames(vector<string>& names) {\\n\\t\\t\\tunordered_map<string, int> mp;\\n\\t\\t\\tfor(int i = 0; i < names.size(); ++i){\\n\\t\\t\\t\\tif(mp.count(names[i])){\\n\\t\\t\\t\\t\\tstring tmp = names[i] + \"(\" + to_string(mp[names[i]]++)+\")\";\\n\\t\\t\\t\\t\\twhile(mp.count(tmp)){\\n\\t\\t\\t\\t\\t\\ttmp = names[i] + \"(\" + to_string(mp[names[i]]++)+\")\";\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 697771,
                "title": "python3-solution-using-dictionary-with-comments",
                "content": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        # A map from each name to it\\'s latest count\\n\\t\\tnames_to_counter = {}\\n\\t\\t# List to store the result\\n\\t\\tres = []\\n        \\n        for name in names:\\n            new_name = name\\n\\t\\t\\t\\n\\t\\t\\t# Repeat as long as the name is already seen\\n\\t\\t\\t# E.g test case that the while loop handles -> [\"fname\", \"fname\", \"fname(1)\"]\\n            while new_name in names_to_counter:\\n\\t\\t\\t    # generate the new name and update its count\\n                new_name = name + \"(\" + str(names_to_counter[name]) + \")\"\\n                names_to_counter[name] += 1\\n            \\n\\t\\t\\tres.append(new_name)\\n\\t\\t\\t\\n\\t\\t\\t# Add the new name to the dictionary too,\\n\\t\\t\\t# so that if later down the list we see this name again, it can be handled\\n\\t\\t\\t# E.g. test case handled by this -> [\"fname\", \"fname\", \"fname(1)\"]\\n            names_to_counter[new_name] = 1\\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        # A map from each name to it\\'s latest count\\n\\t\\tnames_to_counter = {}",
                "codeTag": "Java"
            },
            {
                "id": 2580035,
                "title": "pyhton-simple-hashmaps-and-loops",
                "content": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        \\n        h = {}\\n        for i,name in enumerate(names):\\n            \\n            if name in h:\\n                k = h[name]\\n                while name + \"(\" + str(k) + \")\" in h:\\n                    k += 1\\n                names[i] = name + \"(\"+str(k)+\")\"\\n                h[name + \"(\"+str(k)+\")\"] = 1\\n                h[name] = k\\n            else:\\n                h[name] = 1\\n        return names",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        \\n        h = {}",
                "codeTag": "Java"
            },
            {
                "id": 1808348,
                "title": "java-o-n-unique-directory-creation",
                "content": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String,Integer> map = new HashMap<>();\\n        for(int i=0;i<names.length;i++){\\n            int prefix = map.getOrDefault(names[i],0);\\n            if(prefix != 0){\\n                String raw = names[i];\\n                while(map.getOrDefault(names[i],0) != 0){\\n                    names[i] = raw + \"(\" + prefix + \")\";\\n                    prefix++;\\n                }\\n                map.put(raw,prefix);\\n            }\\n            map.put(names[i],1);\\n        }\\n        return names;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String,Integer> map = new HashMap<>();\\n        for(int i=0;i<names.length;i++){\\n            int prefix = map.getOrDefault(names[i],0);\\n            if(prefix != 0){\\n                String raw = names[i];\\n                while(map.getOrDefault(names[i],0) != 0){\\n                    names[i] = raw + \"(\" + prefix + \")\";\\n                    prefix++;\\n                }\\n                map.put(raw,prefix);\\n            }\\n            map.put(names[i],1);\\n        }\\n        return names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793095,
                "title": "making-file-names-unique-c-fully-explained-code-by-deep-mukherjee",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        \\n        // You can understand the code by seeing explanation below\\n        \\n        unordered_map<string, int> mp;\\n        vector<string> res;\\n        \\n        for(auto i : names){\\n            string val = i;\\n            int cnt = mp[val];\\n            \\n            while(mp[val] != 0){\\n                val = i + \\'(\\' + to_string(cnt) + \\')\\';\\n\\t\\t\\t\\tcnt++;\\n                mp[i] = cnt;\\n\\t\\t\\t\\t   \\n            }\\n            mp[val]++;\\n            res.emplace_back(val);\\n        }\\n        return res;\\n        \\n        \\n        \\n        // For better Understanding Code explained Line by line\\n        \\n        // names = [\"d\", \"d(1)\", \"d(2)\", \"d\"]\\n        \\n        \\n        // running for loop\\n        // val = \"d\";\\n        // cnt = mp[val] = mp[\"d\"] = 0;\\n        // mp[val] = 0, so while loop not executed\\n        // mp[val]++ -> mp[\"d\"] = 0+1 = 1;\\n        // res = [\"d\"]\\n        \\n        // Same for \"d(1)\"\\n        // mp[\"d(1)\"] = 0+1 = 1;\\n        // res = [\"d\", \"d(1)\"]\\n        \\n        // Same for \"d(2)\"\\n        // mp[\"d(2)\"] = 0+1 = 1;\\n        // res = [\"d\", \"d(1)\", \"d(2)\"]\\n        \\n        // now, i = \"d\", val = \"d\";\\n        // cnt = mp[val] = mp[\"d\"] = 1, (appeared before)\\n        // while loop executed bcoz mp[val] = 1 which is greater than 0\\n        // In while loop,\\n        // cnt = 1+1 = 2;\\n        // val = i + \\'(\\' + to_string(cnt) + \\')\\' = \"d(2)\"\\n        // mp[i] = mp[\"d\"] = cnt = 2;\\n        \\n        // now mp[val] = mp[\"d(2)\"] = 1, (appeared before)\\n        // while loop executed bcoz mp[val] = 1 which is greater than 0\\n        // In while loop,\\n        // cnt = 2+1 = 3;\\n        // val = i + \\'(\\' + to_string(cnt) + \\')\\' = \"d(3)\"\\n        // mp[i] = mp[\"d\"] = cnt = 3;\\n        \\n        // now mp[val] = mp[\"d(3)\"] = 0\\n        // while loop closed\\n        // mp[val]++ = mp[\"d(3)\"] = 0+1 = 1;\\n        // res = [\"d\", \"d(1)\", \"d(2)\", \"d(3)\"]\\n        \\n        // now, return res;\\n    }\\n};\\n```\\n\\nUPVOTE PLEASE",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        \\n        // You can understand the code by seeing explanation below\\n        \\n        unordered_map<string, int> mp;\\n        vector<string> res;\\n        \\n        for(auto i : names){\\n            string val = i;\\n            int cnt = mp[val];\\n            \\n            while(mp[val] != 0){\\n                val = i + \\'(\\' + to_string(cnt) + \\')\\';\\n\\t\\t\\t\\tcnt++;\\n                mp[i] = cnt;\\n\\t\\t\\t\\t   \\n            }\\n            mp[val]++;\\n            res.emplace_back(val);\\n        }\\n        return res;\\n        \\n        \\n        \\n        // For better Understanding Code explained Line by line\\n        \\n        // names = [\"d\", \"d(1)\", \"d(2)\", \"d\"]\\n        \\n        \\n        // running for loop\\n        // val = \"d\";\\n        // cnt = mp[val] = mp[\"d\"] = 0;\\n        // mp[val] = 0, so while loop not executed\\n        // mp[val]++ -> mp[\"d\"] = 0+1 = 1;\\n        // res = [\"d\"]\\n        \\n        // Same for \"d(1)\"\\n        // mp[\"d(1)\"] = 0+1 = 1;\\n        // res = [\"d\", \"d(1)\"]\\n        \\n        // Same for \"d(2)\"\\n        // mp[\"d(2)\"] = 0+1 = 1;\\n        // res = [\"d\", \"d(1)\", \"d(2)\"]\\n        \\n        // now, i = \"d\", val = \"d\";\\n        // cnt = mp[val] = mp[\"d\"] = 1, (appeared before)\\n        // while loop executed bcoz mp[val] = 1 which is greater than 0\\n        // In while loop,\\n        // cnt = 1+1 = 2;\\n        // val = i + \\'(\\' + to_string(cnt) + \\')\\' = \"d(2)\"\\n        // mp[i] = mp[\"d\"] = cnt = 2;\\n        \\n        // now mp[val] = mp[\"d(2)\"] = 1, (appeared before)\\n        // while loop executed bcoz mp[val] = 1 which is greater than 0\\n        // In while loop,\\n        // cnt = 2+1 = 3;\\n        // val = i + \\'(\\' + to_string(cnt) + \\')\\' = \"d(3)\"\\n        // mp[i] = mp[\"d\"] = cnt = 3;\\n        \\n        // now mp[val] = mp[\"d(3)\"] = 0\\n        // while loop closed\\n        // mp[val]++ = mp[\"d(3)\"] = 0+1 = 1;\\n        // res = [\"d\", \"d(1)\", \"d(2)\", \"d(3)\"]\\n        \\n        // now, return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571148,
                "title": "python-using-hash",
                "content": "Every time we update the hash of names to the smallest k such that name(k) is a valid addition, we need to also add name(k) itself to the hash.\\n\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n\\n        cache=dict()\\n        output=[]\\n        \\n        for name in names:\\n            if name not in cache:\\n                output.append(name)\\n                cache[name]=1\\n            else:\\n                k=cache[name]\\n                while name+f\\'({k})\\' in cache:\\n                    k+=1\\n                new_name=name+f\\'({k})\\'\\n                output.append(new_name)\\n                cache[name]+=1\\n                cache[new_name]=1            \\n        \\n        return output\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n\\n        cache=dict()\\n        output=[]\\n        \\n        for name in names:\\n            if name not in cache:\\n                output.append(name)\\n                cache[name]=1\\n            else:\\n                k=cache[name]\\n                while name+f\\'({k})\\' in cache:\\n                    k+=1\\n                new_name=name+f\\'({k})\\'\\n                output.append(new_name)\\n                cache[name]+=1\\n                cache[new_name]=1            \\n        \\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390618,
                "title": "java-single-hashmap-beats-84-with-comments-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        String[] output = new String[names.length];\\n        \\n        for(int i=0; i<names.length; i++) {\\n            String s = names[i];\\n            // if we haven\\'t seen this string before, just add it in output\\n            if(!map.containsKey(s)) {\\n                map.put(s,1);\\n                output[i] = s;\\n                continue;\\n            }\\n            int k = map.get(s);\\n            String s1 = s + \"(\" + k + \")\";\\n            // if new string exists in the map, keep on incrementing k unless we find a k which is not previously used\\n            while(map.containsKey(s1)) {\\n                k++;\\n                s1 = s + \"(\" + k + \")\";\\n            }\\n            map.put(s1,1);\\n            map.put(s,k+1);\\n            output[i] = s1;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        String[] output = new String[names.length];\\n        \\n        for(int i=0; i<names.length; i++) {\\n            String s = names[i];\\n            // if we haven\\'t seen this string before, just add it in output\\n            if(!map.containsKey(s)) {\\n                map.put(s,1);\\n                output[i] = s;\\n                continue;\\n            }\\n            int k = map.get(s);\\n            String s1 = s + \"(\" + k + \")\";\\n            // if new string exists in the map, keep on incrementing k unless we find a k which is not previously used\\n            while(map.containsKey(s1)) {\\n                k++;\\n                s1 = s + \"(\" + k + \")\";\\n            }\\n            map.put(s1,1);\\n            map.put(s,k+1);\\n            output[i] = s1;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699519,
                "title": "python3-9-line-concise-solution",
                "content": "Algo \\nWhat\\'s needed here is just a dictionary with name to number mapping where number is the suffix to be added to the name should conflict occurr. \\n\\nAlso, I am utilizing the fact that dictionary is ordered in Python 3.6+. \\n\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        seen = {}\\n        for name in names: \\n            if name not in seen: seen[name] = 1\\n            else: \\n                k = seen[name]\\n                while (suffix := f\"{name}({k})\") in seen: k += 1\\n                seen[name] = k+1\\n                seen[suffix] = 1\\n        return seen.keys()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        seen = {}\\n        for name in names: \\n            if name not in seen: seen[name] = 1\\n            else: \\n                k = seen[name]\\n                while (suffix := f\"{name}({k})\") in seen: k += 1\\n                seen[name] = k+1\\n                seen[suffix] = 1\\n        return seen.keys()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699037,
                "title": "java-simple-hashmap",
                "content": "```\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> map = new HashMap<>();\\n        String[] res = new String[names.length];\\n        for (int i = 0; i < names.length; i++) {\\n            if (!map.containsKey(names[i])) {\\n                res[i] = names[i];\\n                map.put(res[i], 1);\\n                continue;\\n            }\\n            int cnt = map.get(names[i]);\\n            String add = names[i] + \"(\" + cnt + \")\";\\n            while (map.containsKey(add)) {\\n                cnt++;\\n                add = names[i] + \"(\" + cnt + \")\";\\n            }\\n            res[i] = add;\\n            map.put(add, 1);\\n            map.put(names[i], cnt + 1);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> map = new HashMap<>();\\n        String[] res = new String[names.length];\\n        for (int i = 0; i < names.length; i++) {\\n            if (!map.containsKey(names[i])) {\\n                res[i] = names[i];\\n                map.put(res[i], 1);\\n                continue;\\n            }\\n            int cnt = map.get(names[i]);\\n            String add = names[i] + \"(\" + cnt + \")\";\\n            while (map.containsKey(add)) {\\n                cnt++;\\n                add = names[i] + \"(\" + cnt + \")\";\\n            }\\n            res[i] = add;\\n            map.put(add, 1);\\n            map.put(names[i], cnt + 1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698065,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    var stringDict = [String: Int]()\\n    var results = [String]()\\n    \\n    func getFolderNames(_ names: [String]) -> [String] {\\n        if names.isEmpty { return [] }\\n        for name in names {\\n            if let nameVal = stringDict[name] {\\n                let newStr = addSuffix(name)\\n                results.append(newStr)\\n                stringDict[name] = nameVal + 1\\n                stringDict[newStr] = 1\\n            } else {\\n                results.append(name)\\n                stringDict[name] = 1\\n            }\\n        }\\n        return results\\n    }\\n    \\n    func addSuffix(_ name: String) -> String {\\n        if var nameVal = stringDict[name] {\\n            var newStr = name + \"(\\\\(nameVal))\"\\n            while stringDict[newStr] != nil {\\n                nameVal += 1\\n                newStr = name + \"(\\\\(nameVal))\"\\n            }\\n            return newStr\\n        }\\n        return name\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    var stringDict = [String: Int]()\\n    var results = [String]()\\n    \\n    func getFolderNames(_ names: [String]) -> [String] {\\n        if names.isEmpty { return [] }",
                "codeTag": "Java"
            },
            {
                "id": 697719,
                "title": "c-dictionary-solution",
                "content": "```\\npublic class Solution {\\n    public string[] GetFolderNames(string[] names) {\\n        \\n        List<string> res = new List<string>();\\n        if(names == null || names.Length == 0)\\n            return res.ToArray();\\n        \\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n        foreach(string str in names)\\n        {           \\n            if(!dic.ContainsKey(str))\\n            {\\n                dic.Add(str, 0);\\n                res.Add(str);\\n            }\\n            else\\n            {\\n                int suffix  = dic[str] + 1;\\n                \\n                // keep increasing suffix if the name has been used\\n                while(dic.ContainsKey(str + \"(\" + suffix + \")\"))\\n                   suffix++;\\n                \\n                // update the smallest positive integer for folder name \\'str\\' \\n                // to reduce the while loop operations when the next \\'str\\' occurs \\n                dic[str] = suffix;\\n                \\n                // add the new folder name to the dictionary\\n                string newName = str + \"(\" + suffix  + \")\"; \\n                res.Add(newName);\\n                dic.Add(newName, 0);\\n            }\\n        }\\n        \\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string[] GetFolderNames(string[] names) {\\n        \\n        List<string> res = new List<string>();\\n        if(names == null || names.Length == 0)\\n            return res.ToArray();\\n        \\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n        foreach(string str in names)\\n        {           \\n            if(!dic.ContainsKey(str))\\n            {\\n                dic.Add(str, 0);\\n                res.Add(str);\\n            }\\n            else\\n            {\\n                int suffix  = dic[str] + 1;\\n                \\n                // keep increasing suffix if the name has been used\\n                while(dic.ContainsKey(str + \"(\" + suffix + \")\"))\\n                   suffix++;\\n                \\n                // update the smallest positive integer for folder name \\'str\\' \\n                // to reduce the while loop operations when the next \\'str\\' occurs \\n                dic[str] = suffix;\\n                \\n                // add the new folder name to the dictionary\\n                string newName = str + \"(\" + suffix  + \")\"; \\n                res.Add(newName);\\n                dic.Add(newName, 0);\\n            }\\n        }\\n        \\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697706,
                "title": "javascript-100-beats-runtime",
                "content": "Understand Better, Please visit:\\nhttps://youtu.be/ERYkxar94bk?t=2\\n```\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nvar getFolderNames = function(names) {\\n    let words=new Map()\\n    for(let i=0;i<names.length;i++){\\n       if(!words.has(names[i])){\\n           words.set(names[i],0)\\n       }else{\\n           let n = words.get(names[i])\\n           n+=1\\n           let newWord = names[i] + `(${n})`\\n           while(true){\\n               if(words.has(newWord)){\\n                   n+=1\\n                   newWord = names[i] + `(${n})`\\n               }else{\\n                   break\\n               }\\n           }\\n           words.set(names[i],n)\\n           words.set(newWord,0) \\n           names[i] = newWord\\n       }\\n    }\\n    return names\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nvar getFolderNames = function(names) {\\n    let words=new Map()\\n    for(let i=0;i<names.length;i++){\\n       if(!words.has(names[i])){\\n           words.set(names[i],0)\\n       }else{\\n           let n = words.get(names[i])\\n           n+=1\\n           let newWord = names[i] + `(${n})`\\n           while(true){\\n               if(words.has(newWord)){\\n                   n+=1\\n                   newWord = names[i] + `(${n})`\\n               }else{\\n                   break\\n               }\\n           }\\n           words.set(names[i],n)\\n           words.set(newWord,0) \\n           names[i] = newWord\\n       }\\n    }\\n    return names\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938403,
                "title": "python-hashmap-beats-100-with-detailed-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSee comments\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee comments\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNote that the while loop will run at most k (occurence of name) times for each name so IN TOTAL at most O(n) times, which does not add to complexity\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        # map from name to current min k used for that name\\n        nameMinK = dict()   \\n        res = []\\n        for name in names:\\n            if name not in nameMinK:    # new name\\n                res.append(name)\\n                nameMinK[name] = 0\\n            else:   # already added name\\n                k = nameMinK[name] + 1\\n                tmp = name + \\'(\\' + str(k) + \\')\\'\\n                while tmp in nameMinK:\\n                    k += 1\\n                    tmp = name + \\'(\\' + str(k) + \\')\\'\\n                # try until tmp not in usedName => add AND update minK\\n                res.append(tmp)\\n                nameMinK[name] = k  # NOTE: very tricky here!!!, need to update both name & tmp\\n                nameMinK[tmp] = 0\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        # map from name to current min k used for that name\\n        nameMinK = dict()   \\n        res = []\\n        for name in names:\\n            if name not in nameMinK:    # new name\\n                res.append(name)\\n                nameMinK[name] = 0\\n            else:   # already added name\\n                k = nameMinK[name] + 1\\n                tmp = name + \\'(\\' + str(k) + \\')\\'\\n                while tmp in nameMinK:\\n                    k += 1\\n                    tmp = name + \\'(\\' + str(k) + \\')\\'\\n                # try until tmp not in usedName => add AND update minK\\n                res.append(tmp)\\n                nameMinK[name] = k  # NOTE: very tricky here!!!, need to update both name & tmp\\n                nameMinK[tmp] = 0\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691203,
                "title": "java-easy-100-solution",
                "content": "```java\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        final Map<String, Integer> uniqueNames = new HashMap<>();\\n\\n        for(int i = 0; i < names.length; ++i) {\\n            String file = names[i];\\n\\n            int count = uniqueNames.getOrDefault(file, 0);\\n\\n            while(uniqueNames.containsKey(file))\\n                file = names[i] + \"(\" + ++count + \")\";\\n\\n            uniqueNames.put(names[i], count);\\n            uniqueNames.put(file, 0);\\n            \\n            names[i] = file;\\n        }\\n\\n        return names;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        final Map<String, Integer> uniqueNames = new HashMap<>();\\n\\n        for(int i = 0; i < names.length; ++i) {\\n            String file = names[i];\\n\\n            int count = uniqueNames.getOrDefault(file, 0);\\n\\n            while(uniqueNames.containsKey(file))\\n                file = names[i] + \"(\" + ++count + \")\";\\n\\n            uniqueNames.put(names[i], count);\\n            uniqueNames.put(file, 0);\\n            \\n            names[i] = file;\\n        }\\n\\n        return names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280884,
                "title": "noob-solution-dpm07",
                "content": "\\n```\\nfrom typing import List\\n\\n\"\"\"\\n1487. Making File Names Unique\\n\\ncreate n folders in your file system such that, at the ith minute, U will create a folder with the name names[i].\\n\\nSince 2 files cannot have the same name,\\nif you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\\n\\nReturn an arr of str of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.\\n\\n\\nEX:\\n[\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\\nO/P -> [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\\n\\nEX:\\n[\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\\no/p: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\\n\\nEx:\\n[\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]\\no/p: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]\\n\"\"\"\\n\\n\\nclass Solution:\\n    \"\"\"\\n    if it\\'s already in the seen dictionary,\\n    append a suffix k to the name until a unique name is found.\\n\\n    Time: O(n^2) in the worst case where all file names are the same\\n    space: O(n)\\n    \"\"\"\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n\\n        ans = []  # stores unique file names\\n        seen = {}\\n\\n        for name in names:\\n            if name not in seen:\\n                ans.append(name)\\n                seen[name] = 1\\n            else:\\n                k = seen[name]\\n                # creating variants\\n                while True:\\n                    new_name = name + \\'(\\' + str(k) + \\')\\'\\n                    if new_name not in seen:\\n                        ans.append(new_name)\\n                        seen[new_name] = 1\\n                        break\\n                    else:\\n                        k += 1\\n\\n                # save the latest version of variant so to avaoid above while\\n                # loop calculation\\n                seen[name] = k\\n            \\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\n\"\"\"\\n1487. Making File Names Unique\\n\\ncreate n folders in your file system such that, at the ith minute, U will create a folder with the name names[i].\\n\\nSince 2 files cannot have the same name,\\nif you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\\n\\nReturn an arr of str of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.\\n\\n\\nEX:\\n[\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\\nO/P -> [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\\n\\nEX:\\n[\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\\no/p: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\\n\\nEx:\\n[\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]\\no/p: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]\\n\"\"\"\\n\\n\\nclass Solution:\\n    \"\"\"\\n    if it\\'s already in the seen dictionary,\\n    append a suffix k to the name until a unique name is found.\\n\\n    Time: O(n^2) in the worst case where all file names are the same\\n    space: O(n)\\n    \"\"\"\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n\\n        ans = []  # stores unique file names\\n        seen = {}\\n\\n        for name in names:\\n            if name not in seen:\\n                ans.append(name)\\n                seen[name] = 1\\n            else:\\n                k = seen[name]\\n                # creating variants\\n                while True:\\n                    new_name = name + \\'(\\' + str(k) + \\')\\'\\n                    if new_name not in seen:\\n                        ans.append(new_name)\\n                        seen[new_name] = 1\\n                        break\\n                    else:\\n                        k += 1\\n\\n                # save the latest version of variant so to avaoid above while\\n                # loop calculation\\n                seen[name] = k\\n            \\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696776,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<string> getFolderNames(vector<string>& names) {\\n    unordered_map<string,int>m;\\n    vector<string>ans;\\n    for(int i=0;i<names.size();i++){\\n      if(m.find(names[i])!=m.end())\\n       {\\n          int k = m[names[i]];\\n           string str;\\n          do{\\n           str = names[i]+\\'(\\';\\n          str += to_string(k);\\n              str += \\')\\';\\n            m[names[i]]++;\\n            k++;\\n          }\\n          while(m.find(str)!=m.end());\\n          m[str]++ ;\\n          ans.push_back(str);\\n       }\\n       else\\n       {\\n          m[names[i]]++;\\n          ans.push_back(names[i]);\\n       }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<string> getFolderNames(vector<string>& names) {\\n    unordered_map<string,int>m;\\n    vector<string>ans;\\n    for(int i=0;i<names.size();i++){\\n      if(m.find(names[i])!=m.end())\\n       {\\n          int k = m[names[i]];\\n           string str;\\n          do{\\n           str = names[i]+\\'(\\';\\n          str += to_string(k);\\n              str += \\')\\';\\n            m[names[i]]++;\\n            k++;\\n          }\\n          while(m.find(str)!=m.end());\\n          m[str]++ ;\\n          ans.push_back(str);\\n       }\\n       else\\n       {\\n          m[names[i]]++;\\n          ans.push_back(names[i]);\\n       }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581005,
                "title": "c-o-n-solution",
                "content": "**C++ Code:**\\n\\n**Method 1: O(n) Solution**\\n*NOTE : This Solutions seems to be O(n^2) but it is not.*\\n\\n```\\n vector<string> getFolderNames(vector<string>& names) {\\n    unordered_map<string,int>m;\\n    vector<string>ans;\\n    for(int i=0;i<names.size();i++){\\n      if(m.find(names[i])!=m.end())\\n       {\\n          int k = m[names[i]];\\n           string str;\\n          do{\\n           str = names[i]+\\'(\\';\\n          str += to_string(k);\\n              str += \\')\\';\\n            m[names[i]]++;\\n            k++;\\n          }\\n          while(m.find(str)!=m.end());\\n          m[str]++ ;\\n          ans.push_back(str);\\n       }\\n       else\\n       {\\n          m[names[i]]++;\\n          ans.push_back(names[i]);\\n       }\\n    }\\n    return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<string> getFolderNames(vector<string>& names) {\\n    unordered_map<string,int>m;\\n    vector<string>ans;\\n    for(int i=0;i<names.size();i++){\\n      if(m.find(names[i])!=m.end())\\n       {\\n          int k = m[names[i]];\\n           string str;\\n          do{\\n           str = names[i]+\\'(\\';\\n          str += to_string(k);\\n              str += \\')\\';\\n            m[names[i]]++;\\n            k++;\\n          }\\n          while(m.find(str)!=m.end());\\n          m[str]++ ;\\n          ans.push_back(str);\\n       }\\n       else\\n       {\\n          m[names[i]]++;\\n          ans.push_back(names[i]);\\n       }\\n    }\\n    return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2452183,
                "title": "java-code-following-the-hints",
                "content": "```\\npublic String[] getFolderNames(String[] names) {\\n        int currId = 0;\\n        String[] sol = new String[names.length];\\n        Map<String, Integer> nameMap = new HashMap<>();\\n\\n        for (String name : names) {\\n            String addStr;\\n            if (!nameMap.containsKey(name)) {\\n                nameMap.put(name, 1);\\n                addStr = name;\\n            } else {\\n                String str = name;\\n                int i = nameMap.get(str);\\n                while (nameMap.containsKey(str)) {\\n                    str = name + \\'(\\' + i + \\')\\';\\n                    i++;\\n                }\\n                \\n                addStr = str;\\n                nameMap.put(name, i);\\n                nameMap.put(addStr, 1);\\n            }\\n\\n//                System.out.println(\"nameMap: \" + nameMap);\\n            sol[currId++] = addStr;\\n        }\\n\\n        return sol;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String[] getFolderNames(String[] names) {\\n        int currId = 0;\\n        String[] sol = new String[names.length];\\n        Map<String, Integer> nameMap = new HashMap<>();\\n\\n        for (String name : names) {\\n            String addStr;\\n            if (!nameMap.containsKey(name)) {\\n                nameMap.put(name, 1);\\n                addStr = name;\\n            } else {\\n                String str = name;\\n                int i = nameMap.get(str);\\n                while (nameMap.containsKey(str)) {\\n                    str = name + \\'(\\' + i + \\')\\';\\n                    i++;\\n                }\\n                \\n                addStr = str;\\n                nameMap.put(name, i);\\n                nameMap.put(addStr, 1);\\n            }\\n\\n//                System.out.println(\"nameMap: \" + nameMap);\\n            sol[currId++] = addStr;\\n        }\\n\\n        return sol;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2309869,
                "title": "easiest-typescript-javascript-solution",
                "content": "The easiest TypeScript solution is\\n```\\nfunction getFolderNames(names: string[]): string[] {\\n  const reserved = new Set<string>();\\n\\n  return names.map((name) => {\\n    let k = 0;\\n    let possibleName = name;\\n    while (reserved.has(possibleName)) {\\n      k++;\\n      possibleName = `${name}(${k})`;\\n    }\\n\\n    reserved.add(possibleName);\\n    return possibleName;\\n  });\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Ordered Set"
                ],
                "code": "```\\nfunction getFolderNames(names: string[]): string[] {\\n  const reserved = new Set<string>();\\n\\n  return names.map((name) => {\\n    let k = 0;\\n    let possibleName = name;\\n    while (reserved.has(possibleName)) {\\n      k++;\\n      possibleName = `${name}(${k})`;\\n    }\\n\\n    reserved.add(possibleName);\\n    return possibleName;\\n  });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2220358,
                "title": "simple-python",
                "content": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        d ={}\\n        res = []\\n        \\n        for name in names:\\n            \\n            if name not in d:\\n                d[name] = 1\\n                res.append(name)\\n                \\n            else:\\n                num = d[name]\\n                new = name+\"(\"+str(num)+\")\"\\n                \\n                while new in d:\\n                    num+=1\\n                    new = name+\"(\"+str(num)+\")\"\\n                    \\n                res.append(new)\\n                d[name] = num+1\\n                d[new] = 1\\n                \\n        return (res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        d ={}\\n        res = []\\n        \\n        for name in names:\\n            \\n            if name not in d:\\n                d[name] = 1\\n                res.append(name)\\n                \\n            else:\\n                num = d[name]\\n                new = name+\"(\"+str(num)+\")\"\\n                \\n                while new in d:\\n                    num+=1\\n                    new = name+\"(\"+str(num)+\")\"\\n                    \\n                res.append(new)\\n                d[name] = num+1\\n                d[new] = 1\\n                \\n        return (res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186593,
                "title": "c-with-explanation",
                "content": "```\\n// my \"cnt\" map records how many times a filename has occured-1\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string,int>cnt;\\n        vector<string>ans;\\n        for(auto & i:names){\\n            // if the file name is unique till now\\n            if(cnt.count(i)==0){\\n                cnt[i]=0;\\n                ans.push_back(i);\\n            }\\n            else{\\n                // file name is not unique.\\n                while(true){\\n                    // so my next filename can be \"prevname(k)\"\\n                    int k=1+cnt[i];\\n                    string str=i+\"(\"+to_string(k)+\")\";\\n                    //check if this filename is  occupied or not if not then use it\\n                    if(cnt.count(str)==0){\\n                        // important :- we are searching for filename=i,and reached till this point so update the occurence of cnt[i] to avoid O(n*n) time complexity\\n                        cnt[i]=k;\\n                        cnt[str]=0;\\n                        ans.push_back(str);\\n                        break;\\n                    }\\n                    // if filename is already in use then try next value of k\\n                    cnt[i]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// my \"cnt\" map records how many times a filename has occured-1\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string,int>cnt;\\n        vector<string>ans;\\n        for(auto & i:names){\\n            // if the file name is unique till now\\n            if(cnt.count(i)==0){\\n                cnt[i]=0;\\n                ans.push_back(i);\\n            }\\n            else{\\n                // file name is not unique.\\n                while(true){\\n                    // so my next filename can be \"prevname(k)\"\\n                    int k=1+cnt[i];\\n                    string str=i+\"(\"+to_string(k)+\")\";\\n                    //check if this filename is  occupied or not if not then use it\\n                    if(cnt.count(str)==0){\\n                        // important :- we are searching for filename=i,and reached till this point so update the occurence of cnt[i] to avoid O(n*n) time complexity\\n                        cnt[i]=k;\\n                        cnt[str]=0;\\n                        ans.push_back(str);\\n                        break;\\n                    }\\n                    // if filename is already in use then try next value of k\\n                    cnt[i]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899412,
                "title": "super-clean-super-easy-super-fast-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n\\n        std::unordered_map<std::string, int> table;\\n        vector<std::string> result;\\n        result.reserve(names.size());\\n        \\n        for (std::string& name : names) {\\n            \\n            std::string crux = name;\\n            int i = table.count(name) ? table[name] : 0;\\n            \\n            while (table.count(name)) {\\n                name = crux + \"(\" + std::to_string(i) + \")\";\\n                i++;\\n            }\\n            \\n            table[crux] = i;\\n            table[name]++;\\n            result.push_back(name);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n\\n        std::unordered_map<std::string, int> table;\\n        vector<std::string> result;\\n        result.reserve(names.size());\\n        \\n        for (std::string& name : names) {\\n            \\n            std::string crux = name;\\n            int i = table.count(name) ? table[name] : 0;\\n            \\n            while (table.count(name)) {\\n                name = crux + \"(\" + std::to_string(i) + \")\";\\n                i++;\\n            }\\n            \\n            table[crux] = i;\\n            table[name]++;\\n            result.push_back(name);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800341,
                "title": "c-hashing-map",
                "content": "class Solution {\\npublic:\\n    \\n\\tvector<string> getFolderNames(vector<string>& s) {\\n        int n = s.size();\\n        unordered_map<string,int>m;\\n        int c;\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()){\\n                m[s[i]] = 1;\\n            }else{\\n                string t = s[i];\\n                c = m[s[i]]++;\\n                while(m.find(t)!=m.end()){\\n                    t = (s[i]+\"(\"+to_string(c)+\")\");\\n                    c++;\\n                }\\n                s[i] = t;\\n                m[s[i]] = 1;\\n            }\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tvector<string> getFolderNames(vector<string>& s) {\\n        int n = s.size();\\n        unordered_map<string,int>m;\\n        int c;\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()){\\n                m[s[i]] = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1634502,
                "title": "concise-python-java-o-n",
                "content": "This approach runs in O(NC) time and O(NC) space, where N is the number of words and C is the amount of characters in the longest word\\nFor each word, we have 2 cases\\n1. We haven\\'t seen it before. In that case, set map[word] = 1, verify we haven\\'t seen word(1) before. If we have, set map[word] = 2 and repeat\\n1. We have seen it before. Set map[word]++, verify we haven\\'t seen word(map[word]) before. If we have, map[word]++ and repeat\\n\\n**Python**\\n```\\ndef getFolderNames(self, names: List[str]) -> List[str]:\\n\\tindexMap = {}\\n\\tres = []\\n\\tfor word in names:\\n\\t\\tcurrentWord = word   \\n\\t\\twhile currentWord in indexMap:\\n\\t\\t\\tindexMap[word] += 1\\n\\t\\t\\tcurrentWord = f\"{word}({indexMap[word]})\"\\n\\t\\tindexMap[currentWord] = 0\\n\\t\\tres.append(currentWord)\\n\\treturn res\\n```\\n**Java**\\n```\\npublic String[] getFolderNames(String[] names) {\\n\\tMap<String, Integer> indexMap = new HashMap<>();\\n\\tString[] res = new String[names.length];\\n\\tfor (int i = 0; i < names.length; i++) {\\n\\t\\tString currentWord = names[i];\\n\\t\\twhile (indexMap.containsKey(currentWord)) {\\n\\t\\t\\tindexMap.put(names[i], indexMap.getOrDefault(names[i], 0) + 1);\\n\\t\\t\\tcurrentWord = names[i] + \"(\" + indexMap.get(names[i]) + \")\";\\n\\t\\t}\\n\\t\\tindexMap.put(currentWord, 0);\\n\\t\\tres[i] = currentWord;\\n\\t}\\n\\treturn res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndef getFolderNames(self, names: List[str]) -> List[str]:\\n\\tindexMap = {}\\n\\tres = []\\n\\tfor word in names:\\n\\t\\tcurrentWord = word   \\n\\t\\twhile currentWord in indexMap:\\n\\t\\t\\tindexMap[word] += 1\\n\\t\\t\\tcurrentWord = f\"{word}({indexMap[word]})\"\\n\\t\\tindexMap[currentWord] = 0\\n\\t\\tres.append(currentWord)\\n\\treturn res\\n```\n```\\npublic String[] getFolderNames(String[] names) {\\n\\tMap<String, Integer> indexMap = new HashMap<>();\\n\\tString[] res = new String[names.length];\\n\\tfor (int i = 0; i < names.length; i++) {\\n\\t\\tString currentWord = names[i];\\n\\t\\twhile (indexMap.containsKey(currentWord)) {\\n\\t\\t\\tindexMap.put(names[i], indexMap.getOrDefault(names[i], 0) + 1);\\n\\t\\t\\tcurrentWord = names[i] + \"(\" + indexMap.get(names[i]) + \")\";\\n\\t\\t}\\n\\t\\tindexMap.put(currentWord, 0);\\n\\t\\tres[i] = currentWord;\\n\\t}\\n\\treturn res;\\n    }\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1435236,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        String []ans= new String[names.length];\\n        Map<String,Integer>mp= new HashMap<>();\\n\\t\\t\\n        for(int i=0;i<names.length;i++) {\\n\\t\\t\\n            if(mp.containsKey(names[i])){\\n                Integer idx = mp.get(names[i]);\\n                StringBuilder sb = new StringBuilder(names[i]);\\n                sb.append(\\'(\\'); sb.append(idx); sb.append(\\')\\');\\n\\t\\t\\t\\t\\n                while(mp.containsKey(sb.toString())){\\n                    idx++;\\n                    sb = new StringBuilder(names[i]);\\n                    sb.append(\\'(\\'); sb.append(idx); sb.append(\\')\\');\\n                }\\n\\t\\t\\t\\t\\n                ans[i]=sb.toString();\\n                mp.put(sb.toString(),1);\\n                mp.put(names[i],idx+1);\\n            }\\n\\t\\t\\t\\n            else{\\n                ans[i]=names[i];\\n                mp.put(names[i],1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        String []ans= new String[names.length];\\n        Map<String,Integer>mp= new HashMap<>();\\n\\t\\t\\n        for(int i=0;i<names.length;i++) {\\n\\t\\t\\n            if(mp.containsKey(names[i])){\\n                Integer idx = mp.get(names[i]);\\n                StringBuilder sb = new StringBuilder(names[i]);\\n                sb.append(\\'(\\'); sb.append(idx); sb.append(\\')\\');\\n\\t\\t\\t\\t\\n                while(mp.containsKey(sb.toString())){\\n                    idx++;\\n                    sb = new StringBuilder(names[i]);\\n                    sb.append(\\'(\\'); sb.append(idx); sb.append(\\')\\');\\n                }\\n\\t\\t\\t\\t\\n                ans[i]=sb.toString();\\n                mp.put(sb.toString(),1);\\n                mp.put(names[i],idx+1);\\n            }\\n\\t\\t\\t\\n            else{\\n                ans[i]=names[i];\\n                mp.put(names[i],1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360218,
                "title": "straightforward-java-solution",
                "content": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> hmap = new HashMap<>();\\n        String[] output = new String[names.length];\\n        int i = 0;\\n        \\n        for(String str : names) {\\n            if(!hmap.containsKey(str)) {\\n                hmap.put(str, 0) ;\\n                output[i] = str;\\n            } else {\\n                int val = hmap.get(str);\\n                val = val + 1;\\n                String newStr = str + \"(\" + val + \")\"; \\n                while(hmap.containsKey(newStr)) {\\n                    val++;\\n                    newStr = str + \"(\" + val + \")\";\\n                }\\n                hmap.put(str, val);\\n                hmap.put(newStr, 0);\\n                output[i] = newStr;\\n            }\\n            i++;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> hmap = new HashMap<>();\\n        String[] output = new String[names.length];\\n        int i = 0;\\n        \\n        for(String str : names) {\\n            if(!hmap.containsKey(str)) {\\n                hmap.put(str, 0) ;\\n                output[i] = str;\\n            } else {\\n                int val = hmap.get(str);\\n                val = val + 1;\\n                String newStr = str + \"(\" + val + \")\"; \\n                while(hmap.containsKey(newStr)) {\\n                    val++;\\n                    newStr = str + \"(\" + val + \")\";\\n                }\\n                hmap.put(str, val);\\n                hmap.put(newStr, 0);\\n                output[i] = newStr;\\n            }\\n            i++;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282179,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n\\n        dic = collections.defaultdict(int)\\n        ret = []\\n        for i in names:\\n            if i in dic:\\n\\n                dic[i]+=1\\n                key = i+\"(\"+str(dic[i]-1)+\")\"\\n                \\n                while key in dic:\\n                    # saving total number of same name folders\\n                    dic[i]+=1\\n                    # check if this new number folderName(x) is in dic, \\n                    # if it is , need to increase the total same folder count by 1 in next itr\\n                    key = i+\"(\"+str(dic[i]-1)+\")\"\\n                # curr key is now not in the dic, set it to count 1\\n                # this is for the case of name(1) , then create anthoer name(1), second name(1) becomes name(1)(1)\\n                dic[key] = 1\\n                ret.append(i+\"(\"+str(dic[i]-1)+\")\")\\n            else:\\n                dic[i] = 1\\n                ret.append(i)\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n\\n        dic = collections.defaultdict(int)\\n        ret = []\\n        for i in names:\\n            if i in dic:\\n\\n                dic[i]+=1\\n                key = i+\"(\"+str(dic[i]-1)+\")\"\\n                \\n                while key in dic:\\n                    # saving total number of same name folders\\n                    dic[i]+=1\\n                    # check if this new number folderName(x) is in dic, \\n                    # if it is , need to increase the total same folder count by 1 in next itr\\n                    key = i+\"(\"+str(dic[i]-1)+\")\"\\n                # curr key is now not in the dic, set it to count 1\\n                # this is for the case of name(1) , then create anthoer name(1), second name(1) becomes name(1)(1)\\n                dic[key] = 1\\n                ret.append(i+\"(\"+str(dic[i]-1)+\")\")\\n            else:\\n                dic[i] = 1\\n                ret.append(i)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224189,
                "title": "straightforward-8-line-python",
                "content": "**Complexity:**\\nTime O(N)  \\nSpace O(N)\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        res = {}\\n        for i in names:\\n            candidate = i\\n            while candidate in res:\\n                candidate = i+f\\'({res[i]})\\'\\n                res[i] += 1\\n            res[candidate] = 1\\n        return list(res.keys())\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        res = {}\\n        for i in names:\\n            candidate = i\\n            while candidate in res:\\n                candidate = i+f\\'({res[i]})\\'\\n                res[i] += 1\\n            res[candidate] = 1\\n        return list(res.keys())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173242,
                "title": "java-hashmap",
                "content": "```\\n public static String[] getFolderNames(String[] names) {\\n\\n        HashMap<String, Integer> hm = new HashMap<>();\\n\\n        for (int i  = 0; i < names.length; i++) {\\n            String str  = names[i];\\n            if(hm.containsKey(str)){\\n                int count = hm.get(str);\\n                while (true) {\\n\\n                    String temp = str + \"(\" + count + \")\";\\n                    if (hm.containsKey(temp) == false) {\\n                        hm.put(str, count+1);\\n                        hm.put(temp,1);\\n                        names[i] = temp;\\n                        break;\\n                    }\\n                    else{\\n                        count++;\\n                    }\\n                }\\n            }\\n            else{\\n                hm.put(str, 1);\\n            }\\n        }\\n        return names;\\n\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public static String[] getFolderNames(String[] names) {\\n\\n        HashMap<String, Integer> hm = new HashMap<>();\\n\\n        for (int i  = 0; i < names.length; i++) {\\n            String str  = names[i];\\n            if(hm.containsKey(str)){\\n                int count = hm.get(str);\\n                while (true) {\\n\\n                    String temp = str + \"(\" + count + \")\";\\n                    if (hm.containsKey(temp) == false) {\\n                        hm.put(str, count+1);\\n                        hm.put(temp,1);\\n                        names[i] = temp;\\n                        break;\\n                    }\\n                    else{\\n                        count++;\\n                    }\\n                }\\n            }\\n            else{\\n                hm.put(str, 1);\\n            }\\n        }\\n        return names;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1169954,
                "title": "c-map-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> st;\\n        vector<string> ret;\\n        \\n        ret.reserve(names.size());\\n        \\n        for(auto name : names) {\\n            if(st.count(name) == 0) {\\n                st.insert({name, 1});\\n                ret.emplace_back(move(name));\\n                continue;\\n            }\\n            // try to reuse last number assigned to that string\\n            for(int num = st[name];; ++num) {\\n                auto newName = name + \"(\" + to_string(num) + \")\";\\n                if(st.count(newName) == 0) {\\n                    st.insert({newName, 1});\\n                    st[name] = num;\\n                    ret.emplace_back(move(newName));\\n                    break;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> st;\\n        vector<string> ret;\\n        \\n        ret.reserve(names.size());\\n        \\n        for(auto name : names) {\\n            if(st.count(name) == 0) {\\n                st.insert({name, 1});\\n                ret.emplace_back(move(name));\\n                continue;\\n            }\\n            // try to reuse last number assigned to that string\\n            for(int num = st[name];; ++num) {\\n                auto newName = name + \"(\" + to_string(num) + \")\";\\n                if(st.count(newName) == 0) {\\n                    st.insert({newName, 1});\\n                    st[name] = num;\\n                    ret.emplace_back(move(newName));\\n                    break;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967376,
                "title": "java-string-vs-arraylist-or-top-4-vs-tle",
                "content": "Nothing new here but I had struggled a lot.. this problem seems easy but that +200KB test case wasn\\'t, so I\\'d like to post about the speed difference between both codes.\\n* The use of StringBuilder makes no difference.\\n* On Eclipse array solution is ~60% faster, list.size is known so I suppose no time is wasted creating new bigger lists while calling list.add().\\n* You can\\'t have a method bigger than 65535 bytes. which is also the max size of a String.\\n\\n```\\nclass Solution {\\n            \\n    HashMap<String, Integer> count = new HashMap<String, Integer>();\\n\\t// List<String> list;\\n    \\n    public String[] getFolderNames(String[] names) {\\n        String[] toReturn = new String[names.length];   //list = new ArrayList<>(names.length);\\n        \\n        for(int i = 0; i< names.length; i++){\\n            if(count.get(names[i]) == null){\\n                toReturn[i] = names[i];                  //list.add(names[i]);\\n                count.put(names[i],0);\\n            }else{\\n                toReturn[i] = makeUnique(names[i],count.get(names[i]) ); //list.add(...)\\n            }\\n        }\\n        return toReturn;                                  //return list.toArray(new String[list.size()]);\\n    }    \\n    private String makeUnique(String name, int k){\\n        String sb = name+ \\'(\\' + (++k) + \\')\\';\\n        if(count.get(sb) != null){\\n             return makeUnique(name,k);\\n        }else{\\n            count.put(sb.toString(),0);\\n            count.put(name,k);\\n            return sb;\\n        }    \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n            \\n    HashMap<String, Integer> count = new HashMap<String, Integer>();\\n\\t// List<String> list;\\n    \\n    public String[] getFolderNames(String[] names) {\\n        String[] toReturn = new String[names.length];   //list = new ArrayList<>(names.length);\\n        \\n        for(int i = 0; i< names.length; i++){\\n            if(count.get(names[i]) == null){\\n                toReturn[i] = names[i];                  //list.add(names[i]);\\n                count.put(names[i],0);\\n            }else{\\n                toReturn[i] = makeUnique(names[i],count.get(names[i]) ); //list.add(...)\\n            }\\n        }\\n        return toReturn;                                  //return list.toArray(new String[list.size()]);\\n    }    \\n    private String makeUnique(String name, int k){\\n        String sb = name+ \\'(\\' + (++k) + \\')\\';\\n        if(count.get(sb) != null){\\n             return makeUnique(name,k);\\n        }else{\\n            count.put(sb.toString(),0);\\n            count.put(name,k);\\n            return sb;\\n        }    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954429,
                "title": "python-easy-and-simple-solution-brute-force-with-dict",
                "content": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        d={}\\n        for i,j in enumerate(names):\\n            d[j]=d.get(j,0)+1\\n            if d[j]>1:\\n                while names[i]+\"(\"+str(d[j]-1)+\")\" in d:\\n                    d[j]+=1\\n                names[i]=names[i]+\"(\"+str(d[j]-1)+\")\"\\n                d[names[i]]=1\\n        return names\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        d={}\\n        for i,j in enumerate(names):\\n            d[j]=d.get(j,0)+1\\n            if d[j]>1:\\n                while names[i]+\"(\"+str(d[j]-1)+\")\" in d:\\n                    d[j]+=1\\n                names[i]=names[i]+\"(\"+str(d[j]-1)+\")\"\\n                d[names[i]]=1\\n        return names\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881288,
                "title": "swift-solution-fast-than-100",
                "content": "620 ms, 22.5MB\\n```\\nclass Solution {\\n    func getFolderNames(_ names: [String]) -> [String] {\\n        var res: [String] = []\\n        var dict: [String: Int] = [:]\\n\\n        for s in names {\\n            if dict[s] == nil {\\n                dict[s] = 1\\n                res.append(s)\\n            } else {        \\n                for i in dict[s]!...res.count {\\n                    if dict[\"\\\\(s)(\\\\(i))\"] == nil {\\n                        dict[\"\\\\(s)(\\\\(i))\"] = 1\\n                        res.append(\"\\\\(s)(\\\\(i))\")\\n                        dict[s] = i\\n                        break\\n                    }\\n                }\\n            }\\n        }\\n        return res\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func getFolderNames(_ names: [String]) -> [String] {\\n        var res: [String] = []\\n        var dict: [String: Int] = [:]\\n\\n        for s in names {\\n            if dict[s] == nil {\\n                dict[s] = 1\\n                res.append(s)\\n            } else {        \\n                for i in dict[s]!...res.count {\\n                    if dict[\"\\\\(s)(\\\\(i))\"] == nil {\\n                        dict[\"\\\\(s)(\\\\(i))\"] = 1\\n                        res.append(\"\\\\(s)(\\\\(i))\")\\n                        dict[s] = i\\n                        break\\n                    }\\n                }\\n            }\\n        }\\n        return res\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877394,
                "title": "python3-solution-faster-than-99",
                "content": "Basically, the idea is to keep track of  how many times a name has already appeared. If we find a name that has appeared k > 0 times, then we assing the name \"name(k)\" to that file, and check wether that name is actually available or not. If it\\'s not, we look for the closest k value that hasn\\'t such that the name \"name(k)\" hasn\\'t been seen before. Once we find it, that will be the definitive name, and therefore we record that \"name(k)\" has been seen once. Also, we record that the original name has been seen _k_ times (so that if we find again, we can try with the name \"name(k)\" with a good chance that it will be unique). \\n\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        result = []\\n        \\n        name_count = {}\\n\\n        for name in names:\\n            k = name_count.get(name,0)\\n            \\n            fs_name = name\\n            \\n            if k > 0:\\n                \\n                while fs_name in name_count:\\n                    fs_name = f\"{name}({k})\"\\n                    k += 1\\n    \\n                name_count[fs_name] = 1\\n                name_count[name] = k\\n            else:\\n                name_count[name] = 1\\n                \\n            result.append(fs_name)\\n            \\n        return result\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        result = []\\n        \\n        name_count = {}\\n\\n        for name in names:\\n            k = name_count.get(name,0)\\n            \\n            fs_name = name\\n            \\n            if k > 0:\\n                \\n                while fs_name in name_count:\\n                    fs_name = f\"{name}({k})\"\\n                    k += 1\\n    \\n                name_count[fs_name] = 1\\n                name_count[name] = k\\n            else:\\n                name_count[name] = 1\\n                \\n            result.append(fs_name)\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822667,
                "title": "java-99-10-lines-hashmap",
                "content": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> mp = new HashMap();\\n        String[] ans = new String[names.length];\\n        for(int i=0;i<names.length;i++) {\\n            String base = names[i], key = base;\\n            int j=mp.getOrDefault(key,1);\\n            while(mp.containsKey(key))\\n                key = base+\"(\"+(j++)+\")\";\\n            mp.put(base,j);\\n            mp.put(key,1);\\n            ans[i] = key;\\n        }\\n     return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> mp = new HashMap();\\n        String[] ans = new String[names.length];\\n        for(int i=0;i<names.length;i++) {\\n            String base = names[i], key = base;\\n            int j=mp.getOrDefault(key,1);\\n            while(mp.containsKey(key))\\n                key = base+\"(\"+(j++)+\")\";\\n            mp.put(base,j);\\n            mp.put(key,1);\\n            ans[i] = key;\\n        }\\n     return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744184,
                "title": "beginner-friendly-easy-to-understand-with-dry-running-o-n-75-time-100-mem",
                "content": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        cache={}\\n        ans=[]\\n        for s in names:\\n            if s not in cache:\\n                #seen.add(s)\\n                cache[s]=1\\n                ans.append(s)\\n            else:\\n                i=cache[s]\\n                while s+\"(\"+str(i)+\")\" in cache:\\n                    i+=1\\n                string=s+\"(\"+str(i)+\")\"\\n                #.add(string)\\n                ans.append(string)\\n                cache[s]=i+1\\n                cache[string]=1\\n        return ans\\n                    \\n                \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        cache={}\\n        ans=[]\\n        for s in names:\\n            if s not in cache:\\n                #seen.add(s)\\n                cache[s]=1\\n                ans.append(s)\\n            else:\\n                i=cache[s]\\n                while s+\"(\"+str(i)+\")\" in cache:\\n                    i+=1\\n                string=s+\"(\"+str(i)+\")\"\\n                #.add(string)\\n                ans.append(string)\\n                cache[s]=i+1\\n                cache[string]=1\\n        return ans\\n                    \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 718108,
                "title": "java-solution-using-hashmap-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        int n = names.length;\\n        Map<String, Integer> map = new HashMap<>();\\n        String[] res = new String[n];\\n        for (int i = 0; i < n; i++) {\\n            String s = names[i];\\n            if (map.containsKey(s)) {\\n                int index = map.get(s);\\n                while (map.containsKey(s + \"(\" + index + \")\")) {\\n                    index++;\\n                }\\n                map.put(s + \"(\" + index + \")\", 1);\\n                map.put(s, index + 1);\\n                res[i] = s + \"(\" + index + \")\";\\n            } else {\\n                map.put(s, 1);\\n                res[i] = s;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        int n = names.length;\\n        Map<String, Integer> map = new HashMap<>();\\n        String[] res = new String[n];\\n        for (int i = 0; i < n; i++) {\\n            String s = names[i];\\n            if (map.containsKey(s)) {\\n                int index = map.get(s);\\n                while (map.containsKey(s + \"(\" + index + \")\")) {\\n                    index++;\\n                }\\n                map.put(s + \"(\" + index + \")\", 1);\\n                map.put(s, index + 1);\\n                res[i] = s + \"(\" + index + \")\";\\n            } else {\\n                map.put(s, 1);\\n                res[i] = s;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704595,
                "title": "very-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> map;\\n        vector<string> out;\\n   \\n        \\n        for(int i=0; i<names.size(); i++){\\n            if(map.count(names[i])==0){\\n                map[names[i]]=0;\\n                out.push_back(names[i]);\\n            } else{\\n                map[names[i]]++;\\n\\n                int k = map[names[i]];\\n               \\n                string name = names[i]+\"(\"+to_string(k)+\")\";\\n               \\n                while(map.count(name)!=0){\\n                    k++;\\n\\n                    name = names[i]+\"(\"+to_string(k)+\")\";\\n                }\\n                map[name]=0;\\n                out.push_back(name);\\n            }\\n        }\\n    \\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> map;\\n        vector<string> out;\\n   \\n        \\n        for(int i=0; i<names.size(); i++){\\n            if(map.count(names[i])==0){\\n                map[names[i]]=0;\\n                out.push_back(names[i]);\\n            } else{\\n                map[names[i]]++;\\n\\n                int k = map[names[i]];\\n               \\n                string name = names[i]+\"(\"+to_string(k)+\")\";\\n               \\n                while(map.count(name)!=0){\\n                    k++;\\n\\n                    name = names[i]+\"(\"+to_string(k)+\")\";\\n                }\\n                map[name]=0;\\n                out.push_back(name);\\n            }\\n        }\\n    \\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702044,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nNaive solution which generates candidates.  While a candidate has been `seen`, increment the and append the `(k)` count, then push the first unseen candidate onto the answer and mark that candidate as `seen`.\\n\\n**Note:** This solution is AC in Javascript, but TLE in C++\\n\\n*Javascript*\\n```\\nlet getFolderNames = (A, seen = new Set(), ans = []) => {\\n    for (let s of A) {\\n        let cand = s,\\n            cnt = 0;\\n        while (seen.has(cand))\\n            cand = `${s}(${++cnt})`;\\n        ans.push(cand);\\n        seen.add(cand);\\n    }\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    VS getFolderNames(VS& A, Set seen = {}, VS ans = {}) {\\n        for (auto& s: A) {\\n            auto cand{ s };\\n            auto cnt{ 0 };\\n            while (seen.find(cand) != seen.end())\\n                cand = s + \"(\" + to_string(++cnt) + \")\";\\n            ans.push_back(cand);\\n            seen.insert(cand);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet getFolderNames = (A, seen = new Set(), ans = []) => {\\n    for (let s of A) {\\n        let cand = s,\\n            cnt = 0;\\n        while (seen.has(cand))\\n            cand = `${s}(${++cnt})`;\\n        ans.push(cand);\\n        seen.add(cand);\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    VS getFolderNames(VS& A, Set seen = {}, VS ans = {}) {\\n        for (auto& s: A) {\\n            auto cand{ s };\\n            auto cnt{ 0 };\\n            while (seen.find(cand) != seen.end())\\n                cand = s + \"(\" + to_string(++cnt) + \")\";\\n            ans.push_back(cand);\\n            seen.insert(cand);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700423,
                "title": "c-solution-with-explanation",
                "content": "1. Main idea is to keep track which folder name we are taking now and how many times we are taking till this index.\\n2. Therefore we will use C++ map for storing how many times we are taking this name till now.\\n\\n3. If we didn\\'t write a folder with the i-th name before, then we can push this name to the answer array (name vector -v in my code). Then increase its usage by 1 time.\\n\\n4. Else if we used this name before then, we will add the last usage value of this name in the last. Then increase the value of the name by 1 in our map. after adding the value, we get a new name. but also we have to check if this new name is also used or not. if it is already used before this index, we have to find a unique name through a loop. (while loop in my code).\\n\\n**Important :**\\n\\n5. Remember when we add a usage value of a name in the last of this name, we get a new name as well as a new string. so each time we must push this new name in the map with a new usage value also.  \\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        map<string,int>mp;\\n        vector<string>v;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            if(mp.find(names[i])==mp.end())\\n            {\\n                v.push_back(names[i]);\\n                mp[names[i]]++;\\n            }\\n            else\\n                \\n            {\\n                string pp = names[i];\\n                pp+=\\'(\\';\\n                pp+=to_string(mp[names[i]]);\\n                pp+=\\')\\';\\n                mp[names[i]]++;\\n                while(mp.find(pp)!=mp.end())\\n                {\\n                    pp = names[i];\\n                    pp+=\\'(\\';\\n                    pp+=to_string(mp[names[i]]);\\n                    pp+=\\')\\';\\n                    mp[names[i]]++;\\n                }\\n                v.push_back(pp);\\n                mp[pp]++;\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        map<string,int>mp;\\n        vector<string>v;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            if(mp.find(names[i])==mp.end())\\n            {\\n                v.push_back(names[i]);\\n                mp[names[i]]++;\\n            }\\n            else\\n                \\n            {\\n                string pp = names[i];\\n                pp+=\\'(\\';\\n                pp+=to_string(mp[names[i]]);\\n                pp+=\\')\\';\\n                mp[names[i]]++;\\n                while(mp.find(pp)!=mp.end())\\n                {\\n                    pp = names[i];\\n                    pp+=\\'(\\';\\n                    pp+=to_string(mp[names[i]]);\\n                    pp+=\\')\\';\\n                    mp[names[i]]++;\\n                }\\n                v.push_back(pp);\\n                mp[pp]++;\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700043,
                "title": "python-accepted-solution-with-ordereddict-and-defaultdict",
                "content": "The idea is the same as in other solutions. I just use defaultdict and OrderedDict.\\nAs the LC judge just iterates through the result I can return the result as OrderedDict.\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        cnt, res = defaultdict(lambda: 1), OrderedDict()\\n        for name in names:\\n            if name not in res:\\n                res[name] = True\\n            else:\\n                while name + \\'({})\\'.format(cnt[name]) in res:\\n                    cnt[name] += 1\\n                res[name + \\'({})\\'.format(cnt[name])] = True\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        cnt, res = defaultdict(lambda: 1), OrderedDict()\\n        for name in names:\\n            if name not in res:\\n                res[name] = True\\n            else:\\n                while name + \\'({})\\'.format(cnt[name]) in res:\\n                    cnt[name] += 1\\n                res[name + \\'({})\\'.format(cnt[name])] = True\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699713,
                "title": "c-simple-solution-with-comments-beats-95-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> um;\\n        vector<string> result;\\n        \\n        for (auto name : names) {\\n            if (!um.count(name)) {\\n                // for a new name, next possible k value is 1\\n                um[name] = 1; \\n                result.push_back(name);\\n                continue;\\n            }\\n            \\n            // We reach here when current name is not unique\\n            \\n            string temp = name + \"(\";\\n            string candidate = \"\";\\n            \\n            // get next possible k value for current name\\n            int k = um[name]; \\n            \\n            while (true) {\\n                candidate = temp + to_string(k) + \")\";\\n                if (!um.count(candidate)) {\\n                    // we have found a valid candidate. Break out of the loop\\n                    break;\\n                }\\n                // current candidate name already exits. Increment k and try again in next iteraton\\n                k++;\\n            }\\n            \\n            // set the next possible k value for current name\\n            um[name] = k+1;\\n            \\n            // add the new candidate to hash map and set its k to 1\\n            um[candidate] = 1;\\n            \\n            result.push_back(candidate);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n**Concise:**\\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> um;\\n        vector<string> result;\\n        \\n        for (auto name : names) {\\n            if (!um.count(name)) {\\n                um[name] = 1; \\n                result.push_back(name);\\n                continue;\\n            }\\n            \\n            string temp = name + \"(\";\\n            int k = um[name]; \\n            string candidate = temp + to_string(k) + \")\";          \\n            \\n            while (um.count(candidate))\\n                candidate = temp + to_string(++k) + \")\";\\n            \\n            um[name] = k+1;\\n            um[candidate] = 1;\\n            result.push_back(candidate);\\n        }\\n\\t\\t\\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> um;\\n        vector<string> result;\\n        \\n        for (auto name : names) {\\n            if (!um.count(name)) {\\n                // for a new name, next possible k value is 1\\n                um[name] = 1; \\n                result.push_back(name);\\n                continue;\\n            }\\n            \\n            // We reach here when current name is not unique\\n            \\n            string temp = name + \"(\";\\n            string candidate = \"\";\\n            \\n            // get next possible k value for current name\\n            int k = um[name]; \\n            \\n            while (true) {\\n                candidate = temp + to_string(k) + \")\";\\n                if (!um.count(candidate)) {\\n                    // we have found a valid candidate. Break out of the loop\\n                    break;\\n                }\\n                // current candidate name already exits. Increment k and try again in next iteraton\\n                k++;\\n            }\\n            \\n            // set the next possible k value for current name\\n            um[name] = k+1;\\n            \\n            // add the new candidate to hash map and set its k to 1\\n            um[candidate] = 1;\\n            \\n            result.push_back(candidate);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699234,
                "title": "accepted-java-solution-hashmap",
                "content": "This question was pretty frustating because of the poor description, but pretty smart question in terms of working on time complexity.\\n\\n```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(int i = 0; i < names.length; i++) {\\n            if(map.containsKey(names[i])) {\\n                int temp = map.get(names[i]);\\n                if(temp == 0) temp += 1;\\n                while(map.containsKey(names[i] + \"(\"+ temp +\")\")) {\\n                    temp++;\\n                }\\n                map.put(names[i], temp);\\n                map.put(names[i] + \"(\" +temp +\")\", 0);\\n                names[i] = names[i] + \"(\"+ (temp) +\")\";\\n            } else {\\n                map.put(names[i], 0);\\n            }\\n        }\\n        return names;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(int i = 0; i < names.length; i++) {\\n            if(map.containsKey(names[i])) {\\n                int temp = map.get(names[i]);\\n                if(temp == 0) temp += 1;\\n                while(map.containsKey(names[i] + \"(\"+ temp +\")\")) {\\n                    temp++;\\n                }\\n                map.put(names[i], temp);\\n                map.put(names[i] + \"(\" +temp +\")\", 0);\\n                names[i] = names[i] + \"(\"+ (temp) +\")\";\\n            } else {\\n                map.put(names[i], 0);\\n            }\\n        }\\n        return names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698292,
                "title": "one-map-javascript-solution-160-ms",
                "content": "```\\nvar getFolderNames = function(names) {\\n    const map = new Map();\\n    let count;\\n    let key;\\n    \\n    for (let i = 0; i < names.length; ++i) {\\n        count = map.get(names[i]);\\n        if (count === undefined) {\\n            map.set(names[i], 0);\\n        } else {\\n            while (true) {\\n                key = `${names[i]}(${++count})`;\\n                if (map.get(key) === undefined) {\\n                    map.set(names[i], count);\\n                    map.set(key, 0);\\n                    names[i] = key;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return names;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar getFolderNames = function(names) {\\n    const map = new Map();\\n    let count;\\n    let key;\\n    \\n    for (let i = 0; i < names.length; ++i) {\\n        count = map.get(names[i]);\\n        if (count === undefined) {\\n            map.set(names[i], 0);\\n        } else {\\n            while (true) {\\n                key = `${names[i]}(${++count})`;\\n                if (map.get(key) === undefined) {\\n                    map.set(names[i], count);\\n                    map.set(key, 0);\\n                    names[i] = key;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return names;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698104,
                "title": "simple-java-hashmap-solution",
                "content": "class Solution {\\n    public String[] getFolderNames(String[] names) {\\n     String[] output = new String[names.length];\\n    List<String> list = new ArrayList<>();\\n        Map<String,Integer> map = new HashMap<>();        \\n        for(String s : names)\\n        {\\n            map.put(s,map.getOrDefault(s,-1)+1);   \\n            \\n            outer :{\\n            if(map.get(s)!=0)\\n            {\\n                StringBuilder sb = new StringBuilder(s);\\n                sb.append(\"(\");\\n                int count = map.get(s);\\n                sb.append(map.get(s));\\n                sb.append(\")\");\\n                String fileName = sb.toString();                \\n                while(map.containsKey(fileName)){\\n                    String bracket = \"(\"+count+\")\";\\n                    count=count+1;\\n                    int index = fileName.lastIndexOf(\"(\");\\n                    fileName = fileName.substring(0,index+1)+count+\")\";\\n                }\\n                map.put(fileName,map.getOrDefault(fileName,-1)+1);\\n                list.add(fileName);\\n            }\\n            else\\n                list.add(s);           \\n                   }\\n        }\\n        for(int i=0;i<list.size();i++)\\n                output[i]=list.get(i);\\n        return output;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String[] getFolderNames(String[] names) {\\n     String[] output = new String[names.length];\\n    List<String> list = new ArrayList<>();\\n        Map<String,Integer> map = new HashMap<>();        \\n        for(String s : names)\\n        {\\n            map.put(s,map.getOrDefault(s,-1)+1);   \\n            \\n            outer :{\\n            if(map.get(s)!=0)\\n            {\\n                StringBuilder sb = new StringBuilder(s);\\n                sb.append(\"(\");\\n                int count = map.get(s);\\n                sb.append(map.get(s));\\n                sb.append(\")\");\\n                String fileName = sb.toString();                \\n                while(map.containsKey(fileName)){\\n                    String bracket = \"(\"+count+\")\";\\n                    count=count+1;\\n                    int index = fileName.lastIndexOf(\"(\");\\n                    fileName = fileName.substring(0,index+1)+count+\")\";\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 697915,
                "title": "java-short-map-solution",
                "content": "Time Complexity O(N)\\n```\\n    public String[] getFolderNames(String[] names) {\\n        int n = names.length;\\n        Map<String, Integer> cnt = new HashMap();\\n        String[] res = new String[n];\\n        for (int i = 0; i < n; i++) {\\n            String s = names[i];\\n            if (!cnt.containsKey(s)) {\\n                cnt.put(s, 1);\\n                res[i] = s;\\n            } else {\\n                int c = cnt.get(s);\\n                String new_s = s + \"(\" + c + \")\";\\n                while (cnt.containsKey(new_s)) {\\n                    new_s = s + \"(\" + (++c) + \")\";\\n                }\\n                res[i] = new_s;\\n                cnt.put(new_s, 1);\\n                cnt.put(s, cnt.get(s) + 1);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Time Complexity O(N)\\n```\\n    public String[] getFolderNames(String[] names) {\\n        int n = names.length;\\n        Map<String, Integer> cnt = new HashMap();\\n        String[] res = new String[n];\\n        for (int i = 0; i < n; i++) {\\n            String s = names[i];\\n            if (!cnt.containsKey(s)) {\\n                cnt.put(s, 1);\\n                res[i] = s;\\n            } else {\\n                int c = cnt.get(s);\\n                String new_s = s + \"(\" + c + \")\";\\n                while (cnt.containsKey(new_s)) {\\n                    new_s = s + \"(\" + (++c) + \")\";\\n                }\\n                res[i] = new_s;\\n                cnt.put(new_s, 1);\\n                cnt.put(s, cnt.get(s) + 1);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 697870,
                "title": "java-solution-100-in-time-and-space",
                "content": "```\\npublic String[] getFolderNames(String[] names) {\\n        \\n        int len = names.length;\\n        String res[] = new String[len];\\n        Map<String, Integer> hashmap = new HashMap<String, Integer>();\\n        \\n        for(int i=0; i<len; i++){\\n            \\n            String str = names[i];\\n            if(!hashmap.containsKey(str)){\\n                res[i] = str;\\n                hashmap.put(str, 1);\\n            }else{\\n                int number = hashmap.get(str);\\n                String tempString = str;\\n                while(hashmap.containsKey(tempString)){\\n                    tempString = str + \"(\" + String.valueOf(number) + \")\";\\n                    number++;\\n                }\\n                res[i] = str + \"(\" + String.valueOf(number-1) + \")\";\\n                hashmap.put(str, number);\\n                hashmap.put(res[i], 1);\\n            }\\n            \\n        }\\n        return res;\\n    }\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic String[] getFolderNames(String[] names) {\\n        \\n        int len = names.length;\\n        String res[] = new String[len];\\n        Map<String, Integer> hashmap = new HashMap<String, Integer>();\\n        \\n        for(int i=0; i<len; i++){\\n            \\n            String str = names[i];\\n            if(!hashmap.containsKey(str)){\\n                res[i] = str;\\n                hashmap.put(str, 1);\\n            }else{\\n                int number = hashmap.get(str);\\n                String tempString = str;\\n                while(hashmap.containsKey(tempString)){\\n                    tempString = str + \"(\" + String.valueOf(number) + \")\";\\n                    number++;\\n                }\\n                res[i] = str + \"(\" + String.valueOf(number-1) + \")\";\\n                hashmap.put(str, number);\\n                hashmap.put(res[i], 1);\\n            }\\n            \\n        }\\n        return res;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697847,
                "title": "cpp-solution",
                "content": "// Runtime: 1088 ms\\n// Memory Usage: 66.2 MB\\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        //gta gta gta gta(1) \\n        //gta gta(1) gta(2) gta(1)(1)\\n        unordered_map<string,int> u;\\n        int i;\\n        vector<string> output;\\n        for(i = 0; i < names.size(); i++){\\n            string temp = names[i];\\n            if(u.find(temp) != u.end()){\\n                int count = u[temp];\\n                string suffix = \"(\" + to_string(count) + \")\";\\n                cout<<u[temp+suffix]<<endl;\\n                while(u[temp+suffix] != 0){\\n                    count++;\\n                    suffix = \"(\" + to_string(count) + \")\";\\n                }\\n                output.push_back(temp+suffix);\\n                u[temp+suffix] ++;//gta(1) -> 1\\n                u[temp] = count;//gta -> 2\\n            }else{\\n                output.push_back(temp);\\n                u[temp]++;//gta -> 1\\n            }\\n        }\\n        return output;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        //gta gta gta gta(1) \\n        //gta gta(1) gta(2) gta(1)(1)\\n        unordered_map<string,int> u;\\n        int i;\\n        vector<string> output;\\n        for(i = 0; i < names.size(); i++){\\n            string temp = names[i];\\n            if(u.find(temp) != u.end()){\\n                int count = u[temp];\\n                string suffix = \"(\" + to_string(count) + \")\";\\n                cout<<u[temp+suffix]<<endl;\\n                while(u[temp+suffix] != 0){\\n                    count++;\\n                    suffix = \"(\" + to_string(count) + \")\";\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 697787,
                "title": "simple-python-dictionary-map",
                "content": "For every name, we increment in the map regardless of (1) (2) etc.\\n\\nThen after we finished our initial addition of (n) to the answer, we do a while loop to check if the answer is in map or not.\\n\\nFinally, don\\'t forget to add our answer to the map / dictionary itself\\n\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        di = {}\\n        for i, b in enumerate(names):\\n            di[b] = di.get(b,0)+1\\n            if(di[b] > 1):\\n                holder = names[i]+\"(\" + str(di[names[i]]-1) + \")\"\\n                cnt = di[names[i]]-1\\n                while holder in di:\\n                    holder = names[i]+\"(\" + str(cnt) + \")\"\\n                    cnt += 1\\n                names[i] = holder\\n                di[holder] = di.get(holder, 0) + 1\\n        return names\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        di = {}\\n        for i, b in enumerate(names):\\n            di[b] = di.get(b,0)+1\\n            if(di[b] > 1):\\n                holder = names[i]+\"(\" + str(di[names[i]]-1) + \")\"\\n                cnt = di[names[i]]-1\\n                while holder in di:\\n                    holder = names[i]+\"(\" + str(cnt) + \")\"\\n                    cnt += 1\\n                names[i] = holder\\n                di[holder] = di.get(holder, 0) + 1\\n        return names\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697765,
                "title": "python-simple-solution",
                "content": "Dictionary m used to keep track of what the number should be after the file. Without it, the solution is also correct, but times out. Set used is to keep track of what filenames are already taken. If a filename appears in used it is added to the dictionary m with the number 1 as the value. If its also already in the dictionary, the value is incremented.  Linear time. \\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        used=set()\\n        m={}\\n        ans=[]\\n        for name in names:\\n            if name not in used:\\n                used.add(name)\\n                ans.append(name)\\n            else:\\n                i=1\\n                if name in m:\\n                    i= m[name]\\n                while name+\"(\"+str(i)+\")\" in used:\\n                    m[name]=i+1\\n                    i+=1\\n                used.add(name+\"(\"+str(i)+\")\")\\n                ans.append(name+\"(\"+str(i)+\")\")\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        used=set()\\n        m={}\\n        ans=[]\\n        for name in names:\\n            if name not in used:\\n                used.add(name)\\n                ans.append(name)\\n            else:\\n                i=1\\n                if name in m:\\n                    i= m[name]\\n                while name+\"(\"+str(i)+\")\" in used:\\n                    m[name]=i+1\\n                    i+=1\\n                used.add(name+\"(\"+str(i)+\")\")\\n                ans.append(name+\"(\"+str(i)+\")\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697760,
                "title": "my-python-solution",
                "content": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        used = collections.defaultdict(bool)\\n        times = collections.defaultdict(int)\\n        res = []\\n        for k,v in enumerate(names):\\n            if not used[v]:\\n                # not used \\n                res.append(v)\\n                used[v] = True\\n                times[v] += 1\\n            else:\\n                start = times[v]\\n                while used[v+\\'(\\'+str(start)+\\')\\']:\\n                    start += 1\\n                res.append(v+\\'(\\'+str(start)+\\')\\')\\n                used[v+\\'(\\'+str(start)+\\')\\'] = True\\n                times[v] = start+1\\n                times[v+\\'(\\'+str(start)+\\')\\'] += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        used = collections.defaultdict(bool)\\n        times = collections.defaultdict(int)\\n        res = []\\n        for k,v in enumerate(names):\\n            if not used[v]:\\n                # not used \\n                res.append(v)\\n                used[v] = True\\n                times[v] += 1\\n            else:\\n                start = times[v]\\n                while used[v+\\'(\\'+str(start)+\\')\\']:\\n                    start += 1\\n                res.append(v+\\'(\\'+str(start)+\\')\\')\\n                used[v+\\'(\\'+str(start)+\\')\\'] = True\\n                times[v] = start+1\\n                times[v+\\'(\\'+str(start)+\\')\\'] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697759,
                "title": "why-did-my-solution-tle-while-others-passed-leetcode-admin-please-see",
                "content": "Others in the top 100 with very similar solution passed where as mine TLE\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        ans = []\\n        seen = set()\\n        for name in names:\\n            if name not in seen:\\n                seen.add(name)\\n                ans.append(name)\\n            elif name in seen:\\n                i = 1\\n                curr = name + \\'(\\' + str(i) + \\')\\'\\n                while curr in seen:\\n                    curr = name + \\'(\\'  + str(i) + \\')\\'\\n                    i += 1\\n                seen.add(curr)\\n                ans.append(curr)\\n        return ans\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        ans = []\\n        seen = set()\\n        for name in names:\\n            if name not in seen:\\n                seen.add(name)\\n                ans.append(name)\\n            elif name in seen:\\n                i = 1\\n                curr = name + \\'(\\' + str(i) + \\')\\'\\n                while curr in seen:\\n                    curr = name + \\'(\\'  + str(i) + \\')\\'\\n                    i += 1\\n                seen.add(curr)\\n                ans.append(curr)\\n        return ans\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 697742,
                "title": "java-simple-code-using-linkedhashmap",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic String[] getFolderNames(String[] names) {\\n\\t\\t\\n\\t\\tMap<String, Integer> map = new LinkedHashMap<String, Integer>();\\n\\t\\tfor(int i=0; i<names.length; i++) {\\n\\t\\t\\tString name = names[i];\\n\\t\\t\\tif(map.containsKey(name)) {\\n\\t\\t\\t\\tint value = map.get(name);\\n\\t\\t\\t\\tString newItem = name + \"(\" + (++value) + \")\";\\n\\t\\t\\t\\twhile(map.containsKey(newItem)) {\\n\\t\\t\\t\\t\\tnewItem = name + \"(\" + (++value) + \")\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.put(newItem, 0);\\n\\t\\t\\t\\tmap.replace(name, value);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.put(name, 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint i=0;\\n\\t\\tfor(Map.Entry<String, Integer> entry: map.entrySet()) {\\n\\t\\t\\tnames[i++] = entry.getKey();\\n\\t\\t}\\n\\t\\treturn names;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic String[] getFolderNames(String[] names) {\\n\\t\\t\\n\\t\\tMap<String, Integer> map = new LinkedHashMap<String, Integer>();\\n\\t\\tfor(int i=0; i<names.length; i++) {\\n\\t\\t\\tString name = names[i];\\n\\t\\t\\tif(map.containsKey(name)) {\\n\\t\\t\\t\\tint value = map.get(name);\\n\\t\\t\\t\\tString newItem = name + \"(\" + (++value) + \")\";\\n\\t\\t\\t\\twhile(map.containsKey(newItem)) {\\n\\t\\t\\t\\t\\tnewItem = name + \"(\" + (++value) + \")\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.put(newItem, 0);\\n\\t\\t\\t\\tmap.replace(name, value);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.put(name, 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint i=0;\\n\\t\\tfor(Map.Entry<String, Integer> entry: map.entrySet()) {\\n\\t\\t\\tnames[i++] = entry.getKey();\\n\\t\\t}\\n\\t\\treturn names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697726,
                "title": "java-not-perfect-but-my-own-solution-with-hashmap-and-hashset",
                "content": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> map = new HashMap<>();\\n        Set<String> set = new LinkedHashSet<>();\\n        StringBuilder sb = new StringBuilder();\\n                \\n        for (String name : names) {\\n            if (!set.contains(name)) {\\n                set.add(name);\\n                map.put(name, 1);\\n            } else {\\n                while(true) {\\n                    sb.setLength(0);\\n                    sb.append(name + \"(\" + map.get(name) + \")\");                    \\n                    if (set.contains(sb.toString())) {                        \\n                        map.put(name, map.get(name) + 1);\\n                    } else {\\n                        set.add(sb.toString());\\n                        map.put(sb.toString(), 1);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        String[] result = new String[set.size()];\\n        set.toArray(result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> map = new HashMap<>();\\n        Set<String> set = new LinkedHashSet<>();\\n        StringBuilder sb = new StringBuilder();\\n                \\n        for (String name : names) {\\n            if (!set.contains(name)) {\\n                set.add(name);\\n                map.put(name, 1);\\n            } else {\\n                while(true) {\\n                    sb.setLength(0);\\n                    sb.append(name + \"(\" + map.get(name) + \")\");                    \\n                    if (set.contains(sb.toString())) {                        \\n                        map.put(name, map.get(name) + 1);\\n                    } else {\\n                        set.add(sb.toString());\\n                        map.put(sb.toString(), 1);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        String[] result = new String[set.size()];\\n        set.toArray(result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069736,
                "title": "c-solution",
                "content": "The provided code defines a class `Solution` with a member function `getFolderNames` that generates folder names based on a given set of names, ensuring each folder name is unique. The updated code uses a different approach compared to the commented-out section.\\n\\n## Intuition\\n\\nThe code aims to generate unique folder names based on the input names. If a name is already used, it appends a number in parentheses to make it unique.\\n\\n## Approach\\n\\n1. Initialize an unordered map `seen` to keep track of the names and the numbers appended to make them unique.\\n2. Iterate through the input names:\\n   - If the name is not in the `seen` map, add it to the `seen` map and the answer vector.\\n   - If the name is already in the `seen` map, append a number in parentheses to make it unique. Keep incrementing the number until a unique name is generated.\\n3. Return the generated folder names.\\n\\n## Complexity\\n\\n- Time complexity: $$O(n \\\\cdot k)$$, where $$n$$ is the number of names and $$k$$ is the maximum number of times a name needs to be modified to make it unique.\\n- Space complexity: $$O(n)$$, where $$n$$ is the number of names.\\n\\n## Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        // Initialize an unordered map to keep track of seen names and the count of modifications made to each name\\n        unordered_map<string, int> seen;\\n        // Initialize a vector to store the generated folder names\\n        vector<string> answer;\\n\\n        // Iterate through each name in the input vector\\n        for (const string& name : names) {\\n            if (seen.find(name) == seen.end()) {\\n                // If the name is not already in the map, add it to the map and the answer vector\\n                seen[name] = 1;\\n                answer.push_back(name);\\n            } else {\\n                // If the name is already in the map, append a number to make it unique\\n                int k = seen[name];\\n                string temp = name + \"(\" + to_string(k) + \")\";\\n                \\n                // Increment the number until a unique name is generated\\n                while (seen.find(temp) != seen.end()) {\\n                    k++;\\n                    temp = name + \"(\" + to_string(k) + \")\";\\n                }\\n\\n                // Update the count for this name and add the unique name to the map and the answer vector\\n                seen[name] = k;\\n                seen[temp] = 1;\\n                answer.push_back(temp);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        // Initialize an unordered map to keep track of seen names and the count of modifications made to each name\\n        unordered_map<string, int> seen;\\n        // Initialize a vector to store the generated folder names\\n        vector<string> answer;\\n\\n        // Iterate through each name in the input vector\\n        for (const string& name : names) {\\n            if (seen.find(name) == seen.end()) {\\n                // If the name is not already in the map, add it to the map and the answer vector\\n                seen[name] = 1;\\n                answer.push_back(name);\\n            } else {\\n                // If the name is already in the map, append a number to make it unique\\n                int k = seen[name];\\n                string temp = name + \"(\" + to_string(k) + \")\";\\n                \\n                // Increment the number until a unique name is generated\\n                while (seen.find(temp) != seen.end()) {\\n                    k++;\\n                    temp = name + \"(\" + to_string(k) + \")\";\\n                }\\n\\n                // Update the count for this name and add the unique name to the map and the answer vector\\n                seen[name] = k;\\n                seen[temp] = 1;\\n                answer.push_back(temp);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023265,
                "title": "mapping-simple-c-code",
                "content": "# Intuition\\nThe intuition behind this code is to use an unordered map to keep track of how many times each folder name has been encountered. If a folder name is encountered more than once, append a suffix to make it unique. Keep incrementing the suffix until a unique folder name is found.\\n\\n# Approach\\nInitialize an unordered map m to keep track of folder names and their counts and an empty vector ans to store the resulting folder names.\\n\\nIterate through the input names vector.\\n\\nCheck if the current folder name (names[i]) is already in the m map. If it is, then there\\'s a conflict.\\n\\n  a. Initialize k with the count of the current folder name in the map (m[names[i]]).\\n\\n  b. Enter a loop to find a unique folder name: Create a new folder name str by appending the suffix \"(k)\" to the current folder name. Check if str is already in the map (m.find(str) != m.end()). If it\\'s not, it\\'s unique, so break out of the loop. Increment k and update str accordingly.\\n  c. After finding a unique folder name, increment the count for both the original folder name (names[i]) and the unique folder name (str) in the map.\\n\\n  d. Add the unique folder name to the ans vector.\\n\\nIf the current folder name is not already in the map, simply increment its count in the map and add it to the ans vector.\\n\\nReturn the ans vector, which contains the unique folder names.\\n\\n# Complexity\\nTime complexity: The code iterates through the input names vector once, and within the loop, it may perform additional iterations to find unique names. In the worst case, when all folder names are unique, the time complexity is O(n^2), where n is the number of folder names. However, in practice, the actual time complexity is likely to be lower as most folder names won\\'t require multiple iterations.\\n\\nSpace complexity: The code uses an unordered map to store folder names and counts, which can take up to O(n) space. The ans vector also takes O(n) space to store the resulting folder names. Therefore, the space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<string> getFolderNames(vector<string>& names) {\\n    unordered_map<string,int>m;\\n    vector<string>ans;\\n    for(int i=0;i<names.size();i++){\\n      if(m.find(names[i])!=m.end())\\n       {\\n          int k = m[names[i]];\\n           string str;\\n          do{\\n           str = names[i]+\\'(\\';\\n          str += to_string(k);\\n              str += \\')\\';\\n            m[names[i]]++;\\n            k++;\\n          }\\n          while(m.find(str)!=m.end());\\n          m[str]++ ;\\n          ans.push_back(str);\\n       }\\n       else\\n       {\\n          m[names[i]]++;\\n          ans.push_back(names[i]);\\n       }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<string> getFolderNames(vector<string>& names) {\\n    unordered_map<string,int>m;\\n    vector<string>ans;\\n    for(int i=0;i<names.size();i++){\\n      if(m.find(names[i])!=m.end())\\n       {\\n          int k = m[names[i]];\\n           string str;\\n          do{\\n           str = names[i]+\\'(\\';\\n          str += to_string(k);\\n              str += \\')\\';\\n            m[names[i]]++;\\n            k++;\\n          }\\n          while(m.find(str)!=m.end());\\n          m[str]++ ;\\n          ans.push_back(str);\\n       }\\n       else\\n       {\\n          m[names[i]]++;\\n          ans.push_back(names[i]);\\n       }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001442,
                "title": "c-runtime-beats-90-136ms-short-one",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> answers;\\n        unordered_map<string, int> existing;\\n\\n        for (const auto& name : names) {\\n            auto approvedName = name;\\n            int postfix = 0;\\n            if (existing.find(name) != existing.end()) {\\n                for (int k = existing[name] + 1; ; k++) {\\n                    approvedName = name + \"(\" + to_string(k) + \")\";\\n                    if (existing.find(approvedName) == existing.end()) {\\n                        postfix = k;\\n                        existing[approvedName] = 0;\\n                        break;\\n                    }\\n                }\\n            }\\n            existing[name] = postfix;\\n            answers.push_back(approvedName);\\n         }\\n         return answers;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> answers;\\n        unordered_map<string, int> existing;\\n\\n        for (const auto& name : names) {\\n            auto approvedName = name;\\n            int postfix = 0;\\n            if (existing.find(name) != existing.end()) {\\n                for (int k = existing[name] + 1; ; k++) {\\n                    approvedName = name + \"(\" + to_string(k) + \")\";\\n                    if (existing.find(approvedName) == existing.end()) {\\n                        postfix = k;\\n                        existing[approvedName] = 0;\\n                        break;\\n                    }\\n                }\\n            }\\n            existing[name] = postfix;\\n            answers.push_back(approvedName);\\n         }\\n         return answers;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992409,
                "title": "c-hashmap",
                "content": "```C []\\nchar * * getFolderNames(\\n\\tconst char * const * const names,\\n\\tconst int namesLen,\\n\\tint * const pRetsLen\\n){\\n\\t*pRetsLen = namesLen;\\n\\tchar * * const rets = (char * *)malloc(sizeof (char *) * *pRetsLen);\\n\\n\\tHashMap * pHashMap = HashMap_new(15);\\n\\n\\tfor (int i = 0; i < namesLen; i += 1){\\n\\t\\tconst int curNameLen = strlen(names[i]);\\n\\n\\t\\tint value;\\n\\t\\tconst int getValueResult = HashMap_getValue(pHashMap, names[i], &value);\\n\\n\\t\\tif (0 == getValueResult){\\n\\t\\t\\tHashMap_put(pHashMap, names[i], 0);\\n\\n\\t\\t\\trets[i] = (char *)malloc( sizeof (char) * (curNameLen + 1) );\\n\\t\\t\\tmemcpy( rets[i], names[i], sizeof (char) * (curNameLen + 1) );\\n\\t\\t}else {\\n\\t\\t\\tchar nameBuf[40];\\n\\n\\t\\t\\tmemcpy(nameBuf, names[i], sizeof (char) * curNameLen);\\n\\t\\t\\tint nameBufLen = curNameLen;\\n\\n\\t\\t\\twhile (1){\\n\\t\\t\\t\\tvalue += 1;\\n\\t\\t\\t\\tconst int suffixLen = sprintf(nameBuf + curNameLen, \"(%d)\", value);\\n\\n\\t\\t\\t\\tint value2;\\n\\t\\t\\t\\tconst int getValueResult2 = HashMap_getValue(pHashMap, nameBuf, &value2);\\n\\n\\t\\t\\t\\tif (0 == getValueResult2){\\n\\t\\t\\t\\t\\tnameBufLen += suffixLen;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tHashMap_put(pHashMap, names[i], value);\\n\\n\\t\\t\\tHashMap_put(pHashMap, nameBuf, 0);\\n\\n\\t\\t\\trets[i] = (char *)malloc( sizeof (char) * (nameBufLen + 1) );\\n\\t\\t\\tmemcpy( rets[i], nameBuf, sizeof (char) * (nameBufLen + 1) );\\t\\t\\n\\t\\t}\\n\\t}\\n\\n\\tHashMap_delete(pHashMap);\\n\\tpHashMap = NULL;\\n\\n\\treturn rets;\\n}\\n```\\n\\n```C []\\n/**\\n * \\u4EE5\\u201CASCII\\u5B57\\u7B26\\u4E32\\u201D\\u4E3A\\u201CKey\\u201D\\u7684\\u201C\\u54C8\\u5E0C\\u6620\\u5C04\\uFF08HashMap\\uFF09\\u201D\\u7C7B\\u5E93\\n * \\n * \\u4F5C\\u8005\\uFF1A\\u5411\\u9633\\u53F6\\uFF08QQ\\uFF1A914286415\\uFF09\\n * \\u6700\\u540E\\u4FEE\\u8BA2\\u65E5\\u671F\\uFF1A2022.2.2\\n *\\n * \\u652F\\u6301\\u201C\\u589E\\uFF08\\u6539\\uFF09\\u201D\\u3001\\u201C\\u67E5\\u201D\\u3001\\u201C\\u5220\\u201D\\u548C\\u201C\\u904D\\u5386\\uFF08\\u6548\\u7387\\u4F4E\\uFF09\\u201D\\u56DB\\u79CD\\u57FA\\u672C\\u64CD\\u4F5C\\n */\\n\\n#include <stdlib.h>\\t//malloc()\\u3001free()\\n#include <stdint.h>\\t//uint32_t\\n\\n//value_t\\u662F\\u201CValue\\u201D\\u7684\\u6CDB\\u578B\\u66FF\\u4EE3\\ntypedef int value_t;\\n\\n//\\u3010\\u5185\\u90E8\\u7C7B\\u3011Entry\\uFF08HashMap\\u7684\\u8282\\u70B9\\uFF09\\u7684\\u6210\\u5458\\u5C5E\\u6027\\nstruct Entry;\\ntypedef struct Entry Entry;\\nstruct Entry{\\n\\tuint32_t hash;\\t//\\u4FDD\\u5B58\\u5B57\\u7B26\\u4E32\\u768432\\u4F4Dhash\\uFF0C\\u5BF9\\u6BD4\\u5B57\\u7B26\\u4E32\\u4E4B\\u524D\\u5148\\u6BD4\\u5BF9hash\\uFF0C\\u5982\\u679C\\u4E0D\\u540C\\u5219\\u76F4\\u63A5\\u8DF3\\u8FC7\\uFF0C\\u52A0\\u5FEB\\u6BD4\\u5BF9\\u901F\\u5EA6\\n\\tchar * pKey;\\n\\tvalue_t value;\\n\\tEntry * pNext;\\t//Entry\\u662F\\u5355\\u94FE\\u8868\\u7684\\u8282\\u70B9\\n};\\n\\n//\\u3010\\u5185\\u90E8\\u7C7B\\u3011Entry\\uFF08HashMap\\u7684\\u8282\\u70B9\\uFF09\\u7684\\u6210\\u5458\\u65B9\\u6CD5\\n//new\\u548Cdelete\\nstatic Entry * Entry_new(uint32_t hash, const char * pKey, value_t value, Entry * pNext);\\nstatic void Entry_delete(Entry * const pThis);\\n\\n//\\u5185\\u90E8\\u51FD\\u6570\\nstatic char * strCpy(const char * p);\\n\\nstatic Entry * Entry_new(uint32_t hash, const char * pKey, value_t value, Entry * pNext){\\n//try\\n\\t/*\\u68C0\\u6D4B\\u53C2\\u6570*/\\n\\t//pKey\\u4E0D\\u80FD\\u4E3A\\u7A7A\\n\\tif (NULL == pKey)\\n\\t\\tgoto CATCH_1;\\n\\n\\t//\\u521B\\u5EFA\\u5BF9\\u8C61\\n\\tEntry * pNewEntry = (Entry *)malloc(sizeof (Entry));\\n\\tif (NULL == pNewEntry)\\n\\t\\tgoto CATCH_1;\\n\\n\\t/*\\u521D\\u59CB\\u5316\\u6210\\u5458\\u5C5E\\u6027*/\\n\\t//(1)hash\\n\\tpNewEntry->hash = hash;\\n\\t//(2)pKey\\n\\tpNewEntry->pKey = strCpy(pKey);\\n\\tif (NULL == pNewEntry->pKey)\\n\\t\\tgoto CATCH_2;\\n\\t//(3)value\\n\\tpNewEntry->value = value;\\n\\t//(4)pNext\\n\\tpNewEntry->pNext = pNext;\\n\\n\\t//\\u521B\\u5EFA\\u6210\\u529F\\uFF0C\\u8FD4\\u56DE\\n\\treturn pNewEntry;\\n//catch\\nCATCH_2:\\n\\tfree(pNewEntry);\\n\\tpNewEntry = NULL;\\nCATCH_1:\\n\\treturn NULL;\\n}\\n\\nstatic void Entry_delete(Entry * const pThis){\\n\\tif (NULL == pThis)\\n\\t\\treturn;\\n\\n\\tfree(pThis->pKey);\\n\\tpThis->pKey = NULL;\\n\\tfree(pThis);\\n}\\n\\n/**\\n * \\u4F20\\u5165\\u4E00\\u4E2A\\u5B57\\u7B26\\u4E32\\uFF0C\\u5728\\u5806\\u533A\\u5206\\u914D\\u4E00\\u5757\\u7B49\\u957F\\u7684\\u7A7A\\u95F4\\uFF0C\\u7136\\u540E\\u590D\\u5236\\n * \\n * \\u6210\\u529F\\u5219\\u8FD4\\u56DE\\u5806\\u533A\\u5B57\\u7B26\\u4E32\\uFF0Cmalloc()\\u5931\\u8D25\\u5219\\u8FD4\\u56DENULL\\n * \\u56E0\\u4E3A\\u590D\\u5236\\u6210\\u529F\\u7684\\u5B57\\u7B26\\u4E32\\u5728\\u5806\\u533A\\uFF0C\\u6240\\u4EE5\\u8C03\\u7528\\u8005\\u4E00\\u5B9A\\u8981\\u8BB0\\u5F97free()\\n */\\nstatic char * strCpy(const char * p){\\n\\t//\\u53C2\\u6570\\u68C0\\u6D4B\\n\\tif (NULL == p)\\n\\t\\treturn NULL;\\n\\n\\t//\\u68C0\\u6D4B\\u957F\\u5EA6\\n\\tint len = 0;\\n\\twhile (p[len] != \\'\\\\0\\')\\n\\t\\tlen += 1;\\n\\t//\\u5206\\u914D\\u7A7A\\u95F4\\n\\tchar * pRet = (char *)malloc( sizeof (char *) * (len + 1) );\\n\\tif (NULL == pRet)\\n\\t\\treturn NULL;\\n\\t//\\u5B57\\u7B26\\u4E32\\u5C01\\u5C3E\\n\\tpRet[len] = \\'\\\\0\\';\\n\\t//\\u9010\\u5B57\\u7B26\\u590D\\u5236\\n\\tfor (int i = 0; i < len; i += 1)\\n\\t\\tpRet[i] = p[i];\\n\\t//\\u8FD4\\u56DE\\n\\treturn pRet;\\n}\\n\\n\\n/*\\u201C\\u54C8\\u5E0C\\u6620\\u5C04\\u201D\\u7684\\u6210\\u5458\\u5C5E\\u6027*/\\nstruct HashMap;\\ntypedef struct HashMap HashMap;\\nstruct HashMap{\\n\\tEntry ** ppEntry;\\n\\tint len;\\n};\\n\\n/*\\u201C\\u54C8\\u5E0C\\u6620\\u5C04\\u201D\\u7684\\u6210\\u5458\\u65B9\\u6CD5*/\\n//new\\u548Cdelete\\nHashMap * HashMap_new(int const pow);\\nvoid HashMap_delete(HashMap * const pThis);\\n//\\u63A5\\u53E3\\u51FD\\u6570\\nint HashMap_put(const HashMap * const pThis, const char * pKey, value_t value);\\nint HashMap_getValue(const HashMap * const pThis, const char * pKey, value_t * const pValue);\\nint HashMap_remove(const HashMap * const pThis, const char * pKey);\\nint HashMap_traverse(const HashMap * const pThis, void (* pfnTraverse)(const char * pKey, value_t value));\\n\\n//\\u5185\\u90E8\\u51FD\\u6570\\nstatic uint32_t strHash(const char * p);\\nstatic _Bool strCmp(const char * p1, const char * p2);\\n\\n/**\\n * \\u53C2\\u6570pow\\u4EE3\\u8868\\u54C8\\u5E0C\\u8868\\u4E2D\\u201C\\u6876\\u201D\\u7684\\u4E2A\\u6570\\u662F2\\u7684pow\\u6B21\\u65B9\\n * pow\\u7684\\u7406\\u8BBA\\u503C\\u57DF\\u4E3A[0, 30]\\n * \\u4E3A\\u6700\\u5C0F\\u503C0\\u65F6\\uFF0C\\u76F8\\u5F53\\u4E8E\\u5355\\u94FE\\u8868\\uFF0C\\u4E3A\\u6700\\u5927\\u503C30\\u65F6\\uFF0C\\u5C06\\u5360\\u75284G\\uFF0832\\u4F4D\\u6307\\u9488\\uFF09\\u62168G\\uFF0864\\u4F4D\\u6307\\u9488\\uFF09\\u7684\\u5185\\u5B58\\n *\\n * \\u51FA\\u4E8E\\u7F16\\u5199\\u4E0A\\u7684\\u65B9\\u4FBF\\uFF0C\\u201C\\u6876\\u201D\\u7684\\u4E2A\\u6570\\u5728\\u5BF9\\u8C61\\u6574\\u4E2A\\u751F\\u5B58\\u671F\\u95F4\\u4E0D\\u4F1A\\u53D8\\u5316\\n */\\nHashMap * HashMap_new(int const pow){\\n//try\\n\\t//\\u6821\\u9A8C\\u53C2\\u6570\\n\\tif (pow < 0 || pow > 30)\\n\\t\\tgoto CATCH_1;\\n\\n\\t//\\u521B\\u5EFA\\u5BF9\\u8C61\\n\\tHashMap * pNewHashMap = (HashMap *)malloc(sizeof (HashMap));\\n\\tif (NULL == pNewHashMap)\\n\\t\\tgoto CATCH_1;\\n\\n\\t/*\\u521D\\u59CB\\u5316\\u6210\\u5458\\u5C5E\\u6027*/\\n\\t//(1)len\\n\\tpNewHashMap->len = 1 << pow;\\n\\t//(2)ppEntry\\n\\tpNewHashMap->ppEntry = (Entry **)malloc(sizeof (Entry *) * pNewHashMap->len);\\n\\tif (NULL == pNewHashMap->ppEntry)\\n\\t\\tgoto CATCH_2;\\n\\t//ppEntry\\u6570\\u7EC4\\u5168\\u6E05\\u7A7A\\u4E3ANULL\\n\\tfor (int i = 0; i < pNewHashMap->len; i += 1)\\n\\t\\t(pNewHashMap->ppEntry)[i] = NULL;\\n\\n\\t//\\u521B\\u5EFA\\u6210\\u529F\\uFF0C\\u8FD4\\u56DE\\n\\treturn pNewHashMap;\\n//catch\\nCATCH_2:\\n\\tfree(pNewHashMap);\\n\\tpNewHashMap = NULL;\\nCATCH_1:\\n\\treturn NULL;\\n}\\n\\nvoid HashMap_delete(HashMap * const pThis){\\n\\tif (NULL == pThis)\\n\\t\\treturn;\\n\\n\\tfor (int i = 0; i < pThis->len; i += 1){\\n\\t\\tif (NULL == (pThis->ppEntry)[i])\\n\\t\\t\\tcontinue;\\n\\t\\tdo {\\n\\t\\t\\tEntry * pNextEntry = (pThis->ppEntry)[i]->pNext;\\n\\t\\t\\tEntry_delete((pThis->ppEntry)[i]);\\n\\t\\t\\t(pThis->ppEntry)[i] = pNextEntry;\\n\\t\\t}while ( (pThis->ppEntry)[i] != NULL );\\n\\t}\\n\\tfree(pThis->ppEntry);\\n\\tpThis->ppEntry = NULL;\\n\\tfree(pThis);\\n}\\n\\n/**\\n * \\u5C06\\u201C\\u952E\\u503C\\u5BF9\\u201D\\u5199\\u5165HashMap\\n * \\n * \\u5982\\u679C\\u4E0D\\u5B58\\u5728\\u8BE5Key\\uFF0C\\u589E\\u52A0\\u8BE5\\u201C\\u952E\\u503C\\u5BF9\\u201D\\u5E76\\u8FD4\\u56DE1\\n * \\u5982\\u679C\\u5B58\\u5728\\u8BE5Key\\uFF0C\\u5219\\u66F4\\u65B0Value\\u5E76\\u8FD4\\u56DE0\\n * \\u5982\\u679C\\u4F7F\\u7528Entry_new()\\u521B\\u5EFA\\u65B0\\u8282\\u70B9\\u5931\\u8D25\\uFF0C\\u5219\\u8FD4\\u56DE-1\\n */\\nint HashMap_put(const HashMap * const pThis, const char * pKey, value_t value){\\n\\tuint32_t hash = strHash(pKey);\\n\\tint index = hash & (pThis->len - 1);\\n\\tif (NULL == (pThis->ppEntry)[index]){\\n\\t\\t(pThis->ppEntry)[index] = Entry_new(hash, pKey, value, NULL);\\n\\t\\tif ( NULL == (pThis->ppEntry)[index] )\\n\\t\\t\\treturn -1;\\n\\t\\treturn 1;\\n\\t}else {\\n\\t\\tEntry * pCurEntry = (pThis->ppEntry)[index];\\n\\t\\tdo {\\n\\t\\t\\tif (hash == pCurEntry->hash)\\n\\t\\t\\t\\tif (strCmp(pKey, pCurEntry->pKey))\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\tpCurEntry = pCurEntry->pNext;\\n\\t\\t}while (pCurEntry != NULL);\\n\\t\\tif (pCurEntry != NULL){\\n\\t\\t\\tpCurEntry->value = value;\\n\\t\\t\\treturn 0;\\n\\t\\t}else {\\n\\t\\t\\tEntry * pNewEntry = Entry_new(hash, pKey, value, (pThis->ppEntry)[index]);\\n\\t\\t\\tif ( NULL == pNewEntry )\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t(pThis->ppEntry)[index] = pNewEntry;\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t}\\n}\\n\\n/**\\n * \\u63D0\\u4F9B\\u4E00\\u4E2A\\u201CKey\\u201D\\uFF0C\\u5C1D\\u8BD5\\u83B7\\u53D6\\u5176\\u5728HashMap\\u4E2D\\u5BF9\\u5E94\\u7684\\u201CValue\\u201D\\n * \\n * \\u5982\\u679C\\u5B58\\u5728\\u8BE5Key\\uFF0C\\u5219\\u5C06\\u201CValue\\u201D\\u5199\\u5230pValue\\u4E2D\\uFF0C\\u5E76\\u8FD4\\u56DE1\\n * \\u5982\\u679C\\u4E0D\\u5B58\\u5728\\u8BE5Key\\uFF0C\\u5219\\u76F4\\u63A5\\u8FD4\\u56DE0\\n */\\nint HashMap_getValue(const HashMap * const pThis, const char * pKey, value_t * const pValue){\\n\\tuint32_t hash = strHash(pKey);\\n\\tint index = hash & (pThis->len - 1);\\n\\tif (NULL == (pThis->ppEntry)[index])\\n\\t\\treturn 0;\\n\\telse {\\n\\t\\tEntry * pCurEntry = (pThis->ppEntry)[index];\\n\\t\\tdo {\\n\\t\\t\\tif (hash == pCurEntry->hash)\\n\\t\\t\\t\\tif (strCmp(pKey, pCurEntry->pKey))\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\tpCurEntry = pCurEntry->pNext;\\n\\t\\t}while (pCurEntry != NULL);\\n\\t\\tif (pCurEntry != NULL){\\n\\t\\t\\t*pValue = pCurEntry->value;\\n\\t\\t\\treturn 1;\\n\\t\\t}else\\n\\t\\t\\treturn 0;\\n\\t}\\n}\\n\\n/**\\n * \\u5C1D\\u8BD5\\u5220\\u9664\\u6307\\u5B9A\\u7684\\u201CKey\\u201D\\u5728HashMap\\u4E2D\\u5BF9\\u5E94\\u7684\\u201C\\u952E\\u503C\\u5BF9\\u201D\\n * \\n * \\u5982\\u679C\\u8BE5Key\\u5B58\\u5728\\uFF0C\\u5219\\u5220\\u9664\\u8BE5\\u201C\\u952E\\u503C\\u5BF9\\u201D\\uFF0C\\u5E76\\u8FD4\\u56DE1\\n * \\u5982\\u679C\\u8BE5Key\\u4E0D\\u5B58\\u5728\\uFF0C\\u5219\\u76F4\\u63A5\\u8FD4\\u56DE0\\n */\\nint HashMap_remove(const HashMap * const pThis, const char * pKey){\\n\\tuint32_t hash = strHash(pKey);\\n\\tint index = hash & (pThis->len - 1);\\n\\tif (NULL == (pThis->ppEntry)[index])\\n\\t\\treturn 0;\\n\\telse {\\n\\t\\tif (hash == (pThis->ppEntry)[index]->hash)\\n\\t\\t\\tif ( strCmp( pKey, (pThis->ppEntry)[index]->pKey ) ){\\n\\t\\t\\t\\tEntry * pNextEntry = (pThis->ppEntry)[index]->pNext;\\n\\t\\t\\t\\tEntry_delete((pThis->ppEntry)[index]);\\n\\t\\t\\t\\t(pThis->ppEntry)[index] = pNextEntry;\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\tEntry * pPrevEntry = (pThis->ppEntry)[index];\\n\\t\\twhile (pPrevEntry->pNext != NULL) {\\n\\t\\t\\tif (hash == pPrevEntry->pNext->hash)\\n\\t\\t\\t\\tif ( strCmp(pKey, pPrevEntry->pNext->pKey) )\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\tpPrevEntry = pPrevEntry->pNext;\\n\\t\\t}\\n\\t\\tif (NULL == pPrevEntry->pNext)\\n\\t\\t\\treturn 0;\\n\\t\\telse {\\n\\t\\t\\tEntry * pNextNode = pPrevEntry->pNext->pNext;\\n\\t\\t\\tEntry_delete(pPrevEntry->pNext);\\n\\t\\t\\tpPrevEntry->pNext = pNextNode;\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t}\\n}\\n\\n/**\\n * \\u5BF9\\u201C\\u54C8\\u5E0C\\u6620\\u5C04\\u201D\\u8FDB\\u884C\\u904D\\u5386\\n * \\n * pfnTraverse\\u4E3A\\u904D\\u5386\\u51FD\\u6570\\uFF08\\u56DE\\u8C03\\u51FD\\u6570\\uFF09\\u7684\\u6307\\u9488\\n * \\u5F53\\u672C\\u51FD\\u6570\\u627E\\u5230\\u4E00\\u4E2A\\u201C\\u952E\\u503C\\u5BF9\\u201D\\u7684\\u65F6\\u5019\\uFF0C\\u4F1A\\u4EE5Key\\u548CValue\\u4E3A\\u53C2\\u6570\\u8C03\\u7528\\u8BE5\\u51FD\\u6570\\uFF0C\\u7531\\u51FD\\u6570\\u8FDB\\u884C\\u5177\\u4F53\\u7684\\u904D\\u5386\\u64CD\\u4F5C\\n * \\u4E5F\\u53EF\\u4EE5\\u4E3ANULL\\uFF0C\\u6B64\\u65F6\\u4E0D\\u4F1A\\u8C03\\u7528\\u56DE\\u8C03\\u51FD\\u6570\\uFF0C\\u53EF\\u4EE5\\u7528\\u6765\\u83B7\\u53D6\\u5143\\u7D20\\u4E2A\\u6570\\n *\\n * \\u8FD4\\u56DE\\u201C\\u54C8\\u5E0C\\u6620\\u5C04\\u201D\\u4E2D\\u7684\\u5143\\u7D20\\u4E2A\\u6570\\n */\\nint HashMap_traverse( const HashMap * const pThis, void (* pfnTraverse)(const char * pKey, value_t value) ){\\n\\t//\\u8BB0\\u5F55\\u904D\\u5386\\u6210\\u529F\\u7684\\u5143\\u7D20\\u4E2A\\u6570\\n\\tint cnt = 0;\\n\\t//\\u5F00\\u59CB\\u904D\\u5386\\n\\tfor (int i = 0; i < pThis->len; i += 1){\\n\\t\\tif (NULL == (pThis->ppEntry)[i])\\n\\t\\t\\tcontinue;\\n\\t\\tEntry * pCurEntry = (pThis->ppEntry)[i];\\n\\t\\tdo {\\n\\t\\t\\tif (pfnTraverse != NULL)\\n\\t\\t\\t\\t(*pfnTraverse)(pCurEntry->pKey, pCurEntry->value);\\n\\t\\t\\tcnt += 1;\\n\\t\\t\\tpCurEntry = pCurEntry->pNext;\\n\\t\\t}while ( pCurEntry != NULL );\\n\\t}\\n\\t//\\u8FD4\\u56DE\\n\\treturn cnt;\\n}\\n\\n/**\\n * \\u5BF9\\u4E00\\u201CASCII\\u5B57\\u7B26\\u4E32\\u201D\\u6C4232\\u4F4D\\u7684hash\\n * \\n * \\u6CE8\\uFF1A\\u5982\\u679Cchar\\u8D85\\u8FC7\\u4E860x7F\\uFF0C\\u90A3\\u4E48\\u4F1A\\u5F53\\u6210uint8_t\\u6765\\u5BF9\\u5F85\\uFF0C\\u800C\\u4E0D\\u662F\\u8D1F\\u6570\\n */\\nstatic uint32_t strHash(const char * p){\\n\\tuint32_t hash = 0;\\n\\tfor (; *p != \\'\\\\0\\'; p += 1)\\n\\t\\thash = ( (hash << 5) - hash ) + (uint32_t)(uint8_t)*p;\\n\\treturn hash;\\n}\\n\\n/**\\n * \\u6BD4\\u8F83\\u4E24\\u5B57\\u7B26\\u4E32\\u662F\\u5426\\u4E00\\u81F4\\n * \\n * \\u5982\\u679C\\u4E00\\u81F4\\uFF0C\\u8FD4\\u56DE1\\uFF0C\\u4E0D\\u4E00\\u81F4\\u5219\\u8FD4\\u56DE0\\n */\\nstatic _Bool strCmp(const char * p1, const char * p2){\\n\\tif (NULL == p1 || NULL == p2)\\n\\t\\treturn 0;\\n\\n\\tfor (; 1; p1 += 1, p2 += 1){\\n\\t\\tif (*p1 != *p2)\\n\\t\\t\\treturn 0;\\n\\t\\tif (\\'\\\\0\\' == *p1)\\n\\t\\t\\treturn 1;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nchar * * getFolderNames(\\n\\tconst char * const * const names,\\n\\tconst int namesLen,\\n\\tint * const pRetsLen\\n){\\n\\t*pRetsLen = namesLen;\\n\\tchar * * const rets = (char * *)malloc(sizeof (char *) * *pRetsLen);\\n\\n\\tHashMap * pHashMap = HashMap_new(15);\\n\\n\\tfor (int i = 0; i < namesLen; i += 1){\\n\\t\\tconst int curNameLen = strlen(names[i]);\\n\\n\\t\\tint value;\\n\\t\\tconst int getValueResult = HashMap_getValue(pHashMap, names[i], &value);\\n\\n\\t\\tif (0 == getValueResult){\\n\\t\\t\\tHashMap_put(pHashMap, names[i], 0);\\n\\n\\t\\t\\trets[i] = (char *)malloc( sizeof (char) * (curNameLen + 1) );\\n\\t\\t\\tmemcpy( rets[i], names[i], sizeof (char) * (curNameLen + 1) );\\n\\t\\t}else {\\n\\t\\t\\tchar nameBuf[40];\\n\\n\\t\\t\\tmemcpy(nameBuf, names[i], sizeof (char) * curNameLen);\\n\\t\\t\\tint nameBufLen = curNameLen;\\n\\n\\t\\t\\twhile (1){\\n\\t\\t\\t\\tvalue += 1;\\n\\t\\t\\t\\tconst int suffixLen = sprintf(nameBuf + curNameLen, \"(%d)\", value);\\n\\n\\t\\t\\t\\tint value2;\\n\\t\\t\\t\\tconst int getValueResult2 = HashMap_getValue(pHashMap, nameBuf, &value2);\\n\\n\\t\\t\\t\\tif (0 == getValueResult2){\\n\\t\\t\\t\\t\\tnameBufLen += suffixLen;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tHashMap_put(pHashMap, names[i], value);\\n\\n\\t\\t\\tHashMap_put(pHashMap, nameBuf, 0);\\n\\n\\t\\t\\trets[i] = (char *)malloc( sizeof (char) * (nameBufLen + 1) );\\n\\t\\t\\tmemcpy( rets[i], nameBuf, sizeof (char) * (nameBufLen + 1) );\\t\\t\\n\\t\\t}\\n\\t}\\n\\n\\tHashMap_delete(pHashMap);\\n\\tpHashMap = NULL;\\n\\n\\treturn rets;\\n}\\n```\n```C []\\n/**\\n * \\u4EE5\\u201CASCII\\u5B57\\u7B26\\u4E32\\u201D\\u4E3A\\u201CKey\\u201D\\u7684\\u201C\\u54C8\\u5E0C\\u6620\\u5C04\\uFF08HashMap\\uFF09\\u201D\\u7C7B\\u5E93\\n * \\n * \\u4F5C\\u8005\\uFF1A\\u5411\\u9633\\u53F6\\uFF08QQ\\uFF1A914286415\\uFF09\\n * \\u6700\\u540E\\u4FEE\\u8BA2\\u65E5\\u671F\\uFF1A2022.2.2\\n *\\n * \\u652F\\u6301\\u201C\\u589E\\uFF08\\u6539\\uFF09\\u201D\\u3001\\u201C\\u67E5\\u201D\\u3001\\u201C\\u5220\\u201D\\u548C\\u201C\\u904D\\u5386\\uFF08\\u6548\\u7387\\u4F4E\\uFF09\\u201D\\u56DB\\u79CD\\u57FA\\u672C\\u64CD\\u4F5C\\n */\\n\\n#include <stdlib.h>\\t//malloc()\\u3001free()\\n#include <stdint.h>\\t//uint32_t\\n\\n//value_t\\u662F\\u201CValue\\u201D\\u7684\\u6CDB\\u578B\\u66FF\\u4EE3\\ntypedef int value_t;\\n\\n//\\u3010\\u5185\\u90E8\\u7C7B\\u3011Entry\\uFF08HashMap\\u7684\\u8282\\u70B9\\uFF09\\u7684\\u6210\\u5458\\u5C5E\\u6027\\nstruct Entry;\\ntypedef struct Entry Entry;\\nstruct Entry{\\n\\tuint32_t hash;\\t//\\u4FDD\\u5B58\\u5B57\\u7B26\\u4E32\\u768432\\u4F4Dhash\\uFF0C\\u5BF9\\u6BD4\\u5B57\\u7B26\\u4E32\\u4E4B\\u524D\\u5148\\u6BD4\\u5BF9hash\\uFF0C\\u5982\\u679C\\u4E0D\\u540C\\u5219\\u76F4\\u63A5\\u8DF3\\u8FC7\\uFF0C\\u52A0\\u5FEB\\u6BD4\\u5BF9\\u901F\\u5EA6\\n\\tchar * pKey;\\n\\tvalue_t value;\\n\\tEntry * pNext;\\t//Entry\\u662F\\u5355\\u94FE\\u8868\\u7684\\u8282\\u70B9\\n};\\n\\n//\\u3010\\u5185\\u90E8\\u7C7B\\u3011Entry\\uFF08HashMap\\u7684\\u8282\\u70B9\\uFF09\\u7684\\u6210\\u5458\\u65B9\\u6CD5\\n//new\\u548Cdelete\\nstatic Entry * Entry_new(uint32_t hash, const char * pKey, value_t value, Entry * pNext);\\nstatic void Entry_delete(Entry * const pThis);\\n\\n//\\u5185\\u90E8\\u51FD\\u6570\\nstatic char * strCpy(const char * p);\\n\\nstatic Entry * Entry_new(uint32_t hash, const char * pKey, value_t value, Entry * pNext){\\n//try\\n\\t/*\\u68C0\\u6D4B\\u53C2\\u6570*/\\n\\t//pKey\\u4E0D\\u80FD\\u4E3A\\u7A7A\\n\\tif (NULL == pKey)\\n\\t\\tgoto CATCH_1;\\n\\n\\t//\\u521B\\u5EFA\\u5BF9\\u8C61\\n\\tEntry * pNewEntry = (Entry *)malloc(sizeof (Entry));\\n\\tif (NULL == pNewEntry)\\n\\t\\tgoto CATCH_1;\\n\\n\\t/*\\u521D\\u59CB\\u5316\\u6210\\u5458\\u5C5E\\u6027*/\\n\\t//(1)hash\\n\\tpNewEntry->hash = hash;\\n\\t//(2)pKey\\n\\tpNewEntry->pKey = strCpy(pKey);\\n\\tif (NULL == pNewEntry->pKey)\\n\\t\\tgoto CATCH_2;\\n\\t//(3)value\\n\\tpNewEntry->value = value;\\n\\t//(4)pNext\\n\\tpNewEntry->pNext = pNext;\\n\\n\\t//\\u521B\\u5EFA\\u6210\\u529F\\uFF0C\\u8FD4\\u56DE\\n\\treturn pNewEntry;\\n//catch\\nCATCH_2:\\n\\tfree(pNewEntry);\\n\\tpNewEntry = NULL;\\nCATCH_1:\\n\\treturn NULL;\\n}\\n\\nstatic void Entry_delete(Entry * const pThis){\\n\\tif (NULL == pThis)\\n\\t\\treturn;\\n\\n\\tfree(pThis->pKey);\\n\\tpThis->pKey = NULL;\\n\\tfree(pThis);\\n}\\n\\n/**\\n * \\u4F20\\u5165\\u4E00\\u4E2A\\u5B57\\u7B26\\u4E32\\uFF0C\\u5728\\u5806\\u533A\\u5206\\u914D\\u4E00\\u5757\\u7B49\\u957F\\u7684\\u7A7A\\u95F4\\uFF0C\\u7136\\u540E\\u590D\\u5236\\n * \\n * \\u6210\\u529F\\u5219\\u8FD4\\u56DE\\u5806\\u533A\\u5B57\\u7B26\\u4E32\\uFF0Cmalloc()\\u5931\\u8D25\\u5219\\u8FD4\\u56DENULL\\n * \\u56E0\\u4E3A\\u590D\\u5236\\u6210\\u529F\\u7684\\u5B57\\u7B26\\u4E32\\u5728\\u5806\\u533A\\uFF0C\\u6240\\u4EE5\\u8C03\\u7528\\u8005\\u4E00\\u5B9A\\u8981\\u8BB0\\u5F97free()\\n */\\nstatic char * strCpy(const char * p){\\n\\t//\\u53C2\\u6570\\u68C0\\u6D4B\\n\\tif (NULL == p)\\n\\t\\treturn NULL;\\n\\n\\t//\\u68C0\\u6D4B\\u957F\\u5EA6\\n\\tint len = 0;\\n\\twhile (p[len] != \\'\\\\0\\')\\n\\t\\tlen += 1;\\n\\t//\\u5206\\u914D\\u7A7A\\u95F4\\n\\tchar * pRet = (char *)malloc( sizeof (char *) * (len + 1) );\\n\\tif (NULL == pRet)\\n\\t\\treturn NULL;\\n\\t//\\u5B57\\u7B26\\u4E32\\u5C01\\u5C3E\\n\\tpRet[len] = \\'\\\\0\\';\\n\\t//\\u9010\\u5B57\\u7B26\\u590D\\u5236\\n\\tfor (int i = 0; i < len; i += 1)\\n\\t\\tpRet[i] = p[i];\\n\\t//\\u8FD4\\u56DE\\n\\treturn pRet;\\n}\\n\\n\\n/*\\u201C\\u54C8\\u5E0C\\u6620\\u5C04\\u201D\\u7684\\u6210\\u5458\\u5C5E\\u6027*/\\nstruct HashMap;\\ntypedef struct HashMap HashMap;\\nstruct HashMap{\\n\\tEntry ** ppEntry;\\n\\tint len;\\n};\\n\\n/*\\u201C\\u54C8\\u5E0C\\u6620\\u5C04\\u201D\\u7684\\u6210\\u5458\\u65B9\\u6CD5*/\\n//new\\u548Cdelete\\nHashMap * HashMap_new(int const pow);\\nvoid HashMap_delete(HashMap * const pThis);\\n//\\u63A5\\u53E3\\u51FD\\u6570\\nint HashMap_put(const HashMap * const pThis, const char * pKey, value_t value);\\nint HashMap_getValue(const HashMap * const pThis, const char * pKey, value_t * const pValue);\\nint HashMap_remove(const HashMap * const pThis, const char * pKey);\\nint HashMap_traverse(const HashMap * const pThis, void (* pfnTraverse)(const char * pKey, value_t value));\\n\\n//\\u5185\\u90E8\\u51FD\\u6570\\nstatic uint32_t strHash(const char * p);\\nstatic _Bool strCmp(const char * p1, const char * p2);\\n\\n/**\\n * \\u53C2\\u6570pow\\u4EE3\\u8868\\u54C8\\u5E0C\\u8868\\u4E2D\\u201C\\u6876\\u201D\\u7684\\u4E2A\\u6570\\u662F2\\u7684pow\\u6B21\\u65B9\\n * pow\\u7684\\u7406\\u8BBA\\u503C\\u57DF\\u4E3A[0, 30]\\n * \\u4E3A\\u6700\\u5C0F\\u503C0\\u65F6\\uFF0C\\u76F8\\u5F53\\u4E8E\\u5355\\u94FE\\u8868\\uFF0C\\u4E3A\\u6700\\u5927\\u503C30\\u65F6\\uFF0C\\u5C06\\u5360\\u75284G\\uFF0832\\u4F4D\\u6307\\u9488\\uFF09\\u62168G\\uFF0864\\u4F4D\\u6307\\u9488\\uFF09\\u7684\\u5185\\u5B58\\n *\\n * \\u51FA\\u4E8E\\u7F16\\u5199\\u4E0A\\u7684\\u65B9\\u4FBF\\uFF0C\\u201C\\u6876\\u201D\\u7684\\u4E2A\\u6570\\u5728\\u5BF9\\u8C61\\u6574\\u4E2A\\u751F\\u5B58\\u671F\\u95F4\\u4E0D\\u4F1A\\u53D8\\u5316\\n */\\nHashMap * HashMap_new(int const pow){\\n//try\\n\\t//\\u6821\\u9A8C\\u53C2\\u6570\\n\\tif (pow < 0 || pow > 30)\\n\\t\\tgoto CATCH_1;\\n\\n\\t//\\u521B\\u5EFA\\u5BF9\\u8C61\\n\\tHashMap * pNewHashMap = (HashMap *)malloc(sizeof (HashMap));\\n\\tif (NULL == pNewHashMap)\\n\\t\\tgoto CATCH_1;\\n\\n\\t/*\\u521D\\u59CB\\u5316\\u6210\\u5458\\u5C5E\\u6027*/\\n\\t//(1)len\\n\\tpNewHashMap->len = 1 << pow;\\n\\t//(2)ppEntry\\n\\tpNewHashMap->ppEntry = (Entry **)malloc(sizeof (Entry *) * pNewHashMap->len);\\n\\tif (NULL == pNewHashMap->ppEntry)\\n\\t\\tgoto CATCH_2;\\n\\t//ppEntry\\u6570\\u7EC4\\u5168\\u6E05\\u7A7A\\u4E3ANULL\\n\\tfor (int i = 0; i < pNewHashMap->len; i += 1)\\n\\t\\t(pNewHashMap->ppEntry)[i] = NULL;\\n\\n\\t//\\u521B\\u5EFA\\u6210\\u529F\\uFF0C\\u8FD4\\u56DE\\n\\treturn pNewHashMap;\\n//catch\\nCATCH_2:\\n\\tfree(pNewHashMap);\\n\\tpNewHashMap = NULL;\\nCATCH_1:\\n\\treturn NULL;\\n}\\n\\nvoid HashMap_delete(HashMap * const pThis){\\n\\tif (NULL == pThis)\\n\\t\\treturn;\\n\\n\\tfor (int i = 0; i < pThis->len; i += 1){\\n\\t\\tif (NULL == (pThis->ppEntry)[i])\\n\\t\\t\\tcontinue;\\n\\t\\tdo {\\n\\t\\t\\tEntry * pNextEntry = (pThis->ppEntry)[i]->pNext;\\n\\t\\t\\tEntry_delete((pThis->ppEntry)[i]);\\n\\t\\t\\t(pThis->ppEntry)[i] = pNextEntry;\\n\\t\\t}while ( (pThis->ppEntry)[i] != NULL );\\n\\t}\\n\\tfree(pThis->ppEntry);\\n\\tpThis->ppEntry = NULL;\\n\\tfree(pThis);\\n}\\n\\n/**\\n * \\u5C06\\u201C\\u952E\\u503C\\u5BF9\\u201D\\u5199\\u5165HashMap\\n * \\n * \\u5982\\u679C\\u4E0D\\u5B58\\u5728\\u8BE5Key\\uFF0C\\u589E\\u52A0\\u8BE5\\u201C\\u952E\\u503C\\u5BF9\\u201D\\u5E76\\u8FD4\\u56DE1\\n * \\u5982\\u679C\\u5B58\\u5728\\u8BE5Key\\uFF0C\\u5219\\u66F4\\u65B0Value\\u5E76\\u8FD4\\u56DE0\\n * \\u5982\\u679C\\u4F7F\\u7528Entry_new()\\u521B\\u5EFA\\u65B0\\u8282\\u70B9\\u5931\\u8D25\\uFF0C\\u5219\\u8FD4\\u56DE-1\\n */\\nint HashMap_put(const HashMap * const pThis, const char * pKey, value_t value){\\n\\tuint32_t hash = strHash(pKey);\\n\\tint index = hash & (pThis->len - 1);\\n\\tif (NULL == (pThis->ppEntry)[index]){\\n\\t\\t(pThis->ppEntry)[index] = Entry_new(hash, pKey, value, NULL);\\n\\t\\tif ( NULL == (pThis->ppEntry)[index] )\\n\\t\\t\\treturn -1;\\n\\t\\treturn 1;\\n\\t}else {\\n\\t\\tEntry * pCurEntry = (pThis->ppEntry)[index];\\n\\t\\tdo {\\n\\t\\t\\tif (hash == pCurEntry->hash)\\n\\t\\t\\t\\tif (strCmp(pKey, pCurEntry->pKey))\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\tpCurEntry = pCurEntry->pNext;\\n\\t\\t}while (pCurEntry != NULL);\\n\\t\\tif (pCurEntry != NULL){\\n\\t\\t\\tpCurEntry->value = value;\\n\\t\\t\\treturn 0;\\n\\t\\t}else {\\n\\t\\t\\tEntry * pNewEntry = Entry_new(hash, pKey, value, (pThis->ppEntry)[index]);\\n\\t\\t\\tif ( NULL == pNewEntry )\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t(pThis->ppEntry)[index] = pNewEntry;\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t}\\n}\\n\\n/**\\n * \\u63D0\\u4F9B\\u4E00\\u4E2A\\u201CKey\\u201D\\uFF0C\\u5C1D\\u8BD5\\u83B7\\u53D6\\u5176\\u5728HashMap\\u4E2D\\u5BF9\\u5E94\\u7684\\u201CValue\\u201D\\n * \\n * \\u5982\\u679C\\u5B58\\u5728\\u8BE5Key\\uFF0C\\u5219\\u5C06\\u201CValue\\u201D\\u5199\\u5230pValue\\u4E2D\\uFF0C\\u5E76\\u8FD4\\u56DE1\\n * \\u5982\\u679C\\u4E0D\\u5B58\\u5728\\u8BE5Key\\uFF0C\\u5219\\u76F4\\u63A5\\u8FD4\\u56DE0\\n */\\nint HashMap_getValue(const HashMap * const pThis, const char * pKey, value_t * const pValue){\\n\\tuint32_t hash = strHash(pKey);\\n\\tint index = hash & (pThis->len - 1);\\n\\tif (NULL == (pThis->ppEntry)[index])\\n\\t\\treturn 0;\\n\\telse {\\n\\t\\tEntry * pCurEntry = (pThis->ppEntry)[index];\\n\\t\\tdo {\\n\\t\\t\\tif (hash == pCurEntry->hash)\\n\\t\\t\\t\\tif (strCmp(pKey, pCurEntry->pKey))\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\tpCurEntry = pCurEntry->pNext;\\n\\t\\t}while (pCurEntry != NULL);\\n\\t\\tif (pCurEntry != NULL){\\n\\t\\t\\t*pValue = pCurEntry->value;\\n\\t\\t\\treturn 1;\\n\\t\\t}else\\n\\t\\t\\treturn 0;\\n\\t}\\n}\\n\\n/**\\n * \\u5C1D\\u8BD5\\u5220\\u9664\\u6307\\u5B9A\\u7684\\u201CKey\\u201D\\u5728HashMap\\u4E2D\\u5BF9\\u5E94\\u7684\\u201C\\u952E\\u503C\\u5BF9\\u201D\\n * \\n * \\u5982\\u679C\\u8BE5Key\\u5B58\\u5728\\uFF0C\\u5219\\u5220\\u9664\\u8BE5\\u201C\\u952E\\u503C\\u5BF9\\u201D\\uFF0C\\u5E76\\u8FD4\\u56DE1\\n * \\u5982\\u679C\\u8BE5Key\\u4E0D\\u5B58\\u5728\\uFF0C\\u5219\\u76F4\\u63A5\\u8FD4\\u56DE0\\n */\\nint HashMap_remove(const HashMap * const pThis, const char * pKey){\\n\\tuint32_t hash = strHash(pKey);\\n\\tint index = hash & (pThis->len - 1);\\n\\tif (NULL == (pThis->ppEntry)[index])\\n\\t\\treturn 0;\\n\\telse {\\n\\t\\tif (hash == (pThis->ppEntry)[index]->hash)\\n\\t\\t\\tif ( strCmp( pKey, (pThis->ppEntry)[index]->pKey ) ){\\n\\t\\t\\t\\tEntry * pNextEntry = (pThis->ppEntry)[index]->pNext;\\n\\t\\t\\t\\tEntry_delete((pThis->ppEntry)[index]);\\n\\t\\t\\t\\t(pThis->ppEntry)[index] = pNextEntry;\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\tEntry * pPrevEntry = (pThis->ppEntry)[index];\\n\\t\\twhile (pPrevEntry->pNext != NULL) {\\n\\t\\t\\tif (hash == pPrevEntry->pNext->hash)\\n\\t\\t\\t\\tif ( strCmp(pKey, pPrevEntry->pNext->pKey) )\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\tpPrevEntry = pPrevEntry->pNext;\\n\\t\\t}\\n\\t\\tif (NULL == pPrevEntry->pNext)\\n\\t\\t\\treturn 0;\\n\\t\\telse {\\n\\t\\t\\tEntry * pNextNode = pPrevEntry->pNext->pNext;\\n\\t\\t\\tEntry_delete(pPrevEntry->pNext);\\n\\t\\t\\tpPrevEntry->pNext = pNextNode;\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t}\\n}\\n\\n/**\\n * \\u5BF9\\u201C\\u54C8\\u5E0C\\u6620\\u5C04\\u201D\\u8FDB\\u884C\\u904D\\u5386\\n * \\n * pfnTraverse\\u4E3A\\u904D\\u5386\\u51FD\\u6570\\uFF08\\u56DE\\u8C03\\u51FD\\u6570\\uFF09\\u7684\\u6307\\u9488\\n * \\u5F53\\u672C\\u51FD\\u6570\\u627E\\u5230\\u4E00\\u4E2A\\u201C\\u952E\\u503C\\u5BF9\\u201D\\u7684\\u65F6\\u5019\\uFF0C\\u4F1A\\u4EE5Key\\u548CValue\\u4E3A\\u53C2\\u6570\\u8C03\\u7528\\u8BE5\\u51FD\\u6570\\uFF0C\\u7531\\u51FD\\u6570\\u8FDB\\u884C\\u5177\\u4F53\\u7684\\u904D\\u5386\\u64CD\\u4F5C\\n * \\u4E5F\\u53EF\\u4EE5\\u4E3ANULL\\uFF0C\\u6B64\\u65F6\\u4E0D\\u4F1A\\u8C03\\u7528\\u56DE\\u8C03\\u51FD\\u6570\\uFF0C\\u53EF\\u4EE5\\u7528\\u6765\\u83B7\\u53D6\\u5143\\u7D20\\u4E2A\\u6570\\n *\\n * \\u8FD4\\u56DE\\u201C\\u54C8\\u5E0C\\u6620\\u5C04\\u201D\\u4E2D\\u7684\\u5143\\u7D20\\u4E2A\\u6570\\n */\\nint HashMap_traverse( const HashMap * const pThis, void (* pfnTraverse)(const char * pKey, value_t value) ){\\n\\t//\\u8BB0\\u5F55\\u904D\\u5386\\u6210\\u529F\\u7684\\u5143\\u7D20\\u4E2A\\u6570\\n\\tint cnt = 0;\\n\\t//\\u5F00\\u59CB\\u904D\\u5386\\n\\tfor (int i = 0; i < pThis->len; i += 1){\\n\\t\\tif (NULL == (pThis->ppEntry)[i])\\n\\t\\t\\tcontinue;\\n\\t\\tEntry * pCurEntry = (pThis->ppEntry)[i];\\n\\t\\tdo {\\n\\t\\t\\tif (pfnTraverse != NULL)\\n\\t\\t\\t\\t(*pfnTraverse)(pCurEntry->pKey, pCurEntry->value);\\n\\t\\t\\tcnt += 1;\\n\\t\\t\\tpCurEntry = pCurEntry->pNext;\\n\\t\\t}while ( pCurEntry != NULL );\\n\\t}\\n\\t//\\u8FD4\\u56DE\\n\\treturn cnt;\\n}\\n\\n/**\\n * \\u5BF9\\u4E00\\u201CASCII\\u5B57\\u7B26\\u4E32\\u201D\\u6C4232\\u4F4D\\u7684hash\\n * \\n * \\u6CE8\\uFF1A\\u5982\\u679Cchar\\u8D85\\u8FC7\\u4E860x7F\\uFF0C\\u90A3\\u4E48\\u4F1A\\u5F53\\u6210uint8_t\\u6765\\u5BF9\\u5F85\\uFF0C\\u800C\\u4E0D\\u662F\\u8D1F\\u6570\\n */\\nstatic uint32_t strHash(const char * p){\\n\\tuint32_t hash = 0;\\n\\tfor (; *p != \\'\\\\0\\'; p += 1)\\n\\t\\thash = ( (hash << 5) - hash ) + (uint32_t)(uint8_t)*p;\\n\\treturn hash;\\n}\\n\\n/**\\n * \\u6BD4\\u8F83\\u4E24\\u5B57\\u7B26\\u4E32\\u662F\\u5426\\u4E00\\u81F4\\n * \\n * \\u5982\\u679C\\u4E00\\u81F4\\uFF0C\\u8FD4\\u56DE1\\uFF0C\\u4E0D\\u4E00\\u81F4\\u5219\\u8FD4\\u56DE0\\n */\\nstatic _Bool strCmp(const char * p1, const char * p2){\\n\\tif (NULL == p1 || NULL == p2)\\n\\t\\treturn 0;\\n\\n\\tfor (; 1; p1 += 1, p2 += 1){\\n\\t\\tif (*p1 != *p2)\\n\\t\\t\\treturn 0;\\n\\t\\tif (\\'\\\\0\\' == *p1)\\n\\t\\t\\treturn 1;\\n\\t}\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3901136,
                "title": "python3-o-n-using-while-loop-to-get-the-next-key-name",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing while loop to get the next key name\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing while loop to get the next key name\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        cache = {}#store names\\n\\n        for idx, name in enumerate(names):\\n            modified = name\\n            if name not in cache:\\n                #while(name)\\n                cache[name] = 0\\n            else:\\n                k = cache[name]\\n                while modified in cache:\\n                    k += 1\\n                    modified = f\\'{name}({k})\\'\\n                cache[name] = k\\n                cache[modified] = 0\\n        return cache.keys()\\n        #last: pes:0, pes(2):0, pes(1):0, pes(3):0\\n\\n\\n\\n        #[\"pes\",\"pes(2)\", \"pes\", \"pes\"]\\n#expected[\"pes\",\"pes(2)\", \"pes(1)\",\"pes(3)\" ]\\n        #last: pes:3, pes(2):0, pes(1):0, pes(3):0\\n        #modified = pes(3)\\n        \\'\\'\\'\\n        cache = {}#store names\\n        res = []\\n\\n        for idx, i in enumea\\n        \\n\\n        \\n        for i in names:\\n            #not found right away, then\\n            if i not in cache:\\n                if \\'(\\' in i and \\')\\' in i:\\n                    for name in cache: #break this for loop\\n                        \\n                        if name in i:\\n                            leng = len(name)\\n                            if len(i) == leng + 3 and i[leng] == \"(\" and i[leng+2] == \")\":\\n                                #check if it is repeaded :\\n                                if i in cache[name]:\\n                                    break #do nothing\\n                                #check if i_k in within k:\\n                                    \\n                                    \\n                                    i_k = leng+1\\n                                    if i_k > k:\\n                                        cache[name][count] += 1\\n                                        k = cache[name][count]\\n                                        st = name + \"(\" + str(k) + \")\"\\n                                        res.append(st)\\n                                        cache[name][i] = 1\\n                                    \\n                                    \\n                                cache[name][count] += 1\\n                                k = cache[name][count]\\n                                st = name + \"(\" + str(k) + \")\"\\n                                res.append(st)\\n                                break\\n                res.append(i)\\n                cache[i] = {}\\n                cache[i][count] = 0\\n\\n            else:\\n                \\n                cache[i][count] += 1\\n                #res.append(i)\\n                k = cache[i][count]\\n                #cache\\n                st = i + \"(\" + str(k) + \")\"\\n                res.append(st)\\n                cache[i][st] = 1\\n\\n        return res \\n\\n\\n        [\"pes\",\"fifa\",\"gta\",\"pes(1)\", \"pes(2019)\"]\\n        \\'\\'\\'\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        cache = {}#store names\\n\\n        for idx, name in enumerate(names):\\n            modified = name\\n            if name not in cache:\\n                #while(name)\\n                cache[name] = 0\\n            else:\\n                k = cache[name]\\n                while modified in cache:\\n                    k += 1\\n                    modified = f\\'{name}({k})\\'\\n                cache[name] = k\\n                cache[modified] = 0\\n        return cache.keys()\\n        #last: pes:0, pes(2):0, pes(1):0, pes(3):0\\n\\n\\n\\n        #[\"pes\",\"pes(2)\", \"pes\", \"pes\"]\\n#expected[\"pes\",\"pes(2)\", \"pes(1)\",\"pes(3)\" ]\\n        #last: pes:3, pes(2):0, pes(1):0, pes(3):0\\n        #modified = pes(3)\\n        \\'\\'\\'\\n        cache = {}#store names\\n        res = []\\n\\n        for idx, i in enumea\\n        \\n\\n        \\n        for i in names:\\n            #not found right away, then\\n            if i not in cache:\\n                if \\'(\\' in i and \\')\\' in i:\\n                    for name in cache: #break this for loop\\n                        \\n                        if name in i:\\n                            leng = len(name)\\n                            if len(i) == leng + 3 and i[leng] == \"(\" and i[leng+2] == \")\":\\n                                #check if it is repeaded :\\n                                if i in cache[name]:\\n                                    break #do nothing\\n                                #check if i_k in within k:\\n                                    \\n                                    \\n                                    i_k = leng+1\\n                                    if i_k > k:\\n                                        cache[name][count] += 1\\n                                        k = cache[name][count]\\n                                        st = name + \"(\" + str(k) + \")\"\\n                                        res.append(st)\\n                                        cache[name][i] = 1\\n                                    \\n                                    \\n                                cache[name][count] += 1\\n                                k = cache[name][count]\\n                                st = name + \"(\" + str(k) + \")\"\\n                                res.append(st)\\n                                break\\n                res.append(i)\\n                cache[i] = {}\\n                cache[i][count] = 0\\n\\n            else:\\n                \\n                cache[i][count] += 1\\n                #res.append(i)\\n                k = cache[i][count]\\n                #cache\\n                st = i + \"(\" + str(k) + \")\"\\n                res.append(st)\\n                cache[i][st] = 1\\n\\n        return res \\n\\n\\n        [\"pes\",\"fifa\",\"gta\",\"pes(1)\", \"pes(2019)\"]\\n        \\'\\'\\'\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855564,
                "title": "javascript-beats-100-both-runtime-and-memory",
                "content": "![image](https://assets.leetcode.com/users/images/7f6d1f07-c5e6-4117-8f4d-5f44954f847e_1691024890.0260081.png)\\n\\n```\\nconst getFolderNames = function (names) {\\n    const hash = new Map()\\n    for(let i = 0; i < names.length; i++) {\\n        let file = names[i]\\n        let count = hash.has(file) ? hash.get(file) : 0\\n        while(hash.has(file)) {\\n            file = `${names[i]}(${++count})`\\n        }\\n        hash.set(names[i], count)\\n        hash.set(file, 0)\\n        names[i] = file\\n    }\\n    return names\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst getFolderNames = function (names) {\\n    const hash = new Map()\\n    for(let i = 0; i < names.length; i++) {\\n        let file = names[i]\\n        let count = hash.has(file) ? hash.get(file) : 0\\n        while(hash.has(file)) {\\n            file = `${names[i]}(${++count})`\\n        }\\n        hash.set(names[i], count)\\n        hash.set(file, 0)\\n        names[i] = file\\n    }\\n    return names\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850316,
                "title": "explication-with-python-hash-dict",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ average cases\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        #Inicialize hash and new names array\\n        frequency = {}\\n        uniqueNames = []\\n        \\n        #Foreach name in array names:\\n        for name in names:\\n            #If name is unique:\\n            if name not in frequency:\\n                uniqueNames.append(name)\\n                frequency[name] = 1\\n            #Name is not unique:\\n            else:\\n                namePlusNumber = name + \"(\" +str(frequency[name]) + \")\"\\n                frequency[name]+=1\\n                #If new name is not unique:\\n                while(namePlusNumber in frequency):\\n                    namePlusNumber = name + \"(\" +str(frequency[name]) + \")\"\\n                    frequency[name]+=1\\n                #Add new unique name to array and hash:\\n                uniqueNames.append(namePlusNumber)\\n                frequency[namePlusNumber] = 1\\n        \\n        return uniqueNames\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        #Inicialize hash and new names array\\n        frequency = {}\\n        uniqueNames = []\\n        \\n        #Foreach name in array names:\\n        for name in names:\\n            #If name is unique:\\n            if name not in frequency:\\n                uniqueNames.append(name)\\n                frequency[name] = 1\\n            #Name is not unique:\\n            else:\\n                namePlusNumber = name + \"(\" +str(frequency[name]) + \")\"\\n                frequency[name]+=1\\n                #If new name is not unique:\\n                while(namePlusNumber in frequency):\\n                    namePlusNumber = name + \"(\" +str(frequency[name]) + \")\"\\n                    frequency[name]+=1\\n                #Add new unique name to array and hash:\\n                uniqueNames.append(namePlusNumber)\\n                frequency[namePlusNumber] = 1\\n        \\n        return uniqueNames\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836982,
                "title": "easy-to-understand-javascript-solution-hash-table",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar getFolderNames = function(names) {\\n    const fileNameMap = new Map();\\n\\n    return names.reduce((result, name) => {\\n        if (fileNameMap.has(name)) {\\n            let count = fileNameMap.get(name);\\n\\n            while (fileNameMap.has(`${name}(${count})`)) count += 1;\\n            const uniqueName = `${name}(${count})`;\\n\\n            fileNameMap.set(name, count + 1);\\n            fileNameMap.set(uniqueName, 1);\\n            result.push(uniqueName);\\n        } else {\\n            fileNameMap.set(name, 1);\\n            result.push(name);\\n        }\\n        return result;\\n    }, []);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getFolderNames = function(names) {\\n    const fileNameMap = new Map();\\n\\n    return names.reduce((result, name) => {\\n        if (fileNameMap.has(name)) {\\n            let count = fileNameMap.get(name);\\n\\n            while (fileNameMap.has(`${name}(${count})`)) count += 1;\\n            const uniqueName = `${name}(${count})`;\\n\\n            fileNameMap.set(name, count + 1);\\n            fileNameMap.set(uniqueName, 1);\\n            result.push(uniqueName);\\n        } else {\\n            fileNameMap.set(name, 1);\\n            result.push(name);\\n        }\\n        return result;\\n    }, []);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818287,
                "title": "python-simple",
                "content": "# Intuition\\nBasically brute force. Store seen names in set, on already seen run dumb counter until you find first number that is not used.\\n\\n# Complexity\\n- Time complexity:\\nAverage $$O(NW)$$ - test cases support this \\nTeorethical Worst case $$O(N^2W)$$ - for every name (N) processsing within hash table costs in worst case length of the name (W). Also there is counter loop in worst case of length N, imagine use case where there are 10000 same names. \\n\\n- Space complexity:\\n$$O(NW)$$ - N number of names, W length of the name in characters\\n\\n# Code\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        seen = set()\\n        result = []\\n        for name in names:\\n            candidate = name\\n            if candidate in seen:\\n                count = 1\\n                while (candidate := f\\'{name}({count})\\') in seen: count += 1\\n            result.append(candidate)\\n            seen.add(candidate)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        seen = set()\\n        result = []\\n        for name in names:\\n            candidate = name\\n            if candidate in seen:\\n                count = 1\\n                while (candidate := f\\'{name}({count})\\') in seen: count += 1\\n            result.append(candidate)\\n            seen.add(candidate)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615007,
                "title": "100-faster-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n         Map<String,Integer> dic = new HashMap<>();\\n         String[] arr = new String[names.length];\\n         for(int i = 0; i < names.length; i++) {\\n             arr[i] = build(dic, names[i]);\\n         }\\n         return arr;\\n    }\\n\\n    private String build( Map<String,Integer> dic , String name) {\\n        if(dic.containsKey(name)) {\\n            int x = dic.get(name);\\n            String s = name;\\n            while(dic.containsKey(s)) {\\n                x++;\\n                s = name + \"(\" + x + \")\";\\n            }\\n            dic.put(name, x);\\n            dic.put(s, 0);\\n            return s;\\n        } else {\\n            dic.put(name, 0);\\n            return name;\\n        }\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n         Map<String,Integer> dic = new HashMap<>();\\n         String[] arr = new String[names.length];\\n         for(int i = 0; i < names.length; i++) {\\n             arr[i] = build(dic, names[i]);\\n         }\\n         return arr;\\n    }\\n\\n    private String build( Map<String,Integer> dic , String name) {\\n        if(dic.containsKey(name)) {\\n            int x = dic.get(name);\\n            String s = name;\\n            while(dic.containsKey(s)) {\\n                x++;\\n                s = name + \"(\" + x + \")\";\\n            }\\n            dic.put(name, x);\\n            dic.put(s, 0);\\n            return s;\\n        } else {\\n            dic.put(name, 0);\\n            return name;\\n        }\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583387,
                "title": "easy-and-explained-hashmap-solution-in-java",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse HashMap for constant time compexity for searching already existed names.\\n\\n# Complexity\\n- Time complexity: O(n): Time Complexity for searching in HashMap = O(1) + Time Complexity for traversing given array names[ ] = O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n): Space required to store name\\'s record in HashMap.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        // we use ArrayList instead of array because of dynamic-array-length in ArrayList\\n        // we can also use array too  if u want to, just set the size of array a bit large for testcase during submissions\\n        ArrayList<String> rls = new ArrayList<>();\\n\\n        // Use Map: to store names and there number of occurences\\n        HashMap<String, Integer> record = new HashMap<>();      \\n\\n        for( String i: names){\\n            // if our Map named \\'record\\' doesnt contain the name \\'i\\', we add it to the record\\n            if(!record.containsKey(i)){\\n                rls.add(i);\\n                record.put(i, 1);\\n            }\\n            else{\\n                // if it contain name \\'i\\' in record, we first get its value=number of occurences\\n                int k = record.get(i);\\n                String temp = i+\"(\" + k +\")\";\\n\\n                // we again check if \\'record\\' contain \\'i+(k)\\' or not, if it does, we increment k\\n                while(record.containsKey(temp)){\\n                    k++;\\n                    temp=i+\"(\" + k +\")\";\\n                }\\n\\n                // add new name \\'temp\\' i.e. \\'i+(k)\\' with value=1 in record so that if a new name appears, that is same as our modified name, we can start from there\\n                record.put(temp,1);\\n                \\n                //update the old name number of occurences with \\'k\\'\\n                record.put(i,k);\\n                rls.add(temp);\\n            }\\n        }\\n\\n        // one liner: from ArrayList to array conversion->\\n        String ans[] = rls.toArray(new String[rls.size()]);\\n\\n        // proper easy understadable way for: from ArrayList to array conversion->\\n        /*\\n        String ans[] = new String[names.length];\\n        for (int i=0; i<rls.size();i++){\\n            ans[i]=rls.get(i);\\n        }\\n        */\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        // we use ArrayList instead of array because of dynamic-array-length in ArrayList\\n        // we can also use array too  if u want to, just set the size of array a bit large for testcase during submissions\\n        ArrayList<String> rls = new ArrayList<>();\\n\\n        // Use Map: to store names and there number of occurences\\n        HashMap<String, Integer> record = new HashMap<>();      \\n\\n        for( String i: names){\\n            // if our Map named \\'record\\' doesnt contain the name \\'i\\', we add it to the record\\n            if(!record.containsKey(i)){\\n                rls.add(i);\\n                record.put(i, 1);\\n            }\\n            else{\\n                // if it contain name \\'i\\' in record, we first get its value=number of occurences\\n                int k = record.get(i);\\n                String temp = i+\"(\" + k +\")\";\\n\\n                // we again check if \\'record\\' contain \\'i+(k)\\' or not, if it does, we increment k\\n                while(record.containsKey(temp)){\\n                    k++;\\n                    temp=i+\"(\" + k +\")\";\\n                }\\n\\n                // add new name \\'temp\\' i.e. \\'i+(k)\\' with value=1 in record so that if a new name appears, that is same as our modified name, we can start from there\\n                record.put(temp,1);\\n                \\n                //update the old name number of occurences with \\'k\\'\\n                record.put(i,k);\\n                rls.add(temp);\\n            }\\n        }\\n\\n        // one liner: from ArrayList to array conversion->\\n        String ans[] = rls.toArray(new String[rls.size()]);\\n\\n        // proper easy understadable way for: from ArrayList to array conversion->\\n        /*\\n        String ans[] = new String[names.length];\\n        for (int i=0; i<rls.size();i++){\\n            ans[i]=rls.get(i);\\n        }\\n        */\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565797,
                "title": "o-n-simple-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Use a map of integers to track occurances of filenames\\n2. When a duplicate is found increment the counter until the name is unique\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nfunc getFolderNames(names []string) []string {\\n    res := []string{}\\n    m := map[string]int{}\\n\\n    // for each name keep a counter and\\n    // increment until we find a name that\\n    // is not used\\n    for _, name := range names {\\n        if m[name] > 0 {\\n            str := name\\n\\n            for m[str] > 0 {\\n                str = fmt.Sprintf(\"%s(%d)\", name, m[name])\\n                m[name]++\\n            }\\n\\n            res = append(res, str)\\n            m[str] = 1\\n        } else {\\n            res = append(res, name)\\n            m[name] = 1\\n        }\\n    }\\n\\n    return res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getFolderNames(names []string) []string {\\n    res := []string{}\\n    m := map[string]int{}\\n\\n    // for each name keep a counter and\\n    // increment until we find a name that\\n    // is not used\\n    for _, name := range names {\\n        if m[name] > 0 {\\n            str := name\\n\\n            for m[str] > 0 {\\n                str = fmt.Sprintf(\"%s(%d)\", name, m[name])\\n                m[name]++\\n            }\\n\\n            res = append(res, str)\\n            m[str] = 1\\n        } else {\\n            res = append(res, name)\\n            m[name] = 1\\n        }\\n    }\\n\\n    return res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462660,
                "title": "simple-and-straightforward-implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> freq;\\n        vector<string> ans;\\n        for(auto& name: names) {\\n            if(freq.find(name) != freq.end()) {\\n                int x = 0;\\n                string temp = name + \"(\" + to_string(freq[name] + x) + \")\";\\n                while(freq.find(temp) != freq.end()) {\\n                    x++;\\n                    temp = name + \"(\" + to_string(freq[name] + x) + \")\";\\n                }\\n                ans.push_back(temp);\\n                freq[temp]++;\\n            } else {\\n                ans.push_back(name);\\n            }\\n            freq[name]++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> freq;\\n        vector<string> ans;\\n        for(auto& name: names) {\\n            if(freq.find(name) != freq.end()) {\\n                int x = 0;\\n                string temp = name + \"(\" + to_string(freq[name] + x) + \")\";\\n                while(freq.find(temp) != freq.end()) {\\n                    x++;\\n                    temp = name + \"(\" + to_string(freq[name] + x) + \")\";\\n                }\\n                ans.push_back(temp);\\n                freq[temp]++;\\n            } else {\\n                ans.push_back(name);\\n            }\\n            freq[name]++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401542,
                "title": "clean-python-use-dict-beats-95",
                "content": "# Code\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        folders = dict()\\n        for i, name in enumerate(names):\\n            new_name = name\\n            if name not in folders:\\n                folders[name] = 0\\n            else:\\n                while new_name in folders:\\n                    new_name = f\"{name}({folders[name] + 1})\"\\n                    folders[name] += 1\\n\\n                names[i] = new_name\\n                folders[new_name] = 0\\n\\n        return names\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        folders = dict()\\n        for i, name in enumerate(names):\\n            new_name = name\\n            if name not in folders:\\n                folders[name] = 0\\n            else:\\n                while new_name in folders:\\n                    new_name = f\"{name}({folders[name] + 1})\"\\n                    folders[name] += 1\\n\\n                names[i] = new_name\\n                folders[new_name] = 0\\n\\n        return names\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351167,
                "title": "easy-solution",
                "content": "\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        op = {}\\n        for i in range(len(names)):\\n            if names[i] in op:\\n                b=names[i]+\"(\"+str(op[names[i]])+\")\"\\n                op[names[i]]+=1\\n                while b in op:\\n                    b=names[i]+\"(\"+str(op[names[i]])+\")\"\\n                    op[names[i]]+=1\\n                names[i] = b\\n                op[b]=1\\n                \\n            else:\\n                op[names[i]]=1\\n        return names\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        op = {}\\n        for i in range(len(names)):\\n            if names[i] in op:\\n                b=names[i]+\"(\"+str(op[names[i]])+\")\"\\n                op[names[i]]+=1\\n                while b in op:\\n                    b=names[i]+\"(\"+str(op[names[i]])+\")\"\\n                    op[names[i]]+=1\\n                names[i] = b\\n                op[b]=1\\n                \\n            else:\\n                op[names[i]]=1\\n        return names\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301936,
                "title": "487-ms",
                "content": "```ruby\\ndef get_folder_names a\\n    h = {}\\n    a.map! do | s |\\n        unless v = h[s]\\n            h[s] = 1\\n            s\\n        else\\n            v += 1 while h[x = \"#{s}(#{v})\"]\\n            h[x] = 1\\n            h[s] = v + 1\\n            x\\n        end\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef get_folder_names a\\n    h = {}\\n    a.map! do | s |\\n        unless v = h[s]\\n            h[s] = 1\\n            s\\n        else\\n            v += 1 while h[x = \"#{s}(#{v})\"]\\n            h[x] = 1\\n            h[s] = v + 1\\n            x\\n        end\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3254917,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string>ret ;\\n        unordered_map<string, int>names2count ;\\n        \\n        for(auto& name : names){\\n            auto iter = names2count.find(name) ;\\n            if(iter == names2count.end())\\n                ret.push_back(name) ;\\n            else{\\n                string t  ;\\n                int cn = iter->second ;\\n                while(1){\\n                    t = name ;\\n                    t += \"(\" + to_string(cn) + \")\" ;\\n                    if(names2count.count(t) )\\n                        cn++ ;\\n                    else\\n                        break ;\\n                }\\n                ret.push_back(t) ;\\n                names2count[t] = 1 ;\\n            }\\n            names2count[name]++ ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string>ret ;\\n        unordered_map<string, int>names2count ;\\n        \\n        for(auto& name : names){\\n            auto iter = names2count.find(name) ;\\n            if(iter == names2count.end())\\n                ret.push_back(name) ;\\n            else{\\n                string t  ;\\n                int cn = iter->second ;\\n                while(1){\\n                    t = name ;\\n                    t += \"(\" + to_string(cn) + \")\" ;\\n                    if(names2count.count(t) )\\n                        cn++ ;\\n                    else\\n                        break ;\\n                }\\n                ret.push_back(t) ;\\n                names2count[t] = 1 ;\\n            }\\n            names2count[name]++ ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250671,
                "title": "simple-c-solution-o-n-time-and-space-detailed-explanations",
                "content": "# Intuition\\n- Use a hashtable to store the mapping form base_name to its next suffix index\\n\\n# Approach\\n- Initializing containers\\n  - We need a vector ```result``` to store the modified names.\\n  - Also need an unordered_map ```map_``` to store the mapping from the base name to its next suffix index.\\n- Loop through all the names in the input vector ```names```.\\n  - For each name, initialize a string variable ```unique_name``` to store the modified name, which initially equals the current name.\\n  - Get the next available suffix for the current name from the ```map_``` by accessing ```map_[name]``` and store it in an integer variable ```j```.\\n  - If the suffix already exists for the current name, then we need to generate a unique name by appending the next suffix to the base name.\\n    - While the ```unique_name``` already exists in the ```map_```, generate a new unique name by appending the next suffix to the base name until a unique name is found.\\n    - Update the ```map_``` with the new suffix for the current name by setting ```map_[name] = j```.\\n  - Add the ```unique_name``` to the ```map_``` with the next suffix set to ```1``` by setting ```map_[unique_name] = 1```.\\n  - Add the ```unique_name``` to the ```result``` vector.\\n- After all the names have been processed, return the modified ```result``` vector.\\n- The English code comments are generated by chatGPT\\n\\n\\n# Complexity\\n- Time complexity: ```O(n)```\\n- Space complexity: ```O(n)```\\n\\n\\n# Code\\n```cpp\\n// Runtime 184 ms Beats 78.63% Memory 65.9 MB Beats 44.27%\\nstd::vector<std::string> getFolderNames(std::vector<std::string>& names) {\\n    // Hashtable method\\n    // Use a hashtable to store the mapping form base_name to its next suffix index\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    std::vector<std::string> result; \\n    std::unordered_map<std::string, int> map_; // base_name -> next suffix\\n\\n    // Loop through all names in the input vector\\n    for (const std::string& name : names) { \\n        std::string unique_name = name;  // Initialize a string variable to store the modified name\\n        int j = map_[name];      // Get the next available suffix for the current name from the map\\n\\n        // If the suffix already exists for the current name\\n        if (j > 0) { \\n            while (map_.count(unique_name)) { // Keep looping until the unique name is found\\n                // Generate a new unique name by appending the next suffix to the base name\\n                unique_name = name + \"(\" + std::to_string(j++) + \")\"; \\n            }  \\n            map_[name] = j;     // Update the map with the new suffix for the current name     \\n        }\\n        map_[unique_name] = 1;  // Add the unique name to the map with the next suffix set to 1\\n        result.push_back(unique_name); // Add the unique name to the result vector\\n    }\\n    return result; // Return the modified vector of strings\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```result```\n```map_```\n```names```\n```unique_name```\n```map_```\n```map_[name]```\n```j```\n```unique_name```\n```map_```\n```map_```\n```map_[name] = j```\n```unique_name```\n```map_```\n```1```\n```map_[unique_name] = 1```\n```unique_name```\n```result```\n```result```\n```O(n)```\n```O(n)```\n```cpp\\n// Runtime 184 ms Beats 78.63% Memory 65.9 MB Beats 44.27%\\nstd::vector<std::string> getFolderNames(std::vector<std::string>& names) {\\n    // Hashtable method\\n    // Use a hashtable to store the mapping form base_name to its next suffix index\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    std::vector<std::string> result; \\n    std::unordered_map<std::string, int> map_; // base_name -> next suffix\\n\\n    // Loop through all names in the input vector\\n    for (const std::string& name : names) { \\n        std::string unique_name = name;  // Initialize a string variable to store the modified name\\n        int j = map_[name];      // Get the next available suffix for the current name from the map\\n\\n        // If the suffix already exists for the current name\\n        if (j > 0) { \\n            while (map_.count(unique_name)) { // Keep looping until the unique name is found\\n                // Generate a new unique name by appending the next suffix to the base name\\n                unique_name = name + \"(\" + std::to_string(j++) + \")\"; \\n            }  \\n            map_[name] = j;     // Update the map with the new suffix for the current name     \\n        }\\n        map_[unique_name] = 1;  // Add the unique name to the map with the next suffix set to 1\\n        result.push_back(unique_name); // Add the unique name to the result vector\\n    }\\n    return result; // Return the modified vector of strings\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3249006,
                "title": "c-easy-and-simple-solution-using-hash-map",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string>ans;\\n        unordered_map<string,int>mapping;\\n        for(int i=0;i<names.size();i++){\\n            if(mapping[names[i]]){\\n                int val=mapping[names[i]];\\n                if(val==1){\\n                string temp=names[i]+\"(\"+to_string(val)+\")\";\\n                val++;\\n                    while(mapping[temp]){\\n                         temp=names[i]+\"(\"+to_string(val++)+\")\";\\n                    }\\n                    \\n                mapping[temp]=1;\\n                ans.push_back(temp);\\n                mapping[names[i]]++;\\n                }else{\\n                    string temp=names[i]+\"(\"+to_string(val)+\")\";\\n                    val++;\\n                    while(mapping[temp]){\\n                         temp=names[i]+\"(\"+to_string(val++)+\")\";\\n                    }\\n                    \\n                mapping[temp]=1;\\n                ans.push_back(temp);\\n                mapping[names[i]]++;\\n                }\\n                \\n                \\n\\n            }else{\\n                mapping[names[i]]=1;\\n                ans.push_back(names[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string>ans;\\n        unordered_map<string,int>mapping;\\n        for(int i=0;i<names.size();i++){\\n            if(mapping[names[i]]){\\n                int val=mapping[names[i]];\\n                if(val==1){\\n                string temp=names[i]+\"(\"+to_string(val)+\")\";\\n                val++;\\n                    while(mapping[temp]){\\n                         temp=names[i]+\"(\"+to_string(val++)+\")\";\\n                    }\\n                    \\n                mapping[temp]=1;\\n                ans.push_back(temp);\\n                mapping[names[i]]++;\\n                }else{\\n                    string temp=names[i]+\"(\"+to_string(val)+\")\";\\n                    val++;\\n                    while(mapping[temp]){\\n                         temp=names[i]+\"(\"+to_string(val++)+\")\";\\n                    }\\n                    \\n                mapping[temp]=1;\\n                ans.push_back(temp);\\n                mapping[names[i]]++;\\n                }\\n                \\n                \\n\\n            }else{\\n                mapping[names[i]]=1;\\n                ans.push_back(names[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230359,
                "title": "python-pay-attention-to-the-description",
                "content": "this problem really sucks!\\nthe description is so confusing.\\nafter wrestling with a couple of error examples, I figured out what the problem really means.\\nshare the code below.\\n\\nif a str is first time in the hashmap, we assign val(version) 0 to it. and we should do for any strings, either the given array elements or our modified ones.\\n\\nfor str which showed up before, we just increase the version number till a new one.\\n\\n```\\ndef getFolderNames(self, names: List[str]) -> List[str]:\\n        res=[]\\n        m={}\\n        for a in names:\\n            if a not in m:\\n                m[a]=0\\n                res.append(a)\\n            else:\\n                version=m[a]\\n                while a+\"(\"+str(version+1)+\\')\\' in m:\\n                    version+=1\\n                m[a]=version+1\\n                name=a+\"(\"+str(version+1)+\\')\\'\\n                res.append(name)\\n                m[name]=0\\n\\n            #print(f\"a={a}, res={res}, m={m}\")        \\n        return res\\n",
                "solutionTags": [],
                "code": "this problem really sucks!\\nthe description is so confusing.\\nafter wrestling with a couple of error examples, I figured out what the problem really means.\\nshare the code below.\\n\\nif a str is first time in the hashmap, we assign val(version) 0 to it. and we should do for any strings, either the given array elements or our modified ones.\\n\\nfor str which showed up before, we just increase the version number till a new one.\\n\\n```\\ndef getFolderNames(self, names: List[str]) -> List[str]:\\n        res=[]\\n        m={}\\n        for a in names:\\n            if a not in m:\\n                m[a]=0\\n                res.append(a)\\n            else:\\n                version=m[a]\\n                while a+\"(\"+str(version+1)+\\')\\' in m:\\n                    version+=1\\n                m[a]=version+1\\n                name=a+\"(\"+str(version+1)+\\')\\'\\n                res.append(name)\\n                m[name]=0\\n\\n            #print(f\"a={a}, res={res}, m={m}\")        \\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3173553,
                "title": "swift-simple-iteration-tle-on-32-33",
                "content": "# Code\\n```\\nclass Solution {\\n    var map = [String: Int]()\\n    var result = [String]()\\n    func getFolderNames(_ names: [String]) -> [String] {\\n        var newNames = names\\n        \\n        for (idx, name) in names.enumerated() {\\n            var newName = name\\n            if let _ = map[name] {\\n                var counter = 1\\n                newName = name+\"(\\\\(counter))\"\\n                while let value = map[newName] {\\n                    counter += 1\\n                    newName = name+\"(\\\\(counter))\"\\n                }                \\n            }\\n            map[newName] = idx\\n            result.append(newName)\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    var map = [String: Int]()\\n    var result = [String]()\\n    func getFolderNames(_ names: [String]) -> [String] {\\n        var newNames = names\\n        \\n        for (idx, name) in names.enumerated() {\\n            var newName = name\\n            if let _ = map[name] {\\n                var counter = 1\\n                newName = name+\"(\\\\(counter))\"\\n                while let value = map[newName] {\\n                    counter += 1\\n                    newName = name+\"(\\\\(counter))\"\\n                }                \\n            }\\n            map[newName] = idx\\n            result.append(newName)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160622,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_folder_names(names: Vec<String>) -> Vec<String> {\\n        let mut m = std::collections::HashMap::<String, usize>::new();\\n        let mut ans = Vec::new();\\n        for name in names.iter() {\\n            if let Some(k) = m.get(name) {\\n                let mut k = *k;\\n                let mut str2 = String::new();\\n                loop {\\n                    str2 = format!(\"{name}({k})\");\\n                    *m.entry(name.clone()).or_insert(0) += 1;\\n                    k += 1;\\n                    if !m.contains_key(&str2) {\\n                        break;\\n                    }\\n                }\\n                *m.entry(str2.clone()).or_insert(0) += 1;\\n                ans.push(str2);\\n            } else {\\n                *m.entry(name.clone()).or_insert(0) += 1;\\n                ans.push(name.clone());\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_folder_names(names: Vec<String>) -> Vec<String> {\\n        let mut m = std::collections::HashMap::<String, usize>::new();\\n        let mut ans = Vec::new();\\n        for name in names.iter() {\\n            if let Some(k) = m.get(name) {\\n                let mut k = *k;\\n                let mut str2 = String::new();\\n                loop {\\n                    str2 = format!(\"{name}({k})\");\\n                    *m.entry(name.clone()).or_insert(0) += 1;\\n                    k += 1;\\n                    if !m.contains_key(&str2) {\\n                        break;\\n                    }\\n                }\\n                *m.entry(str2.clone()).or_insert(0) += 1;\\n                ans.push(str2);\\n            } else {\\n                *m.entry(name.clone()).or_insert(0) += 1;\\n                ans.push(name.clone());\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3120405,
                "title": "java-with-chinese-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        // LinkedHashMap\\u786E\\u4FDD\\u987A\\u5E8F\\u4FDD\\u6301\\u4E00\\u81F4\\n        var map = new LinkedHashMap<String, Integer>();\\n        //var result = new ArrayList<String>();\\n        Arrays.stream(names).forEach(name -> {\\n            if (map.containsKey(name)) {\\n                var currentIndex = map.get(name);\\n                var candidateName = name + \"(\" + currentIndex + \")\";\\n                // \\u4F7F\\u7528while\\u5FAA\\u73AF\\u67E5\\u627Emap\\u6709\\u6CA1\\u6709\\u5DF2\\u7ECF\\u91CD\\u547D\\u540D\\u7F16\\u53F7\\u7684\\u540D\\u5B57\\n                while (map.containsKey(candidateName)) {\\n                    candidateName = name + \"(\" + ++currentIndex + \")\";\\n                }\\n                map.put(candidateName, 1);\\n                // \\u56E0\\u4E3A\\u662F\\u987A\\u5E8F\\u67E5\\u627E\\uFF0C\\u4E4B\\u524D\\u7684\\u6570\\u5B57\\u80AF\\u5B9A\\u90FD\\u7528\\u8FC7\\uFF0C\\u6240\\u4EE5\\u8FD9\\u91CC\\u53EF\\u4EE5+1\\uFF0C\\u7F29\\u77ED\\u4E0B\\u6B21\\u67E5\\u627Ewhile\\u7684\\u65F6\\u95F4\\n                map.put(name, ++currentIndex);\\n            } else {\\n                map.put(name, 1);\\n            }\\n        });\\n        return map.keySet().toArray(new String[0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        // LinkedHashMap\\u786E\\u4FDD\\u987A\\u5E8F\\u4FDD\\u6301\\u4E00\\u81F4\\n        var map = new LinkedHashMap<String, Integer>();\\n        //var result = new ArrayList<String>();\\n        Arrays.stream(names).forEach(name -> {\\n            if (map.containsKey(name)) {\\n                var currentIndex = map.get(name);\\n                var candidateName = name + \"(\" + currentIndex + \")\";\\n                // \\u4F7F\\u7528while\\u5FAA\\u73AF\\u67E5\\u627Emap\\u6709\\u6CA1\\u6709\\u5DF2\\u7ECF\\u91CD\\u547D\\u540D\\u7F16\\u53F7\\u7684\\u540D\\u5B57\\n                while (map.containsKey(candidateName)) {\\n                    candidateName = name + \"(\" + ++currentIndex + \")\";\\n                }\\n                map.put(candidateName, 1);\\n                // \\u56E0\\u4E3A\\u662F\\u987A\\u5E8F\\u67E5\\u627E\\uFF0C\\u4E4B\\u524D\\u7684\\u6570\\u5B57\\u80AF\\u5B9A\\u90FD\\u7528\\u8FC7\\uFF0C\\u6240\\u4EE5\\u8FD9\\u91CC\\u53EF\\u4EE5+1\\uFF0C\\u7F29\\u77ED\\u4E0B\\u6B21\\u67E5\\u627Ewhile\\u7684\\u65F6\\u95F4\\n                map.put(name, ++currentIndex);\\n            } else {\\n                map.put(name, 1);\\n            }\\n        });\\n        return map.keySet().toArray(new String[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106756,
                "title": "python-solution-w-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we want to find a way to determine which folders should get a number appended to it, and keep track of how many versions of the folder exist. To do this, we can create a dictionary that stores the number of versions of each folder name that we have seen. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can go through each folder name and check if it is in the dictionary. If it is not in the dictionary, then we know that it is the first version of the folder, and we can add it to the answer without a number appended. If it is in the dictionary, then we can start adding numbers to it and incrementing the counter in the dictionary until we find a folder name with a number that is not in the dictionary, and add that to the answer. \\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        n = len(names)\\n        ans = [None]*n\\n        seen = {}\\n        for i in range(n):\\n            if names[i] not in seen:\\n                ans[i] = names[i]\\n                seen[names[i]] = 1\\n            else:\\n                k = seen[names[i]]\\n                while True:\\n                    name = names[i] + \\'(\\' + str(k) + \\')\\'\\n                    if name not in seen:\\n                        ans[i] = name\\n                        seen[name] = 1\\n                        break\\n                    k += 1\\n                seen[names[i]] = k\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        n = len(names)\\n        ans = [None]*n\\n        seen = {}\\n        for i in range(n):\\n            if names[i] not in seen:\\n                ans[i] = names[i]\\n                seen[names[i]] = 1\\n            else:\\n                k = seen[names[i]]\\n                while True:\\n                    name = names[i] + \\'(\\' + str(k) + \\')\\'\\n                    if name not in seen:\\n                        ans[i] = name\\n                        seen[name] = 1\\n                        break\\n                    k += 1\\n                seen[names[i]] = k\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056856,
                "title": "c-using-dictionary-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public string[] GetFolderNames(string[] names) \\n    {\\n        Dictionary<string, int> map = new Dictionary<string, int>();\\n        for(int i=0;i<names.Length;i++)\\n        {\\n            int val = -999;\\n            int count = 0;\\n            if(map.TryGetValue(names[i],out val))\\n            {\\n               count=val;\\n            }\\n            string prev_name = names[i];\\n            if(count >0)\\n            {\\n                while (map.ContainsKey(prev_name))\\n                {                \\n                    prev_name = names[i] + \"(\" + count + \")\";\\n                    count++;\\n                }\\n                map[names[i]] = count;\\n            }\\n            map.Add(prev_name, 1);\\n            names[i]=prev_name;\\n        }\\n        return names;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public string[] GetFolderNames(string[] names) \\n    {\\n        Dictionary<string, int> map = new Dictionary<string, int>();\\n        for(int i=0;i<names.Length;i++)\\n        {\\n            int val = -999;\\n            int count = 0;\\n            if(map.TryGetValue(names[i],out val))\\n            {\\n               count=val;\\n            }\\n            string prev_name = names[i];\\n            if(count >0)\\n            {\\n                while (map.ContainsKey(prev_name))\\n                {                \\n                    prev_name = names[i] + \"(\" + count + \")\";\\n                    count++;\\n                }\\n                map[names[i]] = count;\\n            }\\n            map.Add(prev_name, 1);\\n            names[i]=prev_name;\\n        }\\n        return names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050820,
                "title": "java-hashmap-easy",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        String[] result = new String[names.length];\\n        Map<String, Integer> map = new HashMap<>();\\n        int i = 0;\\n        for(String name : names){\\n            String response = populateWithKValue(name, map);\\n            result[i] = response;\\n            i++;\\n        }\\n        return result;\\n    }\\n\\n    public String populateWithKValue(String name, Map<String, Integer> map){\\n        int k = map.getOrDefault(name, 0);\\n        String nameClone = name;\\n        while(map.containsKey(name)){\\n                k++;\\n                name = nameClone + \\'(\\'+k+\\')\\';\\n        }\\n        if(k != 0)\\n            map.put(nameClone, k);\\n        map.put(name, 0);\\n        return name;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        String[] result = new String[names.length];\\n        Map<String, Integer> map = new HashMap<>();\\n        int i = 0;\\n        for(String name : names){\\n            String response = populateWithKValue(name, map);\\n            result[i] = response;\\n            i++;\\n        }\\n        return result;\\n    }\\n\\n    public String populateWithKValue(String name, Map<String, Integer> map){\\n        int k = map.getOrDefault(name, 0);\\n        String nameClone = name;\\n        while(map.containsKey(name)){\\n                k++;\\n                name = nameClone + \\'(\\'+k+\\')\\';\\n        }\\n        if(k != 0)\\n            map.put(nameClone, k);\\n        map.put(name, 0);\\n        return name;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001959,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\npair<string,int> find_number ( std::string names_input, unordered_map<string, int> map_names, string input,int i){\\n    if(map_names.count(input) != 0){\\n        // int j = i+1;\\n        string new_name = names_input + \"(\"+ to_string(i) + \")\";\\n        return find_number(names_input, map_names, new_name, ++i);\\n    }\\n    else{\\n        return make_pair(input,i);\\n    }\\n}\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string,int> map_names; \\n        unordered_map<string,int> names_count;\\n        vector<string> result_strings;\\n\\n        for(int i = 0; i< names.size();i++){\\n            if(map_names.count(names[i]) ==0 ){\\n                map_names[names[i]] = 1;\\n                result_strings.push_back(names.at(i));\\n            }\\n            else{\\n            //    int num_copy = map_names[names[i]] + 1;\\n            //    string new_name = names.at(i) + \"(\"+ to_string(num_copy) + \")\";\\n            //     map_names[new_name] = 0;\\n               //string new_name = names.at(i) + \"(\"+ to_string(map_names[names[i]]) + \")\";\\n                //result_strings.push_back(new_name);\\n                //map_names[names[i]]= map_names[names[i]] + 1;\\n\\n                // pair<string, int> output = find_number(names.at(i),map_names,names.at(i),map_names[names[i]]);\\n                // result_strings.push_back(output.first);\\n                // map_names[output.first] = 1;\\n                // map_names[names[i]] = output.second;\\n                // }\\n                bool flag = false;\\n                string new_name = names[i];\\n                int count = map_names[names[i]];\\n                while(flag == false){\\n                    new_name = new_name + \"(\"+ to_string(count) + \")\";\\n                    if(map_names.count(new_name) == 0){\\n                        flag = true;\\n                        result_strings.push_back(new_name);\\n                        map_names[new_name] = 1;\\n                        map_names[names[i]] = count++;\\n                    }\\n                    else{\\n                        count = count+1;\\n                        new_name = names[i];\\n                    }\\n                }\\n            }\\n            }\\n        return result_strings;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\npair<string,int> find_number ( std::string names_input, unordered_map<string, int> map_names, string input,int i){\\n    if(map_names.count(input) != 0){\\n        // int j = i+1;\\n        string new_name = names_input + \"(\"+ to_string(i) + \")\";\\n        return find_number(names_input, map_names, new_name, ++i);\\n    }\\n    else{\\n        return make_pair(input,i);\\n    }\\n}\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string,int> map_names; \\n        unordered_map<string,int> names_count;\\n        vector<string> result_strings;\\n\\n        for(int i = 0; i< names.size();i++){\\n            if(map_names.count(names[i]) ==0 ){\\n                map_names[names[i]] = 1;\\n                result_strings.push_back(names.at(i));\\n            }\\n            else{\\n            //    int num_copy = map_names[names[i]] + 1;\\n            //    string new_name = names.at(i) + \"(\"+ to_string(num_copy) + \")\";\\n            //     map_names[new_name] = 0;\\n               //string new_name = names.at(i) + \"(\"+ to_string(map_names[names[i]]) + \")\";\\n                //result_strings.push_back(new_name);\\n                //map_names[names[i]]= map_names[names[i]] + 1;\\n\\n                // pair<string, int> output = find_number(names.at(i),map_names,names.at(i),map_names[names[i]]);\\n                // result_strings.push_back(output.first);\\n                // map_names[output.first] = 1;\\n                // map_names[names[i]] = output.second;\\n                // }\\n                bool flag = false;\\n                string new_name = names[i];\\n                int count = map_names[names[i]];\\n                while(flag == false){\\n                    new_name = new_name + \"(\"+ to_string(count) + \")\";\\n                    if(map_names.count(new_name) == 0){\\n                        flag = true;\\n                        result_strings.push_back(new_name);\\n                        map_names[new_name] = 1;\\n                        map_names[names[i]] = count++;\\n                    }\\n                    else{\\n                        count = count+1;\\n                        new_name = names[i];\\n                    }\\n                }\\n            }\\n            }\\n        return result_strings;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955604,
                "title": "c-faster-than-98",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        // if there are collisions we will increment till we don\\'t find a collision then store that value\\n        unordered_map<string, int> m;\\n        unordered_set<string> v;\\n        vector<string> ans;\\n        for (auto& s : names){\\n            if (v.find(s) == v.end()){\\n                v.insert(s);\\n                m[s] = 1;\\n                ans.push_back(s);\\n            }\\n            else{\\n                int nextNum = m[s];\\n                if (nextNum == 0) ++nextNum;\\n                string current = s + \"(\" + to_string(nextNum) + \")\";\\n                while (v.find(current) != v.end()){\\n                    ++nextNum;\\n                    current = s + \"(\" + to_string(nextNum) + \")\";\\n                }\\n                v.insert(current);\\n                ans.push_back(current);\\n                m[s] = nextNum + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        // if there are collisions we will increment till we don\\'t find a collision then store that value\\n        unordered_map<string, int> m;\\n        unordered_set<string> v;\\n        vector<string> ans;\\n        for (auto& s : names){\\n            if (v.find(s) == v.end()){\\n                v.insert(s);\\n                m[s] = 1;\\n                ans.push_back(s);\\n            }\\n            else{\\n                int nextNum = m[s];\\n                if (nextNum == 0) ++nextNum;\\n                string current = s + \"(\" + to_string(nextNum) + \")\";\\n                while (v.find(current) != v.end()){\\n                    ++nextNum;\\n                    current = s + \"(\" + to_string(nextNum) + \")\";\\n                }\\n                v.insert(current);\\n                ans.push_back(current);\\n                m[s] = nextNum + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923231,
                "title": "java-using-hashmap-straight-forward",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    public String[] getFolderNames(String[] names) {\\n        String[] res = new String[names.length];\\n        Map<String, Integer> seen_lastUsedNum = new HashMap<>();\\n        for (int i = 0; i < names.length; i++) {\\n            String name = names[i];\\n            if (seen_lastUsedNum.containsKey(name)) {\\n                int lastUsedNum = seen_lastUsedNum.get(name);\\n                int num = lastUsedNum + 1;\\n                String nameWithSuffix = name + \"(\" + num + \")\";\\n                while (seen_lastUsedNum.containsKey(nameWithSuffix)) {\\n                    num += 1;\\n                    nameWithSuffix = name + \"(\" + num + \")\";\\n                }\\n                seen_lastUsedNum.put(name, num);\\n                res[i] = nameWithSuffix;\\n                seen_lastUsedNum.put(nameWithSuffix, 0);\\n            } else {\\n                res[i] = name;\\n                seen_lastUsedNum.put(name, 0);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String[] getFolderNames(String[] names) {\\n        String[] res = new String[names.length];\\n        Map<String, Integer> seen_lastUsedNum = new HashMap<>();\\n        for (int i = 0; i < names.length; i++) {\\n            String name = names[i];\\n            if (seen_lastUsedNum.containsKey(name)) {\\n                int lastUsedNum = seen_lastUsedNum.get(name);\\n                int num = lastUsedNum + 1;\\n                String nameWithSuffix = name + \"(\" + num + \")\";\\n                while (seen_lastUsedNum.containsKey(nameWithSuffix)) {\\n                    num += 1;\\n                    nameWithSuffix = name + \"(\" + num + \")\";\\n                }\\n                seen_lastUsedNum.put(name, num);\\n                res[i] = nameWithSuffix;\\n                seen_lastUsedNum.put(nameWithSuffix, 0);\\n            } else {\\n                res[i] = name;\\n                seen_lastUsedNum.put(name, 0);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871119,
                "title": "hashmap-to-record-uniqueid-to-reduce-retry-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecord unique positive integer for each name. Since this problem is relatively simple , we dont need to parse name...\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> ans;\\n        \\n        unordered_map<string, int> m;\\n\\n        for (auto name: names) {\\n            if (!m.count(name)) {\\n                m[name] = 0;\\n                ans.push_back(name);\\n            } else {                \\n                int uniqueID = m[name] + 1;\\n                string anotherName = name + \"(\" + to_string(uniqueID) + \")\";\\n                \\n                // new name exists, try next ID\\n                while(m.count(anotherName)) {                \\n                    anotherName = name + \"(\" + to_string(++uniqueID) + \")\";\\n                }\\n\\n                // update uniqueID for exist name.\\n                m[name] = uniqueID;\\n\\n                // new name, we just record it.\\n                m[anotherName] = 0;\\n                ans.push_back(anotherName);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> ans;\\n        \\n        unordered_map<string, int> m;\\n\\n        for (auto name: names) {\\n            if (!m.count(name)) {\\n                m[name] = 0;\\n                ans.push_back(name);\\n            } else {                \\n                int uniqueID = m[name] + 1;\\n                string anotherName = name + \"(\" + to_string(uniqueID) + \")\";\\n                \\n                // new name exists, try next ID\\n                while(m.count(anotherName)) {                \\n                    anotherName = name + \"(\" + to_string(++uniqueID) + \")\";\\n                }\\n\\n                // update uniqueID for exist name.\\n                m[name] = uniqueID;\\n\\n                // new name, we just record it.\\n                m[anotherName] = 0;\\n                ans.push_back(anotherName);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859972,
                "title": "easy-python-solution-easy-understanding-hashmap",
                "content": "```\\nfrom collections import defaultdict as maps\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        d = maps(int); n = len(names)\\n        for i in range(n):\\n            if (d[names[i]]):\\n                val = names[i] + \"(\" + str(d[names[i]]) + \")\"\\n                while val in d:\\n                    d[names[i]] += 1;\\n                    val = names[i] + \"(\" + str(d[names[i]]) + \")\"\\n                d[val] += 1; names[i] = val;\\n            else:\\n                d[names[i]] += 1;\\n        return names\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict as maps\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        d = maps(int); n = len(names)\\n        for i in range(n):\\n            if (d[names[i]]):\\n                val = names[i] + \"(\" + str(d[names[i]]) + \")\"\\n                while val in d:\\n                    d[names[i]] += 1;\\n                    val = names[i] + \"(\" + str(d[names[i]]) + \")\"\\n                d[val] += 1; names[i] = val;\\n            else:\\n                d[names[i]] += 1;\\n        return names\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850104,
                "title": "python-simple-hashmap-solution-easy-and-fast",
                "content": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        hashMap = defaultdict(int)\\n        for idx, name in enumerate(names):\\n            if name in hashMap:\\n                latestEdition = hashMap[name]\\n                while name + \"(\" + str(latestEdition) + \")\" in hashMap:\\n                    latestEdition += 1\\n                names[idx] = name + \"(\" + str(latestEdition) + \")\"\\n                hashMap[name + \"(\" + str(latestEdition) + \")\"] = 1\\n                hashMap[name] = latestEdition\\n            else:\\n                hashMap[name] = 1\\n        return names\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        hashMap = defaultdict(int)\\n        for idx, name in enumerate(names):\\n            if name in hashMap:\\n                latestEdition = hashMap[name]\\n                while name + \"(\" + str(latestEdition) + \")\" in hashMap:\\n                    latestEdition += 1\\n                names[idx] = name + \"(\" + str(latestEdition) + \")\"\\n                hashMap[name + \"(\" + str(latestEdition) + \")\"] = 1\\n                hashMap[name] = latestEdition\\n            else:\\n                hashMap[name] = 1\\n        return names\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653610,
                "title": "hashmap-implementation",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    \\n    vector<string> getFolderNames(vector<string>& names) \\n    {\\n        map<string,int> store;\\n        vector<string> ans;\\n        for(auto name : names)\\n        {\\n            if(store.find(name)==store.end())\\n            {\\n                ans.push_back(name);\\n                store[name]++;\\n            }\\n            else\\n            {\\n                string t = name + \"(\" + to_string(store[name]) + \")\";\\n                int inc = 1;\\n                while(store.find(t)!=store.end())\\n                {\\n                    t = name + \"(\" + to_string(store[name]+inc) + \")\";\\n                    inc++;\\n                }\\n                store[name]+=inc-1;\\n                ans.push_back(t);\\n                store[t]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    \\n    vector<string> getFolderNames(vector<string>& names) \\n    {\\n        map<string,int> store;\\n        vector<string> ans;\\n        for(auto name : names)\\n        {\\n            if(store.find(name)==store.end())\\n            {\\n                ans.push_back(name);\\n                store[name]++;\\n            }\\n            else\\n            {\\n                string t = name + \"(\" + to_string(store[name]) + \")\";\\n                int inc = 1;\\n                while(store.find(t)!=store.end())\\n                {\\n                    t = name + \"(\" + to_string(store[name]+inc) + \")\";\\n                    inc++;\\n                }\\n                store[name]+=inc-1;\\n                ans.push_back(t);\\n                store[t]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619823,
                "title": "c-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> strToK {};\\n        vector<string> ans {};\\n        \\n        for (string s: names) {\\n            // Case 1: string has not appeared before\\n            if (strToK.find(s) == strToK.end()) {\\n                ans.push_back(s);\\n                strToK[s] = 1;\\n            } \\n            // Case 2: string has appeared before\\n            else {\\n                string candidateString = s + \"(\" + to_string(strToK.at(s)) + \")\"; \\n                // In case there is a conflict with another string that has already appeared \\n                while (strToK.find(candidateString) != strToK.end()) {\\n                    ++strToK[s];\\n                    candidateString = s + \"(\" + to_string(strToK.at(s)) + \")\";\\n                }\\n                strToK[candidateString] = 1; // This string has not appeared before, thus we add it to the map\\n                ans.push_back(candidateString);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> strToK {};\\n        vector<string> ans {};\\n        \\n        for (string s: names) {\\n            // Case 1: string has not appeared before\\n            if (strToK.find(s) == strToK.end()) {\\n                ans.push_back(s);\\n                strToK[s] = 1;\\n            } \\n            // Case 2: string has appeared before\\n            else {\\n                string candidateString = s + \"(\" + to_string(strToK.at(s)) + \")\"; \\n                // In case there is a conflict with another string that has already appeared \\n                while (strToK.find(candidateString) != strToK.end()) {\\n                    ++strToK[s];\\n                    candidateString = s + \"(\" + to_string(strToK.at(s)) + \")\";\\n                }\\n                strToK[candidateString] = 1; // This string has not appeared before, thus we add it to the map\\n                ans.push_back(candidateString);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574159,
                "title": "java-explained-in-deatil-with-help-of-new-example-hashmap-used-tc-sc",
                "content": "// Input  : [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\",\"onepiece(1)\"]\\n// Output : [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\",\"onepiece(1)(1)\"] -> if a name is present with a digit appended in front of it and the new name formed occurs again, then append the digit in front of it again (like openpiece(1) occurs twice, so for second time it becomes onepiece(1)(1))\\n\\n// TC : O(N)\\n// SC : O(N)\\n```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> nameCount = new HashMap<>(); // key -> name, value -> next available num if the \\'key\\' appears again\\n        String[] res = new String[names.length];\\n        \\n        for(int i = 0; i < names.length; i++) {\\n            if(nameCount.containsKey(names[i])) { // if there is the same name available, then we need to append\\n                int nextVal = nameCount.get(names[i]); // find which next avlbl int is there with this key -> name\\n                StringBuilder sb = new StringBuilder(names[i]); // make sb out of names[i]\\n                sb.append(\\'(\\')\\n                    .append(nextVal)\\n                    .append(\\')\\');\\n                \\n                while(nameCount.containsKey(sb.toString())) { // if th NEW string formed is also present, the we need to APPEND next val again and keep doing it until we finds a unique name\\n                    nextVal++;\\n                    sb = new StringBuilder(names[i]);\\n                    sb.append(\\'(\\')\\n                        .append(nextVal)\\n                        .append(\\')\\');\\n                }\\n                \\n                res[i] = sb.toString(); // add the newly formed name to res\\n                nameCount.put(sb.toString(), 1); // since we have formed a new name (which is unique) so add it to map with 1 (if same name appears again, we will use 1 to append in front of it)\\n                nameCount.put(names[i], nextVal + 1); // we need to add the original name with the next avalbl digit\\n            } else { // if the map does not have this name, just add to map and res[]\\n                res[i] = names[i];\\n                nameCount.put(names[i], 1); // value 1 will be used if the next time the same names appear\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> nameCount = new HashMap<>(); // key -> name, value -> next available num if the \\'key\\' appears again\\n        String[] res = new String[names.length];\\n        \\n        for(int i = 0; i < names.length; i++) {\\n            if(nameCount.containsKey(names[i])) { // if there is the same name available, then we need to append\\n                int nextVal = nameCount.get(names[i]); // find which next avlbl int is there with this key -> name\\n                StringBuilder sb = new StringBuilder(names[i]); // make sb out of names[i]\\n                sb.append(\\'(\\')\\n                    .append(nextVal)\\n                    .append(\\')\\');\\n                \\n                while(nameCount.containsKey(sb.toString())) { // if th NEW string formed is also present, the we need to APPEND next val again and keep doing it until we finds a unique name\\n                    nextVal++;\\n                    sb = new StringBuilder(names[i]);\\n                    sb.append(\\'(\\')\\n                        .append(nextVal)\\n                        .append(\\')\\');\\n                }\\n                \\n                res[i] = sb.toString(); // add the newly formed name to res\\n                nameCount.put(sb.toString(), 1); // since we have formed a new name (which is unique) so add it to map with 1 (if same name appears again, we will use 1 to append in front of it)\\n                nameCount.put(names[i], nextVal + 1); // we need to add the original name with the next avalbl digit\\n            } else { // if the map does not have this name, just add to map and res[]\\n                res[i] = names[i];\\n                nameCount.put(names[i], 1); // value 1 will be used if the next time the same names appear\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550941,
                "title": "java-hashmap-and-stringbuilder",
                "content": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> map = new HashMap();\\n        String[] ans = new String[names.length];\\n        for(int i=0;i<names.length;++i){\\n            if(map.containsKey(names[i])) {\\n                Integer val = map.get(names[i]);\\n                StringBuilder sb = new StringBuilder(names[i]);\\n                sb.append(\\'(\\');\\n                sb.append(val);\\n                sb.append(\\')\\');\\n                while (map.containsKey(sb.toString())) {\\n                    val++;\\n                    sb = new StringBuilder(names[i]);\\n                    sb.append(\\'(\\');\\n                    sb.append(val);\\n                    sb.append(\\')\\');\\n                }\\n                ans[i] = sb.toString();\\n                map.put(sb.toString(), 1);\\n                map.put(names[i], val + 1);\\n            }else{\\n                ans[i] = names[i];\\n                map.put(names[i], 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> map = new HashMap();\\n        String[] ans = new String[names.length];\\n        for(int i=0;i<names.length;++i){\\n            if(map.containsKey(names[i])) {\\n                Integer val = map.get(names[i]);\\n                StringBuilder sb = new StringBuilder(names[i]);\\n                sb.append(\\'(\\');\\n                sb.append(val);\\n                sb.append(\\')\\');\\n                while (map.containsKey(sb.toString())) {\\n                    val++;\\n                    sb = new StringBuilder(names[i]);\\n                    sb.append(\\'(\\');\\n                    sb.append(val);\\n                    sb.append(\\')\\');\\n                }\\n                ans[i] = sb.toString();\\n                map.put(sb.toString(), 1);\\n                map.put(names[i], val + 1);\\n            }else{\\n                ans[i] = names[i];\\n                map.put(names[i], 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526689,
                "title": "java-o-n-time-space",
                "content": "\\tpublic static String[] getFolderNames(String[] names) {\\n\\t\\t\\tHashMap<String, Integer> folderNameMap = new HashMap<>();\\n\\t\\t\\tArrayList<String> result = new ArrayList<>();\\n\\t\\t\\tfor(int idx=0; idx<names.length; idx++){\\n\\t\\t\\t\\tString key = names[idx];\\n\\t\\t\\t\\tfolderNameMap.put(key, folderNameMap.getOrDefault(key, 0)+1);\\n\\t\\t\\t\\tif(folderNameMap.get(key) > 1){\\n\\t\\t\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\t\\t\\tint count = folderNameMap.get(key)-1;\\n\\t\\t\\t\\t\\tsb.append(key + \"(\" + count + \")\");\\n\\n\\t\\t\\t\\t\\twhile(folderNameMap.containsKey(sb.toString())) {\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\tsb = new StringBuilder(key);\\n\\t\\t\\t\\t\\t\\tsb.append(\"(\" + (count) + \")\");\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tresult.add(sb.toString());\\n\\t\\t\\t\\t\\tfolderNameMap.put(result.get(idx),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfolderNameMap.getOrDefault(result.get(idx), 0) + 1);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tresult.add(names[idx]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tString[] finalResult = new String[result.size()];\\n\\t\\t\\tfinalResult = result.toArray(finalResult);\\n\\t\\t\\treturn finalResult;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic static String[] getFolderNames(String[] names) {\\n\\t\\t\\tHashMap<String, Integer> folderNameMap = new HashMap<>();\\n\\t\\t\\tArrayList<String> result = new ArrayList<>();\\n\\t\\t\\tfor(int idx=0; idx<names.length; idx++){\\n\\t\\t\\t\\tString key = names[idx];\\n\\t\\t\\t\\tfolderNameMap.put(key, folderNameMap.getOrDefault(key, 0)+1);\\n\\t\\t\\t\\tif(folderNameMap.get(key) > 1){\\n\\t\\t\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\t\\t\\tint count = folderNameMap.get(key)-1;\\n\\t\\t\\t\\t\\tsb.append(key + \"(\" + count + \")\");\\n\\n\\t\\t\\t\\t\\twhile(folderNameMap.containsKey(sb.toString())) {\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\tsb = new StringBuilder(key);\\n\\t\\t\\t\\t\\t\\tsb.append(\"(\" + (count) + \")\");\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tresult.add(sb.toString());\\n\\t\\t\\t\\t\\tfolderNameMap.put(result.get(idx),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfolderNameMap.getOrDefault(result.get(idx), 0) + 1);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tresult.add(names[idx]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tString[] finalResult = new String[result.size()];\\n\\t\\t\\tfinalResult = result.toArray(finalResult);\\n\\t\\t\\treturn finalResult;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2335482,
                "title": "intuitive-do-as-hints-say",
                "content": "```\\nclass Solution {\\n    \\n    unordered_map<string, int> next_index_;\\n    \\n    bool contain(const string& fn) {\\n        return next_index_.find(fn) != next_index_.end();\\n    }\\n    \\n    string get_name(string fn) {\\n        if (!contain(fn)) {\\n            next_index_.insert({fn, 1});\\n            return fn;\\n        }\\n        \\n        int idx = next_index_[fn];\\n        auto cur = fn;\\n        while (contain(cur)) {\\n            next_index_.insert({cur, 1});\\n            cur = fn + \"(\" + to_string(idx) + \")\";\\n            ++idx;\\n        }\\n        next_index_.insert({cur, 1});\\n        next_index_[fn] = idx;\\n        return cur;\\n    }\\n    \\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> res;\\n        for (auto& n : names) {\\n            res.push_back(get_name(n));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    unordered_map<string, int> next_index_;\\n    \\n    bool contain(const string& fn) {\\n        return next_index_.find(fn) != next_index_.end();\\n    }\\n    \\n    string get_name(string fn) {\\n        if (!contain(fn)) {\\n            next_index_.insert({fn, 1});\\n            return fn;\\n        }\\n        \\n        int idx = next_index_[fn];\\n        auto cur = fn;\\n        while (contain(cur)) {\\n            next_index_.insert({cur, 1});\\n            cur = fn + \"(\" + to_string(idx) + \")\";\\n            ++idx;\\n        }\\n        next_index_.insert({cur, 1});\\n        next_index_[fn] = idx;\\n        return cur;\\n    }\\n    \\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> res;\\n        for (auto& n : names) {\\n            res.push_back(get_name(n));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252437,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string,int>m;\\n         vector<string>ans;\\n        for(auto n : names){\\n            if(m.count(n)){\\n                int i =m[n];\\n                string t = n;\\n                while(m.count(t)){\\n                    t = t + \"(\" + to_string(i) + \")\";\\n                    if(!m.count(t)){\\n                        ans.push_back(t);\\n                        m[t]++;\\n                        m[n]++;\\n                        break;\\n                    }\\n                    i++;\\n                    t = n;\\n                }\\n            }\\n            else {\\n                m[n]++;\\n                ans.push_back(n);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string,int>m;\\n         vector<string>ans;\\n        for(auto n : names){\\n            if(m.count(n)){\\n                int i =m[n];\\n                string t = n;\\n                while(m.count(t)){\\n                    t = t + \"(\" + to_string(i) + \")\";\\n                    if(!m.count(t)){\\n                        ans.push_back(t);\\n                        m[t]++;\\n                        m[n]++;\\n                        break;\\n                    }\\n                    i++;\\n                    t = n;\\n                }\\n            }\\n            else {\\n                m[n]++;\\n                ans.push_back(n);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243469,
                "title": "javascript-solution-using-map-with-comments",
                "content": "```\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nvar getFolderNames = function(names) {\\n    // save existed folder names\\n    let hashMap = new Map();\\n    for(let name of names) {\\n        let finalName = name;\\n        // next smallest suffix number\\n        // if this name is not present in the map, next smallest suffix will be 1\\n        let number = hashMap.get(name) || 1;\\n        if(hashMap.has(name)) {\\n            // append suffix to original name\\n            finalName += \\'(\\' + number +\\')\\';\\n            // find the smallest suffix that hasn\\'t been used before\\n            while(hashMap.has(finalName)) {\\n                number++;\\n                // try to use new suffix to update name\\n                finalName = name + \\'(\\' + number +\\')\\';\\n            }\\n            // update next smallest suffix number of new name\\n            hashMap.set(finalName, 1);\\n        }\\n        // update next smallest suffix number of original name\\n        hashMap.set(name, number);\\n    }\\n    return Array.from(hashMap.keys());\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nvar getFolderNames = function(names) {\\n    // save existed folder names\\n    let hashMap = new Map();\\n    for(let name of names) {\\n        let finalName = name;\\n        // next smallest suffix number\\n        // if this name is not present in the map, next smallest suffix will be 1\\n        let number = hashMap.get(name) || 1;\\n        if(hashMap.has(name)) {\\n            // append suffix to original name\\n            finalName += \\'(\\' + number +\\')\\';\\n            // find the smallest suffix that hasn\\'t been used before\\n            while(hashMap.has(finalName)) {\\n                number++;\\n                // try to use new suffix to update name\\n                finalName = name + \\'(\\' + number +\\')\\';\\n            }\\n            // update next smallest suffix number of new name\\n            hashMap.set(finalName, 1);\\n        }\\n        // update next smallest suffix number of original name\\n        hashMap.set(name, number);\\n    }\\n    return Array.from(hashMap.keys());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192048,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    Map<String, Integer> map = new HashMap<>();\\n    \\n    public String[] getFolderNames(String[] names) {\\n        String[] op = new String[names.length];\\n        int i = 0;\\n        \\n        for(String cur : names){\\n            if(map.containsKey(cur)) {\\n                cur = generateCopyName(cur);\\n                op[i++] = cur;\\n             //   System.out.println(map.toString());\\n                continue;\\n            }\\n            \\n            op[i++] = cur;\\n            map.put(cur, 0);\\n           // System.out.println(map.toString());\\n        }\\n        \\n        return op;\\n    }\\n    \\n    private String generateCopyName(String s) {\\n        int count = map.get(s) + 1;\\n        \\n        String postfix = \"(\" + count + \")\";\\n        StringBuilder sb = new StringBuilder(s);\\n        sb.append(postfix);\\n        \\n        boolean isChanged = false;\\n        while(map.containsKey(sb.toString())) {\\n            sb = new StringBuilder(s);\\n            sb.append(\"(\" + count + \")\");\\n            count++;\\n            isChanged = true;\\n        }\\n        String res = sb.toString();\\n        //System.out.println(res);\\n        \\n        \\n        if(isChanged)\\n            count = count -1;\\n        \\n        map.put(s, count);\\n        map.put(res, 0);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Integer> map = new HashMap<>();\\n    \\n    public String[] getFolderNames(String[] names) {\\n        String[] op = new String[names.length];\\n        int i = 0;\\n        \\n        for(String cur : names){\\n            if(map.containsKey(cur)) {\\n                cur = generateCopyName(cur);\\n                op[i++] = cur;\\n             //   System.out.println(map.toString());\\n                continue;\\n            }\\n            \\n            op[i++] = cur;\\n            map.put(cur, 0);\\n           // System.out.println(map.toString());\\n        }\\n        \\n        return op;\\n    }\\n    \\n    private String generateCopyName(String s) {\\n        int count = map.get(s) + 1;\\n        \\n        String postfix = \"(\" + count + \")\";\\n        StringBuilder sb = new StringBuilder(s);\\n        sb.append(postfix);\\n        \\n        boolean isChanged = false;\\n        while(map.containsKey(sb.toString())) {\\n            sb = new StringBuilder(s);\\n            sb.append(\"(\" + count + \")\");\\n            count++;\\n            isChanged = true;\\n        }\\n        String res = sb.toString();\\n        //System.out.println(res);\\n        \\n        \\n        if(isChanged)\\n            count = count -1;\\n        \\n        map.put(s, count);\\n        map.put(res, 0);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183863,
                "title": "long-and-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> ans;\\n        unordered_map<string, int> um;\\n        for(string &name : names)\\n        {\\n            string s = name;\\n            if(um.count(name))\\n            {\\n                string f = s + \\'(\\' + to_string(um[name]) + \\')\\';\\n                while(um.count(f))\\n                {\\n                    um[name]++;\\n                    f = s + \\'(\\' + to_string(um[name]) + \\')\\';\\n                }\\n                um[f] = 1;\\n                um[name]++;\\n                ans.push_back(f);\\n            }\\n            else\\n            {\\n                int sz = s.size();\\n                if(s[sz-1] == \\')\\')\\n                {\\n                    //cout << s;\\n                    int i = sz-2;\\n                    string num = \"\";\\n                    while(i >= 1 && s[i] != \\'(\\' && isdigit(s[i]))\\n                    {\\n                        string tmp = \"\";\\n                        tmp += s[i];\\n                        num.insert(0,tmp);\\n                        //cout << num;\\n                        i--;\\n                    }\\n                    //cout << num;\\n                    if(s[i] == \\'(\\')\\n                    {\\n                        \\n                        string sub = s.substr(0,i);\\n                        //cout << sub;\\n                        if(um.count(sub))\\n                        {\\n                            i = stoi(num);\\n                            if(um[sub] == i)\\n                            {\\n                                um[sub]++;\\n                                um[s] = 1;\\n                                ans.push_back(s);\\n                            }\\n                            else\\n                            {\\n                                um[s] = 1;\\n                                ans.push_back(s);\\n                            }\\n                        }\\n                        else\\n                        {\\n                                um[s] = 1;\\n                                ans.push_back(s);  \\n                        }\\n                    }\\n                    else\\n                    {\\n                        um[s] = 1;\\n                        ans.push_back(s);\\n                    }\\n                }\\n                else\\n                {\\n                    um[s] = 1;\\n                    ans.push_back(s);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> ans;\\n        unordered_map<string, int> um;\\n        for(string &name : names)\\n        {\\n            string s = name;\\n            if(um.count(name))\\n            {\\n                string f = s + \\'(\\' + to_string(um[name]) + \\')\\';\\n                while(um.count(f))\\n                {\\n                    um[name]++;\\n                    f = s + \\'(\\' + to_string(um[name]) + \\')\\';\\n                }\\n                um[f] = 1;\\n                um[name]++;\\n                ans.push_back(f);\\n            }\\n            else\\n            {\\n                int sz = s.size();\\n                if(s[sz-1] == \\')\\')\\n                {\\n                    //cout << s;\\n                    int i = sz-2;\\n                    string num = \"\";\\n                    while(i >= 1 && s[i] != \\'(\\' && isdigit(s[i]))\\n                    {\\n                        string tmp = \"\";\\n                        tmp += s[i];\\n                        num.insert(0,tmp);\\n                        //cout << num;\\n                        i--;\\n                    }\\n                    //cout << num;\\n                    if(s[i] == \\'(\\')\\n                    {\\n                        \\n                        string sub = s.substr(0,i);\\n                        //cout << sub;\\n                        if(um.count(sub))\\n                        {\\n                            i = stoi(num);\\n                            if(um[sub] == i)\\n                            {\\n                                um[sub]++;\\n                                um[s] = 1;\\n                                ans.push_back(s);\\n                            }\\n                            else\\n                            {\\n                                um[s] = 1;\\n                                ans.push_back(s);\\n                            }\\n                        }\\n                        else\\n                        {\\n                                um[s] = 1;\\n                                ans.push_back(s);  \\n                        }\\n                    }\\n                    else\\n                    {\\n                        um[s] = 1;\\n                        ans.push_back(s);\\n                    }\\n                }\\n                else\\n                {\\n                    um[s] = 1;\\n                    ans.push_back(s);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2180530,
                "title": "unordered-map",
                "content": "```\\nic:\\n    vector<string> getFolderNames(vector<string>& n) {\\n        unordered_map<string,int>m;\\n        string g=\"\";\\n        for(int i = 0;i<n.size();i++){\\n            if(m.count(n[i])){\\n                g = n[i]+\\'(\\'+to_string(m[n[i]])+\\')\\';\\n                while(m.count(g)){\\n                    g = n[i]+\\'(\\'+to_string(++m[n[i]])+\\')\\';\\n                }\\n                m[n[i]]++;\\n                n[i]=g;\\n                m[g]=1;\\n            }\\n            else\\n                m[n[i]]=1;\\n        }\\n        return n;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nic:\\n    vector<string> getFolderNames(vector<string>& n) {\\n        unordered_map<string,int>m;\\n        string g=\"\";\\n        for(int i = 0;i<n.size();i++){\\n            if(m.count(n[i])){\\n                g = n[i]+\\'(\\'+to_string(m[n[i]])+\\')\\';\\n                while(m.count(g)){\\n                    g = n[i]+\\'(\\'+to_string(++m[n[i]])+\\')\\';\\n                }\\n                m[n[i]]++;\\n                n[i]=g;\\n                m[g]=1;\\n            }\\n            else\\n                m[n[i]]=1;\\n        }\\n        return n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2156744,
                "title": "c-hashmap-do-comment-a-better-approach-if-any",
                "content": "```\\nclass Solution {\\npublic:    \\n    vector<string> getFolderNames(vector<string>& names) {\\n       unordered_map<string,int>mp;\\n       vector<string>ans;\\n        for(auto&n:names){\\n            string val=n;\\n            int i=mp[val];\\n            while(mp[val]>0){\\n                val=n+\"(\"+to_string(i++)+\")\";\\n                mp[n]=i;\\n            }\\n            ++mp[val];\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    vector<string> getFolderNames(vector<string>& names) {\\n       unordered_map<string,int>mp;\\n       vector<string>ans;\\n        for(auto&n:names){\\n            string val=n;\\n            int i=mp[val];\\n            while(mp[val]>0){\\n                val=n+\"(\"+to_string(i++)+\")\";\\n                mp[n]=i;\\n            }\\n            ++mp[val];\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137729,
                "title": "the-unexpected-right-test-pattern",
                "content": "\\n```text\\nYour input: [\"f(1)\",\"f(1)\",\"f(1)\",\"f(1)\"]\\nExpected: [\"f(1)\",\"f(1)(1)\",\"f(1)(2)\",\"f(1)(3)\"]\\n```\\n\\nHope this test pattern will shed some light for you.\\nI was expected that the answer should be: `[\"f(1)\",\"f(2)\",\"f(3)\",\"f(4)\"]`.\\nBut then it all makes sense, this is just a medium question after all.\\n\\n```cpp\\nmap<string, int> hit;\\nint n = names.size();\\nvector<string> ret(n);\\n\\nfor (int i = 0; i < n; ++i)\\n{\\n\\tint k = hit[names[i]];\\n\\tif (k)\\n\\t{\\n\\t\\tstring str = \"\";\\n\\t\\t\\n\\t\\tdo\\n\\t\\t{\\n\\t\\t\\tstr = names[i] + \"(\" + to_string(k ++) + \")\";\\n\\t\\t} while (hit[str]);\\n\\t\\t\\n\\t\\thit[names[i]] = k;\\n\\t\\t++ hit[str];\\n\\t\\tret[i] = str;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\t++ hit[names[i]];\\n\\t\\tret[i] = names[i];\\n\\t}\\n}\\n\\nreturn ret;\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```text\\nYour input: [\"f(1)\",\"f(1)\",\"f(1)\",\"f(1)\"]\\nExpected: [\"f(1)\",\"f(1)(1)\",\"f(1)(2)\",\"f(1)(3)\"]\\n```\n```cpp\\nmap<string, int> hit;\\nint n = names.size();\\nvector<string> ret(n);\\n\\nfor (int i = 0; i < n; ++i)\\n{\\n\\tint k = hit[names[i]];\\n\\tif (k)\\n\\t{\\n\\t\\tstring str = \"\";\\n\\t\\t\\n\\t\\tdo\\n\\t\\t{\\n\\t\\t\\tstr = names[i] + \"(\" + to_string(k ++) + \")\";\\n\\t\\t} while (hit[str]);\\n\\t\\t\\n\\t\\thit[names[i]] = k;\\n\\t\\t++ hit[str];\\n\\t\\tret[i] = str;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\t++ hit[names[i]];\\n\\t\\tret[i] = names[i];\\n\\t}\\n}\\n\\nreturn ret;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2127368,
                "title": "javascript-simple-hashmap-solution",
                "content": "```\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nvar getFolderNames = function(names) {\\n    let map = {};\\n    \\n    let result = [];\\n    for(let i = 0; i < names.length; i++){\\n        if(map[names[i]]){\\n            let count = 1;\\n            let temp = `${names[i]}(${count})`;\\n            while(map[temp]){\\n                count += 1;\\n                temp = `${names[i]}(${count})`;\\n            }\\n            result.push(temp);\\n            map[temp] = true;\\n        } else {\\n            result.push(names[i]);\\n            map[names[i]] = true;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nvar getFolderNames = function(names) {\\n    let map = {};\\n    \\n    let result = [];\\n    for(let i = 0; i < names.length; i++){\\n        if(map[names[i]]){\\n            let count = 1;\\n            let temp = `${names[i]}(${count})`;\\n            while(map[temp]){\\n                count += 1;\\n                temp = `${names[i]}(${count})`;\\n            }\\n            result.push(temp);\\n            map[temp] = true;\\n        } else {\\n            result.push(names[i]);\\n            map[names[i]] = true;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2077214,
                "title": "java-using-hashmap",
                "content": "```\\nclass Solution {\\n\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> hs = new HashMap<>();\\n        String res[] = new String[names.length];\\n        for (int i = 0; i < names.length; i++) {\\n            StringBuilder sb = new StringBuilder(\"\");\\n            hs.put(names[i], hs.getOrDefault(names[i], 0) + 1);\\n            if (hs.get(names[i]) > 1) {\\n                int count = hs.get(names[i]) - 1;\\n                sb.append(names[i] + \"(\" + count + \")\");\\n\\n                while (hs.containsKey(sb.toString())) {\\n                    count++;\\n                    sb = new StringBuilder(names[i]);\\n                    sb.append(\"(\" + (count) + \")\");\\n                }\\n\\n                res[i] = sb.toString();\\n                hs.put(res[i], hs.getOrDefault(res[i], 0) + 1);\\n            } else {\\n                res[i] = names[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> hs = new HashMap<>();\\n        String res[] = new String[names.length];\\n        for (int i = 0; i < names.length; i++) {\\n            StringBuilder sb = new StringBuilder(\"\");\\n            hs.put(names[i], hs.getOrDefault(names[i], 0) + 1);\\n            if (hs.get(names[i]) > 1) {\\n                int count = hs.get(names[i]) - 1;\\n                sb.append(names[i] + \"(\" + count + \")\");\\n\\n                while (hs.containsKey(sb.toString())) {\\n                    count++;\\n                    sb = new StringBuilder(names[i]);\\n                    sb.append(\"(\" + (count) + \")\");\\n                }\\n\\n                res[i] = sb.toString();\\n                hs.put(res[i], hs.getOrDefault(res[i], 0) + 1);\\n            } else {\\n                res[i] = names[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044802,
                "title": "hashmap-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names){\\n \\n        map<string,int> m;\\n        for(int i=0;i<names.size();i++){\\n            if(!m[names[i]]){\\n                m[names[i]]++;\\n            }else{\\n                \\n                string temp=names[i]+\\'(\\'+to_string(m[names[i]])+\\')\\';\\n                // cout<<temp<<endl;\\n                while(m[temp]){\\n                    m[names[i]]++;\\n                    temp=names[i]+\\'(\\'+to_string(m[names[i]])+\\')\\';\\n                }\\n                names[i]=temp;\\n                m[names[i]]++;\\n            }\\n        } \\n     return names;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names){\\n \\n        map<string,int> m;\\n        for(int i=0;i<names.size();i++){\\n            if(!m[names[i]]){\\n                m[names[i]]++;\\n            }else{\\n                \\n                string temp=names[i]+\\'(\\'+to_string(m[names[i]])+\\')\\';\\n                // cout<<temp<<endl;\\n                while(m[temp]){\\n                    m[names[i]]++;\\n                    temp=names[i]+\\'(\\'+to_string(m[names[i]])+\\')\\';\\n                }\\n                names[i]=temp;\\n                m[names[i]]++;\\n            }\\n        } \\n     return names;  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2026812,
                "title": "go-easiest-solution-hashmap",
                "content": "```go\\nfunc getFolderNames(names []string) []string {\\n    seen := make(map[string]int)\\n    resp := make([]string, len(names))\\n    \\n    for idx, fileName := range names {\\n        f := fileName\\n        _, ok := seen[f]\\n        if ok {\\n            for seen[f] != 0 {\\n                f = fmt.Sprintf(\"%s(%d)\", fileName, seen[fileName])\\n                seen[fileName]++\\n            }\\n        }\\n        resp[idx] = f\\n        seen[f]++\\n    }\\n    return resp\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc getFolderNames(names []string) []string {\\n    seen := make(map[string]int)\\n    resp := make([]string, len(names))\\n    \\n    for idx, fileName := range names {\\n        f := fileName\\n        _, ok := seen[f]\\n        if ok {\\n            for seen[f] != 0 {\\n                f = fmt.Sprintf(\"%s(%d)\", fileName, seen[fileName])\\n                seen[fileName]++\\n            }\\n        }\\n        resp[idx] = f\\n        seen[f]++\\n    }\\n    return resp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2020424,
                "title": "javascript-solution-beats-82-14",
                "content": "```\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nvar getFolderNames = function(names) {\\n    const map = {};\\n    const res = [];\\n    \\n    for (const folderName of names) {\\n        if (folderName in map) {\\n            let k = map[folderName];\\n            let name = `${folderName}(${k})`;\\n            \\n            while(name in map) {\\n                k++;\\n                name = `${folderName}(${k})`;\\n            }\\n            \\n            map[name] = 1;\\n            map[folderName]++;\\n            res.push(name);\\n        } else {\\n            map[folderName] = 1;\\n            res.push(folderName);\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} names\\n * @return {string[]}\\n */\\nvar getFolderNames = function(names) {\\n    const map = {};\\n    const res = [];\\n    \\n    for (const folderName of names) {\\n        if (folderName in map) {\\n            let k = map[folderName];\\n            let name = `${folderName}(${k})`;\\n            \\n            while(name in map) {\\n                k++;\\n                name = `${folderName}(${k})`;\\n            }\\n            \\n            map[name] = 1;\\n            map[folderName]++;\\n            res.push(name);\\n        } else {\\n            map[folderName] = 1;\\n            res.push(folderName);\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2011664,
                "title": "python-hashmap-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        # Hashmap will store the name as key and the number of times that name has duplicated so fas as value.\\n        hashmap = {}\\n        \\n        for name in names:\\n            modified = name\\n            # Check whether the name has already been used\\n            if name in hashmap:\\n                # Get the number of times the {name} has been used\\n                k = hashmap[name]\\n                # Calculate the next available suffix.\\n                while modified in hashmap:\\n                    k += 1\\n                    modified = f\\'{name}({k})\\'\\n                # Update the number of times the original {name} is used. This will help to efficiently check for next available suffix if the {name} again comes in future.\\n                hashmap[name] = k\\n            # Store the modified {name} with 0 as it is not duplicated yet.\\n            hashmap[modified] = 0\\n            \\n        # Return the keys of hashmap as that would be the unique file names.\\n        return hashmap.keys()\\n```\\n\\n\\n### Note: \\n- \\t**Amortised** Time Complexity is O(n)\\n\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        # Hashmap will store the name as key and the number of times that name has duplicated so fas as value.\\n        hashmap = {}\\n        \\n        for name in names:\\n            modified = name\\n            # Check whether the name has already been used\\n            if name in hashmap:\\n                # Get the number of times the {name} has been used\\n                k = hashmap[name]\\n                # Calculate the next available suffix.\\n                while modified in hashmap:\\n                    k += 1\\n                    modified = f\\'{name}({k})\\'\\n                # Update the number of times the original {name} is used. This will help to efficiently check for next available suffix if the {name} again comes in future.\\n                hashmap[name] = k\\n            # Store the modified {name} with 0 as it is not duplicated yet.\\n            hashmap[modified] = 0\\n            \\n        # Return the keys of hashmap as that would be the unique file names.\\n        return hashmap.keys()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998348,
                "title": "clean-kotlin-using-mutablemap-solution",
                "content": "```\\nclass Solution {\\n    private val keyCount: MutableMap<String, Int> = mutableMapOf()\\n    \\n    fun getFolderNames(names: Array<String>): Array<String> {\\n        val results: MutableList<String> = mutableListOf()\\n        \\n        for (index in 0 .. names.lastIndex) {\\n            val name = names[index]\\n            val result = if (keyCount[name] == null) {\\n                name\\n            } else {\\n                var counter = keyCount.getOrDefault(name, 0)\\n                while(keyCount[\"$name($counter)\"] != null) {\\n                    counter++\\n                }\\n                keyCount[name] = counter + 1\\n                \"$name($counter)\"\\n            }\\n            \\n            names[index] = result\\n            keyCount[result] = keyCount.getOrDefault(result, 0) + 1 \\n        }\\n        \\n        return names\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    private val keyCount: MutableMap<String, Int> = mutableMapOf()\\n    \\n    fun getFolderNames(names: Array<String>): Array<String> {\\n        val results: MutableList<String> = mutableListOf()\\n        \\n        for (index in 0 .. names.lastIndex) {\\n            val name = names[index]\\n            val result = if (keyCount[name] == null) {\\n                name\\n            } else {\\n                var counter = keyCount.getOrDefault(name, 0)\\n                while(keyCount[\"$name($counter)\"] != null) {\\n                    counter++\\n                }\\n                keyCount[name] = counter + 1\\n                \"$name($counter)\"\\n            }\\n            \\n            names[index] = result\\n            keyCount[result] = keyCount.getOrDefault(result, 0) + 1 \\n        }\\n        \\n        return names\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954026,
                "title": "simple-java-solution",
                "content": "\\tclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> seen = new HashMap<>();\\n        String[] out = new String[names.length];\\n        int index = 0;\\n        for(String name : names){\\n            if(!seen.containsKey(name)){\\n                out[index++] = name;\\n                seen.put(name, 1);\\n            }else{\\n                int count = seen.get(name);\\n                String key = name + \"(\" + count + \")\";\\n                while(seen.containsKey(key)){\\n                    count++;\\n                    key = name + \"(\" + count + \")\";\\n                }\\n                out[index++] = key;\\n                seen.put(key, 1);\\n                seen.put(name, count + 1);\\n            }\\n        }\\n        return out;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String[] getFolderNames(String[] names) {\\n        Map<String, Integer> seen = new HashMap<>();\\n        String[] out = new String[names.length];\\n        int index = 0;\\n        for(String name : names){\\n            if(!seen.containsKey(name)){\\n                out[index++] = name;\\n                seen.put(name, 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1924646,
                "title": "c-solution",
                "content": "```\\n    vector<string> getFolderNames(vector<string>& names) {\\n        // files keeps the number should be appended to the next file with the same name\\n        // if a new file after appending the number still has the same name of another file, then it means that\\n        // the number is outdated it needs to be updated, i.e. plus one\\n        // then let the new file append the new number and try again until no existing file with the same name as it\\n        unordered_map<string, int> files;\\n        vector<string> res;\\n        for (auto& s : names) {\\n            if (files.find(s) == files.end()) {\\n                files[s] = 1;\\n                res.push_back(s);\\n                continue;\\n            }\\n            string newStr = s + \\'(\\' + to_string(files[s]++) + \\')\\';\\n            while (files.find(newStr) != files.end()) {\\n                newStr = s + \\'(\\' + to_string(files[s]++) + \\')\\';\\n            }\\n            files[newStr] = 1;\\n            res.push_back(newStr);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<string> getFolderNames(vector<string>& names) {\\n        // files keeps the number should be appended to the next file with the same name\\n        // if a new file after appending the number still has the same name of another file, then it means that\\n        // the number is outdated it needs to be updated, i.e. plus one\\n        // then let the new file append the new number and try again until no existing file with the same name as it\\n        unordered_map<string, int> files;\\n        vector<string> res;\\n        for (auto& s : names) {\\n            if (files.find(s) == files.end()) {\\n                files[s] = 1;\\n                res.push_back(s);\\n                continue;\\n            }\\n            string newStr = s + \\'(\\' + to_string(files[s]++) + \\')\\';\\n            while (files.find(newStr) != files.end()) {\\n                newStr = s + \\'(\\' + to_string(files[s]++) + \\')\\';\\n            }\\n            files[newStr] = 1;\\n            res.push_back(newStr);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1896393,
                "title": "typescript-and-js-easy-way-with-map",
                "content": "```\\nvar getFolderNames = function(names) {\\n  const map = new Map();\\n    \\n  for (const name of names) {\\n    if (!map.has(name)) {\\n      map.set(name, 1);\\n    } else {\\n      let count = map.get(name);\\n      let newName = `${name}(${count})`;  \\n\\t  \\n      while (map.has(newName)) {\\n        count++;\\n        newName = `${name}(${count})`;\\n      }\\n      \\n\\t  \\n      map.set(name, count + 1);\\n      map.set(newName, 1);\\n    }\\n  }  \\n    \\n  return [...map.keys()];\\n};",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nvar getFolderNames = function(names) {\\n  const map = new Map();\\n    \\n  for (const name of names) {\\n    if (!map.has(name)) {\\n      map.set(name, 1);\\n    } else {\\n      let count = map.get(name);\\n      let newName = `${name}(${count})`;  \\n\\t  \\n      while (map.has(newName)) {\\n        count++;\\n        newName = `${name}(${count})`;\\n      }\\n      \\n\\t  \\n      map.set(name, count + 1);\\n      map.set(newName, 1);\\n    }\\n  }  \\n    \\n  return [...map.keys()];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1767568,
                "title": "rust",
                "content": "```rust\\nimpl Solution {\\n    pub fn get_folder_names(names: Vec<String>) -> Vec<String> {\\n        use std::collections::HashMap;\\n        let mut m = HashMap::<String, usize>::new();\\n        let mut res = vec!();\\n        for n in &names {\\n            let mut tmp = n.clone();\\n            while m.contains_key(tmp.as_str()) {\\n                tmp = format!(\"{}({})\", n, m[n]);\\n                *m.entry(n.clone()).or_default() += 1;\\n            }\\n            *m.entry(n.clone()).or_default() += 1;\\n            res.push(tmp);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn get_folder_names(names: Vec<String>) -> Vec<String> {\\n        use std::collections::HashMap;\\n        let mut m = HashMap::<String, usize>::new();\\n        let mut res = vec!();\\n        for n in &names {\\n            let mut tmp = n.clone();\\n            while m.contains_key(tmp.as_str()) {\\n                tmp = format!(\"{}({})\", n, m[n]);\\n                *m.entry(n.clone()).or_default() += 1;\\n            }\\n            *m.entry(n.clone()).or_default() += 1;\\n            res.push(tmp);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766618,
                "title": "my-java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        if (names == null || names.length == 0) {\\n            return names;\\n        }\\n        HashMap<String, Integer> map = new HashMap<>();\\n        String[] res = new String[names.length];\\n        for (int i = 0; i < names.length; i++) {\\n            if (map.containsKey(names[i])) {\\n                String curName = names[i];\\n                int idx = map.get(curName);\\n                while (true) {\\n                    StringBuilder sb = new StringBuilder(curName);\\n                    sb.append(\\'(\\').append(idx).append(\\')\\');\\n                    String newName = sb.toString();\\n                    if (!map.containsKey(newName)) {\\n                        res[i] = newName;\\n                        map.put(newName, 1);\\n                        map.put(names[i], idx + 1);\\n                        break;\\n                    }\\n                    idx++;\\n                }\\n            } else {\\n                map.put(names[i], 1);\\n                res[i] = names[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        if (names == null || names.length == 0) {\\n            return names;\\n        }\\n        HashMap<String, Integer> map = new HashMap<>();\\n        String[] res = new String[names.length];\\n        for (int i = 0; i < names.length; i++) {\\n            if (map.containsKey(names[i])) {\\n                String curName = names[i];\\n                int idx = map.get(curName);\\n                while (true) {\\n                    StringBuilder sb = new StringBuilder(curName);\\n                    sb.append(\\'(\\').append(idx).append(\\')\\');\\n                    String newName = sb.toString();\\n                    if (!map.containsKey(newName)) {\\n                        res[i] = newName;\\n                        map.put(newName, 1);\\n                        map.put(names[i], idx + 1);\\n                        break;\\n                    }\\n                    idx++;\\n                }\\n            } else {\\n                map.put(names[i], 1);\\n                res[i] = names[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740405,
                "title": "javascript-solution",
                "content": "```\\nvar getFolderNames = function(names) {\\n  const namesCountMap = {};\\n  let solution = [];\\n  for (let i = 0; i < names.length; i++) {\\n      let currName = names[i];\\n\\n      if (!(currName in namesCountMap)) {\\n        solution.push(currName);\\n        namesCountMap[currName] = 0;\\n      } else {\\n        namesCountMap[currName] += 1;\\n        let currNameCount = namesCountMap[currName];\\n        let newName = `${currName}(${currNameCount})`;\\n        while (newName in namesCountMap) {\\n          newName = `${currName}(${++currNameCount})`;\\n        }\\n        solution.push(newName);\\n        namesCountMap[newName] = 0;\\n      }\\n  }\\n  return solution;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar getFolderNames = function(names) {\\n  const namesCountMap = {};\\n  let solution = [];\\n  for (let i = 0; i < names.length; i++) {\\n      let currName = names[i];\\n\\n      if (!(currName in namesCountMap)) {\\n        solution.push(currName);\\n        namesCountMap[currName] = 0;\\n      } else {\\n        namesCountMap[currName] += 1;\\n        let currNameCount = namesCountMap[currName];\\n        let newName = `${currName}(${currNameCount})`;\\n        while (newName in namesCountMap) {\\n          newName = `${currName}(${++currNameCount})`;\\n        }\\n        solution.push(newName);\\n        namesCountMap[newName] = 0;\\n      }\\n  }\\n  return solution;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1553992,
                "title": "java-hashmap-with-comments",
                "content": "```\\n    public String[] getFolderNames(String[] names) {\\n        if(names == null || names.length == 0) {\\n            return names;\\n        }\\n        String[] res = new String[names.length];\\n        Map<String, Integer> freq = new HashMap<>(); // key - name; value - name\\'s already assigned largest number\\n        for(int i = 0; i < names.length; i++) {\\n\\t\\t    // current name\\n            String str = names[i];\\n            int count = 0;\\n            if(!freq.containsKey(str)) {\\n                freq.put(str, count);\\n                res[i] = str;\\n            }else {\\n                String newStr = str;\\n                // keep building the current name with an adding number until we can\\'t find the new created name in the map\\n                while(freq.containsKey(newStr)) {\\n\\t\\t\\t\\t    // get the already assigned largest number of current name\\n                    count = freq.get(str);\\n\\t\\t\\t\\t\\t// add it by 1\\n                    count++;\\n\\t\\t\\t\\t\\t// create a new name with current name and the added number\\n                    newStr = str + \"(\" + count + \")\";\\n                    // update the current name\\'s assigned number\\n                    freq.put(str, count);\\n                }\\n\\t\\t\\t\\t// found a unique name, add it to the result\\n                res[i] = newStr;\\n                // put the new created unique name into the map\\n                freq.put(newStr, 0);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)",
                "solutionTags": [],
                "code": "```\\n    public String[] getFolderNames(String[] names) {\\n        if(names == null || names.length == 0) {\\n            return names;\\n        }\\n        String[] res = new String[names.length];\\n        Map<String, Integer> freq = new HashMap<>(); // key - name; value - name\\'s already assigned largest number\\n        for(int i = 0; i < names.length; i++) {\\n\\t\\t    // current name\\n            String str = names[i];\\n            int count = 0;\\n            if(!freq.containsKey(str)) {\\n                freq.put(str, count);\\n                res[i] = str;\\n            }else {\\n                String newStr = str;\\n                // keep building the current name with an adding number until we can\\'t find the new created name in the map\\n                while(freq.containsKey(newStr)) {\\n\\t\\t\\t\\t    // get the already assigned largest number of current name\\n                    count = freq.get(str);\\n\\t\\t\\t\\t\\t// add it by 1\\n                    count++;\\n\\t\\t\\t\\t\\t// create a new name with current name and the added number\\n                    newStr = str + \"(\" + count + \")\";\\n                    // update the current name\\'s assigned number\\n                    freq.put(str, count);\\n                }\\n\\t\\t\\t\\t// found a unique name, add it to the result\\n                res[i] = newStr;\\n                // put the new created unique name into the map\\n                freq.put(newStr, 0);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539744,
                "title": "go",
                "content": "```\\nfunc getFolderNames(names []string) []string {\\n    var res []string\\n    set := make(map[string]int)\\n    for _, v := range names {\\n        if set[v] == 0 {\\n            set[v] = 1\\n            res = append(res, v)\\n        } else {\\n            i := set[v]\\n            for {\\n                tmp := v + \"(\" + strconv.Itoa(i) + \")\"\\n                if set[tmp] != 0 {\\n                    i++\\n                } else {\\n                    set[v] = i + 1\\n                    set[tmp] = 1\\n                    res = append(res, tmp)\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc getFolderNames(names []string) []string {\\n    var res []string\\n    set := make(map[string]int)\\n    for _, v := range names {\\n        if set[v] == 0 {\\n            set[v] = 1\\n            res = append(res, v)\\n        } else {\\n            i := set[v]\\n            for {\\n                tmp := v + \"(\" + strconv.Itoa(i) + \")\"\\n                if set[tmp] != 0 {\\n                    i++\\n                } else {\\n                    set[v] = i + 1\\n                    set[tmp] = 1\\n                    res = append(res, tmp)\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1531780,
                "title": "1487-why-this-incorrect",
                "content": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        String[] res = new String[names.length];\\n        int index = 0;\\n        HashMap<String,Integer> map = new HashMap<>();\\n        for(String i : names){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n            res[index] = i;\\n            if(map.get(i) != 1){\\n                res[index] = i + \"(\" + String.valueOf(map.get(i) - 1) + \")\";\\n                int a = map.get(i);\\n                while(map.containsKey(res[index])){\\n                    res[index] = i + \"(\" + String.valueOf(a) + \")\";\\n                    a++;\\n                }\\n            }\\n            \\n            index++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        String[] res = new String[names.length];\\n        int index = 0;\\n        HashMap<String,Integer> map = new HashMap<>();\\n        for(String i : names){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n            res[index] = i;\\n            if(map.get(i) != 1){\\n                res[index] = i + \"(\" + String.valueOf(map.get(i) - 1) + \")\";\\n                int a = map.get(i);\\n                while(map.containsKey(res[index])){\\n                    res[index] = i + \"(\" + String.valueOf(a) + \")\";\\n                    a++;\\n                }\\n            }\\n            \\n            index++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525593,
                "title": "c-dictionary-100-faster",
                "content": "```\\npublic class Solution {\\n    public string[] GetFolderNames(string[] names) \\n    {\\n        string[] result = new string[names.Length];\\n        \\n        if(names == null || names.Length == 0) return result;\\n        \\n        Dictionary<string,int> suffixMap = new Dictionary<string,int>();\\n                \\n        for(int i = 0 ;  i < names.Length ; i++)\\n        {   \\n           if(suffixMap.ContainsKey(names[i]))\\n           {\\n               int newIndex = ++suffixMap[names[i]];\\n               string temp = names[i] + \"(\" + newIndex + \")\";  \\n\\t\\t\\t    // Need to check if there is already an entry present with the generated string\\n               while(suffixMap.ContainsKey(temp))\\n               {\\n                   newIndex = newIndex + 1;\\n                   temp = names[i] + \"(\" + newIndex + \")\"; \\n               }\\n               suffixMap.Add(temp,0);\\n               suffixMap[names[i]] = newIndex;\\n           }\\n           else\\n           {\\n               suffixMap.Add(names[i],0);\\n           }\\n        }        \\n        return suffixMap.Keys.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string[] GetFolderNames(string[] names) \\n    {\\n        string[] result = new string[names.Length];\\n        \\n        if(names == null || names.Length == 0) return result;\\n        \\n        Dictionary<string,int> suffixMap = new Dictionary<string,int>();\\n                \\n        for(int i = 0 ;  i < names.Length ; i++)\\n        {   \\n           if(suffixMap.ContainsKey(names[i]))\\n           {\\n               int newIndex = ++suffixMap[names[i]];\\n               string temp = names[i] + \"(\" + newIndex + \")\";  \\n\\t\\t\\t    // Need to check if there is already an entry present with the generated string\\n               while(suffixMap.ContainsKey(temp))\\n               {\\n                   newIndex = newIndex + 1;\\n                   temp = names[i] + \"(\" + newIndex + \")\"; \\n               }\\n               suffixMap.Add(temp,0);\\n               suffixMap[names[i]] = newIndex;\\n           }\\n           else\\n           {\\n               suffixMap.Add(names[i],0);\\n           }\\n        }        \\n        return suffixMap.Keys.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518015,
                "title": "c-map",
                "content": "To me it was a nice question despite so many dislikes. :D\\nExplanation : If a file name doesn\\'t appeared in past, then simply store in to the ans array and increment the minimum no.(k) by 1.\\nto do this we can maintain a map from file name to minimum k value.\\n\\nChallenge was to figure out minimum when a file name is already present in map.\\nwe can handle this by incrementing k and generating the file name.\\nIf filename is already there in map we will increment k and look for the next one.\\n\\n//Below is the code for same.\\n```\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> mp;\\n        vector<string> ans;\\n        for(string s:names)\\n        {\\n            if(mp.find(s) == mp.end())mp[s]++, ans.push_back(s);\\n            else\\n            {\\n                string tmp;\\n                while(1)\\n                {\\n                    tmp = s;\\n                    s += \"(\";\\n                    s += to_string(mp[tmp]);\\n                    s += \")\";\\n                    if(mp.find(s) == mp.end())break;\\n                    s = tmp;\\n                    mp[tmp]++;\\n                    s = tmp;\\n                }\\n                ans.push_back(s);\\n                mp[tmp]++; //original string\\n                mp[s]++; //new string\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        unordered_map<string, int> mp;\\n        vector<string> ans;\\n        for(string s:names)\\n        {\\n            if(mp.find(s) == mp.end())mp[s]++, ans.push_back(s);\\n            else\\n            {\\n                string tmp;\\n                while(1)\\n                {\\n                    tmp = s;\\n                    s += \"(\";\\n                    s += to_string(mp[tmp]);\\n                    s += \")\";\\n                    if(mp.find(s) == mp.end())break;\\n                    s = tmp;\\n                    mp[tmp]++;\\n                    s = tmp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1462294,
                "title": "c-name-frequency-map",
                "content": "```\\n\\nclass Solution \\n{\\npublic:\\n    vector<string> getFolderNames(vector<string>& names)\\n    {\\n        unordered_map<string, int> name_str_frequency_map;\\n        \\n        vector<string> result_str;\\n        \\n        //\\n        //  NOTE:\\n        //\\n        //  Since we need to update the (name_str),\\n        //  we don\\'t want to use the (const) keyword.\\n        //\\n        \\n        for(string& name_str : names)\\n        {\\n            if(name_str_frequency_map.count(name_str))\\n            {\\n                ++name_str_frequency_map[name_str];\\n                \\n                const int cur_frequency = name_str_frequency_map[name_str];\\n\\n                string new_name_str = name_str + \"(\" + to_string(cur_frequency) + \")\";\\n                \\n                while(name_str_frequency_map.count(new_name_str))\\n                {\\n                    ++name_str_frequency_map[name_str];\\n                    \\n                    new_name_str = name_str + \"(\" + \\n                                   to_string(name_str_frequency_map[name_str]) + \")\";\\n                }\\n                \\n                //\\n                // Update the (name_str).\\n                //\\n                \\n                name_str = new_name_str;\\n            }\\n            \\n            //\\n            //  Initialize (the current name) on the map.\\n            //\\n            \\n            name_str_frequency_map[name_str] = 0;\\n            \\n            //\\n            //  Update the Result.\\n            //\\n            \\n            result_str.push_back(name_str);\\n        }\\n        \\n        return result_str;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution \\n{\\npublic:\\n    vector<string> getFolderNames(vector<string>& names)\\n    {\\n        unordered_map<string, int> name_str_frequency_map;\\n        \\n        vector<string> result_str;\\n        \\n        //\\n        //  NOTE:\\n        //\\n        //  Since we need to update the (name_str),\\n        //  we don\\'t want to use the (const) keyword.\\n        //\\n        \\n        for(string& name_str : names)\\n        {\\n            if(name_str_frequency_map.count(name_str))\\n            {\\n                ++name_str_frequency_map[name_str];\\n                \\n                const int cur_frequency = name_str_frequency_map[name_str];\\n\\n                string new_name_str = name_str + \"(\" + to_string(cur_frequency) + \")\";\\n                \\n                while(name_str_frequency_map.count(new_name_str))\\n                {\\n                    ++name_str_frequency_map[name_str];\\n                    \\n                    new_name_str = name_str + \"(\" + \\n                                   to_string(name_str_frequency_map[name_str]) + \")\";\\n                }\\n                \\n                //\\n                // Update the (name_str).\\n                //\\n                \\n                name_str = new_name_str;\\n            }\\n            \\n            //\\n            //  Initialize (the current name) on the map.\\n            //\\n            \\n            name_str_frequency_map[name_str] = 0;\\n            \\n            //\\n            //  Update the Result.\\n            //\\n            \\n            result_str.push_back(name_str);\\n        }\\n        \\n        return result_str;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457872,
                "title": "python-solution-with-dictionary-easy-to-understand-with-explanation",
                "content": "Use a dictionary whose key is `file name ` and value is `next (possibly) available version`\\n\\nThe code below utilizes the helper function `append_version` which will improve the readability\\n\\n```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        def append_version(file_name, version):\\n            return f\"{file_name}({version})\"\\n        \\n        file_name_to_version = {} # key: file name, value: next (possibly) available version\\n    \\n        output = []\\n        for file_name in names:\\n            if file_name not in file_name_to_version:\\n                file_name_to_version[file_name] = 1\\n                output.append(file_name)\\n                continue\\n\\n            version = file_name_to_version[file_name]\\n            versioned_file_name = append_version(file_name, version)\\n            while versioned_file_name in file_name_to_version:\\n                version += 1\\n                versioned_file_name = append_version(file_name, version)\\n\\n            file_name_to_version[versioned_file_name] = 1\\n            file_name_to_version[file_name] = version\\n            output.append(versioned_file_name)\\n\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        def append_version(file_name, version):\\n            return f\"{file_name}({version})\"\\n        \\n        file_name_to_version = {} # key: file name, value: next (possibly) available version\\n    \\n        output = []\\n        for file_name in names:\\n            if file_name not in file_name_to_version:\\n                file_name_to_version[file_name] = 1\\n                output.append(file_name)\\n                continue\\n\\n            version = file_name_to_version[file_name]\\n            versioned_file_name = append_version(file_name, version)\\n            while versioned_file_name in file_name_to_version:\\n                version += 1\\n                versioned_file_name = append_version(file_name, version)\\n\\n            file_name_to_version[versioned_file_name] = 1\\n            file_name_to_version[file_name] = version\\n            output.append(versioned_file_name)\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447306,
                "title": "simple-python-o-n-amortized-dictionary-set-solution",
                "content": "```Python\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        ret, ret_set, name2nextSuffix = [], set(), {}\\n        for n in names:\\n            if n not in name2nextSuffix:\\n                ret.append(n)\\n                ret_set.add(n)\\n                name2nextSuffix[n] = 1\\n            else:\\n                suffix = name2nextSuffix[n]\\n                while n+\\'(\\'+str(suffix)+\\')\\' in ret_set:\\n                    suffix += 1\\n                    name2nextSuffix[n] += 1\\n                name2nextSuffix[n] += 1\\n                name2nextSuffix[n+\\'(\\'+str(suffix)+\\')\\'] = 1\\n                ret.append(n+\\'(\\'+str(suffix)+\\')\\')                \\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```Python\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        ret, ret_set, name2nextSuffix = [], set(), {}\\n        for n in names:\\n            if n not in name2nextSuffix:\\n                ret.append(n)\\n                ret_set.add(n)\\n                name2nextSuffix[n] = 1\\n            else:\\n                suffix = name2nextSuffix[n]\\n                while n+\\'(\\'+str(suffix)+\\')\\' in ret_set:\\n                    suffix += 1\\n                    name2nextSuffix[n] += 1\\n                name2nextSuffix[n] += 1\\n                name2nextSuffix[n+\\'(\\'+str(suffix)+\\')\\'] = 1\\n                ret.append(n+\\'(\\'+str(suffix)+\\')\\')                \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403707,
                "title": "python-easy-to-understand-solution-using-dict-for-next-suffix",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        name2nextSuffix = defaultdict(int)\\n        ret = []\\n        for name in names:\\n            if name not in name2nextSuffix:\\n                name2nextSuffix[name] = 1\\n                ret.append(name)\\n            else:\\n                nextSuffix = name2nextSuffix[name]\\n                while name+\\'(\\'+str(nextSuffix)+\\')\\' in name2nextSuffix:\\n                    nextSuffix += 1\\n                new_name = name+\\'(\\'+str(nextSuffix)+\\')\\'\\n                name2nextSuffix[name] = nextSuffix+1\\n                name2nextSuffix[new_name] = 1\\n                ret.append(new_name)\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n        name2nextSuffix = defaultdict(int)\\n        ret = []\\n        for name in names:\\n            if name not in name2nextSuffix:\\n                name2nextSuffix[name] = 1\\n                ret.append(name)\\n            else:\\n                nextSuffix = name2nextSuffix[name]\\n                while name+\\'(\\'+str(nextSuffix)+\\')\\' in name2nextSuffix:\\n                    nextSuffix += 1\\n                new_name = name+\\'(\\'+str(nextSuffix)+\\')\\'\\n                name2nextSuffix[name] = nextSuffix+1\\n                name2nextSuffix[new_name] = 1\\n                ret.append(new_name)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398484,
                "title": "",
                "content": "\\u4E0D\\u505A\\u4E86\\u3002\\u3002\\u3002\\u3002\\u3002\\u3002\\u3002\\u3002\\u3002\\u3002\\u3002",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1397522,
                "title": "c-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string checkinsert(string s,unordered_map<string,int> &mp)\\n    {\\n        string res;\\n        int k;\\n        if(mp.find(s) != mp.end() && mp[s]>1)\\n        {\\n            k=mp[s]-1;\\n            res=s+\"(\"+to_string(k)+\")\";\\n            while(mp.find(res) != mp.end()){\\n                res=s+\"(\"+to_string(++k)+\")\";\\n            }\\n            \\n            \\n            mp[res]++;\\n            return res;\\n        }\\n        \\n        else\\n            return s;\\n    }\\n    \\n    vector<string> getFolderNames(vector<string>& names) \\n    {\\n        vector<string> ans(names.size(),\"\");\\n        unordered_map<string,int> mp;\\n        \\n        for(int i=0;i<names.size();i++)\\n        {\\n            mp[names[i]]++;\\n            ans[i]=checkinsert(names[i],mp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string checkinsert(string s,unordered_map<string,int> &mp)\\n    {\\n        string res;\\n        int k;\\n        if(mp.find(s) != mp.end() && mp[s]>1)\\n        {\\n            k=mp[s]-1;\\n            res=s+\"(\"+to_string(k)+\")\";\\n            while(mp.find(res) != mp.end()){\\n                res=s+\"(\"+to_string(++k)+\")\";\\n            }\\n            \\n            \\n            mp[res]++;\\n            return res;\\n        }\\n        \\n        else\\n            return s;\\n    }\\n    \\n    vector<string> getFolderNames(vector<string>& names) \\n    {\\n        vector<string> ans(names.size(),\"\");\\n        unordered_map<string,int> mp;\\n        \\n        for(int i=0;i<names.size();i++)\\n        {\\n            mp[names[i]]++;\\n            ans[i]=checkinsert(names[i],mp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375116,
                "title": "java-solution-hashmap-hashset-beats-84",
                "content": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> number = new HashMap();\\n        String[] res = new String[names.length];\\n        HashSet<String> used = new HashSet();\\n        \\n        for (int i = 0; i < names.length; i++){\\n            String n = names[i];\\n            \\n            if (number.containsKey(n)){\\n                int num = number.get(n);\\n                String temp = n + \"(\" + num + \")\";\\n                while (used.contains(temp)){\\n                    num++;\\n                    temp = n + \"(\" + num + \")\";\\n                }\\n                res[i] = temp;\\n                \\n                number.put(n, num + 1);\\n                used.add(temp);\\n            }\\n            else if (used.contains(n)){\\n                int num = 1;\\n                String temp = n + \"(\" + num + \")\";\\n                while (used.contains(temp)){\\n                    num++;\\n                    temp = n + \"(\" + num + \")\";\\n                }\\n                res[i] = temp;\\n                number.put(n, num + 1);\\n                used.add(temp);\\n            }\\n            else{\\n                number.put(n, 1);\\n                used.add(n);\\n                res[i] = n;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] getFolderNames(String[] names) {\\n        HashMap<String, Integer> number = new HashMap();\\n        String[] res = new String[names.length];\\n        HashSet<String> used = new HashSet();\\n        \\n        for (int i = 0; i < names.length; i++){\\n            String n = names[i];\\n            \\n            if (number.containsKey(n)){\\n                int num = number.get(n);\\n                String temp = n + \"(\" + num + \")\";\\n                while (used.contains(temp)){\\n                    num++;\\n                    temp = n + \"(\" + num + \")\";\\n                }\\n                res[i] = temp;\\n                \\n                number.put(n, num + 1);\\n                used.add(temp);\\n            }\\n            else if (used.contains(n)){\\n                int num = 1;\\n                String temp = n + \"(\" + num + \")\";\\n                while (used.contains(temp)){\\n                    num++;\\n                    temp = n + \"(\" + num + \")\";\\n                }\\n                res[i] = temp;\\n                number.put(n, num + 1);\\n                used.add(temp);\\n            }\\n            else{\\n                number.put(n, 1);\\n                used.add(n);\\n                res[i] = n;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564816,
                "content": [
                    {
                        "username": "Leodicap99",
                        "content": "The sample test cases were poor the description was poor. Leetcode should stop posting such questions"
                    },
                    {
                        "username": "luoyuf",
                        "content": "one of most terrible questions I have ever seen.\\n\\nI mean you can post low quality questions, it\\'s ok. But pls do not show us this kind of disaster questions, it\\'s wasting people\\'s time.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Its like a 12 year old got their question added to LC somehow. This question is A) near gibberish, B) not hard once you understand what is being asked, and C) has childish test data. Delete this "
                    },
                    {
                        "username": "krishnakorade",
                        "content": "One Piece Is Real"
                    },
                    {
                        "username": "ryananderson0147",
                        "content": "This test case seems incorrect to me.\n\n`[\"kaido\",\"kaido(1)\",\"kaido\",\"kaido(1)\",\"kaido(2)\"]`\n\nThe expected result is \n\n`[\"kaido\",\"kaido(1)\",\"kaido(2)\",\"kaido(1)(1)\",\"kaido(2)(1)\"]`\n\nFrom the requirements \n\n\"if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\" \n\nHowever \"kaido(2)\" is not a name that is previously used in the array, so it should not receive a new Suffix.  Instead the following should be the expected result.\n\n`[\"kaido\",\"kaido(1)\",\"kaido(3)\",\"kaido(1)(1)\",\"kaido(2)\"]`\n\nWhere \"kaido(2)\" simply remains as is at the end, and we set \"kaido(3)\" to the middle value. That is certainly how I would expect this to work on an operating system. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How did you get to \"kaido(3)\" before processing \"kaido(2)\"? Per the question, you are processing them in order. \n1) \"kaido\" -new, add as is      > \"kaido\"\n2) \"kaido(1)\" -new, add as is   > \"kaido(1)\"\n3) \"kaido\" - NOT new, try adding (1) to it- NOT new, try adding (2) to it.... New, add modified result     >\"kaido(2)\n4) \"kaido(1)\" - NOT new, try adding (1) to it.... New, add modified result    > \"kaido(1)(1)\"\n5) \"kaido(2)\" - NOT new, try adding (1) to it.... New, add modified result  > \"kaido(2)(1)\""
                    },
                    {
                        "username": "shireGangZZ",
                        "content": "C++ solution for \\n\\'\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> result;\\n        \\n        unordered_map<string, int> frequency_counter;\\n        \\n        for(auto x: names){\\n            if(frequency_counter.find(x)==frequency_counter.end()){\\n                result.push_back(x);\\n                frequency_counter[x]++;\\n            } else {\\n                \\n                \\n                string temp = x+ \"(\"+ to_string(frequency_counter[x]) + \")\";\\n                while(frequency_counter.find(temp)!=frequency_counter.end()){\\n                    temp = x+ \"(\"+ to_string(++frequency_counter[x]) + \")\";\\n                }\\n                result.push_back(temp);\\n                frequency_counter[temp]++;\\n                frequency_counter[x]++;\\n            }\\n            \\n        }\\n        \\n        \\n        return result;\\n    }\\n};\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573950,
                "content": [
                    {
                        "username": "Leodicap99",
                        "content": "The sample test cases were poor the description was poor. Leetcode should stop posting such questions"
                    },
                    {
                        "username": "luoyuf",
                        "content": "one of most terrible questions I have ever seen.\\n\\nI mean you can post low quality questions, it\\'s ok. But pls do not show us this kind of disaster questions, it\\'s wasting people\\'s time.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Its like a 12 year old got their question added to LC somehow. This question is A) near gibberish, B) not hard once you understand what is being asked, and C) has childish test data. Delete this "
                    },
                    {
                        "username": "krishnakorade",
                        "content": "One Piece Is Real"
                    },
                    {
                        "username": "ryananderson0147",
                        "content": "This test case seems incorrect to me.\n\n`[\"kaido\",\"kaido(1)\",\"kaido\",\"kaido(1)\",\"kaido(2)\"]`\n\nThe expected result is \n\n`[\"kaido\",\"kaido(1)\",\"kaido(2)\",\"kaido(1)(1)\",\"kaido(2)(1)\"]`\n\nFrom the requirements \n\n\"if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\" \n\nHowever \"kaido(2)\" is not a name that is previously used in the array, so it should not receive a new Suffix.  Instead the following should be the expected result.\n\n`[\"kaido\",\"kaido(1)\",\"kaido(3)\",\"kaido(1)(1)\",\"kaido(2)\"]`\n\nWhere \"kaido(2)\" simply remains as is at the end, and we set \"kaido(3)\" to the middle value. That is certainly how I would expect this to work on an operating system. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How did you get to \"kaido(3)\" before processing \"kaido(2)\"? Per the question, you are processing them in order. \n1) \"kaido\" -new, add as is      > \"kaido\"\n2) \"kaido(1)\" -new, add as is   > \"kaido(1)\"\n3) \"kaido\" - NOT new, try adding (1) to it- NOT new, try adding (2) to it.... New, add modified result     >\"kaido(2)\n4) \"kaido(1)\" - NOT new, try adding (1) to it.... New, add modified result    > \"kaido(1)(1)\"\n5) \"kaido(2)\" - NOT new, try adding (1) to it.... New, add modified result  > \"kaido(2)(1)\""
                    },
                    {
                        "username": "shireGangZZ",
                        "content": "C++ solution for \\n\\'\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> result;\\n        \\n        unordered_map<string, int> frequency_counter;\\n        \\n        for(auto x: names){\\n            if(frequency_counter.find(x)==frequency_counter.end()){\\n                result.push_back(x);\\n                frequency_counter[x]++;\\n            } else {\\n                \\n                \\n                string temp = x+ \"(\"+ to_string(frequency_counter[x]) + \")\";\\n                while(frequency_counter.find(temp)!=frequency_counter.end()){\\n                    temp = x+ \"(\"+ to_string(++frequency_counter[x]) + \")\";\\n                }\\n                result.push_back(temp);\\n                frequency_counter[temp]++;\\n                frequency_counter[x]++;\\n            }\\n            \\n        }\\n        \\n        \\n        return result;\\n    }\\n};\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1854177,
                "content": [
                    {
                        "username": "Leodicap99",
                        "content": "The sample test cases were poor the description was poor. Leetcode should stop posting such questions"
                    },
                    {
                        "username": "luoyuf",
                        "content": "one of most terrible questions I have ever seen.\\n\\nI mean you can post low quality questions, it\\'s ok. But pls do not show us this kind of disaster questions, it\\'s wasting people\\'s time.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Its like a 12 year old got their question added to LC somehow. This question is A) near gibberish, B) not hard once you understand what is being asked, and C) has childish test data. Delete this "
                    },
                    {
                        "username": "krishnakorade",
                        "content": "One Piece Is Real"
                    },
                    {
                        "username": "ryananderson0147",
                        "content": "This test case seems incorrect to me.\n\n`[\"kaido\",\"kaido(1)\",\"kaido\",\"kaido(1)\",\"kaido(2)\"]`\n\nThe expected result is \n\n`[\"kaido\",\"kaido(1)\",\"kaido(2)\",\"kaido(1)(1)\",\"kaido(2)(1)\"]`\n\nFrom the requirements \n\n\"if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\" \n\nHowever \"kaido(2)\" is not a name that is previously used in the array, so it should not receive a new Suffix.  Instead the following should be the expected result.\n\n`[\"kaido\",\"kaido(1)\",\"kaido(3)\",\"kaido(1)(1)\",\"kaido(2)\"]`\n\nWhere \"kaido(2)\" simply remains as is at the end, and we set \"kaido(3)\" to the middle value. That is certainly how I would expect this to work on an operating system. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How did you get to \"kaido(3)\" before processing \"kaido(2)\"? Per the question, you are processing them in order. \n1) \"kaido\" -new, add as is      > \"kaido\"\n2) \"kaido(1)\" -new, add as is   > \"kaido(1)\"\n3) \"kaido\" - NOT new, try adding (1) to it- NOT new, try adding (2) to it.... New, add modified result     >\"kaido(2)\n4) \"kaido(1)\" - NOT new, try adding (1) to it.... New, add modified result    > \"kaido(1)(1)\"\n5) \"kaido(2)\" - NOT new, try adding (1) to it.... New, add modified result  > \"kaido(2)(1)\""
                    },
                    {
                        "username": "shireGangZZ",
                        "content": "C++ solution for \\n\\'\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> result;\\n        \\n        unordered_map<string, int> frequency_counter;\\n        \\n        for(auto x: names){\\n            if(frequency_counter.find(x)==frequency_counter.end()){\\n                result.push_back(x);\\n                frequency_counter[x]++;\\n            } else {\\n                \\n                \\n                string temp = x+ \"(\"+ to_string(frequency_counter[x]) + \")\";\\n                while(frequency_counter.find(temp)!=frequency_counter.end()){\\n                    temp = x+ \"(\"+ to_string(++frequency_counter[x]) + \")\";\\n                }\\n                result.push_back(temp);\\n                frequency_counter[temp]++;\\n                frequency_counter[x]++;\\n            }\\n            \\n        }\\n        \\n        \\n        return result;\\n    }\\n};\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1804663,
                "content": [
                    {
                        "username": "Leodicap99",
                        "content": "The sample test cases were poor the description was poor. Leetcode should stop posting such questions"
                    },
                    {
                        "username": "luoyuf",
                        "content": "one of most terrible questions I have ever seen.\\n\\nI mean you can post low quality questions, it\\'s ok. But pls do not show us this kind of disaster questions, it\\'s wasting people\\'s time.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Its like a 12 year old got their question added to LC somehow. This question is A) near gibberish, B) not hard once you understand what is being asked, and C) has childish test data. Delete this "
                    },
                    {
                        "username": "krishnakorade",
                        "content": "One Piece Is Real"
                    },
                    {
                        "username": "ryananderson0147",
                        "content": "This test case seems incorrect to me.\n\n`[\"kaido\",\"kaido(1)\",\"kaido\",\"kaido(1)\",\"kaido(2)\"]`\n\nThe expected result is \n\n`[\"kaido\",\"kaido(1)\",\"kaido(2)\",\"kaido(1)(1)\",\"kaido(2)(1)\"]`\n\nFrom the requirements \n\n\"if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\" \n\nHowever \"kaido(2)\" is not a name that is previously used in the array, so it should not receive a new Suffix.  Instead the following should be the expected result.\n\n`[\"kaido\",\"kaido(1)\",\"kaido(3)\",\"kaido(1)(1)\",\"kaido(2)\"]`\n\nWhere \"kaido(2)\" simply remains as is at the end, and we set \"kaido(3)\" to the middle value. That is certainly how I would expect this to work on an operating system. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How did you get to \"kaido(3)\" before processing \"kaido(2)\"? Per the question, you are processing them in order. \n1) \"kaido\" -new, add as is      > \"kaido\"\n2) \"kaido(1)\" -new, add as is   > \"kaido(1)\"\n3) \"kaido\" - NOT new, try adding (1) to it- NOT new, try adding (2) to it.... New, add modified result     >\"kaido(2)\n4) \"kaido(1)\" - NOT new, try adding (1) to it.... New, add modified result    > \"kaido(1)(1)\"\n5) \"kaido(2)\" - NOT new, try adding (1) to it.... New, add modified result  > \"kaido(2)(1)\""
                    },
                    {
                        "username": "shireGangZZ",
                        "content": "C++ solution for \\n\\'\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> result;\\n        \\n        unordered_map<string, int> frequency_counter;\\n        \\n        for(auto x: names){\\n            if(frequency_counter.find(x)==frequency_counter.end()){\\n                result.push_back(x);\\n                frequency_counter[x]++;\\n            } else {\\n                \\n                \\n                string temp = x+ \"(\"+ to_string(frequency_counter[x]) + \")\";\\n                while(frequency_counter.find(temp)!=frequency_counter.end()){\\n                    temp = x+ \"(\"+ to_string(++frequency_counter[x]) + \")\";\\n                }\\n                result.push_back(temp);\\n                frequency_counter[temp]++;\\n                frequency_counter[x]++;\\n            }\\n            \\n        }\\n        \\n        \\n        return result;\\n    }\\n};\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1734966,
                "content": [
                    {
                        "username": "Leodicap99",
                        "content": "The sample test cases were poor the description was poor. Leetcode should stop posting such questions"
                    },
                    {
                        "username": "luoyuf",
                        "content": "one of most terrible questions I have ever seen.\\n\\nI mean you can post low quality questions, it\\'s ok. But pls do not show us this kind of disaster questions, it\\'s wasting people\\'s time.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Its like a 12 year old got their question added to LC somehow. This question is A) near gibberish, B) not hard once you understand what is being asked, and C) has childish test data. Delete this "
                    },
                    {
                        "username": "krishnakorade",
                        "content": "One Piece Is Real"
                    },
                    {
                        "username": "ryananderson0147",
                        "content": "This test case seems incorrect to me.\n\n`[\"kaido\",\"kaido(1)\",\"kaido\",\"kaido(1)\",\"kaido(2)\"]`\n\nThe expected result is \n\n`[\"kaido\",\"kaido(1)\",\"kaido(2)\",\"kaido(1)(1)\",\"kaido(2)(1)\"]`\n\nFrom the requirements \n\n\"if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\" \n\nHowever \"kaido(2)\" is not a name that is previously used in the array, so it should not receive a new Suffix.  Instead the following should be the expected result.\n\n`[\"kaido\",\"kaido(1)\",\"kaido(3)\",\"kaido(1)(1)\",\"kaido(2)\"]`\n\nWhere \"kaido(2)\" simply remains as is at the end, and we set \"kaido(3)\" to the middle value. That is certainly how I would expect this to work on an operating system. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How did you get to \"kaido(3)\" before processing \"kaido(2)\"? Per the question, you are processing them in order. \n1) \"kaido\" -new, add as is      > \"kaido\"\n2) \"kaido(1)\" -new, add as is   > \"kaido(1)\"\n3) \"kaido\" - NOT new, try adding (1) to it- NOT new, try adding (2) to it.... New, add modified result     >\"kaido(2)\n4) \"kaido(1)\" - NOT new, try adding (1) to it.... New, add modified result    > \"kaido(1)(1)\"\n5) \"kaido(2)\" - NOT new, try adding (1) to it.... New, add modified result  > \"kaido(2)(1)\""
                    },
                    {
                        "username": "shireGangZZ",
                        "content": "C++ solution for \\n\\'\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> result;\\n        \\n        unordered_map<string, int> frequency_counter;\\n        \\n        for(auto x: names){\\n            if(frequency_counter.find(x)==frequency_counter.end()){\\n                result.push_back(x);\\n                frequency_counter[x]++;\\n            } else {\\n                \\n                \\n                string temp = x+ \"(\"+ to_string(frequency_counter[x]) + \")\";\\n                while(frequency_counter.find(temp)!=frequency_counter.end()){\\n                    temp = x+ \"(\"+ to_string(++frequency_counter[x]) + \")\";\\n                }\\n                result.push_back(temp);\\n                frequency_counter[temp]++;\\n                frequency_counter[x]++;\\n            }\\n            \\n        }\\n        \\n        \\n        return result;\\n    }\\n};\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1671565,
                "content": [
                    {
                        "username": "Leodicap99",
                        "content": "The sample test cases were poor the description was poor. Leetcode should stop posting such questions"
                    },
                    {
                        "username": "luoyuf",
                        "content": "one of most terrible questions I have ever seen.\\n\\nI mean you can post low quality questions, it\\'s ok. But pls do not show us this kind of disaster questions, it\\'s wasting people\\'s time.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Its like a 12 year old got their question added to LC somehow. This question is A) near gibberish, B) not hard once you understand what is being asked, and C) has childish test data. Delete this "
                    },
                    {
                        "username": "krishnakorade",
                        "content": "One Piece Is Real"
                    },
                    {
                        "username": "ryananderson0147",
                        "content": "This test case seems incorrect to me.\n\n`[\"kaido\",\"kaido(1)\",\"kaido\",\"kaido(1)\",\"kaido(2)\"]`\n\nThe expected result is \n\n`[\"kaido\",\"kaido(1)\",\"kaido(2)\",\"kaido(1)(1)\",\"kaido(2)(1)\"]`\n\nFrom the requirements \n\n\"if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\" \n\nHowever \"kaido(2)\" is not a name that is previously used in the array, so it should not receive a new Suffix.  Instead the following should be the expected result.\n\n`[\"kaido\",\"kaido(1)\",\"kaido(3)\",\"kaido(1)(1)\",\"kaido(2)\"]`\n\nWhere \"kaido(2)\" simply remains as is at the end, and we set \"kaido(3)\" to the middle value. That is certainly how I would expect this to work on an operating system. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How did you get to \"kaido(3)\" before processing \"kaido(2)\"? Per the question, you are processing them in order. \n1) \"kaido\" -new, add as is      > \"kaido\"\n2) \"kaido(1)\" -new, add as is   > \"kaido(1)\"\n3) \"kaido\" - NOT new, try adding (1) to it- NOT new, try adding (2) to it.... New, add modified result     >\"kaido(2)\n4) \"kaido(1)\" - NOT new, try adding (1) to it.... New, add modified result    > \"kaido(1)(1)\"\n5) \"kaido(2)\" - NOT new, try adding (1) to it.... New, add modified result  > \"kaido(2)(1)\""
                    },
                    {
                        "username": "shireGangZZ",
                        "content": "C++ solution for \\n\\'\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> getFolderNames(vector<string>& names) {\\n        vector<string> result;\\n        \\n        unordered_map<string, int> frequency_counter;\\n        \\n        for(auto x: names){\\n            if(frequency_counter.find(x)==frequency_counter.end()){\\n                result.push_back(x);\\n                frequency_counter[x]++;\\n            } else {\\n                \\n                \\n                string temp = x+ \"(\"+ to_string(frequency_counter[x]) + \")\";\\n                while(frequency_counter.find(temp)!=frequency_counter.end()){\\n                    temp = x+ \"(\"+ to_string(++frequency_counter[x]) + \")\";\\n                }\\n                result.push_back(temp);\\n                frequency_counter[temp]++;\\n                frequency_counter[x]++;\\n            }\\n            \\n        }\\n        \\n        \\n        return result;\\n    }\\n};\\n\\'\\'\\'"
                    }
                ]
            }
        ]
    },
    {
        "title": "Avoid Flood in The City",
        "question_content": "<p>Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the <code>nth</code> lake, the <code>nth</code> lake becomes full of water. If it rains over a lake that is <strong>full of water</strong>, there will be a <strong>flood</strong>. Your goal is to avoid floods in any lake.</p>\n\n<p>Given an integer array <code>rains</code> where:</p>\n\n<ul>\n\t<li><code>rains[i] &gt; 0</code> means there will be rains over the <code>rains[i]</code> lake.</li>\n\t<li><code>rains[i] == 0</code> means there are no rains this day and you can choose <strong>one lake</strong> this day and <strong>dry it</strong>.</li>\n</ul>\n\n<p>Return <em>an array <code>ans</code></em> where:</p>\n\n<ul>\n\t<li><code>ans.length == rains.length</code></li>\n\t<li><code>ans[i] == -1</code> if <code>rains[i] &gt; 0</code>.</li>\n\t<li><code>ans[i]</code> is the lake you choose to dry in the <code>ith</code> day if <code>rains[i] == 0</code>.</li>\n</ul>\n\n<p>If there are multiple valid answers return <strong>any</strong> of them. If it is impossible to avoid flood return <strong>an empty array</strong>.</p>\n\n<p>Notice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> rains = [1,2,3,4]\n<strong>Output:</strong> [-1,-1,-1,-1]\n<strong>Explanation:</strong> After the first day full lakes are [1]\nAfter the second day full lakes are [1,2]\nAfter the third day full lakes are [1,2,3]\nAfter the fourth day full lakes are [1,2,3,4]\nThere&#39;s no day to dry any lake and there is no flood in any lake.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> rains = [1,2,0,0,2,1]\n<strong>Output:</strong> [-1,-1,2,1,-1,-1]\n<strong>Explanation:</strong> After the first day full lakes are [1]\nAfter the second day full lakes are [1,2]\nAfter the third day, we dry lake 2. Full lakes are [1]\nAfter the fourth day, we dry lake 1. There is no full lakes.\nAfter the fifth day, full lakes are [2].\nAfter the sixth day, full lakes are [1,2].\nIt is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is another acceptable scenario.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> rains = [1,2,0,1,2]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> After the second day, full lakes are  [1,2]. We have to dry one lake in the third day.\nAfter that, it will rain over lakes [1,2]. It&#39;s easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rains.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= rains[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 697687,
                "title": "a-set-and-a-map-lucid-code-with-documented-comments",
                "content": "\\n**Two key things to note-**\\n1. When drying a lake #L, it is only useful to dry it if it is FULL already. Otherwise its of no use. (Explained this in the code with a small example as well.)\\n2. Which lake to dry on a day when there is no rain, can not be determined without knowing the rain sequence that is coming next.\\nFor example - If you have rains = [1, 2, 0, ??]. Without knowing what the \\'??\\' is, you can not determine which lake to dry on the 3rd day (rains[2]), this is because if \\'??\\' = 1, then you must dry the lake #1 to avoid flooding. Similarly, if \\'??\\' =2,  then you must dry lake #2 to avoid flooding.\\n\\n![image](https://assets.leetcode.com/users/images/e775a319-756a-4e1c-8a61-2ef448137900_1593072251.1421912.png)\\n\\nDetailed Comments in the code.\\n\\nPlease upvote if it helps - \\n1. It encourages me to write and share my solutions if they are easy to understand. \\n2. It reaches to more learners, larger audience. :)\\n\\nThanks.\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int> ans; // Store the final answer here.\\n        int n = rains.size(); \\n        unordered_map<int, int> fulllakes; // Lake number -> day on which it became full.\\n        set<int> drydays;     // Set of available days that can be used for drying a full lake.\\n        for (int i=0; i<n; i++) {  // For each day - \\n            if (rains[i] == 0) {  // No rain on this day.\\n                drydays.insert(i); // This day can be used as a day to dry some lake.\\n                                   // We don\\'t know which lake to prioritize for drying yet.\\n                ans.push_back(1);  // Any number would be ok. This will get overwritten eventually.\\n                                   // If it doesn\\'t get overwritten, its totally ok to dry a lake\\n                                   // irrespective of whether it is full or empty.\\n            } else { // Rained in rains[i]-th lake.\\n                int lake = rains[i]; \\n                if (fulllakes.find(lake) != fulllakes.end()) { // If it is already full -\\n                    // We must dry this lake before it rains in this lake.\\n                    // So find a day in \"drydays\" to dry this lake. Obviously, that day must be\\n                    // a day that is after the day on which the lake was full.\\n                    // i.e. if the lake got full on 7th day, we must find a dry day that is \\n                    // greater than 7.\\n                    auto it = drydays.lower_bound(fulllakes[lake]);\\n                    if (it == drydays.end()) { // If there is no available dry day to dry the lake,\\n                                               // flooding is inevitable.\\n                        return {}; // Sorry, couldn\\'t stop flooding.\\n                    }\\n                    int dryday = *it; // Great, we found a day which we can use to dry this lake.\\n                    ans[dryday] = lake; // Overwrite the \"1\" and dry \"lake\"-th lake instead.\\n                    drydays.erase(dryday); // We dried \"lake\"-th lake on \"dryday\", and we can\\'t use\\n                                           // the same day to dry any other lake, so remove the day\\n                                           // from the set of available drydays.\\n                }\\n                fulllakes[lake] = i; // Update that the \"lake\" became full on \"i\"-th day.\\n                ans.push_back(-1); // As the problem statement expects.\\n            }\\n        }\\n        return ans; // Congratualtions, you avoided flooding.\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int> ans; // Store the final answer here.\\n        int n = rains.size(); \\n        unordered_map<int, int> fulllakes; // Lake number -> day on which it became full.\\n        set<int> drydays;     // Set of available days that can be used for drying a full lake.\\n        for (int i=0; i<n; i++) {  // For each day - \\n            if (rains[i] == 0) {  // No rain on this day.\\n                drydays.insert(i); // This day can be used as a day to dry some lake.\\n                                   // We don\\'t know which lake to prioritize for drying yet.\\n                ans.push_back(1);  // Any number would be ok. This will get overwritten eventually.\\n                                   // If it doesn\\'t get overwritten, its totally ok to dry a lake\\n                                   // irrespective of whether it is full or empty.\\n            } else { // Rained in rains[i]-th lake.\\n                int lake = rains[i]; \\n                if (fulllakes.find(lake) != fulllakes.end()) { // If it is already full -\\n                    // We must dry this lake before it rains in this lake.\\n                    // So find a day in \"drydays\" to dry this lake. Obviously, that day must be\\n                    // a day that is after the day on which the lake was full.\\n                    // i.e. if the lake got full on 7th day, we must find a dry day that is \\n                    // greater than 7.\\n                    auto it = drydays.lower_bound(fulllakes[lake]);\\n                    if (it == drydays.end()) { // If there is no available dry day to dry the lake,\\n                                               // flooding is inevitable.\\n                        return {}; // Sorry, couldn\\'t stop flooding.\\n                    }\\n                    int dryday = *it; // Great, we found a day which we can use to dry this lake.\\n                    ans[dryday] = lake; // Overwrite the \"1\" and dry \"lake\"-th lake instead.\\n                    drydays.erase(dryday); // We dried \"lake\"-th lake on \"dryday\", and we can\\'t use\\n                                           // the same day to dry any other lake, so remove the day\\n                                           // from the set of available drydays.\\n                }\\n                fulllakes[lake] = i; // Update that the \"lake\" became full on \"i\"-th day.\\n                ans.push_back(-1); // As the problem statement expects.\\n            }\\n        }\\n        return ans; // Congratualtions, you avoided flooding.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697701,
                "title": "java-nlog-n-find-zero-that-can-be-used-to-empty-the-fullfilled-lake",
                "content": "```java\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        // the previous appeared idx of rains[i]\\n        Map<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> zeros = new TreeSet<>();\\n        int[] res = new int[rains.length];\\n        for (int i = 0; i < rains.length; i++) {\\n            if (rains[i] == 0) {\\n                zeros.add(i);\\n            } else {\\n                if (map.containsKey(rains[i])) {\\n                    // find the location of zero that can be used to empty rains[i]\\n                    Integer next = zeros.ceiling(map.get(rains[i]));\\n                    if (next == null) return new int[0];\\n                    res[next] = rains[i];\\n                    zeros.remove(next);\\n                }\\n                res[i] = -1;\\n\\t\\t\\t\\tmap.put(rains[i], i);\\n            }\\n        }\\n        for (int i : zeros) res[i] = 1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        // the previous appeared idx of rains[i]\\n        Map<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> zeros = new TreeSet<>();\\n        int[] res = new int[rains.length];\\n        for (int i = 0; i < rains.length; i++) {\\n            if (rains[i] == 0) {\\n                zeros.add(i);\\n            } else {\\n                if (map.containsKey(rains[i])) {\\n                    // find the location of zero that can be used to empty rains[i]\\n                    Integer next = zeros.ceiling(map.get(rains[i]));\\n                    if (next == null) return new int[0];\\n                    res[next] = rains[i];\\n                    zeros.remove(next);\\n                }\\n                res[i] = -1;\\n\\t\\t\\t\\tmap.put(rains[i], i);\\n            }\\n        }\\n        for (int i : zeros) res[i] = 1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697703,
                "title": "greedy-with-a-heap",
                "content": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        seen = set()\\n        closest = []\\n        locs = collections.defaultdict(collections.deque)\\n        for i, lake in enumerate(rains):\\n            locs[lake].append(i)\\n        ret = []\\n        for lake in rains:\\n            if lake in seen:\\n                return []\\n            if not lake:\\n                # get closest that\\'s already seen\\n                if not closest:\\n                    # there\\'s nothing filled that will be filled again later\\n                    ret.append(1) \\n                    continue\\n                nxt = heapq.heappop(closest)\\n                ret.append(rains[nxt])\\n                seen.remove(rains[nxt])\\n            else:\\n                seen.add(lake)\\n                l = locs[lake]\\n                l.popleft()\\n                if l:\\n                    nxt = l[0]\\n                    heapq.heappush(closest, nxt)\\n                ret.append(-1)\\n        return ret\\n```\\n\\nstart by getting all the days that each river is rained on, in chronological order.\\n\\nthen, go through each day. if a lake is rained on during a day, we get the next day that that river is going to be rained on in the future. we put this day in our \"closest\" minheap so that the next time we have a dry day, we can just pop from the minheap and fill up the lake that will be re-rained on nearest in the future.\\n\\nedit: solution without seen, thanks @yaroslav-repeta\\n\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        closest = []\\n        locs = collections.defaultdict(collections.deque)\\n        for i, lake in enumerate(rains):\\n            locs[lake].append(i)\\n        ret = []\\n        for i, lake in enumerate(rains):\\n            if closest and closest[0] == i:\\n                return []\\n            if not lake:\\n                if not closest:\\n                    ret.append(1) \\n                    continue\\n                nxt = heapq.heappop(closest)\\n                ret.append(rains[nxt])\\n            else:\\n                l = locs[lake]\\n                l.popleft()\\n                if l:\\n                    nxt = l[0]\\n                    heapq.heappush(closest, nxt)\\n                ret.append(-1)\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        seen = set()\\n        closest = []\\n        locs = collections.defaultdict(collections.deque)\\n        for i, lake in enumerate(rains):\\n            locs[lake].append(i)\\n        ret = []\\n        for lake in rains:\\n            if lake in seen:\\n                return []\\n            if not lake:\\n                # get closest that\\'s already seen\\n                if not closest:\\n                    # there\\'s nothing filled that will be filled again later\\n                    ret.append(1) \\n                    continue\\n                nxt = heapq.heappop(closest)\\n                ret.append(rains[nxt])\\n                seen.remove(rains[nxt])\\n            else:\\n                seen.add(lake)\\n                l = locs[lake]\\n                l.popleft()\\n                if l:\\n                    nxt = l[0]\\n                    heapq.heappush(closest, nxt)\\n                ret.append(-1)\\n        return ret\\n```\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        closest = []\\n        locs = collections.defaultdict(collections.deque)\\n        for i, lake in enumerate(rains):\\n            locs[lake].append(i)\\n        ret = []\\n        for i, lake in enumerate(rains):\\n            if closest and closest[0] == i:\\n                return []\\n            if not lake:\\n                if not closest:\\n                    ret.append(1) \\n                    continue\\n                nxt = heapq.heappop(closest)\\n                ret.append(rains[nxt])\\n            else:\\n                l = locs[lake]\\n                l.popleft()\\n                if l:\\n                    nxt = l[0]\\n                    heapq.heappush(closest, nxt)\\n                ret.append(-1)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697840,
                "title": "c-o-nlogn-with-explanation",
                "content": "Idea is to maintain a set of the indexes of zero and a hashmap of indexes of rain.\\nWhenever we find a zero in the rains vector, we push it into zero set which maintain the indexes of zero.\\nIf the rains[i] is non-zero, then we see if we have already filled the lake.\\nIf it is already filled, we try to empty it.\\nWe find the last index of rains[i].\\nThen we find the index of the lake we want to empty which is the next bigger element than the last index of rains[i]. (As we can\\'t empty the lake before it is filled).\\nIf, no such zero slot is found, the lake will be flooded, hence return an empty result.\\nOnce zero is filled, erase it from the set.\\n\\n\\n```\\nvector<int> avoidFlood(vector<int>& rains) {\\n        vector<int> res(rains.size(),-1);\\n        unordered_map<int, int> m;\\n        set<int> zero;\\n        for(int i =0; i < rains.size(); ++i)\\n        {\\n            if(rains[i] == 0)\\n            {\\n                zero.insert(i);\\n                res[i] = 1;\\n            }\\n            else\\n            {\\n                if(m.count(rains[i]))\\n                {\\n                    int lastIndex = m[rains[i]];\\n                    auto zeroIndex = zero.upper_bound(lastIndex);\\n                    if(zeroIndex == zero.end())\\n                    {\\n                        return {};\\n                    }\\n                    res[*zeroIndex] = rains[i];\\n                    zero.erase(zeroIndex);\\n                }\\n                m[rains[i]] = i;\\n            }\\n        }\\n        return res;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "Idea is to maintain a set of the indexes of zero and a hashmap of indexes of rain.\\nWhenever we find a zero in the rains vector, we push it into zero set which maintain the indexes of zero.\\nIf the rains[i] is non-zero, then we see if we have already filled the lake.\\nIf it is already filled, we try to empty it.\\nWe find the last index of rains[i].\\nThen we find the index of the lake we want to empty which is the next bigger element than the last index of rains[i]. (As we can\\'t empty the lake before it is filled).\\nIf, no such zero slot is found, the lake will be flooded, hence return an empty result.\\nOnce zero is filled, erase it from the set.\\n\\n\\n```\\nvector<int> avoidFlood(vector<int>& rains) {\\n        vector<int> res(rains.size(),-1);\\n        unordered_map<int, int> m;\\n        set<int> zero;\\n        for(int i =0; i < rains.size(); ++i)\\n        {\\n            if(rains[i] == 0)\\n            {\\n                zero.insert(i);\\n                res[i] = 1;\\n            }\\n            else\\n            {\\n                if(m.count(rains[i]))\\n                {\\n                    int lastIndex = m[rains[i]];\\n                    auto zeroIndex = zero.upper_bound(lastIndex);\\n                    if(zeroIndex == zero.end())\\n                    {\\n                        return {};\\n                    }\\n                    res[*zeroIndex] = rains[i];\\n                    zero.erase(zeroIndex);\\n                }\\n                m[rains[i]] = i;\\n            }\\n        }\\n        return res;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 697950,
                "title": "python-well-explained-simple-logic-o-nlogn-greedy-and-heap",
                "content": "Variables:\\n1. ```dic``` stores the raining day for each lake in ascending order.\\n2. ```to_empty``` is a Min-heap and records the lakes that are full and sorted in **urgency** order. Notably, lake ```i``` has the highest **urgency** means that lake ```i``` is currently full and will be rained in the most recent future among all other full lakes.\\n3. ```full``` is a HashSet used to record the full lakes for efficient queries. ```lake in full``` could be replaced by ```lake in to_empty``` yet the time complexity is ```O(1)``` vs. ```O(n)```.\\n\\nLogics:\\nWe dry lakes in the order of **urgency** - Greedy.\\nIterating through days, when day ```i``` is raining on lake ```lake```, if ```lake``` is already full, simply return ```[]```; else, push the next raining day for ```lake``` to ```to_empty``` to queue it for drying.\\nWhen day ```i``` is sunny, dry the most **urgent** lake referring to ```to_empty```. Remember to remove it from ```full```.\\n\\nPython code is as follows:\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        dic = collections.defaultdict(list)\\n        ret = [-1] * len(rains)\\n        to_empty = [] # index\\n        full = set([])\\n        for day,lake in enumerate(rains):\\n            dic[lake].append(day)\\n        \\n        for i in range(len(rains)):\\n            lake = rains[i]\\n            if lake:\\n                if lake in full:\\n                    return []\\n                full.add(lake)\\n                dic[lake].pop(0)\\n                if dic[lake]:\\n                    heapq.heappush(to_empty,dic[lake][0])\\n            else:\\n                if to_empty:\\n                    ret[i] = rains[heapq.heappop(to_empty)]\\n                    full.remove(ret[i])\\n                else:\\n                    ret[i] = 1\\n        return ret\\n```\\n\\nOr we can get rid of ```full``` and take advantage of ```dic```, not big difference tho.\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        dic = collections.defaultdict(list)\\n        ret = [-1] * len(rains)\\n        to_empty = [] # index\\n        \\n        for day,lake in enumerate(rains):\\n            dic[lake].append(day)\\n        \\n        for i in range(len(rains)):\\n            lake = rains[i]\\n            if lake:\\n                if dic[lake] and dic[lake][0] < i:\\n                    return []\\n                if dic[lake] and len(dic[lake])>1:\\n                    heapq.heappush(to_empty,dic[lake][1])\\n            else:\\n                if to_empty:\\n                    ret[i] = rains[heapq.heappop(to_empty)]\\n                    dic[ret[i]].pop(0)\\n                else:\\n                    ret[i] = 1\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```dic```\n```to_empty```\n```i```\n```i```\n```full```\n```lake in full```\n```lake in to_empty```\n```O(1)```\n```O(n)```\n```i```\n```lake```\n```lake```\n```[]```\n```lake```\n```to_empty```\n```i```\n```to_empty```\n```full```\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        dic = collections.defaultdict(list)\\n        ret = [-1] * len(rains)\\n        to_empty = [] # index\\n        full = set([])\\n        for day,lake in enumerate(rains):\\n            dic[lake].append(day)\\n        \\n        for i in range(len(rains)):\\n            lake = rains[i]\\n            if lake:\\n                if lake in full:\\n                    return []\\n                full.add(lake)\\n                dic[lake].pop(0)\\n                if dic[lake]:\\n                    heapq.heappush(to_empty,dic[lake][0])\\n            else:\\n                if to_empty:\\n                    ret[i] = rains[heapq.heappop(to_empty)]\\n                    full.remove(ret[i])\\n                else:\\n                    ret[i] = 1\\n        return ret\\n```\n```full```\n```dic```\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        dic = collections.defaultdict(list)\\n        ret = [-1] * len(rains)\\n        to_empty = [] # index\\n        \\n        for day,lake in enumerate(rains):\\n            dic[lake].append(day)\\n        \\n        for i in range(len(rains)):\\n            lake = rains[i]\\n            if lake:\\n                if dic[lake] and dic[lake][0] < i:\\n                    return []\\n                if dic[lake] and len(dic[lake])>1:\\n                    heapq.heappush(to_empty,dic[lake][1])\\n            else:\\n                if to_empty:\\n                    ret[i] = rains[heapq.heappop(to_empty)]\\n                    dic[ret[i]].pop(0)\\n                else:\\n                    ret[i] = 1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697749,
                "title": "python-python-straight-forward-solution-using-two-hashmaps",
                "content": "The key of this problem is **how to use dry days wisely.**  So every time we meet a dry day, we save it for future use. \\n\\nTwo hashmaps: **first hashmap for tracking the lake state, second for keeping track of the last rainy day of this lake.**\\n\\n1. if the lake is empty and we encounter a rainy day, simply update the state of this lake.\\n2. if the lake is full, and it rains again, check if there is a dry day we can use. **if there is an available dry day after the last rain day, use it for drying this lake;** if we can\\'t find a qualified dry day, we can directly return `[]`.\\n\\nNot optimal, but this idea is relatively easy to understand.\\n\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        lakes = collections.defaultdict(bool)\\n        lastrain = collections.defaultdict(int)\\n        res = []\\n        dry = []\\n        for k,v in enumerate(rains):\\n            if v > 0:\\n                if not lakes[v]:\\n                    lakes[v] = True\\n                    res.append(-1)\\n                    lastrain[v] = k\\n                else:\\n                    # lakes[v] == True\\n                    if dry == []:\\n                        return []\\n                    else:\\n                        # check if there is a dry day we can use\\n                        i = 0\\n                        found = False\\n                        while i < len(dry) and not found:\\n                            if dry[i] > lastrain[v]:\\n                                found = True\\n                                dry_day = dry[i]\\n                            else:\\n                                i += 1\\n                        if found:\\n                            res[dry_day] = v\\n                            lastrain[v] = k\\n                            dry.pop(i)\\n                            res.append(-1)\\n                        else:\\n                            return []\\n            elif v == 0:\\n                res.append(1)\\n                dry.append(k)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        lakes = collections.defaultdict(bool)\\n        lastrain = collections.defaultdict(int)\\n        res = []\\n        dry = []\\n        for k,v in enumerate(rains):\\n            if v > 0:\\n                if not lakes[v]:\\n                    lakes[v] = True\\n                    res.append(-1)\\n                    lastrain[v] = k\\n                else:\\n                    # lakes[v] == True\\n                    if dry == []:\\n                        return []\\n                    else:\\n                        # check if there is a dry day we can use\\n                        i = 0\\n                        found = False\\n                        while i < len(dry) and not found:\\n                            if dry[i] > lastrain[v]:\\n                                found = True\\n                                dry_day = dry[i]\\n                            else:\\n                                i += 1\\n                        if found:\\n                            res[dry_day] = v\\n                            lastrain[v] = k\\n                            dry.pop(i)\\n                            res.append(-1)\\n                        else:\\n                            return []\\n            elif v == 0:\\n                res.append(1)\\n                dry.append(k)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165465,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func avoidFlood(_ rains: [Int]) -> [Int] {\\n        var res = [Int](repeating: -1, count: rains.count)\\n        var wat = [Int:[Int]](), flds = [Int]()\\n        for r in 0..<rains.count {\\n            let nth = rains[r]\\n            if nth == 0 {\\n                flds.append(r)\\n            } else {\\n                if wat[nth] == nil {\\n                    wat[nth] = [1,r]\\n                } else {\\n                    let dry = wat[nth]![1]\\n                    guard !flds.isEmpty, flds.last! > dry else { return [] }\\n                    for d in 0..<flds.count where flds[d] > dry {\\n                        res[flds[d]] = nth\\n                        flds.remove(at: d)\\n                        wat[nth]![1] = r\\n                        break\\n                    }\\n                }\\n            }\\n        }\\n        flds.forEach{ res[$0] = 1 }\\n        return res\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.024 (0.026) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.avoidFlood([1,2,3,4])\\n        XCTAssertEqual(value, [-1,-1,-1,-1])\\n    }\\n    \\n    func test1() {\\n        let value = solution.avoidFlood([1,2,0,0,2,1])\\n        XCTAssertEqual(value, [-1,-1,2,1,-1,-1])\\n    }\\n    \\n    func test2() {\\n        let value = solution.avoidFlood([1,2,0,1,2])\\n        XCTAssertEqual(value, [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func avoidFlood(_ rains: [Int]) -> [Int] {\\n        var res = [Int](repeating: -1, count: rains.count)\\n        var wat = [Int:[Int]](), flds = [Int]()\\n        for r in 0..<rains.count {\\n            let nth = rains[r]\\n            if nth == 0 {\\n                flds.append(r)\\n            } else {\\n                if wat[nth] == nil {\\n                    wat[nth] = [1,r]\\n                } else {\\n                    let dry = wat[nth]![1]\\n                    guard !flds.isEmpty, flds.last! > dry else { return [] }\\n                    for d in 0..<flds.count where flds[d] > dry {\\n                        res[flds[d]] = nth\\n                        flds.remove(at: d)\\n                        wat[nth]![1] = r\\n                        break\\n                    }\\n                }\\n            }\\n        }\\n        flds.forEach{ res[$0] = 1 }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.avoidFlood([1,2,3,4])\\n        XCTAssertEqual(value, [-1,-1,-1,-1])\\n    }\\n    \\n    func test1() {\\n        let value = solution.avoidFlood([1,2,0,0,2,1])\\n        XCTAssertEqual(value, [-1,-1,2,1,-1,-1])\\n    }\\n    \\n    func test2() {\\n        let value = solution.avoidFlood([1,2,0,1,2])\\n        XCTAssertEqual(value, [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838640,
                "title": "python-save-it-for-a-rainy-day",
                "content": "```html5\\n<b>Time Complexity: O(n) - O(n&middot;log(n))\\nSpace Complexity: O(n)</b>\\n```\\n&#127783; *Numbers match the annotated steps in the code* &#127783;\\n**(#1)** When it rains on a city and that city is empty, mark the city as full and the day it was filled: **filled[city] = day**\\n**(#2)** When it does not rain, save the day ~ for a rainy day ~ in **free_day**.  We will decide which city needs to be dried on this day later.  \\n**(#3)** When it rains on a city **and** that city is not empty:\\n1. Check if we have a free day that has occurred since the last time it rained on this city.\\n1. If not then the city will flood: **return []**\\n1. Otherwise, use **the earliest free day** that occurred **after the last time it rained on the city** to dry the city.  Then update the most recent rainy day for the city.  \\n\\n```python\\ndef avoidFlood(self, rains: List[int]) -> List[int]:\\n\\n\\tres = []\\n\\tfree_day = [] # days without rain\\n\\tfilled = {}   # map of cities that are full (but not flooded) -> day that they were filled\\n\\n\\tfor day,city in enumerate(rains):\\n\\t\\tif city: \\n\\t\\t\\tres.append(-1)\\n\\t\\t\\tif city not in filled:                                       # 1\\n\\t\\t\\t\\tfilled[city] = day                                       # 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif free_day and (free_day[-1] > filled[city]):           # 3.1\\n\\t\\t\\t\\t\\tdry_day = bisect.bisect_left(free_day, filled[city]) # 3.3\\n\\t\\t\\t\\t\\tres[free_day.pop(dry_day)] = city                    # 3.3\\n\\t\\t\\t\\t\\tfilled[city] = day                                   # 3.3\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn []                                            # 3.2\\n\\t\\telse:\\n\\t\\t\\tres.append(1)                                                # 2 (we will fill in rain free days later ~ use city 1 as a place holder)\\n\\t\\t\\tfree_day.append(day)                                         # 2\\n\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```html5\\n<b>Time Complexity: O(n) - O(n&middot;log(n))\\nSpace Complexity: O(n)</b>\\n```\n```python\\ndef avoidFlood(self, rains: List[int]) -> List[int]:\\n\\n\\tres = []\\n\\tfree_day = [] # days without rain\\n\\tfilled = {}   # map of cities that are full (but not flooded) -> day that they were filled\\n\\n\\tfor day,city in enumerate(rains):\\n\\t\\tif city: \\n\\t\\t\\tres.append(-1)\\n\\t\\t\\tif city not in filled:                                       # 1\\n\\t\\t\\t\\tfilled[city] = day                                       # 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif free_day and (free_day[-1] > filled[city]):           # 3.1\\n\\t\\t\\t\\t\\tdry_day = bisect.bisect_left(free_day, filled[city]) # 3.3\\n\\t\\t\\t\\t\\tres[free_day.pop(dry_day)] = city                    # 3.3\\n\\t\\t\\t\\t\\tfilled[city] = day                                   # 3.3\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn []                                            # 3.2\\n\\t\\telse:\\n\\t\\t\\tres.append(1)                                                # 2 (we will fill in rain free days later ~ use city 1 as a place holder)\\n\\t\\t\\tfree_day.append(day)                                         # 2\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 699030,
                "title": "java-simple-treeset-and-hashmap",
                "content": "See comments for details\\n```\\n    public int[] avoidFlood(int[] rains) {\\n        Map<Integer, Integer> full = new HashMap<>();  // last days that is full\\n        TreeSet<Integer> drain = new TreeSet<>();  // storage days to be used for drain\\n        int n = rains.length, res[] = new int[n];\\n        Arrays.fill(res, 1);  // in case extra draining days not used;\\n        for (int i = 0; i < rains.length; i++) {\\n            int lake = rains[i];\\n            if (full.containsKey(lake)){\\n                Integer key = drain.ceiling(full.get(lake));  // find if there is a day could be drain after last full\\n                if (key == null) return new int[]{};  // did not find, flooded\\n                res[key] = lake;    // set the day to be drained with lake\\n                drain.remove(key);  // the darining day has already been used;\\n            }\\n            if (lake == 0) drain.add(i);  // we got new days\\n            else {\\n                full.put(lake, i);\\n                res[i] = -1;  // lake is 0, or could be dry\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] avoidFlood(int[] rains) {\\n        Map<Integer, Integer> full = new HashMap<>();  // last days that is full\\n        TreeSet<Integer> drain = new TreeSet<>();  // storage days to be used for drain\\n        int n = rains.length, res[] = new int[n];\\n        Arrays.fill(res, 1);  // in case extra draining days not used;\\n        for (int i = 0; i < rains.length; i++) {\\n            int lake = rains[i];\\n            if (full.containsKey(lake)){\\n                Integer key = drain.ceiling(full.get(lake));  // find if there is a day could be drain after last full\\n                if (key == null) return new int[]{};  // did not find, flooded\\n                res[key] = lake;    // set the day to be drained with lake\\n                drain.remove(key);  // the darining day has already been used;\\n            }\\n            if (lake == 0) drain.add(i);  // we got new days\\n            else {\\n                full.put(lake, i);\\n                res[i] = -1;  // lake is 0, or could be dry\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1484592,
                "title": "c-clean-code-set-and-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n     vector<int>ans;\\n     unordered_map<int,int>mp;\\n     int size=rains.size();\\n       set<int>st; \\n      for(int i=0;i<size;i++){\\n          if(rains[i]==0){\\n            st.insert(i);\\n              ans.push_back(1);\\n          }\\n          else{\\n              if(mp.find(rains[i])!=mp.end()){\\n                  auto it=st.lower_bound(mp[rains[i]]);\\n                  if(it==st.end())\\n                      return {};\\n                  ans[*it]=rains[i];\\n                  st.erase(*it);\\n              }\\n              mp[rains[i]]=i;\\n              ans.push_back(-1);\\n          }\\n      }\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps:)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n     vector<int>ans;\\n     unordered_map<int,int>mp;\\n     int size=rains.size();\\n       set<int>st; \\n      for(int i=0;i<size;i++){\\n          if(rains[i]==0){\\n            st.insert(i);\\n              ans.push_back(1);\\n          }\\n          else{\\n              if(mp.find(rains[i])!=mp.end()){\\n                  auto it=st.lower_bound(mp[rains[i]]);\\n                  if(it==st.end())\\n                      return {};\\n                  ans[*it]=rains[i];\\n                  st.erase(*it);\\n              }\\n              mp[rains[i]]=i;\\n              ans.push_back(-1);\\n          }\\n      }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736135,
                "title": "python-short-readable-and-single-pass-code-possibly-easiest-code-to-understand",
                "content": "Keep track of dry days, and use a **valid** dry day for a lake that will be flooded.  What do I mean by valid? A valid day is dry day that happend after the lake was initially rained on. In other words, you make sure you dry a lake that already has water on it. \\n\\n```\\ndef avoidFlood(self, rains):\\n\\tfilled, dry_days = {}, []\\n\\tans = [1] * len(rains)\\n\\n\\tfor day, lake in enumerate(rains):\\n\\t\\tif not lake:\\n\\t\\t\\tdry_days.append(day)\\n\\t\\t\\tcontinue \\n\\n\\t\\tans[day] = -1\\n\\t\\tif lake in filled:\\n\\t\\t\\tif not dry_days: return []\\n\\t\\t\\t# use the first dry day after the lake was filled (stored in filled[lake])\\n\\t\\t\\tdry_on_day_index = bisect.bisect_left(dry_days, filled[lake])\\n\\t\\t\\tif dry_on_day_index >= len(dry_days): return []\\n\\t\\t\\tdry_on_day = dry_days.pop(dry_on_day_index)\\n\\t\\t\\tans[dry_on_day] = lake\\n\\n\\t\\tfilled[lake] = day # we fill it on day\\n\\n\\treturn ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef avoidFlood(self, rains):\\n\\tfilled, dry_days = {}, []\\n\\tans = [1] * len(rains)\\n\\n\\tfor day, lake in enumerate(rains):\\n\\t\\tif not lake:\\n\\t\\t\\tdry_days.append(day)\\n\\t\\t\\tcontinue \\n\\n\\t\\tans[day] = -1\\n\\t\\tif lake in filled:\\n\\t\\t\\tif not dry_days: return []\\n\\t\\t\\t# use the first dry day after the lake was filled (stored in filled[lake])\\n\\t\\t\\tdry_on_day_index = bisect.bisect_left(dry_days, filled[lake])\\n\\t\\t\\tif dry_on_day_index >= len(dry_days): return []\\n\\t\\t\\tdry_on_day = dry_days.pop(dry_on_day_index)\\n\\t\\t\\tans[dry_on_day] = lake\\n\\n\\t\\tfilled[lake] = day # we fill it on day\\n\\n\\treturn ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 724050,
                "title": "c-simple-soln-with-explanation",
                "content": "Idea : Allot an empty day to a city as soon as it repeats itself\\n>Explanation : We keep a map to store the latest index of a city (map of int,int is enough since we will be storing only the latest  index, if we were to store all the indices then we would have used map of int and vectors). \\n\\n> Now we scan the cities starting from the first (left to right), as we encounter a dry day we simply insert it into a set (it will be clear soon why i have used set) \\n> If we encounter a rainy day (i.e. rains[i] != 0) then we first check if that city is filled or not (to do this we will check if we have stored an index i (!=0) , for that city in the map), now two cases arise : \\n> >1. City is not filled with water (i.e. mp[rains[i]] == 0) : In this case we just fill the city with water since this will be its first occurrence and its safe to fill it with the rain water, so we simply assign the key as the city and value as that index in the map i.e mp[rains[i]] = i+1 ( i have used 1-based indexing so that we can check for the first occurrence i.e. then mp[rains[i]] == 0 means that city has not been filled yet)\\n> >2. City is filled (i.e. mp[rains[i]] != 0) : This means we need to allot a dry day to this city to dry it up so that we can refill it at this point. Lets denote the current index of the city we are scanning as h ( = i+1, we are following 1 bsed indexing) and the latest occurrence stored in the map (of the same city)  as l, we know that only those dry days ( where rains[i] = 0) can be used to dry up this city which lie between l and h. So we binary search in the set (where we have stored the positions of empty spaces) for the least value greater than l (this can be easily done using the lower bound function of set), \\n> > >  >**if** this value is also less than h then we simply assign that index (the one which we retrievd from set using lower bound) the value of the current city, and update the map to store the current index as the latest index of that city, and we also need to remove the occurrence of this index from the set, since only once can we use a dry day to dry up a filled city, and after doing these operations we move further,\\n>>> >**else** we cannot dry up this filled city and the condition is violated, so we return an empty array (vector in my code).\\n\\n> Why have I used set to store the positions of empty spaces (i.e. where rains[i] = 0)?\\n> >Since we need to binary search for the index just greater than l, we need a sorted list (note that if we dont do binary search then the complexity will become O(n^2) now it is O(nlog(n)).\\n\\n> >Further we need to delete the occurrence of an index quickly (either in O(log(n)) or in O(1)) \\n\\n>> So set allows us to do the first operation in O(log(n)) since it stores the inserted values in sorted fashion and the second operation (i.e. the deletion) is amortised constant in sets when we provide the position to be deleted (may take up a maximum of O(log(n)) but that will also work).\\n\\nIf you face any difficulty in understaing, i would suggest you to read about sets and lower_bound and the think more on my logic and take up 2-3 test cases to understand the functioning of the code. This is a really tricky problem, the idea to deal the problem storing the indices of the cities rather than storing cities at indices is difficult to come up to if you are already involved in thinking of the latter soln. So please don\\'t leave this q if you could not solve this. Reach out to your freinds for a solution or read my soln 2-3 times. You\\'ll get it definitely.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        set<int> st;\\n        int n = rains.size();\\n        map<int,int> v;\\n        vector<int> res(n,1);\\n        for(int i=0; i<n; i++) {\\n            if(rains[i] == 0) \\n                st.insert(i+1);\\n            else {\\n                if(v[rains[i]] == 0) {\\n                    v[rains[i]] = i+1;\\n                }\\n                else {\\n                    int l = v[rains[i]], h = i+1;\\n                    auto it = st.lower_bound(l);\\n                    if(st.empty() || it == st.end() || (*it) > h) {\\n                        res.resize(0);\\n                        return res;\\n                    }\\n                    else {\\n                        res[(*it)-1] = rains[i];\\n                    }\\n                    v[rains[i]] = h;\\n                    st.erase(it);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(rains[i] > 0) \\n                res[i] = -1;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        set<int> st;\\n        int n = rains.size();\\n        map<int,int> v;\\n        vector<int> res(n,1);\\n        for(int i=0; i<n; i++) {\\n            if(rains[i] == 0) \\n                st.insert(i+1);\\n            else {\\n                if(v[rains[i]] == 0) {\\n                    v[rains[i]] = i+1;\\n                }\\n                else {\\n                    int l = v[rains[i]], h = i+1;\\n                    auto it = st.lower_bound(l);\\n                    if(st.empty() || it == st.end() || (*it) > h) {\\n                        res.resize(0);\\n                        return res;\\n                    }\\n                    else {\\n                        res[(*it)-1] = rains[i];\\n                    }\\n                    v[rains[i]] = h;\\n                    st.erase(it);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(rains[i] > 0) \\n                res[i] = -1;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993352,
                "title": "question-has-errors",
                "content": "The question says to return any answer in case multiple correct answers available but it isn\\'t accepting.\\nFor Eg testcase [69,0,0,0,69]\\nMy ans is [-1,1,1,69,-1] which it isn\\'t accepting \\nBut accepts [-1,69,1,1,-1].\\n\\nMy Code:\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        int i,n=rains.size();\\n        vector<int> v(n,-1);\\n        vector<int> d;\\n        unordered_map<int,int> h;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n        if(rains[i]==0)\\n        d.push_back(i);\\n        \\n        else if(h[rains[i]]==1)\\n        {\\n             if(d.size()==0)\\n            return {};\\n            else\\n            {\\n            h[rains[i]]--;\\n            v[d.back()]=rains[i];\\n            d.pop_back();\\n            }\\n        }  \\n            \\n        else\\n        h[rains[i]]++;\\n        }\\n        \\n        return v;\\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        int i,n=rains.size();\\n        vector<int> v(n,-1);\\n        vector<int> d;\\n        unordered_map<int,int> h;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n        if(rains[i]==0)\\n        d.push_back(i);\\n        \\n        else if(h[rains[i]]==1)\\n        {\\n             if(d.size()==0)\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 879467,
                "title": "java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i = 0; i < rains.length; i++) {\\n\\t\\t//store the dryouts..which can be used later\\n            if (rains[i] == 0) {\\n                rains[i] = 1;\\n                set.add(i);\\n                continue;\\n            }\\n            //We have seen rain in this lake before..it needs to be dried out..else flood !!!!\\n            if (map.containsKey(rains[i])) {\\n\\n                //if there are dryouts available.. try using the dryout now\\n                if (set.size() > 0) {\\n\\n                    //we will try to find out any dryout periods which are available after rain in current lake\\n                    Integer dryout = set.ceiling(map.get(rains[i]));\\n\\n                    //if all the dryout are before the rain happend in current lake\\n                    //that means we cannot use them (it\\'s a constraint)\\n                    if(dryout == null)\\n                        return new int[0];\\n                    \\n                    //update the dryout index with the lake\\n                    rains[dryout] = rains[i];\\n                    \\n                    //put the new index of the lake\\n                    //which means this lake is again full and needs to be dried out if it rains again \\n                    map.put(rains[i], i);\\n                    rains[i] = -1;\\n\\n                    //remove the used dryout\\n                    set.remove(dryout);\\n                } \\n                else\\n                    return new int[0];\\n\\n            } else {\\n                map.put(rains[i], i);\\n                rains[i] = -1;\\n            }\\n        }\\n        return rains;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i = 0; i < rains.length; i++) {\\n\\t\\t//store the dryouts..which can be used later\\n            if (rains[i] == 0) {\\n                rains[i] = 1;\\n                set.add(i);\\n                continue;\\n            }\\n            //We have seen rain in this lake before..it needs to be dried out..else flood !!!!\\n            if (map.containsKey(rains[i])) {\\n\\n                //if there are dryouts available.. try using the dryout now\\n                if (set.size() > 0) {\\n\\n                    //we will try to find out any dryout periods which are available after rain in current lake\\n                    Integer dryout = set.ceiling(map.get(rains[i]));\\n\\n                    //if all the dryout are before the rain happend in current lake\\n                    //that means we cannot use them (it\\'s a constraint)\\n                    if(dryout == null)\\n                        return new int[0];\\n                    \\n                    //update the dryout index with the lake\\n                    rains[dryout] = rains[i];\\n                    \\n                    //put the new index of the lake\\n                    //which means this lake is again full and needs to be dried out if it rains again \\n                    map.put(rains[i], i);\\n                    rains[i] = -1;\\n\\n                    //remove the used dryout\\n                    set.remove(dryout);\\n                } \\n                else\\n                    return new int[0];\\n\\n            } else {\\n                map.put(rains[i], i);\\n                rains[i] = -1;\\n            }\\n        }\\n        return rains;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716206,
                "title": "java-well-explained-o-n-2",
                "content": "This is not the most optimised solution that once can have. The reason I am writing this is to explain people the concept of the greedy approach that we use to solve it. At the bottome I have mentioned what can be done to optimise it but for now let\\'s consider the trivial approach and how to do it.\\n\\nBasically the idea is this: Assume you have the time machine. For each days it does not rain, you take a note of the day. You save it in a list called dryDays. Now everytime it rains, also save the day it rained and on what lake it rained in a map. \\n\\nNow let\\'s say there is a rain today (day Z), you check if there is going to be rain on an already filled lake (say lake L) , if there is you do the following:\\n1. You pull out your rain map to see when it last rained on this lake. Let\\'s say it rained on day X. Z (today) > X (When it last rained here)\\n2.  Now you pull out your dry day list and scroll through it to check if there was a dry day **AFTER** when there was rain on L. Let\\'s say you find the first dry day that came after X and it is Y i.e min(Y) such that X < Y\\n3.  You time travel and go to day Y and empty the lake so that it can rain on it again\\n4.  Now you add lake L again in the rain map with day Z\\n5.  Town is saved!\\n\\nBut what if there is no such Y such that X < Y? Well then bad news! There gonna be flood. You know it so run boy run!\\n\\nNow if today it is going to rain on a new lake, you just add it in you map and go to sleep peacefully knowing you saved the town once again!\\n\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        // We will maintain a map of lake and when it last rained there\\n        Map<Integer, Integer> full = new HashMap<>();\\n        \\n        // We will maintain a list of days that were dry day.\\n        List<Integer> dryDays = new ArrayList<>();\\n        \\n        // Return value for flood\\n        int[] emptyArray = new int[0];\\n        \\n        // Return order for no flood\\n        int[] dryOrder = new int[rains.length];\\n        \\n        for(int i = 0; i < rains.length; i++){\\n            \\n            //It is a dry day aka day with no rain\\n            if(rains[i] == 0){ \\n                \\n                // We got a dry day so just put 1 for now. It will be overwritten is actually used to empty any lake later\\n                dryOrder[i] = 1; \\n                if(full.size() == 0){ \\n                    continue; // Since we do not have any lake filled yet these dry days are useless so don\\'t add them to the dryDays list\\n                }\\n                \\n                // When was this dry day, we can only empty lakes that were filled before this\\n                dryDays.add(i); \\n                \\n            }else{ //It is a rainy day and it is gonna rain on some lake, let\\'s see if we have emptied it before it rained\\n                \\n                //The lake was already full\\n                if(full.containsKey(rains[i])){ \\n                    \\n                    // No dry days to empty the lake so flood is sure\\n                    if(dryDays.size() == 0){ \\n                        return emptyArray;\\n                    }\\n                    \\n                    // When did it last rain on this lake\\n                    int rainDay = full.get(rains[i]); \\n                    \\n                    boolean flood = true;  \\n                    \\n                    // Note: Optimisations can be done here to search in LogN instead of linear search\\n                    for(int j = 0; j < dryDays.size(); j++){ // O(n)\\n                        // Did we get a dry day after it rained here?\\n                        int dryDay = dryDays.get(j);\\n                        if(rainDay <= dryDay){\\n                            \\n                            // So we empty this lake on the first dry day that the occured after rain on this lake\\n                            dryOrder[dryDay] = rains[i]; \\n                            \\n                            // Dry day j is used to empty lake[i] and hence can not be used again\\n                            dryDays.remove(j);  // O(n)\\n                            \\n                            // Since it rained again on this lake, that is why we are in this loop in the first\\n                            // place, but because we dried the lake before it rained again there is no flood but \\n                            // this lake is full again.\\n                            full.put(rains[i], i);\\n                            \\n                            // We had emptied this lake before so no flood\\n                            flood = false;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if(flood){ //If we could not find a dry day after rainDay on lake[i] flood is sure because we could not dry it\\n                        return emptyArray;\\n                    }\\n                }else{ // If this is the first time there is rain on this lake just put it in the map\\n                    full.put(rains[i], i);\\n                }\\n                \\n                // Since it is a rain day, the dry order is bound to have -1 at this position\\n                dryOrder[i] = -1; \\n            }\\n        }\\n        \\n        return dryOrder;\\n    }\\n}\\n```\\n\\nThe optimisation that can be done is use a `TreeMap` instead of `ArrayList` and use its `ceiling` function to get Y. This operation is `log(n)` and removal of a node is also `log(n)`.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        // We will maintain a map of lake and when it last rained there\\n        Map<Integer, Integer> full = new HashMap<>();\\n        \\n        // We will maintain a list of days that were dry day.\\n        List<Integer> dryDays = new ArrayList<>();\\n        \\n        // Return value for flood\\n        int[] emptyArray = new int[0];\\n        \\n        // Return order for no flood\\n        int[] dryOrder = new int[rains.length];\\n        \\n        for(int i = 0; i < rains.length; i++){\\n            \\n            //It is a dry day aka day with no rain\\n            if(rains[i] == 0){ \\n                \\n                // We got a dry day so just put 1 for now. It will be overwritten is actually used to empty any lake later\\n                dryOrder[i] = 1; \\n                if(full.size() == 0){ \\n                    continue; // Since we do not have any lake filled yet these dry days are useless so don\\'t add them to the dryDays list\\n                }\\n                \\n                // When was this dry day, we can only empty lakes that were filled before this\\n                dryDays.add(i); \\n                \\n            }else{ //It is a rainy day and it is gonna rain on some lake, let\\'s see if we have emptied it before it rained\\n                \\n                //The lake was already full\\n                if(full.containsKey(rains[i])){ \\n                    \\n                    // No dry days to empty the lake so flood is sure\\n                    if(dryDays.size() == 0){ \\n                        return emptyArray;\\n                    }\\n                    \\n                    // When did it last rain on this lake\\n                    int rainDay = full.get(rains[i]); \\n                    \\n                    boolean flood = true;  \\n                    \\n                    // Note: Optimisations can be done here to search in LogN instead of linear search\\n                    for(int j = 0; j < dryDays.size(); j++){ // O(n)\\n                        // Did we get a dry day after it rained here?\\n                        int dryDay = dryDays.get(j);\\n                        if(rainDay <= dryDay){\\n                            \\n                            // So we empty this lake on the first dry day that the occured after rain on this lake\\n                            dryOrder[dryDay] = rains[i]; \\n                            \\n                            // Dry day j is used to empty lake[i] and hence can not be used again\\n                            dryDays.remove(j);  // O(n)\\n                            \\n                            // Since it rained again on this lake, that is why we are in this loop in the first\\n                            // place, but because we dried the lake before it rained again there is no flood but \\n                            // this lake is full again.\\n                            full.put(rains[i], i);\\n                            \\n                            // We had emptied this lake before so no flood\\n                            flood = false;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if(flood){ //If we could not find a dry day after rainDay on lake[i] flood is sure because we could not dry it\\n                        return emptyArray;\\n                    }\\n                }else{ // If this is the first time there is rain on this lake just put it in the map\\n                    full.put(rains[i], i);\\n                }\\n                \\n                // Since it is a rain day, the dry order is bound to have -1 at this position\\n                dryOrder[i] = -1; \\n            }\\n        }\\n        \\n        return dryOrder;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697735,
                "title": "java-map-treeset-solution",
                "content": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int n = rains.length;\\n        int[] res = new int[n];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for(int i = 0; i < n; i++) {\\n            if(rains[i] != 0) {\\n                res[i] = -1;\\n                if(map.containsKey(rains[i])) {\\n                    int index = map.get(rains[i]);\\n                    if(ts.isEmpty() || ts.ceiling(index) == null) return new int[0];\\n                    res[ts.ceiling(index)] = rains[i];\\n                    map.put(rains[i], i);\\n                    ts.remove(ts.ceiling(index));\\n                } else {\\n                    map.put(rains[i], i);\\n                }\\n            } else {\\n                ts.add(i);\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(res[i] == 0) res[i] = 1;\\n        }       \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int n = rains.length;\\n        int[] res = new int[n];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for(int i = 0; i < n; i++) {\\n            if(rains[i] != 0) {\\n                res[i] = -1;\\n                if(map.containsKey(rains[i])) {\\n                    int index = map.get(rains[i]);\\n                    if(ts.isEmpty() || ts.ceiling(index) == null) return new int[0];\\n                    res[ts.ceiling(index)] = rains[i];\\n                    map.put(rains[i], i);\\n                    ts.remove(ts.ceiling(index));\\n                } else {\\n                    map.put(rains[i], i);\\n                }\\n            } else {\\n                ts.add(i);\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(res[i] == 0) res[i] = 1;\\n        }       \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340456,
                "title": "c-set-map",
                "content": "* Store indices where `rains[i] == 0` , in  set `st`.\\n\\n* Keep a map `indices` to keep track of which lake is already filled .\\n\\n* When encountering a lake, if it is already filled, then it had to be dried. But on which Day???\\n\\n* `PrevDay` stores the last seen index of same lake. Therefore, it is only possible to empty this lake if there is a zero after `prevDay` index. Which we can easily check with `upper_bound` in set `st`.\\n\\n* We get the index of zero after `prevDay`, Now remove this index from set `st`. and now the last seen index of the lake will be present `i`. Update it.\\n\\n* Now, on the day where we can empty any lake But ans still contains -1, replace it with 1.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int> ans(rains.size() , -1) ;\\n        unordered_map<int,int> indices ; //store the lake and its index \\n        set<int> st ; //stores the indices of zeros \\n        \\n        for(int i = 0 ; i < rains.size() ; ++i ){\\n            if(!rains[i]) st.insert(i) ;\\n            else{\\n                if(indices.find(rains[i]) == end(indices)) indices[rains[i]] = i ;\\n                else{\\n                    int prevDay = indices[rains[i]] ;\\n                    auto it = st.upper_bound(prevDay) ;\\n                    if(it == end(st)) return {} ;\\n                    ans[*it] = rains[i] ;\\n                    indices[rains[i]] = i ;\\n                    st.erase(it);\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < ans.size(); ++i ){\\n            if(!rains[i] and ans[i] == -1) ans[i] = 1 ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int> ans(rains.size() , -1) ;\\n        unordered_map<int,int> indices ; //store the lake and its index \\n        set<int> st ; //stores the indices of zeros \\n        \\n        for(int i = 0 ; i < rains.size() ; ++i ){\\n            if(!rains[i]) st.insert(i) ;\\n            else{\\n                if(indices.find(rains[i]) == end(indices)) indices[rains[i]] = i ;\\n                else{\\n                    int prevDay = indices[rains[i]] ;\\n                    auto it = st.upper_bound(prevDay) ;\\n                    if(it == end(st)) return {} ;\\n                    ans[*it] = rains[i] ;\\n                    indices[rains[i]] = i ;\\n                    st.erase(it);\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < ans.size(); ++i ){\\n            if(!rains[i] and ans[i] == -1) ans[i] = 1 ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194200,
                "title": "c-solution-with-well-defined-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& a) {\\n        int n = a.size();\\n        \\n        // To store index of zeros\\n        set<int> index; \\n        \\n        // To store last index\\n        unordered_map<int, int> last;\\n        \\n        // To store result\\n        vector<int> res(n); \\n        \\n        for (int i=0; i<n; i++) {\\n            if (a[i] == 0) {\\n                \\n                // store index of zeros\\n                index.insert(i); \\n                res[i] = 1;\\n            } else {\\n                res[i] = -1;\\n                \\n                // if it appeared already\\n                if (last.find(a[i]) != last.end()) {\\n                    \\n                    // find a zero after last occurence\\n                    auto it = index.upper_bound(last[a[i]]);\\n                    \\n                    // if couldn\\'t find any\\n                    if (it == index.end()) \\n                        return {};\\n                    \\n                    // use a zero index to empty\\n                    res[*it] = a[i];\\n                    \\n                    // remove from set \\n                    index.erase(it);\\n                }\\n                \\n                // update last index\\n                last[a[i]] = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& a) {\\n        int n = a.size();\\n        \\n        // To store index of zeros\\n        set<int> index; \\n        \\n        // To store last index\\n        unordered_map<int, int> last;\\n        \\n        // To store result\\n        vector<int> res(n); \\n        \\n        for (int i=0; i<n; i++) {\\n            if (a[i] == 0) {\\n                \\n                // store index of zeros\\n                index.insert(i); \\n                res[i] = 1;\\n            } else {\\n                res[i] = -1;\\n                \\n                // if it appeared already\\n                if (last.find(a[i]) != last.end()) {\\n                    \\n                    // find a zero after last occurence\\n                    auto it = index.upper_bound(last[a[i]]);\\n                    \\n                    // if couldn\\'t find any\\n                    if (it == index.end()) \\n                        return {};\\n                    \\n                    // use a zero index to empty\\n                    res[*it] = a[i];\\n                    \\n                    // remove from set \\n                    index.erase(it);\\n                }\\n                \\n                // update last index\\n                last[a[i]] = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719162,
                "title": "java-solution-with-documented-comments",
                "content": "```java\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        // this map stores last day when it rained over lake\\n        Map<Integer, Integer> fullLakeLastDay = new HashMap<>();\\n        // contains set of dry days on which no lake has been dried yet\\n        TreeSet<Integer> dryDays = new TreeSet<>();\\n        int[] result = new int[rains.length];\\n        Arrays.fill(result, -1);\\n        for (int i = 0; i < rains.length; i++) {\\n            int rain = rains[i];\\n            if (rain == 0) {\\n                // dry day, put it into dry day set\\n                dryDays.add(i);\\n            } else {\\n                if (fullLakeLastDay.containsKey(rain)) {\\n                    // get first dry day after last day it rained over lake\\n                    Integer dryDayToEmptyLake = dryDays.ceiling(fullLakeLastDay.get(rain));\\n                    if (dryDayToEmptyLake == null) {\\n                        // no dry day so there is no way to empty lake which is already filled\\n                        return new int[0];\\n                    } else {\\n                        // found the dry day, empty the lake on that dry day\\n                        dryDays.remove(dryDayToEmptyLake);\\n                        result[dryDayToEmptyLake] = rain;\\n                    }\\n                }\\n                // now fill the lake again\\n                fullLakeLastDay.put(rain, i);\\n            }\\n        }\\n        for(Integer dryDay: dryDays) {\\n            result[dryDay] = 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        // this map stores last day when it rained over lake\\n        Map<Integer, Integer> fullLakeLastDay = new HashMap<>();\\n        // contains set of dry days on which no lake has been dried yet\\n        TreeSet<Integer> dryDays = new TreeSet<>();\\n        int[] result = new int[rains.length];\\n        Arrays.fill(result, -1);\\n        for (int i = 0; i < rains.length; i++) {\\n            int rain = rains[i];\\n            if (rain == 0) {\\n                // dry day, put it into dry day set\\n                dryDays.add(i);\\n            } else {\\n                if (fullLakeLastDay.containsKey(rain)) {\\n                    // get first dry day after last day it rained over lake\\n                    Integer dryDayToEmptyLake = dryDays.ceiling(fullLakeLastDay.get(rain));\\n                    if (dryDayToEmptyLake == null) {\\n                        // no dry day so there is no way to empty lake which is already filled\\n                        return new int[0];\\n                    } else {\\n                        // found the dry day, empty the lake on that dry day\\n                        dryDays.remove(dryDayToEmptyLake);\\n                        result[dryDayToEmptyLake] = rain;\\n                    }\\n                }\\n                // now fill the lake again\\n                fullLakeLastDay.put(rain, i);\\n            }\\n        }\\n        for(Integer dryDay: dryDays) {\\n            result[dryDay] = 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743367,
                "title": "greedy-easy-implementation-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is simple, **we\\'ll assign dry days to the lake that rained most recently (2 times)**.\\n**For Example-1:- Rains[] = [1,2,0,3,2,1]** Here dry day (2nd day) will be assigned to Lake-2 as it is the first lake where it rained second time.\\n\\n**For eg-1:- rain[] = [1,2,0,3,1,4]** Here the dry day (2nd day) will be assigned to lake-1 as it is the first lake where it rained second time.\\n\\n**Note:-**\\ntry to implement this approach yourself... (**use list or deque to store dry day position**) if you fail to implement this **please read the code and if it helps you Upvote me please....**\\n\\n\\n# Complexity\\n- Time complexity:O(N*M) \\n- here M = Number of Dry Day.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& r) {\\n        list<int> zero_pos;\\n        int n =  r.size();\\n        vector<int> ans(n,-1);\\n        unordered_map<int,int> freq;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(r[i]==0)\\n            zero_pos.push_back(i);\\n            else\\n            {\\n                if(freq.find(r[i])==freq.end())\\n                freq[r[i]]  = i;\\n                else\\n                {\\n                    vector<int> tmp;\\n                    while(zero_pos.size()>0 && zero_pos.front()<freq[r[i]])\\n                    {\\n                        tmp.push_back(zero_pos.front());\\n                        zero_pos.pop_front();\\n                    }\\n                    if(zero_pos.size()==0) return {};\\n                    else\\n                    {\\n                        ans[zero_pos.front()] = r[i];\\n                        zero_pos.pop_front();\\n                        freq[r[i]] = i;\\n                        for(int j = tmp.size()-1;j>=0;j--) zero_pos.push_front(tmp[j]);\\n                    }\\n                }\\n            }\\n        }\\n        while(!zero_pos.empty())\\n        {\\n            ans[zero_pos.front()] = 1;\\n            zero_pos.pop_front();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/03cdba68-896f-4d72-addb-14f3b2c093de_1688960445.6739316.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& r) {\\n        list<int> zero_pos;\\n        int n =  r.size();\\n        vector<int> ans(n,-1);\\n        unordered_map<int,int> freq;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(r[i]==0)\\n            zero_pos.push_back(i);\\n            else\\n            {\\n                if(freq.find(r[i])==freq.end())\\n                freq[r[i]]  = i;\\n                else\\n                {\\n                    vector<int> tmp;\\n                    while(zero_pos.size()>0 && zero_pos.front()<freq[r[i]])\\n                    {\\n                        tmp.push_back(zero_pos.front());\\n                        zero_pos.pop_front();\\n                    }\\n                    if(zero_pos.size()==0) return {};\\n                    else\\n                    {\\n                        ans[zero_pos.front()] = r[i];\\n                        zero_pos.pop_front();\\n                        freq[r[i]] = i;\\n                        for(int j = tmp.size()-1;j>=0;j--) zero_pos.push_front(tmp[j]);\\n                    }\\n                }\\n            }\\n        }\\n        while(!zero_pos.empty())\\n        {\\n            ans[zero_pos.front()] = 1;\\n            zero_pos.pop_front();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158331,
                "title": "java-binary-search-hashmap-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int getNearestDryDay(List<Integer> dryDays, int targetDay) //returns the nearest dry day after targetDay\\n    {\\n        int low = 0, high = dryDays.size() - 1;\\n        int ans = -1, index = -1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            int currDay = dryDays.get(mid);\\n            if (currDay > targetDay) { index = mid; ans = currDay; high = mid - 1; }\\n            else low = mid + 1;\\n        }\\n        if (index != -1) dryDays.remove(index);\\n        return ans;\\n    }\\n    public int[] avoidFlood(int[] rains) \\n    {\\n        HashMap<Integer, Integer>fullMap = new HashMap(); //{lakeIdx : day} \\n        int n = rains.length;\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, 1);\\n        //=========================================================\\n        List<Integer>dryDays = new ArrayList();\\n        for (int i = 0; i < n; i++) //i denotes the ith day\\n        {\\n            int lakeIdx = rains[i]; \\n            if (lakeIdx == 0) { dryDays.add(i); continue; }  //no rain over any lake\\n            \\n            if (fullMap.containsKey(lakeIdx)) //if current lake is already full\\n            {\\n                int lastDrenchedDay = fullMap.get(lakeIdx); //day when \"lakeIdx\"th lake was last drenched\\n                int nearestDryDay = getNearestDryDay(dryDays, lastDrenchedDay);\\n                \\n                if (nearestDryDay == -1) return new int[]{};\\n                ans[nearestDryDay] = lakeIdx;\\n            }\\n            fullMap.put(lakeIdx, i);\\n            ans[i] = -1;\\n        }\\n        //===========================================================\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int getNearestDryDay(List<Integer> dryDays, int targetDay) //returns the nearest dry day after targetDay\\n    {\\n        int low = 0, high = dryDays.size() - 1;\\n        int ans = -1, index = -1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            int currDay = dryDays.get(mid);\\n            if (currDay > targetDay) { index = mid; ans = currDay; high = mid - 1; }\\n            else low = mid + 1;\\n        }\\n        if (index != -1) dryDays.remove(index);\\n        return ans;\\n    }\\n    public int[] avoidFlood(int[] rains) \\n    {\\n        HashMap<Integer, Integer>fullMap = new HashMap(); //{lakeIdx : day} \\n        int n = rains.length;\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, 1);\\n        //=========================================================\\n        List<Integer>dryDays = new ArrayList();\\n        for (int i = 0; i < n; i++) //i denotes the ith day\\n        {\\n            int lakeIdx = rains[i]; \\n            if (lakeIdx == 0) { dryDays.add(i); continue; }  //no rain over any lake\\n            \\n            if (fullMap.containsKey(lakeIdx)) //if current lake is already full\\n            {\\n                int lastDrenchedDay = fullMap.get(lakeIdx); //day when \"lakeIdx\"th lake was last drenched\\n                int nearestDryDay = getNearestDryDay(dryDays, lastDrenchedDay);\\n                \\n                if (nearestDryDay == -1) return new int[]{};\\n                ans[nearestDryDay] = lakeIdx;\\n            }\\n            fullMap.put(lakeIdx, i);\\n            ans[i] = -1;\\n        }\\n        //===========================================================\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269720,
                "title": "java-easy-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int[] ans=new int[rains.length];\\n        Arrays.fill(ans,1);\\n        TreeSet<Integer> set=new TreeSet<>();\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<rains.length;i++){\\n            if(rains[i]==0){\\n                set.add(i);\\n            }\\n            else{\\n                if(map.containsKey(rains[i])){\\n                    Integer zero=set.ceiling(map.get(rains[i]));\\n                     if (zero == null) return new int[0];\\n                    ans[zero]=rains[i];\\n                    set.remove(zero);\\n                }\\n                ans[i]=-1;\\n                map.put(rains[i],i);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int[] ans=new int[rains.length];\\n        Arrays.fill(ans,1);\\n        TreeSet<Integer> set=new TreeSet<>();\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<rains.length;i++){\\n            if(rains[i]==0){\\n                set.add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1198233,
                "title": "simple-o-nlogn-82-5",
                "content": "We have 1 unordered_map **full** where **full[lake_no] -- stores the last day when that lake was filled completely**\\nThe set **dry** stores list of dry days when emptying of some lakes can be performed. When we reach an element a[i] it means that lake a[i] is going to be filled today so we search if there exists some dry day between last time when that lake was filled and curr day. **So we search for the dry day just greater than full[a[i]]**. If such day exists then the current lake can be emptied on that day. else there will be flood. \\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& a) {\\n        int i=0,n=a.size();\\n        vector<int> ans(n,-1);\\n        unordered_map<int,int> full;\\n        set<int> dry;\\n        for(i=0;i<n;i++){\\n            if(a[i]==0){\\n                dry.insert(i);\\n                continue;\\n            }\\n            if(full.find(a[i])!=full.end()){\\n                auto it=dry.lower_bound(full[a[i]]); // next dry day \\n\\t\\t\\t\\t// checking if there was a dry day someday after the curr lake was filled previously\\n                if(it==dry.end()) // if there does not exists any dry day between last time the lake was filled and curr day\\n                    return {};\\n                ans[*it]=a[i];\\n                dry.erase(it);\\n            }\\n            full[a[i]]=i;\\n        }\\n\\t\\t// it does matter what we do on remaining dry days\\n        for(auto e:dry){\\n            ans[e]=1; // fill it with any +ve integer\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& a) {\\n        int i=0,n=a.size();\\n        vector<int> ans(n,-1);\\n        unordered_map<int,int> full;\\n        set<int> dry;\\n        for(i=0;i<n;i++){\\n            if(a[i]==0){\\n                dry.insert(i);\\n                continue;\\n            }\\n            if(full.find(a[i])!=full.end()){\\n                auto it=dry.lower_bound(full[a[i]]); // next dry day \\n\\t\\t\\t\\t// checking if there was a dry day someday after the curr lake was filled previously\\n                if(it==dry.end()) // if there does not exists any dry day between last time the lake was filled and curr day\\n                    return {};\\n                ans[*it]=a[i];\\n                dry.erase(it);\\n            }\\n            full[a[i]]=i;\\n        }\\n\\t\\t// it does matter what we do on remaining dry days\\n        for(auto e:dry){\\n            ans[e]=1; // fill it with any +ve integer\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166374,
                "title": "java-greedy-map-treeset-o-nlogn-single-pass",
                "content": "\\n\\tpublic int[] avoidFlood(int[] rains) {\\n\\n\\t\\tint len = rains.length;\\n\\t\\tint[] ans = new int[len];\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tTreeSet<Integer> set = new TreeSet<>();\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (rains[i] != 0) {\\n\\t\\t\\t\\tans[i] = -1;\\n\\t\\t\\t\\tif (map.containsKey(rains[i])) {\\n\\t\\t\\t\\t\\tint day = map.get(rains[i]);\\n\\t\\t\\t\\t\\tInteger spot = set.ceiling(day);\\n\\t\\t\\t\\t\\tif (spot == null)\\n\\t\\t\\t\\t\\t\\treturn new int[0];\\n\\t\\t\\t\\t\\tset.remove(spot);\\n\\t\\t\\t\\t\\tans[spot] = rains[i];\\n\\t\\t\\t\\t\\tmap.put(rains[i], i);\\n\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\tmap.put(rains[i], i);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans[i] = 10;\\n\\t\\t\\t\\tset.add(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\tpublic int[] avoidFlood(int[] rains) {\\n\\n\\t\\tint len = rains.length;\\n\\t\\tint[] ans = new int[len];\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tTreeSet<Integer> set = new TreeSet<>();\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (rains[i] != 0) {\\n\\t\\t\\t\\tans[i] = -1;\\n\\t\\t\\t\\tif (map.containsKey(rains[i])) {\\n\\t\\t\\t\\t\\tint day = map.get(rains[i]);\\n\\t\\t\\t\\t\\tInteger spot = set.ceiling(day);\\n\\t\\t\\t\\t\\tif (spot == null)\\n\\t\\t\\t\\t\\t\\treturn new int[0];\\n\\t\\t\\t\\t\\tset.remove(spot);\\n\\t\\t\\t\\t\\tans[spot] = rains[i];\\n\\t\\t\\t\\t\\tmap.put(rains[i], i);\\n\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\tmap.put(rains[i], i);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans[i] = 10;\\n\\t\\t\\t\\tset.add(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 834672,
                "title": "my-java-solution-using-hashmap-treeset-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int n = rains.length;\\n        int [] result = new int [n];\\n        Arrays.fill(result, 1);\\n        TreeSet<Integer> emptyLake = new TreeSet<>(); // O(logn)\\n        Map<Integer, Integer> fullLake = new HashMap<>();\\n        for (int i=0; i<n; i++) {\\n            int lake = rains[i];\\n            if (lake > 0) {\\n                result[i] = -1;\\n                if (fullLake.containsKey(lake)) {\\n                    Integer emptyDate = emptyLake.higher(fullLake.get(lake));\\n                    if (emptyDate == null)\\n                        return new int [0];\\n                    result[emptyDate] = lake;\\n                    emptyLake.remove(emptyDate);\\n                }\\n                    fullLake.put(lake, i);\\n            }\\n            else {\\n                emptyLake.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int n = rains.length;\\n        int [] result = new int [n];\\n        Arrays.fill(result, 1);\\n        TreeSet<Integer> emptyLake = new TreeSet<>(); // O(logn)\\n        Map<Integer, Integer> fullLake = new HashMap<>();\\n        for (int i=0; i<n; i++) {\\n            int lake = rains[i];\\n            if (lake > 0) {\\n                result[i] = -1;\\n                if (fullLake.containsKey(lake)) {\\n                    Integer emptyDate = emptyLake.higher(fullLake.get(lake));\\n                    if (emptyDate == null)\\n                        return new int [0];\\n                    result[emptyDate] = lake;\\n                    emptyLake.remove(emptyDate);\\n                }\\n                    fullLake.put(lake, i);\\n            }\\n            else {\\n                emptyLake.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791557,
                "title": "map-o-nlogn-python",
                "content": "```\\nfrom sortedcontainers import SortedList as sl\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        ans = [-1]*(len(rains))\\n        has_rained = dict()\\n        free = sl()\\n        for i in range(len(rains)):\\n            # print(free)\\n            if rains[i]==0:\\n                free.add(i)\\n            else:\\n                if rains[i] not in has_rained:\\n                    has_rained[rains[i]]=i\\n                else:\\n\\t\\t\\t\\t\\t# no free days are available\\n                    if len(free)==0:\\n                        return []\\n\\t\\t\\t\\t\\t#finding the index of the free day that came after the first occurance of\\n\\t\\t\\t\\t\\t# rains[i]\\n                    idx = free.bisect_left(has_rained[rains[i]])\\n                    # print(free,idx,i,has_rained)\\n                    if idx<len(free):\\n                        ans[free[idx]]=rains[i]\\n\\t\\t\\t\\t\\t\\t# updating the index of rains[i] for future it\\'s future occurances\\n                        has_rained[rains[i]] = i\\n                        free.remove(free[idx])\\n                    else:\\n\\t\\t\\t\\t\\t\\t#if no such index exists then return\\n                        return []\\n        if len(free):\\n            while free:\\n\\t\\t\\t\\t# choosing some day to dry on the remaining days\\n                ans[free.pop()]=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList as sl\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        ans = [-1]*(len(rains))\\n        has_rained = dict()\\n        free = sl()\\n        for i in range(len(rains)):\\n            # print(free)\\n            if rains[i]==0:\\n                free.add(i)\\n            else:\\n                if rains[i] not in has_rained:\\n                    has_rained[rains[i]]=i\\n                else:\\n\\t\\t\\t\\t\\t# no free days are available\\n                    if len(free)==0:\\n                        return []\\n\\t\\t\\t\\t\\t#finding the index of the free day that came after the first occurance of\\n\\t\\t\\t\\t\\t# rains[i]\\n                    idx = free.bisect_left(has_rained[rains[i]])\\n                    # print(free,idx,i,has_rained)\\n                    if idx<len(free):\\n                        ans[free[idx]]=rains[i]\\n\\t\\t\\t\\t\\t\\t# updating the index of rains[i] for future it\\'s future occurances\\n                        has_rained[rains[i]] = i\\n                        free.remove(free[idx])\\n                    else:\\n\\t\\t\\t\\t\\t\\t#if no such index exists then return\\n                        return []\\n        if len(free):\\n            while free:\\n\\t\\t\\t\\t# choosing some day to dry on the remaining days\\n                ans[free.pop()]=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701957,
                "title": "c-100-faster-solution-using-just-dictionary-and-linked-list",
                "content": "```csharp\\npublic int[] AvoidFlood(int[] rains)\\n{\\n\\tLinkedList<int> dryDays = new LinkedList<int>();\\n\\tint[] result = new int[rains.Length];\\n\\tDictionary<int, int> lastRained = new Dictionary<int, int>();\\n\\n\\tfor (int i = 0; i < rains.Length; i++)\\n\\t{\\n\\t\\tint lake = rains[i];\\n\\t\\tif (lake == 0)\\n\\t\\t{\\n\\t\\t\\tdryDays.AddLast(i);\\n\\t\\t\\tresult[i] = 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t// There is already rain on this lake\\n\\t\\t\\tif (lastRained.ContainsKey(lake))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint low = lastRained[lake];\\n\\t\\t\\t\\tint ceiling = -1;\\n\\n\\t\\t\\t\\tforeach (var dryDay in dryDays)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (dryDay > low)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tceiling = dryDay;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (ceiling >= 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tresult[ceiling] = lake;\\n\\t\\t\\t\\t\\tdryDays.Remove(ceiling);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn Array.Empty<int>();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tlastRained[lake] = i;\\n\\t\\t\\tresult[i] = -1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[] AvoidFlood(int[] rains)\\n{\\n\\tLinkedList<int> dryDays = new LinkedList<int>();\\n\\tint[] result = new int[rains.Length];\\n\\tDictionary<int, int> lastRained = new Dictionary<int, int>();\\n\\n\\tfor (int i = 0; i < rains.Length; i++)\\n\\t{\\n\\t\\tint lake = rains[i];\\n\\t\\tif (lake == 0)\\n\\t\\t{\\n\\t\\t\\tdryDays.AddLast(i);\\n\\t\\t\\tresult[i] = 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t// There is already rain on this lake\\n\\t\\t\\tif (lastRained.ContainsKey(lake))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint low = lastRained[lake];\\n\\t\\t\\t\\tint ceiling = -1;\\n\\n\\t\\t\\t\\tforeach (var dryDay in dryDays)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (dryDay > low)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tceiling = dryDay;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (ceiling >= 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tresult[ceiling] = lake;\\n\\t\\t\\t\\t\\tdryDays.Remove(ceiling);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn Array.Empty<int>();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tlastRained[lake] = i;\\n\\t\\t\\tresult[i] = -1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697806,
                "title": "javascript-with-comments-and-refactored-wtih-hashset-and-map",
                "content": "```\\n// if rains[i] > 0, ans[i] = -1\\n// for every repeat rains[i] (lake), there has to be a 0 in between repeats\\n// ORDER MATTERS\\nvar avoidFlood = function(rains) {\\n    let stackOfZeros = []\\n    let ans = new Array(rains.length).fill(-1)\\n    \\n    let fullLakes = new Map() // {lake: index}\\n    let dryDays = new Set() // [indices with 0]\\n    for (let i = 0; i < rains.length; i++){\\n        if (rains[i] === 0) {\\n            dryDays.add(i)\\n            ans[i] = 0\\n        } else {\\n            if (!fullLakes.has(rains[i])) { // set {lake => index}\\n                fullLakes.set(rains[i], i)\\n            } else { // lake is full, check if a 0 is between current i and prev index\\n                let previous = fullLakes.get(rains[i])\\n                if (dryDays.size === 0) return []\\n                let dryLake = false // see if the lake can be dried\\n                for(let day of dryDays.keys()){\\n                    if (previous < day && day < i){\\n                        ans[day] = rains[i] // dry the lake\\n                        dryDays.delete(day) // remove the 0\\n                        fullLakes.set(rains[i], i) // reset when lake is refilled\\n                        dryLake = true // able to dry a lake\\n                        break\\n                    } \\n                }\\n                if (!dryLake){ // couldn\\'t dry\\n                    return []\\n                }\\n            }\\n        }\\n    }\\n    // remaining 0s get assigned \\n    for (let i = 0; i < ans.length; i++){\\n        if (ans[i] === 0) {\\n            ans[i] = 1\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// if rains[i] > 0, ans[i] = -1\\n// for every repeat rains[i] (lake), there has to be a 0 in between repeats\\n// ORDER MATTERS\\nvar avoidFlood = function(rains) {\\n    let stackOfZeros = []\\n    let ans = new Array(rains.length).fill(-1)\\n    \\n    let fullLakes = new Map() // {lake: index}\\n    let dryDays = new Set() // [indices with 0]\\n    for (let i = 0; i < rains.length; i++){\\n        if (rains[i] === 0) {\\n            dryDays.add(i)\\n            ans[i] = 0\\n        } else {\\n            if (!fullLakes.has(rains[i])) { // set {lake => index}\\n                fullLakes.set(rains[i], i)\\n            } else { // lake is full, check if a 0 is between current i and prev index\\n                let previous = fullLakes.get(rains[i])\\n                if (dryDays.size === 0) return []\\n                let dryLake = false // see if the lake can be dried\\n                for(let day of dryDays.keys()){\\n                    if (previous < day && day < i){\\n                        ans[day] = rains[i] // dry the lake\\n                        dryDays.delete(day) // remove the 0\\n                        fullLakes.set(rains[i], i) // reset when lake is refilled\\n                        dryLake = true // able to dry a lake\\n                        break\\n                    } \\n                }\\n                if (!dryLake){ // couldn\\'t dry\\n                    return []\\n                }\\n            }\\n        }\\n    }\\n    // remaining 0s get assigned \\n    for (let i = 0; i < ans.length; i++){\\n        if (ans[i] === 0) {\\n            ans[i] = 1\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697711,
                "title": "c-easy-understand-stl-and-upper-bound-with-explanation",
                "content": "First of all we store the index of the positive numbers as well as of 0\\'s in different data structures. In my case, it is map and set respectively. If we see a positive number which has already come before, we will find the first 0 after the previous index of that number. If there is no 0 present, that means we cannot dry that lake and we return else we continue. \\n\\nFor Eg: ```1 x 0 1 0 x 1 0 1 x```\\n\\n(x = Any positive number)\\n\\nindex=0, we simply update index of 1 to 0 because it is the first occurance.\\n\\nindex=3, we have already stored previous location of 1, i.e 0. From 0 we will do upper  bound and find whether a 0 exists or not after index 0. In this case, it exists at index 2, we will use that 0 and update the index of 1 to 3.\\n\\nindex=6, again we encountered 1, now we will do upper_bound and find whether a 0 exists or not after index 3. In this case, it exists at index 4, we will use that 0 and update the index of 1 to 6.\\n \\n And so on.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int,int> s;\\n        set<int> store;\\n        int n=rains.size();\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(rains[i]>0){\\n                if(s.count(rains[i])){\\n                    auto pos=store.upper_bound(s[rains[i]]);\\n                    if(pos==store.end())\\n                        return {};\\n                    else {\\n                        int ind=*pos;\\n                        store.erase(pos);\\n                        ans[ind]=rains[i];\\n                    }\\n                }\\n            } else \\n                store.insert(i);\\n            \\n            s[rains[i]]=i;\\n        }\\n        for(int i:store)\\n            ans[i]=1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```1 x 0 1 0 x 1 0 1 x```\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int,int> s;\\n        set<int> store;\\n        int n=rains.size();\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(rains[i]>0){\\n                if(s.count(rains[i])){\\n                    auto pos=store.upper_bound(s[rains[i]]);\\n                    if(pos==store.end())\\n                        return {};\\n                    else {\\n                        int ind=*pos;\\n                        store.erase(pos);\\n                        ans[ind]=rains[i];\\n                    }\\n                }\\n            } else \\n                store.insert(i);\\n            \\n            s[rains[i]]=i;\\n        }\\n        for(int i:store)\\n            ans[i]=1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990474,
                "title": "100-0ms-simple-easy-short",
                "content": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        // the previous appeared idx of rains[i]\\n        Map<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> zeros = new TreeSet<>();\\n        int[] res = new int[rains.length];\\n        for (int i = 0; i < rains.length; i++) {\\n            if (rains[i] == 0) {\\n                zeros.add(i);\\n            } else {\\n                if (map.containsKey(rains[i])) {\\n                    // find the location of zero that can be used to empty rains[i]\\n                    Integer next = zeros.ceiling(map.get(rains[i]));\\n                    if (next == null) return new int[0];\\n                    res[next] = rains[i];\\n                    zeros.remove(next);\\n                }\\n                res[i] = -1;\\n\\t\\t\\t\\tmap.put(rains[i], i);\\n            }\\n        }\\n        for (int i : zeros) res[i] = 1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Go",
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        // the previous appeared idx of rains[i]\\n        Map<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> zeros = new TreeSet<>();\\n        int[] res = new int[rains.length];\\n        for (int i = 0; i < rains.length; i++) {\\n            if (rains[i] == 0) {\\n                zeros.add(i);\\n            } else {\\n                if (map.containsKey(rains[i])) {\\n                    // find the location of zero that can be used to empty rains[i]\\n                    Integer next = zeros.ceiling(map.get(rains[i]));\\n                    if (next == null) return new int[0];\\n                    res[next] = rains[i];\\n                    zeros.remove(next);\\n                }\\n                res[i] = -1;\\n\\t\\t\\t\\tmap.put(rains[i], i);\\n            }\\n        }\\n        for (int i : zeros) res[i] = 1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903684,
                "title": "java-simple-solution-with-linewise-comments",
                "content": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n         HashMap<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> treeSet = new TreeSet<>();\\n        \\n        int[] ans= new int[rains.length];\\n        \\n        // Importaint for passing test case like 0, 2, 0, 2;\\n        for(int i = 0; i < ans.length; i++) if (rains[i] == 0) ans[i] = 1;\\n        \\n        for(int i = 0; i < rains.length; i++){\\n            \\n            if (rains[i] == 0){\\n                // dry day information store in treeset.\\n                treeSet.add(i);   \\n            }\\n            else{\\n                int lakei = rains[i];\\n                // lake vs Day map\\n                if (map.containsKey(lakei)){\\n                    // getting the day lake got filled with rain.\\n                    int day = map.get(lakei);\\n                    \\n                    // getting the nearest upcomming dry day from treeSet;\\n                    if (treeSet.ceiling(day) != null){\\n                        int dryDay = treeSet.ceiling(day);\\n                        // after getting dryday remove this day from treeset.\\n                        treeSet.remove(dryDay);\\n                        // on this dry day i am going to dry my lake.\\n                        ans[dryDay] = lakei;\\n                        \\n                        // now lake can fill once again after drying\\n                        map.put(lakei, i);\\n                        ans[i] = -1;\\n                    }\\n                    else{\\n                        // no ceiling dryday found.\\n                        return new int[0];\\n                    }\\n                }\\n                else{\\n                    map.put(lakei, i);\\n                    ans[i] = -1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    \\n    }\\n}**if it is useful upvote please**\\n```",
                "solutionTags": [
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n         HashMap<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> treeSet = new TreeSet<>();\\n        \\n        int[] ans= new int[rains.length];\\n        \\n        // Importaint for passing test case like 0, 2, 0, 2;\\n        for(int i = 0; i < ans.length; i++) if (rains[i] == 0) ans[i] = 1;\\n        \\n        for(int i = 0; i < rains.length; i++){\\n            \\n            if (rains[i] == 0){\\n                // dry day information store in treeset.\\n                treeSet.add(i);   \\n            }\\n            else{\\n                int lakei = rains[i];\\n                // lake vs Day map\\n                if (map.containsKey(lakei)){\\n                    // getting the day lake got filled with rain.\\n                    int day = map.get(lakei);\\n                    \\n                    // getting the nearest upcomming dry day from treeSet;\\n                    if (treeSet.ceiling(day) != null){\\n                        int dryDay = treeSet.ceiling(day);\\n                        // after getting dryday remove this day from treeset.\\n                        treeSet.remove(dryDay);\\n                        // on this dry day i am going to dry my lake.\\n                        ans[dryDay] = lakei;\\n                        \\n                        // now lake can fill once again after drying\\n                        map.put(lakei, i);\\n                        ans[i] = -1;\\n                    }\\n                    else{\\n                        // no ceiling dryday found.\\n                        return new int[0];\\n                    }\\n                }\\n                else{\\n                    map.put(lakei, i);\\n                    ans[i] = -1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    \\n    }\\n}**if it is useful upvote please**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685714,
                "title": "set-and-binary-search-soln-c",
                "content": "The main idea is to store the lakes with their latest date of rain in a map and store the dry dates in a set. \\nWhenever you get a lake which is already filled check if there is dry date just after the lakes\\' previous rain date so that you can dry that date if not you can return empty list cause you cannot stop the flood. If you get such a date update the answer with that lake no.\\nCode is self explanatory.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int,int> mp;\\n        int n = rains.size();\\n        vector<int> ans;\\n        set<int> st;\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            \\n            if(rains[i] == 0) {\\n                st.insert(i);\\n                ans.push_back(1);\\n            }\\n            else \\n            {\\n                if(mp.find(rains[i]) != mp.end()) {\\n                int x = rains[i];\\n                auto it = st.lower_bound(mp[x]);\\n                \\n                //cout<<x<<\" \"<<*it<<\" \";\\n                    \\n                if(it == st.end())\\n                    return {};\\n                \\n                ans[*it] = rains[i];\\n                st.erase(*it);\\n            }\\n                mp[rains[i]] = i;\\n                ans.push_back(-1);\\n        }\\n    }   \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int,int> mp;\\n        int n = rains.size();\\n        vector<int> ans;\\n        set<int> st;\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            \\n            if(rains[i] == 0) {\\n                st.insert(i);\\n                ans.push_back(1);\\n            }\\n            else \\n            {\\n                if(mp.find(rains[i]) != mp.end()) {\\n                int x = rains[i];\\n                auto it = st.lower_bound(mp[x]);\\n                \\n                //cout<<x<<\" \"<<*it<<\" \";\\n                    \\n                if(it == st.end())\\n                    return {};\\n                \\n                ans[*it] = rains[i];\\n                st.erase(*it);\\n            }\\n                mp[rains[i]] = i;\\n                ans.push_back(-1);\\n        }\\n    }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1536140,
                "title": "c-272ms-80-simple-easy-small",
                "content": "Runtime: 272 ms, faster than 79.71% of C++ online submissions for Avoid Flood in The City.\\nMemory Usage: 109.2 MB, less than 85.61% of C++ online submissions for Avoid Flood in The City.\\n```\\nclass Solution {\\npublic:\\n  vector<int> avoidFlood(vector<int>& rains) {\\n    unordered_map<int,int>likes;\\n    set<int>days;\\n    \\n    for(int i = 0; i != rains.size(); i++)\\n      if(rains[i]){\\n        if(likes.count(rains[i])){\\n          auto it = days.upper_bound(likes[rains[i]]);\\n          if(it == days.end()) return {};\\n          rains[*it] = rains[i];\\n          days.erase(*it);\\n        }\\n        likes[rains[i]] = i;\\n        rains[i] = -1;\\n      }\\n      else days.insert(i), rains[i] = 1;\\n    \\n    return rains;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> avoidFlood(vector<int>& rains) {\\n    unordered_map<int,int>likes;\\n    set<int>days;\\n    \\n    for(int i = 0; i != rains.size(); i++)\\n      if(rains[i]){\\n        if(likes.count(rains[i])){\\n          auto it = days.upper_bound(likes[rains[i]]);\\n          if(it == days.end()) return {};\\n          rains[*it] = rains[i];\\n          days.erase(*it);\\n        }\\n        likes[rains[i]] = i;\\n        rains[i] = -1;\\n      }\\n      else days.insert(i), rains[i] = 1;\\n    \\n    return rains;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385202,
                "title": "java-easy-approach-with-explanation-hashmap-treeset",
                "content": "```\\nclass Solution \\n{//T -> O( N log N) S -> O( N )\\n    public int[] avoidFlood(int[] rains)\\n    {           \\n        int[] ans= new int[rains.length];//resultant array \\n        \\n        Arrays.fill(ans, 1);//default case if dry day is not utilised \\n        \\n        Map<Integer, Integer> map= new HashMap<>();//lake -- index \\n        \\n        TreeSet<Integer> dry= new TreeSet<>();//like min heap//next dry day index//DNSO\\n        \\n        for(int i= 0; i< rains.length; i++) //linearly traversing the Array \\n        {\\n            if(rains[i] == 0) \\n                dry.add(i);//dry day index \\n            else \\n           {\\n                if(map.containsKey(rains[i]))//lake already present with previous index\\n                {\\n                    //next dry day for the paricular lake, if not present then the city will be in flooded \\n                    Integer nextDry= dry.ceiling(map.get(rains[i]));//O(log N)//in min heap we require O(N) by contains method//internal mechanism Red Black Tree//ceiling return the next greater of the specified value \\n                    \\n                    if(nextDry == null)//no dry day means overflow, city is flooded\\n                        return new int[0];\\n                    \\n                    ans[nextDry]= rains[i];//putting the lake which is dried in the dry day \\n                    \\n                    dry.remove(nextDry);//dry day utilised, dried a lake//O(log N)\\n                }\\n                ans[i]= -1;//ans[i] == -1 if rains[i] > 0.//normal raining day \\n\\t\\t\\t\\tmap.put(rains[i], i);//putting the the lake and their corresponding index to the map \\n            }\\n        }\\n        return ans;//returning the resultant Array \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution \\n{//T -> O( N log N) S -> O( N )\\n    public int[] avoidFlood(int[] rains)\\n    {           \\n        int[] ans= new int[rains.length];//resultant array \\n        \\n        Arrays.fill(ans, 1);//default case if dry day is not utilised \\n        \\n        Map<Integer, Integer> map= new HashMap<>();//lake -- index \\n        \\n        TreeSet<Integer> dry= new TreeSet<>();//like min heap//next dry day index//DNSO\\n        \\n        for(int i= 0; i< rains.length; i++) //linearly traversing the Array \\n        {\\n            if(rains[i] == 0) \\n                dry.add(i);//dry day index \\n            else \\n           {\\n                if(map.containsKey(rains[i]))//lake already present with previous index\\n                {\\n                    //next dry day for the paricular lake, if not present then the city will be in flooded \\n                    Integer nextDry= dry.ceiling(map.get(rains[i]));//O(log N)//in min heap we require O(N) by contains method//internal mechanism Red Black Tree//ceiling return the next greater of the specified value \\n                    \\n                    if(nextDry == null)//no dry day means overflow, city is flooded\\n                        return new int[0];\\n                    \\n                    ans[nextDry]= rains[i];//putting the lake which is dried in the dry day \\n                    \\n                    dry.remove(nextDry);//dry day utilised, dried a lake//O(log N)\\n                }\\n                ans[i]= -1;//ans[i] == -1 if rains[i] > 0.//normal raining day \\n\\t\\t\\t\\tmap.put(rains[i], i);//putting the the lake and their corresponding index to the map \\n            }\\n        }\\n        return ans;//returning the resultant Array \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286259,
                "title": "python-3-solution-with-intuitive-explanation",
                "content": "What this solution does is iterates through the rains list and keep track of 2 things: \\n1. A list of the index of all available dry days from most oldest to newest \\n2. A hashtable of lakes containing the most recent day each lake got rained on \\n\\nin the event that lake i is zero, we set ans[i] to 1 (the description does not say this, but it must be done for a correct solution). We then add that zero to the end of the zeros list \\n\\nin the event that rains[i] is not in our current lake, we add it to our lakes hashtable with the index as its value \\n\\nin the event that rains[i] is in our hashtable (meaning the lake will flood if it is not cleared) we go through our list of zeros from oldest to newest (so we dont interfere with future clearings) and find the first one which is greater than the value of lakes[rains[i]]. \\n\\nWe then set ans[valid zero] to the lakes number(meaning we cleared this lake on this day), and remove the zero from our zeros list. Next, we set the lake\\'s value in our lake hashtable to the current index, because this is now the most recent day that the lake got rained on \\n\\nIf no valid zero is found, we return []\\n\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        lakes = dict() \\n        ans = [-1] * len(rains) \\n        zeros = [] \\n        \\n        for i in range(0, len(rains)):\\n            if rains[i] == 0:\\n                zeros.append(i)\\n                ans[i] = 1\\n            \\n            elif rains[i] in lakes:  \\n                if len(zeros) == 0:\\n                    return []\\n                \\n                for j in range(0, len(zeros)):\\n                    if zeros[j] > lakes[rains[i]]:\\n                        ans[zeros[j]] = rains[i]\\n                        lakes[rains[i]] = i \\n                        del zeros[j]\\n                        break \\n                    \\n                    if j == len(zeros) - 1:\\n                        return []\\n                                   \\n            elif rains[i] not in lakes:\\n                lakes[rains[i]] = i \\n                \\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        lakes = dict() \\n        ans = [-1] * len(rains) \\n        zeros = [] \\n        \\n        for i in range(0, len(rains)):\\n            if rains[i] == 0:\\n                zeros.append(i)\\n                ans[i] = 1\\n            \\n            elif rains[i] in lakes:  \\n                if len(zeros) == 0:\\n                    return []\\n                \\n                for j in range(0, len(zeros)):\\n                    if zeros[j] > lakes[rains[i]]:\\n                        ans[zeros[j]] = rains[i]\\n                        lakes[rains[i]] = i \\n                        del zeros[j]\\n                        break \\n                    \\n                    if j == len(zeros) - 1:\\n                        return []\\n                                   \\n            elif rains[i] not in lakes:\\n                lakes[rains[i]] = i \\n                \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166241,
                "title": "java-greedy-map-set-heap-o-nlogn-double-pass",
                "content": "\\n\\tpublic int[] avoidFlood(int[] rains) {\\n\\n\\t\\tint len = rains.length;\\n\\t\\tint[] ans = new int[len];\\n\\t\\tHashMap<Integer, ArrayDeque<Integer>> map = new HashMap<>();\\n\\t\\tHashSet<Integer> filled = new HashSet<>();\\n\\t\\tPriorityQueue<int[]> heap = new PriorityQueue<>(new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn o1[1] - o2[1];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (rains[i] != 0) {\\n\\t\\t\\t\\tArrayDeque<Integer> dequeue = map.getOrDefault(rains[i], new ArrayDeque<>());\\n\\t\\t\\t\\tdequeue.offerLast(i);\\n\\t\\t\\t\\tmap.put(rains[i], dequeue);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int key : map.keySet())\\n\\t\\t\\tmap.get(key).offerLast(Integer.MAX_VALUE);\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (rains[i] != 0) {\\n\\t\\t\\t\\tif (filled.contains(rains[i]))\\n\\t\\t\\t\\t\\treturn new int[0];\\n\\t\\t\\t\\tans[i] = -1;\\n\\t\\t\\t\\tArrayDeque<Integer> dequeue = map.get(rains[i]);\\n\\t\\t\\t\\tdequeue.pollFirst();\\n\\t\\t\\t\\tint idx = dequeue.peekFirst();\\n\\t\\t\\t\\theap.add(new int[] { rains[i], idx });\\n\\t\\t\\t\\tfilled.add(rains[i]);\\n\\t\\t\\t} else {\\n                int lake = (heap.size() != 0) ? heap.poll()[0] : 10;\\n\\t\\t\\t\\tans[i] = lake;\\n\\t\\t\\t\\tfilled.remove(lake);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n    \\n",
                "solutionTags": [],
                "code": "\\n\\tpublic int[] avoidFlood(int[] rains) {\\n\\n\\t\\tint len = rains.length;\\n\\t\\tint[] ans = new int[len];\\n\\t\\tHashMap<Integer, ArrayDeque<Integer>> map = new HashMap<>();\\n\\t\\tHashSet<Integer> filled = new HashSet<>();\\n\\t\\tPriorityQueue<int[]> heap = new PriorityQueue<>(new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn o1[1] - o2[1];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (rains[i] != 0) {\\n\\t\\t\\t\\tArrayDeque<Integer> dequeue = map.getOrDefault(rains[i], new ArrayDeque<>());\\n\\t\\t\\t\\tdequeue.offerLast(i);\\n\\t\\t\\t\\tmap.put(rains[i], dequeue);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int key : map.keySet())\\n\\t\\t\\tmap.get(key).offerLast(Integer.MAX_VALUE);\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (rains[i] != 0) {\\n\\t\\t\\t\\tif (filled.contains(rains[i]))\\n\\t\\t\\t\\t\\treturn new int[0];\\n\\t\\t\\t\\tans[i] = -1;\\n\\t\\t\\t\\tArrayDeque<Integer> dequeue = map.get(rains[i]);\\n\\t\\t\\t\\tdequeue.pollFirst();\\n\\t\\t\\t\\tint idx = dequeue.peekFirst();\\n\\t\\t\\t\\theap.add(new int[] { rains[i], idx });\\n\\t\\t\\t\\tfilled.add(rains[i]);\\n\\t\\t\\t} else {\\n                int lake = (heap.size() != 0) ? heap.poll()[0] : 10;\\n\\t\\t\\t\\tans[i] = lake;\\n\\t\\t\\t\\tfilled.remove(lake);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1116688,
                "title": "c-clean-and-readable-code-with-comments",
                "content": "```\\n vector<int> avoidFlood(vector<int>& rains) {\\n        int n=rains.size();\\n        vector<int>result(n,-1);\\n        // it will keep track of already filled lakes\\n        unordered_map<int,int>mymap;\\n        \\n        //it will keep the track of available dry day\\n        map<int,int>dry_day;\\n        \\n        for(int i=0;i<n;i++){\\n             if(rains[i]==0){\\n                 dry_day[i]++;\\n                 continue;\\n             }\\n           //else  if rains[i] lake is already visited\\n            if(mymap.find(rains[i])!=mymap.end()){\\n                    //now we will check available dry day after the rains[i] lake was filled\\n                   int last_date=mymap[rains[i]];\\n                   auto it=dry_day.upper_bound(last_date);\\n                   if(it!=dry_day.end()){\\n                        //it meanse some dry days is available after last_date\\n                        //now,we will make rains[i] lake  empty\\n                         mymap.erase(rains[i]);\\n\\t\\t\\t\\t\\t\\t \\n                        //pushing it in result array\\n                         result[it->first]=rains[i];\\n\\t\\t\\t\\t\\t\\t \\n                         //removing the filled dry day from aur map\\n                          dry_day.erase(it);\\n                   }\\n                  else{\\n                    //it meanse there was no available dry day after last_date for rains[i] lake\\n                     return{};\\n                    }\\n                \\n                \\n            }\\n            mymap[rains[i]]=i;\\n             \\n        }\\n\\t\\t// we can empty any lake  if we have more dry day than required\\n        while(dry_day.size()){\\n            auto it=dry_day.begin();\\n            result[it->first]=1000000;\\n            dry_day.erase(it);\\n        }\\n        return result;\\n        \\n        \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<int> avoidFlood(vector<int>& rains) {\\n        int n=rains.size();\\n        vector<int>result(n,-1);\\n        // it will keep track of already filled lakes\\n        unordered_map<int,int>mymap;\\n        \\n        //it will keep the track of available dry day\\n        map<int,int>dry_day;\\n        \\n        for(int i=0;i<n;i++){\\n             if(rains[i]==0){\\n                 dry_day[i]++;\\n                 continue;\\n             }\\n           //else  if rains[i] lake is already visited\\n            if(mymap.find(rains[i])!=mymap.end()){\\n                    //now we will check available dry day after the rains[i] lake was filled\\n                   int last_date=mymap[rains[i]];\\n                   auto it=dry_day.upper_bound(last_date);\\n                   if(it!=dry_day.end()){\\n                        //it meanse some dry days is available after last_date\\n                        //now,we will make rains[i] lake  empty\\n                         mymap.erase(rains[i]);\\n\\t\\t\\t\\t\\t\\t \\n                        //pushing it in result array\\n                         result[it->first]=rains[i];\\n\\t\\t\\t\\t\\t\\t \\n                         //removing the filled dry day from aur map\\n                          dry_day.erase(it);\\n                   }\\n                  else{\\n                    //it meanse there was no available dry day after last_date for rains[i] lake\\n                     return{};\\n                    }\\n                \\n                \\n            }\\n            mymap[rains[i]]=i;\\n             \\n        }\\n\\t\\t// we can empty any lake  if we have more dry day than required\\n        while(dry_day.size()){\\n            auto it=dry_day.begin();\\n            result[it->first]=1000000;\\n            dry_day.erase(it);\\n        }\\n        return result;\\n        \\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1066434,
                "title": "c-with-comments",
                "content": "```\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int> ans(rains.size(), -1);\\n        // hashmap to hold the index of previous rainy days\\n        std::unordered_map<int, int> previous;\\n        // Set to store the dry days index\\n        std::set<int> dryDays;\\n        \\n        for (int i = 0; i < rains.size(); i++) {\\n            if (rains[i] == 0) {\\n                // No rain this day, a dry day, save it in the\\n                // set and will use later\\n                dryDays.insert(i);\\n                // Store 1, in case if we choose to dry an empty lake\\n                ans[i] = 1;\\n            }\\n            else {\\n                if (previous.count(rains[i]) > 0) {\\n                    // The lake was already filled, need to see if there\\n                    // is any dry lake, after the last filled lake\\n                    auto it = dryDays.upper_bound(previous[rains[i]]);\\n                    // If there is no dry days, we can\\'t avoid the flood,\\n                    // returning empty array\\n                    if (it == dryDays.end())\\n                        return {};\\n                    \\n                    // empty the lake that was previously filled\\n                    ans[*it] = rains[i];\\n                    // Erase the used dry day\\n                    dryDays.erase(it);\\n                }\\n                // store the index of the lake in the hash map\\n                previous[rains[i]] =  i;\\n            }\\n        }\\n        return ans;       \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int> ans(rains.size(), -1);\\n        // hashmap to hold the index of previous rainy days\\n        std::unordered_map<int, int> previous;\\n        // Set to store the dry days index\\n        std::set<int> dryDays;\\n        \\n        for (int i = 0; i < rains.size(); i++) {\\n            if (rains[i] == 0) {\\n                // No rain this day, a dry day, save it in the\\n                // set and will use later\\n                dryDays.insert(i);\\n                // Store 1, in case if we choose to dry an empty lake\\n                ans[i] = 1;\\n            }\\n            else {\\n                if (previous.count(rains[i]) > 0) {\\n                    // The lake was already filled, need to see if there\\n                    // is any dry lake, after the last filled lake\\n                    auto it = dryDays.upper_bound(previous[rains[i]]);\\n                    // If there is no dry days, we can\\'t avoid the flood,\\n                    // returning empty array\\n                    if (it == dryDays.end())\\n                        return {};\\n                    \\n                    // empty the lake that was previously filled\\n                    ans[*it] = rains[i];\\n                    // Erase the used dry day\\n                    dryDays.erase(it);\\n                }\\n                // store the index of the lake in the hash map\\n                previous[rains[i]] =  i;\\n            }\\n        }\\n        return ans;       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 783110,
                "title": "c-99-8-runtime-99-7-memory",
                "content": "The idea is to dry a lake in whch rain will occur in the near future. For example [1,2,0,0,2,1] here at first we dry lake 2 as it is used in the near future.Brute force can be done using 2 for loops O(n^2)\\n\\nOptimised Solution\\nuse map to record full lakes and use count is used to know how many subarray of zero exist and vector v to know first and last index of that subarray. For example [1,2,0,0,0,4,5,6,0,0,7,8,0,9] here first 3 zeros belong to one subarray and second 2 to another. while iterating the array when 0 occurs update the subarray and in case non zero element of empty \\nlake update the map . if in case of non-empty lake look  for a day to dry if it exists update ans and update map\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& A) {\\n        int n = A.size();\\n        unordered_map<int,int>m;\\n        vector<pair<int,int>>v; int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i]==0)\\n            {\\n                if(i==0) {A[i]=1;continue;}\\n                int j=i;\\n                while(j<n && A[j]==0) {  A[j]=1;j++;}\\n                count++; \\n                v.push_back({i,j});\\n                i=j-1;\\n            }\\n            else\\n            {\\n                if(m.find(A[i])==m.end())\\n                {\\n                    \\n                    m[A[i]]=count;\\n                    A[i]=-1;\\n                    \\n                }\\n                else\\n                {\\n                    int d =m[A[i]];\\n                    while(d<v.size() && v[d].first>=v[d].second) d++;\\n                    if(d<v.size() && v[d].first<v[d].second)\\n                    {\\n                        A[v[d].first]=A[i];\\n                        v[d].first++;\\n                        m[A[i]]=count;\\n                        A[i]=-1;\\n                    }\\n                    else \\n                    { return {};}\\n                    \\n                }\\n               \\n            }\\n        }\\n        return A;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& A) {\\n        int n = A.size();\\n        unordered_map<int,int>m;\\n        vector<pair<int,int>>v; int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i]==0)\\n            {\\n                if(i==0) {A[i]=1;continue;}\\n                int j=i;\\n                while(j<n && A[j]==0) {  A[j]=1;j++;}\\n                count++; \\n                v.push_back({i,j});\\n                i=j-1;\\n            }\\n            else\\n            {\\n                if(m.find(A[i])==m.end())\\n                {\\n                    \\n                    m[A[i]]=count;\\n                    A[i]=-1;\\n                    \\n                }\\n                else\\n                {\\n                    int d =m[A[i]];\\n                    while(d<v.size() && v[d].first>=v[d].second) d++;\\n                    if(d<v.size() && v[d].first<v[d].second)\\n                    {\\n                        A[v[d].first]=A[i];\\n                        v[d].first++;\\n                        m[A[i]]=count;\\n                        A[i]=-1;\\n                    }\\n                    else \\n                    { return {};}\\n                    \\n                }\\n               \\n            }\\n        }\\n        return A;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725862,
                "title": "c-solution-with-comments-time-complexity-o-nlog-n-and-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n\\t\\n        vector<int> result(rains.size(), 1);\\n        \\n\\t\\t// Create a hash_map with lake and corresponding position.\\n\\t\\t// When we see the same lake again, we need to \\n\\t\\t// find a dry day (0) between current appearance and previous appearance (map will have index of previous appearance).\\n        unordered_map<int, int> lakes;\\n\\t\\t\\n\\t\\t// Keep track of dry days position in a sorted order, so that we can binary-search between\\n\\t\\t// lakes appearing twice (between two lakes postion).\\n        std::set<int> dry_days_pos;\\n        \\n        // time: O(nlog(n)), space: O(n)\\n        for (int i = 0; i < rains.size(); i++)\\n        {\\n            if (rains[i] == 0)\\n            {\\n                // insert takes log(n)\\n                dry_days_pos.insert(i); // Save position of dry days.\\n                // Will update the result array with appropriate lake to be dried out as we move forward.\\n                continue;\\n            }\\n            \\n            result[i] = -1; // fill -1 to result array when there is a rainy day;\\n            \\n\\t\\t\\t// Check if this lake was already filled before.\\n            auto it = lakes.find(rains[i]);\\n            if (it == lakes.end()) // If lake was not filled before, no fludding \\n            {\\n                lakes[rains[i]] = i; // => save the lake and the day it got filled (day refers to position)\\n            }\\n            else\\n            {\\n                // upper_bound() takes log(n) as it uses binary search to find an element.\\n                auto dry_day_it = dry_days_pos.upper_bound(it->second); // remember, we saved the lake\\'s day when it was filled before.\\n                if (dry_day_it == dry_days_pos.end())\\n                    return {}; // Could not find any dry day between the days, the lake was previously filled and currently being filled\\n                \\n\\t\\t\\t\\t// When we could find a dry day, fill the result array at dry day position with current lake being dried out.\\n                result[*dry_day_it] = rains[i]; // Update the result array with appropriate lake to dry it out\\n                dry_days_pos.erase(dry_day_it); // Remove dry day from set as we already used it.\\n                \\n                // Update the dictionary to the current lake\\'s index, \\n                // as the previously filled lake is already dried out.\\n                lakes[rains[i]] = i;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n\\t\\n        vector<int> result(rains.size(), 1);\\n        \\n\\t\\t// Create a hash_map with lake and corresponding position.\\n\\t\\t// When we see the same lake again, we need to \\n\\t\\t// find a dry day (0) between current appearance and previous appearance (map will have index of previous appearance).\\n        unordered_map<int, int> lakes;\\n\\t\\t\\n\\t\\t// Keep track of dry days position in a sorted order, so that we can binary-search between\\n\\t\\t// lakes appearing twice (between two lakes postion).\\n        std::set<int> dry_days_pos;\\n        \\n        // time: O(nlog(n)), space: O(n)\\n        for (int i = 0; i < rains.size(); i++)\\n        {\\n            if (rains[i] == 0)\\n            {\\n                // insert takes log(n)\\n                dry_days_pos.insert(i); // Save position of dry days.\\n                // Will update the result array with appropriate lake to be dried out as we move forward.\\n                continue;\\n            }\\n            \\n            result[i] = -1; // fill -1 to result array when there is a rainy day;\\n            \\n\\t\\t\\t// Check if this lake was already filled before.\\n            auto it = lakes.find(rains[i]);\\n            if (it == lakes.end()) // If lake was not filled before, no fludding \\n            {\\n                lakes[rains[i]] = i; // => save the lake and the day it got filled (day refers to position)\\n            }\\n            else\\n            {\\n                // upper_bound() takes log(n) as it uses binary search to find an element.\\n                auto dry_day_it = dry_days_pos.upper_bound(it->second); // remember, we saved the lake\\'s day when it was filled before.\\n                if (dry_day_it == dry_days_pos.end())\\n                    return {}; // Could not find any dry day between the days, the lake was previously filled and currently being filled\\n                \\n\\t\\t\\t\\t// When we could find a dry day, fill the result array at dry day position with current lake being dried out.\\n                result[*dry_day_it] = rains[i]; // Update the result array with appropriate lake to dry it out\\n                dry_days_pos.erase(dry_day_it); // Remove dry day from set as we already used it.\\n                \\n                // Update the dictionary to the current lake\\'s index, \\n                // as the previously filled lake is already dried out.\\n                lakes[rains[i]] = i;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699438,
                "title": "set-map-c",
                "content": "```\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int,int> full_days; // lakeno -> day of first occurence\\n       set<int> dry_days; // dry days \\n        vector<int> result;\\n        for(int i =0;i < rains.size();++i){\\n            if(rains[i] == 0){\\n                dry_days.insert(i);\\n                result.push_back(1);\\n            } else{\\n                if(full_days.find(rains[i]) != full_days.end()){\\n                    auto it = dry_days.upper_bound(full_days[rains[i]]);\\n                    if(it == dry_days.end()){\\n                        return {};\\n                    } else{\\n                        result[*it] = rains[i];\\n                        dry_days.erase(*it);\\n                    }\\n                    \\n                }\\n                full_days[rains[i]] = i;\\n                result.push_back(-1);\\n            }\\n            \\n        }\\n        \\n        return result;\\n\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int,int> full_days; // lakeno -> day of first occurence\\n       set<int> dry_days; // dry days \\n        vector<int> result;\\n        for(int i =0;i < rains.size();++i){\\n            if(rains[i] == 0){\\n                dry_days.insert(i);\\n                result.push_back(1);\\n            } else{\\n                if(full_days.find(rains[i]) != full_days.end()){\\n                    auto it = dry_days.upper_bound(full_days[rains[i]]);\\n                    if(it == dry_days.end()){\\n                        return {};\\n                    } else{\\n                        result[*it] = rains[i];\\n                        dry_days.erase(*it);\\n                    }\\n                    \\n                }\\n                full_days[rains[i]] = i;\\n                result.push_back(-1);\\n            }\\n            \\n        }\\n        \\n        return result;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699431,
                "title": "javascript-binary-search-solution-with-brief-comments",
                "content": "```\\nconst avoidFlood = (rains) => {\\n    let n = rains.length;\\n    let res = new Array(n).fill(-1);\\n\\n    let emptyLake = [];\\n    let map = new Map();\\n\\n    for (let i = 0; i < n; i++) {\\n        if (rains[i] > 0) { \\n            if (map.has(rains[i])) {\\n                let it = binary_search(emptyLake, map.get(rains[i])); // Find whether exists the \"zero\" right after previous filled lake \\n\\n                if (it[0] === -1) { // No \"zero\" is found\\n                    return [];\\n                }\\n                res[it[0]] = rains[i];\\n                emptyLake.splice(it[1], 1); // remove the \"zero\" when we use to clear current lake\\n            }\\n            map.set(rains[i], i);\\n        } else { \\n            emptyLake.push(i);\\n        }\\n    }\\n\\n    for (let i = 0; i < n; ++i) {\\n        if (rains[i] === 0 && res[i] < 0) {\\n            res[i] = 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\nconst binary_search = (array, target) => {\\n    let start = 0, end = array.length - 1;\\n\\n    while (start + 1 < end) {\\n        let mid = start + ((end - start) >> 1);\\n\\n        if (array[mid] >= target) {\\n            end = mid;\\n        } else {\\n            start = mid;\\n        }\\n    }\\n\\n    if (array[start] >= target) {\\n        return [array[start], start];\\n    }\\n\\n    if (array[end] >= target) {\\n        return [array[end], end];\\n    }\\n    \\n    return [-1, -1];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nconst avoidFlood = (rains) => {\\n    let n = rains.length;\\n    let res = new Array(n).fill(-1);\\n\\n    let emptyLake = [];\\n    let map = new Map();\\n\\n    for (let i = 0; i < n; i++) {\\n        if (rains[i] > 0) { \\n            if (map.has(rains[i])) {\\n                let it = binary_search(emptyLake, map.get(rains[i])); // Find whether exists the \"zero\" right after previous filled lake \\n\\n                if (it[0] === -1) { // No \"zero\" is found\\n                    return [];\\n                }\\n                res[it[0]] = rains[i];\\n                emptyLake.splice(it[1], 1); // remove the \"zero\" when we use to clear current lake\\n            }\\n            map.set(rains[i], i);\\n        } else { \\n            emptyLake.push(i);\\n        }\\n    }\\n\\n    for (let i = 0; i < n; ++i) {\\n        if (rains[i] === 0 && res[i] < 0) {\\n            res[i] = 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\nconst binary_search = (array, target) => {\\n    let start = 0, end = array.length - 1;\\n\\n    while (start + 1 < end) {\\n        let mid = start + ((end - start) >> 1);\\n\\n        if (array[mid] >= target) {\\n            end = mid;\\n        } else {\\n            start = mid;\\n        }\\n    }\\n\\n    if (array[start] >= target) {\\n        return [array[start], start];\\n    }\\n\\n    if (array[end] >= target) {\\n        return [array[end], end];\\n    }\\n    \\n    return [-1, -1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699005,
                "title": "python-3-solution-using-heap",
                "content": "The only action we can take is to dry a lake full of rain on the day when there is no rain. So which lakes should we dry? The answer is the lake that will receive rain next among those lakes already full.\\n\\nNow, the key is to figure out which lake will receive the rain next. To do this, we first scan the array once and save the indices for each lake. In the second scan, each time the rain falls on a lake, we extract an index of when the rain will next fall on that lake and push it to the heap. \\n\\nWhen it\\'s the day of no rain, we just pop the index from the heap and let that lake dry out.\\n      \\n\\n```\\ndef avoidFlood(self, rains: List[int]) -> List[int]:\\n\\tfrom collections import defaultdict\\n\\timport heapq\\n\\n\\t# The first step is to save the list of lake indexes to a hash table.\\n\\t# e.g., cache = { lake id: [list of indices]}\\n\\tcache = defaultdict(list)\\n\\tfor i in range(len(rains)):\\n\\t\\tcache[rains[i]].append(i)\\n\\n\\tfull = set()\\n\\theap = []\\n\\tans = []\\n\\n\\tfor i in range(len(rains)):\\n\\t\\tif rains[i] == 0:\\n\\t\\t\\tif heap:\\n\\t\\t\\t\\t# Index of the lake where the rain comes next\\n\\t\\t\\t\\tnext_index = heapq.heappop(heap)\\n\\t\\t\\t\\tif rains[next_index] in full:\\n\\t\\t\\t\\t\\tans.append(rains[next_index])\\n\\t\\t\\t\\t\\tfull.remove(rains[next_index])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append(1)\\n\\t\\telse:\\n\\t\\t\\tif rains[i] in full:\\n\\t\\t\\t\\treturn []\\n\\t\\t\\telse:\\n\\t\\t\\t\\tfull.add(rains[i])\\n\\t\\t\\t\\tcache[rains[i]].pop(0)\\n\\n\\t\\t\\t\\t# If it still rains in the future, push the index to the heap\\n\\t\\t\\t\\tif cache[rains[i]]:\\n\\t\\t\\t\\t\\theapq.heappush(heap, cache[rains[i]][0])\\n\\n\\t\\t\\t\\tans.append(-1)\\n\\n\\treturn ans",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "The only action we can take is to dry a lake full of rain on the day when there is no rain. So which lakes should we dry? The answer is the lake that will receive rain next among those lakes already full.\\n\\nNow, the key is to figure out which lake will receive the rain next. To do this, we first scan the array once and save the indices for each lake. In the second scan, each time the rain falls on a lake, we extract an index of when the rain will next fall on that lake and push it to the heap. \\n\\nWhen it\\'s the day of no rain, we just pop the index from the heap and let that lake dry out.\\n      \\n\\n```\\ndef avoidFlood(self, rains: List[int]) -> List[int]:\\n\\tfrom collections import defaultdict\\n\\timport heapq\\n\\n\\t# The first step is to save the list of lake indexes to a hash table.\\n\\t# e.g., cache = { lake id: [list of indices]}\\n\\tcache = defaultdict(list)\\n\\tfor i in range(len(rains)):\\n\\t\\tcache[rains[i]].append(i)\\n\\n\\tfull = set()\\n\\theap = []\\n\\tans = []\\n\\n\\tfor i in range(len(rains)):\\n\\t\\tif rains[i] == 0:\\n\\t\\t\\tif heap:\\n\\t\\t\\t\\t# Index of the lake where the rain comes next\\n\\t\\t\\t\\tnext_index = heapq.heappop(heap)\\n\\t\\t\\t\\tif rains[next_index] in full:\\n\\t\\t\\t\\t\\tans.append(rains[next_index])\\n\\t\\t\\t\\t\\tfull.remove(rains[next_index])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append(1)\\n\\t\\telse:\\n\\t\\t\\tif rains[i] in full:\\n\\t\\t\\t\\treturn []\\n\\t\\t\\telse:\\n\\t\\t\\t\\tfull.add(rains[i])\\n\\t\\t\\t\\tcache[rains[i]].pop(0)\\n\\n\\t\\t\\t\\t# If it still rains in the future, push the index to the heap\\n\\t\\t\\t\\tif cache[rains[i]]:\\n\\t\\t\\t\\t\\theapq.heappush(heap, cache[rains[i]][0])\\n\\n\\t\\t\\t\\tans.append(-1)\\n\\n\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 698323,
                "title": "python-detailed-explanation-using-binary-search",
                "content": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        ## RC ##\\n        ## APPROACH : INSERTION INDEX IN A SORTED ARRAY using BINARY SEARCH ##\\n        ## LOGIC ##\\n        # 1. we keep hashmap(lakes) to store {rain value : index} and also we use zeros array to store occurance of zeros\\n        # 2. When you see rains[i] with a duplicate value ( lets say first occurance of rains[i] == 2 is i and curr index is j, rains[j] == 2.)\\n        # 3. Logic is if there is any \\'0\\' between i and j, we can use that \\'0\\' to dry our value at index i and prevent flooding.\\n        # 4. To find out which zero to use, we use binary search to find the index of first zero between i and j. we replace that 0 with our rain value.\\n        # 5. as we have used that 0, we will remove it from zeros. Also make sure to change the index of val in hashmap to j.\\n        # 6. If we donot find any feasible position from our binary search, we return [].\\n        # 7. Finally if there are any extra zeros left, we replace it with 1.\\n        \\n        ## TIME COMPLEXITY : O(NxN) ##\\n        ## SPACE COMPLEXITY : O(N) ##\\n        \\n        zeros, lakes, res = [], {}, [-1] * len(rains)\\n        for i,val in enumerate(rains):\\n            if val in lakes:                                    # 2\\n                idx = bisect.bisect_left(zeros, lakes[val])     # 4\\n                if idx == len(zeros): return []                 # 6\\n                res[zeros[idx]] = val                           # 4\\n                zeros.pop(idx)                                  # 5\\n                lakes[val] = i                                  # change to current index, so it can be used when the same value appears again\\n            elif val == 0: zeros.append(i)                      # 1\\n            else: lakes[val] = i                                # 1\\n        for i in range(len(res)):\\n            if rains[i] == 0 and res[i] == -1:\\n                res[i] = 1                                      # 7\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        ## RC ##\\n        ## APPROACH : INSERTION INDEX IN A SORTED ARRAY using BINARY SEARCH ##\\n        ## LOGIC ##\\n        # 1. we keep hashmap(lakes) to store {rain value : index} and also we use zeros array to store occurance of zeros\\n        # 2. When you see rains[i] with a duplicate value ( lets say first occurance of rains[i] == 2 is i and curr index is j, rains[j] == 2.)\\n        # 3. Logic is if there is any \\'0\\' between i and j, we can use that \\'0\\' to dry our value at index i and prevent flooding.\\n        # 4. To find out which zero to use, we use binary search to find the index of first zero between i and j. we replace that 0 with our rain value.\\n        # 5. as we have used that 0, we will remove it from zeros. Also make sure to change the index of val in hashmap to j.\\n        # 6. If we donot find any feasible position from our binary search, we return [].\\n        # 7. Finally if there are any extra zeros left, we replace it with 1.\\n        \\n        ## TIME COMPLEXITY : O(NxN) ##\\n        ## SPACE COMPLEXITY : O(N) ##\\n        \\n        zeros, lakes, res = [], {}, [-1] * len(rains)\\n        for i,val in enumerate(rains):\\n            if val in lakes:                                    # 2\\n                idx = bisect.bisect_left(zeros, lakes[val])     # 4\\n                if idx == len(zeros): return []                 # 6\\n                res[zeros[idx]] = val                           # 4\\n                zeros.pop(idx)                                  # 5\\n                lakes[val] = i                                  # change to current index, so it can be used when the same value appears again\\n            elif val == 0: zeros.append(i)                      # 1\\n            else: lakes[val] = i                                # 1\\n        for i in range(len(res)):\\n            if rains[i] == 0 and res[i] == -1:\\n                res[i] = 1                                      # 7\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698259,
                "title": "python3-in-one-pass-o-n-x-zeros",
                "content": "O(N x Zeros)\\nTechnically if you can optimize del in a middle of zeroes it will go to O(N x LOG(Zeros))\\n\\nWhy i think worst case is O(N x Zeros):\\n\\n*bisect.bisect(zeros, passed[lake])* - O(log(zeros))\\n*del zeros[minZero]* - O(zeros) as it will re-arrange an array\\n\\nHowever in average it can be closer to linear time as we do not have always all 0s in *zeros* and we are getting rid of free 0s on every rainy day.\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        n = len(rains)\\n        res = [-1] * n\\n        if not n:\\n            return res\\n        passed = {} # store {lake:day} in chrono order\\n        zeros = deque() # store days with 0s\\n        # traverse the rains to populate zeros and replace zero with \\n        for i, lake in enumerate(rains):\\n            if lake == 0:\\n                zeros.append(i)\\n            else:\\n                if lake in passed: # flood alert! look for a free 0 day to make this lake empty\\n                    if zeros:\\n                        # search for a first zero after last match passed[lake]\\n                        minZero = bisect.bisect(zeros, passed[lake])\\n                        if minZero == len(zeros): # no 0s before passed[lake], for example [0, 1, 1] case when there are no 0s between 1 and 1\\n                            return []\\n                        res[zeros[minZero]] = lake\\n                        del zeros[minZero] # this del cal be optimized further!!!\\n                    else: # Flood unavoidable! No options to dry ths lake in advance\\n                        return []                       \\n                passed[lake] = i\\n        # you have to choose one lake on day with and dry it to pass the requirements and tests\\n        for i in zeros:\\n            res[i] = 1 # can be any 1 <= num <= 10^9\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        n = len(rains)\\n        res = [-1] * n\\n        if not n:\\n            return res\\n        passed = {} # store {lake:day} in chrono order\\n        zeros = deque() # store days with 0s\\n        # traverse the rains to populate zeros and replace zero with \\n        for i, lake in enumerate(rains):\\n            if lake == 0:\\n                zeros.append(i)\\n            else:\\n                if lake in passed: # flood alert! look for a free 0 day to make this lake empty\\n                    if zeros:\\n                        # search for a first zero after last match passed[lake]\\n                        minZero = bisect.bisect(zeros, passed[lake])\\n                        if minZero == len(zeros): # no 0s before passed[lake], for example [0, 1, 1] case when there are no 0s between 1 and 1\\n                            return []\\n                        res[zeros[minZero]] = lake\\n                        del zeros[minZero] # this del cal be optimized further!!!\\n                    else: # Flood unavoidable! No options to dry ths lake in advance\\n                        return []                       \\n                passed[lake] = i\\n        # you have to choose one lake on day with and dry it to pass the requirements and tests\\n        for i in zeros:\\n            res[i] = 1 # can be any 1 <= num <= 10^9\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698046,
                "title": "c-time-machine-approach",
                "content": "The idea is, when you see a lake is going to flood, you take the time machine and go back in time to dry the lake.  If there is no sunny day previously, you let it flood.  If there are multiple sunny days, you choose the latest one that can dry the previous raining day of the lake.\\n\\n\\n```\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        const int N = rains.size();\\n        vector<int> out(N, -1);\\n        set<int> zeroIdx;  // time machine records which days we can go back to\\n        unordered_map<int, int> fullLakes;  // lake --> the last raining day\\n        \\n        for (int i = 0; i < N; ++i) {\\n            if (rains[i] == 0) {\\n                zeroIdx.insert(i);  // time machine logs the day\\n                continue;\\n            }\\n            \\n            // i is a raining day\\n            if (fullLakes.count(rains[i]) == 0) {\\n                fullLakes[rains[i]] = i;  // let it be full first\\n                continue;\\n            }\\n            \\n            // the lake is already full\\n            if (zeroIdx.size() == 0) return vector<int>();  // no past sunny day available\\n\\t\\t\\t\\n            // find the first eligible sunny day to fix the lake before it floods\\n            auto fix = zeroIdx.lower_bound(fullLakes[rains[i]]);\\n            if (fix == zeroIdx.end()) return vector<int>();  // unfortunately, no eligible past sunny day\\n            \\n\\t\\t\\t// yeah, it\\'s fixable\\n            out[*fix] = rains[i];  // go back in time, and clean the lake\\n            fullLakes[rains[i]] = i;  // now go back to present time and fill the lake\\n            zeroIdx.erase(fix);  // this sunny day is no longer available to rescue the world\\n        }\\n        \\n\\t\\t// all the extra sunny days, just dry lake 1 as exercise\\n        for (auto& idx : zeroIdx) {\\n            out[idx] = 1;\\n        }\\n\\n        return out;\\n    }\\n```\\n\\nTime: O(N logN),  I guess\\nSpace: O(N), all sunny days or it rains at all different lakes.",
                "solutionTags": [],
                "code": "```\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        const int N = rains.size();\\n        vector<int> out(N, -1);\\n        set<int> zeroIdx;  // time machine records which days we can go back to\\n        unordered_map<int, int> fullLakes;  // lake --> the last raining day\\n        \\n        for (int i = 0; i < N; ++i) {\\n            if (rains[i] == 0) {\\n                zeroIdx.insert(i);  // time machine logs the day\\n                continue;\\n            }\\n            \\n            // i is a raining day\\n            if (fullLakes.count(rains[i]) == 0) {\\n                fullLakes[rains[i]] = i;  // let it be full first\\n                continue;\\n            }\\n            \\n            // the lake is already full\\n            if (zeroIdx.size() == 0) return vector<int>();  // no past sunny day available\\n\\t\\t\\t\\n            // find the first eligible sunny day to fix the lake before it floods\\n            auto fix = zeroIdx.lower_bound(fullLakes[rains[i]]);\\n            if (fix == zeroIdx.end()) return vector<int>();  // unfortunately, no eligible past sunny day\\n            \\n\\t\\t\\t// yeah, it\\'s fixable\\n            out[*fix] = rains[i];  // go back in time, and clean the lake\\n            fullLakes[rains[i]] = i;  // now go back to present time and fill the lake\\n            zeroIdx.erase(fix);  // this sunny day is no longer available to rescue the world\\n        }\\n        \\n\\t\\t// all the extra sunny days, just dry lake 1 as exercise\\n        for (auto& idx : zeroIdx) {\\n            out[idx] = 1;\\n        }\\n\\n        return out;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697925,
                "title": "python-concise-hashmap-greedy-solution",
                "content": "Idea: Keep track of the set of un-used dry lands so far, upon flooding (i.e second time we see a lake number), try to dry it with earliest dry land that falls between the first time we see the lake and current index.\\n```\\nclass Solution:\\n    def avoidFlood(self, rains):\\n        dry_lands = []    # Index of dry lands that are not used yet\\n        last_flood = dict()    # index of previous flood\\n        res = []      # result list to return\\n        for i,r in enumerate(rains):\\n            if r == 0:\\n                dry_lands.append(i)\\n                res.append(1)\\n            else:\\n                if r in last_flood: # If flood occurs, try the first dry land up until this point\\n                    dried = False\\n                    for j,dl in enumerate(dry_lands):\\n                        if dl > last_flood[r]:\\n                            res[dl] = r\\n                            last_flood[r] = i\\n                            del dry_lands[j]\\n                            dried = True\\n                            break\\n                    if not dried:\\n                        return []\\n                else:\\n                    last_flood[r] = i\\n                res.append(-1)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains):\\n        dry_lands = []    # Index of dry lands that are not used yet\\n        last_flood = dict()    # index of previous flood\\n        res = []      # result list to return\\n        for i,r in enumerate(rains):\\n            if r == 0:\\n                dry_lands.append(i)\\n                res.append(1)\\n            else:\\n                if r in last_flood: # If flood occurs, try the first dry land up until this point\\n                    dried = False\\n                    for j,dl in enumerate(dry_lands):\\n                        if dl > last_flood[r]:\\n                            res[dl] = r\\n                            last_flood[r] = i\\n                            del dry_lands[j]\\n                            dried = True\\n                            break\\n                    if not dried:\\n                        return []\\n                else:\\n                    last_flood[r] = i\\n                res.append(-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697905,
                "title": "sliding-window-binary-search-n-log-n",
                "content": "```\\n fun avoidFlood(rains: IntArray): IntArray {\\n        val fullLakes = HashMap<Int, Int>()\\n        var emptyLakes = ArrayList<Int>()\\n        var ans = IntArray(rains.size) { -1 }\\n        \\n        for(i in 0 until rains.size) {\\n\\t\\t    if(rains[i] == 0) {\\n\\t\\t\\t   // if empty lake, save it for future filling.\\n\\t\\t\\t   emptyLakes.add(i)\\n\\t\\t\\t   continue\\n\\t\\t\\t}\\n             if(fullLakes.containsKey(rains[i])) {\\n\\t\\t\\t    // NOTE : you can use Treemap here to make this step easy. but i like raw code than data structure.\\n\\t\\t\\t\\t\\n\\t\\t\\t    // Do binary search to find the lake which is empty that comes after the day\\n\\t\\t\\t\\t// when it rained at rains[i] lake previously\\n\\t\\t\\t\\tvar start = 0\\n\\t\\t\\t\\tvar end = emptyLakes.size - 1\\n\\t\\t\\t\\tvar index = -1 \\n\\t\\t\\t\\twhile(start <= end) {\\n\\t\\t\\t\\t\\tval mid = (start + end)/2\\n\\t\\t\\t\\t\\tif(emptyLakes[mid] > fullLakes[rains[i]]!!) {\\n\\t\\t\\t\\t\\t\\tindex = mid\\n\\t\\t\\t\\t\\t\\tend = mid - 1\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tstart = mid + 1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// if no lake found, return empty \\n\\t\\t\\t\\tif(index == -1) return intArrayOf()\\n\\t\\t\\t\\t// if found, then empty rain[i] lake\\n\\t\\t\\t\\tans[emptyLakes[index]] = rains[i]\\n\\t\\t\\t\\t// remove empty lake now\\n\\t\\t\\t\\temptyLakes.removeAt(index)\\n\\t\\t\\t}\\n\\t\\t\\t// Now update the day when it rained in rain[i] lake\\n\\t\\t\\tfullLakes[rains[i]] = i\\n        }\\n        for(l in emptyLakes) {\\n\\t\\t    // fill all empty lakes with some numbers\\n            ans[l] = 1\\n        }\\n        return ans\\n    }",
                "solutionTags": [],
                "code": "```\\n fun avoidFlood(rains: IntArray): IntArray {\\n        val fullLakes = HashMap<Int, Int>()\\n        var emptyLakes = ArrayList<Int>()\\n        var ans = IntArray(rains.size) { -1 }\\n        \\n        for(i in 0 until rains.size) {\\n\\t\\t    if(rains[i] == 0) {\\n\\t\\t\\t   // if empty lake, save it for future filling.\\n\\t\\t\\t   emptyLakes.add(i)\\n\\t\\t\\t   continue\\n\\t\\t\\t}\\n             if(fullLakes.containsKey(rains[i])) {\\n\\t\\t\\t    // NOTE : you can use Treemap here to make this step easy. but i like raw code than data structure.\\n\\t\\t\\t\\t\\n\\t\\t\\t    // Do binary search to find the lake which is empty that comes after the day\\n\\t\\t\\t\\t// when it rained at rains[i] lake previously\\n\\t\\t\\t\\tvar start = 0\\n\\t\\t\\t\\tvar end = emptyLakes.size - 1\\n\\t\\t\\t\\tvar index = -1 \\n\\t\\t\\t\\twhile(start <= end) {\\n\\t\\t\\t\\t\\tval mid = (start + end)/2\\n\\t\\t\\t\\t\\tif(emptyLakes[mid] > fullLakes[rains[i]]!!) {\\n\\t\\t\\t\\t\\t\\tindex = mid\\n\\t\\t\\t\\t\\t\\tend = mid - 1\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tstart = mid + 1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// if no lake found, return empty \\n\\t\\t\\t\\tif(index == -1) return intArrayOf()\\n\\t\\t\\t\\t// if found, then empty rain[i] lake\\n\\t\\t\\t\\tans[emptyLakes[index]] = rains[i]\\n\\t\\t\\t\\t// remove empty lake now\\n\\t\\t\\t\\temptyLakes.removeAt(index)\\n\\t\\t\\t}\\n\\t\\t\\t// Now update the day when it rained in rain[i] lake\\n\\t\\t\\tfullLakes[rains[i]] = i\\n        }\\n        for(l in emptyLakes) {\\n\\t\\t    // fill all empty lakes with some numbers\\n            ans[l] = 1\\n        }\\n        return ans\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 697856,
                "title": "java-short-and-easy-to-understand-solution",
                "content": "Time Complexity: O(N * LogN). Space Complexity: O(N)\\n```\\n    public int[] avoidFlood(int[] rains) {\\n        int n = rains.length;\\n        int[] res = new int[n];\\n        // TreeSet to save all the days that can dry the lake\\n        TreeSet<Integer> days = new TreeSet();\\n        // Set to save all the full lake\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int i = 0; i < n; i++) {\\n            int c = rains[i];\\n            if (c == 0) {\\n                days.add(i);\\n                res[i] = 1;\\n            } else {\\n                res[i] = -1;\\n                if (map.containsKey(c)) {\\n                    Integer d = days.ceiling(map.get(c));\\n                    if (d == null) return new int[]{};\\n                    days.remove(d);\\n                    res[d] = c; \\n                } \\n                map.put(c, i);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Time Complexity: O(N * LogN). Space Complexity: O(N)\\n```\\n    public int[] avoidFlood(int[] rains) {\\n        int n = rains.length;\\n        int[] res = new int[n];\\n        // TreeSet to save all the days that can dry the lake\\n        TreeSet<Integer> days = new TreeSet();\\n        // Set to save all the full lake\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int i = 0; i < n; i++) {\\n            int c = rains[i];\\n            if (c == 0) {\\n                days.add(i);\\n                res[i] = 1;\\n            } else {\\n                res[i] = -1;\\n                if (map.containsKey(c)) {\\n                    Integer d = days.ceiling(map.get(c));\\n                    if (d == null) return new int[]{};\\n                    days.remove(d);\\n                    res[d] = c; \\n                } \\n                map.put(c, i);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 697786,
                "title": "java-treeset-and-a-map-idea-is-to-fill-the-blanks-later-when-you-encounter-a-possible-flood",
                "content": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int zeroes = 0;\\n        Map<Integer, Integer> rained = new HashMap<>();\\n        TreeSet<Integer> dry = new TreeSet<>();\\n        int result[] = new int[rains.length];\\n        for(int i =0; i<rains.length; ++i) {\\n            if(rains[i] == 0) {\\n                dry.add(i);\\n                result[i] = 1;\\n            } else {\\n                if(!rained.containsKey(rains[i])) {\\n                    result[i] = -1;\\n                    rained.put(rains[i], i);\\n                } else {\\n                    Integer fill = dry.ceiling(rained.get(rains[i]) +1);\\n                    if(fill == null)\\n                        return new int[0];\\n                    result[fill] = rains[i];\\n                    result[i] = -1;\\n                    dry.remove(fill);\\n                    rained.put(rains[i], i);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int zeroes = 0;\\n        Map<Integer, Integer> rained = new HashMap<>();\\n        TreeSet<Integer> dry = new TreeSet<>();\\n        int result[] = new int[rains.length];\\n        for(int i =0; i<rains.length; ++i) {\\n            if(rains[i] == 0) {\\n                dry.add(i);\\n                result[i] = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 697722,
                "title": "clean-python-3-heap-and-deque-o-nlogl",
                "content": "Time: `O(NlogL)`, where `N` is the length of `rains` and `L` is the most amounts of full lakes in the same time.\\nSpace: `O(L)`\\n```\\nimport collections\\nimport heapq\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        full, heap, result = set(), [], []\\n        lookup = collections.defaultdict(collections.deque)\\n        for i, lake in enumerate(rains):\\n            if lake > 0: lookup[lake].append(i)\\n        for i, lake in enumerate(rains):\\n            if lake > 0:\\n                if lake in full: return []\\n                result.append(-1)\\n                full.add(lake)\\n                lookup[lake].popleft()\\n                if lookup[lake]:\\n                    heapq.heappush(heap, (lookup[lake][0], lake))\\n            else:\\n                day, urgent_lake = heapq.heappop(heap) if heap else (1, 1)\\n                while heap and day <= i:\\n                    day, urgent_lake = heapq.heappop(heap)\\n                result.append(urgent_lake)\\n                full.discard(urgent_lake)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nimport heapq\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        full, heap, result = set(), [], []\\n        lookup = collections.defaultdict(collections.deque)\\n        for i, lake in enumerate(rains):\\n            if lake > 0: lookup[lake].append(i)\\n        for i, lake in enumerate(rains):\\n            if lake > 0:\\n                if lake in full: return []\\n                result.append(-1)\\n                full.add(lake)\\n                lookup[lake].popleft()\\n                if lookup[lake]:\\n                    heapq.heappush(heap, (lookup[lake][0], lake))\\n            else:\\n                day, urgent_lake = heapq.heappop(heap) if heap else (1, 1)\\n                while heap and day <= i:\\n                    day, urgent_lake = heapq.heappop(heap)\\n                result.append(urgent_lake)\\n                full.discard(urgent_lake)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697692,
                "title": "python-java-python-bisect-java-treeset-solution",
                "content": "```python\\n# yes, I know, it\\'s O(n^2), QAQ\\n# But If we have treeSet in Python, it\\'s will become O(nlogn), as slots.pop(idx) can become O(log(n))\\nimport bisect\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        res = [-1]*len(rains)\\n        slots = []\\n        memo = {}\\n        for i,r in enumerate(rains):\\n            if r==0:\\n                slots.append(i)\\n            else:\\n                if r in memo:\\n                    idx = bisect.bisect_left(slots,memo[r])\\n                    if idx == len(slots): return []\\n                    res[slots.pop(idx)] = r\\n                memo[r] = i\\n        while slots:\\n            res[slots.pop()] = 1\\n        return res\\n```\\n\\n```java\\n\\n// In comparision, java can achieve O(nlogn) with TreeSet, as you can see.\\n\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        Map<Integer, Integer> posMemo = new HashMap<>();\\n        TreeSet<Integer> slots = new TreeSet<>();\\n        int[] res = new int[rains.length];\\n        Arrays.fill(res,-1);\\n        for (int i=0;i<rains.length;i++){\\n            if (rains[i]==0){\\n                slots.add(i);\\n            } else {\\n                if (posMemo.containsKey(rains[i])){\\n                    Integer slot = slots.ceiling(posMemo.get(rains[i]));\\n                    if (slot == null) return new int[0];\\n                    res[slot] = rains[i];\\n                    slots.remove(slot);\\n                }\\n                posMemo.put(rains[i],i);\\n            }\\n        }\\n        for (int s: slots) res[s] = 1;\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```python\\n# yes, I know, it\\'s O(n^2), QAQ\\n# But If we have treeSet in Python, it\\'s will become O(nlogn), as slots.pop(idx) can become O(log(n))\\nimport bisect\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        res = [-1]*len(rains)\\n        slots = []\\n        memo = {}\\n        for i,r in enumerate(rains):\\n            if r==0:\\n                slots.append(i)\\n            else:\\n                if r in memo:\\n                    idx = bisect.bisect_left(slots,memo[r])\\n                    if idx == len(slots): return []\\n                    res[slots.pop(idx)] = r\\n                memo[r] = i\\n        while slots:\\n            res[slots.pop()] = 1\\n        return res\\n```\n```java\\n\\n// In comparision, java can achieve O(nlogn) with TreeSet, as you can see.\\n\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        Map<Integer, Integer> posMemo = new HashMap<>();\\n        TreeSet<Integer> slots = new TreeSet<>();\\n        int[] res = new int[rains.length];\\n        Arrays.fill(res,-1);\\n        for (int i=0;i<rains.length;i++){\\n            if (rains[i]==0){\\n                slots.add(i);\\n            } else {\\n                if (posMemo.containsKey(rains[i])){\\n                    Integer slot = slots.ceiling(posMemo.get(rains[i]));\\n                    if (slot == null) return new int[0];\\n                    res[slot] = rains[i];\\n                    slots.remove(slot);\\n                }\\n                posMemo.put(rains[i],i);\\n            }\\n        }\\n        for (int s: slots) res[s] = 1;\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613276,
                "title": "using-hashmap-and-treeset-simple-and-fast-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        TreeSet<Integer> dry=new TreeSet<>();\\n\\n        int n=rains.length;\\n        int[] res=new int[n];\\n\\n        for(int i=0;i<n;i++){\\n            if(rains[i]==0){\\n                dry.add(i);\\n                res[i]=1; \\n            }\\n            else{\\n                if(map.containsKey(rains[i])){\\n                   Integer availZero=dry.ceiling(map.get(rains[i]));\\n                   if(availZero==null){\\n                       return new int[0];\\n                   }\\n                   res[availZero]=rains[i];\\n                   dry.remove(availZero);\\n\\n                }\\n                res[i]=-1;\\n                map.put(rains[i],i);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        TreeSet<Integer> dry=new TreeSet<>();\\n\\n        int n=rains.length;\\n        int[] res=new int[n];\\n\\n        for(int i=0;i<n;i++){\\n            if(rains[i]==0){\\n                dry.add(i);\\n                res[i]=1; \\n            }\\n            else{\\n                if(map.containsKey(rains[i])){\\n                   Integer availZero=dry.ceiling(map.get(rains[i]));\\n                   if(availZero==null){\\n                       return new int[0];\\n                   }\\n                   res[availZero]=rains[i];\\n                   dry.remove(availZero);\\n\\n                }\\n                res[i]=-1;\\n                map.put(rains[i],i);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364577,
                "title": "c-binary-search-hash-table-explained",
                "content": "# Approach\\nDo a linear scan of the input array `rains`.\\n\\n- If `rains[i] == 0`, then store the index in `zeroes`.\\n- If `rains[i] != 0` and `rains[i]` does not exist in the hashmap, then insert it (and its index) into the hashmap. The lake `rains[i]` is now full.\\n- If `rains[i] != 0` and `rains[i]` exists in the hashmap, then perform binary search on `zeroes` to see if `rains[i]` can be dried before it floods.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int, int> memo; // (rains[i], i) where rains[i] != 0\\n        set<int> zeroes; // i where rains[i] == 0\\n        vector<int> ans(rains.size(), -1); // answer\\n\\n        for (int i = 0; i < rains.size(); ++i) {\\n            if (rains[i] == 0) {\\n                // store index in the zeroes list\\n                // or increment chain from previous zero\\n                zeroes.insert(i);\\n            } else if (!memo.count(rains[i])) {\\n                // store \"lake\" index in the hashmap\\n                memo.emplace(rains[i], i);\\n            } else {\\n                // search for zero index that can dry out the \"lake\"\\n                auto it = zeroes.upper_bound(memo.at(rains[i]));\\n                \\n                // return empty list if not found\\n                if (it == zeroes.end()) return vector<int>();\\n\\n                // update answer, hashmp and zeroes\\n                ans.at(*it) = rains[i];\\n                memo.at(rains[i]) = i;\\n                zeroes.erase(it);\\n            }\\n        }\\n\\n        // all unused zeroes will point to \"lake\" 1\\n        for (int i: zeroes) ans.at(i) = 1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int, int> memo; // (rains[i], i) where rains[i] != 0\\n        set<int> zeroes; // i where rains[i] == 0\\n        vector<int> ans(rains.size(), -1); // answer\\n\\n        for (int i = 0; i < rains.size(); ++i) {\\n            if (rains[i] == 0) {\\n                // store index in the zeroes list\\n                // or increment chain from previous zero\\n                zeroes.insert(i);\\n            } else if (!memo.count(rains[i])) {\\n                // store \"lake\" index in the hashmap\\n                memo.emplace(rains[i], i);\\n            } else {\\n                // search for zero index that can dry out the \"lake\"\\n                auto it = zeroes.upper_bound(memo.at(rains[i]));\\n                \\n                // return empty list if not found\\n                if (it == zeroes.end()) return vector<int>();\\n\\n                // update answer, hashmp and zeroes\\n                ans.at(*it) = rains[i];\\n                memo.at(rains[i]) = i;\\n                zeroes.erase(it);\\n            }\\n        }\\n\\n        // all unused zeroes will point to \"lake\" 1\\n        for (int i: zeroes) ans.at(i) = 1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170798,
                "title": "beats-100-java-code",
                "content": "# Java Code\\n```\\nclass Solution {\\n    private LinkedList<Integer> dryDays;\\n\\n    public int[] avoidFlood(int[] rains) {\\n        int n = rains.length;\\n        int[] res = new int[n];\\n        Arrays.fill(res, 1);\\n        dryDays = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (rains[i] == 0) dryDays.add(i);\\n            else res[i] = -1;\\n        }\\n        Map<Integer, Integer> tracker = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            if (rains[i] == 0) continue;\\n            if (tracker.containsKey(rains[i])) {\\n                int dryDay = findDryDay(tracker.get(rains[i]), i);\\n                if (dryDay == -1) {\\n                    return new int[0];\\n                }\\n                res[dryDay] = rains[i];\\n            }\\n            tracker.put(rains[i], i);\\n        }\\n        return res;\\n    }\\n\\n    private int findDryDay(int prev, int current) {\\n        Iterator<Integer> iterator = dryDays.iterator();\\n        while (iterator.hasNext()) {\\n            int day = iterator.next();\\n            if (day < current && day > prev) {\\n                iterator.remove();\\n                return day;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    private LinkedList<Integer> dryDays;\\n\\n    public int[] avoidFlood(int[] rains) {\\n        int n = rains.length;\\n        int[] res = new int[n];\\n        Arrays.fill(res, 1);\\n        dryDays = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (rains[i] == 0) dryDays.add(i);\\n            else res[i] = -1;\\n        }\\n        Map<Integer, Integer> tracker = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            if (rains[i] == 0) continue;\\n            if (tracker.containsKey(rains[i])) {\\n                int dryDay = findDryDay(tracker.get(rains[i]), i);\\n                if (dryDay == -1) {\\n                    return new int[0];\\n                }\\n                res[dryDay] = rains[i];\\n            }\\n            tracker.put(rains[i], i);\\n        }\\n        return res;\\n    }\\n\\n    private int findDryDay(int prev, int current) {\\n        Iterator<Integer> iterator = dryDays.iterator();\\n        while (iterator.hasNext()) {\\n            int day = iterator.next();\\n            if (day < current && day > prev) {\\n                iterator.remove();\\n                return day;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551256,
                "title": "microsoft-interview-question-intuition-explained-most-optimal-way",
                "content": "```\\nvector<int> avoidFlood(vector<int>& arr) {\\n        \\n        vector<int> ans(arr.size(),-1);\\n        unordered_map<int,int> m;\\n        set<int> s;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(m.find(arr[i])!=m.end())  //bhai meri 2sri occurence aagyi\\n            {\\n                int lastFilled=m[arr[i]]; //last me is index me bhra gya tha\\n                \\n          //IMportant --> merse just bda(mera upper bound) ke din mai dry hounga\\n                auto it=s.upper_bound(lastFilled); \\n                \\n                if(it==s.end())  //mai dry nahi ho skta (no dry day left in set)\\n                    return {};\\n                else   //mai dry ho skta hu\\n                {\\n                    ans[*it]=arr[i];  //merse just bda \\n                    s.erase(it);  //ab ye wle dry day use krliya hai set se htado\\n                }\\n                m[arr[i]]=i; //now last filled of this lakes becomes i\\n            }\\n            \\n            else if(arr[i]==0)  //bhai yaha mai abhi ke loye 1 bhrdunga ie default value\\n            {\\n                ans[i]=1;\\n                s.insert(i);\\n            }\\n              \\n            else   //bhai meri pehli occurence hai ye to sirf map me index daldo\\n                m[arr[i]]=i;    \\n        }   \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nvector<int> avoidFlood(vector<int>& arr) {\\n        \\n        vector<int> ans(arr.size(),-1);\\n        unordered_map<int,int> m;\\n        set<int> s;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(m.find(arr[i])!=m.end())  //bhai meri 2sri occurence aagyi\\n            {\\n                int lastFilled=m[arr[i]]; //last me is index me bhra gya tha\\n                \\n          //IMportant --> merse just bda(mera upper bound) ke din mai dry hounga\\n                auto it=s.upper_bound(lastFilled); \\n                \\n                if(it==s.end())  //mai dry nahi ho skta (no dry day left in set)\\n                    return {};\\n                else   //mai dry ho skta hu\\n                {\\n                    ans[*it]=arr[i];  //merse just bda \\n                    s.erase(it);  //ab ye wle dry day use krliya hai set se htado\\n                }\\n                m[arr[i]]=i; //now last filled of this lakes becomes i\\n            }\\n            \\n            else if(arr[i]==0)  //bhai yaha mai abhi ke loye 1 bhrdunga ie default value\\n            {\\n                ans[i]=1;\\n                s.insert(i);\\n            }\\n              \\n            else   //bhai meri pehli occurence hai ye to sirf map me index daldo\\n                m[arr[i]]=i;    \\n        }   \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2330739,
                "title": "java-time-o-nlogn-space-o-n-hash-treeset",
                "content": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        Map<Integer,Integer> rain = new HashMap<>();\\n        TreeSet<Integer> dry = new TreeSet<>();\\n        \\n        int[] result = new int[rains.length];\\n        Arrays.fill(result,-1);\\n        \\n        for(int i=0;i<rains.length;i++){\\n            if(rains[i]==0){\\n                dry.add(i);\\n                result[i] = 1;\\n            }else{\\n                if(rain.containsKey(rains[i])){\\n                    int day = rain.get(rains[i]);\\n                    Integer dryDayCandidate = dry.ceiling(day);\\n                    if(dryDayCandidate==null){\\n                        return new int[]{};\\n                    }else{\\n                        result[dryDayCandidate] = rains[i];\\n                        dry.remove(dryDayCandidate);\\n                    }\\n                }\\n                rain.put(rains[i],i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n\\n//[1]\\n//[1,2,0,3,2,0,3,4,0,2,1]\\n// 0 1 2 3 4 5 6 7 8 9 10\\n\\n//         Map                                        Zeros\\n//i = 0, [1:0]\\n//i = 1, [1:0, 2:1]\\n//i = 2, [1:0, 2:1]                                     2\\n//i = 3, [1:0, 2:1, 3:3]                                2\\n//i = 4, rain = 2, we have in map,\\n//       map.get(rain) = 1, it is filled\\n//       at day 1, and in Zeros, we have 2\\n//       which means at day 2, we can empty\\n//       rain = 2, therefore, result[2] = rain         emtpy\\n//       [1:0, 2:4, 3:3]\\n//i = 5,                                                5\\n//i = 6, rain = 3, we have it in map\\n//       map.get(rain) = 3, and in Zeros, we\\n//       have 5, therefore, result[5] = rain = 3      empty\\n//       [1:0, 2:4, 3:6]\\n//i = 7, [1:0, 2:4, 3:6, 4:7]\\n//i = 8,                                                8\\n//i = 9, rain = 2, we have it in map\\n//       map.get(rain) = 4, and in zero, we have\\n//       8, therefore, result[8] = rain = 4\\n//       [1:0, 2:9, 3:6, 4:7]                         empty\\n//i=10,  rain = 1, we have it in map\\n//       map.get(rain) = 0, we don\\'t have days in\\n//       zeros to empty it, so we return empty result\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        Map<Integer,Integer> rain = new HashMap<>();\\n        TreeSet<Integer> dry = new TreeSet<>();\\n        \\n        int[] result = new int[rains.length];\\n        Arrays.fill(result,-1);\\n        \\n        for(int i=0;i<rains.length;i++){\\n            if(rains[i]==0){\\n                dry.add(i);\\n                result[i] = 1;\\n            }else{\\n                if(rain.containsKey(rains[i])){\\n                    int day = rain.get(rains[i]);\\n                    Integer dryDayCandidate = dry.ceiling(day);\\n                    if(dryDayCandidate==null){\\n                        return new int[]{};\\n                    }else{\\n                        result[dryDayCandidate] = rains[i];\\n                        dry.remove(dryDayCandidate);\\n                    }\\n                }\\n                rain.put(rains[i],i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n\\n//[1]\\n//[1,2,0,3,2,0,3,4,0,2,1]\\n// 0 1 2 3 4 5 6 7 8 9 10\\n\\n//         Map                                        Zeros\\n//i = 0, [1:0]\\n//i = 1, [1:0, 2:1]\\n//i = 2, [1:0, 2:1]                                     2\\n//i = 3, [1:0, 2:1, 3:3]                                2\\n//i = 4, rain = 2, we have in map,\\n//       map.get(rain) = 1, it is filled\\n//       at day 1, and in Zeros, we have 2\\n//       which means at day 2, we can empty\\n//       rain = 2, therefore, result[2] = rain         emtpy\\n//       [1:0, 2:4, 3:3]\\n//i = 5,                                                5\\n//i = 6, rain = 3, we have it in map\\n//       map.get(rain) = 3, and in Zeros, we\\n//       have 5, therefore, result[5] = rain = 3      empty\\n//       [1:0, 2:4, 3:6]\\n//i = 7, [1:0, 2:4, 3:6, 4:7]\\n//i = 8,                                                8\\n//i = 9, rain = 2, we have it in map\\n//       map.get(rain) = 4, and in zero, we have\\n//       8, therefore, result[8] = rain = 4\\n//       [1:0, 2:9, 3:6, 4:7]                         empty\\n//i=10,  rain = 1, we have it in map\\n//       map.get(rain) = 0, we don\\'t have days in\\n//       zeros to empty it, so we return empty result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137469,
                "title": "such-an-unordinary-question",
                "content": "```cpp\\nint n = rains.size();\\n// set default value to 1 for no particular reason.\\nvector<int> ans(n, 1);\\n// those days we can dry a lake.\\nset<int> dry_day;\\n// the day when the particular lake is full.\\nmap<int, int> full;\\n\\n// for each day\\nfor (int i = 0; i < n; ++i)\\n{\\n\\t// if it is rainning\\n\\tif (rains[i])\\n\\t{\\n\\t\\t// if the lake is full\\n\\t\\tif (full[rains[i]])\\n\\t\\t{\\n\\t\\t\\t// we try to find a possible sunny day in the past since the day this lake was filled.\\n\\t\\t\\tauto it = dry_day.lower_bound(full[rains[i]]);\\n\\t\\t\\t\\n\\t\\t\\t// if we can not find a possible day, return fail.\\n\\t\\t\\tif (it == dry_day.end())\\n\\t\\t\\t\\treturn {};\\n\\t\\t\\t\\n\\t\\t\\t// set the day to dry this lake\\n\\t\\t\\tans[*it] = rains[i];\\n\\t\\t\\t// the chosen day can no longer be available.\\n\\t\\t\\tdry_day.erase(it);\\n\\t\\t}\\n\\t\\t\\n\\t\\t// record the day when this lake is filled.\\n\\t\\tfull[rains[i]] = i + 1;\\n\\t\\t// the ans of raining day is always -1\\n\\t\\tans[i] = -1;\\n\\t}\\n\\telse // if it\\'s sunny\\n\\t{\\n\\t\\tdry_day.insert(i);\\n\\t}\\n}\\n\\nreturn ans;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```cpp\\nint n = rains.size();\\n// set default value to 1 for no particular reason.\\nvector<int> ans(n, 1);\\n// those days we can dry a lake.\\nset<int> dry_day;\\n// the day when the particular lake is full.\\nmap<int, int> full;\\n\\n// for each day\\nfor (int i = 0; i < n; ++i)\\n{\\n\\t// if it is rainning\\n\\tif (rains[i])\\n\\t{\\n\\t\\t// if the lake is full\\n\\t\\tif (full[rains[i]])\\n\\t\\t{\\n\\t\\t\\t// we try to find a possible sunny day in the past since the day this lake was filled.\\n\\t\\t\\tauto it = dry_day.lower_bound(full[rains[i]]);\\n\\t\\t\\t\\n\\t\\t\\t// if we can not find a possible day, return fail.\\n\\t\\t\\tif (it == dry_day.end())\\n\\t\\t\\t\\treturn {};\\n\\t\\t\\t\\n\\t\\t\\t// set the day to dry this lake\\n\\t\\t\\tans[*it] = rains[i];\\n\\t\\t\\t// the chosen day can no longer be available.\\n\\t\\t\\tdry_day.erase(it);\\n\\t\\t}\\n\\t\\t\\n\\t\\t// record the day when this lake is filled.\\n\\t\\tfull[rains[i]] = i + 1;\\n\\t\\t// the ans of raining day is always -1\\n\\t\\tans[i] = -1;\\n\\t}\\n\\telse // if it\\'s sunny\\n\\t{\\n\\t\\tdry_day.insert(i);\\n\\t}\\n}\\n\\nreturn ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2051021,
                "title": "simple-java-solution-using-hashmap-and-treeset-easy-to-understand",
                "content": "Please upvote, if you find it useful :)\\n\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int[] ans = new int[rains.length];\\n        TreeSet<Integer> tset = new TreeSet<>();\\n\\n        for(int i=0; i<rains.length; i++) {\\n            if(rains[i] == 0) {\\n                tset.add(i);\\n            } else {\\n                if(map.containsKey(rains[i])) {\\n                    int idx = map.get(rains[i]);\\n                    \\n                    Integer ddidx = tset.ceiling(idx);\\n                    if(ddidx == null) {\\n                        return new int[]{};\\n                    }\\n\\n                    ans[ddidx] = rains[i];\\n                    tset.remove(ddidx);\\n                    map.put(rains[i], i);\\n                    \\n                } else {\\n                    map.put(rains[i], i);\\n                }\\n                ans[i] = -1;\\n            }\\n        }\\n        \\n        for(int i = 0; i<ans.length; i++) {\\n            if(ans[i] == 0) {\\n                ans[i] = 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int[] ans = new int[rains.length];\\n        TreeSet<Integer> tset = new TreeSet<>();\\n\\n        for(int i=0; i<rains.length; i++) {\\n            if(rains[i] == 0) {\\n                tset.add(i);\\n            } else {\\n                if(map.containsKey(rains[i])) {\\n                    int idx = map.get(rains[i]);\\n                    \\n                    Integer ddidx = tset.ceiling(idx);\\n                    if(ddidx == null) {\\n                        return new int[]{};\\n                    }\\n\\n                    ans[ddidx] = rains[i];\\n                    tset.remove(ddidx);\\n                    map.put(rains[i], i);\\n                    \\n                } else {\\n                    map.put(rains[i], i);\\n                }\\n                ans[i] = -1;\\n            }\\n        }\\n        \\n        for(int i = 0; i<ans.length; i++) {\\n            if(ans[i] == 0) {\\n                ans[i] = 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372786,
                "title": "78-th-testcase-failing-can-anyone-tell-why",
                "content": "testcase -[1,0,2,0,3,0,2,0,0,0,1,2,3]\\nexpected ouput-[-1,1,-1,2,-1,3,-1,2,1,1,-1,-1,-1]\\noutput -[-1,1,-1,2,-1,3,-1,1,1,1,-1,-1,-1]\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n            HashMap<Integer,Integer> map=new HashMap<>();\\n            TreeMap<Integer,Integer> tree=new TreeMap<>();\\n            int[] ans=new int[rains.length];\\n        for(int i=0;i<rains.length;i++){\\n            if(rains[i]==0){\\n                ans[i]=1;\\n              tree.put(i,0);\\n            }else{\\n                if(map.containsKey(rains[i])){\\n                  Integer x= tree.ceilingKey(map.get(rains[i]));\\n                    if(x==null)return new int[]{};\\n                    else{\\n                        map.remove(rains[i]);\\n                       ans[x]=rains[i];\\n                        tree.remove(x);\\n                    }\\n                }\\n                else{\\n                    map.put(rains[i],i);\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<ans.length;i++){\\n            if(rains[i]>0)ans[i]=-1;\\n        }\\n      \\n         return  ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n            HashMap<Integer,Integer> map=new HashMap<>();\\n            TreeMap<Integer,Integer> tree=new TreeMap<>();\\n            int[] ans=new int[rains.length];\\n        for(int i=0;i<rains.length;i++){\\n            if(rains[i]==0){\\n                ans[i]=1;\\n              tree.put(i,0);\\n            }else{\\n                if(map.containsKey(rains[i])){\\n                  Integer x= tree.ceilingKey(map.get(rains[i]));\\n                    if(x==null)return new int[]{};\\n                    else{\\n                        map.remove(rains[i]);\\n                       ans[x]=rains[i];\\n                        tree.remove(x);\\n                    }\\n                }\\n                else{\\n                    map.put(rains[i],i);\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<ans.length;i++){\\n            if(rains[i]>0)ans[i]=-1;\\n        }\\n      \\n         return  ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198263,
                "title": "simple-solution-using-a-dictionary-and-a-linkedlist",
                "content": "The idea is to have a list with available days for drying, then when a lake is about to flood, we just have to find if there is a drying day BEFORE the previous rain over the lake.\\n1. if it does remove the day for the list and remove the lake from the full lakes set. \\n2. if it doesn\\'t the flooding is invevitable.\\n\\n\\n```\\npublic int[] AvoidFlood(int[] rains) {\\n        var fullLakes = new Dictionary<int, int>(); // lake, full day\\n        var dries = new LinkedList<int?>();\\n        \\n        var response = new int[rains.Length];\\n        Array.Fill(response, 1);\\n        \\n        for (var d = 0; d < rains.Length; d++){\\n            var lake = rains[d];\\n            if (lake == 0) {\\n                dries.AddLast(d);\\n                continue;\\n            }\\n            \\n            if (fullLakes.ContainsKey(lake)){                \\n                var dry = dries.FirstOrDefault(i => i > fullLakes[lake]);\\n                if (dry == null){\\n                    return new int[0];\\n                }\\n                \\n                response[dry.Value] = lake;\\n                dries.Remove(dry);\\n            }\\n            \\n            response[d] = -1;\\n            fullLakes[lake] = d;\\n        }\\n        \\n        \\n        return response;\\n    }  \\n```",
                "solutionTags": [
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\npublic int[] AvoidFlood(int[] rains) {\\n        var fullLakes = new Dictionary<int, int>(); // lake, full day\\n        var dries = new LinkedList<int?>();\\n        \\n        var response = new int[rains.Length];\\n        Array.Fill(response, 1);\\n        \\n        for (var d = 0; d < rains.Length; d++){\\n            var lake = rains[d];\\n            if (lake == 0) {\\n                dries.AddLast(d);\\n                continue;\\n            }\\n            \\n            if (fullLakes.ContainsKey(lake)){                \\n                var dry = dries.FirstOrDefault(i => i > fullLakes[lake]);\\n                if (dry == null){\\n                    return new int[0];\\n                }\\n                \\n                response[dry.Value] = lake;\\n                dries.Remove(dry);\\n            }\\n            \\n            response[d] = -1;\\n            fullLakes[lake] = d;\\n        }\\n        \\n        \\n        return response;\\n    }  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1180938,
                "title": "c-using-unordered-map-and-set-explanation",
                "content": "```\\n#define DRY  0\\n#define ANY_LAKE 1\\n// The solution is to match dry day by the order it become full again\\n// By selecting the first dry day available after it become full before\\n// We dont have to empty lakes that appear only once even if we can\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) \\n    {\\n        vector<int> result(rains.size(),-1);\\n        unordered_map<int,int> lakes_full;\\n        set<int> dry_days;\\n        for (int i=0; i<rains.size(); i++)\\n        {\\n            if (rains[i] == DRY)\\n            {\\n                result[i] = ANY_LAKE;  // mark as default day as default\\n                dry_days.insert(i);\\n            }\\n            else\\n            {\\n                int lake = rains[i];\\n                auto prior_full_day = lakes_full.find(lake);\\n                // Check if lake is already full\\n                if (prior_full_day != lakes_full.end())\\n                {   // Check for the first dry day after first full\\n                    int day = prior_full_day->second;\\n                    auto first_dry_day = dry_days.lower_bound(day);\\n                    if (first_dry_day  == dry_days.end())\\n                    {   // return fail result\\n                        result.clear();\\n                        break;  \\n                    }\\n                    // Update dry day with lake (change from default)\\n                    result[*first_dry_day]  =  lake;\\n                    // Remove dry day form available days list\\n                    dry_days.erase(first_dry_day);\\n                }\\n                // Update lakes full for current day\\n                lakes_full[lake] = i;\\n            }\\n        }\\n        return result;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define DRY  0\\n#define ANY_LAKE 1\\n// The solution is to match dry day by the order it become full again\\n// By selecting the first dry day available after it become full before\\n// We dont have to empty lakes that appear only once even if we can\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) \\n    {\\n        vector<int> result(rains.size(),-1);\\n        unordered_map<int,int> lakes_full;\\n        set<int> dry_days;\\n        for (int i=0; i<rains.size(); i++)\\n        {\\n            if (rains[i] == DRY)\\n            {\\n                result[i] = ANY_LAKE;  // mark as default day as default\\n                dry_days.insert(i);\\n            }\\n            else\\n            {\\n                int lake = rains[i];\\n                auto prior_full_day = lakes_full.find(lake);\\n                // Check if lake is already full\\n                if (prior_full_day != lakes_full.end())\\n                {   // Check for the first dry day after first full\\n                    int day = prior_full_day->second;\\n                    auto first_dry_day = dry_days.lower_bound(day);\\n                    if (first_dry_day  == dry_days.end())\\n                    {   // return fail result\\n                        result.clear();\\n                        break;  \\n                    }\\n                    // Update dry day with lake (change from default)\\n                    result[*first_dry_day]  =  lake;\\n                    // Remove dry day form available days list\\n                    dry_days.erase(first_dry_day);\\n                }\\n                // Update lakes full for current day\\n                lakes_full[lake] = i;\\n            }\\n        }\\n        return result;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138218,
                "title": "simple-java-solution-map-tree-set",
                "content": "JAVA CODE IS:\\n# \\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        //map contains pair as values-index\\n       Map<Integer,Integer>map=new HashMap<>();\\n        //dry contains index of no rains days\\n        TreeSet<Integer>dry=new TreeSet<>();\\n        int ans[]=new int[rains.length];\\n        for(int i=0;i<rains.length;i++){\\n           if(rains[i]==0){\\n               dry.add(i);\\n               continue;\\n           }\\n            ans[i]=-1;\\n           if(!map.containsKey(rains[i])){ \\n               map.put(rains[i],i);\\n               continue;\\n           }\\n           if(dry.ceiling(map.get(rains[i]))==null) return new int[]{};\\n           ans[dry.ceiling(map.get(rains[i]))]=rains[i];\\n           dry.remove(dry.ceiling(map.get(rains[i])));\\n            map.put(rains[i],i);\\n        }\\n        for(int k : dry) ans[k]=1;\\n        return ans;\\n    }\\n}\\n```\\nTIME : O(nlogn)\\nSPACE : O(n)\\n***PLEASE,UPVOTE IF THIS IS HELPFUL***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        //map contains pair as values-index\\n       Map<Integer,Integer>map=new HashMap<>();\\n        //dry contains index of no rains days\\n        TreeSet<Integer>dry=new TreeSet<>();\\n        int ans[]=new int[rains.length];\\n        for(int i=0;i<rains.length;i++){\\n           if(rains[i]==0){\\n               dry.add(i);\\n               continue;\\n           }\\n            ans[i]=-1;\\n           if(!map.containsKey(rains[i])){ \\n               map.put(rains[i],i);\\n               continue;\\n           }\\n           if(dry.ceiling(map.get(rains[i]))==null) return new int[]{};\\n           ans[dry.ceiling(map.get(rains[i]))]=rains[i];\\n           dry.remove(dry.ceiling(map.get(rains[i])));\\n            map.put(rains[i],i);\\n        }\\n        for(int k : dry) ans[k]=1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125986,
                "title": "python-solution-with-detailed-comments-no-extra-package-used",
                "content": "class Solution:\\n\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        d = set()\\n        full = set()\\n        ans = [1]*len(rains) # we set 1 since if no need to dry a lake in a sunny day, fix it to 1\\n        l = [] # stores the index that rains[i] has appeared before \\n        for i in range(len(rains)):\\n            if rains[i]!=0 and rains[i] in d: #rains[i] appeared before current index\\n                l.append(i)\\n            else:\\n                d.add(rains[i])\\n        del d\\n\\n        for i in range(len(rains)): \\n            if rains[i]:\\n                if rains[i] in full:\\n                    return []\\n                full.add(rains[i])\\n                ans[i] = -1 #rainy day is set to -1\\n            else: # for the sunny day, we search the l and find the first index such that l[j] is full\\n                for j in range(len(l)):\\n                    if rains[l[j]] in full:\\n                        index = l.pop(j)\\n                        ans[i] = rains[index]\\n                        full.remove(rains[index])\\n                        break        \\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        d = set()\\n        full = set()\\n        ans = [1]*len(rains) # we set 1 since if no need to dry a lake in a sunny day, fix it to 1\\n        l = [] # stores the index that rains[i] has appeared before \\n        for i in range(len(rains)):\\n            if rains[i]!=0 and rains[i] in d: #rains[i] appeared before current index\\n                l.append(i)\\n            else:\\n                d.add(rains[i])\\n        del d\\n\\n        for i in range(len(rains)): \\n            if rains[i]:\\n                if rains[i] in full:\\n                    return []\\n                full.add(rains[i])\\n                ans[i] = -1 #rainy day is set to -1\\n            else: # for the sunny day, we search the l and find the first index such that l[j] is full\\n                for j in range(len(l)):\\n                    if rains[l[j]] in full:\\n                        index = l.pop(j)\\n                        ans[i] = rains[index]\\n                        full.remove(rains[index])\\n                        break        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1092346,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int len = rains.length;\\n        int[] res = new int[len];\\n        TreeSet<Integer> dryDays = new TreeSet();\\n        Map<Integer, Integer> fullLakes = new HashMap();\\n        for(int i=0; i<len; i++){\\n            if(rains[i]>0){\\n                res[i] = -1;\\n                if(fullLakes.containsKey(rains[i])){\\n                    Integer dryDay = dryDays.higher(fullLakes.get(rains[i]));\\n                    if(dryDay==null) \\n                        return new int[0];\\n                    else{\\n                        dryDays.remove(dryDay);\\n                        res[dryDay] = rains[i];\\n                    }\\n                }\\n                fullLakes.put(rains[i], i);\\n            }else{\\n                res[i] = 1;\\n                dryDays.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int len = rains.length;\\n        int[] res = new int[len];\\n        TreeSet<Integer> dryDays = new TreeSet();\\n        Map<Integer, Integer> fullLakes = new HashMap();\\n        for(int i=0; i<len; i++){\\n            if(rains[i]>0){\\n                res[i] = -1;\\n                if(fullLakes.containsKey(rains[i])){\\n                    Integer dryDay = dryDays.higher(fullLakes.get(rains[i]));\\n                    if(dryDay==null) \\n                        return new int[0];\\n                    else{\\n                        dryDays.remove(dryDay);\\n                        res[dryDay] = rains[i];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1039868,
                "title": "c-solution-with-o-nlogn",
                "content": "From the description, the lakes are infinite which means range from 1 to 10^5. That means we can not use an array to store the lakes, `HashMap` is a good way.  We can use a variable `unordered_map<int, int> last_rain` to store the last rain lake, and a set variable `sun` to store the sunny day. At iterating the rains, if today is sun day, we can mark it in `sun`, if today is rain day, we can mark it in `last_rain`, but if the lake is full, we should do something to avoid flood:\\n1. find the first sun day from `sun` from the last rain day to today.\\n2. if we can not find the sun day from step1, we should return a empty array to express no way to avoid flood\\n\\n```cpp\\n#include<set>\\n\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        std::set<int> sun;\\n        unordered_map<int, int> last_rain;\\n        vector<int> ans(rains.size(), -1);\\n        for (int i=0; i<rains.size(); ++i) {\\n            // mark the sun day\\n            if (rains[i] == 0) {\\n                sun.insert(i);\\n                ans[i] = 1;\\n            } else {\\n                if (last_rain.count(rains[i]) > 0) {\\n                    // the lake is full, we should do sth...\\n                    // find the first sun day after the last rain day\\n                    auto it = sun.upper_bound(last_rain[rains[i]]);\\n                    // can not find the way to dry the lake\\n                    if (it == std::end(sun)) {\\n                        return {};\\n                    }\\n                    ans[*it] = rains[i];\\n                    sun.erase(it);\\n                }\\n                // mask the last rain day\\n                last_rain[rains[i]] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n#include<set>\\n\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        std::set<int> sun;\\n        unordered_map<int, int> last_rain;\\n        vector<int> ans(rains.size(), -1);\\n        for (int i=0; i<rains.size(); ++i) {\\n            // mark the sun day\\n            if (rains[i] == 0) {\\n                sun.insert(i);\\n                ans[i] = 1;\\n            } else {\\n                if (last_rain.count(rains[i]) > 0) {\\n                    // the lake is full, we should do sth...\\n                    // find the first sun day after the last rain day\\n                    auto it = sun.upper_bound(last_rain[rains[i]]);\\n                    // can not find the way to dry the lake\\n                    if (it == std::end(sun)) {\\n                        return {};\\n                    }\\n                    ans[*it] = rains[i];\\n                    sun.erase(it);\\n                }\\n                // mask the last rain day\\n                last_rain[rains[i]] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 970092,
                "title": "java-easy-to-understand-time-63ms-o-nlogn-space-o-n",
                "content": "**Algorithm**\\n*  Start with the `ans` array equal to the length of he `rains` array\\n*  Fill the `ans` array with `1`, this is defaulted if you have lot of dry day and no lakes available at hand to empty\\n*  You also have to maintain a `emptyLakes` **TreeSet** to store all the empty lakes that we have seen\\n*  Maintain a `fullLakes` **HashMap** to track the full takes that we have seein in the rains array, key will be the rain and value will be the index.\\n*  Loop through the rains array. \\n*  If you see dry day .ie. value `0` for `rains[i]` then add the current index to the `emptyLakes`\\n*  If you see `rain[i]` with `> 0` then fill it immediately with `-1`\\n*  If you find the current lake in the `fullLakes` then get the `empty lake` from `emptyLakes` after the index of the full lake. This is because the dry day should come after the lake is first filled. You cannot fill with a lake that never got full.\\n*  If you dont find any of the fullLakes then you can immediately return `[]`\\n*  Otherwise, store the current lake to the `ans` and remove the lake from `emptyLakes` since its no more empty.\\n*  Update the `fullLakes` with the current lake and index\\n\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int length  = rains.length;\\n        int[] ans = new int[length];\\n        Arrays.fill(ans, 1);\\n        \\n        TreeSet<Integer> emptyLakes  = new TreeSet<>();\\n        Map<Integer,Integer> fullLakes  = new HashMap<>();\\n        for (int i = 0;i<length;i++){\\n            int lake = rains[i];\\n            \\n            if (lake > 0){       \\n                ans[i] = -1;\\n                \\n                if (fullLakes.containsKey(lake)){\\n                    Integer emptyDay = emptyLakes.higher(fullLakes.get(lake));\\n                    if (emptyDay == null)\\n                        return new int[0];\\n                    \\n                    ans[emptyDay] = lake;\\n                    emptyLakes.remove(emptyDay);\\n                }\\n                \\n                fullLakes.put(lake, i);\\n            }\\n            else{\\n                emptyLakes.add(i);\\n            }\\n            \\n        }\\n    \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int length  = rains.length;\\n        int[] ans = new int[length];\\n        Arrays.fill(ans, 1);\\n        \\n        TreeSet<Integer> emptyLakes  = new TreeSet<>();\\n        Map<Integer,Integer> fullLakes  = new HashMap<>();\\n        for (int i = 0;i<length;i++){\\n            int lake = rains[i];\\n            \\n            if (lake > 0){       \\n                ans[i] = -1;\\n                \\n                if (fullLakes.containsKey(lake)){\\n                    Integer emptyDay = emptyLakes.higher(fullLakes.get(lake));\\n                    if (emptyDay == null)\\n                        return new int[0];\\n                    \\n                    ans[emptyDay] = lake;\\n                    emptyLakes.remove(emptyDay);\\n                }\\n                \\n                fullLakes.put(lake, i);\\n            }\\n            else{\\n                emptyLakes.add(i);\\n            }\\n            \\n        }\\n    \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894824,
                "title": "ruby-584ms-100-runtime-w-comments-dry-queue-and-binary-search",
                "content": "```\\n# @param {Integer[]} rains\\n# @return {Integer[]}\\ndef avoid_flood(rains)\\n  last_flood = {} # key - lake ID, value - last time when it was flooded\\n  dry_queue = [] # list of days when we can dry lakes\\n  \\n  days = [] # result\\n  \\n  rains.each_with_index do |lake, day|\\n    if lake > 0 # if it is raining on that date\\n      if last_flood.key?(lake) # if the lake is already full\\n        return [] if dry_queue.empty? # if there are no days when we can dry out the lake, then flooding is inavoidable\\n        \\n\\t\\t# we need to pick a good day to dry out our lake among all available\\n\\t\\t# it is the very first day after the last time this lake was last flooded\\n\\t\\t# e.g. if the lake was flooded last time on day 30, then let\\'s find the earliest possible day after day 30, which is still available\\n\\t\\t# since we know that the array is in ascending order, we can use binary search to achieve O(log N) here\\n        day_to_dry_index = dry_queue.bsearch_index {|x| x > last_flood[lake]}\\n        \\n\\t\\t# if we couldn\\'t find a good day, then it means that even though we have a pool of days when we can dry out lakes\\n\\t\\t# all dry days happened before the last time the current lake was flooded, so there is nothing we can do\\n        return [] unless day_to_dry_index\\n        \\n\\t\\t# great, we found a good day, let\\'s backdate drying the lake on day day_to_dry and remove it from the queue\\n        day_to_dry = dry_queue[day_to_dry_index]\\n        dry_queue.delete_at(day_to_dry_index)\\n        days[day_to_dry] = lake\\n      end\\n      \\n\\t  # today, we cannot do anything, because the lake has flooded, just add -1 to the answer and update the last time the lake was flooded\\n      last_flood[lake] = day\\n      days << -1\\n    else # if it is a dry day\\n      dry_queue << day # add it to the drying queue\\n      days << 1 # add \"1\" to the answer. it will be backdated and updated later. if we don\\'t need this drying day, then it will be just 1, which is OK\\n    end\\n  end\\n  \\n  days\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} rains\\n# @return {Integer[]}\\ndef avoid_flood(rains)\\n  last_flood = {} # key - lake ID, value - last time when it was flooded\\n  dry_queue = [] # list of days when we can dry lakes\\n  \\n  days = [] # result\\n  \\n  rains.each_with_index do |lake, day|\\n    if lake > 0 # if it is raining on that date\\n      if last_flood.key?(lake) # if the lake is already full\\n        return [] if dry_queue.empty? # if there are no days when we can dry out the lake, then flooding is inavoidable\\n        \\n\\t\\t# we need to pick a good day to dry out our lake among all available\\n\\t\\t# it is the very first day after the last time this lake was last flooded\\n\\t\\t# e.g. if the lake was flooded last time on day 30, then let\\'s find the earliest possible day after day 30, which is still available\\n\\t\\t# since we know that the array is in ascending order, we can use binary search to achieve O(log N) here\\n        day_to_dry_index = dry_queue.bsearch_index {|x| x > last_flood[lake]}\\n        \\n\\t\\t# if we couldn\\'t find a good day, then it means that even though we have a pool of days when we can dry out lakes\\n\\t\\t# all dry days happened before the last time the current lake was flooded, so there is nothing we can do\\n        return [] unless day_to_dry_index\\n        \\n\\t\\t# great, we found a good day, let\\'s backdate drying the lake on day day_to_dry and remove it from the queue\\n        day_to_dry = dry_queue[day_to_dry_index]\\n        dry_queue.delete_at(day_to_dry_index)\\n        days[day_to_dry] = lake\\n      end\\n      \\n\\t  # today, we cannot do anything, because the lake has flooded, just add -1 to the answer and update the last time the lake was flooded\\n      last_flood[lake] = day\\n      days << -1\\n    else # if it is a dry day\\n      dry_queue << day # add it to the drying queue\\n      days << 1 # add \"1\" to the answer. it will be backdated and updated later. if we don\\'t need this drying day, then it will be just 1, which is OK\\n    end\\n  end\\n  \\n  days\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 863143,
                "title": "upper-bound-set-explained-c",
                "content": "class Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n      \\n      int n=rains.size();\\n      vector<int> res(n,1);\\n      \\n      set<int> dry_day;// to store index where drying of lake can take plase..\\n      \\n      unordered_map<int,int> memo;//to store the lake which are filled till now..\\n      unordered_map<int,int> previous_index;//to store the last index of filled lake  \\n      \\n      for(int i=0;i<n;i++)\\n      {\\n        int lake=rains[i];\\n        \\n        \\n        if(lake==0)\\n        {\\n          \\n          dry_day.insert(i);//if its a dry _day store this indeex in set dry_day.\\n        }\\n        else if(memo[lake]==0)\\n        {\\n          memo[lake]=1;      // mark the  current lake as filled ans update res[i]=-1 as given in question...\\n          res[i]=-1;\\n          previous_index[lake]=i;//also store previous index[lake]=i,as when we will get same lake again in fill state we can get this index..\\n        }\\n        \\n        else\\n        {\\n           auto it=dry_day.upper_bound(previous_index[lake]);//we found a lake to be filled which is already filled search the index just greter than previous index where this lake was filled..this is optimal because if we use other day which is a dryring day then it may cause mismanagement of drying day and flood may occur\\n          \\n          if(it==dry_day.end()) return {};//if no such index is found\\n          \\n         //int  index=it-dry_day.begin();\\n          res[*it]=lake;// so index *it is the day when we used to empty lake which we dealing now..\\n          //memo[lake]=1;\\n          dry_day.erase(it);//since this dryring is used day removed it (removal in set takes less time as in vector)...\\n          res[i]=-1;\\n          previous_index[lake]=i;\\n        }\\n        \\n      }\\n      \\n      return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n      \\n      int n=rains.size();\\n      vector<int> res(n,1);\\n      \\n      set<int> dry_day;// to store index where drying of lake can take plase..\\n      \\n      unordered_map<int,int> memo;//to store the lake which are filled till now..\\n      unordered_map<int,int> previous_index;//to store the last index of filled lake  \\n      \\n      for(int i=0;i<n;i++)\\n      {\\n        int lake=rains[i];\\n        \\n        \\n        if(lake==0)\\n        {\\n          \\n          dry_day.insert(i);//if its a dry _day store this indeex in set dry_day.\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 861086,
                "title": "python-93-75",
                "content": "Using bisect_right\\n```\\nclass Solution(object):\\n    def avoidFlood(self, rains):\\n        \"\"\"\\n        :type rains: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        q=[] # list for zeros positions\\n        ans=[]\\n        hashmap={}\\n        for i in range(len(rains)):\\n            if rains[i] == 0:\\n                q.append(i)\\n                ans.append(1)  # as per example 4\\n            else:\\n                if rains[i] in hashmap:    \\n                    if len(q) == 0:\\n                        ans=[]\\n                        break\\n                    else:\\n                        index = hashmap[rains[i]]\\n                        # find a zero position just greater than previous occurrence of rains[i]\\n                        pos=bisect.bisect_right(q, index) \\n                        if pos<len(q): # no zero exists in between occurrence\\n                            ans[q[pos]]=rains[i]\\n                            q.pop(pos)\\n                        else:\\n                            ans=[]\\n                            break\\n                hashmap[rains[i]]=i\\n                ans.append(-1)  \\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def avoidFlood(self, rains):\\n        \"\"\"\\n        :type rains: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        q=[] # list for zeros positions\\n        ans=[]\\n        hashmap={}\\n        for i in range(len(rains)):\\n            if rains[i] == 0:\\n                q.append(i)\\n                ans.append(1)  # as per example 4\\n            else:\\n                if rains[i] in hashmap:    \\n                    if len(q) == 0:\\n                        ans=[]\\n                        break\\n                    else:\\n                        index = hashmap[rains[i]]\\n                        # find a zero position just greater than previous occurrence of rains[i]\\n                        pos=bisect.bisect_right(q, index) \\n                        if pos<len(q): # no zero exists in between occurrence\\n                            ans[q[pos]]=rains[i]\\n                            q.pop(pos)\\n                        else:\\n                            ans=[]\\n                            break\\n                hashmap[rains[i]]=i\\n                ans.append(-1)  \\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852421,
                "title": "c-solution-use-2-maps-to-solve-the-problem",
                "content": "Use 2 maps: nextDayHappen & lastDayHappen\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        map<int, int> nextDayHappen;\\n        map<int, int> lastDayHappen;\\n        for(int i = 0; i < rains.size(); i++){\\n            if(rains[i] > 0){\\n                if(lastDayHappen[rains[i]]){\\n                    nextDayHappen[lastDayHappen[rains[i]]] = i + 1;\\n                }\\n                lastDayHappen[rains[i]] = i + 1; // The day number begins from 1.    \\n            }\\n        }\\n        priority_queue<int, vector<int>, greater<int> > emergencyQue;\\n        map<int, int> currWater;\\n        vector<int> res;\\n        for(int i = 0; i < rains.size(); i++){\\n            if(rains[i] > 0){\\n                if(currWater[rains[i]]){\\n                    // we fail\\n                    return vector<int>();\\n                }\\n                currWater[rains[i]]++;\\n                res.push_back(-1);\\n                if(nextDayHappen[i + 1])\\n                    emergencyQue.push(nextDayHappen[i + 1]);\\n            }else{\\n                if(emergencyQue.size()){\\n                    res.push_back(rains[emergencyQue.top() - 1]);\\n                    currWater[rains[emergencyQue.top() - 1]] = 0;\\n                    emergencyQue.pop();\\n                }else{\\n                    res.push_back(1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        map<int, int> nextDayHappen;\\n        map<int, int> lastDayHappen;\\n        for(int i = 0; i < rains.size(); i++){\\n            if(rains[i] > 0){\\n                if(lastDayHappen[rains[i]]){\\n                    nextDayHappen[lastDayHappen[rains[i]]] = i + 1;\\n                }\\n                lastDayHappen[rains[i]] = i + 1; // The day number begins from 1.    \\n            }\\n        }\\n        priority_queue<int, vector<int>, greater<int> > emergencyQue;\\n        map<int, int> currWater;\\n        vector<int> res;\\n        for(int i = 0; i < rains.size(); i++){\\n            if(rains[i] > 0){\\n                if(currWater[rains[i]]){\\n                    // we fail\\n                    return vector<int>();\\n                }\\n                currWater[rains[i]]++;\\n                res.push_back(-1);\\n                if(nextDayHappen[i + 1])\\n                    emergencyQue.push(nextDayHappen[i + 1]);\\n            }else{\\n                if(emergencyQue.size()){\\n                    res.push_back(rains[emergencyQue.top() - 1]);\\n                    currWater[rains[emergencyQue.top() - 1]] = 0;\\n                    emergencyQue.pop();\\n                }else{\\n                    res.push_back(1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832032,
                "title": "python-time-limit-exceeded",
                "content": "Attempted to solve this without using anything \"exotic\" (heaps, queues, bisect), I think this solution is O(n^2) time complexity in the absolute worst case.\\n\\nPerhaps my analysis is wrong?\\n\\nIt is rather frustrating that this times out. I paid for the \"Pro\" service, I would expect to be able to allow me to complute my inefficient code.\\n\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n\\n        answer = []\\n        if len(rains) == 0:\\n            return []\\n        full = set()\\n        lakes = defaultdict(lambda: [])\\n        \\n        for i, lake in enumerate(rains):\\n            lakes[lake].append(i)\\n        \\n        for i, lake in enumerate(rains):\\n            if lake:\\n                if lake in full:\\n                    return []\\n                else:\\n                    full.add(lake)\\n                    answer.append(-1)\\n            else:\\n                next_flood = []\\n                if len(full) == 0:\\n                    answer.append(1)\\n                    continue\\n                for f in full:\\n                    next_flood += [x for x in lakes[f] if x > i]\\n                \\n                drain = -1\\n                if len(next_flood) > 0:\\n                    drain = rains[min(next_flood)]\\n                    full.remove(drain)\\n                else:\\n                    drain = full.pop()\\n                    \\n                answer.append(drain)\\n        \\n        return answer\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n\\n        answer = []\\n        if len(rains) == 0:\\n            return []\\n        full = set()\\n        lakes = defaultdict(lambda: [])\\n        \\n        for i, lake in enumerate(rains):\\n            lakes[lake].append(i)\\n        \\n        for i, lake in enumerate(rains):\\n            if lake:\\n                if lake in full:\\n                    return []\\n                else:\\n                    full.add(lake)\\n                    answer.append(-1)\\n            else:\\n                next_flood = []\\n                if len(full) == 0:\\n                    answer.append(1)\\n                    continue\\n                for f in full:\\n                    next_flood += [x for x in lakes[f] if x > i]\\n                \\n                drain = -1\\n                if len(next_flood) > 0:\\n                    drain = rains[min(next_flood)]\\n                    full.remove(drain)\\n                else:\\n                    drain = full.pop()\\n                    \\n                answer.append(drain)\\n        \\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803488,
                "title": "golang-binary-search",
                "content": "```go\\nfunc avoidFlood(rains []int) []int {\\n\\tavoid := make([]int, len(rains))\\n\\tlast := map[int]int{}\\n\\tvalid := make([]int, 0)\\n\\tfor i, v := range rains {\\n\\t\\tif v > 0 {\\n\\t\\t\\tavoid[i] = -1\\n\\t\\t\\tif _, exist := last[v]; exist {\\n\\t\\t\\t\\tif index := binarySearch(valid, last[v]); index < len(valid) {\\n\\t\\t\\t\\t\\tavoid[valid[index]] = v\\n\\t\\t\\t\\t\\tcopy(valid[index:], valid[index+1:])\\n\\t\\t\\t\\t\\tvalid = valid[:len(valid)-1]\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn []int{}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlast[v] = i\\n\\t\\t} else {\\n\\t\\t\\tvalid = append(valid, i)\\n\\t\\t}\\n\\t}\\n\\tfor i, v := range avoid {\\n\\t\\tif v == 0 {\\n\\t\\t\\tavoid[i] = 1\\n\\t\\t}\\n\\t}\\n\\treturn avoid\\n}\\n\\nfunc binarySearch(array []int, value int) int {\\n\\tl, r := 0, len(array)-1\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tif array[m] < value {\\n\\t\\t\\tl = m+1\\n\\t\\t} else {\\n\\t\\t\\tr = m-1\\n\\t\\t}\\n\\t}\\n\\treturn l\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```go\\nfunc avoidFlood(rains []int) []int {\\n\\tavoid := make([]int, len(rains))\\n\\tlast := map[int]int{}\\n\\tvalid := make([]int, 0)\\n\\tfor i, v := range rains {\\n\\t\\tif v > 0 {\\n\\t\\t\\tavoid[i] = -1\\n\\t\\t\\tif _, exist := last[v]; exist {\\n\\t\\t\\t\\tif index := binarySearch(valid, last[v]); index < len(valid) {\\n\\t\\t\\t\\t\\tavoid[valid[index]] = v\\n\\t\\t\\t\\t\\tcopy(valid[index:], valid[index+1:])\\n\\t\\t\\t\\t\\tvalid = valid[:len(valid)-1]\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn []int{}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlast[v] = i\\n\\t\\t} else {\\n\\t\\t\\tvalid = append(valid, i)\\n\\t\\t}\\n\\t}\\n\\tfor i, v := range avoid {\\n\\t\\tif v == 0 {\\n\\t\\t\\tavoid[i] = 1\\n\\t\\t}\\n\\t}\\n\\treturn avoid\\n}\\n\\nfunc binarySearch(array []int, value int) int {\\n\\tl, r := 0, len(array)-1\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tif array[m] < value {\\n\\t\\t\\tl = m+1\\n\\t\\t} else {\\n\\t\\t\\tr = m-1\\n\\t\\t}\\n\\t}\\n\\treturn l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 734503,
                "title": "mathematical-use-of-max-heap-o-nlogn-o-n-space-speed-88-and-memory-100",
                "content": "So, maintain the minheap of next day for each day, same lake to be flooded. If the same lake is not going to be filled again, put next of that day as n(length of rains) (case of no flood). Put this in the minheap and on a dry day(no pun inteded), pop the lake from heap which will be filled again first.\\n\\n```\\ndef avoidFlood(self, rains: List[int]) -> List[int]:\\n## this is the minheap\\n        arr = []\\n##this map contains if an element is already filled\\n        arrlis = {}\\n##output arr\\n        op = []\\n##next time rain willl happen over ith lake\\n        nxt = {}\\n\\t\\t\\n        for x in range(len(rains)):\\n            i = rains[x]\\n            if i in arrlis:\\n                nxt[arrlis[i]] = x\\n            arrlis[i] = x\\n            \\n        arrlis = {}\\n            \\n        for x in range(len(rains)):\\n            i = rains[x]\\n            if i > 0:\\n                if i in arrlis:\\n                    return []\\n                nx = len(rains)\\n                if x in nxt:\\n                    nx = nxt[x]\\n                heapq.heappush(arr, (nx , i))\\n                arrlis[i] = x\\n                op.append(-1)\\n            else:\\n                if len(arr) > 0:\\n                    op.append(heapq.heappop(arr)[1])\\n                    del arrlis[op[-1]]\\n                else:\\n                    op.append(5)\\n                    if 5 in arrlis:\\n                        del arrlis[5]\\n                    \\n        return op\\n```",
                "solutionTags": [],
                "code": "```\\ndef avoidFlood(self, rains: List[int]) -> List[int]:\\n## this is the minheap\\n        arr = []\\n##this map contains if an element is already filled\\n        arrlis = {}\\n##output arr\\n        op = []\\n##next time rain willl happen over ith lake\\n        nxt = {}\\n\\t\\t\\n        for x in range(len(rains)):\\n            i = rains[x]\\n            if i in arrlis:\\n                nxt[arrlis[i]] = x\\n            arrlis[i] = x\\n            \\n        arrlis = {}\\n            \\n        for x in range(len(rains)):\\n            i = rains[x]\\n            if i > 0:\\n                if i in arrlis:\\n                    return []\\n                nx = len(rains)\\n                if x in nxt:\\n                    nx = nxt[x]\\n                heapq.heappush(arr, (nx , i))\\n                arrlis[i] = x\\n                op.append(-1)\\n            else:\\n                if len(arr) > 0:\\n                    op.append(heapq.heappop(arr)[1])\\n                    del arrlis[op[-1]]\\n                else:\\n                    op.append(5)\\n                    if 5 in arrlis:\\n                        del arrlis[5]\\n                    \\n        return op\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 706448,
                "title": "python-greedy-backtracking-one-pass-o-n",
                "content": "```python\\ndef avoidFlood(self, rains):\\n    full = {}                                       # hashtable of challenges to cause flood\\n\\t\\n\\tdry = []                                        # array of opportunities to avoid flood\\n\\t                                                # note: sortable C++ set or Java TreeSet superior to array in use\\n\\t\\n    for day, lake in enumerate(rains):              # one-pass iteration\\n\\t                                                # outer O(N)\\n        if not lake:\\n            dry.append(day)                         # store indeterminate opportunity in ascending order\\n\\t\\t\\t\\n            rains[day] = 1                          # stationary trial\\n            continue\\n        if lake in full:                            # optimal opportunity consumption \\n\\t\\t                                            # against determinate challenge to cause flood\\n\\t\\t\\n            i = bisect.bisect_left(dry, full[lake]) # optimal greedy search\\n\\t\\t\\t                                        # inner O(log(N)) from binary search on array\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# note: O(log(N)) as well in case of C++ set or Java TreeSet \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n            if i == len(dry): return []             # flood unavoidable result\\n\\t\\t\\t\\n            rains[dry.pop(i)] = lake                # backtracking to reconciliation\\n\\t\\t\\t                                        # inner O(N) due to removal of array element\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# note: O(1) in case of C++ set or Java TreeSet \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n        full[lake] = day                            # store indeterminate challenge for later lookup\\n\\t\\t\\n        rains[day] = -1                             # stationary result\\n\\t\\t\\n    return rains                                    # flood avoidable result\\n```",
                "solutionTags": [],
                "code": "```python\\ndef avoidFlood(self, rains):\\n    full = {}                                       # hashtable of challenges to cause flood\\n\\t\\n\\tdry = []                                        # array of opportunities to avoid flood\\n\\t                                                # note: sortable C++ set or Java TreeSet superior to array in use\\n\\t\\n    for day, lake in enumerate(rains):              # one-pass iteration\\n\\t                                                # outer O(N)\\n        if not lake:\\n            dry.append(day)                         # store indeterminate opportunity in ascending order\\n\\t\\t\\t\\n            rains[day] = 1                          # stationary trial\\n            continue\\n        if lake in full:                            # optimal opportunity consumption \\n\\t\\t                                            # against determinate challenge to cause flood\\n\\t\\t\\n            i = bisect.bisect_left(dry, full[lake]) # optimal greedy search\\n\\t\\t\\t                                        # inner O(log(N)) from binary search on array\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# note: O(log(N)) as well in case of C++ set or Java TreeSet \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n            if i == len(dry): return []             # flood unavoidable result\\n\\t\\t\\t\\n            rains[dry.pop(i)] = lake                # backtracking to reconciliation\\n\\t\\t\\t                                        # inner O(N) due to removal of array element\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# note: O(1) in case of C++ set or Java TreeSet \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n        full[lake] = day                            # store indeterminate challenge for later lookup\\n\\t\\t\\n        rains[day] = -1                             # stationary result\\n\\t\\t\\n    return rains                                    # flood avoidable result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 705892,
                "title": "java-treeset-with-hashmap-solution",
                "content": "First, we create a HashMap to store the day to lake mapping `rains[i] -> i`, which means at day i, lake rains[i] is filled.\\n\\nThen, we maintain a sorted set of the dry days at which we could possibly dry lakes. \\n\\nThe rest works as greedy, or lazy load. If a lake is filled again at `day j`, we would search for the first day after its previous filling date `day i`, which is stored in the map.\\n\\nThe time complexity is O(n * log n), space complexity is O(n). TreeSet does the binary search for us so we can save some efforts.\\n\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int n = rains.length;\\n        int[] ans = new int[n];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> dryDays = new TreeSet<>();\\n        for (int i = 0; i < n; i++) {\\n            if (rains[i] == 0) {\\n                dryDays.add(i);\\n            } else {\\n                ans[i] = -1;\\n                if (map.containsKey(rains[i])) {\\n                    Integer index = dryDays.higher(map.get(rains[i]));\\n                    if (index == null) {\\n                        return new int[0];\\n                    }\\n                    ans[index] = rains[i];\\n                    dryDays.remove(index);\\n                }\\n                map.put(rains[i], i);\\n            }\\n        }\\n        for (int day : dryDays) {\\n            ans[day] = 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int n = rains.length;\\n        int[] ans = new int[n];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> dryDays = new TreeSet<>();\\n        for (int i = 0; i < n; i++) {\\n            if (rains[i] == 0) {\\n                dryDays.add(i);\\n            } else {\\n                ans[i] = -1;\\n                if (map.containsKey(rains[i])) {\\n                    Integer index = dryDays.higher(map.get(rains[i]));\\n                    if (index == null) {\\n                        return new int[0];\\n                    }\\n                    ans[index] = rains[i];\\n                    dryDays.remove(index);\\n                }\\n                map.put(rains[i], i);\\n            }\\n        }\\n        for (int day : dryDays) {\\n            ans[day] = 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705112,
                "title": "python-set-and-dictionary-commented",
                "content": "```\\ndef avoidFlood(self, rains: List[int]) -> List[int]:\\n        # We just need to know if there are zeros in between two lakes\\n        # so that it can be dries otherwise return []\\n        # O(N^2) is easy after we index the zeros and the lakes in a dic\\n        # Maybe use a heap for instead of the set to store the indices of\\n        # Storing the most information that we can is the key to solving the\\n        # question so that we can later use that situation.\\n        dic = {}\\n        set_ = set()\\n        ans = [-1 for _ in range(len(rains))]\\n        for i in range(len(rains)):\\n            if rains[i] == 0:\\n                set_.add(i)\\n            else:\\n                if rains[i] not in dic:\\n                    dic[rains[i]] = i\\n                    ans[i] = -1\\n                else:\\n                    # Need to find an empty spot for this lake that is \\n                    # after its index which was in the dictionary\\n                    index = dic[rains[i]]\\n                    flag = 0\\n                    for item in set_:\\n                        if item > index:\\n\\t\\t\\t\\t\\t\\t# dry this lake on this zero\\n                            ans[item] = rains[i]\\n\\t\\t\\t\\t\\t\\t# Update the location of this lake for future if it needs to be dried\\n                            dic[rains[i]] = i\\n\\t\\t\\t\\t\\t\\t# Can\\'t use this zero to dry up other lakes remove it.\\n                            set_.remove(item)\\n                            flag = 1\\n                            break\\n                            \\n                    if flag == 0:\\n                        # didn\\'t find and empty spot to empty this lake\\n                        return []\\n            # convert the extra zeros into 1\\'s we don\\'t need them for \\n            # drying up any lake\\n            if rains[i] == 0 and ans[i] == -1:\\n                ans[i] = 1\\n        return ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef avoidFlood(self, rains: List[int]) -> List[int]:\\n        # We just need to know if there are zeros in between two lakes\\n        # so that it can be dries otherwise return []\\n        # O(N^2) is easy after we index the zeros and the lakes in a dic\\n        # Maybe use a heap for instead of the set to store the indices of\\n        # Storing the most information that we can is the key to solving the\\n        # question so that we can later use that situation.\\n        dic = {}\\n        set_ = set()\\n        ans = [-1 for _ in range(len(rains))]\\n        for i in range(len(rains)):\\n            if rains[i] == 0:\\n                set_.add(i)\\n            else:\\n                if rains[i] not in dic:\\n                    dic[rains[i]] = i\\n                    ans[i] = -1\\n                else:\\n                    # Need to find an empty spot for this lake that is \\n                    # after its index which was in the dictionary\\n                    index = dic[rains[i]]\\n                    flag = 0\\n                    for item in set_:\\n                        if item > index:\\n\\t\\t\\t\\t\\t\\t# dry this lake on this zero\\n                            ans[item] = rains[i]\\n\\t\\t\\t\\t\\t\\t# Update the location of this lake for future if it needs to be dried\\n                            dic[rains[i]] = i\\n\\t\\t\\t\\t\\t\\t# Can\\'t use this zero to dry up other lakes remove it.\\n                            set_.remove(item)\\n                            flag = 1\\n                            break\\n                            \\n                    if flag == 0:\\n                        # didn\\'t find and empty spot to empty this lake\\n                        return []\\n            # convert the extra zeros into 1\\'s we don\\'t need them for \\n            # drying up any lake\\n            if rains[i] == 0 and ans[i] == -1:\\n                ans[i] = 1\\n        return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 702356,
                "title": "runtime-89-memory-100",
                "content": "\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        full = {}\\n        ans = [-1]*len(rains)\\n        zeros = []\\n        \\n        for index, rain in enumerate(rains):\\n            p = 0\\n            if rain == 0 :\\n                zeros.append(index)\\n                continue\\n            if rain not in full :\\n                full[rain] = index\\n            else:\\n                if len(zeros) == 0:\\n                    return []\\n                else:\\n                    for x in zeros:\\n                        if x > full[rain] and x < index:\\n                            ans[x] = rain\\n                            zeros.remove(x)\\n                            full[rain] = index\\n                            p = 1\\n                            break\\n                    if p == 0:\\n                        return []\\n                        \\n        for x in zeros:\\n            ans[x] = 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        full = {}\\n        ans = [-1]*len(rains)\\n        zeros = []\\n        \\n        for index, rain in enumerate(rains):\\n            p = 0\\n            if rain == 0 :\\n                zeros.append(index)\\n                continue\\n            if rain not in full :\\n                full[rain] = index\\n            else:\\n                if len(zeros) == 0:\\n                    return []\\n                else:\\n                    for x in zeros:\\n                        if x > full[rain] and x < index:\\n                            ans[x] = rain\\n                            zeros.remove(x)\\n                            full[rain] = index\\n                            p = 1\\n                            break\\n                    if p == 0:\\n                        return []\\n                        \\n        for x in zeros:\\n            ans[x] = 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701230,
                "title": "python-o-nlogn-using-heap",
                "content": "Fill the 0s from left to right. For each 0, it can only be filled from values to the left nonzero values. For each of the non-zero values to the left of current 0 use heap to maintain the next occurrence of the same value (greedily pick the next earliest occurrence). If the next occurrence occurs before the current 0 position then we cannot avoid a flood else we fill the zero with the value.\\n\\n```\\nclass Solution(object):\\n    def avoidFlood(self, rains):\\n        positions = {}\\n        \\n        for i in range(len(rains)):\\n            if rains[i] not in positions:\\n                positions[rains[i]] = collections.deque([])\\n            positions[rains[i]].append(i)\\n            \\n        heap, out = [], [-1]*len(rains)\\n        \\n        for i in range(len(rains)):\\n            if rains[i] == 0:\\n                if len(heap) > 0:\\n                    x, y = heapq.heappop(heap)\\n                    if x > i:\\n                        out[i] = y\\n                    else:\\n                        return []\\n            else:\\n                if len(positions[rains[i]]) > 1:\\n                    positions[rains[i]].popleft()\\n                    j = positions[rains[i]][0]\\n                    heapq.heappush(heap, (j, rains[i]))\\n                    \\n        if len(heap) > 0:\\n            return []\\n        \\n        for i in range(len(out)):\\n            if rains[i] == 0 and out[i] == -1:\\n                out[i] = 1\\n                \\n        return out",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def avoidFlood(self, rains):\\n        positions = {}",
                "codeTag": "Java"
            },
            {
                "id": 700149,
                "title": "python-solution-with-bisect",
                "content": "Here is my Python solution. I know that it is O(N^2) because of the last ```dry.pop(idx)``` but it is fast enough to pass the LC tests.\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        full = dict() # store the last day a lake was filled with water\\n        i = 0\\n        dry = [] # array with dry days where we will search when needed\\n        res = [-1 for _ in range(len(rains))]\\n        for i in range(len(rains)):\\n            if rains[i] == 0:\\n                dry.append(i)\\n                continue\\n            if not rains[i] in full:\\n                full[rains[i]] = i\\n                continue\\n            # search a dry day after the last day the lake was filled with water\\n            idx = bisect_right(dry, full[rains[i]])\\n            if idx == len(dry):\\n                # we didn\\'t find a good day\\n                return []\\n            res[dry[idx]] = rains[i]\\n            full[rains[i]] = i\\n            dry.pop(idx)\\n        for x in dry:\\n            res[x] = 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```dry.pop(idx)```\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        full = dict() # store the last day a lake was filled with water\\n        i = 0\\n        dry = [] # array with dry days where we will search when needed\\n        res = [-1 for _ in range(len(rains))]\\n        for i in range(len(rains)):\\n            if rains[i] == 0:\\n                dry.append(i)\\n                continue\\n            if not rains[i] in full:\\n                full[rains[i]] = i\\n                continue\\n            # search a dry day after the last day the lake was filled with water\\n            idx = bisect_right(dry, full[rains[i]])\\n            if idx == len(dry):\\n                # we didn\\'t find a good day\\n                return []\\n            res[dry[idx]] = rains[i]\\n            full[rains[i]] = i\\n            dry.pop(idx)\\n        for x in dry:\\n            res[x] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699462,
                "title": "scala-o-n-lg-n",
                "content": "```\\nimport scala.collection.mutable\\n\\nobject Solution {\\n  def avoidFlood(rains: Array[Int]): Array[Int] = {\\n    // lakeToDayToNextDay(lake)(day) = the next day on which it rains on lake\\n    val lakeToDayToNextDay = rains\\n      .zipWithIndex\\n      .filter(_._1 > 0)\\n      .groupMap(_._1)(_._2)\\n      .view\\n      .mapValues(days => days.zip(days.tail).toMap)\\n      .toMap\\n    // (lake, nextDay) ordered by increasing nextDay\\n    val lakeAndDayPairs = mutable.PriorityQueue()(Ordering.by[(Int, Int), Int](_._2).reverse)\\n    // The set of lakes that are currently full.\\n    val fullLakes = mutable.Set[Int]()\\n    // The plan for drying the lakes.\\n    val plan = Array.fill(rains.length)(-1)\\n    for (day <- rains.indices) {\\n      rains(day) match {\\n        // All lakes are dry.  Any lake is acceptable.\\n        case 0 if fullLakes.isEmpty =>\\n          plan(day) = 1\\n        // Dry the full lake that will flood the soonest.\\n        case 0 =>\\n          val lake = lakeAndDayPairs.dequeue._1\\n          fullLakes -= lake\\n          plan(day) = lake\\n        // Impossible to prevent flooding.\\n        case lake if fullLakes.contains(lake) =>\\n          return Array[Int]()\\n        // Denote the lake as full, and mark the soonest day it will flood.\\n        case lake =>\\n          for (nextDay <- lakeToDayToNextDay(lake).get(day)) lakeAndDayPairs.enqueue(lake -> nextDay)\\n          fullLakes += lake\\n      }\\n    }\\n    plan\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport scala.collection.mutable\\n\\nobject Solution {\\n  def avoidFlood(rains: Array[Int]): Array[Int] = {\\n    // lakeToDayToNextDay(lake)(day) = the next day on which it rains on lake\\n    val lakeToDayToNextDay = rains\\n      .zipWithIndex\\n      .filter(_._1 > 0)\\n      .groupMap(_._1)(_._2)\\n      .view\\n      .mapValues(days => days.zip(days.tail).toMap)\\n      .toMap\\n    // (lake, nextDay) ordered by increasing nextDay\\n    val lakeAndDayPairs = mutable.PriorityQueue()(Ordering.by[(Int, Int), Int](_._2).reverse)\\n    // The set of lakes that are currently full.\\n    val fullLakes = mutable.Set[Int]()\\n    // The plan for drying the lakes.\\n    val plan = Array.fill(rains.length)(-1)\\n    for (day <- rains.indices) {\\n      rains(day) match {\\n        // All lakes are dry.  Any lake is acceptable.\\n        case 0 if fullLakes.isEmpty =>\\n          plan(day) = 1\\n        // Dry the full lake that will flood the soonest.\\n        case 0 =>\\n          val lake = lakeAndDayPairs.dequeue._1\\n          fullLakes -= lake\\n          plan(day) = lake\\n        // Impossible to prevent flooding.\\n        case lake if fullLakes.contains(lake) =>\\n          return Array[Int]()\\n        // Denote the lake as full, and mark the soonest day it will flood.\\n        case lake =>\\n          for (nextDay <- lakeToDayToNextDay(lake).get(day)) lakeAndDayPairs.enqueue(lake -> nextDay)\\n          fullLakes += lake\\n      }\\n    }\\n    plan\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 699401,
                "title": "c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int[] AvoidFlood(int[] rains) \\n    {\\n        var zeros = new List<int>();\\n        var prev = new Dictionary<int, int>();\\n        var result = Enumerable.Repeat(-1, rains.Length).ToArray();\\n        \\n        for(int i = 0; i < rains.Length; i++)\\n        {\\n            var lake = rains[i];\\n            if(rains[i] == 0)\\n            {\\n                zeros.Add(i);\\n                result[i] = 1;\\n            }\\n            else\\n            {\\n                if(!prev.ContainsKey(lake))\\n                    prev[lake] = i;\\n                else\\n                {\\n                    var prevIndex =  prev[lake];\\n                    var index = zeros.BinarySearch(prevIndex + 1);\\n                    if(index < 0)\\n                        index = ~index;\\n                    if(index == zeros.Count)\\n                        return new int[0];\\n                    prev[lake] = i;\\n                    result[zeros[index]] = lake;\\n                    zeros.RemoveAt(index);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int[] AvoidFlood(int[] rains) \\n    {\\n        var zeros = new List<int>();\\n        var prev = new Dictionary<int, int>();\\n        var result = Enumerable.Repeat(-1, rains.Length).ToArray();\\n        \\n        for(int i = 0; i < rains.Length; i++)\\n        {\\n            var lake = rains[i];\\n            if(rains[i] == 0)\\n            {\\n                zeros.Add(i);\\n                result[i] = 1;\\n            }\\n            else\\n            {\\n                if(!prev.ContainsKey(lake))\\n                    prev[lake] = i;\\n                else\\n                {\\n                    var prevIndex =  prev[lake];\\n                    var index = zeros.BinarySearch(prevIndex + 1);\\n                    if(index < 0)\\n                        index = ~index;\\n                    if(index == zeros.Count)\\n                        return new int[0];\\n                    prev[lake] = i;\\n                    result[zeros[index]] = lake;\\n                    zeros.RemoveAt(index);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698703,
                "title": "python-heap-solution-with-detail-explaination",
                "content": "This problem seems pretty complex, however when we divide them into small cases it will become much clearer.\\n\\n- When raining\\n    - Need to check if there is flood, so we need a `full` set to store all full lakes.\\n    - The `ans` must append with -1.\\n- When not raining\\n    - Now we can dry full lake. How? \\n    - We have to need a `dry` to store the dry plan for lakes. How to make the dry plan?\\n    - It\\'s actually a greedy algorithm: **dry the full lake with earliest next rain first**. Thus the `dry` should be a\\n     `Heap` so that the first one is always the earliest.\\n    - If we don\\'t have a dry plan, then `ans` can append whatever.\\n    \\nBack to the first, we need an extra `lakes`(`dict[deque]`) to store the rain order for each lake. When it rains to a\\n lake, we need to check if there\\'s next rain for it, so that store the next rain date(index) to `dry`.\\n\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        \\n        ans = []\\n        # full stores current full lakes\\n        full = set()\\n        # dry stores dry plan for full lakes, the first is the earliest upcomming rain\\n        dry = []\\n        # for each lake, stores rain deque for it\\n        lakes = collections.defaultdict(collections.deque)       \\n        for i, lake in enumerate(rains):\\n            lakes[lake].append(i)\\n        \\n        for lake in rains:\\n            if lake:\\n                # If lake is already full, then it will be a flood\\n                if lake in full: return []\\n                else:\\n                    full.add(lake)\\n                    ans.append(-1)\\n                    lakes[lake].popleft()\\n                    # If there are more rains for this lake later, store the next rains idx into dry\\n                    # dry is Heap so that the first one is always the smallest idx (earlist rain)\\n                    if lakes[lake]:\\n                        heapq.heappush(dry, lakes[lake][0])\\n            else:\\n                if dry: \\n                    next_dry = rains[heapq.heappop(dry)]\\n                    ans.append(next_dry)\\n                    full.remove(next_dry)\\n                else:\\n                    ans.append(1)\\n                    \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        \\n        ans = []\\n        # full stores current full lakes\\n        full = set()\\n        # dry stores dry plan for full lakes, the first is the earliest upcomming rain\\n        dry = []\\n        # for each lake, stores rain deque for it\\n        lakes = collections.defaultdict(collections.deque)       \\n        for i, lake in enumerate(rains):\\n            lakes[lake].append(i)\\n        \\n        for lake in rains:\\n            if lake:\\n                # If lake is already full, then it will be a flood\\n                if lake in full: return []\\n                else:\\n                    full.add(lake)\\n                    ans.append(-1)\\n                    lakes[lake].popleft()\\n                    # If there are more rains for this lake later, store the next rains idx into dry\\n                    # dry is Heap so that the first one is always the smallest idx (earlist rain)\\n                    if lakes[lake]:\\n                        heapq.heappush(dry, lakes[lake][0])\\n            else:\\n                if dry: \\n                    next_dry = rains[heapq.heappop(dry)]\\n                    ans.append(next_dry)\\n                    full.remove(next_dry)\\n                else:\\n                    ans.append(1)\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698663,
                "title": "go-greedy-solution",
                "content": "\\n\\n```\\nfunc avoidFlood(rains []int) []int {\\n    var zeros []int\\n    res := make([]int, len(rains))\\n    m := make(map[int]int)\\n    \\n    for i, r := range rains {        \\n        if r == 0 {\\n            zeros = append(zeros, i)\\n            continue\\n        }\\n        \\n        if _, ok := m[r]; ok {\\n            zi := -1\\n            \\n\\t\\t\\t// find the closest index of zeros that could dry the current fulled lake\\n\\t\\t\\t//  O(NlogN) if using binary search to find the closest index\\n            for ti, tzi := range zeros {\\n                if tzi > m[r] {\\n                    zi = tzi\\n                    zeros = append(zeros[:ti], zeros[ti+1:] ...)\\n                    break\\n                }\\n            }\\n            \\n            if zi == -1 {\\n                return []int{}\\n            }\\n            \\n            res[zi] = r\\n        } \\n        \\n        m[r] = i\\n        res[i] = -1\\n    }\\n    \\n\\t// fill the unused zeros index\\n    for i := range res {\\n        if res[i] == 0 {\\n            res[i] = 1\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc avoidFlood(rains []int) []int {\\n    var zeros []int\\n    res := make([]int, len(rains))\\n    m := make(map[int]int)\\n    \\n    for i, r := range rains {        \\n        if r == 0 {\\n            zeros = append(zeros, i)\\n            continue\\n        }\\n        \\n        if _, ok := m[r]; ok {\\n            zi := -1\\n            \\n\\t\\t\\t// find the closest index of zeros that could dry the current fulled lake\\n\\t\\t\\t//  O(NlogN) if using binary search to find the closest index\\n            for ti, tzi := range zeros {\\n                if tzi > m[r] {\\n                    zi = tzi\\n                    zeros = append(zeros[:ti], zeros[ti+1:] ...)\\n                    break\\n                }\\n            }\\n            \\n            if zi == -1 {\\n                return []int{}\\n            }\\n            \\n            res[zi] = r\\n        } \\n        \\n        m[r] = i\\n        res[i] = -1\\n    }\\n    \\n\\t// fill the unused zeros index\\n    for i := range res {\\n        if res[i] == 0 {\\n            res[i] = 1\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698477,
                "title": "swift-solution-with-explanation",
                "content": "```\\nfunc avoidFlood(_ rains: [Int]) -> [Int] {\\n    // Step 1 : Build an array with -1 as value for rainy days and 1 as value for dry days\\n    var res = Array(repeating: -1, count: rains.count)//Initialize the array of same size to -1\\n    var dict : [Int:Int] = [:] //Dictionary for each rainy day\\n    var ddays : [Int] = []//Array to store the dry days\\n\\t//Update dry days to 1\\n    for i in 0..<rains.count{\\n        if rains[i] == 0{\\n            res[i] = 1\\n        }\\n    }\\n    // Step 2: Create a flood and then go back and check if any dry days are present to prevent the flood\\n    for (i,n) in rains.enumerated(){\\n        if n == 0{\\n            ddays.append(i)//Append dry days\\n            continue\\n        }\\n        else{\\n\\t\\t//Dictionary entry\\n            if dict[n] == nil{\\n                dict[n] = i\\n            }\\n            else{\\n                //If there aren\\'t any dry days left and it rains, then this will result in a flood\\n                if ddays.count > 0{\\n                    var done = false\\n                    for (j,d) in ddays.enumerated(){\\n                        //Use the first value of dry day that satisfies the below condition as the dry day is always after the first rainfall and before the next(if flood needs to be prevented)\\n                        if d > dict[n]!{\\n                            let ind = ddays.remove(at: j)\\n                            res[ind] = n //Change the value of dry day at this index to the value of lake as it was previously initialised to 1\\n                            dict[n] = i //Update the index value of the dictionary to the present index as we are back here after preventing the flood\\n                            done = true\\n                            break\\n                        }\\n                    }\\n                    // If no value is found to satisfy the condition\\n                    if done == false{\\n                        res = []\\n                        break\\n                    }\\n                }\\n                else{\\n                    res = []\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc avoidFlood(_ rains: [Int]) -> [Int] {\\n    // Step 1 : Build an array with -1 as value for rainy days and 1 as value for dry days\\n    var res = Array(repeating: -1, count: rains.count)//Initialize the array of same size to -1\\n    var dict : [Int:Int] = [:] //Dictionary for each rainy day\\n    var ddays : [Int] = []//Array to store the dry days\\n\\t//Update dry days to 1\\n    for i in 0..<rains.count{\\n        if rains[i] == 0{\\n            res[i] = 1\\n        }\\n    }\\n    // Step 2: Create a flood and then go back and check if any dry days are present to prevent the flood\\n    for (i,n) in rains.enumerated(){\\n        if n == 0{\\n            ddays.append(i)//Append dry days\\n            continue\\n        }\\n        else{\\n\\t\\t//Dictionary entry\\n            if dict[n] == nil{\\n                dict[n] = i\\n            }\\n            else{\\n                //If there aren\\'t any dry days left and it rains, then this will result in a flood\\n                if ddays.count > 0{\\n                    var done = false\\n                    for (j,d) in ddays.enumerated(){\\n                        //Use the first value of dry day that satisfies the below condition as the dry day is always after the first rainfall and before the next(if flood needs to be prevented)\\n                        if d > dict[n]!{\\n                            let ind = ddays.remove(at: j)\\n                            res[ind] = n //Change the value of dry day at this index to the value of lake as it was previously initialised to 1\\n                            dict[n] = i //Update the index value of the dictionary to the present index as we are back here after preventing the flood\\n                            done = true\\n                            break\\n                        }\\n                    }\\n                    // If no value is found to satisfy the condition\\n                    if done == false{\\n                        res = []\\n                        break\\n                    }\\n                }\\n                else{\\n                    res = []\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698467,
                "title": "c-data-structure-binary-search-o-n-log-n",
                "content": "```\\n\\nclass Solution {\\npublic:\\n\\tvector<int> avoidFlood(vector<int>& rains) {\\n\\t\\tint n = rains.size();\\n\\n\\t\\tset<int> haveDays;\\n\\t\\tunordered_map<int, int> isFull;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint lake = rains[i];\\n\\t\\t\\trains[i] = -1;\\n\\t\\t\\t\\n\\t\\t\\tif (!lake) { // storing the pt which has no rain on that day \\n\\t\\t\\t\\thaveDays.insert(i);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (isFull.count(lake)) {  // finding the day on which this lake needs to be dried if already filled \\n\\t\\t\\t\\tauto it = haveDays.lower_bound(isFull[lake]);\\n\\t\\t\\t\\tif (it == haveDays.end()) return {};\\n\\t\\t\\t\\trains[*it] = lake;\\n\\t\\t\\t\\thaveDays.erase(it);\\n\\t\\t\\t}\\n\\t\\t\\tisFull[lake] = i;  // marking the last time this lake was filled\\n\\t\\t}\\n\\n\\t\\tfor (int &i : rains) if (!i) i = 1; // if still unused days left then marking them to drying some random lake (1 in my case)\\n\\t\\treturn rains;\\n\\t}\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\tvector<int> avoidFlood(vector<int>& rains) {\\n\\t\\tint n = rains.size();\\n\\n\\t\\tset<int> haveDays;\\n\\t\\tunordered_map<int, int> isFull;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint lake = rains[i];\\n\\t\\t\\trains[i] = -1;\\n\\t\\t\\t\\n\\t\\t\\tif (!lake) { // storing the pt which has no rain on that day \\n\\t\\t\\t\\thaveDays.insert(i);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 698036,
                "title": "i-wanted-to-do-it-without-a-map-or-tree-for-no-reason",
                "content": "It \"works\" i think? Atleast passes all test cases but doesnt actually submit due to not matching the test case, note the question does state \"If there are multiple valid answers return any of them.\"\\n```\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    // If it is impossible to avoid flood return an empty array.\\n    public int[] avoidFlood(int[] rains) {\\n        ArrayList<Integer> ar1 = new ArrayList<Integer>(); // tmp arr for ans\\n        int[] arr = new int[rains.length]; //ans arr\\n        int[] ept = new int[0];\\n        Arrays.sort(rains); // soo\\n        int counter =0;//tracks all 0\\'s\\n        int[] negcc = new int[rains.length]; // all -1 arr\\n\\n        for(int g = 0;g<rains.length;g++){\\n            negcc[g] = -1;\\n        }\\n\\n        if(rains[0] != 0){//does arr != contain 0 @ idx0\\n            for(int w9 = 0;w9<rains.length-1;w9++){\\n                if(rains[w9] == rains[w9+1]){//checks if has dupes+if cur # != \\n                    return ept;//return empty arr\\n                }\\n            }\\n            return negcc; //an all -1 array return\\n\\n\\n        for(int i = 0;i<rains.length-1;i++) {//has 0 arr case\\n            while (rains[i] == 0) {//is val 0?\\n                counter++;\\n                break;\\n            }\\n            if (rains[i] == rains[i + 1] && rains[i] != 0) { // does val hv dupe?YES val\\n                if (counter != 0) {\\n                    ar1.add(rains[i]);\\n                    counter--;\\n                }\\n                else if (counter == 0) {//if counter hits 0 then reutnr empy arr\\n                    return ept;\\n            }// need to down coutner by 1?\\n\\n            }\\n            else{\\n                ar1.add(-1);\\n            }\\n        }//add a case for all leftover counters at the end\\n        if(ar1.size() != rains.length){\\n            ar1.add(-1);\\n        }\\n        for(int p=0;p <ar1.size();p++){\\n            arr[p] = ar1.get(p);\\n        }\\n        Arrays.sort(arr);\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    // If it is impossible to avoid flood return an empty array.\\n    public int[] avoidFlood(int[] rains) {\\n        ArrayList<Integer> ar1 = new ArrayList<Integer>(); // tmp arr for ans\\n        int[] arr = new int[rains.length]; //ans arr\\n        int[] ept = new int[0];\\n        Arrays.sort(rains); // soo\\n        int counter =0;//tracks all 0\\'s\\n        int[] negcc = new int[rains.length]; // all -1 arr\\n\\n        for(int g = 0;g<rains.length;g++){\\n            negcc[g] = -1;\\n        }\\n\\n        if(rains[0] != 0){//does arr != contain 0 @ idx0\\n            for(int w9 = 0;w9<rains.length-1;w9++){\\n                if(rains[w9] == rains[w9+1]){//checks if has dupes+if cur # != \\n                    return ept;//return empty arr\\n                }\\n            }\\n            return negcc; //an all -1 array return\\n\\n\\n        for(int i = 0;i<rains.length-1;i++) {//has 0 arr case\\n            while (rains[i] == 0) {//is val 0?\\n                counter++;\\n                break;\\n            }\\n            if (rains[i] == rains[i + 1] && rains[i] != 0) { // does val hv dupe?YES val\\n                if (counter != 0) {\\n                    ar1.add(rains[i]);\\n                    counter--;\\n                }\\n                else if (counter == 0) {//if counter hits 0 then reutnr empy arr\\n                    return ept;\\n            }// need to down coutner by 1?\\n\\n            }\\n            else{\\n                ar1.add(-1);\\n            }\\n        }//add a case for all leftover counters at the end\\n        if(ar1.size() != rains.length){\\n            ar1.add(-1);\\n        }\\n        for(int p=0;p <ar1.size();p++){\\n            arr[p] = ar1.get(p);\\n        }\\n        Arrays.sort(arr);\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 697922,
                "title": "java-o-nlog-n-time-and-o-n-space-arraylist-and-hashmap-extensively-commented-with-explanation",
                "content": "Concept: The most optimised way of drying a lake on a non-rainy day is to dry the next filled lake on that day. So, we create a hashmap storing the key as lake number and the value as the day when it was filled. We store the non-rainy days in an arraylist. If we come across a non-rainy day, we simply add it in the arraylist. When we come across a rainy day, we find if the lake is already filled or not. If filled, we look for the next non-rainy day (to the day when it was full) in the arraylist using binary search. If no such day is present we couldn\\'t stop flood and we return empty array. If got such a non-rainy day, we fill that day with the lake number that is going to fill again on the ith day. We then remove the non-rainy day from the arraylist. Then(irrespective of the lake was previously full or not) we update the hashmap with the key as lake number and value as i, since it was filled on the ith day. We put -1 for rainy days and a default value of 1 for those non-rainy days that was not used for drying.\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        List<Integer>arr=new ArrayList<>();// to store the days when there was no rain and can be used for drying(dryday).\\n        int n=rains.length,idx;        \\n        HashMap<Integer,Integer>hmap=new HashMap<>();// (key -> value) => (lake -> day when it was full).\\n        for(int i=0;i<n;i++){\\n            \\n            if(rains[i]>0){ // it rained this day\\n\\t\\t\\t\\n                if(hmap.containsKey(rains[i])){  // if the lake on which it rained was already filled\\n                    \\n                    if(arr.size()==0)// no dryday left\\n                        return new int [0];\\n                    \\n                    idx=Collections.binarySearch(arr,hmap.get(rains[i]));// binary search for the dryday, just after the day when the lake was filled.\\n                    \\n                    if(idx<0)\\n                        idx=idx*(-1)-1;      \\n                    \\n                    // if no such dryday, we can\\'t stop flooding\\n                    if(idx==arr.size())\\n                        return new int [0];                                        \\n                    \\n                    rains[arr.get(idx)]=rains[i]; // we got a convenient dryday and we dried the reqired lake on this dryday.\\n                    arr.remove(idx); // remove the dryday from the list of drydays.\\n                    \\n                }                \\n                hmap.put(rains[i],i);   // updating the hashmap (lake -> day when it was filled).             \\n                rains[i]=-1;              \\n            }\\n            else\\n                arr.add(i);         // got a dryday and added it to the list of drydays.       \\n        }\\n        \\n        for(int i:arr) // we then fill up the drydays with a arbitrary number \\'1\\' which was not of any use.\\n            rains[i]=1;\\n        \\n        return rains; // we stopped the flood.\\n    }\\n}\\n```\\nThanks for reading. Please share and upvote :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        List<Integer>arr=new ArrayList<>();// to store the days when there was no rain and can be used for drying(dryday).\\n        int n=rains.length,idx;        \\n        HashMap<Integer,Integer>hmap=new HashMap<>();// (key -> value) => (lake -> day when it was full).\\n        for(int i=0;i<n;i++){\\n            \\n            if(rains[i]>0){ // it rained this day\\n\\t\\t\\t\\n                if(hmap.containsKey(rains[i])){  // if the lake on which it rained was already filled\\n                    \\n                    if(arr.size()==0)// no dryday left\\n                        return new int [0];\\n                    \\n                    idx=Collections.binarySearch(arr,hmap.get(rains[i]));// binary search for the dryday, just after the day when the lake was filled.\\n                    \\n                    if(idx<0)\\n                        idx=idx*(-1)-1;      \\n                    \\n                    // if no such dryday, we can\\'t stop flooding\\n                    if(idx==arr.size())\\n                        return new int [0];                                        \\n                    \\n                    rains[arr.get(idx)]=rains[i]; // we got a convenient dryday and we dried the reqired lake on this dryday.\\n                    arr.remove(idx); // remove the dryday from the list of drydays.\\n                    \\n                }                \\n                hmap.put(rains[i],i);   // updating the hashmap (lake -> day when it was filled).             \\n                rains[i]=-1;              \\n            }\\n            else\\n                arr.add(i);         // got a dryday and added it to the list of drydays.       \\n        }\\n        \\n        for(int i:arr) // we then fill up the drydays with a arbitrary number \\'1\\' which was not of any use.\\n            rains[i]=1;\\n        \\n        return rains; // we stopped the flood.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697895,
                "title": "java-nlog-n-solution-with-comments",
                "content": "```java\\n    public int[] avoidFlood(int[] rains) {\\n        if(rains == null || rains.length == 0) return rains;\\n        int[] res = new int[rains.length];\\n        Map<Integer, Integer> dates = new HashMap<>(); // track the day when a lake is filled\\n        TreeSet<Integer> availableDays = new TreeSet<>(); // track available days that can be used to empty lakes\\n        for(int i = 0; i < rains.length; i++) {\\n            if(rains[i] == 0) {\\n                availableDays.add(i);\\n                res[i] = 1; // placeholder, will be updated if we have to drain any lake on this day\\n            } else {\\n                Integer lastDate = dates.get(rains[i]); // check whether the lake is filled\\n                if(lastDate != null) {\\n                    Integer day = availableDays.ceiling(lastDate); // check for the least day that we can drain the lake\\n                    if(day == null) { // if the day is not available(either no \\'0\\'s available or we don\\'t have a \\'0\\' after the lake was filled last time\\n                        return new int[]{};\\n                    } else {\\n                        res[day] = rains[i]; // update the day we should drain the lake\\n                        availableDays.remove(day);\\n                    }\\n                }\\n                res[i] = -1;\\n                dates.put(rains[i], i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public int[] avoidFlood(int[] rains) {\\n        if(rains == null || rains.length == 0) return rains;\\n        int[] res = new int[rains.length];\\n        Map<Integer, Integer> dates = new HashMap<>(); // track the day when a lake is filled\\n        TreeSet<Integer> availableDays = new TreeSet<>(); // track available days that can be used to empty lakes\\n        for(int i = 0; i < rains.length; i++) {\\n            if(rains[i] == 0) {\\n                availableDays.add(i);\\n                res[i] = 1; // placeholder, will be updated if we have to drain any lake on this day\\n            } else {\\n                Integer lastDate = dates.get(rains[i]); // check whether the lake is filled\\n                if(lastDate != null) {\\n                    Integer day = availableDays.ceiling(lastDate); // check for the least day that we can drain the lake\\n                    if(day == null) { // if the day is not available(either no \\'0\\'s available or we don\\'t have a \\'0\\' after the lake was filled last time\\n                        return new int[]{};\\n                    } else {\\n                        res[day] = rains[i]; // update the day we should drain the lake\\n                        availableDays.remove(day);\\n                    }\\n                }\\n                res[i] = -1;\\n                dates.put(rains[i], i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697845,
                "title": "c-very-brief-explanation",
                "content": "Intuition:\\n\\nBrute force : whenever we encounter rains[i] = 0 ,  we try to find the **first lake** which we can empty ,that was already filled before we encountered rains[i] = 0. It would take O(n) for every rains[i] = 0, to find the lake which we should empty,  so overall complexity is O(n^2).\\n\\nOptimized : We need to optimize the answer by able to find the correct lake which needs to be emptied. So we can use **min heap**, to keep track of the first lake\\'s index which is already filled.\\n\\n\\n```\\nstruct myComp {\\n    bool operator()(pair<int,int> p1 , pair<int,int> p2) {\\n        return p1.first > p2.first;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int,pair<int,vector<int>>> umap;\\n        unordered_map<int,int> filled;\\n        \\n        priority_queue<pair<int,int> , vector<pair<int,int>> , myComp> pq;\\n        \\n        for(int i = 0 ; i < rains.size() ; i++) {\\n            umap[rains[i]].first = 1;\\n            umap[rains[i]].second.push_back(i);\\n        }\\n        vector<int> result;\\n        for(int i = 0 ; i < rains.size() ;i++) {\\n            \\n            if(rains[i] == 0) {\\n                if(!pq.empty()) {\\n                    pair<int,int> temp = pq.top();\\n                    pq.pop();\\n                    filled[temp.second] = 0;\\n                    result.push_back(temp.second);\\n                }\\n                else {\\n                    result.push_back(1);\\n                }\\n            }\\n            else if(filled[rains[i]] == 0) {\\n                filled[rains[i]] = 1;\\n                int index = umap[rains[i]].first;\\n                vector<int> temp = umap[rains[i]].second;\\n                if(index < temp.size()) {\\n                    pq.push({temp[index],rains[i]});\\n                    index++;\\n                    umap[rains[i]].first = index;\\n                }\\n                \\n                result.push_back(-1);\\n            }\\n            else if(filled[rains[i]] != 0){\\n                return {};\\n            }\\n        }\\n       return result;\\n        \\n    }\\n};\\n\\n```\\n\\n\\nPlease comment below if someones wants me to write a detailed explaination",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct myComp {\\n    bool operator()(pair<int,int> p1 , pair<int,int> p2) {\\n        return p1.first > p2.first;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int,pair<int,vector<int>>> umap;\\n        unordered_map<int,int> filled;\\n        \\n        priority_queue<pair<int,int> , vector<pair<int,int>> , myComp> pq;\\n        \\n        for(int i = 0 ; i < rains.size() ; i++) {\\n            umap[rains[i]].first = 1;\\n            umap[rains[i]].second.push_back(i);\\n        }\\n        vector<int> result;\\n        for(int i = 0 ; i < rains.size() ;i++) {\\n            \\n            if(rains[i] == 0) {\\n                if(!pq.empty()) {\\n                    pair<int,int> temp = pq.top();\\n                    pq.pop();\\n                    filled[temp.second] = 0;\\n                    result.push_back(temp.second);\\n                }\\n                else {\\n                    result.push_back(1);\\n                }\\n            }\\n            else if(filled[rains[i]] == 0) {\\n                filled[rains[i]] = 1;\\n                int index = umap[rains[i]].first;\\n                vector<int> temp = umap[rains[i]].second;\\n                if(index < temp.size()) {\\n                    pq.push({temp[index],rains[i]});\\n                    index++;\\n                    umap[rains[i]].first = index;\\n                }\\n                \\n                result.push_back(-1);\\n            }\\n            else if(filled[rains[i]] != 0){\\n                return {};\\n            }\\n        }\\n       return result;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697844,
                "title": "java-the-method-of-post-selection-detailed-explanation",
                "content": "Basically at every step, if we can dry a lake, it would be very nice if we had an oracle that told us which lake we should dry so that we can complete our run successfully, if possible. What would such an oracle\\'s answer at each i be? The oracle would tell us to dry a lake such that, this lake is currently filled, AND this lake would be filled again in the future, and would be the first such lake satisfying this criteria. \\n\\nSo, we simulate such an oracle, by drying lakes AFTER encountering them in a linear scan across the input array: we choose a lake to dry when we encounter some lake getting filled (i.e. when rains[i] > 0); if this lake is already flooded, we check if we could have dried this lake sometime after it was initially filled. If so, we set that dry in the past to have been for the current lake we are looking at, ensuring that our current run will succeed if possible by choosing the earliest such dry times. We make use of TreeSet to get the earliest dry times greater than a filling time.\\n\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        Map<Integer, Integer> fs = new HashMap();\\n        TreeSet<Integer> T = new TreeSet();\\n        int[] ret = new int[rains.length];\\n        Arrays.fill(ret, -1);\\n        for (int i = 0; i < rains.length; i++) {\\n            int cur = rains[i];\\n            if (cur > 0) {\\n                if (fs.containsKey(cur)) {\\n                    int k = fs.get(cur);\\n                    Integer h = T.higher(k);\\n                    if (h == null) return new int[0];\\n                    else {\\n                        ret[h] = cur;\\n                        T.remove(h);\\n                    }\\n                }\\n                fs.put(cur, i);\\n            }\\n            else {\\n                T.add(i);\\n                ret[i] = 1;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        Map<Integer, Integer> fs = new HashMap();\\n        TreeSet<Integer> T = new TreeSet();\\n        int[] ret = new int[rains.length];\\n        Arrays.fill(ret, -1);\\n        for (int i = 0; i < rains.length; i++) {\\n            int cur = rains[i];\\n            if (cur > 0) {\\n                if (fs.containsKey(cur)) {\\n                    int k = fs.get(cur);\\n                    Integer h = T.higher(k);\\n                    if (h == null) return new int[0];\\n                    else {\\n                        ret[h] = cur;\\n                        T.remove(h);\\n                    }\\n                }\\n                fs.put(cur, i);\\n            }\\n            else {\\n                T.add(i);\\n                ret[i] = 1;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697837,
                "title": "java-map-and-treeset-solution-o-nlogn",
                "content": "My thought was that we need to keep track of the last time it rained on an island. If it rains on an island again, there has to be at least 1 dry day between the previous index and the current index it rained. Otherwise, the island will have 2 consecutive rain days and flood. I select the leftmost dry day that comes after the previous rained index in sort of a greedy way, so that there are more dry days closer to the remaining indices.\\n\\nWe store the dry day indices in a TreeSet for O(logN) searching and O(logN) removal. Using another data structure such as ArrayList would result in TLE. \\n\\nAt the end, we make sure that we used all the dry days, which I just set to apply to island 1. \\n\\nTime complexity is about O(N*logN).\\n\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int N = rains.length;\\n        int[] ans = new int[N];        \\n        \\n        Map<Integer, Integer> lakeIndices = new HashMap<>();\\n        TreeSet<Integer> dryDays = new TreeSet<>();\\n                \\n        for (int i = 0; i < N; i++) {\\n            if (rains[i] == 0) {\\n                dryDays.add(i);\\n            }\\n            else {\\n                if (lakeIndices.containsKey(rains[i])) {        \\n                    Integer dryDay = dryDays.higher(lakeIndices.get(rains[i]));\\n                    \\n                    if (dryDay == null) {\\n                        return new int[] {};\\n                    }\\n                                        \\n                    ans[dryDay] = rains[i];\\n                    dryDays.remove(dryDay);\\n                }\\n                \\n                ans[i] = -1;\\n                lakeIndices.put(rains[i], i);\\n            }\\n        }\\n                \\n        for (int dry : dryDays) {\\n            ans[dry] = 1;\\n        }\\n               \\n        return ans;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int N = rains.length;\\n        int[] ans = new int[N];        \\n        \\n        Map<Integer, Integer> lakeIndices = new HashMap<>();\\n        TreeSet<Integer> dryDays = new TreeSet<>();\\n                \\n        for (int i = 0; i < N; i++) {\\n            if (rains[i] == 0) {\\n                dryDays.add(i);\\n            }\\n            else {\\n                if (lakeIndices.containsKey(rains[i])) {        \\n                    Integer dryDay = dryDays.higher(lakeIndices.get(rains[i]));\\n                    \\n                    if (dryDay == null) {\\n                        return new int[] {};\\n                    }\\n                                        \\n                    ans[dryDay] = rains[i];\\n                    dryDays.remove(dryDay);\\n                }\\n                \\n                ans[i] = -1;\\n                lakeIndices.put(rains[i], i);\\n            }\\n        }\\n                \\n        for (int dry : dryDays) {\\n            ans[dry] = 1;\\n        }\\n               \\n        return ans;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697818,
                "title": "java-greedy-one-hashmap-and-one-treeset",
                "content": "How to avoid the city get flood -> we need to ensure each of the lake is not been rained twice.\\nSo we have to dry the last lake before it got rained second time.\\nBut we did not know when to dry and which lake to dry right?\\n\\nFirstly we have to dry a lake once it meet the second rain on it, so we could use a hashmap to store the last rain date which is the index as value.\\nWhen we find the key again, we have to ensure there is a dry date before the second rain day and after the first rain day so that we could use that date to dry the lake.\\n\\nWe could greedly use the first day that greater than the date we need to dry. Using a treeSet so we could apply search in log (n) \\n\\n\\n```\\npublic int[] avoidFlood(int[] rains) {\\n        int[] res = new int[rains.length];\\n        TreeSet<Integer> dryday = new TreeSet<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0 ; i < rains.length; i++) {\\n            if (rains[i] == 0) {\\n                dryday.add(i);\\n                continue;\\n            }\\n            if (!map.containsKey(rains[i])) {\\n                map.put(rains[i], i);\\n            }\\n            else {\\n                //meet the second rain we need to dry the last\\n                int lastIndex = map.get(rains[i]);\\n                if (dryday.size() == 0 || dryday.last() < lastIndex) {\\n                    return new int[]{};\\n                }\\n                int dry = dryday.ceiling(lastIndex);\\n                res[dry] = rains[i];\\n                dryday.remove(dry);\\n                map.put(rains[i], i);\\n            }\\n        }\\n        for (int i = 0; i < rains.length; i++) {\\n            if (rains[i] != 0) {\\n                res[i] = -1;\\n            }\\n            if (rains[i] == 0 && res[i] == 0) {\\n                res[i] = 1;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] avoidFlood(int[] rains) {\\n        int[] res = new int[rains.length];\\n        TreeSet<Integer> dryday = new TreeSet<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0 ; i < rains.length; i++) {\\n            if (rains[i] == 0) {\\n                dryday.add(i);\\n                continue;\\n            }\\n            if (!map.containsKey(rains[i])) {\\n                map.put(rains[i], i);\\n            }\\n            else {\\n                //meet the second rain we need to dry the last\\n                int lastIndex = map.get(rains[i]);\\n                if (dryday.size() == 0 || dryday.last() < lastIndex) {\\n                    return new int[]{};\\n                }\\n                int dry = dryday.ceiling(lastIndex);\\n                res[dry] = rains[i];\\n                dryday.remove(dry);\\n                map.put(rains[i], i);\\n            }\\n        }\\n        for (int i = 0; i < rains.length; i++) {\\n            if (rains[i] != 0) {\\n                res[i] = -1;\\n            }\\n            if (rains[i] == 0 && res[i] == 0) {\\n                res[i] = 1;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697734,
                "title": "python3-heapq-set",
                "content": "```\\nimport collections\\nimport heapq\\n\\n\\nclass Solution:\\n    def avoidFlood(self, rains: list) -> list:\\n        ret = []\\n        ele_last_ind = collections.defaultdict(int)\\n        res = collections.defaultdict(int)\\n        for i, r in enumerate(rains):\\n            if not r: continue\\n            if r not in ele_last_ind:\\n                res[i] = -1\\n            else:\\n                res[ele_last_ind[r]] = i\\n            ele_last_ind[r] = i\\n        h = []\\n        stack = set()\\n        for i, r in enumerate(rains):\\n            if r:\\n                if r in stack: return []\\n                ret.append(-1)\\n                if r in res and res[r] == -1:\\n                    pass\\n                else:\\n                    if res[i] and res[i] != -1:\\n                        heapq.heappush(h, (res[i], {r: res[i]}))\\n                stack.add(r)\\n            else:\\n                if h:\\n                    a = heapq.heappop(h)\\n                    k = a[1].popitem()[0]\\n                    stack.remove(k)\\n                    ret.append(k)\\n                else:\\n                    ret.append(1)\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport collections\\nimport heapq\\n\\n\\nclass Solution:\\n    def avoidFlood(self, rains: list) -> list:\\n        ret = []\\n        ele_last_ind = collections.defaultdict(int)\\n        res = collections.defaultdict(int)\\n        for i, r in enumerate(rains):\\n            if not r: continue\\n            if r not in ele_last_ind:\\n                res[i] = -1\\n            else:\\n                res[ele_last_ind[r]] = i\\n            ele_last_ind[r] = i\\n        h = []\\n        stack = set()\\n        for i, r in enumerate(rains):\\n            if r:\\n                if r in stack: return []\\n                ret.append(-1)\\n                if r in res and res[r] == -1:\\n                    pass\\n                else:\\n                    if res[i] and res[i] != -1:\\n                        heapq.heappush(h, (res[i], {r: res[i]}))\\n                stack.add(r)\\n            else:\\n                if h:\\n                    a = heapq.heappop(h)\\n                    k = a[1].popitem()[0]\\n                    stack.remove(k)\\n                    ret.append(k)\\n                else:\\n                    ret.append(1)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697708,
                "title": "c-o-n-log-n-greedy-with-tree-set",
                "content": "Greedy approach: loop and use a tree set to record all the possible dry days and when needed always select the earliest valid chance to dry a lake\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        int n = rains.size();\\n        unordered_map<int, int> lastPos;\\n        set<int> canDries;\\n        vector<int> result(n, 1);\\n        for (int i = 0; i < n; i++) {\\n            int lake = rains[i];\\n            if (lake == 0) {\\n                canDries.insert(i);\\n            } else {\\n                result[i] = -1;\\n                if (lastPos.find(lake) == lastPos.end()) {\\n                    lastPos[lake] = i;\\n                } else {\\n                    int pos = lastPos[lake];\\n                    auto it = canDries.upper_bound(pos);\\n                    if (it == canDries.end()) {\\n                        result.clear();\\n                        break;\\n                    } else {\\n                        result[*it] = lake;\\n                        canDries.erase(it);\\n                        lastPos[lake] = i;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        int n = rains.size();\\n        unordered_map<int, int> lastPos;\\n        set<int> canDries;\\n        vector<int> result(n, 1);\\n        for (int i = 0; i < n; i++) {\\n            int lake = rains[i];\\n            if (lake == 0) {\\n                canDries.insert(i);\\n            } else {\\n                result[i] = -1;\\n                if (lastPos.find(lake) == lastPos.end()) {\\n                    lastPos[lake] = i;\\n                } else {\\n                    int pos = lastPos[lake];\\n                    auto it = canDries.upper_bound(pos);\\n                    if (it == canDries.end()) {\\n                        result.clear();\\n                        break;\\n                    } else {\\n                        result[*it] = lake;\\n                        canDries.erase(it);\\n                        lastPos[lake] = i;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697696,
                "title": "accepted-c-greedy-solution-decorated-sortedset-used",
                "content": "```\\n    public class Solution\\n    {\\n\\n        public class ComparerDecorator<T> : IComparer<T>\\n        {\\n            private readonly IComparer<T> _comparer;\\n\\n            public T LowerBound { get; private set; }\\n            public T UpperBound { get; private set; }\\n\\n            private bool _resetLower = true;\\n            private bool _resetUpper = true;\\n\\n            public void Reset()\\n            {\\n                _resetLower = true;\\n                _resetUpper = true;\\n            }\\n\\n            public ComparerDecorator(IComparer<T> comparer)\\n            {\\n                _comparer = comparer;\\n            }\\n\\n            public int Compare(T x, T y)\\n            {\\n                int cmp = _comparer.Compare(x, y);\\n\\n                if (_resetLower)\\n                {\\n                    LowerBound = y;\\n                }\\n\\n                if (_resetUpper)\\n                {\\n                    UpperBound = y;\\n                }\\n\\n                if (cmp >= 0)\\n                {\\n                    LowerBound = y;\\n                    _resetLower = false;\\n                }\\n\\n                if (cmp <= 0)\\n                {\\n                    UpperBound = y;\\n                    _resetUpper = false;\\n                }\\n\\n                return cmp;\\n            }\\n        }\\n\\n        public class BoundSortedSet<T> : SortedSet<T>\\n        {\\n            private readonly ComparerDecorator<T> _comparerDecorator;\\n\\n            public BoundSortedSet()\\n                : this(Comparer<T>.Default)\\n            {\\n            }\\n\\n            public BoundSortedSet(IComparer<T> comparer)\\n                : base(new ComparerDecorator<T>(comparer))\\n            {\\n                _comparerDecorator = (ComparerDecorator<T>)this.Comparer;\\n            }\\n\\n            public void FindBounds(T key, out T lower, out T upper)\\n            {\\n                _comparerDecorator.Reset();\\n                var contains = this.Contains<T>(key);\\n                lower = _comparerDecorator.LowerBound;\\n                upper = _comparerDecorator.UpperBound;\\n            }\\n        }\\n\\n\\n        public int[] AvoidFlood(int[] rains)\\n        {\\n            int[] res = new int[rains.Length];\\n\\n            checked\\n            {\\n                BoundSortedSet<int> zeroIndices = new BoundSortedSet<int>();\\n                List<(int lake, int dayFrom, int dayTo)> dry = new List<(int lake, int dayFrom, int dayTo)>();\\n                IDictionary<int, int> fullLakes = new Dictionary<int, int>();\\n\\n                for (int i = 0; i < res.Length; i++)\\n                {\\n                    if (rains[i] == 0)\\n                    {\\n                        zeroIndices.Add(i);\\n                        continue;\\n                    }\\n\\n                    res[i] = -1;\\n\\n                    if (fullLakes.ContainsKey(rains[i]))\\n                    {\\n                        dry.Add((rains[i], fullLakes[rains[i]], i));\\n                        fullLakes[rains[i]] = i;\\n                        continue;\\n                    }\\n\\n                    fullLakes[rains[i]] = i;\\n                }\\n\\n                foreach (var d in dry)\\n                {\\n                    if (zeroIndices.Count == 0)\\n                    {\\n                        return new int[]{};\\n                    }\\n\\n                    zeroIndices.FindBounds(d.dayFrom, out var l, out var h);\\n                    if (h <= d.dayFrom || h >= d.dayTo)\\n                    {\\n                        return new int[] { };\\n                    }\\n                    res[h] = d.lake;\\n                    zeroIndices.Remove(h);\\n                }\\n            }\\n\\n            for (int i = 0; i < res.Length; i++)\\n            {\\n                if (res[i] == 0)\\n                {\\n                    res[i] = 1;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n\\n        public class ComparerDecorator<T> : IComparer<T>\\n        {\\n            private readonly IComparer<T> _comparer;\\n\\n            public T LowerBound { get; private set; }\\n            public T UpperBound { get; private set; }\\n\\n            private bool _resetLower = true;\\n            private bool _resetUpper = true;\\n\\n            public void Reset()\\n            {\\n                _resetLower = true;\\n                _resetUpper = true;\\n            }\\n\\n            public ComparerDecorator(IComparer<T> comparer)\\n            {\\n                _comparer = comparer;\\n            }\\n\\n            public int Compare(T x, T y)\\n            {\\n                int cmp = _comparer.Compare(x, y);\\n\\n                if (_resetLower)\\n                {\\n                    LowerBound = y;\\n                }\\n\\n                if (_resetUpper)\\n                {\\n                    UpperBound = y;\\n                }\\n\\n                if (cmp >= 0)\\n                {\\n                    LowerBound = y;\\n                    _resetLower = false;\\n                }\\n\\n                if (cmp <= 0)\\n                {\\n                    UpperBound = y;\\n                    _resetUpper = false;\\n                }\\n\\n                return cmp;\\n            }\\n        }\\n\\n        public class BoundSortedSet<T> : SortedSet<T>\\n        {\\n            private readonly ComparerDecorator<T> _comparerDecorator;\\n\\n            public BoundSortedSet()\\n                : this(Comparer<T>.Default)\\n            {\\n            }\\n\\n            public BoundSortedSet(IComparer<T> comparer)\\n                : base(new ComparerDecorator<T>(comparer))\\n            {\\n                _comparerDecorator = (ComparerDecorator<T>)this.Comparer;\\n            }\\n\\n            public void FindBounds(T key, out T lower, out T upper)\\n            {\\n                _comparerDecorator.Reset();\\n                var contains = this.Contains<T>(key);\\n                lower = _comparerDecorator.LowerBound;\\n                upper = _comparerDecorator.UpperBound;\\n            }\\n        }\\n\\n\\n        public int[] AvoidFlood(int[] rains)\\n        {\\n            int[] res = new int[rains.Length];\\n\\n            checked\\n            {\\n                BoundSortedSet<int> zeroIndices = new BoundSortedSet<int>();\\n                List<(int lake, int dayFrom, int dayTo)> dry = new List<(int lake, int dayFrom, int dayTo)>();\\n                IDictionary<int, int> fullLakes = new Dictionary<int, int>();\\n\\n                for (int i = 0; i < res.Length; i++)\\n                {\\n                    if (rains[i] == 0)\\n                    {\\n                        zeroIndices.Add(i);\\n                        continue;\\n                    }\\n\\n                    res[i] = -1;\\n\\n                    if (fullLakes.ContainsKey(rains[i]))\\n                    {\\n                        dry.Add((rains[i], fullLakes[rains[i]], i));\\n                        fullLakes[rains[i]] = i;\\n                        continue;\\n                    }\\n\\n                    fullLakes[rains[i]] = i;\\n                }\\n\\n                foreach (var d in dry)\\n                {\\n                    if (zeroIndices.Count == 0)\\n                    {\\n                        return new int[]{};\\n                    }\\n\\n                    zeroIndices.FindBounds(d.dayFrom, out var l, out var h);\\n                    if (h <= d.dayFrom || h >= d.dayTo)\\n                    {\\n                        return new int[] { };\\n                    }\\n                    res[h] = d.lake;\\n                    zeroIndices.Remove(h);\\n                }\\n            }\\n\\n            for (int i = 0; i < res.Length; i++)\\n            {\\n                if (res[i] == 0)\\n                {\\n                    res[i] = 1;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697694,
                "title": "c-typical-greedy-one-priority-queue-and-one-unordered-map",
                "content": "The solution is as follows. First, reverse traverse the array and find out the nextDay that is going to rain on this indexed lake (using hashMap this can be done fast). Then, forward traverse the array and make the priorities, if at any point they don\\'t meet, return an empty vector. If they continue to meet, return the final return vector at the end.\\n```\\nclass Solution {\\npublic:\\n    \\n    struct comp{\\n        template<typename T>\\n        bool operator()(const T& e1, const T & e2)const{\\n            return (e1>e2);\\n        }\\n    };\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int,int> mp;\\n        vector<int> ret;\\n        vector<int> nextDay(rains.size(),-1);\\n        priority_queue<int,vector<int>,comp> pq;\\n        mp[0] = -1;\\n        // Reverse traverse the array and find out the nextDay that is going to rain on this lake\\n        for (int i = rains.size()-1;i>-1;i--){\\n            if(mp.find(rains[i])!=mp.end()){\\n                nextDay[i] = mp[rains[i]];\\n            }\\n            mp[rains[i]] = i;\\n        }\\n        for (int i = 0; i<rains.size(); i++){\\n            // enter to the priority queue the day that is going to rain again on this lake ... \\n            // and if the priority is equal to the current day then return an empty vector.\\n            if (rains[i]){\\n                if (!pq.empty() && rains[pq.top()]==rains[i]) // The top priority is same as the current day, therefore it will flood!!!\\n                    return vector<int> ();\\n                ret.push_back(-1);\\n                if (nextDay[i]!=-1){\\n                    pq.push(nextDay[i]);\\n                }\\n            }\\n            // if today there is no rain, then empty the lake that has the highest priority\\n            if (rains[i]==0){\\n                if (!pq.empty()){\\n                    ret.push_back(rains[pq.top()]);\\n                    pq.pop();\\n                }else\\n                    ret.push_back(1); // push any positive number you want. Such as x, y in example 4\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    struct comp{\\n        template<typename T>\\n        bool operator()(const T& e1, const T & e2)const{\\n            return (e1>e2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4058057,
                "title": "avoid-flood-in-the-city-code-with-approach-and-comments",
                "content": "\\n# Approach\\n - Take a HashMap which will store rains[i] vs i . This will store on which day rain has happend\\n- Take a TreeSet to know the  just greater value than already existed rains[i].\\n\\n# Complexity\\n- Time complexity:\\nO(N * log(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n//        take a hashmap to store rains at ith lake vs which day ie index\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n//        also take a Tree set to know the just greater value than our requirement\\n        TreeSet<Integer> set = new TreeSet<>();\\n\\n        int[] ans=new int[rains.length];\\n\\n        // change default value of array \\n        for(int j=0;j<ans.length;j++){\\n            ans[j]=1; \\n        }\\n        \\n        for (int i=0;i<rains.length;i++){\\n            int x = rains[i];\\n            if (x==0){ //dry day\\n                set.add(i);\\n                continue;\\n            }\\n            if (map.containsKey(x)){ //aleady rained then get the day \\n                int rainDay=map.get(x);\\n                Integer afterRainDay=set.higher(rainDay); //check whether set contains any day higher then raindDay if yes then dry the lake else there is flood\\n                if (afterRainDay==null){\\n                    return new int[0]; // flood\\n                }else { //can dry easily\\n                    ans[afterRainDay]=x; \\n                    map.put(x,i); //update the newer rain day\\n                    set.remove(afterRainDay); //remove this\\n                    ans[i]=-1; //since there has rain so put -1\\n                }\\n            }else { // new lake\\n                map.put(x,i);\\n                ans[i]=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n//        take a hashmap to store rains at ith lake vs which day ie index\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n//        also take a Tree set to know the just greater value than our requirement\\n        TreeSet<Integer> set = new TreeSet<>();\\n\\n        int[] ans=new int[rains.length];\\n\\n        // change default value of array \\n        for(int j=0;j<ans.length;j++){\\n            ans[j]=1; \\n        }\\n        \\n        for (int i=0;i<rains.length;i++){\\n            int x = rains[i];\\n            if (x==0){ //dry day\\n                set.add(i);\\n                continue;\\n            }\\n            if (map.containsKey(x)){ //aleady rained then get the day \\n                int rainDay=map.get(x);\\n                Integer afterRainDay=set.higher(rainDay); //check whether set contains any day higher then raindDay if yes then dry the lake else there is flood\\n                if (afterRainDay==null){\\n                    return new int[0]; // flood\\n                }else { //can dry easily\\n                    ans[afterRainDay]=x; \\n                    map.put(x,i); //update the newer rain day\\n                    set.remove(afterRainDay); //remove this\\n                    ans[i]=-1; //since there has rain so put -1\\n                }\\n            }else { // new lake\\n                map.put(x,i);\\n                ans[i]=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030824,
                "title": "using-map-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& arr) {\\n        // Initialize variables and data structures\\n        int n = arr.size(); // Get the size of the input array\\n        unordered_map<int, int> phle_ki_varsha; // Map to track the last rain day for each lake\\n        set<int> dry; // Set to track dry days\\n        vector<int> ans(arr.size(), 1); // Initialize the answer vector with 1 (indicating no rain initially)\\n\\n        for (int i = 0; i < n; i++) {\\n            int aaj_ki_varsha = arr[i]; // Get the current day\\'s rain in a specific lake\\n\\n            if (aaj_ki_varsha != 0) {\\n                // If it\\'s a rainy day:\\n                if (phle_ki_varsha.count(aaj_ki_varsha)) {\\n                    // Check if it has rained in the same lake before\\n                    auto it = dry.lower_bound(phle_ki_varsha[aaj_ki_varsha]);\\n                    \\n                    if (it == dry.end())\\n                        return {}; // If no dry day available, return an empty vector (impossible)\\n                    \\n                    int temp = *it; // Get the index of a dry day\\n                    dry.erase(it); // Remove the dry day from the set\\n                    ans[temp] = aaj_ki_varsha; // Store the current day\\'s rain in the dry day\\n                }\\n                phle_ki_varsha[aaj_ki_varsha] = i; // Update the last rainy day for the current lake\\n                ans[i] = -1; // Mark the current day as a rainy day (-1)\\n            } else {\\n                dry.insert(i); // If it\\'s a dry day, add it to the set of dry days\\n            }\\n        }\\n\\n        // Fill in any remaining dry days with 1 (no rain)\\n        for (auto days : dry) {\\n            ans[days] = 1;\\n        }\\n\\n        return ans; // Return the answer vector\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& arr) {\\n        // Initialize variables and data structures\\n        int n = arr.size(); // Get the size of the input array\\n        unordered_map<int, int> phle_ki_varsha; // Map to track the last rain day for each lake\\n        set<int> dry; // Set to track dry days\\n        vector<int> ans(arr.size(), 1); // Initialize the answer vector with 1 (indicating no rain initially)\\n\\n        for (int i = 0; i < n; i++) {\\n            int aaj_ki_varsha = arr[i]; // Get the current day\\'s rain in a specific lake\\n\\n            if (aaj_ki_varsha != 0) {\\n                // If it\\'s a rainy day:\\n                if (phle_ki_varsha.count(aaj_ki_varsha)) {\\n                    // Check if it has rained in the same lake before\\n                    auto it = dry.lower_bound(phle_ki_varsha[aaj_ki_varsha]);\\n                    \\n                    if (it == dry.end())\\n                        return {}; // If no dry day available, return an empty vector (impossible)\\n                    \\n                    int temp = *it; // Get the index of a dry day\\n                    dry.erase(it); // Remove the dry day from the set\\n                    ans[temp] = aaj_ki_varsha; // Store the current day\\'s rain in the dry day\\n                }\\n                phle_ki_varsha[aaj_ki_varsha] = i; // Update the last rainy day for the current lake\\n                ans[i] = -1; // Mark the current day as a rainy day (-1)\\n            } else {\\n                dry.insert(i); // If it\\'s a dry day, add it to the set of dry days\\n            }\\n        }\\n\\n        // Fill in any remaining dry days with 1 (no rain)\\n        for (auto days : dry) {\\n            ans[days] = 1;\\n        }\\n\\n        return ans; // Return the answer vector\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009209,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        HashMap<Integer,Integer> lastRain=new HashMap<>();\\n        TreeSet<Integer> dry=new TreeSet<>();\\n\\n        int n=rains.length;\\n        int[] ans=new int[n];\\n\\n        for(int i=0;i<n;i++){\\n            if(rains[i]==0){\\n                dry.add(i);\\n                ans[i]=1; \\n            }\\n            else{\\n                if(lastRain.containsKey(rains[i])){\\n                   Integer availZero=dry.ceiling(lastRain.get(rains[i]));\\n                   if(availZero==null){\\n                       return new int[0];\\n                   }\\n                   ans[availZero]=rains[i];\\n                   dry.remove(availZero);\\n\\n                }\\n                ans[i]=-1;\\n                lastRain.put(rains[i],i);\\n            }\\n        }\\n        return ans  ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        HashMap<Integer,Integer> lastRain=new HashMap<>();\\n        TreeSet<Integer> dry=new TreeSet<>();\\n\\n        int n=rains.length;\\n        int[] ans=new int[n];\\n\\n        for(int i=0;i<n;i++){\\n            if(rains[i]==0){\\n                dry.add(i);\\n                ans[i]=1; \\n            }\\n            else{\\n                if(lastRain.containsKey(rains[i])){\\n                   Integer availZero=dry.ceiling(lastRain.get(rains[i]));\\n                   if(availZero==null){\\n                       return new int[0];\\n                   }\\n                   ans[availZero]=rains[i];\\n                   dry.remove(availZero);\\n\\n                }\\n                ans[i]=-1;\\n                lastRain.put(rains[i],i);\\n            }\\n        }\\n        return ans  ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998910,
                "title": "python-nlogn-adhoc-heap-beats-60",
                "content": "the rev and revmap responsible to map the next closest index of current lake. We traverse from right to left to do this, rev is an array mapping the rain\\'s right closest index for later use.\\nWhen we process from left to right, use a hashmap to keep current counting, checking for flooding possibilities. We break out and return empty array if hashmap[lake] > 1\\n\\nthe min heap with store the (closest element index, lake number), 0 always want to process a lake that had rain before itself: hashmap[lake] = 1 \\n\\nWhen we encounter 0 , priorize the closest right lake that just previously rained and dry it first.\\n\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        rev_map = {}\\n        hashmap = defaultdict(int)\\n        rev = []\\n        for i in range(len(rains)-1,-1,-1):\\n            if rains[i] == 0:\\n                rev.append(0)\\n                continue \\n            if  rains[i] not in rev_map:\\n                rev_map[rains[i]] = i\\n                rev.append(float(\\'inf\\'))\\n            else:\\n                rev.append(rev_map[rains[i]])\\n                rev_map[rains[i]] = i\\n        heap = []\\n        ans = []\\n        N = len(rev) - 1\\n        for i in range(len(rains)):\\n            if rains[i] != 0:\\n                ans.append(-1)\\n                hashmap[rains[i]] += 1\\n                heapq.heappush(heap,(rev[N-i],rains[i]))\\n                if hashmap[rains[i]] > 1:\\n                    return []\\n            else:\\n                if heap:\\n                    ind,lake =heapq.heappop(heap)\\n                    ans.append(lake)\\n                    hashmap[lake] -= 1\\n                else:\\n                    ans.append(1)\\n        return ans",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        rev_map = {}",
                "codeTag": "Java"
            },
            {
                "id": 3953211,
                "title": "cpp-set-map-binary-search-greedy-explaination",
                "content": "\\n\\n\\n##### Intuition : \\n* In question says we `need to dry lakes` in `no rain day`, but which `lake dry` in that day it will `decide optimally`.\\n* Which lake dry? \\n    - We dry those lake we countered again because it\\'s `already full` and it\\'s counterd angain then it\\'s flood that\\'s why we choose last lake and dry it.\\n\\n##### Approach :\\n* We track all those day that day `no rains` in `set` because we need those days for dry lakes.\\n* We also track those lakes and days `[lake, day]` in `map` for which day lake full.\\n* We countered lake that is already full so we dry it but it\\'s possible only we have no rain day in between `map[lake] day to current day`. and it\\'s possible to find out using `binary search` on rains day. \\n\\n    \\n#### Time Complexity : O(N * LOG(N))\\n    \\n#### Space Complexity : O(N)\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        int n = rains.size();\\n        set<int> days; // Tracking no rain days\\n        unordered_map<int, int> l;   // Tracking which lake which day full [lake, day];\\n        \\n        vector<int> ans(n);\\n        \\n        for(int i = 0; i < n; i++) {\\n            // We encountered no rain day so we insert into set\\n            if(!rains[i]) {\\n                days.insert(i);\\n                continue;\\n            }\\n            \\n            ans[i] = -1;\\n            \\n            \\n            if(!l.count(rains[i])) l[rains[i]] = i; // No rains[i] lake encountered in past\\n            else {\\n                int last = l[rains[i]]; // last encountered day for rains[i] lake\\n                auto it = days.upper_bound(last); // find out no rain day just after that for dry it\\n                if(it == days.end()) return {};   // if we not get any day for dry it return empty array\\n                ans[*it] = rains[i];   // we get day for dry it so that day set which lake dry\\n                days.erase(it);   // erase that day into set because we used them\\n                l[rains[i]] = i;  // set new day for current lake\\n            }\\n        }\\n        \\n        // after all process remaining no rains day set 1 (no matter which you set)\\n        for(auto &it : days) ans[it] = 1;\\n        return ans;\\n    }\\n};\\n```\\n\\n> Thanks for upvoting \\uD83D\\uDE00",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        int n = rains.size();\\n        set<int> days; // Tracking no rain days\\n        unordered_map<int, int> l;   // Tracking which lake which day full [lake, day];\\n        \\n        vector<int> ans(n);\\n        \\n        for(int i = 0; i < n; i++) {\\n            // We encountered no rain day so we insert into set\\n            if(!rains[i]) {\\n                days.insert(i);\\n                continue;\\n            }\\n            \\n            ans[i] = -1;\\n            \\n            \\n            if(!l.count(rains[i])) l[rains[i]] = i; // No rains[i] lake encountered in past\\n            else {\\n                int last = l[rains[i]]; // last encountered day for rains[i] lake\\n                auto it = days.upper_bound(last); // find out no rain day just after that for dry it\\n                if(it == days.end()) return {};   // if we not get any day for dry it return empty array\\n                ans[*it] = rains[i];   // we get day for dry it so that day set which lake dry\\n                days.erase(it);   // erase that day into set because we used them\\n                l[rains[i]] = i;  // set new day for current lake\\n            }\\n        }\\n        \\n        // after all process remaining no rains day set 1 (no matter which you set)\\n        for(auto &it : days) ans[it] = 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924837,
                "title": "typescript-solution-o-n-log-n-beats-100-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n\\n- Space complexity:\\nO(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction getFirstIndexGreater(arr: number[], k: number): number | undefined {\\n    if (arr.length === 0) {\\n        return undefined\\n    }\\n    if (k > arr[arr.length - 1]) {\\n        return undefined\\n    }\\n\\n    let low = 0\\n    let high = arr.length - 1\\n\\n    while(low <= high) {\\n        const mid = low + Math.floor((high - low) / 2)\\n        if (arr[mid] > k) {\\n            high = mid - 1\\n        } else {\\n            low = mid + 1\\n        }\\n    }\\n\\n    return low\\n\\n}\\n\\n\\nfunction avoidFlood(rains: number[]): number[] {\\n    const filledLakesMap = new Map<number, number>()\\n    const dryDays = []\\n    const result = []\\n\\n    for (let i = 0; i < rains.length; i++) {\\n        if (rains[i] === 0) {\\n            dryDays.push(i)\\n            result.push(1)\\n        } else {\\n            if (!filledLakesMap.has(rains[i])) {\\n                result.push(-1)\\n                filledLakesMap.set(rains[i], i)\\n            } else {\\n                const dryIndex = getFirstIndexGreater(dryDays, filledLakesMap.get(rains[i]))\\n                \\n                if (dryIndex !== undefined) {\\n                    const [dryDay] = dryDays.splice(dryIndex, 1)\\n                    result[dryDay] = rains[i]\\n                    filledLakesMap.set(rains[i], i)\\n                    result.push(-1)\\n                } else {\\n                    return []\\n                }\\n            }\\n        }\\n    }\\n    return result\\n}\\n\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction getFirstIndexGreater(arr: number[], k: number): number | undefined {\\n    if (arr.length === 0) {\\n        return undefined\\n    }\\n    if (k > arr[arr.length - 1]) {\\n        return undefined\\n    }\\n\\n    let low = 0\\n    let high = arr.length - 1\\n\\n    while(low <= high) {\\n        const mid = low + Math.floor((high - low) / 2)\\n        if (arr[mid] > k) {\\n            high = mid - 1\\n        } else {\\n            low = mid + 1\\n        }\\n    }\\n\\n    return low\\n\\n}\\n\\n\\nfunction avoidFlood(rains: number[]): number[] {\\n    const filledLakesMap = new Map<number, number>()\\n    const dryDays = []\\n    const result = []\\n\\n    for (let i = 0; i < rains.length; i++) {\\n        if (rains[i] === 0) {\\n            dryDays.push(i)\\n            result.push(1)\\n        } else {\\n            if (!filledLakesMap.has(rains[i])) {\\n                result.push(-1)\\n                filledLakesMap.set(rains[i], i)\\n            } else {\\n                const dryIndex = getFirstIndexGreater(dryDays, filledLakesMap.get(rains[i]))\\n                \\n                if (dryIndex !== undefined) {\\n                    const [dryDay] = dryDays.splice(dryIndex, 1)\\n                    result[dryDay] = rains[i]\\n                    filledLakesMap.set(rains[i], i)\\n                    result.push(-1)\\n                } else {\\n                    return []\\n                }\\n            }\\n        }\\n    }\\n    return result\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910040,
                "title": "c-implementation-using-ordered-map-and-multiset-data-structure",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        map<int,int>mp;\\n        vector<int>ans(rains.size());\\n        vector<int>ind;\\n        bool ele=false;\\n        multiset<int>mst;\\n        for(int i=0;i<rains.size();i++){\\n            if(rains[i]){\\n                if(mp.find(rains[i])==mp.end()){\\n                    mp[rains[i]]=i+1;\\n                    ans[i]=-1;\\n                    // mst.clear();\\n                }\\n                else if(mst.size()!=0){\\n                    if(i==mp[rains[i]]){\\n                        return {};\\n                    }\\n                    auto ind=mst.lower_bound(mp[rains[i]]-1);\\n                    if(ind==mst.end()){\\n                        ind--;\\n                    }\\n\\n                    int num=*ind;\\n                    if(num<mp[rains[i]]-1){\\n                        return {};\\n                    }\\n                    ans[num]=rains[i];\\n                    ans[i]=-1;\\n                    mp[rains[i]]=i+1;\\n                    mst.erase(ind);\\n                }\\n                else{\\n                    return {};\\n                }\\n                ele=true;\\n            }\\n            else if(ele){\\n                mst.insert(i);\\n            }\\n        }\\n        for(auto &x:ans){\\n            x=x==0?1:x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        map<int,int>mp;\\n        vector<int>ans(rains.size());\\n        vector<int>ind;\\n        bool ele=false;\\n        multiset<int>mst;\\n        for(int i=0;i<rains.size();i++){\\n            if(rains[i]){\\n                if(mp.find(rains[i])==mp.end()){\\n                    mp[rains[i]]=i+1;\\n                    ans[i]=-1;\\n                    // mst.clear();\\n                }\\n                else if(mst.size()!=0){\\n                    if(i==mp[rains[i]]){\\n                        return {};\\n                    }\\n                    auto ind=mst.lower_bound(mp[rains[i]]-1);\\n                    if(ind==mst.end()){\\n                        ind--;\\n                    }\\n\\n                    int num=*ind;\\n                    if(num<mp[rains[i]]-1){\\n                        return {};\\n                    }\\n                    ans[num]=rains[i];\\n                    ans[i]=-1;\\n                    mp[rains[i]]=i+1;\\n                    mst.erase(ind);\\n                }\\n                else{\\n                    return {};\\n                }\\n                ele=true;\\n            }\\n            else if(ele){\\n                mst.insert(i);\\n            }\\n        }\\n        for(auto &x:ans){\\n            x=x==0?1:x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899712,
                "title": "python-short-with-priority-qu",
                "content": "# Basic idea\\nEverything is described in problem hint.\\nHold last index for very value. Process from start index.\\nWhen value is met, if exists next index put it on priority queue. When zero pop from pqirioty queue.\\nFail is when there is next index equal or smaller to current index or when everything is done and priority qu is not empty.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def avoidFlood(self, rains):\\n        result, pq = [], []\\n        N, last = len(rains), defaultdict(deque)\\n        for i, v in enumerate(rains): last[v].append(i)\\n\\n        for i, v in enumerate(rains):\\n            if v == 0:\\n                if pq: result.append(rains[heappop(pq)])\\n                else: result.append(1)\\n            else:\\n                if (last[v] and last[v][0] < i) or (pq and pq[0] <= i): return []\\n                if len(last[v]) > 1:\\n                    last[v].popleft()\\n                    heappush(pq, last[v][0])\\n                result.append(-1)\\n                \\n        return [] if pq else result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains):\\n        result, pq = [], []\\n        N, last = len(rains), defaultdict(deque)\\n        for i, v in enumerate(rains): last[v].append(i)\\n\\n        for i, v in enumerate(rains):\\n            if v == 0:\\n                if pq: result.append(rains[heappop(pq)])\\n                else: result.append(1)\\n            else:\\n                if (last[v] and last[v][0] < i) or (pq and pq[0] <= i): return []\\n                if len(last[v]) > 1:\\n                    last[v].popleft()\\n                    heappush(pq, last[v][0])\\n                result.append(-1)\\n                \\n        return [] if pq else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883736,
                "title": "fix-set-tle-solution-in-no-time-c-solution-using-set",
                "content": "# Time Complexity of lower_bound\\n**it = lower_bound(st.begin(),st.end(),tmp)**\\nThis is a regular operation for vectors, arrays, etc. It only works in log N if you can \"jump\" to a random place in O(1). For example, I can look at the x-th element of an array by using array[x-1] in O(1).\\n\\n**it = st.lower_bound(tmp)**\\nThis is a special function for sets, multisets, maps, etc. It uses a special walk through the tree that C++ constructs for you, which has log N complexity. If you use the first method, it will get TLE because you can\\'t \"jump\" to the x-th element of the set in O(1).\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to dry only those lakes that are causing floods. If the lake is already filled, then only it is causing floods. So, we have to dry this before hand.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI am using the notRainedOnIndex set to get the index of the days on which it has not rained. I am using the rainedOnValue set to determine which lakes are already filled and using valueToIndex map to find the index using the lake value.\\n\\n- Check whether it rained that day or not.\\n- If it has not rained, then store the index for future reference.\\n- If it has rained, then check whether this lake is already filled or not.\\n- If it is already filled, then find out whether there are any day on which it has not rained after the lake is filled.\\n- If there are none, then return an empty array.\\n- Otherwise, dry the lake, which means set the lake value on that index and erase this index from the set as well.\\n- If there are indexes left in the set, then assign them with any lake number present in the rains array.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        int n = rains.size(),num=1;\\n        set<int> notRainedOnIndex, rainedOnValue;\\n        map<int,int> valueToIndex;\\n        for(int i=0;i<n;i++)\\n        {\\n            int a = rains[i];\\n            if(a==0)\\n            {\\n                notRainedOnIndex.insert(i);\\n            }\\n            else {\\n                num = a;\\n                if(rainedOnValue.find(a)!=rainedOnValue.end())\\n                {\\n                    int ind = valueToIndex[a];\\n                    auto it = notRainedOnIndex.lower_bound(ind);\\n                    if(it==notRainedOnIndex.end())\\n                        return {};\\n                    rains[*it] = a;\\n                    notRainedOnIndex.erase(*it);\\n                }\\n                rainedOnValue.insert(a);\\n                valueToIndex[a] = i;\\n                rains[i] = -1;\\n            }\\n        }\\n        \\n        for(auto a:notRainedOnIndex)\\n        {\\n            rains[a] = num;\\n        }\\n        return rains;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        int n = rains.size(),num=1;\\n        set<int> notRainedOnIndex, rainedOnValue;\\n        map<int,int> valueToIndex;\\n        for(int i=0;i<n;i++)\\n        {\\n            int a = rains[i];\\n            if(a==0)\\n            {\\n                notRainedOnIndex.insert(i);\\n            }\\n            else {\\n                num = a;\\n                if(rainedOnValue.find(a)!=rainedOnValue.end())\\n                {\\n                    int ind = valueToIndex[a];\\n                    auto it = notRainedOnIndex.lower_bound(ind);\\n                    if(it==notRainedOnIndex.end())\\n                        return {};\\n                    rains[*it] = a;\\n                    notRainedOnIndex.erase(*it);\\n                }\\n                rainedOnValue.insert(a);\\n                valueToIndex[a] = i;\\n                rains[i] = -1;\\n            }\\n        }\\n        \\n        for(auto a:notRainedOnIndex)\\n        {\\n            rains[a] = num;\\n        }\\n        return rains;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838192,
                "title": "set-and-map-greedy",
                "content": "\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int,int>cnt;\\n        int nxt[rains.size()+1];\\n        int num = -1; \\n        for(int i = rains.size()-1;i>=0;i--){\\n            if(rains[i] > 0) num = rains[i];\\n\\n            if(cnt[rains[i]] == 0 || rains[i] == 0){\\n                nxt[i] = -1;\\n            }\\n            else {\\n                nxt[i] = cnt[rains[i]];\\n            }\\n            cnt[rains[i]] = i;\\n        }\\n        // for(int i =0 ;i<rains.size();i++)cout<<nxt[i]<<\" \";\\n        // cout<<endl;\\n\\n        set<int>s;\\n        vector<int>ans;\\n        cnt.clear();\\n        // unordered_map<int,int>cnt;\\n        int j = 0;\\n        for(auto i : rains){\\n            if(i > 0 && cnt[i] >= 1){\\n                ans.clear();\\n                break;\\n            }\\n            if(i == 0){\\n                if(s.size()){\\n                    int p = (*s.begin());\\n                    ans.push_back(rains[p]);\\n                    // cout<<p.first<<\" \"<<p.second<<endl;\\n                    cnt[rains[p]]--;\\n                    s.erase(s.begin());\\n                }\\n                else ans.push_back(num);\\n                j++;\\n            }\\n            else {\\n                cnt[i]++;\\n                ans.push_back(-1);\\n                j++;\\n                if(nxt[j-1] == -1)continue;\\n                s.insert(nxt[j-1]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int,int>cnt;\\n        int nxt[rains.size()+1];\\n        int num = -1; \\n        for(int i = rains.size()-1;i>=0;i--){\\n            if(rains[i] > 0) num = rains[i];\\n\\n            if(cnt[rains[i]] == 0 || rains[i] == 0){\\n                nxt[i] = -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3837295,
                "title": "easy-to-understand-javascript-solution-hash-table-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} rains\\n * @return {number[]}\\n */\\nvar avoidFlood = function(rains) {\\n    const fullLakeMap = new Map();\\n    const dryDays = [];\\n    const result = [];\\n    const searchDryDay = (day) => {\\n        if (dryDays.at(-1) < day) return -1; \\n        let start = 0;\\n        let end = dryDays.length - 1;\\n\\n        while (start < end) {\\n            const mid = Math.floor((start + end) / 2);\\n\\n            dryDays[mid] < day ? start = mid + 1 : end = mid;\\n        }\\n        return start;\\n    };\\n\\n    for (let index = 0; index < rains.length; index++) {\\n        const lake = rains[index];\\n\\n        if (!lake) {\\n            dryDays.push(index);\\n            result[index] = 1;\\n            continue;\\n        }\\n        if (fullLakeMap.has(lake)) {\\n            if (!dryDays.length) return [];\\n            const fullDay = fullLakeMap.get(lake);\\n            const dryIndex = searchDryDay(fullDay);\\n            if (dryIndex < 0) return [];\\n            const [dryDay] = dryDays.splice(dryIndex, 1);\\n \\n            result[dryDay] = lake;\\n            fullLakeMap.delete(lake);\\n        }\\n        fullLakeMap.set(lake, index);\\n        result[index] = -1;\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} rains\\n * @return {number[]}\\n */\\nvar avoidFlood = function(rains) {\\n    const fullLakeMap = new Map();\\n    const dryDays = [];\\n    const result = [];\\n    const searchDryDay = (day) => {\\n        if (dryDays.at(-1) < day) return -1; \\n        let start = 0;\\n        let end = dryDays.length - 1;\\n\\n        while (start < end) {\\n            const mid = Math.floor((start + end) / 2);\\n\\n            dryDays[mid] < day ? start = mid + 1 : end = mid;\\n        }\\n        return start;\\n    };\\n\\n    for (let index = 0; index < rains.length; index++) {\\n        const lake = rains[index];\\n\\n        if (!lake) {\\n            dryDays.push(index);\\n            result[index] = 1;\\n            continue;\\n        }\\n        if (fullLakeMap.has(lake)) {\\n            if (!dryDays.length) return [];\\n            const fullDay = fullLakeMap.get(lake);\\n            const dryIndex = searchDryDay(fullDay);\\n            if (dryIndex < 0) return [];\\n            const [dryDay] = dryDays.splice(dryIndex, 1);\\n \\n            result[dryDay] = lake;\\n            fullLakeMap.delete(lake);\\n        }\\n        fullLakeMap.set(lake, index);\\n        result[index] = -1;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786450,
                "title": "one-of-the-optimal-solution-by-gaurav-badola",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        Map<Integer, Integer>map=new HashMap<>();\\n        TreeSet<Integer>zeros = new TreeSet<>();\\n        int[] res = new int[rains.length];\\n        for(int i=0; i< rains.length; i++){\\n            if(rains[i]==0){\\n                zeros.add(i);\\n            }\\n            else{\\n                if(map.containsKey(rains[i])){\\n                    Integer next = zeros.ceiling(map.get(rains[i]));\\n                    if(next==null) return new int[0];\\n                    res[next]=rains[i];\\n                    zeros.remove(next);\\n                }\\n                res[i]=-1;\\n                map.put(rains[i],i);\\n            }\\n        }\\n        for(int i:zeros) res[i]=1;\\n        return res;\\n     \\n  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        Map<Integer, Integer>map=new HashMap<>();\\n        TreeSet<Integer>zeros = new TreeSet<>();\\n        int[] res = new int[rains.length];\\n        for(int i=0; i< rains.length; i++){\\n            if(rains[i]==0){\\n                zeros.add(i);\\n            }\\n            else{\\n                if(map.containsKey(rains[i])){\\n                    Integer next = zeros.ceiling(map.get(rains[i]));\\n                    if(next==null) return new int[0];\\n                    res[next]=rains[i];\\n                    zeros.remove(next);\\n                }\\n                res[i]=-1;\\n                map.put(rains[i],i);\\n            }\\n        }\\n        for(int i:zeros) res[i]=1;\\n        return res;\\n     \\n  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748408,
                "title": "c-python-priority-queue-ordered-set",
                "content": "For each element find its next right and store it in an array. Keep a map to store count of elements. Whenever we have a zero, get the latest right index from the priority queue. Keep updating map alongside. If at some time count of any element is greater than 1, return [] . Also if our heap is empty , we add 1st lake and it doesn\\'t matter if its filled or empty. \\nPython code is using heap and 2 C++ codes using priority queue and set.\\nTime Complexity - O(n * logn)\\nSpace Compleity - O(n)\\n\\nPython Code:\\n\\n```\\nclass Solution:\\n    def avoidFlood(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        cnt=Counter()\\n        right,mp,ans,heap=[-1]*n,{},[],[]\\n        for i in range(n-1,-1,-1):\\n            right[i]=mp.get(nums[i],-1)\\n            mp[nums[i]]=i\\n        for i in range(n):\\n            if nums[i]>0:\\n                if right[i]>0: heappush(heap,right[i])\\n                cnt[nums[i]]+=1\\n                if cnt[nums[i]]>1: return []\\n                ans.append(-1)\\n                continue\\n            if heap: \\n                idx=heappop(heap)\\n                ans.append(nums[idx])\\n                cnt[nums[idx]]=0\\n            else:\\n                ans.append(1)\\n        return ans\\n            \\n                \\n            \\n```\\n\\nC++ Code using Priority Queue:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans,right(n,-1);\\n        unordered_map<int,int> cnt,mp;\\n        priority_queue<int> pq;\\n        for (int i=n-1;i>=0;i--){\\n            if (mp.find(nums[i])!=mp.end()) right[i]=mp[nums[i]];\\n            mp[nums[i]]=i;\\n        }\\n        for (int i=0;i<n;i++){\\n            if (nums[i]>0){\\n                if (right[i]>0) pq.push(-right[i]);\\n                cnt[nums[i]]++;\\n                if (cnt[nums[i]]>1) return {};\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            int idx;\\n            if (!pq.empty()) {\\n                idx=-pq.top(); \\n                pq.pop(); \\n                ans.push_back(nums[idx]); \\n                cnt[nums[idx]]=0;\\n            }\\n            else ans.push_back(1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nC++ Code using Ordered Set:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans,right(n,-1);\\n        unordered_map<int,int> cnt,mp;\\n        set<int> pq;\\n        for (int i=n-1;i>=0;i--){\\n            if (mp.find(nums[i])!=mp.end()) right[i]=mp[nums[i]];\\n            mp[nums[i]]=i;\\n        }\\n        for (int i=0;i<n;i++){\\n            if (nums[i]>0){\\n                if (right[i]>0) pq.insert(right[i]);\\n                cnt[nums[i]]++;\\n                if (cnt[nums[i]]>1) return {};\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            int idx;\\n            if (!pq.empty()) {\\n                idx=*pq.begin(); \\n                pq.erase(pq.begin()); \\n                ans.push_back(nums[idx]); \\n                cnt[nums[idx]]=0;\\n            }\\n            else ans.push_back(1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        cnt=Counter()\\n        right,mp,ans,heap=[-1]*n,{},[],[]\\n        for i in range(n-1,-1,-1):\\n            right[i]=mp.get(nums[i],-1)\\n            mp[nums[i]]=i\\n        for i in range(n):\\n            if nums[i]>0:\\n                if right[i]>0: heappush(heap,right[i])\\n                cnt[nums[i]]+=1\\n                if cnt[nums[i]]>1: return []\\n                ans.append(-1)\\n                continue\\n            if heap: \\n                idx=heappop(heap)\\n                ans.append(nums[idx])\\n                cnt[nums[idx]]=0\\n            else:\\n                ans.append(1)\\n        return ans\\n            \\n                \\n            \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans,right(n,-1);\\n        unordered_map<int,int> cnt,mp;\\n        priority_queue<int> pq;\\n        for (int i=n-1;i>=0;i--){\\n            if (mp.find(nums[i])!=mp.end()) right[i]=mp[nums[i]];\\n            mp[nums[i]]=i;\\n        }\\n        for (int i=0;i<n;i++){\\n            if (nums[i]>0){\\n                if (right[i]>0) pq.push(-right[i]);\\n                cnt[nums[i]]++;\\n                if (cnt[nums[i]]>1) return {};\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            int idx;\\n            if (!pq.empty()) {\\n                idx=-pq.top(); \\n                pq.pop(); \\n                ans.push_back(nums[idx]); \\n                cnt[nums[idx]]=0;\\n            }\\n            else ans.push_back(1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans,right(n,-1);\\n        unordered_map<int,int> cnt,mp;\\n        set<int> pq;\\n        for (int i=n-1;i>=0;i--){\\n            if (mp.find(nums[i])!=mp.end()) right[i]=mp[nums[i]];\\n            mp[nums[i]]=i;\\n        }\\n        for (int i=0;i<n;i++){\\n            if (nums[i]>0){\\n                if (right[i]>0) pq.insert(right[i]);\\n                cnt[nums[i]]++;\\n                if (cnt[nums[i]]>1) return {};\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            int idx;\\n            if (!pq.empty()) {\\n                idx=*pq.begin(); \\n                pq.erase(pq.begin()); \\n                ans.push_back(nums[idx]); \\n                cnt[nums[idx]]=0;\\n            }\\n            else ans.push_back(1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738233,
                "title": "avoiding-floods-in-a-city-with-lakes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem presents a scenario with an infinite number of lakes in a country, and how rain affects these lakes. When it rains, a lake fills up with water. If it rains over a lake already full, it will flood. On days with no rain, a choice can be made to dry a lake. Our task is to determine a sequence of lakes to dry on non-rainy days such that no flooding occurs.\\n\\nInitially, it is clear that we will mark rainy days with -1, since we cannot dry any lakes on these days. For dry days, the challenge is to decide which lake to dry so as to avoid flooding in the future.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution involves tracking the last rainy day for each lake and the available dry days where action can be taken. For this, an unordered map and a set data structure are used respectively.\\n\\nWhen iterating through the input array, if it\\'s a rainy day, we check if it rained on this lake before. If so, we must dry this lake on a day between its previous rainy day and today. We use a set (which stores dry days) to find a suitable day and mark this day with the lake number. If no such day exists, it implies that we cannot prevent flood, hence we return an empty vector.\\n\\nFor each non-rainy day, we simply store it in the set of dry days, which is used later to find suitable days to dry lakes. If any dry days are left after this procedure, we can dry any arbitrary lake (denoted by 1 in this case) on these days.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n log n), where n is the number of days. This is because we iterate through the array once, and for each rainy day, we perform a binary search (lower_bound operation) in the set of dry days, which takes O(log n) time.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n), where n is the number of days. This is due to the space used by the result vector, the unordered map to store the last rainy day of each lake, and the set to store dry days.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int, int> lastRainDay;\\n        set<int> dryDays;\\n        vector<int> res(rains.size(), 1);\\n        \\n        for(int i=0; i<rains.size(); i++) {\\n            int lake = rains[i];\\n            \\n            if(lake != 0) {\\n                if(lastRainDay.count(lake)) {\\n                    auto it = dryDays.lower_bound(lastRainDay[lake]);\\n                    if(it == dryDays.end()) return {};\\n                    \\n                    int dryDay = *it;\\n                    dryDays.erase(it);\\n                    res[dryDay] = lake;\\n                }\\n                \\n                lastRainDay[lake] = i;\\n                res[i] = -1;\\n            }\\n            else {\\n                dryDays.insert(i);\\n            }\\n        }\\n        \\n        for(auto day : dryDays) {\\n            res[day] = 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        unordered_map<int, int> lastRainDay;\\n        set<int> dryDays;\\n        vector<int> res(rains.size(), 1);\\n        \\n        for(int i=0; i<rains.size(); i++) {\\n            int lake = rains[i];\\n            \\n            if(lake != 0) {\\n                if(lastRainDay.count(lake)) {\\n                    auto it = dryDays.lower_bound(lastRainDay[lake]);\\n                    if(it == dryDays.end()) return {};\\n                    \\n                    int dryDay = *it;\\n                    dryDays.erase(it);\\n                    res[dryDay] = lake;\\n                }\\n                \\n                lastRainDay[lake] = i;\\n                res[i] = -1;\\n            }\\n            else {\\n                dryDays.insert(i);\\n            }\\n        }\\n        \\n        for(auto day : dryDays) {\\n            res[day] = 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718200,
                "title": "easy-java-solution-intuitive-solution-hashmap-tree-set-upvote",
                "content": "# Intuition\\nif raining for the first time, we store its index in map so that if it appears again, we need to keep the lake dry so that it will not flood again. So we will keep update of the dry between both of the them so that we can you that dry day to dry that lake where rain again gonna come. So to keep track of dry day I am using tree set. \\n\\n# Code\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> zero = new TreeSet<>();\\n\\n        int[] res = new int[rains.length];\\n        Arrays.fill(res, -1);\\n\\n        for(int i = 0; i < rains.length;i++){\\n            if(rains[i] == 0){\\n                zero.add(i);\\n            }\\n            else{\\n                if(map.containsKey(rains[i])){\\n                    Integer next = zero.ceiling(map.get(rains[i]));\\n                    if(next == null) return new int[0];\\n                    res[next] = rains[i];\\n                    zero.remove(next); \\n                }\\n                map.put(rains[i], i);\\n            }\\n        }\\n        for (int i : zero) res[i] = 1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        TreeSet<Integer> zero = new TreeSet<>();\\n\\n        int[] res = new int[rains.length];\\n        Arrays.fill(res, -1);\\n\\n        for(int i = 0; i < rains.length;i++){\\n            if(rains[i] == 0){\\n                zero.add(i);\\n            }\\n            else{\\n                if(map.containsKey(rains[i])){\\n                    Integer next = zero.ceiling(map.get(rains[i]));\\n                    if(next == null) return new int[0];\\n                    res[next] = rains[i];\\n                    zero.remove(next); \\n                }\\n                map.put(rains[i], i);\\n            }\\n        }\\n        for (int i : zero) res[i] = 1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711682,
                "title": "java-solution-using-hashmap-and-treeset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int n=rains.length;\\n         int[] ans= new int[rains.length];\\n       HashMap<Integer, Integer> map= new HashMap<>();\\n       TreeSet<Integer> set= new TreeSet<>();\\n\\n       for(int i=0; i<n; i++){\\n           if(rains[i]==0){\\n               set.add(i);\\n           }else{\\n\\n            if(map.containsKey(rains[i])){\\n                int idx= map.get(rains[i]);\\n              if(set.size()>0){\\n              \\n               if(set.ceiling(idx)==null){\\n                        return new int[0];\\n                }else if(set.ceiling(idx)!=null){\\n                    int ceil= set.ceiling(idx);\\n                    ans[ceil]= rains[i];\\n                    ans[i]=-1;\\n                    map.remove(rains[i]);\\n                    map.put(rains[i], i);\\n                    set.remove(ceil);\\n                }\\n              }else{\\n                   return new int[0];\\n              }\\n            }else{\\n\\n               ans[i]=-1;\\n               map.put(rains[i],i);\\n            }\\n\\n           }\\n       }\\n       if(set.size()>0){\\n          for(int i: set){\\n              ans[i]=1;\\n          }\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int n=rains.length;\\n         int[] ans= new int[rains.length];\\n       HashMap<Integer, Integer> map= new HashMap<>();\\n       TreeSet<Integer> set= new TreeSet<>();\\n\\n       for(int i=0; i<n; i++){\\n           if(rains[i]==0){\\n               set.add(i);\\n           }else{\\n\\n            if(map.containsKey(rains[i])){\\n                int idx= map.get(rains[i]);\\n              if(set.size()>0){\\n              \\n               if(set.ceiling(idx)==null){\\n                        return new int[0];\\n                }else if(set.ceiling(idx)!=null){\\n                    int ceil= set.ceiling(idx);\\n                    ans[ceil]= rains[i];\\n                    ans[i]=-1;\\n                    map.remove(rains[i]);\\n                    map.put(rains[i], i);\\n                    set.remove(ceil);\\n                }\\n              }else{\\n                   return new int[0];\\n              }\\n            }else{\\n\\n               ans[i]=-1;\\n               map.put(rains[i],i);\\n            }\\n\\n           }\\n       }\\n       if(set.size()>0){\\n          for(int i: set){\\n              ans[i]=1;\\n          }\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693938,
                "title": "c-solution-using-set-and-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int>ans(rains.size(),-1);\\n        unordered_map<int,int>lake;\\n        set<int>dryday;\\n\\n        for(int i=0;i<rains.size();i++)\\n        {\\n            if(rains[i]==0)\\n            {\\n                ans[i]=1;\\n                dryday.insert(i);\\n            }\\n\\n            else\\n            {\\n                if(lake.count(rains[i]))\\n                {\\n                    int prev_day = lake[rains[i]];\\n                    auto dry_day = dryday.upper_bound(prev_day);\\n                    if( dry_day == dryday.end())\\n                    {\\n                      return {};\\n                    }\\n\\n                    ans[*dry_day] = rains[i];\\n                    dryday.erase( dry_day);\\n                    \\n                }\\n             lake[rains[i]] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int>ans(rains.size(),-1);\\n        unordered_map<int,int>lake;\\n        set<int>dryday;\\n\\n        for(int i=0;i<rains.size();i++)\\n        {\\n            if(rains[i]==0)\\n            {\\n                ans[i]=1;\\n                dryday.insert(i);\\n            }\\n\\n            else\\n            {\\n                if(lake.count(rains[i]))\\n                {\\n                    int prev_day = lake[rains[i]];\\n                    auto dry_day = dryday.upper_bound(prev_day);\\n                    if( dry_day == dryday.end())\\n                    {\\n                      return {};\\n                    }\\n\\n                    ans[*dry_day] = rains[i];\\n                    dryday.erase( dry_day);\\n                    \\n                }\\n             lake[rains[i]] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653150,
                "title": "c-using-set-unordered-map-binary-search-lower-bound",
                "content": "```\\n/**\\n * The Solution class provides a method `avoidFlood` to handle the task of avoiding floods in a sequence of rainy days.\\n */\\nclass Solution {\\npublic:\\n  /**\\n   * This function takes a vector of integers representing the sequence of rainy days and returns a vector of integers representing the actions taken to avoid floods.\\n   *\\n   * @param rains The vector of integers representing the sequence of rainy days. Each integer represents the lake index where rain occurred, or 0 if no rain occurred on that day.\\n   * @return A vector of integers representing the actions taken to avoid floods. Each integer represents either a positive value (indicating that no rain occurred) or a negative value (indicating the lake index where water was transferred to avoid flooding).\\n   */\\n  vector<int> avoidFlood(vector<int>& rains) {\\n    // Map to store the last day when rain occurred for each lake\\n    unordered_map<int, int> mp;\\n\\n    // Set to store the days when no rain occurs\\n    set<int> s;\\n\\n    vector<int> ans;\\n\\n    // Iterate over each day in the rains vector\\n    for (int day = 0; day < rains.size(); day++) {\\n      // If no rain occurs on the current day\\n      if (rains[day] == 0) {\\n        // Insert the day into the set of days without rain\\n        s.insert(day);\\n        // Push a positive value (1) to the answer vector indicating no rain occurred\\n        ans.push_back(1);\\n      } else {\\n        // If rain occurs on the current day\\n        // Check if rain occurred for the particular lake before\\n        if (mp.count(rains[day])) {\\n          // If rain occurred for that lake before, check if there is a day without rain after the previous occurrence\\n          if (s.lower_bound(mp[rains[day]]) != s.end()) {\\n            // If a day without rain is found, transfer the water to the particular lake and remove that day from the set\\n            auto idx = s.lower_bound(mp[rains[day]]);\\n            ans[*idx] = rains[day];\\n            s.erase(*idx);\\n          } else {\\n            // If there is no day without rain after the previous occurrence, it is not possible to avoid flood\\n            return {};\\n          }\\n        }\\n        // Map the particular lake with the current day\\n        mp[rains[day]] = day;\\n        // Push a negative value (-1) to the answer vector indicating rain occurred\\n        ans.push_back(-1);\\n      }\\n    }\\n\\n    // Return the final answer vector\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * The Solution class provides a method `avoidFlood` to handle the task of avoiding floods in a sequence of rainy days.\\n */\\nclass Solution {\\npublic:\\n  /**\\n   * This function takes a vector of integers representing the sequence of rainy days and returns a vector of integers representing the actions taken to avoid floods.\\n   *\\n   * @param rains The vector of integers representing the sequence of rainy days. Each integer represents the lake index where rain occurred, or 0 if no rain occurred on that day.\\n   * @return A vector of integers representing the actions taken to avoid floods. Each integer represents either a positive value (indicating that no rain occurred) or a negative value (indicating the lake index where water was transferred to avoid flooding).\\n   */\\n  vector<int> avoidFlood(vector<int>& rains) {\\n    // Map to store the last day when rain occurred for each lake\\n    unordered_map<int, int> mp;\\n\\n    // Set to store the days when no rain occurs\\n    set<int> s;\\n\\n    vector<int> ans;\\n\\n    // Iterate over each day in the rains vector\\n    for (int day = 0; day < rains.size(); day++) {\\n      // If no rain occurs on the current day\\n      if (rains[day] == 0) {\\n        // Insert the day into the set of days without rain\\n        s.insert(day);\\n        // Push a positive value (1) to the answer vector indicating no rain occurred\\n        ans.push_back(1);\\n      } else {\\n        // If rain occurs on the current day\\n        // Check if rain occurred for the particular lake before\\n        if (mp.count(rains[day])) {\\n          // If rain occurred for that lake before, check if there is a day without rain after the previous occurrence\\n          if (s.lower_bound(mp[rains[day]]) != s.end()) {\\n            // If a day without rain is found, transfer the water to the particular lake and remove that day from the set\\n            auto idx = s.lower_bound(mp[rains[day]]);\\n            ans[*idx] = rains[day];\\n            s.erase(*idx);\\n          } else {\\n            // If there is no day without rain after the previous occurrence, it is not possible to avoid flood\\n            return {};\\n          }\\n        }\\n        // Map the particular lake with the current day\\n        mp[rains[day]] = day;\\n        // Push a negative value (-1) to the answer vector indicating rain occurred\\n        ans.push_back(-1);\\n      }\\n    }\\n\\n    // Return the final answer vector\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649556,
                "title": "sagar-easy",
                "content": "\\n    class Solution {\\n    public:\\n        vector<int> avoidFlood(vector<int>& rains) \\n        {\\n            map<int,int> mpp;\\n            set<int> st;\\n            int n=rains.size();\\n\\n            vector<int> ans(n,-1);\\n            for(int i=0;i<n;i++)\\n            {\\n                int lake=rains[i];\\n                if(lake!=0)\\n                {\\n                    if(mpp.count(lake)>0)\\n                    {\\n                        int pre=mpp[lake];\\n                        auto idx=st.upper_bound(pre);\\n                        if(idx==st.end())\\n                        {\\n                            return {};\\n                        }\\n                        ans[*idx]=rains[i];\\n                        st.erase(*idx);\\n                    }\\n                    mpp[lake]=i;\\n                }\\n                else\\n                {\\n                    ans[i]=1;\\n                    st.insert(i);\\n                }\\n            } \\n            return ans;   \\n        }\\n    };\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> avoidFlood(vector<int>& rains) \\n        {\\n            map<int,int> mpp;\\n            set<int> st;\\n            int n=rains.size();\\n\\n            vector<int> ans(n,-1);\\n            for(int i=0;i<n;i++)\\n            {\\n                int lake=rains[i];\\n                if(lake!=0)\\n                {\\n                    if(mpp.count(lake)>0)\\n                    {\\n                        int pre=mpp[lake];\\n                        auto idx=st.upper_bound(pre);\\n                        if(idx==st.end())\\n                        {\\n                            return {}",
                "codeTag": "Java"
            },
            {
                "id": 3643018,
                "title": "c-solution-binary-search-map",
                "content": "# EXPLANATION\\nWe created map to store lake number and index in it.\\nVector **dry** to store index of no rain to dry.\\nCreated vector **v** for answer.\\nIterated through rains vector.\\nIf we found the it has rained in a lake before we check if we can dry the lake or not, here we use binary search in it.\\nIf we found a day left to dry we update the value in **dry**, **v** and update in map the current lake index, and if we did not find a dry day we return empty vector.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        int n=rains.size();\\n        unordered_map<int,int> m;\\n        vector<int> dry;\\n        vector<int> v(n,1);\\n        for(int i=0;i<n;i++){\\n            if(rains[i]==0)\\n                dry.push_back(i);\\n            else{\\n                v[i]=-1;\\n                if(m.find(rains[i])==m.end())\\n                    m[rains[i]]=i;\\n                else{\\n                    auto x=lower_bound(dry.begin(),dry.end(),m[rains[i]])-dry.begin();\\n                    if(x==dry.size())\\n                        return {};\\n                    v[dry[x]]=rains[i];\\n                    dry.erase(dry.begin()+x);\\n                    m[rains[i]]=i;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        int n=rains.size();\\n        unordered_map<int,int> m;\\n        vector<int> dry;\\n        vector<int> v(n,1);\\n        for(int i=0;i<n;i++){\\n            if(rains[i]==0)\\n                dry.push_back(i);\\n            else{\\n                v[i]=-1;\\n                if(m.find(rains[i])==m.end())\\n                    m[rains[i]]=i;\\n                else{\\n                    auto x=lower_bound(dry.begin(),dry.end(),m[rains[i]])-dry.begin();\\n                    if(x==dry.size())\\n                        return {};\\n                    v[dry[x]]=rains[i];\\n                    dry.erase(dry.begin()+x);\\n                    m[rains[i]]=i;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615349,
                "title": "java-clean-and-simple",
                "content": "# Approach\\n1. Keep track of the full lakes in a Map<Integer, Integer>: lake and index\\n2. Also keep track of the days with 0 rains to know their index (treeset)\\n3. If a dry day, add it to treeset\\n4. If rainy day, add it to map. (and set answer[i] = -1)\\n    - If the entry (lake and index) was already there, it means the lake was full.\\n    - Look inside the treeset of days to dry for a day with index >= entry lake.\\n   - If a day past that lake full day is found, then dry the lake so that it can be filled now. (answer[entry.value]= current_day)\\n    - If no such day is present (eg: all dry days were before that day), we cannot dry that lake. Return []\\n5. Populate answer[] with 1 for the rest of dry days from the tree set.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O$$(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int[] answer =  new int[rains.length];\\n        Map<Integer, Integer> fullLakes = new HashMap<>();\\n        TreeSet<Integer> daysToDry = new TreeSet<>();\\n        for (int i = 0; i < rains.length; i++) {\\n            if (rains[i] == 0) {\\n                daysToDry.add(i);\\n            } else {\\n                answer[i] = -1;\\n                Integer index = fullLakes.put(rains[i], i);\\n                if (index != null) {\\n                    if (daysToDry.isEmpty()) {\\n                        return new int[0];\\n                    } \\n                    Integer nextDayToDry = daysToDry.ceiling(index);\\n                    if (nextDayToDry == null) {\\n                        return new int[0];\\n                    } else {\\n                        daysToDry.remove(nextDayToDry);\\n                        answer[nextDayToDry] = rains[i];\\n                    }\\n                }\\n            }\\n        }\\n        daysToDry.forEach(entry -> answer[entry] = 1);\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int[] answer =  new int[rains.length];\\n        Map<Integer, Integer> fullLakes = new HashMap<>();\\n        TreeSet<Integer> daysToDry = new TreeSet<>();\\n        for (int i = 0; i < rains.length; i++) {\\n            if (rains[i] == 0) {\\n                daysToDry.add(i);\\n            } else {\\n                answer[i] = -1;\\n                Integer index = fullLakes.put(rains[i], i);\\n                if (index != null) {\\n                    if (daysToDry.isEmpty()) {\\n                        return new int[0];\\n                    } \\n                    Integer nextDayToDry = daysToDry.ceiling(index);\\n                    if (nextDayToDry == null) {\\n                        return new int[0];\\n                    } else {\\n                        daysToDry.remove(nextDayToDry);\\n                        answer[nextDayToDry] = rains[i];\\n                    }\\n                }\\n            }\\n        }\\n        daysToDry.forEach(entry -> answer[entry] = 1);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513735,
                "title": "use-javascript-to-avoid-floods",
                "content": "# Intuition\\nThe problem requires preventing floods in lakes by strategically choosing dry days to empty the lakes. We need to track the last day each lake became full and select appropriate dry days for each lake. To efficiently find the minimum dry day for each lake, we can use binary search.\\n\\n# Approach\\nInitialize an array ans to store the final solution.\\nInitialize an empty queue q to store available dry days.\\nCreate an empty object fulllake to track the last day each lake became full.\\nIterate over the rains array:\\nFor each day i:\\nCheck if it rained on that day (rains[i] > 0).\\nIf it rained:\\nCheck if the lake ID rains[i] exists in fulllake. If it does, find the minimum dry day in q using binary search.\\nUpdate the solution by setting ans[q[best] - 1] to the current lake ID rains[i].\\nUpdate fulllake to record that the current lake became full on day i + 1.\\nSet the element at index best in q to -1.\\nIf it didn\\'t rain (rains[i] == 0):\\nSet the element at index i in ans to 1 and push i + 1 to q.\\nReturn the ans array as the final solution.\\n\\n# Complexity\\nTime complexity: The algorithm iterates over the rains array once and performs binary search operations. The time complexity is O(n log m), where n is the length of the rains array and m is the length of q.\\n\\nSpace complexity: The algorithm uses additional space for ans, q, and fulllake. The space complexity is O(n), where n is the length of the rains array.\\n\\n\\n# Code\\n```\\nconst avoidFlood = (rains) => {\\n  const n = rains.length;\\n  let ans = new Array(n).fill(-1);\\n  let q = []; // queue to store the list of dry days\\n  let fulllake = {};\\n\\n  for (let i = 0; i < rains.length; i++) {\\n    const lakeId = rains[i];\\n\\n    if (lakeId > 0) {\\n      if (fulllake[lakeId]) {\\n        if (q.length === 0) return [];\\n\\n        let l = 0,\\n          r = q.length - 1,\\n          best = -1;\\n\\n        while (l <= r) {\\n          const mid = Math.floor((l + r) / 2);\\n          if (q[mid] > fulllake[lakeId]) {\\n            best = mid;\\n            r = mid - 1;\\n          } else {\\n            l = mid + 1;\\n          }\\n        }\\n\\n        if (best === -1) return [];\\n        ans[q[best] - 1] = lakeId;\\n        fulllake[lakeId] = i + 1;\\n        q[best] = -1;\\n      } else {\\n        fulllake[lakeId] = i + 1;\\n      }\\n    } else {\\n      ans[i] = 1;\\n      q.push(i + 1);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```\\n\\n# [Follow on medium](https://medium.com/@HansOnCoding) for the tutorial!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst avoidFlood = (rains) => {\\n  const n = rains.length;\\n  let ans = new Array(n).fill(-1);\\n  let q = []; // queue to store the list of dry days\\n  let fulllake = {};\\n\\n  for (let i = 0; i < rains.length; i++) {\\n    const lakeId = rains[i];\\n\\n    if (lakeId > 0) {\\n      if (fulllake[lakeId]) {\\n        if (q.length === 0) return [];\\n\\n        let l = 0,\\n          r = q.length - 1,\\n          best = -1;\\n\\n        while (l <= r) {\\n          const mid = Math.floor((l + r) / 2);\\n          if (q[mid] > fulllake[lakeId]) {\\n            best = mid;\\n            r = mid - 1;\\n          } else {\\n            l = mid + 1;\\n          }\\n        }\\n\\n        if (best === -1) return [];\\n        ans[q[best] - 1] = lakeId;\\n        fulllake[lakeId] = i + 1;\\n        q[best] = -1;\\n      } else {\\n        fulllake[lakeId] = i + 1;\\n      }\\n    } else {\\n      ans[i] = 1;\\n      q.push(i + 1);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3474515,
                "title": "python3-heap-beats-94",
                "content": "1) Keep dry days sorted\\n2) Dry the lake when it rains again on the same lake\\n3) Edit the array in-place with no extra space\\n\\nTime Complexity $$O(n*log(n))$$\\nSpace Complexity $$O(n)$$\\n### Python\\n```py3\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        lastlake = defaultdict(int) # last index of the lake filled\\n        dry = [] # indexes of dry days\\n        for i, lake in enumerate(rains):\\n            if lake == 0: # no rain\\n                rains[i] = 1 # random lake dried\\n                heappush(dry, i) # dry days are sorted\\n            else:\\n                rains[i] = -1 # lake filled\\n                if lake not in lastlake: # new lake\\n                    lastlake[lake] = i\\n                else: # lake full\\n                    t = []\\n                    while dry and dry[0] < lastlake[lake]: # remove dry days before lake was filled and save it\\n                        t.append(heappop(dry))\\n                    if len(dry) == 0: # all dry days happened before this lake was filled so can\\'t dry this lake\\n                        return []\\n                    rains[heappop(dry)] = lake # dry the lake at the first dry day after the lake was filled\\n                    lastlake[lake] = i # update lake index since we dried the previous one\\n                    if t: # add the dry days before this lake back into the heap\\n                        dry += t\\n                        heapify(dry)\\n        return rains\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py3\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        lastlake = defaultdict(int) # last index of the lake filled\\n        dry = [] # indexes of dry days\\n        for i, lake in enumerate(rains):\\n            if lake == 0: # no rain\\n                rains[i] = 1 # random lake dried\\n                heappush(dry, i) # dry days are sorted\\n            else:\\n                rains[i] = -1 # lake filled\\n                if lake not in lastlake: # new lake\\n                    lastlake[lake] = i\\n                else: # lake full\\n                    t = []\\n                    while dry and dry[0] < lastlake[lake]: # remove dry days before lake was filled and save it\\n                        t.append(heappop(dry))\\n                    if len(dry) == 0: # all dry days happened before this lake was filled so can\\'t dry this lake\\n                        return []\\n                    rains[heappop(dry)] = lake # dry the lake at the first dry day after the lake was filled\\n                    lastlake[lake] = i # update lake index since we dried the previous one\\n                    if t: # add the dry days before this lake back into the heap\\n                        dry += t\\n                        heapify(dry)\\n        return rains\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415640,
                "title": "really-interesting-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to predict the future.\\nwhen a dry day comes we have to decide which rains[i] might be flooded in future, which we cannot do without backtracking.\\nthat is why the intuition of storing all the dry days and rainy days in a systematic order comes into mind.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstore the indexes of the dry days first and the last occurence of every rains[i].\\nafter that whenever a rains[i] comes such that it has been already filled we take the last occurance of the rains[i] and search if any dry day has occured after the ith index . if it has then we remove water at that particular day otherwise we just return empty vector {},saying that it is not possible to avoid floods.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int>ans(rains.size(),-1);\\n        unordered_map<int,int>m;\\n        set<int>s;\\n        for(int i=0;i<rains.size();i++){\\n            if(rains[i]==0){\\n                s.insert(i);\\n                ans[i]=1;\\n            }\\n            else{\\n                if(m.count(rains[i])){\\n                    int ind=m[rains[i]];\\n                    auto nextind=s.upper_bound(ind);\\n                    if(nextind==s.end()) return {};\\n                    else{\\n                        ans[*nextind]=rains[i];\\n                        s.erase(nextind);\\n                    }\\n                }\\n                m[rains[i]]=i;\\n            }\\n           \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int>ans(rains.size(),-1);\\n        unordered_map<int,int>m;\\n        set<int>s;\\n        for(int i=0;i<rains.size();i++){\\n            if(rains[i]==0){\\n                s.insert(i);\\n                ans[i]=1;\\n            }\\n            else{\\n                if(m.count(rains[i])){\\n                    int ind=m[rains[i]];\\n                    auto nextind=s.upper_bound(ind);\\n                    if(nextind==s.end()) return {};\\n                    else{\\n                        ans[*nextind]=rains[i];\\n                        s.erase(nextind);\\n                    }\\n                }\\n                m[rains[i]]=i;\\n            }\\n           \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400458,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def avoidFlood(rains: Array[Int]): Array[Int] = {\\n      val n = rains.length\\n      val fullLakes = scala.collection.mutable.Map[Int, Int]()\\n      val dryDays = scala.collection.mutable.Set[Int]()\\n      val res = new Array[Int](n)\\n\\n      for (i <- 0 until n) {\\n        if (rains(i) == 0) {\\n          dryDays += i\\n          res(i) = 1\\n        } else {\\n          val lake = rains(i)\\n          if (fullLakes.contains(lake)) {\\n            val dryDay = dryDays.find(_ > fullLakes(lake)).getOrElse(-1)\\n            if (dryDay == -1) return Array.empty\\n            res(dryDay) = lake\\n            dryDays -= dryDay\\n          }\\n          fullLakes(lake) = i\\n          res(i) = -1\\n        }\\n      }\\n\\n      for (day <- dryDays) res(day) = 1\\n      res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def avoidFlood(rains: Array[Int]): Array[Int] = {\\n      val n = rains.length\\n      val fullLakes = scala.collection.mutable.Map[Int, Int]()\\n      val dryDays = scala.collection.mutable.Set[Int]()\\n      val res = new Array[Int](n)\\n\\n      for (i <- 0 until n) {\\n        if (rains(i) == 0) {\\n          dryDays += i\\n          res(i) = 1\\n        } else {\\n          val lake = rains(i)\\n          if (fullLakes.contains(lake)) {\\n            val dryDay = dryDays.find(_ > fullLakes(lake)).getOrElse(-1)\\n            if (dryDay == -1) return Array.empty\\n            res(dryDay) = lake\\n            dryDays -= dryDay\\n          }\\n          fullLakes(lake) = i\\n          res(i) = -1\\n        }\\n      }\\n\\n      for (day <- dryDays) res(day) = 1\\n      res\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3383324,
                "title": "c-hash-map-hash-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        map<int,int> m;\\n        int n = rains.size();\\n        set<int> idx;\\n        map<int,int> lastIdx;\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(rains[i]==0)\\n            {\\n                idx.insert(i);\\n            }\\n            else if(m[rains[i]]==1)\\n            {\\n                if(idx.size()>0)\\n                {\\n                    auto it = idx.upper_bound(lastIdx[rains[i]]);\\n                    lastIdx[rains[i]] = i;\\n                    if(it!=idx.end())\\n                    {\\n                        ans[*it] = rains[i];\\n                        idx.erase(it);\\n                    }\\n                    else\\n                    {\\n                        m[rains[i]]++;\\n                        if(m[rains[i]]>1)\\n                        return {};\\n                    }\\n                }\\n                else\\n                {\\n                    m[rains[i]]++;\\n                    if(m[rains[i]]>1)\\n                    return {};\\n                }\\n            }\\n            else\\n            {\\n                m[rains[i]]++;\\n                lastIdx[rains[i]] = i;\\n                if(m[rains[i]]>1)\\n                return {};\\n            }\\n        }\\n        \\n        int flg=0;\\n        for(auto &i:m)\\n        {\\n            if(i.second>1)\\n            {\\n                flg = 1;\\n                break;\\n            }\\n        }\\n        if(flg)\\n        return {};\\n        for(auto &i:idx)\\n        {\\n            ans[i] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        map<int,int> m;\\n        int n = rains.size();\\n        set<int> idx;\\n        map<int,int> lastIdx;\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(rains[i]==0)\\n            {\\n                idx.insert(i);\\n            }\\n            else if(m[rains[i]]==1)\\n            {\\n                if(idx.size()>0)\\n                {\\n                    auto it = idx.upper_bound(lastIdx[rains[i]]);\\n                    lastIdx[rains[i]] = i;\\n                    if(it!=idx.end())\\n                    {\\n                        ans[*it] = rains[i];\\n                        idx.erase(it);\\n                    }\\n                    else\\n                    {\\n                        m[rains[i]]++;\\n                        if(m[rains[i]]>1)\\n                        return {};\\n                    }\\n                }\\n                else\\n                {\\n                    m[rains[i]]++;\\n                    if(m[rains[i]]>1)\\n                    return {};\\n                }\\n            }\\n            else\\n            {\\n                m[rains[i]]++;\\n                lastIdx[rains[i]] = i;\\n                if(m[rains[i]]>1)\\n                return {};\\n            }\\n        }\\n        \\n        int flg=0;\\n        for(auto &i:m)\\n        {\\n            if(i.second>1)\\n            {\\n                flg = 1;\\n                break;\\n            }\\n        }\\n        if(flg)\\n        return {};\\n        for(auto &i:idx)\\n        {\\n            ans[i] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339115,
                "title": "keep-track-of-next-rainy-day-of-full-lakes",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        map<int, vector<int>> rainy_days; // list of rainy days for each lake\\n        for (int i = 0; i < (int)rains.size(); i++) {\\n            if (rains[i]) {\\n                rainy_days[rains[i]].push_back(i);\\n            }\\n        }\\n        \\n        // store next rainy day of full lakes in increasing order of time\\n        set<pair<int, int>> upcoming_rain_on_full_lakes;\\n        vector<int> ans;\\n        for (int i = 0; i < (int)rains.size(); i++) {\\n            int lake = rains[i];\\n            if (lake == 0) {\\n                if (!upcoming_rain_on_full_lakes.empty()) {\\n                    lake = upcoming_rain_on_full_lakes.begin()->second;\\n                    upcoming_rain_on_full_lakes.erase(upcoming_rain_on_full_lakes.begin());\\n\\n                    ans.push_back(lake);\\n                }\\n                else {\\n                    ans.push_back(1);\\n                }\\n            }\\n            else {\\n                // if lake is already full -> flood!\\n                auto it = upcoming_rain_on_full_lakes.lower_bound({i, lake});\\n                if (it != upcoming_rain_on_full_lakes.end() and it->second == lake) {\\n                    ans.clear();\\n                    return ans;\\n                }\\n\\n                auto &rain_days = rainy_days[lake];\\n                int index = upper_bound(rain_days.begin(), rain_days.end(), i) - rain_days.begin();\\n                int next_rain_of_lake = rains.size();\\n                if (index != rain_days.size()) {\\n                    next_rain_of_lake = rain_days[index];\\n                }\\n\\n                upcoming_rain_on_full_lakes.insert({next_rain_of_lake, lake});\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        map<int, vector<int>> rainy_days; // list of rainy days for each lake\\n        for (int i = 0; i < (int)rains.size(); i++) {\\n            if (rains[i]) {\\n                rainy_days[rains[i]].push_back(i);\\n            }\\n        }\\n        \\n        // store next rainy day of full lakes in increasing order of time\\n        set<pair<int, int>> upcoming_rain_on_full_lakes;\\n        vector<int> ans;\\n        for (int i = 0; i < (int)rains.size(); i++) {\\n            int lake = rains[i];\\n            if (lake == 0) {\\n                if (!upcoming_rain_on_full_lakes.empty()) {\\n                    lake = upcoming_rain_on_full_lakes.begin()->second;\\n                    upcoming_rain_on_full_lakes.erase(upcoming_rain_on_full_lakes.begin());\\n\\n                    ans.push_back(lake);\\n                }\\n                else {\\n                    ans.push_back(1);\\n                }\\n            }\\n            else {\\n                // if lake is already full -> flood!\\n                auto it = upcoming_rain_on_full_lakes.lower_bound({i, lake});\\n                if (it != upcoming_rain_on_full_lakes.end() and it->second == lake) {\\n                    ans.clear();\\n                    return ans;\\n                }\\n\\n                auto &rain_days = rainy_days[lake];\\n                int index = upper_bound(rain_days.begin(), rain_days.end(), i) - rain_days.begin();\\n                int next_rain_of_lake = rains.size();\\n                if (index != rain_days.size()) {\\n                    next_rain_of_lake = rain_days[index];\\n                }\\n\\n                upcoming_rain_on_full_lakes.insert({next_rain_of_lake, lake});\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317749,
                "title": "python-o-n-2-solution-beats-100-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI wanted to solve this problem by going through the list once and draining lakes only when I needed them to be filled again. If a lake couldn\\'t be drained with unused days, it would return [].\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI went through the list and saved all days where lakes could be drained if the list of full lakes was more than one. Each time we encountered a lake to be filled, and it was already full, I would go through the list of unused days, and if the draining day was after the initial fill date, then the lake would be drained that day, and we could continue to the next day.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        full_lakes = {}  # Stores the index of the last rain occurrence for each full lake\\n        positions = []  # Stores the indices of days with no rain\\n        out = []  # Output array\\n        \\n        # Iterate through the rains array\\n        for i, item in enumerate(rains):\\n            if item == 0:  # No rain on the current day\\n                if len(full_lakes) == 0:\\n                    # If no lakes are full, dry any lake (chosen as 1)\\n                    out.append(1)\\n                elif len(full_lakes) == 1:\\n                    # If there\\'s only one full lake, dry it\\n                    out.append(list(full_lakes.keys())[0])\\n                    full_lakes.pop(list(full_lakes.keys())[0])\\n                else:\\n                    # Store the current index in positions and append a temporary value (0) to the output\\n                    positions.append(i)\\n                    out.append(0)\\n            else:  # Rain on the current day\\n                if len(positions) == 0 and item in full_lakes.keys():\\n                    # If there\\'s no available day to dry the lake and it\\'s already full, return an empty array\\n                    return []\\n                elif item not in full_lakes.keys():\\n                    # If the lake is not full, fill it and mark it as full in the full_lakes dictionary\\n                    full_lakes[item] = i\\n                    out.append(-1)\\n                else:\\n                    # If the lake is full, find a suitable day to dry it before the next rain\\n                    j = 0\\n                    used = False\\n                    while j < len(positions):\\n                        if full_lakes[item] < positions[j]:\\n                            # If a suitable day is found, update the output and remove the day from positions\\n                            out[positions[j]] = item\\n                            full_lakes.pop(item)\\n                            positions.pop(j)\\n                            out.append(-1)\\n                            used = True\\n                            break\\n                        j += 1\\n                    if used == False:\\n                        # If no suitable day is found, return an empty array\\n                        return []\\n\\n        # Update the remaining days in positions with the available lakes to dry\\n        for i in positions:\\n            if len(full_lakes) > 0:\\n                out[i] = full_lakes.pop(list(full_lakes.keys())[0])\\n            else:\\n                out[i] = 1\\n        return out\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        full_lakes = {}  # Stores the index of the last rain occurrence for each full lake\\n        positions = []  # Stores the indices of days with no rain\\n        out = []  # Output array\\n        \\n        # Iterate through the rains array\\n        for i, item in enumerate(rains):\\n            if item == 0:  # No rain on the current day\\n                if len(full_lakes) == 0:\\n                    # If no lakes are full, dry any lake (chosen as 1)\\n                    out.append(1)\\n                elif len(full_lakes) == 1:\\n                    # If there\\'s only one full lake, dry it\\n                    out.append(list(full_lakes.keys())[0])\\n                    full_lakes.pop(list(full_lakes.keys())[0])\\n                else:\\n                    # Store the current index in positions and append a temporary value (0) to the output\\n                    positions.append(i)\\n                    out.append(0)\\n            else:  # Rain on the current day\\n                if len(positions) == 0 and item in full_lakes.keys():\\n                    # If there\\'s no available day to dry the lake and it\\'s already full, return an empty array\\n                    return []\\n                elif item not in full_lakes.keys():\\n                    # If the lake is not full, fill it and mark it as full in the full_lakes dictionary\\n                    full_lakes[item] = i\\n                    out.append(-1)\\n                else:\\n                    # If the lake is full, find a suitable day to dry it before the next rain\\n                    j = 0\\n                    used = False\\n                    while j < len(positions):\\n                        if full_lakes[item] < positions[j]:\\n                            # If a suitable day is found, update the output and remove the day from positions\\n                            out[positions[j]] = item\\n                            full_lakes.pop(item)\\n                            positions.pop(j)\\n                            out.append(-1)\\n                            used = True\\n                            break\\n                        j += 1\\n                    if used == False:\\n                        # If no suitable day is found, return an empty array\\n                        return []\\n\\n        # Update the remaining days in positions with the available lakes to dry\\n        for i in positions:\\n            if len(full_lakes) > 0:\\n                out[i] = full_lakes.pop(list(full_lakes.keys())[0])\\n            else:\\n                out[i] = 1\\n        return out\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297289,
                "title": "binary-search",
                "content": "**It can also be solved without Binary search the speed would beat the same that is 70% ~ So basically no need of binary search and/or heap(priority queue) ain\\'t needed.**\\n\\n# Code\\n```\\nimport bisect\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        ans = []\\n        queue = []\\n        temp = 0\\n        d = Counter()\\n        for idx, e in enumerate(rains):\\n            if e == 0:\\n                temp += 1\\n                queue.append(idx)\\n                ans.append(1)\\n            else:\\n                if e in d:\\n                    i = bisect.bisect_left(queue,d[e])\\n                    if i == temp:\\n                        return []\\n                    ans[queue[i]] = e\\n                    del queue[i]\\n                    temp -= 1\\n                d[e] = idx\\n                ans.append(-1)\\n                \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        ans = []\\n        queue = []\\n        temp = 0\\n        d = Counter()\\n        for idx, e in enumerate(rains):\\n            if e == 0:\\n                temp += 1\\n                queue.append(idx)\\n                ans.append(1)\\n            else:\\n                if e in d:\\n                    i = bisect.bisect_left(queue,d[e])\\n                    if i == temp:\\n                        return []\\n                    ans[queue[i]] = e\\n                    del queue[i]\\n                    temp -= 1\\n                d[e] = idx\\n                ans.append(-1)\\n                \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282183,
                "title": "python-clear-greedy-solution-min-heap-time-o-nlogn",
                "content": "The greedy strategy is to empty the lake which encounters two rains in **the shortest time**.\\nThis can be performed in min_heap.\\n```\\ndef avoidFlood(self, nums: List[int]) -> List[int]:\\n\\tdays, q, ans = defaultdict(list), [], [-1 if x else 1 for x in nums]\\n\\tfor i in range(len(nums)-1, -1, -1):\\n\\t\\tif nums[i]:\\n\\t\\t\\tdays[nums[i]].append(i)\\n\\tfor i, x in enumerate(nums):\\n\\t\\tif x:\\n\\t\\t\\tif q and x==q[0][1]:\\n\\t\\t\\t\\treturn []\\n\\t\\t\\tif len(days[x])>1:\\n\\t\\t\\t\\theappush(q, [days[x][-2]-days[x][-1], x])\\n\\t\\t\\t\\tdays[x].pop()\\n\\t\\telse:\\n\\t\\t\\tif q:\\n\\t\\t\\t\\tans[i] = heappop(q)[1]\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef avoidFlood(self, nums: List[int]) -> List[int]:\\n\\tdays, q, ans = defaultdict(list), [], [-1 if x else 1 for x in nums]\\n\\tfor i in range(len(nums)-1, -1, -1):\\n\\t\\tif nums[i]:\\n\\t\\t\\tdays[nums[i]].append(i)\\n\\tfor i, x in enumerate(nums):\\n\\t\\tif x:\\n\\t\\t\\tif q and x==q[0][1]:\\n\\t\\t\\t\\treturn []\\n\\t\\t\\tif len(days[x])>1:\\n\\t\\t\\t\\theappush(q, [days[x][-2]-days[x][-1], x])\\n\\t\\t\\t\\tdays[x].pop()\\n\\t\\telse:\\n\\t\\t\\tif q:\\n\\t\\t\\t\\tans[i] = heappop(q)[1]\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3280827,
                "title": "explanation-in-python",
                "content": "### Comments:\\nThe test case ```[1,0,2,0,2,1]``` is extremely helpful. Notice how at the first non-raining day, we need to clear lake 1 already. This goes to show that at any given day, we will need the knowledge of the **entire** future to make the correct decision.\\n\\n### Code Explained:\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n\\t\\t# nextRain lets us know for any raining day, when is the next time that the same lake will get rained again.\\n        hasrain = {}\\n        nextRain = [None] * len(rains)\\n        N = len(rains)\\n        for i in reversed(range(N)):\\n            if rains[i] in hasrain:\\n                nextRain[i] = hasrain[rains[i]]\\n            hasrain[rains[i]] = i if rains[i] != 0 else None  \\n        del hasrain\\n        \\n\\t\\t# needToClear are the lakes that have been rained, but not yet emptied\\n\\t\\t# urgency is a heap of future raining dates that we need to be careful about, because during these future dates, the rain will be falling on lakes that have previously been rained before. \\n        needToClear = set()\\n        urgency = []\\n        res = []\\n        for day, lake in enumerate(rains):\\n            # if lake is full from a previous rain and not yet cleared -> gg\\n            if lake in needToClear:\\n                return []\\n            \\n\\t\\t\\t# wow, it\\'s a non-raining day\\n            if lake == 0:\\n                # is there any lake to be cleared?\\n                # if there is, clear the most urgent one\\n                if len(urgency) > 0:\\n                    mosturgent = heapq.heappop(urgency)\\n                    res.append(rains[mosturgent])\\n                    needToClear.remove(rains[mosturgent])\\n                # if there is no lake to be cleared, just put 1 for placeholder value\\n                else:\\n                    res.append(1)\\n            \\n\\t\\t\\t# oh, it\\'s raining\\n            else:\\n\\t\\t\\t# according to the rules, we can only put -1 here\\n                res.append(-1)\\n\\t\\t\\t\\t# if this lake will not get rained on again, just leave it\\n                if nextRain[day] is None:\\n                    continue\\n\\t\\t\\t\\t# oh, so this lake will be rained on again, let\\'s be careful and empty it asap\\n                needToClear.add(lake)\\n                heapq.heappush(urgency, nextRain[day])\\n                \\n        return res\\n```\\n\\nRuntime: 1038 ms (faster than 91.16%)\\nMemory: 33.2 MB (smaller than 34.94%)",
                "solutionTags": [],
                "code": "```[1,0,2,0,2,1]```\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n\\t\\t# nextRain lets us know for any raining day, when is the next time that the same lake will get rained again.\\n        hasrain = {}\\n        nextRain = [None] * len(rains)\\n        N = len(rains)\\n        for i in reversed(range(N)):\\n            if rains[i] in hasrain:\\n                nextRain[i] = hasrain[rains[i]]\\n            hasrain[rains[i]] = i if rains[i] != 0 else None  \\n        del hasrain\\n        \\n\\t\\t# needToClear are the lakes that have been rained, but not yet emptied\\n\\t\\t# urgency is a heap of future raining dates that we need to be careful about, because during these future dates, the rain will be falling on lakes that have previously been rained before. \\n        needToClear = set()\\n        urgency = []\\n        res = []\\n        for day, lake in enumerate(rains):\\n            # if lake is full from a previous rain and not yet cleared -> gg\\n            if lake in needToClear:\\n                return []\\n            \\n\\t\\t\\t# wow, it\\'s a non-raining day\\n            if lake == 0:\\n                # is there any lake to be cleared?\\n                # if there is, clear the most urgent one\\n                if len(urgency) > 0:\\n                    mosturgent = heapq.heappop(urgency)\\n                    res.append(rains[mosturgent])\\n                    needToClear.remove(rains[mosturgent])\\n                # if there is no lake to be cleared, just put 1 for placeholder value\\n                else:\\n                    res.append(1)\\n            \\n\\t\\t\\t# oh, it\\'s raining\\n            else:\\n\\t\\t\\t# according to the rules, we can only put -1 here\\n                res.append(-1)\\n\\t\\t\\t\\t# if this lake will not get rained on again, just leave it\\n                if nextRain[day] is None:\\n                    continue\\n\\t\\t\\t\\t# oh, so this lake will be rained on again, let\\'s be careful and empty it asap\\n                needToClear.add(lake)\\n                heapq.heappush(urgency, nextRain[day])\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255859,
                "title": "python-simple-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def avoidFlood(self, rains):\\n        zeros, lakes, ans = [], {}, [-1]*len(rains)\\n\\n        for i,j in enumerate(rains):\\n            if j in lakes:\\n                idx = bisect.bisect_left(zeros,lakes[j])\\n                if idx == len(zeros): return []\\n                ans[zeros[idx]] = j\\n                zeros.pop(idx)\\n                lakes[j] = i\\n            elif j == 0:\\n                zeros.append(i)\\n            else: lakes[j] = i\\n\\n        for i in range(len(ans)):\\n            if rains[i] == 0 and ans[i] == -1:\\n                ans[i] = 1\\n\\n        return ans\\n\\n\\n\\n\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains):\\n        zeros, lakes, ans = [], {}, [-1]*len(rains)\\n\\n        for i,j in enumerate(rains):\\n            if j in lakes:\\n                idx = bisect.bisect_left(zeros,lakes[j])\\n                if idx == len(zeros): return []\\n                ans[zeros[idx]] = j\\n                zeros.pop(idx)\\n                lakes[j] = i\\n            elif j == 0:\\n                zeros.append(i)\\n            else: lakes[j] = i\\n\\n        for i in range(len(ans)):\\n            if rains[i] == 0 and ans[i] == -1:\\n                ans[i] = 1\\n\\n        return ans\\n\\n\\n\\n\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166969,
                "title": "avoid-flood-in-the-city",
                "content": "# Intuition\\nStore indices where rains[i] == 0 , in set st.\\n\\nKeep a map indices to keep track of which lake is already filled .\\n\\nWhen encountering a lake, if it is already filled, then it had to be dried. But on which Day???\\n\\nPrevDay stores the last seen index of same lake. Therefore, it is only possible to empty this lake if there is a zero after prevDay index. Which we can easily check with upper_bound in set st.\\n\\nWe get the index of zero after prevDay, Now remove this index from set st. and now the last seen index of the lake will be present i. Update it.\\n\\nNow, on the day where we can empty any lake But ans still contains -1, replace it with 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int> res(rains.size(),-1);\\n        unordered_map<int, int> m;\\n        set<int> zero;\\n        for(int i =0; i < rains.size(); ++i)\\n        {\\n            if(rains[i] == 0)\\n            {\\n                zero.insert(i);\\n                res[i] = 1;\\n            }\\n            else\\n            {\\n                if(m.count(rains[i]))\\n                {\\n                    int lastIndex = m[rains[i]];\\n                    auto zeroIndex = zero.upper_bound(lastIndex);\\n                    if(zeroIndex == zero.end())\\n                    {\\n                        return {};\\n                    }\\n                    res[*zeroIndex] = rains[i];\\n                    zero.erase(zeroIndex);\\n                }\\n                m[rains[i]] = i;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int> res(rains.size(),-1);\\n        unordered_map<int, int> m;\\n        set<int> zero;\\n        for(int i =0; i < rains.size(); ++i)\\n        {\\n            if(rains[i] == 0)\\n            {\\n                zero.insert(i);\\n                res[i] = 1;\\n            }\\n            else\\n            {\\n                if(m.count(rains[i]))\\n                {\\n                    int lastIndex = m[rains[i]];\\n                    auto zeroIndex = zero.upper_bound(lastIndex);\\n                    if(zeroIndex == zero.end())\\n                    {\\n                        return {};\\n                    }\\n                    res[*zeroIndex] = rains[i];\\n                    zero.erase(zeroIndex);\\n                }\\n                m[rains[i]] = i;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158926,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        q = []\\n        counter = defaultdict(lambda: [0,-1])\\n        n = len(rains)\\n        res = [-1] * n\\n        for i, a in enumerate(rains):\\n            if a != 0:\\n                counter[a][0] += 1\\n                if counter[a][0] > 1:\\n                    idx1 = bisect_left(q,counter[a][1])\\n                    idx2 = bisect_left(q,i)\\n                    if idx2 > idx1:\\n                        res[q[idx1]] = a\\n                        q.remove(q[idx1])\\n                        counter[a][0] -= 1\\n                    else: return []\\n                counter[a][1] = i\\n            else:\\n                q.append(i)\\n        for idx in q:\\n            res[idx] = 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        q = []\\n        counter = defaultdict(lambda: [0,-1])\\n        n = len(rains)\\n        res = [-1] * n\\n        for i, a in enumerate(rains):\\n            if a != 0:\\n                counter[a][0] += 1\\n                if counter[a][0] > 1:\\n                    idx1 = bisect_left(q,counter[a][1])\\n                    idx2 = bisect_left(q,i)\\n                    if idx2 > idx1:\\n                        res[q[idx1]] = a\\n                        q.remove(q[idx1])\\n                        counter[a][0] -= 1\\n                    else: return []\\n                counter[a][1] = i\\n            else:\\n                q.append(i)\\n        for idx in q:\\n            res[idx] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154117,
                "title": "solution-using-map-and-arraylist",
                "content": "# Intuition\\nMAp and ArrayList\\n# Approach\\nMap for storing lake and ArrayList for dryDays\\n\\n# Complexity\\n- Time complexity:\\nO(N) * O(d) ,d=no.of dry days\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n   \\n    public int[] avoidFlood(int[] rains) {\\n        \\n        Map<Integer,Integer> lake = new HashMap<>();\\n\\n        List<Integer> dryDays = new ArrayList<>();\\n        int [] res = new int[rains.length];\\n        for(int i=0;i<rains.length;i++)\\n        {\\n            if(rains[i] == 0)\\n            {\\n                dryDays.add(i);\\n                \\n            }\\n            else if(lake.containsKey(rains[i]))\\n            {\\n                int low = lake.get(rains[i]);\\n                int high = i;\\n                int index= search(dryDays,low,high);\\n                if(index != -1)\\n                {\\n                    res[dryDays.get(index)] = rains[i];\\n                    lake.remove(rains[i]);\\n                    dryDays.remove(index);\\n                }else{\\n                    return new int[0];\\n                }\\n                \\n            }\\n            lake.put(rains[i],i);\\n            res[i]=-1;\\n        }\\n        for(int i=0;i<dryDays.size();i++)\\n        {\\n            res[dryDays.get(i)]=1;\\n        }\\n        return res;\\n    }\\n    public int search(List<Integer> dryDays,int low,int high)\\n    {\\n        for(int i=0;i<dryDays.size();i++)\\n        {\\n            if(dryDays.get(i)>low && dryDays.get(i)<high)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   \\n    public int[] avoidFlood(int[] rains) {\\n        \\n        Map<Integer,Integer> lake = new HashMap<>();\\n\\n        List<Integer> dryDays = new ArrayList<>();\\n        int [] res = new int[rains.length];\\n        for(int i=0;i<rains.length;i++)\\n        {\\n            if(rains[i] == 0)\\n            {\\n                dryDays.add(i);\\n                \\n            }\\n            else if(lake.containsKey(rains[i]))\\n            {\\n                int low = lake.get(rains[i]);\\n                int high = i;\\n                int index= search(dryDays,low,high);\\n                if(index != -1)\\n                {\\n                    res[dryDays.get(index)] = rains[i];\\n                    lake.remove(rains[i]);\\n                    dryDays.remove(index);\\n                }else{\\n                    return new int[0];\\n                }\\n                \\n            }\\n            lake.put(rains[i],i);\\n            res[i]=-1;\\n        }\\n        for(int i=0;i<dryDays.size();i++)\\n        {\\n            res[dryDays.get(i)]=1;\\n        }\\n        return res;\\n    }\\n    public int search(List<Integer> dryDays,int low,int high)\\n    {\\n        for(int i=0;i<dryDays.size();i++)\\n        {\\n            if(dryDays.get(i)>low && dryDays.get(i)<high)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135900,
                "title": "1488-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        int n = rains.size();\\n        unordered_map<int, int> full;\\n        set<int> zeros;\\n        vector<int> ans(n, -1);\\n        for (int i = 0; i < n; i++) {\\n            if (rains[i] == 0) {\\n                zeros.insert(i);\\n            } else {\\n                if (full.count(rains[i])) {\\n                    auto it = zeros.lower_bound(full[rains[i]]);\\n                    if (it == zeros.end()) return {};\\n                    ans[*it] = rains[i];\\n                    zeros.erase(it);\\n                    full[rains[i]] = i;\\n                } else {\\n                    full[rains[i]] = i;\\n                }\\n            }\\n        }\\n        for (auto& zero : zeros) {\\n            ans[zero] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        int n = rains.size();\\n        unordered_map<int, int> full;\\n        set<int> zeros;\\n        vector<int> ans(n, -1);\\n        for (int i = 0; i < n; i++) {\\n            if (rains[i] == 0) {\\n                zeros.insert(i);\\n            } else {\\n                if (full.count(rains[i])) {\\n                    auto it = zeros.lower_bound(full[rains[i]]);\\n                    if (it == zeros.end()) return {};\\n                    ans[*it] = rains[i];\\n                    zeros.erase(it);\\n                    full[rains[i]] = i;\\n                } else {\\n                    full[rains[i]] = i;\\n                }\\n            }\\n        }\\n        for (auto& zero : zeros) {\\n            ans[zero] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098991,
                "title": "explain-why-so-slow",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<int> avoidFlood(vector<int> &r)\\n{\\n    vector<int> a;\\n    unordered_map<int, int> mp;\\n    for (int i = 0; i < r.size(); i++)\\n    {\\n        if (r[i] == 0)\\n        {\\n            a.push_back(i);\\n            r[i] = 1;\\n        }\\n        else\\n        {\\n            if (mp.count(r[i]))\\n            {\\n                auto it = upper_bound(a.begin(), a.end(), mp[r[i]]);\\n                if (it == a.end())\\n                    return {};\\n                r[*it] = r[i];\\n                a.erase(it);\\n            }\\n            mp[r[i]] = i;\\n            r[i] = -1;\\n        }\\n    }\\n    return r;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<int> avoidFlood(vector<int> &r)\\n{\\n    vector<int> a;\\n    unordered_map<int, int> mp;\\n    for (int i = 0; i < r.size(); i++)\\n    {\\n        if (r[i] == 0)\\n        {\\n            a.push_back(i);\\n            r[i] = 1;\\n        }\\n        else\\n        {\\n            if (mp.count(r[i]))\\n            {\\n                auto it = upper_bound(a.begin(), a.end(), mp[r[i]]);\\n                if (it == a.end())\\n                    return {};\\n                r[*it] = r[i];\\n                a.erase(it);\\n            }\\n            mp[r[i]] = i;\\n            r[i] = -1;\\n        }\\n    }\\n    return r;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044516,
                "title": "python-not-fast-but-easy-to-understand-without-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntrack the city last rained index (i) and if rained again (j), \\n            find the 0 between the 2 time rains. use it and update the last rained index\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        \"\"\"\\n            Idea : track the city last rained index (i) and if rained again (j), \\n            find the 0 between the 2 time rains. use it and update the last rained index\\n\\n            [1,0,2,0,3,0,2,0,0,0,1,2,3]\\n                  <------>, use \"dry\" to save flood   dry[1,3,5] => [1,5]\\n             <-------------------> use \"dry\" to save flood dry[1,5,7,8,9] => [5,7,8,9]\\n                         <----------> use \"dry\" [5,7,8,9] => [5,8,9]\\n                     <----------------> use \"dry\" [5,8,9] = >[8,9]\\n            clean up the ramains dries[8,9]. use on the first rained city\\n        \"\"\"\\n        last_rain = defaultdict(int) # last rained index\\n        zeros = [] # index of dry days\\n        res = [-1]*len(rains)\\n        def find_between(zeros, i, j): # try find a \"dry\" to save the flood\\n            if not zeros:\\n                return None\\n            try:\\n                return next(z for z in zeros if z > i and z < j)\\n            except Exception:\\n                return None\\n\\n        for i,r in enumerate(rains):\\n            if r > 0:\\n                if r not in last_rain or last_rain[r] < 0:\\n                    last_rain[r] = i\\n                else:\\n                    dry = find_between(zeros, last_rain[r], i)\\n                    if not dry:\\n                        return []\\n                    zeros.remove(dry)\\n                    res[dry]=r\\n                    last_rain[r] = i\\n            else:\\n                zeros.append(i)\\n\\n        if zeros: # still there are unused dry, use on the first city\\n            first_city = next(r for r in rains if r > 0)\\n            for z in zeros:\\n                res[z] = first_city\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        \"\"\"\\n            Idea : track the city last rained index (i) and if rained again (j), \\n            find the 0 between the 2 time rains. use it and update the last rained index\\n\\n            [1,0,2,0,3,0,2,0,0,0,1,2,3]\\n                  <------>, use \"dry\" to save flood   dry[1,3,5] => [1,5]\\n             <-------------------> use \"dry\" to save flood dry[1,5,7,8,9] => [5,7,8,9]\\n                         <----------> use \"dry\" [5,7,8,9] => [5,8,9]\\n                     <----------------> use \"dry\" [5,8,9] = >[8,9]\\n            clean up the ramains dries[8,9]. use on the first rained city\\n        \"\"\"\\n        last_rain = defaultdict(int) # last rained index\\n        zeros = [] # index of dry days\\n        res = [-1]*len(rains)\\n        def find_between(zeros, i, j): # try find a \"dry\" to save the flood\\n            if not zeros:\\n                return None\\n            try:\\n                return next(z for z in zeros if z > i and z < j)\\n            except Exception:\\n                return None\\n\\n        for i,r in enumerate(rains):\\n            if r > 0:\\n                if r not in last_rain or last_rain[r] < 0:\\n                    last_rain[r] = i\\n                else:\\n                    dry = find_between(zeros, last_rain[r], i)\\n                    if not dry:\\n                        return []\\n                    zeros.remove(dry)\\n                    res[dry]=r\\n                    last_rain[r] = i\\n            else:\\n                zeros.append(i)\\n\\n        if zeros: # still there are unused dry, use on the first city\\n            first_city = next(r for r in rains if r > 0)\\n            for z in zeros:\\n                res[z] = first_city\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035829,
                "title": "python3-keep-dry-days-fill-days-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf a lake has been filled previously and gets rained over again, we need to check if there have been dry days between the last rain day over the lake and the current day.\\n\\nIn order to do that, we need to save when the last rain day was and also what the dry days up until this point have been.\\n\\nAs the dry days grow monotonously due to the for loop, we can use binary search in the indices of the dry days to find the earliest dry day after a lake has been rained over.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*logN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) worst case\\n# Code\\n```\\nfrom bisect import bisect_right\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n\\n        # make an array to save dry days we had in the past\\n        zeros = []\\n\\n        # make a dict to save the day when the lake has been filled\\n        lakes_full = dict()\\n\\n        # result array to put in the lakes to dry\\n        result = [-1]*len(rains)\\n\\n        # go through all rain days\\n        for idx, lake in enumerate(rains):\\n\\n            # append the date of a dry day to the stack of dry days\\n            if not lake:\\n                zeros.append(idx)\\n            \\n            # we have a rain day\\n            else:\\n\\n                # check whether the lake it rains over has been filled previously\\n                if lake in lakes_full:\\n\\n                    # binary search to find any dry days that occured after the last\\n                    # time the lake was flooded\\n                    rx = bisect_right(zeros, lakes_full[lake])\\n\\n                    # check whether the binary search found something\\n                    if rx < len(zeros):\\n\\n                        # go back in history to the earliest dry day after the fillup\\n                        # and dry the lake\\n                        result[zeros[rx]] = lake\\n\\n                        # delete the dry day as we have used it\\n                        zeros.pop(rx)\\n                    \\n                    # there have been no dry days between the last rain over the\\n                    # lake and now\\n                    else:\\n                        return []\\n                \\n                # update the last rain\\n                lakes_full[lake] = idx\\n        \\n        # dry random lake as we are forced to dry something\\n        for idx in zeros:\\n            result[idx] = 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_right\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n\\n        # make an array to save dry days we had in the past\\n        zeros = []\\n\\n        # make a dict to save the day when the lake has been filled\\n        lakes_full = dict()\\n\\n        # result array to put in the lakes to dry\\n        result = [-1]*len(rains)\\n\\n        # go through all rain days\\n        for idx, lake in enumerate(rains):\\n\\n            # append the date of a dry day to the stack of dry days\\n            if not lake:\\n                zeros.append(idx)\\n            \\n            # we have a rain day\\n            else:\\n\\n                # check whether the lake it rains over has been filled previously\\n                if lake in lakes_full:\\n\\n                    # binary search to find any dry days that occured after the last\\n                    # time the lake was flooded\\n                    rx = bisect_right(zeros, lakes_full[lake])\\n\\n                    # check whether the binary search found something\\n                    if rx < len(zeros):\\n\\n                        # go back in history to the earliest dry day after the fillup\\n                        # and dry the lake\\n                        result[zeros[rx]] = lake\\n\\n                        # delete the dry day as we have used it\\n                        zeros.pop(rx)\\n                    \\n                    # there have been no dry days between the last rain over the\\n                    # lake and now\\n                    else:\\n                        return []\\n                \\n                # update the last rain\\n                lakes_full[lake] = idx\\n        \\n        # dry random lake as we are forced to dry something\\n        for idx in zeros:\\n            result[idx] = 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019792,
                "title": "approach-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n-- track indexes where 0 is present.\\n-- maintain a dict where key is element and value is index of the element where it occured last\\n\\n---traverse the rains array:\\n    -- if the lake has been alreadyfound while traversing \\n\\t\\t\\t-- if the rain is 0 \\n\\t\\t\\t\\t\\t\\t\\t--just add current index in zeroi and update ans\\n\\t    --check if anyone of the zeroindex arrived so far, has arrived after lastfound index of the element.\\n\\t\\t\\t\\t\\t\\t\\t-- if yes : \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-- update the lastfound and ans\\n\\t\\t\\t\\t\\t\\t\\t-- no:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-- not possible\\n\\t\\t\\t\\t---if not -> just appdate the lastfound and ans \\n\\t\\t\\t\\t\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n\\n        ans=[]\\n        zeroi=[]\\n        lastfound={}\\n        for i,v in enumerate(rains):\\n            # print(lastfound,zeroi,ans)\\n            if v==0:\\n                zeroi.append(i)\\n                ans.append(1)\\n            else:\\n                if v in lastfound:\\n                    if zeroi!=[]:\\n                        done=False\\n                        for x,y  in enumerate(zeroi):\\n                            if y>lastfound[v]:\\n                                ans[zeroi.pop(x)]=v\\n                                break\\n                        else:\\n                            return []\\n                        lastfound[v]=i\\n                    else:\\n                        return []\\n                    \\n                    ans.append(-1)\\n                else:\\n                    lastfound[v]=i\\n                    ans.append(-1)\\n\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n\\n        ans=[]\\n        zeroi=[]\\n        lastfound={}\\n        for i,v in enumerate(rains):\\n            # print(lastfound,zeroi,ans)\\n            if v==0:\\n                zeroi.append(i)\\n                ans.append(1)\\n            else:\\n                if v in lastfound:\\n                    if zeroi!=[]:\\n                        done=False\\n                        for x,y  in enumerate(zeroi):\\n                            if y>lastfound[v]:\\n                                ans[zeroi.pop(x)]=v\\n                                break\\n                        else:\\n                            return []\\n                        lastfound[v]=i\\n                    else:\\n                        return []\\n                    \\n                    ans.append(-1)\\n                else:\\n                    lastfound[v]=i\\n                    ans.append(-1)\\n\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013696,
                "title": "c",
                "content": "```\\n\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* avoidFlood(int* rains, int rainsSize, int* returnSize){\\n    int n = rainsSize;\\n    *returnSize = n;\\n    int* ans = calloc(n , sizeof(int));\\n    int* stack = malloc( n * sizeof(int));\\n    int s_idx = 0;\\n    int top = 0;\\n    int N = 2* n;\\n    int** hash = calloc(N , sizeof(int*)) ;\\n    for(int i = 0; i < n; i++){\\n        if( rains[i] == 0){\\n            stack[s_idx] = i;\\n            s_idx++;\\n            ans[i] = 1;\\n        }\\n        else{\\n            ans[i] = -1;\\n            int val = rains[i];\\n            int d = val;\\n            while(1){\\n                if(hash[d % N] == NULL){\\n                    hash[d % N] = malloc(2*sizeof(int));\\n                    hash[d % N][0] = val;\\n                    hash[d % N][1] = i;\\n                    break;\\n                }\\n                else if(hash[d % N][0] == val){\\n                    if(top == s_idx){\\n                        *returnSize = 0;\\n                        goto exit;\\n                    }    \\n                    for(int j = top; j < s_idx; j++){\\n                        if(stack[j] > hash[d % N][1]){                            \\n                            ans[stack[j]] = val;\\n                            stack[j] = -1;\\n                            hash[d % N][1] = i;\\n                            break;\\n                        }\\n                        if(j == s_idx-1){\\n                            *returnSize = 0;\\n                            goto exit;\\n                        }\\n                    }\\n                    break;\\n                }\\n                else\\n                    d++;\\n            }\\n            while(top < s_idx && stack[top] == -1){\\n                top++;\\n            }\\n        }\\n    }\\n    exit:\\n    free(stack);\\n    for(int i = 0; i < N; i++){\\n        if(hash[i])\\n            free(hash[i]);\\n    }\\n    free(hash);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* avoidFlood(int* rains, int rainsSize, int* returnSize){\\n    int n = rainsSize;\\n    *returnSize = n;\\n    int* ans = calloc(n , sizeof(int));\\n    int* stack = malloc( n * sizeof(int));\\n    int s_idx = 0;\\n    int top = 0;\\n    int N = 2* n;\\n    int** hash = calloc(N , sizeof(int*)) ;\\n    for(int i = 0; i < n; i++){\\n        if( rains[i] == 0){\\n            stack[s_idx] = i;\\n            s_idx++;\\n            ans[i] = 1;\\n        }\\n        else{\\n            ans[i] = -1;\\n            int val = rains[i];\\n            int d = val;\\n            while(1){\\n                if(hash[d % N] == NULL){\\n                    hash[d % N] = malloc(2*sizeof(int));\\n                    hash[d % N][0] = val;\\n                    hash[d % N][1] = i;\\n                    break;\\n                }\\n                else if(hash[d % N][0] == val){\\n                    if(top == s_idx){\\n                        *returnSize = 0;\\n                        goto exit;\\n                    }    \\n                    for(int j = top; j < s_idx; j++){\\n                        if(stack[j] > hash[d % N][1]){                            \\n                            ans[stack[j]] = val;\\n                            stack[j] = -1;\\n                            hash[d % N][1] = i;\\n                            break;\\n                        }\\n                        if(j == s_idx-1){\\n                            *returnSize = 0;\\n                            goto exit;\\n                        }\\n                    }\\n                    break;\\n                }\\n                else\\n                    d++;\\n            }\\n            while(top < s_idx && stack[top] == -1){\\n                top++;\\n            }\\n        }\\n    }\\n    exit:\\n    free(stack);\\n    for(int i = 0; i < N; i++){\\n        if(hash[i])\\n            free(hash[i]);\\n    }\\n    free(hash);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3012042,
                "title": "python-long-solution-with-binary-search-beats-100",
                "content": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        res = [-1] * len(rains)\\n        memo = dict()\\n        empty = []\\n        last_rain = dict()\\n        for i in range(len(rains)):\\n            if rains[i] == 0:\\n                empty.append(i)\\n                res[i] = 1\\n        for i in range(len(empty)): memo[i] = i\\n\\n        def f(cur):\\n            if cur >= len(empty): return len(empty)\\n            if memo[cur] == cur:\\n                memo[cur] = cur + 1\\n                return cur\\n            \\n            x = f(memo[cur])\\n            memo[cur] = x+1\\n            return x\\n\\n        for i in range(len(rains)):\\n            if rains[i] == 0: continue \\n                \\n            if rains[i] in last_rain:\\n                index = bisect.bisect_right(empty,last_rain[rains[i]])\\n                if index >= len(empty):return []\\n                if empty[index] > i: return []\\n                x = f(index)\\n                if x >= len(empty): return []\\n                res[empty[x]] = rains[i]\\n                last_rain[rains[i]] = i\\n            else:\\n                last_rain[rains[i]] = i\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        res = [-1] * len(rains)\\n        memo = dict()\\n        empty = []\\n        last_rain = dict()\\n        for i in range(len(rains)):\\n            if rains[i] == 0:\\n                empty.append(i)\\n                res[i] = 1\\n        for i in range(len(empty)): memo[i] = i\\n\\n        def f(cur):\\n            if cur >= len(empty): return len(empty)\\n            if memo[cur] == cur:\\n                memo[cur] = cur + 1\\n                return cur\\n            \\n            x = f(memo[cur])\\n            memo[cur] = x+1\\n            return x\\n\\n        for i in range(len(rains)):\\n            if rains[i] == 0: continue \\n                \\n            if rains[i] in last_rain:\\n                index = bisect.bisect_right(empty,last_rain[rains[i]])\\n                if index >= len(empty):return []\\n                if empty[index] > i: return []\\n                x = f(index)\\n                if x >= len(empty): return []\\n                res[empty[x]] = rains[i]\\n                last_rain[rains[i]] = i\\n            else:\\n                last_rain[rains[i]] = i\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985907,
                "title": "python-tle-on-set-ac-on-binary-search",
                "content": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        n =len(rains)\\n        ans =[1]*n\\n        drys=[]\\n        d={}\\n        for i in range(n):\\n            if rains[i] == 0:\\n                drys.append(i)\\n            else:\\n                if rains[i] in d:\\n                    day = bisect.bisect_left(drys,d[rains[i]])\\n                    if day >= len(drys): return []\\n                    ans[drys[day]] = rains[i]\\n                    drys.pop(day)\\n                d[rains[i]] = i\\n                ans[i]=-1\\n        return ans\\n```\\n2 used set : tle\\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        n =len(rains)\\n        ans =[1]*n\\n        G=set()\\n        d={}\\n        for i in range(n):\\n            if rains[i] == 0:\\n                G.add(i)\\n            else:\\n                if rains[i] in d:\\n                    for day in range(d[rains[i]],i):\\n                        if day in G:\\n                            ans[day] = rains[i]\\n                            G.remove(day)\\n                            break\\n                    else:\\n                        return []\\n                d[rains[i]] = i\\n                ans[i]=-1\\n        return ans\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        n =len(rains)\\n        ans =[1]*n\\n        drys=[]\\n        d={}\\n        for i in range(n):\\n            if rains[i] == 0:\\n                drys.append(i)\\n            else:\\n                if rains[i] in d:\\n                    day = bisect.bisect_left(drys,d[rains[i]])\\n                    if day >= len(drys): return []\\n                    ans[drys[day]] = rains[i]\\n                    drys.pop(day)\\n                d[rains[i]] = i\\n                ans[i]=-1\\n        return ans\\n```\n```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        n =len(rains)\\n        ans =[1]*n\\n        G=set()\\n        d={}\\n        for i in range(n):\\n            if rains[i] == 0:\\n                G.add(i)\\n            else:\\n                if rains[i] in d:\\n                    for day in range(d[rains[i]],i):\\n                        if day in G:\\n                            ans[day] = rains[i]\\n                            G.remove(day)\\n                            break\\n                    else:\\n                        return []\\n                d[rains[i]] = i\\n                ans[i]=-1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975090,
                "title": "python-heap",
                "content": "# Intuition\\nKeep track of which lakes are flooded, if you get the chance you want to dry that one that is first to see rain again.\\n\\n# Approach\\nKeep a priority queue of flooded lakes where they are sorted according when it is going to rain again. Updating efficiently requires to store next time it will rain for all lakes before.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ we pass by every day a fixed number of times\\n\\n- Space complexity:\\n$$O(n)$$ from hash maps\\n\\n# Code\\n```\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        #push flooded lakes on a heap, heap invariant is when it will rain over them next time\\n        rainyDays_ht={}\\n        for i,r in enumerate(rains):\\n            if r>0:\\n                if r not in rainyDays_ht:\\n                    rainyDays_ht[r]=[i]\\n                else:\\n                    rainyDays_ht[r].append(i)\\n        \\n        flooded_ht={}\\n        flooded_heap=[]\\n        ans=[]\\n\\n        for i,r in enumerate(rains):\\n            if r>0:\\n                if r in flooded_ht:\\n                    return []\\n                else:\\n                    flooded_ht[r]=True\\n                    if r in rainyDays_ht:\\n                        rainyDays_ht[r].pop(0)\\n                        if rainyDays_ht[r]:\\n                            nextRainyDay=rainyDays_ht[r][0]\\n                            heappush(flooded_heap,(nextRainyDay,r))\\n                        else: #not rainyDays_ht[r]:\\n                            del rainyDays_ht[r]\\n                ans.append(-1)\\n            else:\\n                if flooded_heap:\\n                    drain=heappop(flooded_heap)\\n                    del flooded_ht[drain[1]]\\n                    ans.append(drain[1])\\n                else:\\n                    ans.append(1)\\n        return ans\\n\\n                       \\n\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        #push flooded lakes on a heap, heap invariant is when it will rain over them next time\\n        rainyDays_ht={}\\n        for i,r in enumerate(rains):\\n            if r>0:\\n                if r not in rainyDays_ht:\\n                    rainyDays_ht[r]=[i]\\n                else:\\n                    rainyDays_ht[r].append(i)\\n        \\n        flooded_ht={}\\n        flooded_heap=[]\\n        ans=[]\\n\\n        for i,r in enumerate(rains):\\n            if r>0:\\n                if r in flooded_ht:\\n                    return []\\n                else:\\n                    flooded_ht[r]=True\\n                    if r in rainyDays_ht:\\n                        rainyDays_ht[r].pop(0)\\n                        if rainyDays_ht[r]:\\n                            nextRainyDay=rainyDays_ht[r][0]\\n                            heappush(flooded_heap,(nextRainyDay,r))\\n                        else: #not rainyDays_ht[r]:\\n                            del rainyDays_ht[r]\\n                ans.append(-1)\\n            else:\\n                if flooded_heap:\\n                    drain=heappop(flooded_heap)\\n                    del flooded_ht[drain[1]]\\n                    ans.append(drain[1])\\n                else:\\n                    ans.append(1)\\n        return ans\\n\\n                       \\n\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969032,
                "title": "python3-sortedlist-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search to find the position to dry the lake when this lake is going to be filled again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the dry day id in sorted list;\\nStore the first full id for each lake in pre dict;\\nWhen the same lake is going to be full, bisect search its first full id in sorted list; Pick the first dry id appearing after the first full id\\n\\nInsert and discard an element from sorted list is: O(NlogN);\\n\\nMaintain a sorted list: space complexity will be O(N)\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        dry_order = SortedList()\\n        pre = defaultdict(int)\\n        ans = [1 for _ in range(len(rains))]\\n        for i, r in enumerate(rains):\\n            if r == 0:\\n                dry_order.add(i)\\n            else:\\n                if r in pre:\\n                    if not dry_order: \\n                        return []\\n                    pos = bisect.bisect(dry_order, pre[r])\\n                    if pos == len(dry_order): \\n                        return []\\n                    dry_pos = dry_order[pos]\\n                    dry_order.discard(dry_pos)\\n                    ans[dry_pos] = r\\n                \\n                pre[r] = i\\n        \\n                ans[i] = -1\\n\\n        return ans \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        dry_order = SortedList()\\n        pre = defaultdict(int)\\n        ans = [1 for _ in range(len(rains))]\\n        for i, r in enumerate(rains):\\n            if r == 0:\\n                dry_order.add(i)\\n            else:\\n                if r in pre:\\n                    if not dry_order: \\n                        return []\\n                    pos = bisect.bisect(dry_order, pre[r])\\n                    if pos == len(dry_order): \\n                        return []\\n                    dry_pos = dry_order[pos]\\n                    dry_order.discard(dry_pos)\\n                    ans[dry_pos] = r\\n                \\n                pre[r] = i\\n        \\n                ans[i] = -1\\n\\n        return ans \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967679,
                "title": "java-solution-with-comments",
                "content": "# Intuition\\nTrack dry days available and use them when the lake is going to overflow.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2), due to iteration over the linkedList. Can improve by using a treeSet to O(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int[] result = new int[rains.length];\\n        Arrays.fill(result, -1);\\n        int dryDays = 0;\\n        LinkedList<Integer> dryDaysList = new LinkedList<>();\\n        HashMap<Integer, Integer> lakeDayMap = new HashMap<>();\\n        for (int i = 0; i < rains.length; i++) {\\n            if (rains[i] == 0) {\\n                if (lakeDayMap.size() > 0) {\\n                    dryDays++;\\n                    dryDaysList.add(i);\\n                }\\n                result[i] = 1;\\n            } else {\\n                int rainLake = rains[i];\\n                if (lakeDayMap.containsKey(rainLake)) { // Is Lake full already\\n                    if (dryDays == 0) { // No dry days prior, then overflow\\n                        return new int[]{};\\n                    } else {\\n                        dryDays--;\\n                        int dryDayIndex = getDryDayIndex(lakeDayMap, rainLake, dryDaysList);\\n                        if (dryDayIndex == -1) { // No Dry day after previous rain, then overflow.\\n                            return new int[]{};\\n                        }\\n                        result[dryDayIndex] = rainLake;\\n                        lakeDayMap.put(rainLake, i);\\n                    }\\n                } else {// Lake is empty.\\n                    lakeDayMap.put(rainLake, i);\\n                }\\n            }\\n        }\\n        while (dryDaysList.size() > 0) {\\n            result[dryDaysList.get(0)] = 1;\\n            dryDaysList.remove(0);\\n        }\\n\\n        return result;\\n    }\\n\\n    private static int getDryDayIndex(HashMap<Integer, Integer> map, int key, LinkedList<Integer> dryDayList) {\\n        int dayReq = map.get(key);\\n        for (int i = 0; i < dryDayList.size(); i++) {\\n            if (dryDayList.get(i) > dayReq) {\\n                int val = dryDayList.get(i);\\n                dryDayList.remove(i);\\n                return val;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int[] result = new int[rains.length];\\n        Arrays.fill(result, -1);\\n        int dryDays = 0;\\n        LinkedList<Integer> dryDaysList = new LinkedList<>();\\n        HashMap<Integer, Integer> lakeDayMap = new HashMap<>();\\n        for (int i = 0; i < rains.length; i++) {\\n            if (rains[i] == 0) {\\n                if (lakeDayMap.size() > 0) {\\n                    dryDays++;\\n                    dryDaysList.add(i);\\n                }\\n                result[i] = 1;\\n            } else {\\n                int rainLake = rains[i];\\n                if (lakeDayMap.containsKey(rainLake)) { // Is Lake full already\\n                    if (dryDays == 0) { // No dry days prior, then overflow\\n                        return new int[]{};\\n                    } else {\\n                        dryDays--;\\n                        int dryDayIndex = getDryDayIndex(lakeDayMap, rainLake, dryDaysList);\\n                        if (dryDayIndex == -1) { // No Dry day after previous rain, then overflow.\\n                            return new int[]{};\\n                        }\\n                        result[dryDayIndex] = rainLake;\\n                        lakeDayMap.put(rainLake, i);\\n                    }\\n                } else {// Lake is empty.\\n                    lakeDayMap.put(rainLake, i);\\n                }\\n            }\\n        }\\n        while (dryDaysList.size() > 0) {\\n            result[dryDaysList.get(0)] = 1;\\n            dryDaysList.remove(0);\\n        }\\n\\n        return result;\\n    }\\n\\n    private static int getDryDayIndex(HashMap<Integer, Integer> map, int key, LinkedList<Integer> dryDayList) {\\n        int dayReq = map.get(key);\\n        for (int i = 0; i < dryDayList.size(); i++) {\\n            if (dryDayList.get(i) > dayReq) {\\n                int val = dryDayList.get(i);\\n                dryDayList.remove(i);\\n                return val;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950705,
                "title": "treeset-approach-java-solution-clean-code",
                "content": "# Code\\n```java\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int ans[] = new int[rains.length];\\n        Map<Integer,Integer> mp = new HashMap<>();\\n        TreeSet<Integer> dryDays = new TreeSet<>();\\n        for(int i = 0;i < rains.length;i++){\\n            if(rains[i] != 0){\\n                ans[i] = -1;\\n                if(mp.containsKey(rains[i])){\\n                    if(dryDays.isEmpty()) return new int[0];\\n                    var l = dryDays.higher(mp.get(rains[i]));\\n                    if(l == null) return new int[0];\\n                    ans[l] = rains[i];\\n                    dryDays.remove(l);\\n                }\\n                mp.put(rains[i],i);\\n            }\\n            else{\\n                ans[i] = 1;\\n                dryDays.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int ans[] = new int[rains.length];\\n        Map<Integer,Integer> mp = new HashMap<>();\\n        TreeSet<Integer> dryDays = new TreeSet<>();\\n        for(int i = 0;i < rains.length;i++){\\n            if(rains[i] != 0){\\n                ans[i] = -1;\\n                if(mp.containsKey(rains[i])){\\n                    if(dryDays.isEmpty()) return new int[0];\\n                    var l = dryDays.higher(mp.get(rains[i]));\\n                    if(l == null) return new int[0];\\n                    ans[l] = rains[i];\\n                    dryDays.remove(l);\\n                }\\n                mp.put(rains[i],i);\\n            }\\n            else{\\n                ans[i] = 1;\\n                dryDays.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943880,
                "title": "java-o-nlgn-binary-search-clean-and-elegent-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int[] result = new int[rains.length];\\n        Map<Integer, Integer> map = new HashMap<>(); \\n        List<Integer> list = new ArrayList<>(); // zero lake index\\n        Arrays.fill(result, -1);\\n        for (int index = 0; index < rains.length; index++) {\\n            if (rains[index] > 0) {\\n                if (map.containsKey(rains[index]) && list.isEmpty()) {\\n                    return new int[0];\\n                } else if (!map.containsKey(rains[index])) {\\n                    map.put(rains[index], index);\\n                } else if (map.containsKey(rains[index]) && !list.isEmpty()) {\\n                    int zeroIndex = findClosestZero(list, map.get(rains[index]), result);\\n                    if (zeroIndex == -1) {\\n                        return new int[0];\\n                    } else {\\n                        result[list.get(zeroIndex)] = rains[index];\\n                        map.put(rains[index], index);\\n                    }           \\n                }\\n            } else {\\n                list.add(index);\\n            }\\n        }\\n        for (int index = 0; index < list.size(); index++) {\\n            if (result[list.get(index)] == -1) {\\n                result[list.get(index)] = 1;\\n            }     \\n        }\\n        return result;\\n    }\\n\\n    public int findClosestZero(List<Integer> list, int index, int[] result) {\\n        int left = 0;\\n        int right = list.size() - 1;\\n        int answer = -1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n                                        //if the closet zero has already been used \\n            if (list.get(mid) < index || result[list.get(mid)] != -1) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n                answer = mid;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        int[] result = new int[rains.length];\\n        Map<Integer, Integer> map = new HashMap<>(); \\n        List<Integer> list = new ArrayList<>(); // zero lake index\\n        Arrays.fill(result, -1);\\n        for (int index = 0; index < rains.length; index++) {\\n            if (rains[index] > 0) {\\n                if (map.containsKey(rains[index]) && list.isEmpty()) {\\n                    return new int[0];\\n                } else if (!map.containsKey(rains[index])) {\\n                    map.put(rains[index], index);\\n                } else if (map.containsKey(rains[index]) && !list.isEmpty()) {\\n                    int zeroIndex = findClosestZero(list, map.get(rains[index]), result);\\n                    if (zeroIndex == -1) {\\n                        return new int[0];\\n                    } else {\\n                        result[list.get(zeroIndex)] = rains[index];\\n                        map.put(rains[index], index);\\n                    }           \\n                }\\n            } else {\\n                list.add(index);\\n            }\\n        }\\n        for (int index = 0; index < list.size(); index++) {\\n            if (result[list.get(index)] == -1) {\\n                result[list.get(index)] = 1;\\n            }     \\n        }\\n        return result;\\n    }\\n\\n    public int findClosestZero(List<Integer> list, int index, int[] result) {\\n        int left = 0;\\n        int right = list.size() - 1;\\n        int answer = -1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n                                        //if the closet zero has already been used \\n            if (list.get(mid) < index || result[list.get(mid)] != -1) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n                answer = mid;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937603,
                "title": "java-solution-binary-search-tree-set-beat-99",
                "content": "*If you like it **Please Kindly Upvote** this solution!*\\n\\n# Java Code:\\n```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        \\n        HashMap<Integer, Integer> lastRain = new HashMap<>();\\n        TreeSet<Integer> dry = new TreeSet<>();\\n\\n        int n = rains.length;\\n        int ans[] = new int[n];\\n\\n        for(int i = 0; i < n; i++) {\\n            int x = rains[i];\\n\\n            if(x == 0) {\\n                dry.add(i);\\n                ans[i] = 1;\\n            } else {\\n                Integer id = lastRain.get(x);\\n                if(id == null) {\\n                    lastRain.put(x, i);\\n                } else {\\n                    Integer drythisDay = dry.higher(id);\\n\\n                    if(drythisDay == null) {\\n                        return new int[0];\\n                    }\\n                    ans[drythisDay] = x;\\n                    dry.remove(drythisDay);\\n\\n                    lastRain.put(x, i);\\n                }\\n                ans[i] = -1;\\n            }\\n        } \\n        return ans;\\n    }\\n}\\n```\\n# Happy Coding:)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] avoidFlood(int[] rains) {\\n        \\n        HashMap<Integer, Integer> lastRain = new HashMap<>();\\n        TreeSet<Integer> dry = new TreeSet<>();\\n\\n        int n = rains.length;\\n        int ans[] = new int[n];\\n\\n        for(int i = 0; i < n; i++) {\\n            int x = rains[i];\\n\\n            if(x == 0) {\\n                dry.add(i);\\n                ans[i] = 1;\\n            } else {\\n                Integer id = lastRain.get(x);\\n                if(id == null) {\\n                    lastRain.put(x, i);\\n                } else {\\n                    Integer drythisDay = dry.higher(id);\\n\\n                    if(drythisDay == null) {\\n                        return new int[0];\\n                    }\\n                    ans[drythisDay] = x;\\n                    dry.remove(drythisDay);\\n\\n                    lastRain.put(x, i);\\n                }\\n                ans[i] = -1;\\n            }\\n        } \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869184,
                "title": "kotlin-treeset-solution",
                "content": "Reffers to [Luolingwei, [Python/Java] Python bisect / Java TreeSet solution](https://leetcode.com/problems/avoid-flood-in-the-city/solutions/697692/python-java-python-bisect-java-treeset-solution/?q=java&orderBy=most_relevant).\\n\\n# Code\\n```\\nclass Solution {\\n    fun avoidFlood(rains: IntArray): IntArray {\\n        val n: Int = rains.size\\n        val map = HashMap<Int, Int>()\\n        val zeroes = TreeSet<Int>()\\n        val res: IntArray = IntArray(n){1}\\n\\n        for(i in 0 until n) {\\n            if(rains[i] == 0) {\\n                zeroes.add(i)\\n            } else {\\n                if(map.containsKey(rains[i])) {\\n                    val next: Int? = zeroes.ceiling(map.get(rains[i]))\\n                    if(next == null) {\\n                        return IntArray(0){0}\\n                    }\\n                    res[next] = rains[i]\\n                    zeroes.remove(next)\\n                }\\n                map.put(rains[i], i)\\n                res[i] = -1\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun avoidFlood(rains: IntArray): IntArray {\\n        val n: Int = rains.size\\n        val map = HashMap<Int, Int>()\\n        val zeroes = TreeSet<Int>()\\n        val res: IntArray = IntArray(n){1}\\n\\n        for(i in 0 until n) {\\n            if(rains[i] == 0) {\\n                zeroes.add(i)\\n            } else {\\n                if(map.containsKey(rains[i])) {\\n                    val next: Int? = zeroes.ceiling(map.get(rains[i]))\\n                    if(next == null) {\\n                        return IntArray(0){0}\\n                    }\\n                    res[next] = rains[i]\\n                    zeroes.remove(next)\\n                }\\n                map.put(rains[i], i)\\n                res[i] = -1\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850099,
                "title": "python-hashmap-sortedlist-solution-faster-than-91-commented-simple",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        # dryDays = Set of available days that can be used for drying a full lake.\\n        dryDays, numDays = SortedList(), len(rains)\\n        # fullLakes is a hashMap which stores Lake number -> day on which it became full.\\n        fullLakes, ans = defaultdict(int), []\\n        for idx in range(numDays):\\n            if rains[idx] == 0:\\n                # This day can be used as a day to dry some lake.\\n                dryDays.add(idx)\\n                # Any number would be ok. This will get overwritten eventually.\\n                # If it doesn\\'t get overwritten, its totally ok to dry a lake\\n                # irrespective of whether it is full or empty.\\n                ans.append(1)\\n            # Rained in rains[i]-th lake.\\n            else:\\n                lake = rains[idx]\\n                if lake in fullLakes:\\n                    # We must dry this lake before it rains in this lake.\\n                    # So find a day in \"drydays\" to dry this lake. Obviously, that day must be\\n                    # a day that is after the day on which the lake was full.\\n                    # i.e. if the lake got full on 7th day, we must find a dry day that is \\n                    # greater than 7.\\n                    dryDayIdx = dryDays.bisect_left(fullLakes[lake])\\n                    # If there is no available dry day to dry the lake, flooding is inevitable.\\n                    if dryDayIdx == len(dryDays):\\n                        return []\\n                    # Great, we found a day which we can use to dry this lake.\\n                    dryDay = dryDays[dryDayIdx]\\n                    # Overwrite the \"1\" and dry \"lake\"-th lake instead.\\n                    ans[dryDay] = lake\\n                    # We dried \"lake\"-th lake on \"dryday\", and we can\\'t use the same day to \\n                    # dry any other lake, so remove the day from the set of available drydays.\\n                    dryDays.remove(dryDay)\\n                # Update that the \"lake\" became full on \"i\"-th day.\\n                fullLakes[lake] = idx\\n                # As the problem statement expects.\\n                ans.append(-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        # dryDays = Set of available days that can be used for drying a full lake.\\n        dryDays, numDays = SortedList(), len(rains)\\n        # fullLakes is a hashMap which stores Lake number -> day on which it became full.\\n        fullLakes, ans = defaultdict(int), []\\n        for idx in range(numDays):\\n            if rains[idx] == 0:\\n                # This day can be used as a day to dry some lake.\\n                dryDays.add(idx)\\n                # Any number would be ok. This will get overwritten eventually.\\n                # If it doesn\\'t get overwritten, its totally ok to dry a lake\\n                # irrespective of whether it is full or empty.\\n                ans.append(1)\\n            # Rained in rains[i]-th lake.\\n            else:\\n                lake = rains[idx]\\n                if lake in fullLakes:\\n                    # We must dry this lake before it rains in this lake.\\n                    # So find a day in \"drydays\" to dry this lake. Obviously, that day must be\\n                    # a day that is after the day on which the lake was full.\\n                    # i.e. if the lake got full on 7th day, we must find a dry day that is \\n                    # greater than 7.\\n                    dryDayIdx = dryDays.bisect_left(fullLakes[lake])\\n                    # If there is no available dry day to dry the lake, flooding is inevitable.\\n                    if dryDayIdx == len(dryDays):\\n                        return []\\n                    # Great, we found a day which we can use to dry this lake.\\n                    dryDay = dryDays[dryDayIdx]\\n                    # Overwrite the \"1\" and dry \"lake\"-th lake instead.\\n                    ans[dryDay] = lake\\n                    # We dried \"lake\"-th lake on \"dryday\", and we can\\'t use the same day to \\n                    # dry any other lake, so remove the day from the set of available drydays.\\n                    dryDays.remove(dryDay)\\n                # Update that the \"lake\" became full on \"i\"-th day.\\n                fullLakes[lake] = idx\\n                # As the problem statement expects.\\n                ans.append(-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796818,
                "title": "hashset-hashmap-binary-search-c",
                "content": "# Intuition \\nDry lakes only when there is a requirement\\nand while drying out the lake choose the closest day on which we can dry that particular lake\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity: O(2N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int> ans(rains.size(),1);\\n        map<int,int> mp;\\n        set<int> ms;\\n        for(int i=0;i<rains.size();i++){\\n            if(rains[i] == 0){\\n                ms.insert(i);\\n            }else if(mp.count(rains[i])){\\n                int last = mp[rains[i]];\\n                auto lb = ms.lower_bound(last);\\n                if(lb == ms.end()) return {};\\n                ans[*lb] = rains[i];\\n                ans[i] = -1;\\n                ms.erase(lb);\\n            }else{\\n                ans[i] = -1;\\n            }\\n            mp[rains[i]] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> avoidFlood(vector<int>& rains) {\\n        vector<int> ans(rains.size(),1);\\n        map<int,int> mp;\\n        set<int> ms;\\n        for(int i=0;i<rains.size();i++){\\n            if(rains[i] == 0){\\n                ms.insert(i);\\n            }else if(mp.count(rains[i])){\\n                int last = mp[rains[i]];\\n                auto lb = ms.lower_bound(last);\\n                if(lb == ms.end()) return {};\\n                ans[*lb] = rains[i];\\n                ans[i] = -1;\\n                ms.erase(lb);\\n            }else{\\n                ans[i] = -1;\\n            }\\n            mp[rains[i]] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795510,
                "title": "heap-solution-with-comments-python",
                "content": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        n = len(rains)\\n        ans = [1 for _ in range(n)]\\n        times = defaultdict(list)\\n        for day, lake in enumerate(rains):\\n            times[lake].append(day)\\n        for row in times.values():\\n            row.reverse()\\n            \\n        h = [] # heap that stores the next drying events by urgency\\n        for day, lake in enumerate(rains):\\n            if lake:\\n                row = times[lake]\\n                # if the row has only 1 element, we don\\'t need to dry\\n                if len(row) >= 2:\\n                    row.pop()\\n                    j = row[-1]\\n                    heappush(h, j)\\n                ans[day] = -1\\n            # if it doesn\\'t rain and the heap is not empty (which means that some drying event is available)\\n            elif h:\\n                j = heappop(h)\\n                if j < day:\\n                    return []\\n                ans[day] = rains[j]\\n        return ans if not h else []\\n    # Time: O(N * log(N))\\n    # Space: O(N)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def avoidFlood(self, rains: List[int]) -> List[int]:\\n        n = len(rains)\\n        ans = [1 for _ in range(n)]\\n        times = defaultdict(list)\\n        for day, lake in enumerate(rains):\\n            times[lake].append(day)\\n        for row in times.values():\\n            row.reverse()\\n            \\n        h = [] # heap that stores the next drying events by urgency\\n        for day, lake in enumerate(rains):\\n            if lake:\\n                row = times[lake]\\n                # if the row has only 1 element, we don\\'t need to dry\\n                if len(row) >= 2:\\n                    row.pop()\\n                    j = row[-1]\\n                    heappush(h, j)\\n                ans[day] = -1\\n            # if it doesn\\'t rain and the heap is not empty (which means that some drying event is available)\\n            elif h:\\n                j = heappop(h)\\n                if j < day:\\n                    return []\\n                ans[day] = rains[j]\\n        return ans if not h else []\\n    # Time: O(N * log(N))\\n    # Space: O(N)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1573953,
                "content": [
                    {
                        "username": "sumitm",
                        "content": "One test case for this question is not correct. Due to this my answer is not getting accepted:\\nInput\\n[69,0,0,0,69]\\n\\nOutput\\n[-1,69,-1,-1,-1]   << my o/p\\nExpected\\n[-1,69,1,1,-1]   << this is wrong expectation. We do not need to dry any lake on 3rd and 4th day"
                    },
                    {
                        "username": "JustBored",
                        "content": "This test case is so stupid, why do we have to dry lake 1 on day 2 and 3 when it never rained there in the first place. They should mention in the description that if there is no lake that needs to be dried, we still have to pick a random lake anyway"
                    },
                    {
                        "username": "user2049D",
                        "content": "What is indicated :\\nans[i] == -1 if rains[i] > 0\\n\\nFor a not rainy day, you have to chose one lake, even if it\\'s empty."
                    },
                    {
                        "username": "dawalrus",
                        "content": "[@introvert-99](/introvert-99) Yeah, I agree it's kind of stupid. Just take rains array of zeroes. Then set everything in the ans[] to 42. That answer is accepted. "
                    },
                    {
                        "username": "introvert9112k",
                        "content": "if there is any no Rain Day which is not used to dry out any lake, then take ans[i] as 1, then it would work. I think they forget to mention this in the question, explicitly. \\n\\nInitially I also confused why there is 1 for the no Rain Days for which no lake is dried. Later upon taking 1 for all such all  Rain Days my code got accepted. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "Amkchari",
                        "content": "When there are enough dry days and if i choose a lake which rained over before with all other lakes empty, it is coming as wrong answer. The expected answer is choose the default 1. Given lake 77698 didn\\'t get rain again, if we choose it or not should not matter, but choose lake 77698 as hightlighed below should be an acceptable alternatie answer.\\n\\ndoes any one have any comments.\\n\\nInput:\\n[24526,23938,93949,0,61370,0,0,80971,0,0,0,55547,0,80482,74942,77698,54795,0,0,0,0,**77698,0**,0,54410,0,0,23938,0,0,0,0,0,0,75018,0,0,47564,0,**24526,0**,0,0,48639,0,68554,39045,75357,48639,6992,0,47564,54410,0,0,0,74942,6992,40783,82220,0,75018,0,61370,0,0,68554,0,0,82220,0,40783,55547,80971,0,93949,87360,0,87360,39045,0,80482,75357,0,0,54795]\\nOutput:\\n[-1,-1,-1,23938,-1,61370,80971,-1,93949,24526,1,-1,55547,-1,-1,-1,-1,80482,77698,54795,74942,**-1,77698**,1,-1,54410,1,-1,23938,1,1,1,1,1,-1,75018,1,-1,47564,**-1,24526**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]\\nExpected:\\n[-1,-1,-1,23938,-1,24526,61370,-1,80971,93949,1,-1,55547,-1,-1,-1,-1,77698,74942,80482,54795,**-1,1**,1,-1,54410,1,-1,1,1,1,1,1,1,-1,75018,1,-1,47564,**-1,1**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]"
                    },
                    {
                        "username": "luanjunyi",
                        "content": "I think this is a very good problem.\\n\\nThe idea is to focus on rain days. \\n\\nfull[lake] is dict storing the day *lake* is filled by rain.\\n\\nOn each rain day(denoted as C), if the lake was not full, make it as full by marking full[lake] = C\\n\\nOtherwise, assume it\\'s rained on day X. Then find the next available spot(denoted as S) to dry after X. If S > C, then no solution. Otherwise dry it on S, and mark full[lake] = C.\\n\\nThe next question is how to find S. You can use bruteful to search. This is O(n^2) in worst case. I used a idea similar to unin find to make sure every position is searched at most once. Thus making overall alorighm O(n)."
                    },
                    {
                        "username": "wya",
                        "content": "For the test case: [2,3,0,0,3,1,0,1,0,2,2]\\n\\nShouldn\\'t [-1,-1,3,2,-1,-1,1,-1,1,-1,-1] work?\\n\\nWhy is the expected answer []."
                    },
                    {
                        "username": "dawalrus",
                        "content": "No, because of 2,2 in the end you are guaranteed a flood. "
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "finally solved it. :>"
                    },
                    {
                        "username": "Accepted_code",
                        "content": "why so slow\\n```\\nclass Solution {\\npublic:\\n   vector<int> avoidFlood(vector<int> &r)\\n{\\n    vector<int> a;\\n    unordered_map<int, int> mp;\\n    for (int i = 0; i < r.size(); i++)\\n    {\\n        if (r[i] == 0)\\n        {\\n            a.push_back(i);\\n            r[i] = 1;\\n        }\\n        else\\n        {\\n            if (mp.count(r[i]))\\n            {\\n                auto it = upper_bound(a.begin(), a.end(), mp[r[i]]);\\n                if (it == a.end())\\n                    return {};\\n                r[*it] = r[i];\\n                a.erase(it);\\n            }\\n            mp[r[i]] = i;\\n            r[i] = -1;\\n        }\\n    }\\n    return r;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1570805,
                "content": [
                    {
                        "username": "sumitm",
                        "content": "One test case for this question is not correct. Due to this my answer is not getting accepted:\\nInput\\n[69,0,0,0,69]\\n\\nOutput\\n[-1,69,-1,-1,-1]   << my o/p\\nExpected\\n[-1,69,1,1,-1]   << this is wrong expectation. We do not need to dry any lake on 3rd and 4th day"
                    },
                    {
                        "username": "JustBored",
                        "content": "This test case is so stupid, why do we have to dry lake 1 on day 2 and 3 when it never rained there in the first place. They should mention in the description that if there is no lake that needs to be dried, we still have to pick a random lake anyway"
                    },
                    {
                        "username": "user2049D",
                        "content": "What is indicated :\\nans[i] == -1 if rains[i] > 0\\n\\nFor a not rainy day, you have to chose one lake, even if it\\'s empty."
                    },
                    {
                        "username": "dawalrus",
                        "content": "[@introvert-99](/introvert-99) Yeah, I agree it's kind of stupid. Just take rains array of zeroes. Then set everything in the ans[] to 42. That answer is accepted. "
                    },
                    {
                        "username": "introvert9112k",
                        "content": "if there is any no Rain Day which is not used to dry out any lake, then take ans[i] as 1, then it would work. I think they forget to mention this in the question, explicitly. \\n\\nInitially I also confused why there is 1 for the no Rain Days for which no lake is dried. Later upon taking 1 for all such all  Rain Days my code got accepted. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "Amkchari",
                        "content": "When there are enough dry days and if i choose a lake which rained over before with all other lakes empty, it is coming as wrong answer. The expected answer is choose the default 1. Given lake 77698 didn\\'t get rain again, if we choose it or not should not matter, but choose lake 77698 as hightlighed below should be an acceptable alternatie answer.\\n\\ndoes any one have any comments.\\n\\nInput:\\n[24526,23938,93949,0,61370,0,0,80971,0,0,0,55547,0,80482,74942,77698,54795,0,0,0,0,**77698,0**,0,54410,0,0,23938,0,0,0,0,0,0,75018,0,0,47564,0,**24526,0**,0,0,48639,0,68554,39045,75357,48639,6992,0,47564,54410,0,0,0,74942,6992,40783,82220,0,75018,0,61370,0,0,68554,0,0,82220,0,40783,55547,80971,0,93949,87360,0,87360,39045,0,80482,75357,0,0,54795]\\nOutput:\\n[-1,-1,-1,23938,-1,61370,80971,-1,93949,24526,1,-1,55547,-1,-1,-1,-1,80482,77698,54795,74942,**-1,77698**,1,-1,54410,1,-1,23938,1,1,1,1,1,-1,75018,1,-1,47564,**-1,24526**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]\\nExpected:\\n[-1,-1,-1,23938,-1,24526,61370,-1,80971,93949,1,-1,55547,-1,-1,-1,-1,77698,74942,80482,54795,**-1,1**,1,-1,54410,1,-1,1,1,1,1,1,1,-1,75018,1,-1,47564,**-1,1**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]"
                    },
                    {
                        "username": "luanjunyi",
                        "content": "I think this is a very good problem.\\n\\nThe idea is to focus on rain days. \\n\\nfull[lake] is dict storing the day *lake* is filled by rain.\\n\\nOn each rain day(denoted as C), if the lake was not full, make it as full by marking full[lake] = C\\n\\nOtherwise, assume it\\'s rained on day X. Then find the next available spot(denoted as S) to dry after X. If S > C, then no solution. Otherwise dry it on S, and mark full[lake] = C.\\n\\nThe next question is how to find S. You can use bruteful to search. This is O(n^2) in worst case. I used a idea similar to unin find to make sure every position is searched at most once. Thus making overall alorighm O(n)."
                    },
                    {
                        "username": "wya",
                        "content": "For the test case: [2,3,0,0,3,1,0,1,0,2,2]\\n\\nShouldn\\'t [-1,-1,3,2,-1,-1,1,-1,1,-1,-1] work?\\n\\nWhy is the expected answer []."
                    },
                    {
                        "username": "dawalrus",
                        "content": "No, because of 2,2 in the end you are guaranteed a flood. "
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "finally solved it. :>"
                    },
                    {
                        "username": "Accepted_code",
                        "content": "why so slow\\n```\\nclass Solution {\\npublic:\\n   vector<int> avoidFlood(vector<int> &r)\\n{\\n    vector<int> a;\\n    unordered_map<int, int> mp;\\n    for (int i = 0; i < r.size(); i++)\\n    {\\n        if (r[i] == 0)\\n        {\\n            a.push_back(i);\\n            r[i] = 1;\\n        }\\n        else\\n        {\\n            if (mp.count(r[i]))\\n            {\\n                auto it = upper_bound(a.begin(), a.end(), mp[r[i]]);\\n                if (it == a.end())\\n                    return {};\\n                r[*it] = r[i];\\n                a.erase(it);\\n            }\\n            mp[r[i]] = i;\\n            r[i] = -1;\\n        }\\n    }\\n    return r;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1575153,
                "content": [
                    {
                        "username": "sumitm",
                        "content": "One test case for this question is not correct. Due to this my answer is not getting accepted:\\nInput\\n[69,0,0,0,69]\\n\\nOutput\\n[-1,69,-1,-1,-1]   << my o/p\\nExpected\\n[-1,69,1,1,-1]   << this is wrong expectation. We do not need to dry any lake on 3rd and 4th day"
                    },
                    {
                        "username": "JustBored",
                        "content": "This test case is so stupid, why do we have to dry lake 1 on day 2 and 3 when it never rained there in the first place. They should mention in the description that if there is no lake that needs to be dried, we still have to pick a random lake anyway"
                    },
                    {
                        "username": "user2049D",
                        "content": "What is indicated :\\nans[i] == -1 if rains[i] > 0\\n\\nFor a not rainy day, you have to chose one lake, even if it\\'s empty."
                    },
                    {
                        "username": "dawalrus",
                        "content": "[@introvert-99](/introvert-99) Yeah, I agree it's kind of stupid. Just take rains array of zeroes. Then set everything in the ans[] to 42. That answer is accepted. "
                    },
                    {
                        "username": "introvert9112k",
                        "content": "if there is any no Rain Day which is not used to dry out any lake, then take ans[i] as 1, then it would work. I think they forget to mention this in the question, explicitly. \\n\\nInitially I also confused why there is 1 for the no Rain Days for which no lake is dried. Later upon taking 1 for all such all  Rain Days my code got accepted. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "Amkchari",
                        "content": "When there are enough dry days and if i choose a lake which rained over before with all other lakes empty, it is coming as wrong answer. The expected answer is choose the default 1. Given lake 77698 didn\\'t get rain again, if we choose it or not should not matter, but choose lake 77698 as hightlighed below should be an acceptable alternatie answer.\\n\\ndoes any one have any comments.\\n\\nInput:\\n[24526,23938,93949,0,61370,0,0,80971,0,0,0,55547,0,80482,74942,77698,54795,0,0,0,0,**77698,0**,0,54410,0,0,23938,0,0,0,0,0,0,75018,0,0,47564,0,**24526,0**,0,0,48639,0,68554,39045,75357,48639,6992,0,47564,54410,0,0,0,74942,6992,40783,82220,0,75018,0,61370,0,0,68554,0,0,82220,0,40783,55547,80971,0,93949,87360,0,87360,39045,0,80482,75357,0,0,54795]\\nOutput:\\n[-1,-1,-1,23938,-1,61370,80971,-1,93949,24526,1,-1,55547,-1,-1,-1,-1,80482,77698,54795,74942,**-1,77698**,1,-1,54410,1,-1,23938,1,1,1,1,1,-1,75018,1,-1,47564,**-1,24526**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]\\nExpected:\\n[-1,-1,-1,23938,-1,24526,61370,-1,80971,93949,1,-1,55547,-1,-1,-1,-1,77698,74942,80482,54795,**-1,1**,1,-1,54410,1,-1,1,1,1,1,1,1,-1,75018,1,-1,47564,**-1,1**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]"
                    },
                    {
                        "username": "luanjunyi",
                        "content": "I think this is a very good problem.\\n\\nThe idea is to focus on rain days. \\n\\nfull[lake] is dict storing the day *lake* is filled by rain.\\n\\nOn each rain day(denoted as C), if the lake was not full, make it as full by marking full[lake] = C\\n\\nOtherwise, assume it\\'s rained on day X. Then find the next available spot(denoted as S) to dry after X. If S > C, then no solution. Otherwise dry it on S, and mark full[lake] = C.\\n\\nThe next question is how to find S. You can use bruteful to search. This is O(n^2) in worst case. I used a idea similar to unin find to make sure every position is searched at most once. Thus making overall alorighm O(n)."
                    },
                    {
                        "username": "wya",
                        "content": "For the test case: [2,3,0,0,3,1,0,1,0,2,2]\\n\\nShouldn\\'t [-1,-1,3,2,-1,-1,1,-1,1,-1,-1] work?\\n\\nWhy is the expected answer []."
                    },
                    {
                        "username": "dawalrus",
                        "content": "No, because of 2,2 in the end you are guaranteed a flood. "
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "finally solved it. :>"
                    },
                    {
                        "username": "Accepted_code",
                        "content": "why so slow\\n```\\nclass Solution {\\npublic:\\n   vector<int> avoidFlood(vector<int> &r)\\n{\\n    vector<int> a;\\n    unordered_map<int, int> mp;\\n    for (int i = 0; i < r.size(); i++)\\n    {\\n        if (r[i] == 0)\\n        {\\n            a.push_back(i);\\n            r[i] = 1;\\n        }\\n        else\\n        {\\n            if (mp.count(r[i]))\\n            {\\n                auto it = upper_bound(a.begin(), a.end(), mp[r[i]]);\\n                if (it == a.end())\\n                    return {};\\n                r[*it] = r[i];\\n                a.erase(it);\\n            }\\n            mp[r[i]] = i;\\n            r[i] = -1;\\n        }\\n    }\\n    return r;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1573964,
                "content": [
                    {
                        "username": "sumitm",
                        "content": "One test case for this question is not correct. Due to this my answer is not getting accepted:\\nInput\\n[69,0,0,0,69]\\n\\nOutput\\n[-1,69,-1,-1,-1]   << my o/p\\nExpected\\n[-1,69,1,1,-1]   << this is wrong expectation. We do not need to dry any lake on 3rd and 4th day"
                    },
                    {
                        "username": "JustBored",
                        "content": "This test case is so stupid, why do we have to dry lake 1 on day 2 and 3 when it never rained there in the first place. They should mention in the description that if there is no lake that needs to be dried, we still have to pick a random lake anyway"
                    },
                    {
                        "username": "user2049D",
                        "content": "What is indicated :\\nans[i] == -1 if rains[i] > 0\\n\\nFor a not rainy day, you have to chose one lake, even if it\\'s empty."
                    },
                    {
                        "username": "dawalrus",
                        "content": "[@introvert-99](/introvert-99) Yeah, I agree it's kind of stupid. Just take rains array of zeroes. Then set everything in the ans[] to 42. That answer is accepted. "
                    },
                    {
                        "username": "introvert9112k",
                        "content": "if there is any no Rain Day which is not used to dry out any lake, then take ans[i] as 1, then it would work. I think they forget to mention this in the question, explicitly. \\n\\nInitially I also confused why there is 1 for the no Rain Days for which no lake is dried. Later upon taking 1 for all such all  Rain Days my code got accepted. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "Amkchari",
                        "content": "When there are enough dry days and if i choose a lake which rained over before with all other lakes empty, it is coming as wrong answer. The expected answer is choose the default 1. Given lake 77698 didn\\'t get rain again, if we choose it or not should not matter, but choose lake 77698 as hightlighed below should be an acceptable alternatie answer.\\n\\ndoes any one have any comments.\\n\\nInput:\\n[24526,23938,93949,0,61370,0,0,80971,0,0,0,55547,0,80482,74942,77698,54795,0,0,0,0,**77698,0**,0,54410,0,0,23938,0,0,0,0,0,0,75018,0,0,47564,0,**24526,0**,0,0,48639,0,68554,39045,75357,48639,6992,0,47564,54410,0,0,0,74942,6992,40783,82220,0,75018,0,61370,0,0,68554,0,0,82220,0,40783,55547,80971,0,93949,87360,0,87360,39045,0,80482,75357,0,0,54795]\\nOutput:\\n[-1,-1,-1,23938,-1,61370,80971,-1,93949,24526,1,-1,55547,-1,-1,-1,-1,80482,77698,54795,74942,**-1,77698**,1,-1,54410,1,-1,23938,1,1,1,1,1,-1,75018,1,-1,47564,**-1,24526**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]\\nExpected:\\n[-1,-1,-1,23938,-1,24526,61370,-1,80971,93949,1,-1,55547,-1,-1,-1,-1,77698,74942,80482,54795,**-1,1**,1,-1,54410,1,-1,1,1,1,1,1,1,-1,75018,1,-1,47564,**-1,1**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]"
                    },
                    {
                        "username": "luanjunyi",
                        "content": "I think this is a very good problem.\\n\\nThe idea is to focus on rain days. \\n\\nfull[lake] is dict storing the day *lake* is filled by rain.\\n\\nOn each rain day(denoted as C), if the lake was not full, make it as full by marking full[lake] = C\\n\\nOtherwise, assume it\\'s rained on day X. Then find the next available spot(denoted as S) to dry after X. If S > C, then no solution. Otherwise dry it on S, and mark full[lake] = C.\\n\\nThe next question is how to find S. You can use bruteful to search. This is O(n^2) in worst case. I used a idea similar to unin find to make sure every position is searched at most once. Thus making overall alorighm O(n)."
                    },
                    {
                        "username": "wya",
                        "content": "For the test case: [2,3,0,0,3,1,0,1,0,2,2]\\n\\nShouldn\\'t [-1,-1,3,2,-1,-1,1,-1,1,-1,-1] work?\\n\\nWhy is the expected answer []."
                    },
                    {
                        "username": "dawalrus",
                        "content": "No, because of 2,2 in the end you are guaranteed a flood. "
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "finally solved it. :>"
                    },
                    {
                        "username": "Accepted_code",
                        "content": "why so slow\\n```\\nclass Solution {\\npublic:\\n   vector<int> avoidFlood(vector<int> &r)\\n{\\n    vector<int> a;\\n    unordered_map<int, int> mp;\\n    for (int i = 0; i < r.size(); i++)\\n    {\\n        if (r[i] == 0)\\n        {\\n            a.push_back(i);\\n            r[i] = 1;\\n        }\\n        else\\n        {\\n            if (mp.count(r[i]))\\n            {\\n                auto it = upper_bound(a.begin(), a.end(), mp[r[i]]);\\n                if (it == a.end())\\n                    return {};\\n                r[*it] = r[i];\\n                a.erase(it);\\n            }\\n            mp[r[i]] = i;\\n            r[i] = -1;\\n        }\\n    }\\n    return r;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1574022,
                "content": [
                    {
                        "username": "sumitm",
                        "content": "One test case for this question is not correct. Due to this my answer is not getting accepted:\\nInput\\n[69,0,0,0,69]\\n\\nOutput\\n[-1,69,-1,-1,-1]   << my o/p\\nExpected\\n[-1,69,1,1,-1]   << this is wrong expectation. We do not need to dry any lake on 3rd and 4th day"
                    },
                    {
                        "username": "JustBored",
                        "content": "This test case is so stupid, why do we have to dry lake 1 on day 2 and 3 when it never rained there in the first place. They should mention in the description that if there is no lake that needs to be dried, we still have to pick a random lake anyway"
                    },
                    {
                        "username": "user2049D",
                        "content": "What is indicated :\\nans[i] == -1 if rains[i] > 0\\n\\nFor a not rainy day, you have to chose one lake, even if it\\'s empty."
                    },
                    {
                        "username": "dawalrus",
                        "content": "[@introvert-99](/introvert-99) Yeah, I agree it's kind of stupid. Just take rains array of zeroes. Then set everything in the ans[] to 42. That answer is accepted. "
                    },
                    {
                        "username": "introvert9112k",
                        "content": "if there is any no Rain Day which is not used to dry out any lake, then take ans[i] as 1, then it would work. I think they forget to mention this in the question, explicitly. \\n\\nInitially I also confused why there is 1 for the no Rain Days for which no lake is dried. Later upon taking 1 for all such all  Rain Days my code got accepted. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "Amkchari",
                        "content": "When there are enough dry days and if i choose a lake which rained over before with all other lakes empty, it is coming as wrong answer. The expected answer is choose the default 1. Given lake 77698 didn\\'t get rain again, if we choose it or not should not matter, but choose lake 77698 as hightlighed below should be an acceptable alternatie answer.\\n\\ndoes any one have any comments.\\n\\nInput:\\n[24526,23938,93949,0,61370,0,0,80971,0,0,0,55547,0,80482,74942,77698,54795,0,0,0,0,**77698,0**,0,54410,0,0,23938,0,0,0,0,0,0,75018,0,0,47564,0,**24526,0**,0,0,48639,0,68554,39045,75357,48639,6992,0,47564,54410,0,0,0,74942,6992,40783,82220,0,75018,0,61370,0,0,68554,0,0,82220,0,40783,55547,80971,0,93949,87360,0,87360,39045,0,80482,75357,0,0,54795]\\nOutput:\\n[-1,-1,-1,23938,-1,61370,80971,-1,93949,24526,1,-1,55547,-1,-1,-1,-1,80482,77698,54795,74942,**-1,77698**,1,-1,54410,1,-1,23938,1,1,1,1,1,-1,75018,1,-1,47564,**-1,24526**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]\\nExpected:\\n[-1,-1,-1,23938,-1,24526,61370,-1,80971,93949,1,-1,55547,-1,-1,-1,-1,77698,74942,80482,54795,**-1,1**,1,-1,54410,1,-1,1,1,1,1,1,1,-1,75018,1,-1,47564,**-1,1**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]"
                    },
                    {
                        "username": "luanjunyi",
                        "content": "I think this is a very good problem.\\n\\nThe idea is to focus on rain days. \\n\\nfull[lake] is dict storing the day *lake* is filled by rain.\\n\\nOn each rain day(denoted as C), if the lake was not full, make it as full by marking full[lake] = C\\n\\nOtherwise, assume it\\'s rained on day X. Then find the next available spot(denoted as S) to dry after X. If S > C, then no solution. Otherwise dry it on S, and mark full[lake] = C.\\n\\nThe next question is how to find S. You can use bruteful to search. This is O(n^2) in worst case. I used a idea similar to unin find to make sure every position is searched at most once. Thus making overall alorighm O(n)."
                    },
                    {
                        "username": "wya",
                        "content": "For the test case: [2,3,0,0,3,1,0,1,0,2,2]\\n\\nShouldn\\'t [-1,-1,3,2,-1,-1,1,-1,1,-1,-1] work?\\n\\nWhy is the expected answer []."
                    },
                    {
                        "username": "dawalrus",
                        "content": "No, because of 2,2 in the end you are guaranteed a flood. "
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "finally solved it. :>"
                    },
                    {
                        "username": "Accepted_code",
                        "content": "why so slow\\n```\\nclass Solution {\\npublic:\\n   vector<int> avoidFlood(vector<int> &r)\\n{\\n    vector<int> a;\\n    unordered_map<int, int> mp;\\n    for (int i = 0; i < r.size(); i++)\\n    {\\n        if (r[i] == 0)\\n        {\\n            a.push_back(i);\\n            r[i] = 1;\\n        }\\n        else\\n        {\\n            if (mp.count(r[i]))\\n            {\\n                auto it = upper_bound(a.begin(), a.end(), mp[r[i]]);\\n                if (it == a.end())\\n                    return {};\\n                r[*it] = r[i];\\n                a.erase(it);\\n            }\\n            mp[r[i]] = i;\\n            r[i] = -1;\\n        }\\n    }\\n    return r;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1977567,
                "content": [
                    {
                        "username": "sumitm",
                        "content": "One test case for this question is not correct. Due to this my answer is not getting accepted:\\nInput\\n[69,0,0,0,69]\\n\\nOutput\\n[-1,69,-1,-1,-1]   << my o/p\\nExpected\\n[-1,69,1,1,-1]   << this is wrong expectation. We do not need to dry any lake on 3rd and 4th day"
                    },
                    {
                        "username": "JustBored",
                        "content": "This test case is so stupid, why do we have to dry lake 1 on day 2 and 3 when it never rained there in the first place. They should mention in the description that if there is no lake that needs to be dried, we still have to pick a random lake anyway"
                    },
                    {
                        "username": "user2049D",
                        "content": "What is indicated :\\nans[i] == -1 if rains[i] > 0\\n\\nFor a not rainy day, you have to chose one lake, even if it\\'s empty."
                    },
                    {
                        "username": "dawalrus",
                        "content": "[@introvert-99](/introvert-99) Yeah, I agree it's kind of stupid. Just take rains array of zeroes. Then set everything in the ans[] to 42. That answer is accepted. "
                    },
                    {
                        "username": "introvert9112k",
                        "content": "if there is any no Rain Day which is not used to dry out any lake, then take ans[i] as 1, then it would work. I think they forget to mention this in the question, explicitly. \\n\\nInitially I also confused why there is 1 for the no Rain Days for which no lake is dried. Later upon taking 1 for all such all  Rain Days my code got accepted. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "Amkchari",
                        "content": "When there are enough dry days and if i choose a lake which rained over before with all other lakes empty, it is coming as wrong answer. The expected answer is choose the default 1. Given lake 77698 didn\\'t get rain again, if we choose it or not should not matter, but choose lake 77698 as hightlighed below should be an acceptable alternatie answer.\\n\\ndoes any one have any comments.\\n\\nInput:\\n[24526,23938,93949,0,61370,0,0,80971,0,0,0,55547,0,80482,74942,77698,54795,0,0,0,0,**77698,0**,0,54410,0,0,23938,0,0,0,0,0,0,75018,0,0,47564,0,**24526,0**,0,0,48639,0,68554,39045,75357,48639,6992,0,47564,54410,0,0,0,74942,6992,40783,82220,0,75018,0,61370,0,0,68554,0,0,82220,0,40783,55547,80971,0,93949,87360,0,87360,39045,0,80482,75357,0,0,54795]\\nOutput:\\n[-1,-1,-1,23938,-1,61370,80971,-1,93949,24526,1,-1,55547,-1,-1,-1,-1,80482,77698,54795,74942,**-1,77698**,1,-1,54410,1,-1,23938,1,1,1,1,1,-1,75018,1,-1,47564,**-1,24526**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]\\nExpected:\\n[-1,-1,-1,23938,-1,24526,61370,-1,80971,93949,1,-1,55547,-1,-1,-1,-1,77698,74942,80482,54795,**-1,1**,1,-1,54410,1,-1,1,1,1,1,1,1,-1,75018,1,-1,47564,**-1,1**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]"
                    },
                    {
                        "username": "luanjunyi",
                        "content": "I think this is a very good problem.\\n\\nThe idea is to focus on rain days. \\n\\nfull[lake] is dict storing the day *lake* is filled by rain.\\n\\nOn each rain day(denoted as C), if the lake was not full, make it as full by marking full[lake] = C\\n\\nOtherwise, assume it\\'s rained on day X. Then find the next available spot(denoted as S) to dry after X. If S > C, then no solution. Otherwise dry it on S, and mark full[lake] = C.\\n\\nThe next question is how to find S. You can use bruteful to search. This is O(n^2) in worst case. I used a idea similar to unin find to make sure every position is searched at most once. Thus making overall alorighm O(n)."
                    },
                    {
                        "username": "wya",
                        "content": "For the test case: [2,3,0,0,3,1,0,1,0,2,2]\\n\\nShouldn\\'t [-1,-1,3,2,-1,-1,1,-1,1,-1,-1] work?\\n\\nWhy is the expected answer []."
                    },
                    {
                        "username": "dawalrus",
                        "content": "No, because of 2,2 in the end you are guaranteed a flood. "
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "finally solved it. :>"
                    },
                    {
                        "username": "Accepted_code",
                        "content": "why so slow\\n```\\nclass Solution {\\npublic:\\n   vector<int> avoidFlood(vector<int> &r)\\n{\\n    vector<int> a;\\n    unordered_map<int, int> mp;\\n    for (int i = 0; i < r.size(); i++)\\n    {\\n        if (r[i] == 0)\\n        {\\n            a.push_back(i);\\n            r[i] = 1;\\n        }\\n        else\\n        {\\n            if (mp.count(r[i]))\\n            {\\n                auto it = upper_bound(a.begin(), a.end(), mp[r[i]]);\\n                if (it == a.end())\\n                    return {};\\n                r[*it] = r[i];\\n                a.erase(it);\\n            }\\n            mp[r[i]] = i;\\n            r[i] = -1;\\n        }\\n    }\\n    return r;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1774391,
                "content": [
                    {
                        "username": "sumitm",
                        "content": "One test case for this question is not correct. Due to this my answer is not getting accepted:\\nInput\\n[69,0,0,0,69]\\n\\nOutput\\n[-1,69,-1,-1,-1]   << my o/p\\nExpected\\n[-1,69,1,1,-1]   << this is wrong expectation. We do not need to dry any lake on 3rd and 4th day"
                    },
                    {
                        "username": "JustBored",
                        "content": "This test case is so stupid, why do we have to dry lake 1 on day 2 and 3 when it never rained there in the first place. They should mention in the description that if there is no lake that needs to be dried, we still have to pick a random lake anyway"
                    },
                    {
                        "username": "user2049D",
                        "content": "What is indicated :\\nans[i] == -1 if rains[i] > 0\\n\\nFor a not rainy day, you have to chose one lake, even if it\\'s empty."
                    },
                    {
                        "username": "dawalrus",
                        "content": "[@introvert-99](/introvert-99) Yeah, I agree it's kind of stupid. Just take rains array of zeroes. Then set everything in the ans[] to 42. That answer is accepted. "
                    },
                    {
                        "username": "introvert9112k",
                        "content": "if there is any no Rain Day which is not used to dry out any lake, then take ans[i] as 1, then it would work. I think they forget to mention this in the question, explicitly. \\n\\nInitially I also confused why there is 1 for the no Rain Days for which no lake is dried. Later upon taking 1 for all such all  Rain Days my code got accepted. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "Amkchari",
                        "content": "When there are enough dry days and if i choose a lake which rained over before with all other lakes empty, it is coming as wrong answer. The expected answer is choose the default 1. Given lake 77698 didn\\'t get rain again, if we choose it or not should not matter, but choose lake 77698 as hightlighed below should be an acceptable alternatie answer.\\n\\ndoes any one have any comments.\\n\\nInput:\\n[24526,23938,93949,0,61370,0,0,80971,0,0,0,55547,0,80482,74942,77698,54795,0,0,0,0,**77698,0**,0,54410,0,0,23938,0,0,0,0,0,0,75018,0,0,47564,0,**24526,0**,0,0,48639,0,68554,39045,75357,48639,6992,0,47564,54410,0,0,0,74942,6992,40783,82220,0,75018,0,61370,0,0,68554,0,0,82220,0,40783,55547,80971,0,93949,87360,0,87360,39045,0,80482,75357,0,0,54795]\\nOutput:\\n[-1,-1,-1,23938,-1,61370,80971,-1,93949,24526,1,-1,55547,-1,-1,-1,-1,80482,77698,54795,74942,**-1,77698**,1,-1,54410,1,-1,23938,1,1,1,1,1,-1,75018,1,-1,47564,**-1,24526**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]\\nExpected:\\n[-1,-1,-1,23938,-1,24526,61370,-1,80971,93949,1,-1,55547,-1,-1,-1,-1,77698,74942,80482,54795,**-1,1**,1,-1,54410,1,-1,1,1,1,1,1,1,-1,75018,1,-1,47564,**-1,1**,1,1,-1,48639,-1,-1,-1,-1,-1,6992,-1,-1,68554,39045,75357,-1,-1,-1,-1,82220,-1,40783,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,87360,-1,-1,1,-1,-1,1,1,-1]"
                    },
                    {
                        "username": "luanjunyi",
                        "content": "I think this is a very good problem.\\n\\nThe idea is to focus on rain days. \\n\\nfull[lake] is dict storing the day *lake* is filled by rain.\\n\\nOn each rain day(denoted as C), if the lake was not full, make it as full by marking full[lake] = C\\n\\nOtherwise, assume it\\'s rained on day X. Then find the next available spot(denoted as S) to dry after X. If S > C, then no solution. Otherwise dry it on S, and mark full[lake] = C.\\n\\nThe next question is how to find S. You can use bruteful to search. This is O(n^2) in worst case. I used a idea similar to unin find to make sure every position is searched at most once. Thus making overall alorighm O(n)."
                    },
                    {
                        "username": "wya",
                        "content": "For the test case: [2,3,0,0,3,1,0,1,0,2,2]\\n\\nShouldn\\'t [-1,-1,3,2,-1,-1,1,-1,1,-1,-1] work?\\n\\nWhy is the expected answer []."
                    },
                    {
                        "username": "dawalrus",
                        "content": "No, because of 2,2 in the end you are guaranteed a flood. "
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "finally solved it. :>"
                    },
                    {
                        "username": "Accepted_code",
                        "content": "why so slow\\n```\\nclass Solution {\\npublic:\\n   vector<int> avoidFlood(vector<int> &r)\\n{\\n    vector<int> a;\\n    unordered_map<int, int> mp;\\n    for (int i = 0; i < r.size(); i++)\\n    {\\n        if (r[i] == 0)\\n        {\\n            a.push_back(i);\\n            r[i] = 1;\\n        }\\n        else\\n        {\\n            if (mp.count(r[i]))\\n            {\\n                auto it = upper_bound(a.begin(), a.end(), mp[r[i]]);\\n                if (it == a.end())\\n                    return {};\\n                r[*it] = r[i];\\n                a.erase(it);\\n            }\\n            mp[r[i]] = i;\\n            r[i] = -1;\\n        }\\n    }\\n    return r;\\n}\\n};"
                    }
                ]
            }
        ]
    }
]