[
    {
        "title": "Count the Number of Ideal Arrays",
        "question_content": "You are given two integers n and maxValue, which are used to describe an ideal array.\nA 0-indexed integer array arr of length n is considered ideal if the following conditions hold:\n\n\tEvery arr[i] is a value from 1 to maxValue, for 0 <= i < n.\n\tEvery arr[i] is divisible by arr[i - 1], for 0 < i < n.\n\nReturn the number of distinct ideal arrays of length n. Since the answer may be very large, return it modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: n = 2, maxValue = 5\nOutput: 10\nExplanation: The following are the possible ideal arrays:\n- Arrays starting with the value 1 (5 arrays): [1,1], [1,2], [1,3], [1,4], [1,5]\n- Arrays starting with the value 2 (2 arrays): [2,2], [2,4]\n- Arrays starting with the value 3 (1 array): [3,3]\n- Arrays starting with the value 4 (1 array): [4,4]\n- Arrays starting with the value 5 (1 array): [5,5]\nThere are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays.\n\nExample 2:\n\nInput: n = 5, maxValue = 3\nOutput: 11\nExplanation: The following are the possible ideal arrays:\n- Arrays starting with the value 1 (9 arrays): \n   - With no other distinct values (1 array): [1,1,1,1,1] \n   - With 2nd distinct value 2 (4 arrays): [1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]\n   - With 2nd distinct value 3 (4 arrays): [1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]\n- Arrays starting with the value 2 (1 array): [2,2,2,2,2]\n- Arrays starting with the value 3 (1 array): [3,3,3,3,3]\nThere are a total of 9 + 1 + 1 = 11 distinct ideal arrays.\n\n&nbsp;\nConstraints:\n\n\t2 <= n <= 104\n\t1 <= maxValue <= 104",
        "solutions": [
            {
                "id": 2262093,
                "title": "java-passed-understandable-solution-will-illustration-solving-strictly-increasing-case-first",
                "content": "**Take the hints:**\\n1. Notice that an ideal array is non-decreasing.\\n2. Consider an alternative problem: where an ideal array must also be strictly increasing. Use DP to solve it.\\n3. Use combinatorics to get an answer to the actual problem from the alternative problem.\\n\\n**DP idea:**\\n```\\ndp[i][j]: the number of ideal array of length i ending with number j\\ndp[i][j] = sum(dp[i-1][k]) where j is divisible by k\\n```\\n\\n**How to get answer to the actual problem from the alternative problem:**\\nIdea is the same as [stars and bars](https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics))\\nTake a strictly increasing ideal array of length `len1`, we can repeat numbers in the array to create an ideal array of longer length `len2`. For example, from [1, 2, 4], we can get [1,1,1,2,4], [1,1,2,2,4],[1,2,4,4,4], ...\\n\\n**How combinatorics comes into play:**\\nFor example, we want to translate a strictly increasing array [1,2,4] of length 3 into an ideal array of length 5, then we need to decide how many 1s to fill, how many 2s to fill, and how many 4s to fill in the ideal array. \\n```\\nideal array: _ _ _ _ _ (5 positions to fill)\\n```\\nWe can split it into 3 subarrays by putting 2 bars between any positions. Some valid ways to split:\\n```\\n_ | _ | _ _ _ (this translates to 1 | 2 | 4 4 4 )\\n_ _ | _ | _ _ (this translates to 1 1 | 2 | 4 4 )\\n```\\nThis is essentially choosing 2 from 4 (2 bars to place, 4 potential places to put the bars)\\nTo generalize, \\n```\\nN = The number of ways to create a ideal array of length len2 from a strictly increasing ideal array of length len1\\nN = nChooseK(len2 - 1, len1 - 1)\\nThere are len2 - 1 of potential places to put the bars\\nThere are len1 - 1 bars to place\\n```\\n\\n**Why the length of strictly increasing ideal array is at most 14?**\\nNote that 2^14 > 10,000, so the longest striclty increasing ideal array is:\\n[1, 2, 4, 8, ..., 8096] or\\n[2^0, 2^1, 2^2, ..., 2^13]\\n\\n \\n**Code**\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int idealArrays(int n, int maxValue) {\\n        int m = 1000000007;\\n        BigInteger res = BigInteger.ZERO;\\n        long[][] dp = new long[15][maxValue + 1]; \\n        Map<Integer, List<Integer>> map = buildMap(maxValue);\\n        \\n        // step 1: compute dp for the alternative problem (strictly increasing case)\\n        for (int i = 1; i <= maxValue; i++) {\\n            dp[1][i] = 1;\\n        }\\n        for (int i = 2; i <= n && i <= 14; i++) {\\n            for (int j = 1; j <= maxValue; j++) {\\n                for (int k : map.get(j)) {\\n                    dp[i][j] += dp[i - 1][k];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        }\\n        for (int i = 1; i <= n && i <= 14; i++) {\\n            for (int j = 1; j <= maxValue; j++) {\\n                dp[i][0] += dp[i][j];\\n                dp[i][0] %= m; // dp[i][0] = number of ideal arrays (strictly increasing case) of length i\\n            }\\n        }\\n        \\n        // step 2: use combinatorics to get the final answer for the actual problem from the alternative problem (strictly increasing case)\\n        for (int i = 1; i <= n && i <= 14; i++) {\\n            res = res.add(nCk(n - 1, i - 1).multiply(BigInteger.valueOf(dp[i][0])));\\n            res = res.mod(BigInteger.valueOf(m));\\n        }\\n        return res.intValue();\\n    }\\n    \\n    // helper function to compute \"n choose k\" \\n    private BigInteger nCk(int n, int k) {\\n        BigInteger res = BigInteger.ONE;\\n        for (int i = 1; i <=k; i++) {\\n            res = res.multiply(BigInteger.valueOf(n - (i - 1))).divide(BigInteger.valueOf(i));\\n        }\\n        return res;\\n    }\\n    \\n    // helper funciton to build map {Integer -> {its divisors}}\\n    private Map<Integer, List<Integer>> buildMap(int maxValue) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 1; i <= maxValue; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for (int i = 1; i <= maxValue; i++) {\\n            int j = i * 2; // strictly increasing\\n            while (j <= maxValue) {\\n                map.get(j).add(i);\\n                j += i;\\n            }\\n        }\\n        return map;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j]: the number of ideal array of length i ending with number j\\ndp[i][j] = sum(dp[i-1][k]) where j is divisible by k\\n```\n```\\nideal array: _ _ _ _ _ (5 positions to fill)\\n```\n```\\n_ | _ | _ _ _ (this translates to 1 | 2 | 4 4 4 )\\n_ _ | _ | _ _ (this translates to 1 1 | 2 | 4 4 )\\n```\n```\\nN = The number of ways to create a ideal array of length len2 from a strictly increasing ideal array of length len1\\nN = nChooseK(len2 - 1, len1 - 1)\\nThere are len2 - 1 of potential places to put the bars\\nThere are len1 - 1 bars to place\\n```\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int idealArrays(int n, int maxValue) {\\n        int m = 1000000007;\\n        BigInteger res = BigInteger.ZERO;\\n        long[][] dp = new long[15][maxValue + 1]; \\n        Map<Integer, List<Integer>> map = buildMap(maxValue);\\n        \\n        // step 1: compute dp for the alternative problem (strictly increasing case)\\n        for (int i = 1; i <= maxValue; i++) {\\n            dp[1][i] = 1;\\n        }\\n        for (int i = 2; i <= n && i <= 14; i++) {\\n            for (int j = 1; j <= maxValue; j++) {\\n                for (int k : map.get(j)) {\\n                    dp[i][j] += dp[i - 1][k];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        }\\n        for (int i = 1; i <= n && i <= 14; i++) {\\n            for (int j = 1; j <= maxValue; j++) {\\n                dp[i][0] += dp[i][j];\\n                dp[i][0] %= m; // dp[i][0] = number of ideal arrays (strictly increasing case) of length i\\n            }\\n        }\\n        \\n        // step 2: use combinatorics to get the final answer for the actual problem from the alternative problem (strictly increasing case)\\n        for (int i = 1; i <= n && i <= 14; i++) {\\n            res = res.add(nCk(n - 1, i - 1).multiply(BigInteger.valueOf(dp[i][0])));\\n            res = res.mod(BigInteger.valueOf(m));\\n        }\\n        return res.intValue();\\n    }\\n    \\n    // helper function to compute \"n choose k\" \\n    private BigInteger nCk(int n, int k) {\\n        BigInteger res = BigInteger.ONE;\\n        for (int i = 1; i <=k; i++) {\\n            res = res.multiply(BigInteger.valueOf(n - (i - 1))).divide(BigInteger.valueOf(i));\\n        }\\n        return res;\\n    }\\n    \\n    // helper funciton to build map {Integer -> {its divisors}}\\n    private Map<Integer, List<Integer>> buildMap(int maxValue) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 1; i <= maxValue; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for (int i = 1; i <= maxValue; i++) {\\n            int j = i * 2; // strictly increasing\\n            while (j <= maxValue) {\\n                map.get(j).add(i);\\n                j += i;\\n            }\\n        }\\n        return map;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261280,
                "title": "python-arranging-primes-intro-to-combinatorics",
                "content": "Consider a value, `v`, where `1 <= v <= maxValue`. If we\\'re going to end the array with the number v, then we\\'re going to have to \"place\" every prime factor of v somewhere in one of the array\\'s n indices. \\n\\nWhen I say \"place\" a prime at index `i`, I mean we multiply every element from `i` up to `n - 1` with the prime, so it \"shows up\" in every number up to v at the end. So, we\\'ll count the number of ways to arrange each prime `p` of value `v`, multiply each number of ways together, and add up each of these products for all `v`. \\n\\nIf we only have one prime of a certain type, call it p, then it\\'s easy to figure out how many different arrays this can give us: the ability to place the prime at any of our n indices just multiplies the number of different arrays by n. \\n\\nBut if there\\'s more than one prime of one type - say `k` primes of this type - then it\\'s a little harder, because we can\\'t count duplicates. For example, n = 2 and v = 4, we\\'d count `[2, 2]` twice if we multiplied by n two times (one for each prime). The solution here is to use `nCr` instead; count the ways to arrange `k` primes among `n` possible spaces. For k = 2, it\\'s `n * (n + 1) / 2`. For k = 3, it\\'s `n * (n + 1) * (n + 2) / (2 * 3)`, and so on.\\n\\nCode is a bit long, but most of it is just auxiliary code to get prime factors.\\n\\n```\\nfrom math import sqrt\\n\\nclass Solution:\\n    def primesUpTo(self, n):\\n        primes = set(range(2, n + 1))\\n        for i in range(2, n):\\n            if i in primes:\\n                it = i * 2\\n                while it <= n:\\n                    if it in primes:\\n                        primes.remove(it)\\n                    it += i\\n\\n        return primes\\n\\n    def getPrimeFactors(self, n, primes):\\n        ret = {}\\n        sq = int(math.sqrt(n))\\n\\n        for p in primes:\\n            if n in primes:\\n                ret[n] = 1\\n                break\\n\\n            while n % p == 0:\\n                ret[p] = ret.get(p, 0) + 1\\n                n //= p\\n\\n            if n <= 1:\\n                break\\n\\n        return ret\\n        \\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        mod = 10**9 + 7\\n        ret = 0\\n        primes = self.primesUpTo(maxValue)\\n        \\n        for num in range(1, maxValue + 1):\\n            # find number of arrays that can end with num\\n            # for each prime factor, we can add it at any index i that we want\\n            pf = self.getPrimeFactors(num, primes)\\n            cur = 1\\n            for d in pf:\\n                ct = pf[d]\\n                v = n\\n                # there are (n + 1) choose k ways to add k prime factors\\n                for add in range(1, ct):\\n                    v *= (n + add)\\n                    v //= (add + 1)\\n                \\n                cur = (cur * v) % mod\\n                    \\n            ret = (ret + cur) % mod\\n                    \\n        return ret\\n```\\n\\nHappy to answer any questions in the comments, I wrote this kind of quickly so I may have glossed over some details. If you found this useful and want to learn more about combinatorics and higher-level math in competitive programming/interview problems, [check out this post I made explaining another mathy problem on Leetcode.](https://leetcode.com/problems/kth-smallest-instructions/discuss/918396/python-math-solution-introduction-to-combinatorics)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nfrom math import sqrt\\n\\nclass Solution:\\n    def primesUpTo(self, n):\\n        primes = set(range(2, n + 1))\\n        for i in range(2, n):\\n            if i in primes:\\n                it = i * 2\\n                while it <= n:\\n                    if it in primes:\\n                        primes.remove(it)\\n                    it += i\\n\\n        return primes\\n\\n    def getPrimeFactors(self, n, primes):\\n        ret = {}\\n        sq = int(math.sqrt(n))\\n\\n        for p in primes:\\n            if n in primes:\\n                ret[n] = 1\\n                break\\n\\n            while n % p == 0:\\n                ret[p] = ret.get(p, 0) + 1\\n                n //= p\\n\\n            if n <= 1:\\n                break\\n\\n        return ret\\n        \\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        mod = 10**9 + 7\\n        ret = 0\\n        primes = self.primesUpTo(maxValue)\\n        \\n        for num in range(1, maxValue + 1):\\n            # find number of arrays that can end with num\\n            # for each prime factor, we can add it at any index i that we want\\n            pf = self.getPrimeFactors(num, primes)\\n            cur = 1\\n            for d in pf:\\n                ct = pf[d]\\n                v = n\\n                # there are (n + 1) choose k ways to add k prime factors\\n                for add in range(1, ct):\\n                    v *= (n + add)\\n                    v //= (add + 1)\\n                \\n                cur = (cur * v) % mod\\n                    \\n            ret = (ret + cur) % mod\\n                    \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261608,
                "title": "python3-2-solutions-explained-from-bfs-tle-to-dp-beat-100",
                "content": "BFS solution (TLE):\\neach state in the queue represents a valid sequence of elements by [last_element, length]. e.g. 1,3 is represented by [3, 2]; 1,2,4,8 is represented by [8, 4]. \\n\\ninitial states contains [i, 1] for all 1 <= i <= mx, then simply BFS it: for each state, get the next states by iterating all multipliers of the last element, until either length = n or multiplier > mx.\\n\\ngen(k) computes number of valid arrays from k numbers with \\'[stars and bars](https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics))\\'. e.g. for n = 3, gen(2) = 2 (say the sequence is [1,2] valid arrays of length 3 are [1,1,2], [1,2,2])\\n\\n```\\nclass Solution:\\n    def idealArrays(self, n: int, mx: int) -> int:\\n        \\n        @lru_cache(None)\\n        def gen(k):            \\n            return math.comb(n-1, k-1)\\n        \\n        q = deque([[i, 1] for i in range(1, mx+1)])\\n        res = 0\\n        \\n        while q:\\n            cur, l = q.popleft()\\n            res += gen(l)\\n            nxt = cur * 2\\n            if l == n or nxt > mx:\\n                continue\\n            while nxt <= mx:\\n                q.append([nxt, l+1])\\n                nxt += cur\\n                \\n        return res % (10**9 + 7)\\n\\t\\t\\n```\\n\\n\\nDP solution (746ms beats 100%):\\nthe BFS solution above gets TLE. notice same states are recomputed (e.g. state [12,3] are recomputed since it represents multiple sequences [1,2,12], [1,4,12], [2,6,12]...). thus modifying it to a DFS solution with memorization (DP) to avoid recomputations.\\n\\n```\\nclass Solution:\\n    def idealArrays(self, n: int, mx: int) -> int:\\n        \\n        @lru_cache(None)\\n        def gen(k):            \\n            return math.comb(n-1, k-1)\\n\\n        @lru_cache(None)\\n        def dp(cur, l):\\n            res = gen(l)\\n            nxt = cur * 2\\n            if l == n or nxt > mx:\\n                return res\\n            while nxt <= mx:\\n                res += dp(nxt, l+1)\\n                nxt += cur\\n            return res\\n                \\n        return sum([dp(i, 1) for i in range(1, mx+1)]) % (10**9 + 7)\\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def idealArrays(self, n: int, mx: int) -> int:\\n        \\n        @lru_cache(None)\\n        def gen(k):            \\n            return math.comb(n-1, k-1)\\n        \\n        q = deque([[i, 1] for i in range(1, mx+1)])\\n        res = 0\\n        \\n        while q:\\n            cur, l = q.popleft()\\n            res += gen(l)\\n            nxt = cur * 2\\n            if l == n or nxt > mx:\\n                continue\\n            while nxt <= mx:\\n                q.append([nxt, l+1])\\n                nxt += cur\\n                \\n        return res % (10**9 + 7)\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def idealArrays(self, n: int, mx: int) -> int:\\n        \\n        @lru_cache(None)\\n        def gen(k):            \\n            return math.comb(n-1, k-1)\\n\\n        @lru_cache(None)\\n        def dp(cur, l):\\n            res = gen(l)\\n            nxt = cur * 2\\n            if l == n or nxt > mx:\\n                return res\\n            while nxt <= mx:\\n                res += dp(nxt, l+1)\\n                nxt += cur\\n            return res\\n                \\n        return sum([dp(i, 1) for i in range(1, mx+1)]) % (10**9 + 7)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261351,
                "title": "python3-freq-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/f00c06cefbc1b2305f127a8cde7ff9b010197930) for solutions of weekly 301. \\n\\n**Intuition**\\nIt is not hard to figure out that this is a DP problem. What\\'s challenging is that due to the very tight time constraint, one has to come up with a linear-ish algorithm to solve this problem. So we have to play some math instead of running the naive DP. \\n\\nThe most important observation is that the number of ideal arrays of k distinct numbers are the same regardless of what the k numbers are. They are all (n-1, k-1) i.e. n-1 choose k-1. Here, you simply need to place the k-1 places where the numbers change among the n-1 candidates. \\n\\nWith this obsevation, the below DP setup can work in O(Nlog^2M) time. The states are \\n1) number of changes `k` (or equivalently `k+1` unique values)\\n2) the ending value which is used to generate ideal arrays with more unique values. \\n\\nSince there are multiple ways to end up at the same values e.g. `(1,2,6)`, `(1,3,6)`, I also need to maintain a counter to reflect this fact. \\n\\nI start with `{1:1, 2:1, ..., maxValue:1}` which indicates that `(1,1,..1)`, `(2,2,...,2)`, ... `(maxValue, maxValue, ..., maxValue)` each contributes 1 to the final answer. Then I enumerate the number of changes `k` as 1, 2, ..., n-1. At each `k`, I compute `freq[x]` which is the number of ways to arrive at `x` (with `k` changes). For example, with 2 changes, you can get 6 as `(1,2,6)` and `(1,3,6)`. Then, `comb(n-1, k) * freq[x]` is the contribution from the ideal arrays with `k` changes ending at `x`. \\n\\n```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        ans = maxValue\\n        freq = {x : 1 for x in range(1, maxValue+1)}\\n        for k in range(1, n): \\n            temp = Counter()\\n            for x in freq: \\n                for m in range(2, maxValue//x+1): \\n                    ans += comb(n-1, k)*freq[x]\\n                    temp[m*x] += freq[x]\\n            freq = temp\\n            ans %= 1_000_000_007\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        ans = maxValue\\n        freq = {x : 1 for x in range(1, maxValue+1)}\\n        for k in range(1, n): \\n            temp = Counter()\\n            for x in freq: \\n                for m in range(2, maxValue//x+1): \\n                    ans += comb(n-1, k)*freq[x]\\n                    temp[m*x] += freq[x]\\n            freq = temp\\n            ans %= 1_000_000_007\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265366,
                "title": "sieve-of-eratosthenes-o-maxvalue",
                "content": "I was proud of my optimized tabulation solution. It works for `n` up to `7000`, but gives TLE for higher `n`. So close, but I could not optimize it any further.\\n \\nOnly then I realized that it needs a combinatorial solution instead.\\n \\n#### Sieve of Eratosthenes - Stars and Bars (3 ms)\\nHow many unique numbers can we have in an ideal array? Not many. If max value is limited to 10,000, then we will have no more than 14 unique numbers.  \\n \\nNow, how many unique ideal arrays can we produce with those unique numbers and `n` slots? Note that, in an ideal array, those numbers must appear in the non-decreasing order.\\nThis is the \"Stars and Bars\" problem, and the number of different ways to generate ideal arrays is `nCr[stars - 1][bars]`, where `starts == n`, and `bars` is the number of unique numbers.\\n\\n![image](https://assets.leetcode.com/users/images/0f646e64-7a48-42aa-baaa-e1ea0cb2afcf_1658009605.5916152.png)\\n\\nIn essence, for any number, we only need to figure **lenghes** (bars) of each unique numbers combination, and count those lenghes.\\n \\n**C++**\\nThe first part is really a one-time computation (note that we preserve result in the global variables): \\n\\t- compute `comb` (nCr) using the Pascal triangle technique. \\n\\t- use the \"Sieve of Eratosthenes\" approach to accumulate the count of each unique numbers arrangement.\\n\\t\\t- if a number `i` is divisible by `div`, it \"inherits\" all bars of `div`, adding `1` to each bar.\\n \\nAfter one-time computation, we can get the result in O(maxValue).\\n\\n![image](https://assets.leetcode.com/users/images/9540f59c-d8a5-425a-b6a6-650dc5b7258e_1658008772.938303.png)\\n\\n```cpp\\nint comb[10001][14] = { 1 }, cnt[10001][14] = {}, mod = 1000000007;\\nclass Solution {\\npublic: \\nint idealArrays(int n, int maxValue) {\\n    if (comb[1][1] == 0) { // one-time computation.\\n        for (int s = 1; s <= 10000; ++s) // nCr (comb)\\n            for (int r = 0; r < 14; ++r)\\n                comb[s][r] = r == 0 ? 1 : (comb[s - 1][r - 1] + comb[s - 1][r]) % mod;\\n        for (int div = 1; div <= 10000; ++div) { // Sieve of Eratosthenes\\n            ++cnt[div][0];\\n            for (int i = 2 * div; i <= 10000; i += div)\\n                for (int bars = 0; cnt[div][bars]; ++bars)\\n                    cnt[i][bars + 1] += cnt[div][bars];\\n        }\\n    }\\n    int res = 0;\\n    for (int i = 1; i <= maxValue; ++i)\\n        for (int bars = 0; bars < min(14, n) && cnt[i][bars]; ++bars)\\n            res = (1LL * cnt[i][bars] * comb[n - 1][bars] + res) % mod;\\n    return res;\\n}\\n};\\n```\\n\\n#### Sieve of Eratosthenes - Tabulation (TLE)\\nWe use 1D tabulation array, and for each iteration we fill it from smaller value to larger.\\n\\nWe go from smallest to largest, and a value `j` we add number of arrays from previous iteration from `j * 2`, `j * 3`, `j * 4`, and so on (\"Sieve of Eratosthenes\").\\n\\nWe only go to `maxValue / 2`, because the number of arrays is `1` for all values above.\\n\\n**C++**\\n```cpp\\nint dp[10000] = {}, mod = 1000000007;\\nclass Solution {\\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        fill(begin(dp), begin(dp) + maxValue, 1);\\n        for (int i = 1; i < n; ++i)\\n            for (int j = 1; j <= maxValue / 2; ++j) {\\n                for (int k = 2 * j; k <= maxValue / 2; k += j)\\n                    dp[j - 1] = (dp[j - 1] + dp[k - 1]) % mod;\\n                dp[j - 1] = (dp[j - 1] + maxValue / j - maxValue / 2 / j) % mod;\\n            }\\n        return accumulate(begin(dp), begin(dp) + maxValue, 0, [&](int s, int n){ return (s + n) % mod; });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint comb[10001][14] = { 1 }, cnt[10001][14] = {}, mod = 1000000007;\\nclass Solution {\\npublic: \\nint idealArrays(int n, int maxValue) {\\n    if (comb[1][1] == 0) { // one-time computation.\\n        for (int s = 1; s <= 10000; ++s) // nCr (comb)\\n            for (int r = 0; r < 14; ++r)\\n                comb[s][r] = r == 0 ? 1 : (comb[s - 1][r - 1] + comb[s - 1][r]) % mod;\\n        for (int div = 1; div <= 10000; ++div) { // Sieve of Eratosthenes\\n            ++cnt[div][0];\\n            for (int i = 2 * div; i <= 10000; i += div)\\n                for (int bars = 0; cnt[div][bars]; ++bars)\\n                    cnt[i][bars + 1] += cnt[div][bars];\\n        }\\n    }\\n    int res = 0;\\n    for (int i = 1; i <= maxValue; ++i)\\n        for (int bars = 0; bars < min(14, n) && cnt[i][bars]; ++bars)\\n            res = (1LL * cnt[i][bars] * comb[n - 1][bars] + res) % mod;\\n    return res;\\n}\\n};\\n```\n```cpp\\nint dp[10000] = {}, mod = 1000000007;\\nclass Solution {\\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        fill(begin(dp), begin(dp) + maxValue, 1);\\n        for (int i = 1; i < n; ++i)\\n            for (int j = 1; j <= maxValue / 2; ++j) {\\n                for (int k = 2 * j; k <= maxValue / 2; k += j)\\n                    dp[j - 1] = (dp[j - 1] + dp[k - 1]) % mod;\\n                dp[j - 1] = (dp[j - 1] + maxValue / j - maxValue / 2 / j) % mod;\\n            }\\n        return accumulate(begin(dp), begin(dp) + maxValue, 0, [&](int s, int n){ return (s + n) % mod; });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261491,
                "title": "c-accepted-dp-o-15-n-space-complete-explanation",
                "content": "Just find number of sequences having all numbers unique such that a[i] is divisible by a[i-1].\\nThis count is conntained in tot array. Multiplying this count with the number of ways to expand this array into a N sized array. This ways is stored in dp[i][j] where i refers to number of unique elements and j refers to size of the array.\\n\\nAlso the maximum length of sequence having a[i] divisible by a[i-1] is just 14(1, 2, 4, 8,...., 2^13).\\n\\nFor calculating dp[i][j]:-\\nNumber of ways to fill `j` sized array with `i` unique elements is sum of number of ways to fill `1 to j-1` sized array with `i-1` unique elements as we can add the remainig space with current element.\\n\\nSo dp[i][j]=dp[i-1][1]+dp[i-1][2]+dp[i-1][3].....+dp[i-1][j-1]\\nAnd to prevent TLE we are taking the prefix sum of dp values in `pr` array.\\n\\n```\\nclass Solution {\\npublic:\\n    long long dp[15][10001],pr[15][10001],tot[15],mod=1e9+7,mx,n;\\n    void get(int la,int cn){\\n        tot[cn]++;\\n        for(int p=2*la;p<=mx;p+=la)get(p,cn+1);\\n    }\\n    int idealArrays(int nn, int mmx) {\\n        n=nn;mx=mmx;\\n        for(int i=1;i<=10000;i++)\\n            dp[1][i]=1,pr[1][i]=i;\\n        \\n        for(int i=2;i<15;i++){\\n            for(int j=i;j<=10000;j++){\\n                dp[i][j]=pr[i-1][j-1];\\n                pr[i][j]=dp[i][j]+pr[i][j-1];\\n                dp[i][j]%=mod,pr[i][j]%=mod;\\n            }\\n        }\\n        long long ans=mx,x;\\n        for(int i=1;i<=mx;i++)\\n            get(i,1);\\n            \\n        for(int i=2;i<15;i++){\\n            x=tot[i]*dp[i][n];\\n            x%=mod;\\n            ans+=x;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[15][10001],pr[15][10001],tot[15],mod=1e9+7,mx,n;\\n    void get(int la,int cn){\\n        tot[cn]++;\\n        for(int p=2*la;p<=mx;p+=la)get(p,cn+1);\\n    }\\n    int idealArrays(int nn, int mmx) {\\n        n=nn;mx=mmx;\\n        for(int i=1;i<=10000;i++)\\n            dp[1][i]=1,pr[1][i]=i;\\n        \\n        for(int i=2;i<15;i++){\\n            for(int j=i;j<=10000;j++){\\n                dp[i][j]=pr[i-1][j-1];\\n                pr[i][j]=dp[i][j]+pr[i][j-1];\\n                dp[i][j]%=mod,pr[i][j]%=mod;\\n            }\\n        }\\n        long long ans=mx,x;\\n        for(int i=1;i<=mx;i++)\\n            get(i,1);\\n            \\n        for(int i=2;i<15;i++){\\n            x=tot[i]*dp[i][n];\\n            x%=mod;\\n            ans+=x;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261917,
                "title": "java-stars-and-bars-o-n-sqrt-n-similar-questions",
                "content": "2D DP solution is straight-forward, it will however get you TLE or MLE due to the constraint. We have to come up with something better.\\n\\nCredit to [@grawlixes (link to their post)](https://leetcode.com/problems/count-the-number-of-ideal-arrays/discuss/2261280/Python-Arranging-primes-intro-to-combinatorics). For each element ending in `val`, we can place its primes into `n` slots where each slot can have multiple primes, then it corresponds to a valid sequence. \\n\\n> This is also known as \"Stars and Bars ([wiki link here](https://en.wikipedia.org/wiki/Stars_and_bars_%28combinatorics%29))\" \\n\\n\\nHere is a brief explanation of Stars and Bars for anyone who doesn\\'t want to click on the links above:\\n> The gist of idea is that we have k primes to put into n slots, so we can place n-1 \"bars\" between the primes (stars), resulting in n groups (slots). This means that there are k+n-1 total slots to place the n - 1 bars = (k+n-1)C(n-1) = (k+n-1)Ck\\n\\nThe challenge for Java is how to compute combination. \\n#### Enter Mod Inverse.\\nA brief introduction on why mod inverse is needed here: \\nwhen it comes to computing numbers like `100!/25! MOD (1e9+7)`, if we compute `100! MOD 1e9+7` first, and got a result less than `25!`, the whole expression evaluates to 0, which is obviously not correct. In order to correct this, we have to use mod inverse. `100!/25! = 100! * (1/25!) = 100! * (25!)^-1`. If we can find a number `x` such that `x*25! = 1 MOD (1e9+7)`, then we will be able to compute `100!/25! MOD 1e9+7 = 100! * x MOD 1e9+7`.\\n\\nPlease refer to CP algorithm Mod inverse page for more info (Just google it or check the link in the comment below).\\n\\nHere I provide a Java implentation for the idea above:\\n95ms at 100% Speed.\\n\\n#### Time Complexity: O(n*sqrt(n))\\n#### Space Complexity: O(n)\\n\\n\\n```Java\\n\\nclass Solution {\\n    int M =(int)1e9+7;\\n    public int idealArrays(int n, int maxValue) {\\n        long ans = 0;\\n        int N = n+maxValue;\\n        long[] inv = new long[N];\\n        long[] fact = new long[N];\\n        long[] factinv = new long[N];\\n        inv[1]=fact[0]=fact[1]=factinv[0]=factinv[1]=1;\\n        for (int i = 2; i < N; i++){ // mod inverse\\n            inv[i]=M-M/i*inv[M%i]%M;\\n            fact[i]=fact[i-1]*i%M;\\n            factinv[i]=factinv[i-1]*inv[i]%M;\\n        }\\n        for (int i = 1; i <= maxValue; i++){\\n            int tmp = i;\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for (int j = 2; j*j<= tmp; j++){\\n                while(tmp%j==0){  // prime factorization.\\n                    tmp/=j;\\n                    map.merge(j, 1, Integer::sum);\\n                }\\n            }\\n            if (tmp>1){\\n                map.merge(tmp, 1, Integer::sum);\\n            }\\n            long gain=1;\\n            for (int val : map.values()){ // arranges all the primes.\\n                gain *= comb(n+val-1, val, fact, factinv);\\n                gain %= M;\\n            }\\n            ans += gain;\\n            ans %= M;\\n        }\\n\\n        return (int)ans;\\n    }\\n\\n    private long comb(int a, int b, long[] fact, long[] factinv){\\n        return fact[a]*factinv[b]%M*factinv[a-b]%M;\\n    }\\n}\\n```\\n#### Similar Questions that use Stars and Bars:\\n\\n[1621. Number of Sets of K Non-Overlapping Line Segments](https://leetcode.com/problems/number-of-sets-of-k-non-overlapping-line-segments/discuss/898830/Python-O(N)-Solution-with-Prove) (direct application)\\n[1735. Count Ways to Make Array With Product](https://leetcode.com/problems/count-ways-to-make-array-with-product/) (I came across this question 1 day after contest. They are literally identical with 1-2 lines difference)",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```Java\\n\\nclass Solution {\\n    int M =(int)1e9+7;\\n    public int idealArrays(int n, int maxValue) {\\n        long ans = 0;\\n        int N = n+maxValue;\\n        long[] inv = new long[N];\\n        long[] fact = new long[N];\\n        long[] factinv = new long[N];\\n        inv[1]=fact[0]=fact[1]=factinv[0]=factinv[1]=1;\\n        for (int i = 2; i < N; i++){ // mod inverse\\n            inv[i]=M-M/i*inv[M%i]%M;\\n            fact[i]=fact[i-1]*i%M;\\n            factinv[i]=factinv[i-1]*inv[i]%M;\\n        }\\n        for (int i = 1; i <= maxValue; i++){\\n            int tmp = i;\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for (int j = 2; j*j<= tmp; j++){\\n                while(tmp%j==0){  // prime factorization.\\n                    tmp/=j;\\n                    map.merge(j, 1, Integer::sum);\\n                }\\n            }\\n            if (tmp>1){\\n                map.merge(tmp, 1, Integer::sum);\\n            }\\n            long gain=1;\\n            for (int val : map.values()){ // arranges all the primes.\\n                gain *= comb(n+val-1, val, fact, factinv);\\n                gain %= M;\\n            }\\n            ans += gain;\\n            ans %= M;\\n        }\\n\\n        return (int)ans;\\n    }\\n\\n    private long comb(int a, int b, long[] fact, long[] factinv){\\n        return fact[a]*factinv[b]%M*factinv[a-b]%M;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283400,
                "title": "go-12ms-dp-combinatorics-with-explanation",
                "content": "Approach:\\n\\nThe first fact that we need to note is that any ideal arrays are non-decreasing, since if `a > b` then `b` cannot be a multiple of `a`. This means that we want to find increasing sequences of numbers such that each number is a multiple of the previous one, and then we will repeat some numbers in order to fill in the rest of the array. For example, the ideal array `[1, 1, 3, 3, 3, 6]` would correspond to the increasing sequence `{1, 3, 6}` of length 3.\\n\\nThere are two steps here as a result: Firstly, we want to find the number of strictly increasing ideal sequences such that all values are between `1` and `maxValue`, and secondly, we want to find how many ideal arrays of length `n` correspond to each strictly increasing sequence.\\n\\nLet\\'s actually look at the second part first. Say we have an ideal array of length `n` with some number of distinct values -- for example, `3` distinct values in our `{1, 3, 6}` example. How many different arrays can we make here? There will be a group of 1s, followed by a group of 3s, followed by a group of 6s, each of which has size at least 1. This means that there are two \"gaps\" in the array between two values where we jump up to the next value -- from 1 to 3, and 3 to 6. These jumps can\\'t occur at the same place, because otherwise we will go from 1 to 6 directly. So if we have `r` jumps, then the binomial coefficient `(n - 1) choose r` gives the number of array configurations, since there are `n - 1` gaps between values in the array to choose from, and we need `r` of them to have jumps. Note that the number of jumps `r` is equal to the number of distinct values in the array minus 1.\\n\\nSo, we now know how to find the number of length-`n` arrays corresponding to a strictly increasing ideal sequence. How can we find the number of increasing ideal sequences for a given length? Note that an increasing sequence of length `l` is an increasing sequence of length `l - 1` with another value appended onto the end, which suggests a DP approach. In particular, we will solve the problem \"How many such sequences of length `l` exist that end with value `k`?\" for `1 <= k <= maxValue`.\\n\\nWe can do this having the answers for this problem for length `l - 1`. If I want to find it for length `l` and ending value `k`, then I sum the values for length `l - 1` which end in proper divisors of `k`. This is equivalent to iterating through each value for the length `l - 1` array. For each such element, which corresponds to an `l - 1`th value of `v` in the sequence, we add the value to length `l` for `2 * v, 3 * v, ...`.\\n\\nHow many times do we do this? Either until there are 0 sequences in total, in which case there is nothing to add anymore, or until the length of each sequence is `n` (and there are `n - 1` jumps), because we can\\'t handle any more distinct values in an array of length `n`. For each length, we count the total number of sequences, find the number of distinct array configurations for that length, and multiply them. This is because each array configuration and strictly-increasing ideal sequence generates a unique ideal array.\\n\\nSumming these values up mod `10^9 + 7` gives the final answer.\\n\\nOptimizations:\\n\\nTo make finding `n! / r!(n - r)!` faster (binomial coefficient), we pre-compute the factorials from `0!` to `10000!` and their inverses mod `10^9 + 7`. Pre-computing the factorials can be done easily using a loop. To pre-compute inverses, we find the inverse of `10000!`. Then given the inverse of `n!`, we can find the inverse of `(n - 1)!`. How? We know `(n!)^-1 * n = ((n - 1)!)^-1 * n^-1 * n = ((n - 1)!)^-1 * 1 = ((n - 1)!)^-1` like we want. So, the only thing left is to find the inverse of `10000!`.\\n\\nTo do that, we use Fermat\\'s Little Theorem, which states that for any prime `p` and any integer `k`, `k^(p - 1) = 1 mod p`. Then `k^(p - 2) * k = 1 mod p`, so `k^(p - 2) = k^-1 mod p`. Since `10^9 + 7` is prime, we can use exponentiation mod `10^9 + 7` to find the inverse of `10000!`. This allows the precomputing to be done efficiently.\\n\\nCode:\\n```\\nfunc idealArrays(n int, maxValue int) int {\\n    mod := int64(1000000007)\\n    \\n\\t// binary exponentiation for FLT\\n    var exp func(int64, int64) int64\\n    exp = func(b int64, p int64) int64 {\\n        if(p == 0) {\\n            return 1\\n        }\\n        if(p == 1) {\\n            return b\\n        }\\n        half := exp(b, p / 2)\\n        half *= half\\n        half %= mod\\n        if(p % 2 == 1) {\\n            half *= b\\n            half %= mod\\n        }\\n        return half\\n    }\\n    \\n\\t// precompute factorials up to 10000!\\n    fact := make([]int64, 10001)\\n    fact[0] = 1\\n    for i := 1; i < 10001; i++ {\\n        fact[i] = (fact[i - 1] * int64(i)) % mod\\n    }\\n\\t// precompute modular inverses of factorials mod 10^9 + 7\\n    inv := make([]int64, 10001)\\n    inv[10000] = exp(fact[10000], mod - 2)\\n    for i := 9999; i >= 0; i-- {\\n        inv[i] = (inv[i + 1] * int64(i + 1)) % mod\\n    }\\n    \\n    res := int64(0)\\n    \\n    dp := make([]int64, maxValue + 1)\\n\\t// initialize to all 0 except for 1, so that 2 to maxValue initialize to 1 in first round of dp\\n    dp[1] = 1\\n    sum := int64(1)\\n    for jumps := 0; jumps < n && sum != 0; jumps++ {\\n        sum = int64(0)\\n\\t\\t// generate number of sequences with the given number of jumps for each ending value \\n        dp2 := make([]int64, maxValue + 1)\\n        for i := 1; i <= maxValue / 2 + 1; i++ {\\n\\t\\t\\t// if we don\\'t end up adding anything, skip\\n            if(dp[i] == 0) {\\n                continue\\n            }\\n            for j := 2 * i; j <= maxValue; j += i {\\n                dp2[j] += dp[i]\\n                sum += dp[i]\\n            }\\n        }\\n\\t\\t// for the first iteration, we need to make sure that dp2[1] = 1\\n        if (jumps == 0) {\\n            sum++\\n            dp2[1] = 1\\n        }\\n\\t\\t// binomial coefficient using precomputed values\\n        res += ((sum * fact[n - 1]) % mod) * ((inv[n - 1 - jumps] * inv[jumps]) % mod) % mod\\n        res %= mod\\n\\t\\t// update dp array to be used for next length of sequences\\n        dp = dp2\\n    }\\n    res %= mod\\n    return int(res)\\n}\\n```\\n\\nIf this solution helped you, please upvote!",
                "solutionTags": [
                    "Go",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nfunc idealArrays(n int, maxValue int) int {\\n    mod := int64(1000000007)\\n    \\n\\t// binary exponentiation for FLT\\n    var exp func(int64, int64) int64\\n    exp = func(b int64, p int64) int64 {\\n        if(p == 0) {\\n            return 1\\n        }\\n        if(p == 1) {\\n            return b\\n        }\\n        half := exp(b, p / 2)\\n        half *= half\\n        half %= mod\\n        if(p % 2 == 1) {\\n            half *= b\\n            half %= mod\\n        }\\n        return half\\n    }\\n    \\n\\t// precompute factorials up to 10000!\\n    fact := make([]int64, 10001)\\n    fact[0] = 1\\n    for i := 1; i < 10001; i++ {\\n        fact[i] = (fact[i - 1] * int64(i)) % mod\\n    }\\n\\t// precompute modular inverses of factorials mod 10^9 + 7\\n    inv := make([]int64, 10001)\\n    inv[10000] = exp(fact[10000], mod - 2)\\n    for i := 9999; i >= 0; i-- {\\n        inv[i] = (inv[i + 1] * int64(i + 1)) % mod\\n    }\\n    \\n    res := int64(0)\\n    \\n    dp := make([]int64, maxValue + 1)\\n\\t// initialize to all 0 except for 1, so that 2 to maxValue initialize to 1 in first round of dp\\n    dp[1] = 1\\n    sum := int64(1)\\n    for jumps := 0; jumps < n && sum != 0; jumps++ {\\n        sum = int64(0)\\n\\t\\t// generate number of sequences with the given number of jumps for each ending value \\n        dp2 := make([]int64, maxValue + 1)\\n        for i := 1; i <= maxValue / 2 + 1; i++ {\\n\\t\\t\\t// if we don\\'t end up adding anything, skip\\n            if(dp[i] == 0) {\\n                continue\\n            }\\n            for j := 2 * i; j <= maxValue; j += i {\\n                dp2[j] += dp[i]\\n                sum += dp[i]\\n            }\\n        }\\n\\t\\t// for the first iteration, we need to make sure that dp2[1] = 1\\n        if (jumps == 0) {\\n            sum++\\n            dp2[1] = 1\\n        }\\n\\t\\t// binomial coefficient using precomputed values\\n        res += ((sum * fact[n - 1]) % mod) * ((inv[n - 1 - jumps] * inv[jumps]) % mod) % mod\\n        res %= mod\\n\\t\\t// update dp array to be used for next length of sequences\\n        dp = dp2\\n    }\\n    res %= mod\\n    return int(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2263352,
                "title": "c-o-20-n-sqrt-n",
                "content": "```\\nclass Solution {\\npublic:\\n    const static int M=1e9+7, MAXN=1e4+4, p=1e9+7, N=20;\\n    long long invfact[MAXN+1];\\n    long long invnum[MAXN+1];\\n    long long fact[MAXN+1];\\n    void InverseofNumber(int p){\\n        invnum[0]=invnum[1]=1;\\n        for (int i=2;i<=MAXN;i++){\\n            invnum[i]=invnum[p%i]*(p-p/i)%p;\\n        }\\n    }\\n    // precompute inverse of factorials\\n    void InverseofFactorial(int p){\\n        invfact[0]=invfact[1]=1;\\n        // precompute inverse of natural numbers\\n        for (int i = 2; i <= MAXN; i++)\\n            invfact[i]=(invnum[i]*invfact[i-1])%p;\\n    }\\n    // calculate factorial of 1 to MAXN\\n    void factorial(int p){\\n        fact[0]=1;\\n        for (int i=1;i<=MAXN;i++) {\\n            fact[i]=(fact[i-1]*i)% p;\\n        }\\n    }\\n    long long C(long long n,long long r){\\n        if(n < r || r < 0){\\n            return 0;\\n        }\\n        int res=fact[n];\\n        res=(M+res*invfact[r])%M;\\n        res=(M+res*invfact[n-r])%M;\\n        return res;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        // there is a observation that the number of distinct numbers in an ideal sequence can not be greater than log(maxValue)\\n        // 1, 2, 4, 8, ..., this sequence can have the maximum length and it is not more than log(maxValue)+1\\n        // Hence we can precomute the number of different ideal sequences having k distinct elements\\n        InverseofNumber(p);\\n        InverseofFactorial(p);\\n        factorial(p);\\n        long long dp[maxValue+1][N];\\n        // dp(i,j) represents the number of ideal sequences with i as the last value and having j distinct elements \\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=maxValue;i++){\\n            // the number of sequences with length 1 with last value being i is exactly 1\\n            dp[i][1]=1;\\n        }\\n        // factorization\\n        auto factorize = [&](int x){\\n            // take all factors except the number itself\\n            vector<int> res;\\n            if(x > 1){\\n                res.push_back(1);\\n            }\\n            for(int i=2;i*i<=x;i++){\\n                if(x%i == 0){\\n                    res.push_back(i);\\n                    if(i != x/i){\\n                        res.push_back(x/i);\\n                    }\\n                }\\n            }\\n            return res;\\n        };\\n        for(int i=1;i<=maxValue;i++){\\n            vector<int> fact=factorize(i);\\n            for(int j=2;j<N;j++){\\n                for(int x: fact){\\n                    // the last element i must have been preceeded by the one of it\\'s factors\\n                    // so the transition is number of sequences with length j and last element i is the sum\\n                    // of all sequences with length j-1 and last element as factor of i \\n                    dp[i][j]+=dp[x][j-1];\\n                    dp[i][j]%=M;\\n                }\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=1;i<=maxValue;i++){\\n            long long tmp=0;\\n            // how many distinct k length sequences are possible with last element as i\\n            for(int k=1;k<=min(n,(int)(N-1));k++){\\n                // Now the number of such sequences is equal to the number of solutions of the equation below\\n                // x1+x2+...+xk = n\\n                // where each of x1, x2,..., xk >= 1\\n                // hence, subtract 1 from each of the variable and the resulting equation is\\n                // x1\\'+x2\\'+...+xk\\' = n-k\\n                // the number of ideal sequences with last element as i and having k distinct elements is thus the number\\n                // of solution of the above equation (C(n-k+k-1,k-1)) multiplied by dp[i][k]\\n                long long add=C(n-1,k-1);\\n                tmp+=add*dp[i][k];\\n                tmp%=M;\\n            }\\n            ans+=tmp;\\n            ans%=M;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const static int M=1e9+7, MAXN=1e4+4, p=1e9+7, N=20;\\n    long long invfact[MAXN+1];\\n    long long invnum[MAXN+1];\\n    long long fact[MAXN+1];\\n    void InverseofNumber(int p){\\n        invnum[0]=invnum[1]=1;\\n        for (int i=2;i<=MAXN;i++){\\n            invnum[i]=invnum[p%i]*(p-p/i)%p;\\n        }\\n    }\\n    // precompute inverse of factorials\\n    void InverseofFactorial(int p){\\n        invfact[0]=invfact[1]=1;\\n        // precompute inverse of natural numbers\\n        for (int i = 2; i <= MAXN; i++)\\n            invfact[i]=(invnum[i]*invfact[i-1])%p;\\n    }\\n    // calculate factorial of 1 to MAXN\\n    void factorial(int p){\\n        fact[0]=1;\\n        for (int i=1;i<=MAXN;i++) {\\n            fact[i]=(fact[i-1]*i)% p;\\n        }\\n    }\\n    long long C(long long n,long long r){\\n        if(n < r || r < 0){\\n            return 0;\\n        }\\n        int res=fact[n];\\n        res=(M+res*invfact[r])%M;\\n        res=(M+res*invfact[n-r])%M;\\n        return res;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        // there is a observation that the number of distinct numbers in an ideal sequence can not be greater than log(maxValue)\\n        // 1, 2, 4, 8, ..., this sequence can have the maximum length and it is not more than log(maxValue)+1\\n        // Hence we can precomute the number of different ideal sequences having k distinct elements\\n        InverseofNumber(p);\\n        InverseofFactorial(p);\\n        factorial(p);\\n        long long dp[maxValue+1][N];\\n        // dp(i,j) represents the number of ideal sequences with i as the last value and having j distinct elements \\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=maxValue;i++){\\n            // the number of sequences with length 1 with last value being i is exactly 1\\n            dp[i][1]=1;\\n        }\\n        // factorization\\n        auto factorize = [&](int x){\\n            // take all factors except the number itself\\n            vector<int> res;\\n            if(x > 1){\\n                res.push_back(1);\\n            }\\n            for(int i=2;i*i<=x;i++){\\n                if(x%i == 0){\\n                    res.push_back(i);\\n                    if(i != x/i){\\n                        res.push_back(x/i);\\n                    }\\n                }\\n            }\\n            return res;\\n        };\\n        for(int i=1;i<=maxValue;i++){\\n            vector<int> fact=factorize(i);\\n            for(int j=2;j<N;j++){\\n                for(int x: fact){\\n                    // the last element i must have been preceeded by the one of it\\'s factors\\n                    // so the transition is number of sequences with length j and last element i is the sum\\n                    // of all sequences with length j-1 and last element as factor of i \\n                    dp[i][j]+=dp[x][j-1];\\n                    dp[i][j]%=M;\\n                }\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=1;i<=maxValue;i++){\\n            long long tmp=0;\\n            // how many distinct k length sequences are possible with last element as i\\n            for(int k=1;k<=min(n,(int)(N-1));k++){\\n                // Now the number of such sequences is equal to the number of solutions of the equation below\\n                // x1+x2+...+xk = n\\n                // where each of x1, x2,..., xk >= 1\\n                // hence, subtract 1 from each of the variable and the resulting equation is\\n                // x1\\'+x2\\'+...+xk\\' = n-k\\n                // the number of ideal sequences with last element as i and having k distinct elements is thus the number\\n                // of solution of the above equation (C(n-k+k-1,k-1)) multiplied by dp[i][k]\\n                long long add=C(n-1,k-1);\\n                tmp+=add*dp[i][k];\\n                tmp%=M;\\n            }\\n            ans+=tmp;\\n            ans%=M;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265023,
                "title": "java-dp-combination-learned-from-others",
                "content": "### Most Important\\nI did not complete it in the contest. The solution here is from https://www.bilibili.com/video/BV1we4y1R7ZG?spm_id_from=333.999.0.0&vd_source=1e76c6792d63c37f5b33ade7d74b6a87. He is [@yxc](https://leetcode.cn/u/acvv_cxy/) . \\n\\n\\nI want to share his idea here and also helps myself to better understand it.\\n\\n### Intuition\\nThe problem could be seperated into 2 steps:\\n1. Assume **all numbers are different in each plan**, how many of plans in total could we have? \\n\\t(eg, [1, 2, 4] is a unique plan)\\n\\t\\n2. Expand the **unique numbers plans** into required length `n` plans using [Combination](https://en.wikipedia.org/wiki/Combination).\\n\\t(eg, if n = 5 maxValue = 8, [1, 2, 4] -> [1, 1, 2, 2, 4], [1, 1, 1, 2, 4], [1, 2, 2, 2, 4] ... )\\n\\t\\nHere is a relationship for two steps with an example.\\n\\n![image](https://assets.leetcode.com/users/images/b2ed0074-b617-4fbd-a048-f984da4bb2ad_1657476647.3299763.png)\\n\\n\\n\\n### Algorithm\\n\\n#### Step1. Unique Numbers Plan\\n**Using dp to store different states (ending number, length) results.**\\n\\ndp\\\\[i]\\\\[j] : the number of unique number plans **ending number ( right ) with `i`** and **the total length is `j`**\\n\\nFor example, dp\\\\[1]\\\\[1] = 1, since there is only [1] plan.   \\n\\ndp\\\\[16]\\\\[3] is for plans like [1, 2, 16], [1,4,16] and others.\\n\\n**Implementation**\\n```\\nlong[][] dp = new long[m + 1][15] ; // 15 is due to 2^13 < 10000,   2^14 > 10000, total possible max length is 14.\\n// length = 1\\nfor(int i = 1; i <= m; i++){\\n\\tdp[i][1] = 1; \\n}\\n\\n// other length\\nfor(int j = 1; j < 14; j++){\\n\\t// for current possible ending number\\n\\tfor(int i = 1; i <= m; i++){\\n\\t\\tfor next possible ending number, must be k * i\\n\\t\\tfor(int k = 2; k * i <= m; k++){\\n\\t\\t\\tdp[k * i][j + 1] = (dp[k * i][j + 1] + dp[i][j]) % MOD;\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n#### Step2. Expand With Combinations\\n\\nIf we have `n = 5`, `maxValue = 8`,  there are 5 slots we need to fill.  For example,  the unique plan is `[1, 2]`, which belongs to state `dp[2][2]` (ending with 2, length = 2). We need to fill 5 slots with `[1, 2]`. (Remember smaller numbers always in the front according to divisible requirement.)\\n\\nIn an array with length 5, we can split the array with at most 4 possible positions. \\n\\n![image](https://assets.leetcode.com/users/images/c7701f08-3c26-40cd-9e02-c814d5887f5b_1657477299.7447517.png)\\n\\nSince we want `[1, 2]`, we only need to cut once. Left subarray will be filled with 1, while the right with 2.\\n![image](https://assets.leetcode.com/users/images/620879c0-56d8-4395-afb2-e81fe287d228_1657477455.5039759.png)\\n\\nThe total number of ways to cut is Combination <img src=\"http://latex.codecogs.com/svg.image?C_{4}^{1}\"  />.\\n\\n> For other plans `[1, .... i]` with ending `i` and length `j`, total required length `n`, we need  <img src=\"http://latex.codecogs.com/svg.image?C_{n - 1}^{j - 1}\"  />.\\n\\n**Implementation of Preprocessing Combination Values\\n**\\n```\\nlong[][] C = new long[n][15]; // [n] is underrscript, [15] is superscript\\nfor(int i = 0; i < n; i++) {\\n\\tfor(int j = 0; j < 15 && j <= i; j++){\\n\\t\\tif(j == 0) C[i][j] = 1;\\n\\t\\t// this is recursion formular for combination\\n\\t\\telse C[i][j] = (C[i  - 1][j  - 1] + C[i - 1][j]) % MOD;\\n\\t}\\n}\\n```\\nThe  recursion equation of combination is: <img src=\"http://latex.codecogs.com/svg.image?C_{n}^{m}=C_{n - 1} ^ {m - 1} + C_{n - 1}^{m}\"  /> .\\n\\n#### Step3. Sum the result\\n\\nMultiply each state count with relative combination.\\n\\n```\\nlong result = 0L;\\n\\n// iterate state\\n// ending number i\\nfor(int i = 1; i <= m; i++){\\n\\t// length of unique plan\\n\\tfor(int j = 1; j <= 14 && j <= n; j++){\\n\\t\\tres = (res + dp[i][j] * C[n - 1][j - 1] ) % MOD;\\n\\t}\\n}\\n\\nreturn (int) res;\\n```\\n\\n\\n\\n### Code\\n```\\nclass Solution {\\n    public int idealArrays(int n, int m) {\\n        // step 1 ending number, length, unique plans\\n        int MOD = (int)1e9 + 7;\\n        long[][] dp = new long[m + 1][15];\\n\\n        for(int i = 1; i <= m; i++){\\n            dp[i][1] = 1;\\n        }\\n        \\n        // based on current -> calculate next\\n        // length\\n        for(int j = 1; j < 14; j++){\\n            // current state ending\\n            for(int i = 1; i <= m; i++){\\n                // next state ending\\n                for(int k = 2; i * k <= m; k++){\\n                    dp[k * i][j + 1] = (dp[i][j] + dp[k * i][j + 1]) % MOD;\\n                }\\n            }\\n        }\\n        \\n        \\n        // step 2 combination\\n        long[][] C = new long[n][15];\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < 15 && j <= i; j++){\\n                if(j == 0) C[i][j] = 1;\\n                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\\n            }\\n        }\\n        \\n        // step 3 result \\n        long res = 0L;\\n        for(int i = 1; i <= m; i++){\\n            for(int j = 1; j <= 14 && j <= n; j++){\\n                res = (res + dp[i][j] * C[n - 1][j - 1]) % MOD;\\n            }\\n        }\\n        \\n        return (int)res;\\n        \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nlong[][] dp = new long[m + 1][15] ; // 15 is due to 2^13 < 10000,   2^14 > 10000, total possible max length is 14.\\n// length = 1\\nfor(int i = 1; i <= m; i++){\\n\\tdp[i][1] = 1; \\n}\\n\\n// other length\\nfor(int j = 1; j < 14; j++){\\n\\t// for current possible ending number\\n\\tfor(int i = 1; i <= m; i++){\\n\\t\\tfor next possible ending number, must be k * i\\n\\t\\tfor(int k = 2; k * i <= m; k++){\\n\\t\\t\\tdp[k * i][j + 1] = (dp[k * i][j + 1] + dp[i][j]) % MOD;\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nlong[][] C = new long[n][15]; // [n] is underrscript, [15] is superscript\\nfor(int i = 0; i < n; i++) {\\n\\tfor(int j = 0; j < 15 && j <= i; j++){\\n\\t\\tif(j == 0) C[i][j] = 1;\\n\\t\\t// this is recursion formular for combination\\n\\t\\telse C[i][j] = (C[i  - 1][j  - 1] + C[i - 1][j]) % MOD;\\n\\t}\\n}\\n```\n```\\nlong result = 0L;\\n\\n// iterate state\\n// ending number i\\nfor(int i = 1; i <= m; i++){\\n\\t// length of unique plan\\n\\tfor(int j = 1; j <= 14 && j <= n; j++){\\n\\t\\tres = (res + dp[i][j] * C[n - 1][j - 1] ) % MOD;\\n\\t}\\n}\\n\\nreturn (int) res;\\n```\n```\\nclass Solution {\\n    public int idealArrays(int n, int m) {\\n        // step 1 ending number, length, unique plans\\n        int MOD = (int)1e9 + 7;\\n        long[][] dp = new long[m + 1][15];\\n\\n        for(int i = 1; i <= m; i++){\\n            dp[i][1] = 1;\\n        }\\n        \\n        // based on current -> calculate next\\n        // length\\n        for(int j = 1; j < 14; j++){\\n            // current state ending\\n            for(int i = 1; i <= m; i++){\\n                // next state ending\\n                for(int k = 2; i * k <= m; k++){\\n                    dp[k * i][j + 1] = (dp[i][j] + dp[k * i][j + 1]) % MOD;\\n                }\\n            }\\n        }\\n        \\n        \\n        // step 2 combination\\n        long[][] C = new long[n][15];\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < 15 && j <= i; j++){\\n                if(j == 0) C[i][j] = 1;\\n                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\\n            }\\n        }\\n        \\n        // step 3 result \\n        long res = 0L;\\n        for(int i = 1; i <= m; i++){\\n            for(int j = 1; j <= 14 && j <= n; j++){\\n                res = (res + dp[i][j] * C[n - 1][j - 1]) % MOD;\\n            }\\n        }\\n        \\n        return (int)res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262868,
                "title": "java-21-ms-solution-beats-100",
                "content": "This is mostly a math problem. \\n\\nAssume `dp[i][j]` is the count of increasing number groups with `i` distinct numbers, and start from number `j`. For example,\\n\\n```\\nfor n = 2, maxValue = 5\\ndp[2][1]=4 -> (1,2) (1,3) (1,4) (1,5)\\ndp[2][2]=1 -> (2,4)\\n```\\n\\nWe have \\n\\n```\\ndp[i + 1][j] = dp[i][j*2] + dp[i][j*3] +... + dp[i][j*k]   where j * k <= maxValue\\n```\\n\\nWe can do a sum on `dp[i]`, i.e. `sum[i] = dp[i][0] + dp[i][1] + ...`, then `sum[i]` is the count of increasing number groups with `i` distinct numbers.\\n\\nNow we can calculated the number of ideal arrays with combinatorics:\\n\\n```\\nfor i in [1,n)\\nnumber of ideal arrays += sum[i] * comb(n - 1, i - 1)\\n```\\n\\nCode:\\n\\n```\\n    /*\\n    Runtime: 21 ms, faster than 100.00% of Java online submissions for Count the Number of Ideal Arrays.\\n    Memory Usage: 45.9 MB, less than 100.00% of Java online submissions for Count the Number of Ideal Arrays.\\n     */\\n    public int idealArrays(int n, int maxValue) {\\n        int mod = (int) (1e9 + 7);\\n\\n        int maxDistinct = (int) (Math.log(maxValue) / Math.log(2)) + 1;\\n        int[][] dp = new int[maxDistinct + 1][maxValue + 1];\\n        Arrays.fill(dp[1], 1);\\n        dp[1][0] = 0;\\n        for (int i = 2; i <= maxDistinct; i++) {\\n            for (int j = 1; j <= maxValue; j++) {\\n                for (int k = 2; j * k <= maxValue && dp[i - 1][j * k] != 0; k++) {\\n                    dp[i][j] += dp[i - 1][j * k];\\n                }\\n            }\\n        }\\n\\n        int[] sum = new int[maxDistinct + 1];\\n        for (int i = 1; i <= maxDistinct; i++) {\\n            sum[i] = Arrays.stream(dp[i]).sum();\\n        }\\n        \\n\\t\\t// https://cp-algorithms.com/algebra/module-inverse.html#mod-inv-all-num\\n        long[] invs = new long[Math.min(n, maxDistinct) + 1];\\n        invs[1] = 1;\\n        for (int i = 2; i < invs.length; i++) {\\n            invs[i] = mod - mod / i * invs[mod % i] % mod;\\n        }\\n\\n        long result = maxValue;\\n        long comb = n - 1;\\n        for (int i = 2; i <= maxDistinct && i <= n; i++) {\\n            result += (sum[i] * comb) % mod;\\n\\n            comb *= n - i;\\n            comb %= mod;\\n            comb *= invs[i];\\n            comb %= mod;\\n        }\\n\\n        return (int) (result % mod);\\n    }\\n```\\n\\nI didn\\'t get the correct solution during the context due to the overflow of combinatorics. Thanks https://leetcode.com/problems/count-the-number-of-ideal-arrays/discuss/2261917/java-stars-and-bars-onsqrtn/1480882 for the trick of modular inverse.",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor n = 2, maxValue = 5\\ndp[2][1]=4 -> (1,2) (1,3) (1,4) (1,5)\\ndp[2][2]=1 -> (2,4)\\n```\n```\\ndp[i + 1][j] = dp[i][j*2] + dp[i][j*3] +... + dp[i][j*k]   where j * k <= maxValue\\n```\n```\\nfor i in [1,n)\\nnumber of ideal arrays += sum[i] * comb(n - 1, i - 1)\\n```\n```\\n    /*\\n    Runtime: 21 ms, faster than 100.00% of Java online submissions for Count the Number of Ideal Arrays.\\n    Memory Usage: 45.9 MB, less than 100.00% of Java online submissions for Count the Number of Ideal Arrays.\\n     */\\n    public int idealArrays(int n, int maxValue) {\\n        int mod = (int) (1e9 + 7);\\n\\n        int maxDistinct = (int) (Math.log(maxValue) / Math.log(2)) + 1;\\n        int[][] dp = new int[maxDistinct + 1][maxValue + 1];\\n        Arrays.fill(dp[1], 1);\\n        dp[1][0] = 0;\\n        for (int i = 2; i <= maxDistinct; i++) {\\n            for (int j = 1; j <= maxValue; j++) {\\n                for (int k = 2; j * k <= maxValue && dp[i - 1][j * k] != 0; k++) {\\n                    dp[i][j] += dp[i - 1][j * k];\\n                }\\n            }\\n        }\\n\\n        int[] sum = new int[maxDistinct + 1];\\n        for (int i = 1; i <= maxDistinct; i++) {\\n            sum[i] = Arrays.stream(dp[i]).sum();\\n        }\\n        \\n\\t\\t// https://cp-algorithms.com/algebra/module-inverse.html#mod-inv-all-num\\n        long[] invs = new long[Math.min(n, maxDistinct) + 1];\\n        invs[1] = 1;\\n        for (int i = 2; i < invs.length; i++) {\\n            invs[i] = mod - mod / i * invs[mod % i] % mod;\\n        }\\n\\n        long result = maxValue;\\n        long comb = n - 1;\\n        for (int i = 2; i <= maxDistinct && i <= n; i++) {\\n            result += (sum[i] * comb) % mod;\\n\\n            comb *= n - i;\\n            comb %= mod;\\n            comb *= invs[i];\\n            comb %= mod;\\n        }\\n\\n        return (int) (result % mod);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261921,
                "title": "python-combination-dp-explained",
                "content": "Like others posted in the forum, the key is to use `nCr`, which is `math.comb` in Python.\\n\\nFirst, we need to compute strictly-increasing sequence within `maxValue`.  For example, given `n=5` and `maxValue=6`, and a sequence `[1,2,4]`, which represents `[1.., 2.., 4..]` of a `5` element array.  That means:\\n\\nWe increase the number by twice (`1->2`, `2->4`), and, we need to use `5` elements, which means `4` chances to increase.  That leads to a combination problem, and the answer is `C(4,2)=6`:\\n\\n`[1,1,1,2,4] [1,1,2,2,4] [1,1,2,4,4] [1,2,2,2,4] [1,2,2,4,4] [1,2,4,4,4]`\\n\\nNote that we don\\'t count `[1,1,1,1,2]` nor `[1,1,1,1,1]` here, because they will be counted when dealing with `[1,2]` and `[1]`, respectively.\\n\\nNow, the rest is to count all strictly-increasing sequences.  This can be done with a DP recursive call:\\n\\n```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        MOD = 1000000007\\n        @cache\\n        def rec(i, k):\\n\\t\\t    # i: current number; k: increase count\\n            m = comb(n-1, k) % MOD  # combination if the sequence stops here\\n            if k == n-1:  # no more chance to increase; sequence stops here\\n                return m % MOD\\n            for j in range(i+i, maxValue+1, i):\\n                m += rec(j, k+1) % MOD\\n            return m % MOD\\n        \\n        m = 0\\n        for i in range(1, maxValue+1):\\n            m += rec(i, 0) % MOD\\n        return m % MOD\\n```\\n\\nIt seems like still an `O(maxValue * n)` DP, which will be TLE, but it is actually not.  The reason is, the length of longest sequence is `min(lg(maxValue), n)` rather than simply `n`.  When `n` goes large, it is bounded by `lg(maxValue)`.  If we replace the `n` with `lg(maxValue)` in the original big-O notation, it becomes `O(maxValue lg maxValue)`, so it will not TLE.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        MOD = 1000000007\\n        @cache\\n        def rec(i, k):\\n\\t\\t    # i: current number; k: increase count\\n            m = comb(n-1, k) % MOD  # combination if the sequence stops here\\n            if k == n-1:  # no more chance to increase; sequence stops here\\n                return m % MOD\\n            for j in range(i+i, maxValue+1, i):\\n                m += rec(j, k+1) % MOD\\n            return m % MOD\\n        \\n        m = 0\\n        for i in range(1, maxValue+1):\\n            m += rec(i, 0) % MOD\\n        return m % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261741,
                "title": "c-dp-100-fast-easy-to-understand",
                "content": "**-------------------------------Please Upvote-------------------------------**\\n**Approach**\\nLet us try to find the answer for each A*n* =1,2,\\u2026,M and sum them up. The answer for fixed A*n* can be found as the product of n binomial coefficients, where n is the number of prime factors of A*n*, by focusing on where in the sequence the number of times each prime factor is multiplied increases.\\nThe total number of prime factors of i=1,2,\\u2026,M can be evaluated as O(MlogM). Thus, excluding the precomputation for binomial coefficients, we can solve the problem in O(MlogM) time.\\n\\n```\\nclass Solution {\\npublic:\\n    int n,m,dp[10005][20];\\n    int C[10005][20];\\n    int idealArrays(int n, int m) {\\n        int mod = 1e9+7;\\n        for(int i=1; i<=m; i++) {\\n\\t\\t    dp[i][1]=(dp[i][1]+1)%mod;\\n\\t\\t    for(int j=i+i; j<=m; j+=i) {\\n\\t\\t\\t    for(int k=1; k<=18; k++) {\\n\\t\\t\\t\\t    dp[j][k]=(dp[j][k]+dp[i][k-1])%mod;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\t    for(int i=0; i<=n; i++) {\\n\\t\\t    C[i][0]=1;\\n\\t\\t    for(int j=1; j<=min(i,18); j++) {\\n\\t\\t\\t    C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\\n\\t\\t    }\\n\\t    }\\n\\t    long long ans=0;\\n\\t    for(int i=1; i<=m; i++) {\\n\\t\\t    for(int j=1; j<=18; j++) {\\n\\t\\t\\t    ans=(ans+1ll*dp[i][j]*C[n-1][j-1]%mod)%mod;\\n\\t\\t    }\\n\\t    }\\n\\t    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m,dp[10005][20];\\n    int C[10005][20];\\n    int idealArrays(int n, int m) {\\n        int mod = 1e9+7;\\n        for(int i=1; i<=m; i++) {\\n\\t\\t    dp[i][1]=(dp[i][1]+1)%mod;\\n\\t\\t    for(int j=i+i; j<=m; j+=i) {\\n\\t\\t\\t    for(int k=1; k<=18; k++) {\\n\\t\\t\\t\\t    dp[j][k]=(dp[j][k]+dp[i][k-1])%mod;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\t    for(int i=0; i<=n; i++) {\\n\\t\\t    C[i][0]=1;\\n\\t\\t    for(int j=1; j<=min(i,18); j++) {\\n\\t\\t\\t    C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\\n\\t\\t    }\\n\\t    }\\n\\t    long long ans=0;\\n\\t    for(int i=1; i<=m; i++) {\\n\\t\\t    for(int j=1; j<=18; j++) {\\n\\t\\t\\t    ans=(ans+1ll*dp[i][j]*C[n-1][j-1]%mod)%mod;\\n\\t\\t    }\\n\\t    }\\n\\t    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261212,
                "title": "precomputing-short-increasing-sequences",
                "content": "First precompute all strictly increasing sequences starting with x = 1 and ending with a value less than or equal to `maxValue`. Each subsequent element of the sequence is a multiple of the previous element. For `maxValue=10000`, there are only 2602393 such sequences and the maximum length is atmost 14.  Call the set of all such sequences `S`. By construction, removing any element (except the first x=1 element) from a sequence belonging to `S` results in another sequence belonging to `S`. \\nGiven a sequence `1=s[0],...,s[m-1] <= maxValue` belonging  to S, we may convert this sequence into an ideal array by having `c_i` copies of the `i^th` element (since each element is a divisor of itself).\\nIn order to avoid duplication from other sequences, `c[0] >= 0, c[i] > 0`. In other words, we can have zero or more ones in the beginning and a non zero number of other elements. The number of ways to do this is the number of solutions to\\n`c[0]+...+c[m-1]=n` such that `c[0]>=0 and c[i]>=1 for i>0`. Substituting `x[0]=c[0]` and `x[i]=c[i]-1 for i>0`, this is simply the number of solutions to\\n`x[0]+...+x[m-1]=n-m+1` such that `x[i]>=0 for i>=0`. This is a standard problem whose solution is `Binomial(n,m-1)`.\\n\\nHence we simply precompute all sequences in `S` and for each such sequence of length `m`, we add `Binomial(n,m-1)` to the answer. Note that `m` is atmost 14 and there are less than 3 million of them.\\n\\n\\n`\\n\\n\\t#define ll long long\\n\\t#define MODD 1000000007\\n\\t#define MAXN 10000\\n    ll fact[MAXN+1];\\n    ll factinv[MAXN+1];\\n    ll modpow(ll x, ll y) {\\n        ll xs = x;\\n        ll answer = 1;\\n        while(y) {\\n            if (y&1) {\\n                answer = (answer * xs) % MODD;\\n            }\\n            y >>= 1;\\n            xs = (xs * xs) % MODD ;\\n        }\\n        return answer;\\n    }\\n    ll GetBinom(ll x, ll y) {\\n        if (x < y) return 0;\\n        return fact[x]*factinv[x-y]%MODD*factinv[y]%MODD;\\n    }\\n    ll BruteForce(vector<int>& A, int n, int maxValue) {\\n        ll ans = GetBinom(n,A.size()-1);\\n        int x = A.back();\\n        for(int y=2*x;y<=maxValue;y+=x) {\\n            A.push_back(y);\\n            ans += BruteForce(A, n, maxValue);\\n\\t\\t\\tif (ans >= MODD) ans -= MODD;\\n            A.pop_back();\\n        }\\n\\t\\treturn ans;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        vector<int> A={1};\\n        fact[0]=factinv[0]=1;\\n        for(int i=1;i<=n+1;i++) {\\n            fact[i]=(fact[i-1]*i)%MODD;\\n            factinv[i]=modpow(fact[i],MODD-2);\\n        }\\n        return BruteForce(A, n, maxValue);        \\n    }\\n\\t\\n`\\n\\n\\n",
                "solutionTags": [],
                "code": "First precompute all strictly increasing sequences starting with x = 1 and ending with a value less than or equal to `maxValue`. Each subsequent element of the sequence is a multiple of the previous element. For `maxValue=10000`, there are only 2602393 such sequences and the maximum length is atmost 14.  Call the set of all such sequences `S`. By construction, removing any element (except the first x=1 element) from a sequence belonging to `S` results in another sequence belonging to `S`. \\nGiven a sequence `1=s[0],...,s[m-1] <= maxValue` belonging  to S, we may convert this sequence into an ideal array by having `c_i` copies of the `i^th` element (since each element is a divisor of itself).\\nIn order to avoid duplication from other sequences, `c[0] >= 0, c[i] > 0`. In other words, we can have zero or more ones in the beginning and a non zero number of other elements. The number of ways to do this is the number of solutions to\\n`c[0]+...+c[m-1]=n` such that `c[0]>=0 and c[i]>=1 for i>0`. Substituting `x[0]=c[0]` and `x[i]=c[i]-1 for i>0`, this is simply the number of solutions to\\n`x[0]+...+x[m-1]=n-m+1` such that `x[i]>=0 for i>=0`. This is a standard problem whose solution is `Binomial(n,m-1)`.\\n\\nHence we simply precompute all sequences in `S` and for each such sequence of length `m`, we add `Binomial(n,m-1)` to the answer. Note that `m` is atmost 14 and there are less than 3 million of them.\\n\\n\\n`\\n\\n\\t#define ll long long\\n\\t#define MODD 1000000007\\n\\t#define MAXN 10000\\n    ll fact[MAXN+1];\\n    ll factinv[MAXN+1];\\n    ll modpow(ll x, ll y) {\\n        ll xs = x;\\n        ll answer = 1;\\n        while(y) {\\n            if (y&1) {\\n                answer = (answer * xs) % MODD;\\n            }\\n            y >>= 1;\\n            xs = (xs * xs) % MODD ;\\n        }\\n        return answer;\\n    }\\n    ll GetBinom(ll x, ll y) {\\n        if (x < y) return 0;\\n        return fact[x]*factinv[x-y]%MODD*factinv[y]%MODD;\\n    }\\n    ll BruteForce(vector<int>& A, int n, int maxValue) {\\n        ll ans = GetBinom(n,A.size()-1);\\n        int x = A.back();\\n        for(int y=2*x;y<=maxValue;y+=x) {\\n            A.push_back(y);\\n            ans += BruteForce(A, n, maxValue);\\n\\t\\t\\tif (ans >= MODD) ans -= MODD;\\n            A.pop_back();\\n        }\\n\\t\\treturn ans;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        vector<int> A={1};\\n        fact[0]=factinv[0]=1;\\n        for(int i=1;i<=n+1;i++) {\\n            fact[i]=(fact[i-1]*i)%MODD;\\n            factinv[i]=modpow(fact[i],MODD-2);\\n        }\\n        return BruteForce(A, n, maxValue);        \\n    }\\n\\t\\n`\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2261965,
                "title": "python-freq-table-solution-by-ye15-with-explanations",
                "content": "First, full credits to @ye15\\'s [amazing solution](https://leetcode.com/problems/count-the-number-of-ideal-arrays/discuss/2261351/Python3-freq-table). Here are some explanations.\\n\\nInstead of counting the possible ideal arrays by different starting (or ending) values, we count the possible ideal arrays by the number of **unique values** in the array.\\nStep 1a. Initialize `ans` as `maxValue`, representing ideal arrays with all of the same values (that is, the number of unique values in the array being 1)\\nStep 1b. Initialize the `freq` table as a `Counter` object which represents the number of distinct ideal arrays ending with value `x` with the current number of unique values (which is 1 for now)\\nStep 2. We iterate `k` which represents the current number of unique values. For each value of `k`, we define a `temp` as a `Counter` object for the next iteration of `freq`. Then, for each value `x` in the current `freq`, we consider the next possible value (i.e. `m * x`), different from `x`, such that there are `freq[x]` possible ways contributing to `nxt[m * x]`. In the meantime, `freq[x]` also contributes to the final output `ans` by a factor of `comb(n - 1, k)` (**key step**). This is because we have set the ending value to be *m * x*, so that among the first `n - 1` possible positions, there are `math.comb(n - 1, k)` possible ways to assign the `k` unique values to the `n - 1` positions. One thing to note is that since the ideal array is defined such that \"every `arr[i]` is divisible by `arr[i - 1]`, for `0 < i < n`. After we have selected `k` positions out of `n - 1` possible positions, we can always work from the right to the left by keeping the current value as the same unless we encounter another selected position. For example, if `n = 5, k = 2, m = 2` and the two unique values are `1` and `2`, then `math.comb(n - 1, k) = math.comb(4, 2) = 6`. Below are the 6 possible ideal arrays contributing to `ans`.\\n```\\n(1, 2) -> [1, 2, 4, 4, 4]\\n(1, 3) -> [1, 2, 2, 4, 4]\\n(1, 4) -> [1, 2, 2, 2, 4]\\n(2, 3) -> [1, 1, 2, 4, 4]\\n(2, 4) -> [1, 1, 2, 2, 4]\\n(3, 4) -> [1, 1, 1, 2, 4]\\n```\\nHence, we add `math.comb(n - 1, k) * freq[x]` to `ans`\\nStep 3: Update `freq` by setting it to `temp`\\nStep 4: Return `ans`\\n\\nFinally, adding an early stopping rule to the solution. If you find this explanation helpful, please feel free to upvote and also upvote the @ye15\\'s post.\\n```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        MOD = 10 ** 9 + 7\\n        ans = maxValue\\n        freq = {x: 1 for x in range(1, maxValue + 1)}\\n        for k in range(1, n):\\n            if not freq:\\n                break\\n            nxt = collections.defaultdict(int)\\n            for x in freq:\\n                for m in range(2, maxValue // x + 1):\\n                    ans += math.comb(n - 1, k) * freq[x]\\n                    nxt[m * x] += freq[x]\\n            freq = nxt\\n            ans %= MOD\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\n(1, 2) -> [1, 2, 4, 4, 4]\\n(1, 3) -> [1, 2, 2, 4, 4]\\n(1, 4) -> [1, 2, 2, 2, 4]\\n(2, 3) -> [1, 1, 2, 4, 4]\\n(2, 4) -> [1, 1, 2, 2, 4]\\n(3, 4) -> [1, 1, 1, 2, 4]\\n```\n```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        MOD = 10 ** 9 + 7\\n        ans = maxValue\\n        freq = {x: 1 for x in range(1, maxValue + 1)}\\n        for k in range(1, n):\\n            if not freq:\\n                break\\n            nxt = collections.defaultdict(int)\\n            for x in freq:\\n                for m in range(2, maxValue // x + 1):\\n                    ans += math.comb(n - 1, k) * freq[x]\\n                    nxt[m * x] += freq[x]\\n            freq = nxt\\n            ans %= MOD\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347532,
                "title": "somebody-please-tell-me-how-to-optimise-my-code-need-urgent-help",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>fact;\\n    const int mod = 1e9+7;\\n    map<pair<int,int>,int>dp;\\n    int recur(int i , int last){\\n        if(i==0)return 1;\\n        if(dp.find({i,last})!=dp.end())return dp[{i,last}];\\n        int ans=0;\\n        for(auto it : fact[last]){\\n            ans = (ans+recur(i-1,it))%mod;\\n        }\\n        return dp[{i,last}]=ans%mod;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        fact.assign(maxValue+1, {});\\n        for(int i=1;i<=maxValue; i++){\\n            int cur = i;\\n            for(int j=1;j*j<=cur;j++){\\n                if(cur%j==0){\\n                    fact[cur].push_back(j);\\n                    if(cur/j !=j)\\n                    fact[cur].push_back(cur/j);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1;i<=maxValue; i++){\\n            ans=(ans+recur(n-1,i))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>fact;\\n    const int mod = 1e9+7;\\n    map<pair<int,int>,int>dp;\\n    int recur(int i , int last){\\n        if(i==0)return 1;\\n        if(dp.find({i,last})!=dp.end())return dp[{i,last}];\\n        int ans=0;\\n        for(auto it : fact[last]){\\n            ans = (ans+recur(i-1,it))%mod;\\n        }\\n        return dp[{i,last}]=ans%mod;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        fact.assign(maxValue+1, {});\\n        for(int i=1;i<=maxValue; i++){\\n            int cur = i;\\n            for(int j=1;j*j<=cur;j++){\\n                if(cur%j==0){\\n                    fact[cur].push_back(j);\\n                    if(cur/j !=j)\\n                    fact[cur].push_back(cur/j);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1;i<=maxValue; i++){\\n            ans=(ans+recur(n-1,i))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280251,
                "title": "python3-solution-dp-clean-concise",
                "content": "`Time Complexity` : `O(mlogm)`\\n`Space Complexity` : `O(m)`\\n\\n```\\nclass Solution:\\n    def idealArrays(self, n, m):\\n        mod, ans, comb = 10**9 + 7, m, 1\\n        dp = [0] + [1] * m\\n        \\n        for i in range(1, min(n, 14)):\\n            for j in range(m, 0, -1):\\n                if dp[j] == 0: continue\\n                for k in range(j << 1, m + 1, j):\\n                    dp[k] += dp[j]\\n                dp[j] = 0\\n            comb = (comb * (n-i)) // i\\n            ans = (ans + sum(dp) * comb) % mod\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def idealArrays(self, n, m):\\n        mod, ans, comb = 10**9 + 7, m, 1\\n        dp = [0] + [1] * m\\n        \\n        for i in range(1, min(n, 14)):\\n            for j in range(m, 0, -1):\\n                if dp[j] == 0: continue\\n                for k in range(j << 1, m + 1, j):\\n                    dp[k] += dp[j]\\n                dp[j] = 0\\n            comb = (comb * (n-i)) // i\\n            ans = (ans + sum(dp) * comb) % mod\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261968,
                "title": "c-o-n-logn-2",
                "content": "let\\'s say we have a sequence of length S of strictly increasing integers and each integer is a multiple of the one before, then the total number of ways of making ideal arrays of length N that contain all of the numbers in the sequence is N - 1 choose S - 1.\\n\\nFor example, let\\'s say the sequence is {1, 4, 8} and N is 5, then the total ways of constructing an ideal array of length 5 that contain 1, 4, and 8, is (N - 1)! / (S - 1)! / (N - S)! = 4! / 2! / 2! = 6.\\nAll the 6 ideal arrays are:\\n\\t{1, 4, 8, 8, 8}\\n\\t{1, 4, 4, 8, 8}\\n\\t{1, 4, 4, 4, 8}\\n\\t{1, 1, 4, 8, 8}\\n\\t{1, 1, 4, 4, 8}\\n\\t{1, 1, 1, 4, 8}\\n\\ndp[i][j] is the number of different combinations of sequences ending with i and with length j.\\ndp[i][1] is always 1.\\ndp[i][j] is the sum of dp[k][j - 1] for all k that are a factor of i.\\n\\nThe result is the sum of (n - 1 choose n - j) * dp[i][j] for all possible sequences.\\n```\\nint facts[10001] = {};\\nint dp[10001][15];\\n\\nclass Solution {\\npublic:\\n\\tlong long mod = 1e9 + 7;\\n    long long modPow(long long a, long long b) {\\n        long long res = 1;\\n        while (b) {\\n            if (b % 2) res = (res * a) % mod;\\n            a = (a * a) % mod;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n    long long fact(long long n) {\\n        if (n == 0) return 1;\\n        if (facts[n]) return facts[n];\\n        facts[n] = (n * fact(n - 1)) % mod;\\n        return facts[n];\\n    }\\n    long long choose(long long a, long long b) {\\n        return (((fact(a) * modPow(fact(b), mod - 2)) % mod) * modPow(fact(a - b), mod - 2)) % mod;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        for (int i = 1; i <= maxValue; i++)\\n            for (int j = 1; j <= min(n, 14); j++)\\n                dp[i][j] = 0;\\n        for (int i = 1; i <= maxValue; i++) {\\n            dp[i][1] = 1;\\n            for (int j = 2; j * i <= maxValue; j++)\\n                for (int k = 1; k < min(n, 14); k++)\\n                    dp[i * j][k + 1] += dp[i][k];\\n        }\\n        long long res = 0;\\n        for (int i = 1; i <= maxValue; i++)\\n            for (int j = 1; j <= min(n, 14); j++)\\n                res = (res + choose(n - 1, n - j) * dp[i][j]) % mod;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint facts[10001] = {};\\nint dp[10001][15];\\n\\nclass Solution {\\npublic:\\n\\tlong long mod = 1e9 + 7;\\n    long long modPow(long long a, long long b) {\\n        long long res = 1;\\n        while (b) {\\n            if (b % 2) res = (res * a) % mod;\\n            a = (a * a) % mod;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n    long long fact(long long n) {\\n        if (n == 0) return 1;\\n        if (facts[n]) return facts[n];\\n        facts[n] = (n * fact(n - 1)) % mod;\\n        return facts[n];\\n    }\\n    long long choose(long long a, long long b) {\\n        return (((fact(a) * modPow(fact(b), mod - 2)) % mod) * modPow(fact(a - b), mod - 2)) % mod;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        for (int i = 1; i <= maxValue; i++)\\n            for (int j = 1; j <= min(n, 14); j++)\\n                dp[i][j] = 0;\\n        for (int i = 1; i <= maxValue; i++) {\\n            dp[i][1] = 1;\\n            for (int j = 2; j * i <= maxValue; j++)\\n                for (int k = 1; k < min(n, 14); k++)\\n                    dp[i * j][k + 1] += dp[i][k];\\n        }\\n        long long res = 0;\\n        for (int i = 1; i <= maxValue; i++)\\n            for (int j = 1; j <= min(n, 14); j++)\\n                res = (res + choose(n - 1, n - j) * dp[i][j]) % mod;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261325,
                "title": "easy-dp-with-explanation",
                "content": "we need two dp tables here: \\n1. one used to remember how many ways to fill up an arr of size j by using i numbers\\n2. another one used to count how many size j distinct sequence, i.e. {2,4}, {2,4,8}... start with number i\\n\\nonly thing left is simple multiplication\\n```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n\\n        \"\"\"\\n        opt[i][j]: # way to make arr size j of i numbers\\n        opt[i][j] = sum(opt[i-1][k] for k in range(j))\\n        \"\"\"\\n\\n        opt = [[0 for j in range(n + 1)] for i in range(20)]\\n        for j in range(1, n + 1):\\n            opt[1][j] = 1\\n\\n        for i in range(2, 20):\\n            for j in range(i, n + 1):\\n                opt[i][j] = opt[i][j - 1] + opt[i - 1][j - 1]\\n\\n        \"\"\"\\n        A[i][j]: # of size j sequence start with number i\\n        A[i][j] = sum(A[k][j-1] for all k in d[i] if k != i)\\n        \"\"\"\\n\\n        d = defaultdict(list)\\n        for i in range(1, maxValue):\\n            for j in range(2, (maxValue // i) + 1):\\n                d[i].append(j * i)\\n\\n        A = [[0 for j in range(20)] for i in range(maxValue + 1)]\\n        for i in range(1, maxValue + 1):\\n            A[i][1] = 1\\n\\n        res = maxValue\\n\\n        for i in range(1, maxValue + 1)[::-1]:\\n            for j in range(2, 20):\\n                for k in d[i]:\\n                    A[i][j] += A[k][j - 1]\\n                res += opt[j][n] * A[i][j] % (10 ** 9 + 7)\\n\\n        return res % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n\\n        \"\"\"\\n        opt[i][j]: # way to make arr size j of i numbers\\n        opt[i][j] = sum(opt[i-1][k] for k in range(j))\\n        \"\"\"\\n\\n        opt = [[0 for j in range(n + 1)] for i in range(20)]\\n        for j in range(1, n + 1):\\n            opt[1][j] = 1\\n\\n        for i in range(2, 20):\\n            for j in range(i, n + 1):\\n                opt[i][j] = opt[i][j - 1] + opt[i - 1][j - 1]\\n\\n        \"\"\"\\n        A[i][j]: # of size j sequence start with number i\\n        A[i][j] = sum(A[k][j-1] for all k in d[i] if k != i)\\n        \"\"\"\\n\\n        d = defaultdict(list)\\n        for i in range(1, maxValue):\\n            for j in range(2, (maxValue // i) + 1):\\n                d[i].append(j * i)\\n\\n        A = [[0 for j in range(20)] for i in range(maxValue + 1)]\\n        for i in range(1, maxValue + 1):\\n            A[i][1] = 1\\n\\n        res = maxValue\\n\\n        for i in range(1, maxValue + 1)[::-1]:\\n            for j in range(2, 20):\\n                for k in d[i]:\\n                    A[i][j] += A[k][j - 1]\\n                res += opt[j][n] * A[i][j] % (10 ** 9 + 7)\\n\\n        return res % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479334,
                "title": "combinatorics-dp-o-m-log-m-log-m-simple-c",
                "content": "# Approach\\nWe first count all the strictly increasing sequences that follows the property given in problem statement, so the longest such sequence has length approx. `log2(mxv)`, using previous and current dp we count all such sequences [memory optimization], `lcnt[i]` stores the count of all such sequences with length `i`, now to problem reduces to simple combinatoris, i.e. given there are `i` buckets and n ball, how many ways are there to place those `n` balls such that each bucket contains atleast `1` ball i.e. $${n-1} \\\\choose {i-1}$$, and we do this for each `i`[last for loop].\\n\\n# Code\\n```\\n#define fi first\\n#define se second\\n#define pb push_back\\n#define ppb pop_back\\n#define all(a) a.begin(),a.end()\\nusing ll = long long;\\nusing vi = vector<int>;\\nusing vl = vector<ll>;\\nusing vb = vector<bool>;\\nusing pii = pair<int,int>;\\nusing pll = pair<ll,ll>;\\nconst int MOD = 1e9 + 7;\\nconst int iinf = 1e9;\\nll mod_a(ll a,ll b){a%=MOD;b%=MOD;return((a+b)%MOD);}\\nll mod_m(ll a,ll b){a%=MOD;b%=MOD;return((a*b)%MOD);}\\nll pow_m(ll a,ll b){a%=MOD;b%=(MOD-1);ll r = 1;\\nwhile(b){if(b&1){r=mod_m(r,a);}a=mod_m(a,a);b/=2;}return r;}\\nll mod_i(ll a){return pow_m(a,MOD-2);}\\nll mod_d(ll a,ll b){return mod_m(a,mod_i(b));}\\nll mod_s(ll a,ll b){a%=MOD;b%=MOD;return((((a-b)%MOD)+MOD)%MOD);}\\nconst int mxn = 4e4 + 10;\\nint fact[mxn], ifact[mxn];\\nint flag = 0;\\n\\nvoid init(){\\n    if(flag)return;\\n    flag = 1;\\n    fact[0] = ifact[0] = 1;\\n    for(int i=1;i<mxn;i++){\\n        fact[i] = mod_m(fact[i-1], i * 1ll);\\n    }\\n    ifact[mxn-1] = mod_i(fact[mxn-1]);\\n    for(int i=mxn-2;i>=0;i--){\\n        ifact[i] = mod_m(ifact[i+1], (i+1) * 1ll);\\n    }\\n}\\n\\nll NCR(int n,int r){\\n    return mod_m(fact[n], mod_m(ifact[n-r], ifact[r]));\\n}\\n\\nclass Solution {\\npublic:\\n    int idealArrays(int n, int mxv) {\\n        init();\\n        int mxstep = log2(mxv) + 2;\\n        vi lcnt(mxstep+1, 0), p(mxv+1, 1), c(mxv+1, 0);\\n        lcnt[1] = mxv;\\n        p[0] = p[1] = 0;\\n        for(int i=2;i<=mxstep;i++){\\n            for(int j=1;j<=mxv;j++){\\n                for(int k=2*j;k<=mxv;k+=j){\\n                    c[j] = (c[j] + p[k]) % MOD;\\n                }\\n            }\\n            ll len = 0;\\n            for(int j=0;j<=mxv;j++){\\n                p[j] = c[j];\\n                len = (len + c[j]) % MOD;\\n                c[j] = 0;\\n            }\\n            lcnt[i] = len;\\n        }\\n        int ans = 0;\\n        for(int i=1;i<=min(n,mxstep);i++){\\n            ans = (ans + (lcnt[i] * 1ll * NCR(n-1, i-1)) % MOD) % MOD;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\n#define fi first\\n#define se second\\n#define pb push_back\\n#define ppb pop_back\\n#define all(a) a.begin(),a.end()\\nusing ll = long long;\\nusing vi = vector<int>;\\nusing vl = vector<ll>;\\nusing vb = vector<bool>;\\nusing pii = pair<int,int>;\\nusing pll = pair<ll,ll>;\\nconst int MOD = 1e9 + 7;\\nconst int iinf = 1e9;\\nll mod_a(ll a,ll b){a%=MOD;b%=MOD;return((a+b)%MOD);}\\nll mod_m(ll a,ll b){a%=MOD;b%=MOD;return((a*b)%MOD);}\\nll pow_m(ll a,ll b){a%=MOD;b%=(MOD-1);ll r = 1;\\nwhile(b){if(b&1){r=mod_m(r,a);}a=mod_m(a,a);b/=2;}return r;}\\nll mod_i(ll a){return pow_m(a,MOD-2);}\\nll mod_d(ll a,ll b){return mod_m(a,mod_i(b));}\\nll mod_s(ll a,ll b){a%=MOD;b%=MOD;return((((a-b)%MOD)+MOD)%MOD);}\\nconst int mxn = 4e4 + 10;\\nint fact[mxn], ifact[mxn];\\nint flag = 0;\\n\\nvoid init(){\\n    if(flag)return;\\n    flag = 1;\\n    fact[0] = ifact[0] = 1;\\n    for(int i=1;i<mxn;i++){\\n        fact[i] = mod_m(fact[i-1], i * 1ll);\\n    }\\n    ifact[mxn-1] = mod_i(fact[mxn-1]);\\n    for(int i=mxn-2;i>=0;i--){\\n        ifact[i] = mod_m(ifact[i+1], (i+1) * 1ll);\\n    }\\n}\\n\\nll NCR(int n,int r){\\n    return mod_m(fact[n], mod_m(ifact[n-r], ifact[r]));\\n}\\n\\nclass Solution {\\npublic:\\n    int idealArrays(int n, int mxv) {\\n        init();\\n        int mxstep = log2(mxv) + 2;\\n        vi lcnt(mxstep+1, 0), p(mxv+1, 1), c(mxv+1, 0);\\n        lcnt[1] = mxv;\\n        p[0] = p[1] = 0;\\n        for(int i=2;i<=mxstep;i++){\\n            for(int j=1;j<=mxv;j++){\\n                for(int k=2*j;k<=mxv;k+=j){\\n                    c[j] = (c[j] + p[k]) % MOD;\\n                }\\n            }\\n            ll len = 0;\\n            for(int j=0;j<=mxv;j++){\\n                p[j] = c[j];\\n                len = (len + c[j]) % MOD;\\n                c[j] = 0;\\n            }\\n            lcnt[i] = len;\\n        }\\n        int ans = 0;\\n        for(int i=1;i<=min(n,mxstep);i++){\\n            ans = (ans + (lcnt[i] * 1ll * NCR(n-1, i-1)) % MOD) % MOD;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469224,
                "title": "c-dp-explanation-with-memoization-solution-with-comments-combinatorics",
                "content": "**Find all ideal sequence with distinct integer and expand all to make ideal sequence according to question**\\n* Let\\'s understand with an example. If we take (1, 2) and make a ideal sequence of length 4 then our all ideal sequence would look like - [1,2,2,2] , [1,1,2,2], [1,1,1,2] and similarly if we take (2,4) of same length as previous and make all ideal sequences then our all ideal sequence would look like [2,4,4,4], [2,2,4,4], [2,2,2,4] . so what did you observe ? \\n* Observation is that it doesn\\'t matter what are the elements present in an ideal sequence of distinct integer to make ideal sequence (not necessarily distinct according to question) , number of ideal sequences would be same if we take same length of ideal sequence of distinct integer.\\n* so, we wil count the number of ideal sequence of distinct integere of each length and for each length we will make ideal sequence according to question and add all those in our final ans.\\n* this question require little bit knowledge of combinatory (p & c) where we need how to find total number of ways to distribue n identical items to i person.\\n* so, let\\'s move to the code\\n\\n```\\n#define um unordered_map<int,int>\\n#define ll long long\\n\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n    int idealArrays(int n, int m) {\\n        vector<um> dp(m+1); // dp[i] store a map where key is the length of an ideal sequence ending on integer i and value is number of that ideal sequence of a particular length.\\n        \\n        vector<int> count(20); // count[i] store the number of ideal sequences of length i.\\n        for(int i=m;i>0;i--){\\n            if(dp[i].empty()){\\n                help(i,count,dp);\\n            }\\n        }\\n        long long ans = 0;\\n        // precalculate factorial\\n        std::vector<ll> factorial(n+1,1);\\n        for(int i=2;i<=n;i++){\\n            factorial[i]=i*factorial[i-1];\\n            factorial[i]%=mod;\\n        }\\n        \\n        for(int i=1;i<20;i++){\\n            //cout<<count[i]<<\" \";\\n            if(count[i] != 0){\\n                if(n < i)\\n                    break;\\n                ans += (1ll* count[i] * nCr(n-1, i-1, v)); // (n-1)C(i-1) is the number of ways to distribute n position to i integer..( concept of permutation and combination)\\n                ans = (ans%mod + mod)%mod;\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void help(int m, vector<int>& count, vector<um> &dp){\\n        if(!dp[m].empty()){\\n            return ;\\n        }\\n        um ans;\\n        if(m == 1){\\n            ans[1] = 1;\\n            count[1]++;\\n            dp[1] = ans;\\n            return;\\n        }\\n        \\n        ans[1] = 1;\\n        count[1]++;\\n        for(int i=2;i<=m;i++){\\n            if(m%i == 0){\\n                help(m/i,count,dp);\\n                for(auto it : dp[m/i]){\\n                    ans[it.first+1] += it.second; // append curr element to that sequence\\n                    count[it.first+1] += it.second;\\n                }\\n            }\\n        }\\n        \\n        dp[m] = ans;\\n    }\\n    \\n    int power(ll x,int n){\\n        ll ans=1;\\n        //int mod=1000000007;\\n        x%=mod;\\n        while(n!=0){\\n            if(n&1){\\n                ans*=x;\\n                ans%=mod;\\n            }\\n            x*=x;\\n            x%=mod;\\n            n=n>>1;\\n        }\\n    \\n        return int(ans);\\n    }\\n    \\n    int nCr(int n,int r, vector<ll>& v){\\n        //int mod=1000000007;\\n    \\n        ll ans=1; \\n    \\n        // (x/y)%m = ((x%m)*((y^(m-2))%m)) % m;\\n        ans = ((v[n]%mod)*(power(v[r]*v[n-r],mod-2)%mod))%mod;\\n    \\n        return int(ans);\\n    }\\n};\\n```\\n\\n* Below , I have written code where i am finding number of all ideal sequence with distinct integer ending on integer i and having some length j in dp[i][j].\\n* Then using this dp, we fill value in count array where count[i] is number of ideal sequence with distinct integer having length i.\\n* Then , using combinatorics , calculate all ideal seqeuences according to question\\n\\n```\\n#define um unordered_map<int,int>\\n#define ll long long\\n\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n    int idealArrays(int n, int m) {\\n        // see recursive solution in submissions\\n        // now writing iterative solution\\n        \\n        vector<vector<int>> dp(m+1,vector<int>(20)); // dp[i][j] store the number of ideal sequence with distinct integer ending with i.\\n        \\n        for(int i=1;i<=m;i++){\\n            dp[i][1] = 1;\\n            for(int j=i+i;j<=m;j+=i){\\n                for(int len=1;len<19;len++){\\n                    dp[j][len+1] += dp[i][len];\\n                }\\n            }\\n        }\\n        \\n        vector<int> count(20); // count[i] store the number of ideal sequences of length i.\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<20;j++){\\n                count[j] += dp[i][j];\\n            }\\n        }\\n        \\n        // use combinatorics\\n        long long ans = 0;\\n        \\n        std::vector<ll> v(n+1,1);\\n        for(int i=2;i<=n;i++){\\n            v[i]=i*v[i-1];\\n            v[i]%=mod;\\n        }\\n        \\n        for(int i=1;i<20;i++){\\n            //cout<<count[i]<<\" \";\\n            if(count[i] != 0){\\n                if(n < i)\\n                    break;\\n                ans += (1ll* count[i] * nCr(n-1, i-1, v));\\n                ans = (ans%mod + mod)%mod;\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int power(ll x,int n){\\n        ll ans=1;\\n        //int mod=1000000007;\\n        x%=mod;\\n        while(n!=0){\\n            if(n&1){\\n                ans*=x;\\n                ans%=mod;\\n            }\\n            x*=x;\\n            x%=mod;\\n            n=n>>1;\\n        }\\n    \\n        return int(ans);\\n    }\\n    \\n    int nCr(int n,int r, vector<ll>& v){\\n        //int mod=1000000007;\\n    \\n        ll ans=1; \\n    \\n        // (x/y)%m = ((x%m)*((y^(m-2))%m)) % m;\\n        ans = ((v[n]%mod)*(power(v[r]*v[n-r],mod-2)%mod))%mod;\\n    \\n        return int(ans);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\n#define um unordered_map<int,int>\\n#define ll long long\\n\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n    int idealArrays(int n, int m) {\\n        vector<um> dp(m+1); // dp[i] store a map where key is the length of an ideal sequence ending on integer i and value is number of that ideal sequence of a particular length.\\n        \\n        vector<int> count(20); // count[i] store the number of ideal sequences of length i.\\n        for(int i=m;i>0;i--){\\n            if(dp[i].empty()){\\n                help(i,count,dp);\\n            }\\n        }\\n        long long ans = 0;\\n        // precalculate factorial\\n        std::vector<ll> factorial(n+1,1);\\n        for(int i=2;i<=n;i++){\\n            factorial[i]=i*factorial[i-1];\\n            factorial[i]%=mod;\\n        }\\n        \\n        for(int i=1;i<20;i++){\\n            //cout<<count[i]<<\" \";\\n            if(count[i] != 0){\\n                if(n < i)\\n                    break;\\n                ans += (1ll* count[i] * nCr(n-1, i-1, v)); // (n-1)C(i-1) is the number of ways to distribute n position to i integer..( concept of permutation and combination)\\n                ans = (ans%mod + mod)%mod;\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void help(int m, vector<int>& count, vector<um> &dp){\\n        if(!dp[m].empty()){\\n            return ;\\n        }\\n        um ans;\\n        if(m == 1){\\n            ans[1] = 1;\\n            count[1]++;\\n            dp[1] = ans;\\n            return;\\n        }\\n        \\n        ans[1] = 1;\\n        count[1]++;\\n        for(int i=2;i<=m;i++){\\n            if(m%i == 0){\\n                help(m/i,count,dp);\\n                for(auto it : dp[m/i]){\\n                    ans[it.first+1] += it.second; // append curr element to that sequence\\n                    count[it.first+1] += it.second;\\n                }\\n            }\\n        }\\n        \\n        dp[m] = ans;\\n    }\\n    \\n    int power(ll x,int n){\\n        ll ans=1;\\n        //int mod=1000000007;\\n        x%=mod;\\n        while(n!=0){\\n            if(n&1){\\n                ans*=x;\\n                ans%=mod;\\n            }\\n            x*=x;\\n            x%=mod;\\n            n=n>>1;\\n        }\\n    \\n        return int(ans);\\n    }\\n    \\n    int nCr(int n,int r, vector<ll>& v){\\n        //int mod=1000000007;\\n    \\n        ll ans=1; \\n    \\n        // (x/y)%m = ((x%m)*((y^(m-2))%m)) % m;\\n        ans = ((v[n]%mod)*(power(v[r]*v[n-r],mod-2)%mod))%mod;\\n    \\n        return int(ans);\\n    }\\n};\\n```\n```\\n#define um unordered_map<int,int>\\n#define ll long long\\n\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n    int idealArrays(int n, int m) {\\n        // see recursive solution in submissions\\n        // now writing iterative solution\\n        \\n        vector<vector<int>> dp(m+1,vector<int>(20)); // dp[i][j] store the number of ideal sequence with distinct integer ending with i.\\n        \\n        for(int i=1;i<=m;i++){\\n            dp[i][1] = 1;\\n            for(int j=i+i;j<=m;j+=i){\\n                for(int len=1;len<19;len++){\\n                    dp[j][len+1] += dp[i][len];\\n                }\\n            }\\n        }\\n        \\n        vector<int> count(20); // count[i] store the number of ideal sequences of length i.\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<20;j++){\\n                count[j] += dp[i][j];\\n            }\\n        }\\n        \\n        // use combinatorics\\n        long long ans = 0;\\n        \\n        std::vector<ll> v(n+1,1);\\n        for(int i=2;i<=n;i++){\\n            v[i]=i*v[i-1];\\n            v[i]%=mod;\\n        }\\n        \\n        for(int i=1;i<20;i++){\\n            //cout<<count[i]<<\" \";\\n            if(count[i] != 0){\\n                if(n < i)\\n                    break;\\n                ans += (1ll* count[i] * nCr(n-1, i-1, v));\\n                ans = (ans%mod + mod)%mod;\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int power(ll x,int n){\\n        ll ans=1;\\n        //int mod=1000000007;\\n        x%=mod;\\n        while(n!=0){\\n            if(n&1){\\n                ans*=x;\\n                ans%=mod;\\n            }\\n            x*=x;\\n            x%=mod;\\n            n=n>>1;\\n        }\\n    \\n        return int(ans);\\n    }\\n    \\n    int nCr(int n,int r, vector<ll>& v){\\n        //int mod=1000000007;\\n    \\n        ll ans=1; \\n    \\n        // (x/y)%m = ((x%m)*((y^(m-2))%m)) % m;\\n        ans = ((v[n]%mod)*(power(v[r]*v[n-r],mod-2)%mod))%mod;\\n    \\n        return int(ans);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2346184,
                "title": "runtime-128-ms-memory-usage-14-4-mb",
                "content": "```\\nclass Solution:\\n\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        MOD = 10 ** 9 + 7\\n\\n        my_combs = [1, n]  # my_combs[k] = n+k-1 choose k\\n        for k in range(2, 21):\\n            my_combs.append(((n + k - 1) * my_combs[-1]) // k)\\n        for x in range(len(my_combs)):\\n            my_combs[x] %= MOD\\n\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\\n                  53, 59, 61, 67, 71, 73,\\n                  79, 83, 89, 97]\\n\\n        fac_prods = [1] * (maxValue + 1)\\n        ans = 1\\n\\n        for x in primes:\\n            if x > maxValue:\\n                break\\n\\n            mult = x\\n            ii = 1\\n            comb_prodder = my_combs[ii]\\n\\n            while mult <= maxValue:\\n                for nm in range(mult, mult * x, mult):\\n                    if nm > maxValue:\\n                        break\\n                    for y in range(nm, maxValue + 1, mult * x):\\n                        fac_prods[y] = fac_prods[y] * comb_prodder % MOD\\n                mult *= x\\n                ii += 1\\n                comb_prodder = my_combs[ii]\\n\\n        for i in range(2, maxValue + 1):\\n            if fac_prods[i] == 1 and i > 100:\\n                for y in range(i, maxValue + 1, i):\\n                    fac_prods[y] *= n\\n            ans += fac_prods[i] % MOD\\n\\n        return ans % MOD\\n```\\nhit like button.,  this solution helped you somehow\\n**if you found any problem or have any suggestion... feel free to share with me**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        MOD = 10 ** 9 + 7\\n\\n        my_combs = [1, n]  # my_combs[k] = n+k-1 choose k\\n        for k in range(2, 21):\\n            my_combs.append(((n + k - 1) * my_combs[-1]) // k)\\n        for x in range(len(my_combs)):\\n            my_combs[x] %= MOD\\n\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\\n                  53, 59, 61, 67, 71, 73,\\n                  79, 83, 89, 97]\\n\\n        fac_prods = [1] * (maxValue + 1)\\n        ans = 1\\n\\n        for x in primes:\\n            if x > maxValue:\\n                break\\n\\n            mult = x\\n            ii = 1\\n            comb_prodder = my_combs[ii]\\n\\n            while mult <= maxValue:\\n                for nm in range(mult, mult * x, mult):\\n                    if nm > maxValue:\\n                        break\\n                    for y in range(nm, maxValue + 1, mult * x):\\n                        fac_prods[y] = fac_prods[y] * comb_prodder % MOD\\n                mult *= x\\n                ii += 1\\n                comb_prodder = my_combs[ii]\\n\\n        for i in range(2, maxValue + 1):\\n            if fac_prods[i] == 1 and i > 100:\\n                for y in range(i, maxValue + 1, i):\\n                    fac_prods[y] *= n\\n            ans += fac_prods[i] % MOD\\n\\n        return ans % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299171,
                "title": "c-37-tc-passed",
                "content": "```\\nint mod=1e9+7;\\n    int solve(int prev,int ind,int maxValue,vector<vector<int>>& dp,int n){\\n        if(ind==n) return 1;\\n        if(prev==maxValue) return 1;\\n        if(dp[ind][prev]!=-1) return dp[ind][prev]%mod;\\n        int sml=0;\\n        for(int i=prev;i<=maxValue;i+=prev){\\n            // if(i%prev==0){\\n                // ar[ind]=i;\\n                sml=sml%mod;\\n                sml+=solve(i,ind+1,maxValue,dp,n)%mod;\\n                sml=sml%mod;\\n            // }\\n        }\\n        return dp[ind][prev]=sml%mod;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        vector<vector<int>> dp(n+1,vector<int>(maxValue+1,-1));\\n        int ans=0;\\n        for(int i=1;i<=maxValue;i++){\\n            // ar[0]=i;\\n            ans=ans%mod;\\n            ans+=solve(i,1,maxValue,dp,n)%mod;\\n            ans=ans%mod;\\n        }\\n        return ans;\\n    }\\n```\\ncan u convert this to a tabulation \\nn why is it giving tle for 5000 x 2000 tc even though it is under 10^8\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint mod=1e9+7;\\n    int solve(int prev,int ind,int maxValue,vector<vector<int>>& dp,int n){\\n        if(ind==n) return 1;\\n        if(prev==maxValue) return 1;\\n        if(dp[ind][prev]!=-1) return dp[ind][prev]%mod;\\n        int sml=0;\\n        for(int i=prev;i<=maxValue;i+=prev){\\n            // if(i%prev==0){\\n                // ar[ind]=i;\\n                sml=sml%mod;\\n                sml+=solve(i,ind+1,maxValue,dp,n)%mod;\\n                sml=sml%mod;\\n            // }\\n        }\\n        return dp[ind][prev]=sml%mod;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        vector<vector<int>> dp(n+1,vector<int>(maxValue+1,-1));\\n        int ans=0;\\n        for(int i=1;i<=maxValue;i++){\\n            // ar[0]=i;\\n            ans=ans%mod;\\n            ans+=solve(i,1,maxValue,dp,n)%mod;\\n            ans=ans%mod;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267920,
                "title": "c-stars-and-bars-combinations",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long fac[10030], inv[10030];\\n    unordered_map<int,vector<int>> mp;\\n    void MAP(int m){\\n        for(int i = 1; i<=m;++i){\\n            for(int j = i+i; j<=m;j+=i) mp[j].push_back(i);\\n        }\\n    }\\n    void find(){\\n        int n = 10020;\\n        fac[0] = 1; fac[1] = 1;\\n        for(int i = 2; i<=n; ++i) fac[i] = (i*fac[i-1])%mod;\\n        inv[n] = 464446337;\\n        for(int i = n-1;i>=0;i--) inv[i] = ((i+1)*inv[i+1])%mod;\\n    }\\n    long nCr(int n,int r){\\n        return ((fac[n]*inv[r])%mod*inv[n-r])%mod;\\n    }\\n    int idealArrays(int n, int m) {\\n        MAP(m); find();\\n        int l = log2(m)+1;\\n        vector<vector<long>> dp(l+1,vector<long>(m+1,0));\\n        for(int i = 1; i<=min(n,l);++i){\\n            for(int j = 1;j<=m;++j){\\n                if(i==1){ dp[i][j] = 1; continue; }\\n                for(int k = 0; k<mp[j].size();++k){\\n                    dp[i][j] = (dp[i-1][mp[j][k]] + dp[i][j])%mod;\\n                }\\n            }\\n        }\\n        vector<long> dp2(l+1,1);\\n        for(int i = 2; i<=l;++i){\\n            dp2[i] = nCr(n+i-1,n);\\n            for(int j = i-1;j>=1;--j){\\n                dp2[i] = (dp2[i] - dp2[j]*nCr(i,j) + mod)%mod;\\n            }\\n        }\\n        long long re = 0;\\n        for(int i = 1; i<=min(n,l);++i){\\n            for(int j = 1;j<=m;++j){\\n                re = (re + (dp[i][j]*dp2[i])%mod)%mod;\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long fac[10030], inv[10030];\\n    unordered_map<int,vector<int>> mp;\\n    void MAP(int m){\\n        for(int i = 1; i<=m;++i){\\n            for(int j = i+i; j<=m;j+=i) mp[j].push_back(i);\\n        }\\n    }\\n    void find(){\\n        int n = 10020;\\n        fac[0] = 1; fac[1] = 1;\\n        for(int i = 2; i<=n; ++i) fac[i] = (i*fac[i-1])%mod;\\n        inv[n] = 464446337;\\n        for(int i = n-1;i>=0;i--) inv[i] = ((i+1)*inv[i+1])%mod;\\n    }\\n    long nCr(int n,int r){\\n        return ((fac[n]*inv[r])%mod*inv[n-r])%mod;\\n    }\\n    int idealArrays(int n, int m) {\\n        MAP(m); find();\\n        int l = log2(m)+1;\\n        vector<vector<long>> dp(l+1,vector<long>(m+1,0));\\n        for(int i = 1; i<=min(n,l);++i){\\n            for(int j = 1;j<=m;++j){\\n                if(i==1){ dp[i][j] = 1; continue; }\\n                for(int k = 0; k<mp[j].size();++k){\\n                    dp[i][j] = (dp[i-1][mp[j][k]] + dp[i][j])%mod;\\n                }\\n            }\\n        }\\n        vector<long> dp2(l+1,1);\\n        for(int i = 2; i<=l;++i){\\n            dp2[i] = nCr(n+i-1,n);\\n            for(int j = i-1;j>=1;--j){\\n                dp2[i] = (dp2[i] - dp2[j]*nCr(i,j) + mod)%mod;\\n            }\\n        }\\n        long long re = 0;\\n        for(int i = 1; i<=min(n,l);++i){\\n            for(int j = 1;j<=m;++j){\\n                re = (re + (dp[i][j]*dp2[i])%mod)%mod;\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265037,
                "title": "c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> comb;\\n    static const int mod = (1e9 + 7);\\n    int idealArrays(int n, int mx) {\\n        int k = min({15, n + 1, mx + 1});\\n        dp = vector<vector<int>>(mx + 1, vector<int>(k, 1));\\n        comb = vector<vector<int>>(n, vector<int>(k));\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < k; j++) {\\n                if (j > i) break;\\n                if (i == j) comb[i][j] = 1;\\n                else if (j == 1) comb[i][j] = i;\\n                else comb[i][j] = (comb[i - 1][j - 1] + comb[i- 1][j]) % mod;\\n            }\\n        }\\n        long long ans = mx;\\n        for (int l = 2; l < k; l++) {\\n            for (int i = 1; i <= mx; i++) {        \\n                long long cur = 0;\\n                for (int a = i + i; a <= mx; a += i) {\\n                    cur = (cur + dp[a][l - 1]) % mod;\\n                }\\n                dp[i][l] = cur;\\n                ans = (ans + cur * comb[n - 1][l - 1]) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> comb;\\n    static const int mod = (1e9 + 7);\\n    int idealArrays(int n, int mx) {\\n        int k = min({15, n + 1, mx + 1});\\n        dp = vector<vector<int>>(mx + 1, vector<int>(k, 1));\\n        comb = vector<vector<int>>(n, vector<int>(k));\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < k; j++) {\\n                if (j > i) break;\\n                if (i == j) comb[i][j] = 1;\\n                else if (j == 1) comb[i][j] = i;\\n                else comb[i][j] = (comb[i - 1][j - 1] + comb[i- 1][j]) % mod;\\n            }\\n        }\\n        long long ans = mx;\\n        for (int l = 2; l < k; l++) {\\n            for (int i = 1; i <= mx; i++) {        \\n                long long cur = 0;\\n                for (int a = i + i; a <= mx; a += i) {\\n                    cur = (cur + dp[a][l - 1]) % mod;\\n                }\\n                dp[i][l] = cur;\\n                ans = (ans + cur * comb[n - 1][l - 1]) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264979,
                "title": "python3-math-lru-cache-compute-combinatorics",
                "content": "It is not hard to get the math expression for the final solution. However, it takes some time to optimize to pass the test. I will explain some tricks later. See a rough code below. More details to be added. \\n\\n```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        # first find all primes\\n        p = []\\n\\n        for num in range(2, maxValue+1):\\n            prime = True\\n            for i in range(2,int(math.sqrt(num))+1):\\n                if (num % i==0):\\n                    prime = False\\n                    break\\n            if prime:\\n                p.append(num)\\n        m = len(p)\\n        d = defaultdict(list)\\n        for i in range(m):\\n            d[p[i]] = [0] * m\\n            d[p[i]][i] = 1\\n            \\n        # calculate prime factorization for each possible maxValue\\n        for v in range(3, maxValue+1):\\n            if v not in d:\\n                d[v] = [0] * m\\n                for i in range(m):\\n                    prime = p[i]\\n                    if v % prime == 0:\\n                        d[v] = d[v//prime].copy()\\n                        d[v][i] += 1\\n                        break\\n                        \\n        # calculate combinatorics number C(ri+n-1, n-1) to speed up (memorization)\\n        @lru_cache(None)\\n        def C(n, k):\\n            if k == 0:\\n                return 1\\n            if k == 1:\\n                return n\\n            if k > n:\\n                return 0\\n            return C(n-1, k) + C(n-1, k-1)\\n              \\n        N = 10 ** 9 + 7\\n        res = 0\\n        for v in range(1, maxValue+1):\\n            r = d[v]\\n            t = 1\\n            for ri in r:\\n                if ri > 0:\\n                    t *= C(ri+n-1, min(n-1, ri))\\n                \\n            res += t % N\\n        return res % N\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        # first find all primes\\n        p = []\\n\\n        for num in range(2, maxValue+1):\\n            prime = True\\n            for i in range(2,int(math.sqrt(num))+1):\\n                if (num % i==0):\\n                    prime = False\\n                    break\\n            if prime:\\n                p.append(num)\\n        m = len(p)\\n        d = defaultdict(list)\\n        for i in range(m):\\n            d[p[i]] = [0] * m\\n            d[p[i]][i] = 1\\n            \\n        # calculate prime factorization for each possible maxValue\\n        for v in range(3, maxValue+1):\\n            if v not in d:\\n                d[v] = [0] * m\\n                for i in range(m):\\n                    prime = p[i]\\n                    if v % prime == 0:\\n                        d[v] = d[v//prime].copy()\\n                        d[v][i] += 1\\n                        break\\n                        \\n        # calculate combinatorics number C(ri+n-1, n-1) to speed up (memorization)\\n        @lru_cache(None)\\n        def C(n, k):\\n            if k == 0:\\n                return 1\\n            if k == 1:\\n                return n\\n            if k > n:\\n                return 0\\n            return C(n-1, k) + C(n-1, k-1)\\n              \\n        N = 10 ** 9 + 7\\n        res = 0\\n        for v in range(1, maxValue+1):\\n            r = d[v]\\n            t = 1\\n            for ri in r:\\n                if ri > 0:\\n                    t *= C(ri+n-1, min(n-1, ri))\\n                \\n            res += t % N\\n        return res % N\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262415,
                "title": "video-explanation",
                "content": "https://www.youtube.com/watch?v=Ar0AEWaO2Xk",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "https://www.youtube.com/watch?v=Ar0AEWaO2Xk",
                "codeTag": "Unknown"
            },
            {
                "id": 2262118,
                "title": "c-easy-dp-solution-beats-100",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int n,m,dp[10005][20];\\n    int cnt[10005][20];\\n    int idealArrays(int n, int m) {\\n        int mod = 1e9+7;\\n        for(int i=1; i<=m; i++) {\\n\\t\\t    dp[i][1]=(dp[i][1]+1)%mod;\\n\\t\\t    for(int j=i+i; j<=m; j+=i) {\\n\\t\\t\\t    for(int k=1; k<=18; k++) {\\n\\t\\t\\t\\t    dp[j][k]=(dp[j][k]+dp[i][k-1])%mod;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\t    for(int i=0; i<=n; i++) {\\n\\t\\t    cnt[i][0]=1;\\n\\t\\t    for(int j=1; j<=min(i,18); j++) {\\n\\t\\t\\t    cnt[i][j]=(cnt[i-1][j]+cnt[i-1][j-1])%mod;\\n\\t\\t    }\\n\\t    }\\n\\t    long long ans=0;\\n\\t    for(int i=1; i<=m; i++) {\\n\\t\\t    for(int j=1; j<=18; j++) {\\n\\t\\t\\t    ans=(ans+1ll*dp[i][j]*cnt[n-1][j-1]%mod)%mod;\\n\\t\\t    }\\n\\t    }\\n\\t    return ans;\\n    }\\n};\\n~~~",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int n,m,dp[10005][20];\\n    int cnt[10005][20];\\n    int idealArrays(int n, int m) {\\n        int mod = 1e9+7;\\n        for(int i=1; i<=m; i++) {\\n\\t\\t    dp[i][1]=(dp[i][1]+1)%mod;\\n\\t\\t    for(int j=i+i; j<=m; j+=i) {\\n\\t\\t\\t    for(int k=1; k<=18; k++) {\\n\\t\\t\\t\\t    dp[j][k]=(dp[j][k]+dp[i][k-1])%mod;\\n\\t\\t\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 2261902,
                "title": "python3-precalculate-dp-table-beat-100-100",
                "content": "Let `dp[i][j]` be **the number of length `i`  sequences with distinct elements that ends with `j`**. Then we know **all the test cases will use the same dp table**.\\nAfter we get the precalculated table, we just need to count the total number of length `i`  sequences with distinct elements that ends with `1<= j <= maxValue`. Then we use this number multiplied by `comb(n - 1, i - 1)`, and add it to the `ans`.\\nThe combinatorics part is the same as the question: If `x1+...+xi = n`,  find the number of positive integer solutions.\\n```\\nM = 10 ** 9 + 7\\nl = 0\\nwhile 2 ** l <= 10 ** 4:\\n    l += 1\\ndp = [[0] * (10 ** 4 + 1) for _ in range(l + 1)]\\nfor j in range(1, 10 ** 4 + 1):\\n    dp[1][j] = 1\\nfor i in range(2, l + 1):\\n    for j in range(2 ** (i - 2), 10 ** 4 + 1):\\n        k = 2\\n        while j * k <= 10 ** 4:\\n            dp[i][j*k] = (dp[i][j*k] + dp[i-1][j]) % M\\n            k += 1\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        i = 0\\n        while 2 ** i <= maxValue:\\n            i += 1\\n        l = min(n, i)\\n        ans = 0\\n        for i in range(1, l + 1):\\n            ans = (ans + sum(dp[i][:maxValue + 1]) * math.comb(n - 1, i - 1)) % M\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nM = 10 ** 9 + 7\\nl = 0\\nwhile 2 ** l <= 10 ** 4:\\n    l += 1\\ndp = [[0] * (10 ** 4 + 1) for _ in range(l + 1)]\\nfor j in range(1, 10 ** 4 + 1):\\n    dp[1][j] = 1\\nfor i in range(2, l + 1):\\n    for j in range(2 ** (i - 2), 10 ** 4 + 1):\\n        k = 2\\n        while j * k <= 10 ** 4:\\n            dp[i][j*k] = (dp[i][j*k] + dp[i-1][j]) % M\\n            k += 1\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        i = 0\\n        while 2 ** i <= maxValue:\\n            i += 1\\n        l = min(n, i)\\n        ans = 0\\n        for i in range(1, l + 1):\\n            ans = (ans + sum(dp[i][:maxValue + 1]) * math.comb(n - 1, i - 1)) % M\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261718,
                "title": "c-solution-with-think-processing",
                "content": "It\\'s easy to come up with a 2D dp solution. \\ndp(s,n) = number of ideal array starts with s and length is n. \\nAnd dp(s,n) = sum of (dp(s\\\\*i,n-1)) where s\\\\*i <= maxValue (m). \\nHowever, the solution will time out. \\nWe need comupte length from 1 to n. \\nFor each length i, we need compute m + m/2 + m/3 + ... + m/m = log(m)*m times from length n -1. \\nThus the total time complexity is n * m * log(m). \\nSince n = 1e4 and m = 1e4. It cannot pass. \\n\\nIt takes me a while to realize that we only need to count distinct increasing array. \\nFor example, if n = 5 and m = 3. \\nwe have distinct array [2,4,8] \\nand we can choose any 3 slots from the 10 empty slots to assign the array. \\nWe need to compute n choose 3.\\nFor example, we can assign it as [1,2,2,4,8] or [2,2,2,4,8]\\nAnd it\\'s easy to prove that the length of longest disticnt array cannot larger than 20. (Because 2 ** 20 = 1e6 > 1e10). \\nI choose 20 as upper bound, though it\\'s a little overkill. \\n\\nThen the problem became easy. \\nWe only need to compute number of distinct array. And multiple it with the number of assign the distinct array to empty slots. \\nWe need to add 1 because all 1 array is also a valid solution. \\n\\nBecause the number is large, we need to comput Modular multiplicative inverse. I precompute it by python. pow(i,mod-2,mod)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7; \\n    void f(int s, int m, int len, vector<long long>& tmp) {\\n        if(s <= m) {\\n            tmp[len]++; \\n        }\\n        for(int i = 2;i*s<=m;i++) {\\n            f(s*i,m,len+1,tmp);\\n        }\\n    }\\n    \\n    long long NCR(int n, int r)\\n    {\\n    vector<int> reverse_m = {1, 500000004, 333333336, 250000002, 400000003, 166666668, 142857144, 125000001, 111111112, 700000005, 818181824, 83333334, 153846155, 71428572, 466666670, 562500004, 352941179, 55555556, 157894738, 850000006};\\n    if(n == r) {\\n        return 1; \\n    }\\n    if(r > n) {\\n        return 0; \\n    }\\n    if (r == 0) return 1;\\n    long long res = 1; \\n    for (int k = 1; k <= r; ++k)\\n    {\\n        res *= n - k + 1;\\n        res %= mod; \\n        res *= reverse_m[k-1];\\n        res %= mod; \\n    }\\n\\n    return res % mod;\\n    }\\n    \\n    \\n    int idealArrays(int n, int m) {\\n        vector<long long> tmp(20);\\n        for(int i = 2;i<=m;i++) {\\n            f(i,m,1,tmp);\\n        }\\n        vector<vector<long long>> dp(n+2,vector<long long>(20,-1));\\n        long long ret = 0;\\n\\n        for(int i = 1;i<tmp.size();i++) {\\n            if(tmp[i] == 0) {\\n                break; \\n            }\\n            long long t = NCR(n,i);\\n            t *= tmp[i];\\n            t %= mod; \\n            ret += t; \\n        }\\n        return (ret + 1) % mod; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7; \\n    void f(int s, int m, int len, vector<long long>& tmp) {\\n        if(s <= m) {\\n            tmp[len]++; \\n        }\\n        for(int i = 2;i*s<=m;i++) {\\n            f(s*i,m,len+1,tmp);\\n        }\\n    }\\n    \\n    long long NCR(int n, int r)\\n    {\\n    vector<int> reverse_m = {1, 500000004, 333333336, 250000002, 400000003, 166666668, 142857144, 125000001, 111111112, 700000005, 818181824, 83333334, 153846155, 71428572, 466666670, 562500004, 352941179, 55555556, 157894738, 850000006};\\n    if(n == r) {\\n        return 1; \\n    }\\n    if(r > n) {\\n        return 0; \\n    }\\n    if (r == 0) return 1;\\n    long long res = 1; \\n    for (int k = 1; k <= r; ++k)\\n    {\\n        res *= n - k + 1;\\n        res %= mod; \\n        res *= reverse_m[k-1];\\n        res %= mod; \\n    }\\n\\n    return res % mod;\\n    }\\n    \\n    \\n    int idealArrays(int n, int m) {\\n        vector<long long> tmp(20);\\n        for(int i = 2;i<=m;i++) {\\n            f(i,m,1,tmp);\\n        }\\n        vector<vector<long long>> dp(n+2,vector<long long>(20,-1));\\n        long long ret = 0;\\n\\n        for(int i = 1;i<tmp.size();i++) {\\n            if(tmp[i] == 0) {\\n                break; \\n            }\\n            long long t = NCR(n,i);\\n            t *= tmp[i];\\n            t %= mod; \\n            ret += t; \\n        }\\n        return (ret + 1) % mod; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261457,
                "title": "python-stars-and-bars-combinatorics-beats-100-o-m-log-2-m",
                "content": "**Idea**\\n\\n* Count the number of ideal arrays without allowing repeats.\\n* Use [Stars and Bars](https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics)) to calculate the number of ideal arrays with repeats, given the unique counts. Each ideal array of length `x` without repeats can become `(n-1 choose x-1)` ideal arrays with repeats. \\n****\\nFor example, given an ideal array with no repeats of `[1,2,3]`, and a value of `n=6`, we can form (5 choose 2) = 10 different arrays of length 6 that contain only the digits (1, 2, 3) in that order.\\n\\nSince we only care about the length of the unique ideal arrays, we should iterate over divisors of each number.\\n\\nTo find the number of unique ideal arrays of length `k` that end on an integer `m`, sum the number of unique ideal arrays of length `k-1` that end on a divisor of `m`. \\n\\nWe can loop over the divisors instead for speed and to allow parallelization with numpy. The longest unique ideal array with a maximum value of M is at most `(log_2(M)+1)`, since each value in that array is twice as large as the previous. For us, 18 is large enough, since `log_2(10^4) < 14`\\n\\n****\\n**Python (with numpy)** \\n\\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        MOD = 10 ** 9 + 7\\n\\n        my_combs = [1]  # n-1 choose k\\n        for k in range(1, 21):\\n            my_combs.append(((n - k) * my_combs[-1]) // k)\\n\\n        my_lengths = np.zeros(shape=(maxValue + 1, 18), dtype=np.int32)\\n        my_lengths[:, 1] = 1\\n        my_lengths[:, 2] = 1\\n\\n        for x in range(2, min((maxValue + 1) // 2, maxValue) + 1):\\n            my_lengths[2 * x: maxValue + 1: x, 1:] += my_lengths[x, :-1]\\n\\n        my_lengths[0] = 0\\n        my_lengths[1, 2] = 0\\n        by_total_length = np.sum(my_lengths, axis=0)\\n\\n        total = 0\\n        for k, v in enumerate(by_total_length):\\n            if k == 0 or v == 0:\\n                continue\\n            total += int(v) * my_combs[k - 1] % MOD\\n\\n        return total % MOD\\n```\\nTime complexity: `O(maxValue * log^2(maxValue))`. \\nSpace complexity: `O(maxValue *  log(maxValue))`. \\n\\nUsing numpy, we can this run several times faster than an equivalent non-Numpy solution, and more competitive with compiled languages. However, a non-vectorized solution is still fast enough to pass Leetcode timing.\\n\\nEdit: Corrected variable names in time complexity",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nimport numpy as np\\n\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        MOD = 10 ** 9 + 7\\n\\n        my_combs = [1]  # n-1 choose k\\n        for k in range(1, 21):\\n            my_combs.append(((n - k) * my_combs[-1]) // k)\\n\\n        my_lengths = np.zeros(shape=(maxValue + 1, 18), dtype=np.int32)\\n        my_lengths[:, 1] = 1\\n        my_lengths[:, 2] = 1\\n\\n        for x in range(2, min((maxValue + 1) // 2, maxValue) + 1):\\n            my_lengths[2 * x: maxValue + 1: x, 1:] += my_lengths[x, :-1]\\n\\n        my_lengths[0] = 0\\n        my_lengths[1, 2] = 0\\n        by_total_length = np.sum(my_lengths, axis=0)\\n\\n        total = 0\\n        for k, v in enumerate(by_total_length):\\n            if k == 0 or v == 0:\\n                continue\\n            total += int(v) * my_combs[k - 1] % MOD\\n\\n        return total % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261426,
                "title": "c-dp-combination-o-n",
                "content": "observation:\\n1. log(10000) / log(2) = 13.287, so there are at most 14 different numbers in the array (use 16 in program for safe)\\n\\nby using this observation, we can come up with the answer with three steps\\n1. count the possible array that start from val, and change K times\\n2. calculate the possible combination if we need to change K times\\n3. sum up (step1 * step2)\\n\\n```\\n#define MOD (1000000007)\\n\\nclass Solution {\\nprivate:\\n    int data[10001] = {0};\\n    int count[10001][16] = {0};\\n    int N;\\n    int c[100001][16] = {0};\\n    \\n    int find(int val, int n, int maxValue){\\n        if(count[val][n]!=0){\\n            return count[val][n];\\n        }\\n        if(n==0){\\n            return 1;\\n        }\\n        \\n        int ans = 0;\\n        for(int i=val+val ; i<=maxValue ; i+= val){\\n            ans = (ans + find(i, n-1, maxValue))%MOD;\\n        }\\n        count[val][n] = ans;\\n        \\n        return ans;\\n    }\\n    \\n    int choose(int a, int b){\\n        if(a==b || b==0){\\n            return 1;\\n        }\\n        if(c[a][b]!=0){\\n            return c[a][b]; \\n        }\\n        \\n        c[a][b] = (choose(a-1, b-1)+choose(a-1, b))%MOD;\\n        \\n        return c[a][b];\\n    }\\n    \\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        long long ans = 0;\\n    \\n        N = n;\\n        int upper = min(n, 16);\\n        int temp, t;\\n        for(int i=1 ; i<=maxValue ; i++){\\n            for(int j=0 ; j<upper ; j++){\\n                temp = find(i, j, maxValue);\\n                if(temp>0){\\n                    t = (1ll * temp * choose(n-1, j)) %MOD;\\n                    ans = (ans + t) % MOD;   \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MOD (1000000007)\\n\\nclass Solution {\\nprivate:\\n    int data[10001] = {0};\\n    int count[10001][16] = {0};\\n    int N;\\n    int c[100001][16] = {0};\\n    \\n    int find(int val, int n, int maxValue){\\n        if(count[val][n]!=0){\\n            return count[val][n];\\n        }\\n        if(n==0){\\n            return 1;\\n        }\\n        \\n        int ans = 0;\\n        for(int i=val+val ; i<=maxValue ; i+= val){\\n            ans = (ans + find(i, n-1, maxValue))%MOD;\\n        }\\n        count[val][n] = ans;\\n        \\n        return ans;\\n    }\\n    \\n    int choose(int a, int b){\\n        if(a==b || b==0){\\n            return 1;\\n        }\\n        if(c[a][b]!=0){\\n            return c[a][b]; \\n        }\\n        \\n        c[a][b] = (choose(a-1, b-1)+choose(a-1, b))%MOD;\\n        \\n        return c[a][b];\\n    }\\n    \\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        long long ans = 0;\\n    \\n        N = n;\\n        int upper = min(n, 16);\\n        int temp, t;\\n        for(int i=1 ; i<=maxValue ; i++){\\n            for(int j=0 ; j<upper ; j++){\\n                temp = find(i, j, maxValue);\\n                if(temp>0){\\n                    t = (1ll * temp * choose(n-1, j)) %MOD;\\n                    ans = (ans + t) % MOD;   \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261326,
                "title": "tle-dp-solution-in-c",
                "content": "Given TLE\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7 ;\\n    int idealArrays(int n, int target) {\\n        vector<vector<long long int >> dp(n,vector<long long int>(target+1 ,0)) ;\\n        \\n        for(int i = 0; i<n ;i++){\\n            for(int j=1 ;j<=target ;j++){\\n                if(i == 0){\\n                    dp[i][j] = 1 ;\\n                    continue ;\\n                }\\n                for(int k =1 ;k<=j;k++){\\n                    if(j%k != 0) continue ;\\n                    dp[i][j] += dp[i-1][k] ;\\n                    dp[i][j] %= mod ;\\n                }\\n            }            \\n        }\\n        long long int ans = 0 ;\\n        for(int i = 1; i<=target ;i++){\\n            ans += dp[n-1][i] ;\\n            ans%=mod ;\\n            cout<<dp[n-1][i]<<\" \" ;\\n        }\\n        return ans ;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int mod = 1e9+7 ;\\n    int idealArrays(int n, int target) {\\n        vector<vector<long long int >> dp(n,vector<long long int>(target+1 ,0)) ;\\n        \\n        for(int i = 0; i<n ;i++){\\n            for(int j=1 ;j<=target ;j++){\\n                if(i == 0){\\n                    dp[i][j] = 1 ;\\n                    continue ;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3950640,
                "title": "dp-combinatorics-c-solution",
                "content": "# Intuition\\n--> we need to find the number of ideal arrays of length n;\\n--> ideal array is defined as , arr[i-1] divides arr[i] and each array elemnt is in range [1...maxValue].\\n\\n--> arr[i-1] divides arr[i] means that arr[i] >= arr[i-1] must hold;\\n\\n--> some examples of valid array of length=3  and maxValue = 15 is \\n[1, 1, 1], [2, 2, 2] ...\\n\\n[1, 2, 2], [1, 4, 4], [2, 4, 4], [2, 2, 4] ...\\n\\n[1, 2, 4], [1, 3, 6], [2, 4, 8], [1, 4, 8] ...\\n\\nwe can se that the array can containe distinct elements ranging from [1, n];\\n\\n--> we are going to solve this problem in two steps \\n1.) we find the no. of ideal arrays possible of length i : 1<= i=>n\\n2.) find the no. ways of extending a i length array to n length array \\nby duplicating some or all of its elements \\n\\nphase 1 \\n    dp[i][j] = # of arrays of length i ending at element j \\n    dp[i][j] = sum(dp[i-1][k]) ; k is factor of j and k != j;\\n\\nphase 2\\n    let dp[i][0] = # of different ideal arrays of length i ;\\n    dp[i][0] = sum(dp[i][j]) ; for all  0<= j =>maxValue;\\n\\nQ how do we extend i length array to n length;\\n    --> this can be done using stars & bars technique\\n    eg suppose we have 3 length array [1, 2, 4];\\n    we want to extend this to length 10 ;\\n\\n_ _ _ _ _ _ _ _ _ _ ; we need to place theese 3 elements in 10 positions . how can we do that ? \\n\\nthere are exactly  nCk(9, 2) ways of doing this // think about placing bars in b/w to divide these positions into 3 parts\\n\\n\\n// now we are almost there \\n\\nans = sum of  dp[i][0] * nCk(n-1, i-1) ; for all 1 <= i => n; \\n\\nthats it \\n\\n### Happy Coding !!!\\n\\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\n    //dp[i][j] --> no. of unique valid arrays having length i ending at element j;\\npublic:\\n#define ll long long\\n    vector<ll> fac[10005];\\n    void init(int maxValue){\\n        for(int i=1; i<=maxValue; i++){\\n            int j=2*i;\\n            while(j <= maxValue){\\n                fac[j].push_back(i);\\n                j += i;\\n            }\\n        }\\n    }\\n\\n    int idealArrays(int n, int maxValue) {\\n        init(maxValue);\\n        int mod = 1e9+7;\\n        ll res = 0;\\n        vector<vector<ll>> dp(15, vector<ll>(maxValue+1));\\n        //conputing dp values;\\n        for(int j=1; j<=maxValue; j++){\\n            dp[1][j] = 1;\\n            dp[1][0] += 1;\\n        } \\n\\n        for(int i=2; i<=n && i<15; i++){\\n            for(int j=1; j<=maxValue; j++){\\n                for(int k : fac[j]){\\n                    dp[i][j] += dp[i-1][k];\\n                    dp[i][j] %= mod;\\n                }\\n                 //store this in dp[i][0];\\n                    dp[i][0] += dp[i][j];\\n                    dp[i][0] %= mod;\\n            }\\n        }\\n\\n        // for(int i=1; i<=n && i<15; i++){\\n        //     for(int j=1; j<=maxValue; j++){\\n        //         dp[i][0] += dp[i][j];\\n        //         dp[i][0] %=mod;\\n        //     }\\n        // }\\n\\n        //calculate value of nCk;\\n        vector<vector<ll>> nCk(10005, vector<ll>(15, 0));\\n        nCk[0][0] = 1;\\n        for(int i=1; i<=n; i++){\\n            nCk[i][0] = 1;\\n            for(int j=1; j<=i && j<15; j++){\\n                nCk[i][j] = (nCk[i-1][j] + nCk[i-1][j-1])%mod;\\n            }\\n        }\\n\\n\\n        //use stars-bars for each length i to get the final ans\\n        for(int i=1; i<=n && i<15; i++){\\n            res = (res + dp[i][0] * nCk[n-1][i-1])%mod;\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    //dp[i][j] --> no. of unique valid arrays having length i ending at element j;\\npublic:\\n#define ll long long\\n    vector<ll> fac[10005];\\n    void init(int maxValue){\\n        for(int i=1; i<=maxValue; i++){\\n            int j=2*i;\\n            while(j <= maxValue){\\n                fac[j].push_back(i);\\n                j += i;\\n            }\\n        }\\n    }\\n\\n    int idealArrays(int n, int maxValue) {\\n        init(maxValue);\\n        int mod = 1e9+7;\\n        ll res = 0;\\n        vector<vector<ll>> dp(15, vector<ll>(maxValue+1));\\n        //conputing dp values;\\n        for(int j=1; j<=maxValue; j++){\\n            dp[1][j] = 1;\\n            dp[1][0] += 1;\\n        } \\n\\n        for(int i=2; i<=n && i<15; i++){\\n            for(int j=1; j<=maxValue; j++){\\n                for(int k : fac[j]){\\n                    dp[i][j] += dp[i-1][k];\\n                    dp[i][j] %= mod;\\n                }\\n                 //store this in dp[i][0];\\n                    dp[i][0] += dp[i][j];\\n                    dp[i][0] %= mod;\\n            }\\n        }\\n\\n        // for(int i=1; i<=n && i<15; i++){\\n        //     for(int j=1; j<=maxValue; j++){\\n        //         dp[i][0] += dp[i][j];\\n        //         dp[i][0] %=mod;\\n        //     }\\n        // }\\n\\n        //calculate value of nCk;\\n        vector<vector<ll>> nCk(10005, vector<ll>(15, 0));\\n        nCk[0][0] = 1;\\n        for(int i=1; i<=n; i++){\\n            nCk[i][0] = 1;\\n            for(int j=1; j<=i && j<15; j++){\\n                nCk[i][j] = (nCk[i-1][j] + nCk[i-1][j-1])%mod;\\n            }\\n        }\\n\\n\\n        //use stars-bars for each length i to get the final ans\\n        for(int i=1; i<=n && i<15; i++){\\n            res = (res + dp[i][0] * nCk[n-1][i-1])%mod;\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682047,
                "title": "count-only-increasing-sequences",
                "content": "```\\nfrom collections import defaultdict, Counter\\n\\nclass Solution:\\n    def idealArrays(self, n, maxValue):\\n        M = 10 ** 9 + 7\\n        f = [1] * (n + 1)\\n        fi = [1] * (n + 1)\\n        for i in range(2, n + 1):\\n            f[i] = i * f[i - 1]\\n            fi[i] = pow(i, M - 2, M) * fi[i - 1]\\n            f[i] %= M\\n            fi[i] %= M\\n        vals = defaultdict(Counter)\\n        for i in range(1, maxValue + 1):\\n            vals[1][i] += 1\\n        ctr = 2\\n        while ctr <= n:\\n            done = True\\n            for prev in vals[ctr - 1]:\\n                mul = 2\\n                while prev * mul <= maxValue:\\n                    vals[ctr][prev * mul] += vals[ctr - 1][prev]\\n                    mul += 1\\n                    done = False\\n            if done:\\n                break\\n            ctr += 1\\n        res = 0\\n        for i in range(1, ctr + 1):\\n            l = sum(vals[i].values())\\n            res += l * f[n - 1] * fi[i - 1] * fi[n - i]\\n            res %= M\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict, Counter\\n\\nclass Solution:\\n    def idealArrays(self, n, maxValue):\\n        M = 10 ** 9 + 7\\n        f = [1] * (n + 1)\\n        fi = [1] * (n + 1)\\n        for i in range(2, n + 1):\\n            f[i] = i * f[i - 1]\\n            fi[i] = pow(i, M - 2, M) * fi[i - 1]\\n            f[i] %= M\\n            fi[i] %= M\\n        vals = defaultdict(Counter)\\n        for i in range(1, maxValue + 1):\\n            vals[1][i] += 1\\n        ctr = 2\\n        while ctr <= n:\\n            done = True\\n            for prev in vals[ctr - 1]:\\n                mul = 2\\n                while prev * mul <= maxValue:\\n                    vals[ctr][prev * mul] += vals[ctr - 1][prev]\\n                    mul += 1\\n                    done = False\\n            if done:\\n                break\\n            ctr += 1\\n        res = 0\\n        for i in range(1, ctr + 1):\\n            l = sum(vals[i].values())\\n            res += l * f[n - 1] * fi[i - 1] * fi[n - i]\\n            res %= M\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642300,
                "title": "tweaked-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first intuition is instead of considering the array $$A$$ where $$A[i]$$ is divisible by $$A[i-1]$$, we consider the divisor array $$D$$ where $$A[i] = D[i]*A[i-1]$$ and $$D[0] = A[0]$$. This means $$A$$ is the prefix product array of $$D$$ and there exists a unique $$D$$ for each $$A$$.\\n\\nThe problem becomes count the number of distinct integer array $$D$$ of length $$n$$ where:\\n$$\\\\hspace{2.9cm}1 \\\\leq D[0]*D[1]*\\\\cdots*D[n-1] \\\\leq maxVal$$\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAn easy dp approach to count such sequence $$D$$ is to employ the following recursive function: \\n$$\\\\hspace{2cm}f(n,\\\\, maxVal) := \\\\sum_{i}f(n-1,\\\\, \\\\frac{maxVal}{i})$$\\n\\nThis hits TLE so I have to be more clever here. \\nMy second intuition is that most of the sequence would be filled with 1\\'s. The max number of $$D[i]$$ different from 1 would be $$\\\\lfloor\\\\textup{log}_{2}(maxVal)\\\\rfloor$$. So I **tweak** dp to count sequences $$D^*$$\\'s with length $$k \\\\leq \\\\lfloor\\\\textup{log}_{2}(maxVal)\\\\rfloor$$ such that $$D^{*}[i] \\\\geq 2$$. For the remaining $$n - k$$ 1\\'s, I distribute them into $$D^*$$ through the empty slots in between the elements of $$D^*$$.\\n$$\\\\hspace{4cm}..D^{*}[0]..D^{*}[1]..\\\\, ..\\\\, ..D^{*}[n-1]..$$\\nThere are in total $$k+1$$ such empty slots. The number of way to distribute $$n-k$$ 1\\'s in those slots is $$n\\\\choose k$$. The answer is:\\n$$\\\\hspace{3cm}\\\\sum_{k}{n\\\\choose k}f^{*}(k,\\\\, maxVal)$$ for $$1\\\\leq k \\\\leq \\\\lfloor\\\\textup{log}_{2}(maxVal)\\\\rfloor$$\\nWhere $$f^*$$ is the tweaked dp function described above.\\n# Complexity\\n- Time complexity: O(I don\\'t know LOL, pretty fast, beat 96%)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n# Code\\n```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        @lru_cache(None)\\n        def countWithout1s(n: int, maxVal: int):\\n            if n == 1:\\n                return maxVal-1\\n\\n            ans = 0\\n            for i in range(2, maxVal//2**(n-1)+1):\\n                ans += countWithout1s(n-1, maxVal//i)\\n            return ans\\n        \\n        MOD, comb, ans = 10**9+7, 1, 1\\n        for i in range(1, floor(log2(maxValue))+1):\\n            comb = comb * (n-i+1)//i # cumulative combination\\n            ans += comb * countWithout1s(i, maxValue)\\n\\n        return ans % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        @lru_cache(None)\\n        def countWithout1s(n: int, maxVal: int):\\n            if n == 1:\\n                return maxVal-1\\n\\n            ans = 0\\n            for i in range(2, maxVal//2**(n-1)+1):\\n                ans += countWithout1s(n-1, maxVal//i)\\n            return ans\\n        \\n        MOD, comb, ans = 10**9+7, 1, 1\\n        for i in range(1, floor(log2(maxValue))+1):\\n            comb = comb * (n-i+1)//i # cumulative combination\\n            ans += comb * countWithout1s(i, maxValue)\\n\\n        return ans % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550344,
                "title": "golang",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- Golang implementation of https://leetcode.com/problems/count-the-number-of-ideal-arrays/solutions/2262093/java-passed-understandable-solution-will-illustration-solving-strictly-increasing-case-first/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst mod = 1e9+7\\n\\nfunc idealArrays(n int, maxValue int) int { \\n    dp := make([][]int, 15)\\n    for i := range dp {\\n        dp[i] = make([]int, maxValue+1)\\n    }\\n    m := make(map[int][]int)\\n    for i := 1; i <= maxValue; i++ {\\n        j := i * 2\\n        for j <= maxValue {\\n            m[j] = append(m[j], i)\\n            j += i\\n        }\\n    }\\n\\n    for i := 1; i <= maxValue; i++ {\\n        dp[1][i] = 1\\n    }\\n    for i := 2; i <= n && i <= 14; i++ {\\n        for j := 1; j <= maxValue; j++ {\\n            for _, k := range m[j] {\\n                dp[i][j] = (dp[i][j] + dp[i-1][k]) % mod\\n            }\\n        }\\n    }\\n    for i := 1; i <= n && i <= 14; i++ {\\n        for j := 1; j <= maxValue; j++ {\\n            dp[i][0] = (dp[i][0] + dp[i][j]) % mod\\n        }\\n    }\\n\\n    memo := make([][]int, n+1)\\n    for i := range memo {\\n        memo[i] = make([]int, 15)\\n    }\\n    res := 0\\n    for i := 1; i <= n && i <= 14; i++ {\\n        res += nCk(n-1, i-1, memo) * dp[i][0]%mod\\n        res %= mod\\n    }\\n\\n    return res\\n}\\n\\nfunc nCk(n, k int, memo [][]int) int {\\n    if k == 0 {\\n        return 1\\n    }\\n    if n == 0 {\\n        return 0\\n    }\\n    if memo[n][k] != 0 {\\n        return memo[n][k]\\n    }\\n    memo[n][k] = nCk(n-1, k, memo) + nCk(n-1, k-1, memo)\\n    memo[n][k] %= mod\\n    return memo[n][k]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst mod = 1e9+7\\n\\nfunc idealArrays(n int, maxValue int) int { \\n    dp := make([][]int, 15)\\n    for i := range dp {\\n        dp[i] = make([]int, maxValue+1)\\n    }\\n    m := make(map[int][]int)\\n    for i := 1; i <= maxValue; i++ {\\n        j := i * 2\\n        for j <= maxValue {\\n            m[j] = append(m[j], i)\\n            j += i\\n        }\\n    }\\n\\n    for i := 1; i <= maxValue; i++ {\\n        dp[1][i] = 1\\n    }\\n    for i := 2; i <= n && i <= 14; i++ {\\n        for j := 1; j <= maxValue; j++ {\\n            for _, k := range m[j] {\\n                dp[i][j] = (dp[i][j] + dp[i-1][k]) % mod\\n            }\\n        }\\n    }\\n    for i := 1; i <= n && i <= 14; i++ {\\n        for j := 1; j <= maxValue; j++ {\\n            dp[i][0] = (dp[i][0] + dp[i][j]) % mod\\n        }\\n    }\\n\\n    memo := make([][]int, n+1)\\n    for i := range memo {\\n        memo[i] = make([]int, 15)\\n    }\\n    res := 0\\n    for i := 1; i <= n && i <= 14; i++ {\\n        res += nCk(n-1, i-1, memo) * dp[i][0]%mod\\n        res %= mod\\n    }\\n\\n    return res\\n}\\n\\nfunc nCk(n, k int, memo [][]int) int {\\n    if k == 0 {\\n        return 1\\n    }\\n    if n == 0 {\\n        return 0\\n    }\\n    if memo[n][k] != 0 {\\n        return memo[n][k]\\n    }\\n    memo[n][k] = nCk(n-1, k, memo) + nCk(n-1, k-1, memo)\\n    memo[n][k] %= mod\\n    return memo[n][k]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3419375,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def idealArrays(self, n, maxValue):\\n        ans = maxValue\\n        dict1 = {x:1 for x in range(1,maxValue+1)}\\n\\n        for k in range(1,n):\\n            temp = Counter()\\n            for x in dict1:\\n                for m in range(2,maxValue//x+1):\\n                    ans += comb(n-1,k)*dict1[x]\\n                    temp[m*x] += dict1[x]\\n            dict1 = temp\\n            ans = ans%(10**9+7)\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def idealArrays(self, n, maxValue):\\n        ans = maxValue\\n        dict1 = {x:1 for x in range(1,maxValue+1)}\\n\\n        for k in range(1,n):\\n            temp = Counter()\\n            for x in dict1:\\n                for m in range(2,maxValue//x+1):\\n                    ans += comb(n-1,k)*dict1[x]\\n                    temp[m*x] += dict1[x]\\n            dict1 = temp\\n            ans = ans%(10**9+7)\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368543,
                "title": "java-easy-solution-no-time-taken-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/b706f23e-352a-4f7f-9a10-d4813c09926c_1680408854.617423.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int M =(int)1e9+7;\\n    public int idealArrays(int n, int maxValue) {\\n        long ans = 0;\\n        int N = n+maxValue;\\n        long[] inv = new long[N];\\n        long[] fact = new long[N];\\n        long[] factinv = new long[N];\\n        inv[1]=fact[0]=fact[1]=factinv[0]=factinv[1]=1;\\n        for (int i = 2; i < N; i++){ // mod inverse\\n            inv[i]=M-M/i*inv[M%i]%M;\\n            fact[i]=fact[i-1]*i%M;\\n            factinv[i]=factinv[i-1]*inv[i]%M;\\n        }\\n        for (int i = 1; i <= maxValue; i++){\\n            int tmp = i;\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for (int j = 2; j*j<= tmp; j++){\\n                while(tmp%j==0){  // prime factorization.\\n                    tmp/=j;\\n                    map.merge(j, 1, Integer::sum);\\n                }\\n            }\\n            if (tmp>1){\\n                map.merge(tmp, 1, Integer::sum);\\n            }\\n            long gain=1;\\n            for (int val : map.values()){ // arranges all the primes.\\n                gain *= comb(n+val-1, val, fact, factinv);\\n                gain %= M;\\n            }\\n            ans += gain;\\n            ans %= M;\\n        }\\n\\n        return (int)ans;\\n    }\\n\\n    private long comb(int a, int b, long[] fact, long[] factinv){\\n        return fact[a]*factinv[b]%M*factinv[a-b]%M;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    int M =(int)1e9+7;\\n    public int idealArrays(int n, int maxValue) {\\n        long ans = 0;\\n        int N = n+maxValue;\\n        long[] inv = new long[N];\\n        long[] fact = new long[N];\\n        long[] factinv = new long[N];\\n        inv[1]=fact[0]=fact[1]=factinv[0]=factinv[1]=1;\\n        for (int i = 2; i < N; i++){ // mod inverse\\n            inv[i]=M-M/i*inv[M%i]%M;\\n            fact[i]=fact[i-1]*i%M;\\n            factinv[i]=factinv[i-1]*inv[i]%M;\\n        }\\n        for (int i = 1; i <= maxValue; i++){\\n            int tmp = i;\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for (int j = 2; j*j<= tmp; j++){\\n                while(tmp%j==0){  // prime factorization.\\n                    tmp/=j;\\n                    map.merge(j, 1, Integer::sum);\\n                }\\n            }\\n            if (tmp>1){\\n                map.merge(tmp, 1, Integer::sum);\\n            }\\n            long gain=1;\\n            for (int val : map.values()){ // arranges all the primes.\\n                gain *= comb(n+val-1, val, fact, factinv);\\n                gain %= M;\\n            }\\n            ans += gain;\\n            ans %= M;\\n        }\\n\\n        return (int)ans;\\n    }\\n\\n    private long comb(int a, int b, long[] fact, long[] factinv){\\n        return fact[a]*factinv[b]%M*factinv[a-b]%M;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359148,
                "title": "o-maxvalue-logmaxvalue-2-202-ms-with-explaination-dp-with-combinatorics",
                "content": "# Intuition\\n\\n# Approach\\n\\nlet\\'s first calculate maximum how many unique numbers there can be in a ideal array\\nsince maxValue <= 1e4 , [2^0,2^1,2^2,........,2^13] , so maximum length of a ideal array is 14 , \\n\\nlet\\'s say , we know a ideal array with last element x and no of unique elements uc , \\nthen lets consider the sequence of incresing unique elements of this ideal array with last element x\\n\\nthen no of different ideal array with last element x and no of unique elements boils down to solving this combinatorical problem \\n\\nx1+x2+x3+.. + xr = n , no of positive solutions of this equation is (n-1)C(r-1) -> (n-1)C(uc-1)\\n\\n\\nFor example , lets say last element = 6 \\nunique element 1 -> [6]\\nunique element 2 -> [1 6]\\nunique element 3 -> [1 2 6] [1 3 6] \\n\\nso , for any length n , we can expand unique length sequence and no of different ideal array would be from the above mentioned formula\\n\\n\\n\\nnow , we have to calculate dp[last][uc] -> no of sequence with last number last and count of unique elements uc such that each number divides its next number so,\\n\\ndp[i][1]=1 for all i\\n\\ndp[j][uc+1]+=dp[i][uc] , where j=2*i,3*i,... \\n\\nnow for each dp[last][uc] -> no of different ideal array would be \\ndp[last][uc]*(n-1)C(uc-1)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n    O(maxValue(log(maxValue)^2))\\n- Space complexity:\\n    O(maxValue(log(maxValue)))\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\n    long long power(long long a,long long b,long long mod)\\n    {\\n        long long result=1;\\n        while(b>0)\\n        {\\n            if(b%2==1)\\n            {\\n                result= (result*a)%mod;\\n            }\\n            a= (a*a)%mod;\\n            b=b/2;\\n        }\\n        return result;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        \\n        const int mod=1e9+7;\\n        const int N=max(n,maxValue);\\n        long long fact[N+1];\\n        long long invfact[N+1];\\n        fact[0]=1;\\n        invfact[0]=1;\\n        for(int i=1;i<=N;i++)\\n        {\\n            fact[i]=i*fact[i-1];\\n            fact[i]%=mod;\\n            invfact[i]=power(fact[i],mod-2,mod);\\n        }\\n        auto nCr=[&](int n,int r){\\n            if(r>n)\\n                return 0LL;\\n            long long ans=fact[n];\\n            ans*=invfact[n-r];\\n            ans%=mod;\\n            ans*=invfact[r];\\n            ans%=mod;\\n            return ans;\\n        };\\n        vector<vector<int>> dp(maxValue+1,vector<int>(15,0));\\n        for(int i=1;i<=maxValue;i++)\\n            dp[i][1]=1;\\n        for(int i=1;i<=maxValue;i++)\\n        {\\n            for(int len=1;len<14;len++)\\n            {\\n                for(int j=2*i;j<=maxValue;j+=i)\\n                {\\n                    dp[j][len+1]+=dp[i][len];\\n                }\\n            }\\n        }\\n\\n        long long ans=0;\\n        for(int last=1;last<=maxValue;last++)\\n        {\\n            for(int uc=1;uc<15;uc++)\\n            {\\n                long long k=nCr(n-1,uc-1);\\n                k*=dp[last][uc];\\n                k%=mod;\\n                ans+=k;\\n                if(ans>=mod)\\n                    ans-=mod;\\n            }\\n        }\\n         \\n        return ans;\\n\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    long long power(long long a,long long b,long long mod)\\n    {\\n        long long result=1;\\n        while(b>0)\\n        {\\n            if(b%2==1)\\n            {\\n                result= (result*a)%mod;\\n            }\\n            a= (a*a)%mod;\\n            b=b/2;\\n        }\\n        return result;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        \\n        const int mod=1e9+7;\\n        const int N=max(n,maxValue);\\n        long long fact[N+1];\\n        long long invfact[N+1];\\n        fact[0]=1;\\n        invfact[0]=1;\\n        for(int i=1;i<=N;i++)\\n        {\\n            fact[i]=i*fact[i-1];\\n            fact[i]%=mod;\\n            invfact[i]=power(fact[i],mod-2,mod);\\n        }\\n        auto nCr=[&](int n,int r){\\n            if(r>n)\\n                return 0LL;\\n            long long ans=fact[n];\\n            ans*=invfact[n-r];\\n            ans%=mod;\\n            ans*=invfact[r];\\n            ans%=mod;\\n            return ans;\\n        };\\n        vector<vector<int>> dp(maxValue+1,vector<int>(15,0));\\n        for(int i=1;i<=maxValue;i++)\\n            dp[i][1]=1;\\n        for(int i=1;i<=maxValue;i++)\\n        {\\n            for(int len=1;len<14;len++)\\n            {\\n                for(int j=2*i;j<=maxValue;j+=i)\\n                {\\n                    dp[j][len+1]+=dp[i][len];\\n                }\\n            }\\n        }\\n\\n        long long ans=0;\\n        for(int last=1;last<=maxValue;last++)\\n        {\\n            for(int uc=1;uc<15;uc++)\\n            {\\n                long long k=nCr(n-1,uc-1);\\n                k*=dp[last][uc];\\n                k%=mod;\\n                ans+=k;\\n                if(ans>=mod)\\n                    ans-=mod;\\n            }\\n        }\\n         \\n        return ans;\\n\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268313,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn ideal_arrays(n: i32, max_value: i32) -> i32 {\\n        use std::collections::HashMap;\\n        const MOD: i32 = 1_000_000_007;\\n\\n        fn add(a: i32, b: i32) -> i32 {\\n            let mut r = a + b;\\n            if r >= MOD {\\n                r -= MOD;\\n            }\\n            r\\n        }\\n\\n        fn mul(a: i32, b: i32) -> i32 {\\n            ((a as i64) * (b as i64) % (MOD as i64)) as i32\\n        }\\n\\n        fn edges(max_value: usize) -> (Vec<i32>, Vec<Vec<(i32, i32)>>) {\\n            let mut divisor = vec![1; max_value + 1];\\n            for i in 2..=max_value {\\n                if divisor[i] != 1 {\\n                    continue;\\n                }\\n                for j in (i..=max_value).step_by(i) {\\n                    divisor[j] = i;\\n                }\\n            }\\n            let mut states = HashMap::new();\\n            let mut state_id = vec![0; max_value + 1];\\n            for (i, state_id_i) in state_id.iter_mut().enumerate().take(max_value + 1).skip(1) {\\n                let mut state = Vec::new();\\n                let mut n = i;\\n                while n != 1 {\\n                    let p = divisor[n];\\n                    let mut d = 0;\\n                    while n % p == 0 {\\n                        d += 1;\\n                        n /= p;\\n                    }\\n                    state.push(d);\\n                }\\n                state.sort();\\n                let size = states.len() as i32;\\n                let id = *states.entry(state).or_insert(size);\\n                *state_id_i = id;\\n            }\\n            let mut some_val_for_state = vec![0; states.len()];\\n            for i in (1..=max_value).rev() {\\n                let s = state_id[i] as usize;\\n                some_val_for_state[s] = i;\\n            }\\n            let mut edges = vec![HashMap::new(); states.len()];\\n            for i in 1..=max_value {\\n                for j in (2 * i..=max_value).step_by(i) {\\n                    let s = state_id[j] as usize;\\n                    if j == some_val_for_state[s] {\\n                        *edges[s].entry(state_id[i]).or_insert(0) += 1;\\n                    }\\n                }\\n            }\\n            let edges = edges\\n                .into_iter()\\n                .map(|map| map.into_iter().collect::<Vec<_>>())\\n                .collect::<Vec<_>>();\\n            (state_id, edges)\\n        }\\n\\n        let max_value = max_value as usize;\\n        let (state_id, edges) = edges(max_value);\\n        let mut dp = vec![0; edges.len()];\\n        dp[0] = 1;\\n        for _ in 0..n {\\n            for i in (0..dp.len()).rev() {\\n                for &(to, cnt) in edges[i].iter() {\\n                    dp[i] = add(dp[i], mul(dp[to as usize], cnt));\\n                }\\n            }\\n        }\\n        let mut result = 0;\\n        for i in 1..=max_value {\\n            result = add(result, dp[state_id[i] as usize]);\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn ideal_arrays(n: i32, max_value: i32) -> i32 {\\n        use std::collections::HashMap;\\n        const MOD: i32 = 1_000_000_007;\\n\\n        fn add(a: i32, b: i32) -> i32 {\\n            let mut r = a + b;\\n            if r >= MOD {\\n                r -= MOD;\\n            }\\n            r\\n        }\\n\\n        fn mul(a: i32, b: i32) -> i32 {\\n            ((a as i64) * (b as i64) % (MOD as i64)) as i32\\n        }\\n\\n        fn edges(max_value: usize) -> (Vec<i32>, Vec<Vec<(i32, i32)>>) {\\n            let mut divisor = vec![1; max_value + 1];\\n            for i in 2..=max_value {\\n                if divisor[i] != 1 {\\n                    continue;\\n                }\\n                for j in (i..=max_value).step_by(i) {\\n                    divisor[j] = i;\\n                }\\n            }\\n            let mut states = HashMap::new();\\n            let mut state_id = vec![0; max_value + 1];\\n            for (i, state_id_i) in state_id.iter_mut().enumerate().take(max_value + 1).skip(1) {\\n                let mut state = Vec::new();\\n                let mut n = i;\\n                while n != 1 {\\n                    let p = divisor[n];\\n                    let mut d = 0;\\n                    while n % p == 0 {\\n                        d += 1;\\n                        n /= p;\\n                    }\\n                    state.push(d);\\n                }\\n                state.sort();\\n                let size = states.len() as i32;\\n                let id = *states.entry(state).or_insert(size);\\n                *state_id_i = id;\\n            }\\n            let mut some_val_for_state = vec![0; states.len()];\\n            for i in (1..=max_value).rev() {\\n                let s = state_id[i] as usize;\\n                some_val_for_state[s] = i;\\n            }\\n            let mut edges = vec![HashMap::new(); states.len()];\\n            for i in 1..=max_value {\\n                for j in (2 * i..=max_value).step_by(i) {\\n                    let s = state_id[j] as usize;\\n                    if j == some_val_for_state[s] {\\n                        *edges[s].entry(state_id[i]).or_insert(0) += 1;\\n                    }\\n                }\\n            }\\n            let edges = edges\\n                .into_iter()\\n                .map(|map| map.into_iter().collect::<Vec<_>>())\\n                .collect::<Vec<_>>();\\n            (state_id, edges)\\n        }\\n\\n        let max_value = max_value as usize;\\n        let (state_id, edges) = edges(max_value);\\n        let mut dp = vec![0; edges.len()];\\n        dp[0] = 1;\\n        for _ in 0..n {\\n            for i in (0..dp.len()).rev() {\\n                for &(to, cnt) in edges[i].iter() {\\n                    dp[i] = add(dp[i], mul(dp[to as usize], cnt));\\n                }\\n            }\\n        }\\n        let mut result = 0;\\n        for i in 1..=max_value {\\n            result = add(result, dp[state_id[i] as usize]);\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3226221,
                "title": "key-idea-fully-explained-python",
                "content": "**Approach 1: Prime Factorisation, Combinatorics**\\nHow to find the number of ideal arrays ending with integer `x`?\\nLet **prime factorisation** of `x = P1^f1 * P2^f2 * ... * Pm^fm`\\n\\nHow many ways to put M balls into N slots?\\nHow many ways to put f1 P1s into n slots?\\nThis can be found using https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics)\\nThere are `(n - 1 + f1 Choose f1)` ways to distribute all P1s into n slots.\\n\\n`ways(x,n) = (n - 1 + f1 C f1) * (n - 1 + f2 C f2) * ... * (n - 1 + fm C fm)`\\nWhere `ways(x,n) = no. of ideal arrays of size n, ending with x`\\n\\n**Time: O(n sqrt(n))\\nSpace: O(n log n)**\\n\\n```\\ndef idealArrays(self, n: int, maxValue: int) -> int:\\n    mod = 10**9 + 7\\n    \\n    @lru_cache(None)\\n    def getComb(k):\\n        return math.comb(n - 1 + k, k)\\n\\n    # prime factorisation O(n * sqrt(n))\\n    prime_exp = [[] for _ in range(maxValue + 1)]\\n    for i in range(2, maxValue + 1):\\n        v = i; pow_cnt = 0\\n        while i%2 == 0:\\n            i //= 2\\n            pow_cnt += 1\\n        if pow_cnt:\\n            prime_exp[v].append(pow_cnt)\\n            pow_cnt = 0\\n        \\n        for j in range(3, 1 + floor(sqrt(i)), 2):\\n            while i%j == 0:\\n                i //= j\\n                pow_cnt += 1\\n            if pow_cnt:\\n                prime_exp[v].append(pow_cnt)\\n                pow_cnt = 0\\n        \\n        if i > 2: #reamining factor is a prime\\n            prime_exp[v].append(1)\\n    \\n    #find number of ideal arrays ending with i for i in [1...maxVal]\\n    res = 0\\n    for i in range(1, maxValue + 1):\\n        mul = 1\\n        for exp in prime_exp[i]:\\n            mul = (mul * getComb(exp))%mod\\n        res = (res + mul)%mod\\n    \\n    return res\\n```\\n\\n**Approach 2: Dynamic Programming, Combinatorics**\\nRealise that `no of unique values in the sequence <= 1 + floor(log2(maxValue))`\\nSince `maxValue <= 10000`, then maximum 14 unique values.\\n\\nif we have `x` unique values, then there are `(n-1 Choose x-1)` ways of putting them in the array in increasing order.\\nFirst value in array is always the smallest unique value, so thats why u have `n-1 C x-1`.\\neg: `unique_vals = {1,2,4}, n = 4`, then there have 3 options:\\n`[1,1,2,4], [1,2,2,4], [1,2,4,4]`\\n\\nBut, how to find number of combinations of unique values?\\n`dp(i,k) = no. of combinations of unique vals starting with i, k unique vals`\\n`dp(i,k) = sum( dp(i*j,k-1) for j in [2...maxVal/i] )`\\n\\n**Time: O( log n * n * (1 + 1/2 + 1/3 + ... + 1/n) )\\nSpace: O(n log n)**\\n```\\ndef idealArrays(self, n: int, maxValue: int) -> int:\\n    @lru_cache(None)\\n    def getComb(k):\\n        return comb(n - 1, k - 1)\\n\\n    mx_unique = floor(log2(maxValue)) + 1\\n\\n    @lru_cache(None)\\n    def dp(i, uniqueChars):\\n        if uniqueChars == 1: return 1\\n        return sum([dp(i*j, uniqueChars - 1) for j in range(2, floor(maxValue/i) + 1)])\\n\\n    dp = [[0]*(mx_unique + 1) for _ in range(maxValue + 1)]\\n    for i in range(1, maxValue + 1):\\n        dp[i][1] = 1\\n        for j in range(2, floor(maxValue/i) + 1):\\n            for k in range(1, mx_unique + 1):\\n                dp[i*j][k] += dp[i][k-1]\\n\\n    res = 0\\n    for start in range(1, maxValue + 1):\\n        for uniqueVals in range(1, mx_unique + 1):\\n            if n >= uniqueVals:\\n                res += dp[start][uniqueVals] * getComb(uniqueVals)\\n    \\n    return res%(10**9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics",
                    "Number Theory"
                ],
                "code": "```\\ndef idealArrays(self, n: int, maxValue: int) -> int:\\n    mod = 10**9 + 7\\n    \\n    @lru_cache(None)\\n    def getComb(k):\\n        return math.comb(n - 1 + k, k)\\n\\n    # prime factorisation O(n * sqrt(n))\\n    prime_exp = [[] for _ in range(maxValue + 1)]\\n    for i in range(2, maxValue + 1):\\n        v = i; pow_cnt = 0\\n        while i%2 == 0:\\n            i //= 2\\n            pow_cnt += 1\\n        if pow_cnt:\\n            prime_exp[v].append(pow_cnt)\\n            pow_cnt = 0\\n        \\n        for j in range(3, 1 + floor(sqrt(i)), 2):\\n            while i%j == 0:\\n                i //= j\\n                pow_cnt += 1\\n            if pow_cnt:\\n                prime_exp[v].append(pow_cnt)\\n                pow_cnt = 0\\n        \\n        if i > 2: #reamining factor is a prime\\n            prime_exp[v].append(1)\\n    \\n    #find number of ideal arrays ending with i for i in [1...maxVal]\\n    res = 0\\n    for i in range(1, maxValue + 1):\\n        mul = 1\\n        for exp in prime_exp[i]:\\n            mul = (mul * getComb(exp))%mod\\n        res = (res + mul)%mod\\n    \\n    return res\\n```\n```\\ndef idealArrays(self, n: int, maxValue: int) -> int:\\n    @lru_cache(None)\\n    def getComb(k):\\n        return comb(n - 1, k - 1)\\n\\n    mx_unique = floor(log2(maxValue)) + 1\\n\\n    @lru_cache(None)\\n    def dp(i, uniqueChars):\\n        if uniqueChars == 1: return 1\\n        return sum([dp(i*j, uniqueChars - 1) for j in range(2, floor(maxValue/i) + 1)])\\n\\n    dp = [[0]*(mx_unique + 1) for _ in range(maxValue + 1)]\\n    for i in range(1, maxValue + 1):\\n        dp[i][1] = 1\\n        for j in range(2, floor(maxValue/i) + 1):\\n            for k in range(1, mx_unique + 1):\\n                dp[i*j][k] += dp[i][k-1]\\n\\n    res = 0\\n    for start in range(1, maxValue + 1):\\n        for uniqueVals in range(1, mx_unique + 1):\\n            if n >= uniqueVals:\\n                res += dp[start][uniqueVals] * getComb(uniqueVals)\\n    \\n    return res%(10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3124667,
                "title": "check-this-clean-solution",
                "content": "\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int idealArrays(int n, int maxValue) {\\n        int m = 1000000007;\\n        BigInteger res = BigInteger.ZERO;\\n        long[][] dp = new long[15][maxValue + 1]; \\n        Map<Integer, List<Integer>> map = buildMap(maxValue);\\n        \\n        // step 1: compute dp for the alternative problem (strictly increasing case)\\n        for (int i = 1; i <= maxValue; i++) {\\n            dp[1][i] = 1;\\n        }\\n        for (int i = 2; i <= n && i <= 14; i++) {\\n            for (int j = 1; j <= maxValue; j++) {\\n                for (int k : map.get(j)) {\\n                    dp[i][j] += dp[i - 1][k];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        }\\n        for (int i = 1; i <= n && i <= 14; i++) {\\n            for (int j = 1; j <= maxValue; j++) {\\n                dp[i][0] += dp[i][j];\\n                dp[i][0] %= m; // dp[i][0] = number of ideal arrays (strictly increasing case) of length i\\n            }\\n        }\\n        \\n        // step 2: use combinatorics to get the final answer for the actual problem from the alternative problem (strictly increasing case)\\n        for (int i = 1; i <= n && i <= 14; i++) {\\n            res = res.add(nCk(n - 1, i - 1).multiply(BigInteger.valueOf(dp[i][0])));\\n            res = res.mod(BigInteger.valueOf(m));\\n        }\\n        return res.intValue();\\n    }\\n    \\n    // helper function to compute \"n choose k\" \\n    private BigInteger nCk(int n, int k) {\\n        BigInteger res = BigInteger.ONE;\\n        for (int i = 1; i <=k; i++) {\\n            res = res.multiply(BigInteger.valueOf(n - (i - 1))).divide(BigInteger.valueOf(i));\\n        }\\n        return res;\\n    }\\n    \\n    // helper funciton to build map {Integer -> {its divisors}}\\n    private Map<Integer, List<Integer>> buildMap(int maxValue) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 1; i <= maxValue; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for (int i = 1; i <= maxValue; i++) {\\n            int j = i * 2; // strictly increasing\\n            while (j <= maxValue) {\\n                map.get(j).add(i);\\n                j += i;\\n            }\\n        }\\n        return map;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int idealArrays(int n, int maxValue) {\\n        int m = 1000000007;\\n        BigInteger res = BigInteger.ZERO;\\n        long[][] dp = new long[15][maxValue + 1]; \\n        Map<Integer, List<Integer>> map = buildMap(maxValue);\\n        \\n        // step 1: compute dp for the alternative problem (strictly increasing case)\\n        for (int i = 1; i <= maxValue; i++) {\\n            dp[1][i] = 1;\\n        }\\n        for (int i = 2; i <= n && i <= 14; i++) {\\n            for (int j = 1; j <= maxValue; j++) {\\n                for (int k : map.get(j)) {\\n                    dp[i][j] += dp[i - 1][k];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        }\\n        for (int i = 1; i <= n && i <= 14; i++) {\\n            for (int j = 1; j <= maxValue; j++) {\\n                dp[i][0] += dp[i][j];\\n                dp[i][0] %= m; // dp[i][0] = number of ideal arrays (strictly increasing case) of length i\\n            }\\n        }\\n        \\n        // step 2: use combinatorics to get the final answer for the actual problem from the alternative problem (strictly increasing case)\\n        for (int i = 1; i <= n && i <= 14; i++) {\\n            res = res.add(nCk(n - 1, i - 1).multiply(BigInteger.valueOf(dp[i][0])));\\n            res = res.mod(BigInteger.valueOf(m));\\n        }\\n        return res.intValue();\\n    }\\n    \\n    // helper function to compute \"n choose k\" \\n    private BigInteger nCk(int n, int k) {\\n        BigInteger res = BigInteger.ONE;\\n        for (int i = 1; i <=k; i++) {\\n            res = res.multiply(BigInteger.valueOf(n - (i - 1))).divide(BigInteger.valueOf(i));\\n        }\\n        return res;\\n    }\\n    \\n    // helper funciton to build map {Integer -> {its divisors}}\\n    private Map<Integer, List<Integer>> buildMap(int maxValue) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 1; i <= maxValue; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for (int i = 1; i <= maxValue; i++) {\\n            int j = i * 2; // strictly increasing\\n            while (j <= maxValue) {\\n                map.get(j).add(i);\\n                j += i;\\n            }\\n        }\\n        return map;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822273,
                "title": "python-o-max-nlogm-mlogm",
                "content": "First we do some preprocessing so that we can get the prime factors of any number in the range 1 .. 10^4 in log(n). The array sm holds the biggest prime factor of each number in the range. Now we can get prime factors by continuously dividing by the biggest prime:\\n\\nsm = [x,x,2,3,2,5,3] (for 1 .. 6 and I have set 0 and 1\\'s biggest prime to x)\\nthen if we want to factor 6:\\nsm[6] = 3 so we record 3\\nsm[6//3 = 2] = 2 so we record 2 \\n\\nWe will need O(log(n)) iterations to factor a number n (one iteration for each prime factor)\\n\\nNow observe that any valid array with n elements ending with a number x can be generated by the following process:\\nStart with an array of all 1\\'s. For each of x\\'s prime factors (including duplicates), choose some index i and multiply all elements of the array from i onward by the prime factor. \\nBy considering all possible i\\'s for all prime factors, we get every valid array ending with x.\\nThis is true because since each number is divisible by the previous one, as soon as a prime factor is introduced the first time it must be in all numbers afterwards. Since we want the array to end with x, we need to multiply in each of it\\'s prime factors at some point. \\n\\nHow many arrays are there ending with x? The answer is the product of the number of ways to choose the indices for each distinct prime factor. The number of ways to choose indices for a prime factor that appears k times in x is n + k - 1 choose k, the number of ways to choose k elements from n elements with replacement.\\n\\n```\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        sm = [maxValue+1 for i in range(maxValue+1)]\\n        for i in range(2,maxValue+1):\\n            if sm[i] == maxValue+1:\\n                sm[i::i] = [i]*(maxValue//i)\\n        \\n        MOD = int(1e9) + 7\\n        nck = [[0 for _ in range(int(log(maxValue, 2) + 1))] for _ in range(n+int(log(maxValue, 2)))]\\n        nck[0][0] = 1\\n        for i in range(1,len(nck)):\\n            for j in range(len(nck[0])):\\n                if j == 0: nck[i][j] = 1\\n                else: nck[i][j] = (nck[i-1][j] + nck[i-1][j-1])%MOD\\n        \\n        ret = 0\\n        for i in range(2,maxValue+1):\\n            facs = defaultdict(int)\\n            while i > 1:\\n                facs[sm[i]] += 1\\n                i //= sm[i]\\n            ret += reduce(lambda x,y: (x*nck[n+y-1][y])%MOD, facs.values(), 1)\\n            if ret > MOD: ret -= MOD\\n        return (ret + 1)%MOD\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        sm = [maxValue+1 for i in range(maxValue+1)]\\n        for i in range(2,maxValue+1):\\n            if sm[i] == maxValue+1:\\n                sm[i::i] = [i]*(maxValue//i)\\n        \\n        MOD = int(1e9) + 7\\n        nck = [[0 for _ in range(int(log(maxValue, 2) + 1))] for _ in range(n+int(log(maxValue, 2)))]\\n        nck[0][0] = 1\\n        for i in range(1,len(nck)):\\n            for j in range(len(nck[0])):\\n                if j == 0: nck[i][j] = 1\\n                else: nck[i][j] = (nck[i-1][j] + nck[i-1][j-1])%MOD\\n        \\n        ret = 0\\n        for i in range(2,maxValue+1):\\n            facs = defaultdict(int)\\n            while i > 1:\\n                facs[sm[i]] += 1\\n                i //= sm[i]\\n            ret += reduce(lambda x,y: (x*nck[n+y-1][y])%MOD, facs.values(), 1)\\n            if ret > MOD: ret -= MOD\\n        return (ret + 1)%MOD\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2750514,
                "title": "c-combinator-with-dp-comments",
                "content": "**Assume:**\\n\\n**[#, x1, #, #, #, x2, #, #, #, #]  with {x1, x2, x3, ...} as number and  \"#\" as blank**\\n\\n* Then the result should be [#, x1, x1, x1, x1, x2, x2, x2, x2, x2]\\n* \"#\" will try to copy the number from its left\\n* x(i) will be divisible by x(i -1)\\n* The result considers valid when there is no remaining blank \"#\"\\n\\n**[#, #, $, #, #, #, $, #, #, #] with \"#\" as blank, \"$\" as chosen blank, the size n = 10, number of chosen blank r = 2.**\\n* When we choose r/n (2/10) random # to become $, there will be C(10, 2) = 45 ways to do so, where C is combinatorics\\n* To make the result become valid, one \"$\" must be on the first position. After that, we only have remaining r = 1 and remaining n = 9.\\n* Then there will be C(9, 1) = 9 possible valid results\\n\\n**x(r) = {x1, x2, x3, ..., xr} and the problem gives limit maxValue = 10000**\\n* where r is number of chosen blank\\n* x(i) > x(i -1) and x(i) % x(i - 1) == 0\\n* We start at x1 = 1, x2 = 2, x3 = 4, x4 = 8, ..., x14 = 8192, x15 = 16384. It clearly that x15 is over the given limit so maximum number of chosen blank \"$\" should be less than 15. With r < 15, we will no longer meet TLE or MLE\\n\\n**Example:**\\n* n = 5\\n* maxValue = 3\\n\\nWith n = 5, r = 1 and x(r) = {1}. After put one $ on the first position then remaining n = 4, r = 0. Then we will have C(4, 0) = 1 possible valid result:\\n1. [$, #, #, #, #]\\n2. [1, #, #, #, #]\\n3. [1, 1, 1, 1, 1]\\n\\nThe same operation for:\\n* n = 5, r = 1 and x(r) = {2} \\n* n = 5, r = 1 and x(r) = {3}\\n\\nWith n = 5, r = 2 and x(r) = {1, 2}. After put one $ on the first position then remaining n = 4, r = 1. Then we will have C(4, 1) = 4 possible valid result:\\n1. [$, $, #, #, #]   [$, #, $, #, #]   [$, #, #, $, #]  [$, #, #, #, $]\\n2. [1, 2, #, #, #]   [1, #, 2, #, #]   [1, #, #, 2, #]  [1, #, #, #, 2]\\n3. [1, 1, 1, 1, 1]   [1, 1, 2, 2, 2]   [1, 1, 1, 2, 2]  [1, 1, 1, 1, 2]\\n \\nThe same operation for:\\n* n = 5, r = 2 and x(r) = {1, 3}\\n\\n==> There will be 3 * 1 + 2 * 4 = 11 possible results\\n\\n**What if:**\\nWith n = 5, r = 3 and x(r) = {1, 4, 8}. After put one $ on the first position then remaining n = 4, r = 2. Then we will have C(4, 2) = 6 possible valid result:\\n1. [$, $, $, #, #]   [$, $, #, $, #]   [$, $, #, #, $]  [$, #, $, $, #]    [$, #, $, #, $]   [$, #, #, $, $]\\n2. [1, 4, 8, #, #]   [1, 4, #, 8, #]   [1, 4, #, #, 8]  [1, #, 4, 8, #]    [1, #, 4, #, 8]   [1, #, #, 4, 8]\\n3. [1, 4, 8, 8, 8]   [1, 4, 4, 8, 8]   [1, 4, 4, 4, 8]  [1, 1, 4, 8, 8]    [1, 1, 4, 4, 8]   [1, 1, 1, 4, 8]\\n```\\n#define MaximumSpaceLimit 15\\n\\nclass Solution {\\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        int res = 0;\\n        int mod = 1e9 + 7;\\n        vector<vector<int>> C(n); \\n        vector<vector<int>> dp(maxValue + 1, vector<int>(MaximumSpaceLimit, 0));\\n        \\n        // Build a pascal tree to calculate combinator\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j <= i && j < MaximumSpaceLimit; j++)\\n                if(j == 0 || j == i) C[i].push_back(1);\\n                else C[i].push_back((C[i - 1][j] + C[i - 1][j - 1]) % mod);\\n        \\n        function<int(int, int)> dfs = [&](int curVal, int amount) {\\n            if(dp[curVal][amount]) return dp[curVal][amount];\\n            \\n            for(int nextVal = curVal ? curVal + curVal : 1; nextVal <= maxValue; nextVal += curVal ? curVal : 1) {\\n                dp[curVal][amount] += C[n - 1][amount];\\n                dp[curVal][amount] %= mod;\\n                \\n                if(amount < n - 1 && amount < MaximumSpaceLimit) {\\n                    dp[curVal][amount] += dfs(nextVal, amount + 1);\\n                    dp[curVal][amount] %= mod;\\n                }\\n            }\\n            \\n            return dp[curVal][amount];\\n        };\\n        \\n        return dfs(0, 0);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        int res = 0;\\n        int mod = 1e9 + 7;\\n        vector<vector<int>> C(n); \\n        vector<vector<int>> dp(maxValue + 1, vector<int>(MaximumSpaceLimit, 0));\\n        \\n        // Build a pascal tree to calculate combinator\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j <= i && j < MaximumSpaceLimit; j++)\\n                if(j == 0 || j == i) C[i].push_back(1);\\n                else C[i].push_back((C[i - 1][j] + C[i - 1][j - 1]) % mod);\\n        \\n        function<int(int, int)> dfs = [&](int curVal, int amount) {\\n            if(dp[curVal][amount]) return dp[curVal][amount];\\n            \\n            for(int nextVal = curVal ? curVal + curVal : 1; nextVal <= maxValue; nextVal += curVal ? curVal : 1) {\\n                dp[curVal][amount] += C[n - 1][amount];\\n                dp[curVal][amount] %= mod;\\n                \\n                if(amount < n - 1 && amount < MaximumSpaceLimit) {\\n                    dp[curVal][amount] += dfs(nextVal, amount + 1);\\n                    dp[curVal][amount] %= mod;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2729763,
                "title": "java-prime-factor-count-combinatorics-no-modular-inverse-o-log-maxvalue-memory",
                "content": "```\\nclass Solution {\\n    long mod = 1000000007;\\n    public int idealArrays(int n, int maxValue) {\\n//        n = 5; maxValue = 3;\\n        long resp = 0;\\n        // precalculate binomial coeff (n,k) up to k = 13\\n        // 13 is the maximum count of a prime factor for any number up to 10000 (below 2^14 to be exact)\\n        long[] binom = binom(n,13); \\n        for (int i = 1; i <= maxValue; i++) {\\n            // calculate ideal arrays of length n with the last item = i\\n            long contr = 1;\\n            int num = i;\\n            for (int d = 2; d*d <= num; d++) {\\n                // calculate multiplicity (count) of d in prime factorization of i\\n                int count = 0;\\n                while (num % d == 0) {\\n                    count++;\\n                    num /= d;\\n                }\\n                contr = (contr * binom[count]) % mod;\\n                // prime factor d must kick in total of count times along n places available in the ideal array, hence binomial coeff\\n                // each prime factor is independent of the others, hence multiplication\\n            }\\n            if (num != 1) contr = (contr * binom[1]) % mod; // need to take into account the last prime factor, if present\\n            resp = (resp + contr) % mod; \\n        }\\n        return (int)resp;\\n    }\\n    private long[] binom(int n, int m) {\\n        // calculate binom coeff up to m avoiding divisions, hence no modular inverse needed\\n        long[] resp = new long[m+1];\\n        resp[0] = 1;\\n        long factorial = 1;\\n        for (int i = 2; i <= m; i++) // max denominator is m!\\n            factorial *= i;\\n        long numer = 1; // factor removed from numerator\\n        long denom = 1; // factor required for current denominator\\n        long curr = 1;\\n        for (int i = 1; i <= m; i++) {\\n            long mult = n + i - 1; // current multiplier\\n            denom *= i;\\n            for (int d = 2; d <= m; d++) { // reduce multiplier against maximum denominator\\n                while (mult % d == 0 && factorial % d == 0) {\\n                    factorial /= d;\\n                    mult /= d;\\n                    numer *= d; // keep track what has been simplified from the numerator\\n                }\\n            }\\n            curr = (curr * mult) % mod; // running numerator\\n            resp[i] = (curr * (numer / denom)) % mod; // apply the remaining numerator and denominator (numer % denom == 0) \\n        }\\n        return resp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    long mod = 1000000007;\\n    public int idealArrays(int n, int maxValue) {\\n//        n = 5; maxValue = 3;\\n        long resp = 0;\\n        // precalculate binomial coeff (n,k) up to k = 13\\n        // 13 is the maximum count of a prime factor for any number up to 10000 (below 2^14 to be exact)\\n        long[] binom = binom(n,13); \\n        for (int i = 1; i <= maxValue; i++) {\\n            // calculate ideal arrays of length n with the last item = i\\n            long contr = 1;\\n            int num = i;\\n            for (int d = 2; d*d <= num; d++) {\\n                // calculate multiplicity (count) of d in prime factorization of i\\n                int count = 0;\\n                while (num % d == 0) {\\n                    count++;\\n                    num /= d;\\n                }\\n                contr = (contr * binom[count]) % mod;\\n                // prime factor d must kick in total of count times along n places available in the ideal array, hence binomial coeff\\n                // each prime factor is independent of the others, hence multiplication\\n            }\\n            if (num != 1) contr = (contr * binom[1]) % mod; // need to take into account the last prime factor, if present\\n            resp = (resp + contr) % mod; \\n        }\\n        return (int)resp;\\n    }\\n    private long[] binom(int n, int m) {\\n        // calculate binom coeff up to m avoiding divisions, hence no modular inverse needed\\n        long[] resp = new long[m+1];\\n        resp[0] = 1;\\n        long factorial = 1;\\n        for (int i = 2; i <= m; i++) // max denominator is m!\\n            factorial *= i;\\n        long numer = 1; // factor removed from numerator\\n        long denom = 1; // factor required for current denominator\\n        long curr = 1;\\n        for (int i = 1; i <= m; i++) {\\n            long mult = n + i - 1; // current multiplier\\n            denom *= i;\\n            for (int d = 2; d <= m; d++) { // reduce multiplier against maximum denominator\\n                while (mult % d == 0 && factorial % d == 0) {\\n                    factorial /= d;\\n                    mult /= d;\\n                    numer *= d; // keep track what has been simplified from the numerator\\n                }\\n            }\\n            curr = (curr * mult) % mod; // running numerator\\n            resp[i] = (curr * (numer / denom)) % mod; // apply the remaining numerator and denominator (numer % denom == 0) \\n        }\\n        return resp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719192,
                "title": "java-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTry To Calculate the array with without repetation and use permuataion after every calculation.\\n\\n# Complexity\\n- Time complexity:\\nO(14*maxValue)\\n\\n- Space complexity:\\nO(15*maxValue)\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    static long mod;\\n    static long[][] dp;\\n    static long[][] ncrDp;\\n\\n    long nCr(int n, int k)\\n    {\\n\\n        // Base Cases\\n        if (k > n)\\n            return 0;\\n        if (k == 0 || k == n)\\n            return 1;\\n\\n        if(ncrDp[n][k]!=0){\\n            return ncrDp[n][k];\\n        }\\n\\n        return ncrDp[n][k]=(nCr(n - 1, k - 1)%mod\\n                + nCr(n - 1, k)%mod)%mod;\\n    }\\n\\n\\n\\n\\n    public int idealArrays(int n, int maxVal) {\\n\\n        long sum = 0;\\n\\n        mod = 1000000007;\\n        ncrDp = new long[n+1][16];\\n        dp = new long[maxVal+1][15];\\n\\n        for (int i = 0; i <=maxVal; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        for (int i = 1; i <= maxVal; i++) {\\n            long a = solve(i, n, maxVal, 1);\\n            sum  = (sum+a)%mod;\\n        }\\n\\n        return (int) sum;\\n\\n    }\\n\\n    public long solve(int i, int n, int maxVal, int ind) {\\n\\n\\n        if (ind == n) {\\n            return 1;\\n        }\\n\\n        if (dp[i][ind] != -1) {\\n            return dp[i][ind];\\n        }\\n\\n\\n        long sum = 0;\\n        for (int j = 2; j*i <= maxVal; j++) {\\n            sum = (sum + solve(j * i, n, maxVal, ind + 1)%mod) % mod;\\n        }\\n        sum = (sum + nCr(n - 1, ind - 1)%mod)%mod;\\n\\n        return dp[i][ind] = sum;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    static long mod;\\n    static long[][] dp;\\n    static long[][] ncrDp;\\n\\n    long nCr(int n, int k)\\n    {\\n\\n        // Base Cases\\n        if (k > n)\\n            return 0;\\n        if (k == 0 || k == n)\\n            return 1;\\n\\n        if(ncrDp[n][k]!=0){\\n            return ncrDp[n][k];\\n        }\\n\\n        return ncrDp[n][k]=(nCr(n - 1, k - 1)%mod\\n                + nCr(n - 1, k)%mod)%mod;\\n    }\\n\\n\\n\\n\\n    public int idealArrays(int n, int maxVal) {\\n\\n        long sum = 0;\\n\\n        mod = 1000000007;\\n        ncrDp = new long[n+1][16];\\n        dp = new long[maxVal+1][15];\\n\\n        for (int i = 0; i <=maxVal; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        for (int i = 1; i <= maxVal; i++) {\\n            long a = solve(i, n, maxVal, 1);\\n            sum  = (sum+a)%mod;\\n        }\\n\\n        return (int) sum;\\n\\n    }\\n\\n    public long solve(int i, int n, int maxVal, int ind) {\\n\\n\\n        if (ind == n) {\\n            return 1;\\n        }\\n\\n        if (dp[i][ind] != -1) {\\n            return dp[i][ind];\\n        }\\n\\n\\n        long sum = 0;\\n        for (int j = 2; j*i <= maxVal; j++) {\\n            sum = (sum + solve(j * i, n, maxVal, ind + 1)%mod) % mod;\\n        }\\n        sum = (sum + nCr(n - 1, ind - 1)%mod)%mod;\\n\\n        return dp[i][ind] = sum;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687045,
                "title": "stars-bars",
                "content": "#define ll long long\\nll mod=1000000007;\\nclass Solution\\n{\\n    vector<vector<ll>> factor;\\n    vector<ll> fact, infact;\\npublic:\\n    int idealArrays(int n, int mx)\\n    {\\n        vector<vector<ll>> dp( 20, vector<ll>  (mx+10 ) );\\n        calc();\\n        \\n        for(int i=1; i<=min(n, 15) ; i++ )\\n        {\\n            for(int j=1;j<=mx;j++)   \\n            {\\n                if(i==1)\\n                {\\n                    dp[i][j]=1;\\n                    continue;\\n                }\\n                for(ll x: factor[j])\\n                {\\n                    dp[i][j]=( dp[i][j]+dp[i-1][x] )%mod;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<= min( 15, n ); i++ )\\n        {\\n            for(int j=1;j<=mx;j++)\\n            {\\n                dp[i][0]=( dp[i][0] + dp[i][j] )%mod;\\n            }\\n        }\\n        \\n        ll ans=0;\\n        for(int i=1;i<= min( 15, n ); i++ )\\n        {\\n            ans = ( ans+ (dp[i][0]* nCr( n-1, i-1 ) )%mod ) %mod;\\n        }\\n        \\n        return (int) ans;\\n    }\\n    \\n    ll nCr( ll n, ll r )\\n    {\\n        ll res=( fact[n]*infact[r] )%mod;\\n        res=( res*infact[n-r] )%mod;\\n        return res;\\n    }\\n    \\n    void calc()\\n    {\\n        factor= vector<vector<ll>> ( 10009 );\\n        for(ll i=1;i<10000;i++)\\n        {\\n            for(ll j=i*2;j<=10000;j+=i)\\n            {\\n                factor[j].push_back(i);\\n            }\\n        }\\n        \\n        fact=vector<ll> (10009);\\n        infact=vector<ll> (10009);\\n        fact[0]=infact[0]=1;\\n        for(ll i=1;i<=10000;i++) fact[i]=(fact[i-1]*i)%mod;\\n        infact[10000]=powmod( fact[10000], mod-2 );\\n        for(ll i=9999;i>0;i--) infact[i]=( infact[i+1]*(i+1) )%mod;\\n        \\n    }\\n    \\n    ll powmod( ll a, ll b )\\n    {\\n        ll res=1;\\n        while(b)\\n        {\\n            if( b&1) res=(res*a)%mod;\\n            b=b>>1;\\n            a=(a*a)%mod;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "class Solution\\n{\\n    vector<vector<ll>> factor;\\n    vector<ll> fact, infact;\\npublic:\\n    int idealArrays(int n, int mx)\\n    {\\n        vector<vector<ll>> dp( 20, vector<ll>  (mx+10 ) );\\n        calc();\\n        \\n        for(int i=1; i<=min(n, 15) ; i++ )\\n        {\\n            for(int j=1;j<=mx;j++)   \\n            {\\n                if(i==1)\\n                {\\n                    dp[i][j]=1;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2641693,
                "title": "c-combinatorics",
                "content": "```\\nclass Solution {\\npublic:\\n    int mm[10001][16];\\n    long func(long x,long m,long maxValue, long mod){\\n        if(m==1){\\n            mm[x][m] = 1;\\n            return 1;\\n        }\\n        if(mm[x][m])\\n            return mm[x][m];\\n        long res = 0;\\n        for(int i=2;i<=(maxValue/x);i++){\\n            if(x*i <= maxValue)\\n                res = (res + func(x*i,m-1,maxValue,mod))%mod;\\n            else\\n                break;\\n        }\\n        mm[x][m]=res;\\n        return res;\\n    }\\n    long exp(long x,long a,long mod){\\n        if(a==0)\\n            return 1;\\n        long temp = exp(x,a/2,mod);\\n        temp = (temp*temp)%mod;\\n        if(a%2)\\n            temp = (temp*x)%mod;\\n        return temp;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        vector<long> c(maxValue+1);\\n        memset(mm,0,sizeof(mm));\\n        long mod = 1e9 + 7;\\n        c[0]=1;\\n        for(long i=1;i<=min((long)(n-1),(long)maxValue);i++){\\n            c[i] = (((c[i-1]*(n-i))%mod)*exp(i,mod-2,mod))%mod;\\n        }\\n        long ans=0;\\n        for(long i=1;i<=maxValue;i++){\\n            for(int j=1;j<=min(15,n);j++){\\n                long r = func(i,j,maxValue,mod);\\n                if(r == 0)\\n                    break;\\n                ans = (ans + (r*c[j-1])%mod)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mm[10001][16];\\n    long func(long x,long m,long maxValue, long mod){\\n        if(m==1){\\n            mm[x][m] = 1;\\n            return 1;\\n        }\\n        if(mm[x][m])\\n            return mm[x][m];\\n        long res = 0;\\n        for(int i=2;i<=(maxValue/x);i++){\\n            if(x*i <= maxValue)\\n                res = (res + func(x*i,m-1,maxValue,mod))%mod;\\n            else\\n                break;\\n        }\\n        mm[x][m]=res;\\n        return res;\\n    }\\n    long exp(long x,long a,long mod){\\n        if(a==0)\\n            return 1;\\n        long temp = exp(x,a/2,mod);\\n        temp = (temp*temp)%mod;\\n        if(a%2)\\n            temp = (temp*x)%mod;\\n        return temp;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        vector<long> c(maxValue+1);\\n        memset(mm,0,sizeof(mm));\\n        long mod = 1e9 + 7;\\n        c[0]=1;\\n        for(long i=1;i<=min((long)(n-1),(long)maxValue);i++){\\n            c[i] = (((c[i-1]*(n-i))%mod)*exp(i,mod-2,mod))%mod;\\n        }\\n        long ans=0;\\n        for(long i=1;i<=maxValue;i++){\\n            for(int j=1;j<=min(15,n);j++){\\n                long r = func(i,j,maxValue,mod);\\n                if(r == 0)\\n                    break;\\n                ans = (ans + (r*c[j-1])%mod)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626350,
                "title": "why-am-i-geetting-tle",
                "content": "```\\nclass Solution {\\n    int mod=1e9+7;\\n    int rec(int i,int n,int maxv,int ind,vector<vector<int>> &dp){\\n        if(ind>=n) return 1;\\n        if(dp[ind][i]!=-1) return dp[ind][i];\\n        long long temp=0;\\n        for(int j=1;j*i<=maxv;j++){\\n            temp=(temp+rec(i*j,n,maxv,ind+1,dp))%mod;            \\n        }\\n        return dp[ind][i]=temp;\\n    }\\npublic:\\n    int idealArrays(int n, int maxv) {\\n        vector<vector<int>> dp(n+1,vector<int>(maxv+1,-1));\\n        return rec(1,n,maxv,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1e9+7;\\n    int rec(int i,int n,int maxv,int ind,vector<vector<int>> &dp){\\n        if(ind>=n) return 1;\\n        if(dp[ind][i]!=-1) return dp[ind][i];\\n        long long temp=0;\\n        for(int j=1;j*i<=maxv;j++){\\n            temp=(temp+rec(i*j,n,maxv,ind+1,dp))%mod;            \\n        }\\n        return dp[ind][i]=temp;\\n    }\\npublic:\\n    int idealArrays(int n, int maxv) {\\n        vector<vector<int>> dp(n+1,vector<int>(maxv+1,-1));\\n        return rec(1,n,maxv,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626099,
                "title": "rust-solution",
                "content": "```\\n\\n//https://leetcode.com/problems/count-the-number-of-ideal-arrays/\\n\\n\\nmod m {\\n    pub const M : i64 = 1_000_000_007;\\n    pub fn factor(n:i32) -> Vec<(i32,i32)> {\\n        let mut factors = Vec::new();\\n        let sq= f64::sqrt(n as f64) as i32;\\n        let mut r = n;\\n\\n        for p in 2..=(sq+1) {\\n            let mut cnt=0;\\n            while r % p == 0 {\\n                cnt+=1;\\n                r/=p;\\n            }\\n            if(cnt > 0) {\\n                factors.push((p,cnt));\\n            }\\n        }\\n        if(r > 1) {\\n            factors.push((r,1))\\n        }\\n        factors\\n    }\\n    pub         fn nchoosek(n:i32,k:i32) -> i64 {\\n        fn gcd_extended(a:i64,b:i64) -> (i64,i64,i64) {\\n            if(a==0) {\\n                return (b,0,1);\\n            }\\n            let r = gcd_extended(b%a, a);\\n\\n            return (r.0,r.2 - (b/a)*r.1,r.1);\\n        }\\n        \\n        let mut ret :i64 = 1;\\n        let mut div :i64 = 1;\\n        let o=n%k;\\n        for i in 1..=k {\\n            ret*=(n-i+1) as i64;\\n            div*=i as i64;\\n            if ret >= M {\\n                ret %=M;\\n            }\\n            if div >= M {\\n                div %=M;\\n            }\\n        }\\n        \\n        ret*=(gcd_extended(div,M).1 + M)%M;\\n        ret+=M;\\n        ret % M\\n    }\\n\\n}\\n\\nuse self::m::*;\\n#[allow(unused)]\\nimpl Solution {\\n    pub fn ideal_arrays(n: i32, max_value: i32) -> i32 {\\n \\n        let mut ret : i64=1;\\n\\n        for a in 2..=max_value {\\n            \\n            let mut t=1;\\n            for (_,k) in factor(a) {\\n                t*=nchoosek(n+k-1, k);\\n                t+=M;\\n                t%=M;\\n            }\\n//            println!(\"{} : {}\",a,t);\\n            ret+=t;\\n            ret%=M;\\n        }\\n  //      println!(\"{} {} => {}\",n,max_value,ret);\\n\\n\\n        ret as i32\\n    }\\n}\\nstruct Solution { }\\n\\n#[cfg(test)]\\nmod tests {\\n    // Note this useful idiom: importing names from outer (for mod tests) scope.\\n    use super::*;\\n\\n    #[test]\\n    fn test135() {\\n        assert_eq!(Solution::ideal_arrays(2,5), 10);\\n    }\\n\\n    #[test]\\n    fn test1315() {\\n        assert_eq!(Solution::ideal_arrays(5,3), 11);\\n    }\\n    #[test]\\n    fn test13115() {\\n        assert_eq!(Solution::ideal_arrays(184,389), 510488787\\n    );\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\n//https://leetcode.com/problems/count-the-number-of-ideal-arrays/\\n\\n\\nmod m {\\n    pub const M : i64 = 1_000_000_007;\\n    pub fn factor(n:i32) -> Vec<(i32,i32)> {\\n        let mut factors = Vec::new();\\n        let sq= f64::sqrt(n as f64) as i32;\\n        let mut r = n;\\n\\n        for p in 2..=(sq+1) {\\n            let mut cnt=0;\\n            while r % p == 0 {\\n                cnt+=1;\\n                r/=p;\\n            }\\n            if(cnt > 0) {\\n                factors.push((p,cnt));\\n            }\\n        }\\n        if(r > 1) {\\n            factors.push((r,1))\\n        }\\n        factors\\n    }\\n    pub         fn nchoosek(n:i32,k:i32) -> i64 {\\n        fn gcd_extended(a:i64,b:i64) -> (i64,i64,i64) {\\n            if(a==0) {\\n                return (b,0,1);\\n            }\\n            let r = gcd_extended(b%a, a);\\n\\n            return (r.0,r.2 - (b/a)*r.1,r.1);\\n        }\\n        \\n        let mut ret :i64 = 1;\\n        let mut div :i64 = 1;\\n        let o=n%k;\\n        for i in 1..=k {\\n            ret*=(n-i+1) as i64;\\n            div*=i as i64;\\n            if ret >= M {\\n                ret %=M;\\n            }\\n            if div >= M {\\n                div %=M;\\n            }\\n        }\\n        \\n        ret*=(gcd_extended(div,M).1 + M)%M;\\n        ret+=M;\\n        ret % M\\n    }\\n\\n}\\n\\nuse self::m::*;\\n#[allow(unused)]\\nimpl Solution {\\n    pub fn ideal_arrays(n: i32, max_value: i32) -> i32 {\\n \\n        let mut ret : i64=1;\\n\\n        for a in 2..=max_value {\\n            \\n            let mut t=1;\\n            for (_,k) in factor(a) {\\n                t*=nchoosek(n+k-1, k);\\n                t+=M;\\n                t%=M;\\n            }\\n//            println!(\"{} : {}\",a,t);\\n            ret+=t;\\n            ret%=M;\\n        }\\n  //      println!(\"{} {} => {}\",n,max_value,ret);\\n\\n\\n        ret as i32\\n    }\\n}\\nstruct Solution { }\\n\\n#[cfg(test)]\\nmod tests {\\n    // Note this useful idiom: importing names from outer (for mod tests) scope.\\n    use super::*;\\n\\n    #[test]\\n    fn test135() {\\n        assert_eq!(Solution::ideal_arrays(2,5), 10);\\n    }\\n\\n    #[test]\\n    fn test1315() {\\n        assert_eq!(Solution::ideal_arrays(5,3), 11);\\n    }\\n    #[test]\\n    fn test13115() {\\n        assert_eq!(Solution::ideal_arrays(184,389), 510488787\\n    );\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2462204,
                "title": "python3-details-guide-and-math",
                "content": "![image](https://assets.leetcode.com/users/images/2f457fd6-24b3-4bfa-8158-13492dd97b60_1661148982.8231964.png)\\n\\n\\n\\n\\n---\\n\\n## Code\\n---\\n\\n```python\\nclass Solution:\\n    def idealArrays(self, m: int, n: int) -> int:\\n        def dec(num):\\n            i = 2\\n            ct = Counter()\\n            while i <= num//i:\\n                if num % i == 0:\\n                    j = 0\\n                    while num % i == 0:\\n                        num //= i\\n                        j += 1\\n                    ct[i] = j\\n                i += 1\\n            if num!=1:\\n                ct[num] += 1\\n            return ct\\n        mod = 10**9 + 7\\n        res = 1\\n        for i in range(2,n+1):\\n            ctr = dec(i)\\n            p = 1\\n            for key in ctr:\\n                ct = ctr[key]\\n                p = (p * comb(m+ct-1, m-1)) % mod\\n            res = (res + p) % mod\\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def idealArrays(self, m: int, n: int) -> int:\\n        def dec(num):\\n            i = 2\\n            ct = Counter()\\n            while i <= num//i:\\n                if num % i == 0:\\n                    j = 0\\n                    while num % i == 0:\\n                        num //= i\\n                        j += 1\\n                    ct[i] = j\\n                i += 1\\n            if num!=1:\\n                ct[num] += 1\\n            return ct\\n        mod = 10**9 + 7\\n        res = 1\\n        for i in range(2,n+1):\\n            ctr = dec(i)\\n            p = 1\\n            for key in ctr:\\n                ct = ctr[key]\\n                p = (p * comb(m+ct-1, m-1)) % mod\\n            res = (res + p) % mod\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374657,
                "title": "simple-c-dp-solution",
                "content": "```\\nclass Solution {\\n    int mod = 1e9+7;\\n    vector<int> factorise(int x)\\n    {\\n        vector<int> res;\\n        if(x>1)\\n            res.push_back(1);\\n        for(int i=2;i*i<=x;i++)\\n        {\\n            \\n            if(x%i==0){\\n                res.push_back(i);\\n                if(i!=x/i)\\n                res.push_back(x/i);\\n            }\\n        }\\n        return res;\\n    }\\n    // double C(int n,int r)\\n    // {\\n    //     long long res =1 ;\\n    //     if(r>n-r)\\n    //         r=n-r;\\n    //     for(int i=0;i<r;i++)\\n    //     {\\n    //         res*=(n-i);\\n    //         res/=(i+1);\\n    //     }\\n    //     return res%mod;\\n    // }\\n    vector<long long> invFact;\\n    vector<long long> invNum;\\n    vector<long long> fact;\\n    \\n    long long C(int n,int r)\\n    {\\n        if(r<0 || n<r)\\n            return 0;\\n        long long res = (((fact[n]%mod)*(invFact[n-r]%mod)%mod)*(invFact[r]%mod))%mod;\\n        return res;\\n    }\\n    \\n    \\n    \\n    public:\\n    int idealArrays(int n, int maxValue) {\\n        \\n        invFact = vector<long long>(1e4+5);\\n        invNum=vector<long long> (1e4+5);\\n        fact=vector<long long> (1e4+5);\\n        invNum[0]=invNum[1]=1;\\n        invFact[0]=invFact[1]=1;\\n        fact[0]=fact[1]=1;\\n        for(int i=2;i<=1e4+4;i++)\\n        {\\n            invNum[i] = invNum[mod%i]*(mod-mod/i)%mod;\\n            invFact[i] = (invNum[i]*invFact[i-1])%mod;\\n            fact[i] = (i*fact[i-1])%mod;\\n        }\\n        \\n        vector<vector<long long>> dp(maxValue+1,vector<long long>(21,0));\\n        //dp[i][j] = number of ideal sequences having i as maxElement and j as distinct elements\\n        for(int i=1;i<=maxValue;i++)\\n            dp[i][1] = 1;\\n        for(int i=1;i<=maxValue;i++)\\n        {\\n            vector<int> factors = factorise(i);\\n            //log2(1e4) = 15\\n            for(int j=2;j<=20;j++)\\n            {\\n                for(int k:factors)\\n                {\\n                    dp[i][j] += dp[k][j-1];\\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        }\\n        // for(auto x:dp)\\n        // {\\n        //     for(auto y:x)\\n        //     {\\n        //         cout<<y<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        // cout<<endl;\\n        long long ans =0 ;\\n        for(int i=1;i<=maxValue;i++)\\n        {\\n            for(int j=1;j<=min(n,20);j++)\\n            {\\n                ans +=C(n-1,j-1)*dp[i][j];\\n                ans%=mod;\\n                // cout<<C(n-1,j-1)<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9+7;\\n    vector<int> factorise(int x)\\n    {\\n        vector<int> res;\\n        if(x>1)\\n            res.push_back(1);\\n        for(int i=2;i*i<=x;i++)\\n        {\\n            \\n            if(x%i==0){\\n                res.push_back(i);\\n                if(i!=x/i)\\n                res.push_back(x/i);\\n            }\\n        }\\n        return res;\\n    }\\n    // double C(int n,int r)\\n    // {\\n    //     long long res =1 ;\\n    //     if(r>n-r)\\n    //         r=n-r;\\n    //     for(int i=0;i<r;i++)\\n    //     {\\n    //         res*=(n-i);\\n    //         res/=(i+1);\\n    //     }\\n    //     return res%mod;\\n    // }\\n    vector<long long> invFact;\\n    vector<long long> invNum;\\n    vector<long long> fact;\\n    \\n    long long C(int n,int r)\\n    {\\n        if(r<0 || n<r)\\n            return 0;\\n        long long res = (((fact[n]%mod)*(invFact[n-r]%mod)%mod)*(invFact[r]%mod))%mod;\\n        return res;\\n    }\\n    \\n    \\n    \\n    public:\\n    int idealArrays(int n, int maxValue) {\\n        \\n        invFact = vector<long long>(1e4+5);\\n        invNum=vector<long long> (1e4+5);\\n        fact=vector<long long> (1e4+5);\\n        invNum[0]=invNum[1]=1;\\n        invFact[0]=invFact[1]=1;\\n        fact[0]=fact[1]=1;\\n        for(int i=2;i<=1e4+4;i++)\\n        {\\n            invNum[i] = invNum[mod%i]*(mod-mod/i)%mod;\\n            invFact[i] = (invNum[i]*invFact[i-1])%mod;\\n            fact[i] = (i*fact[i-1])%mod;\\n        }\\n        \\n        vector<vector<long long>> dp(maxValue+1,vector<long long>(21,0));\\n        //dp[i][j] = number of ideal sequences having i as maxElement and j as distinct elements\\n        for(int i=1;i<=maxValue;i++)\\n            dp[i][1] = 1;\\n        for(int i=1;i<=maxValue;i++)\\n        {\\n            vector<int> factors = factorise(i);\\n            //log2(1e4) = 15\\n            for(int j=2;j<=20;j++)\\n            {\\n                for(int k:factors)\\n                {\\n                    dp[i][j] += dp[k][j-1];\\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        }\\n        // for(auto x:dp)\\n        // {\\n        //     for(auto y:x)\\n        //     {\\n        //         cout<<y<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        // cout<<endl;\\n        long long ans =0 ;\\n        for(int i=1;i<=maxValue;i++)\\n        {\\n            for(int j=1;j<=min(n,20);j++)\\n            {\\n                ans +=C(n-1,j-1)*dp[i][j];\\n                ans%=mod;\\n                // cout<<C(n-1,j-1)<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2362279,
                "title": "c-dp-no-tle-nor-outofmemory-detailed-explain",
                "content": "Tips.\\n\\n1.Normal DP as following will TLE, that\\'s why this question is **HARD**,  we must do some optimized.\\n```\\n        public int IdealArrays_TLE(int n, int maxValue)\\n        {\\n            int mod = 1_000_000_007;\\n            int[][] dp = new int[n][];\\n            for(int i = 0; i < n; i++)\\n                dp[i]=new int[maxValue+1];\\n            Array.Fill(dp[0], 1);\\n            for(int i = 0; i < n-1; i++)\\n            {\\n                for(int j = 1; j <= maxValue; j++)\\n                {\\n                    if (dp[i][j] == 0) continue;\\n                    int x=j;\\n                    while(x <= maxValue)\\n                    {\\n                        dp[i + 1][x] = (dp[i + 1][x] + dp[i][j]) % mod;\\n                        x+=j;\\n                    }\\n                }\\n            }\\n            int res = 0;\\n            for (int i = 1; i <= maxValue; i++)\\n                res = (res + dp[n - 1][i]) % mod;\\n            return res;\\n        }\\n```\\n\\n2.How to optimized?\\n\\nOrigin question:\\n* arr[i] is a value from 1 to maxValue, for 0 <= i < n.\\n* Every arr[i] is divisible by arr[i - 1], for 0 < i < n.\\n\\n=>So, arr[i] = times * arr[i - 1], times in range [1, maxValue/arr[i - 1] ] \\n=>times will be 1 or greater than 1 (2,3,4...)\\n\\nFinally we can transfer the origin question to :\\n\\n1.Find all strictly increasing array that length <=n and elements<=maxValue;\\n2.For all strictly increasing array, clone any element and place it at same position, repeat this step to make array to a non-descreasing array with n length.\\n\\nThe maxLength of strictly increasing array must less than 15, because:\\n1->2->4->8...->8096, maxValue<=10000\\n\\nSo. the final solution is:\\n\\n```\\n        public int IdealArrays(int n, int maxValue)\\n        {\\n            long mod = 1_000_000_007;\\n            long res = 0;\\n            long[][] dp = new long[15][];//find all strictly increasing arrays that last element <= maxValue\\n            for (int i = 0; i < dp.Length; i++)\\n                dp[i] = new long[maxValue + 1];\\n            Array.Fill(dp[1], 1);\\n\\t\\t\\t//dp[i][j] means an strictly increasing array with i length and lastElement = j, (aka max =j )\\n            for(int i = 1; i < dp.Length-1; i++)\\n            {\\n                for(int j = 1; j <= maxValue; j++)\\n                {\\n                    if (dp[i][j] == 0)  continue;\\n                    int k = 2;\\n                    while(k*j <= maxValue)\\n                    {\\n                        dp[i + 1][k * j] = (dp[i + 1][k * j] + dp[i][j])%mod;\\n                        k++;\\n                    }\\n                }\\n            }\\n            //for testcase 38 , IdealArrays(9557,9767), bottom-up query table will occur OUT OF MEMORY on leetcode but works well in local IDE\\n            //create query table, ways to insert n-m element to strictly asc arr(m-length) to make it non-desc as n-length\\n            //long[][] memo = new long[n+1][];\\n            //for (int i = 0; i <= n; i++)\\n            //    memo[i] = new long[n + 1];\\n            //Array.Fill(memo[1], 1);\\n            //for(int i = 2; i <= n; i++)\\n            //{\\n            //    memo[i][i] = 1;\\n            //    for(int j = i + 1; j <= n; j++)\\n            //    {\\n            //        memo[i][j] = (memo[i][j - 1] + memo[i - 1][j - 1])% mod;\\n            //    }\\n            //}\\n            //bottom-up query table will OUT OF MEMORY,so we using top-down memoization\\n            var memo = new Dictionary<int, long>();//using m*10000+n as query key\\n            for (int i = 1; i < dp.Length && i<=n; i++)\\n            {\\n                for(int j=1;j<= maxValue; j++)\\n                {\\n                    if (dp[i][j] == 0) continue;\\n                    res = (res + dp[i][j] * IdealArrays_GetCount(i,n, memo)) % mod;\\n                }\\n            }\\n            return (int)res;\\n        }\\n\\n        private long IdealArrays_GetCount(int i, int n, Dictionary<int,long> dict)\\n        {\\n            if (i == 1) return 1;//special case\\n            if (i == n) return 1;//special case\\n            if (i > n) return 0;//never happen\\n            long mod = 1_000_000_007;\\n            if (dict.ContainsKey(i * 10000 + n))\\n            {\\n                return dict[i * 10000 + n];\\n            }\\n            else\\n            {\\n                //eg. for a 6 x 6 query table, memo[i][j] = memo[i][j - 1] + memo[i - 1][j - 1]\\n                //     |  1  |  2  |  3  |  4  |  5  |  6  |\\n                //  1  |  1  |  1  |  1  |  1  |  1  |  1  |\\n                //  2  |  x  |  1  |  2  |  3  |  4  |  5  |\\n                //  3  |  x  |  x  |  1  |  3  |  6  |  10 |\\n                //  4  |  x  |  x  |  x  |  1  |  4  |  10 |\\n                //  5  |  x  |  x  |  x  |  x  |  1  |  5  |\\n                //  6  |  x  |  x  |  x  |  x  |  x  |  1  |\\n                long res = IdealArrays_GetCount(i, n - 1, dict) + IdealArrays_GetCount(i - 1, n - 1, dict);\\n                res = res % mod;\\n                dict.Add(i * 10000 + n, res );\\n                return res;\\n            }\\n        }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n        public int IdealArrays_TLE(int n, int maxValue)\\n        {\\n            int mod = 1_000_000_007;\\n            int[][] dp = new int[n][];\\n            for(int i = 0; i < n; i++)\\n                dp[i]=new int[maxValue+1];\\n            Array.Fill(dp[0], 1);\\n            for(int i = 0; i < n-1; i++)\\n            {\\n                for(int j = 1; j <= maxValue; j++)\\n                {\\n                    if (dp[i][j] == 0) continue;\\n                    int x=j;\\n                    while(x <= maxValue)\\n                    {\\n                        dp[i + 1][x] = (dp[i + 1][x] + dp[i][j]) % mod;\\n                        x+=j;\\n                    }\\n                }\\n            }\\n            int res = 0;\\n            for (int i = 1; i <= maxValue; i++)\\n                res = (res + dp[n - 1][i]) % mod;\\n            return res;\\n        }\\n```\n```\\n        public int IdealArrays(int n, int maxValue)\\n        {\\n            long mod = 1_000_000_007;\\n            long res = 0;\\n            long[][] dp = new long[15][];//find all strictly increasing arrays that last element <= maxValue\\n            for (int i = 0; i < dp.Length; i++)\\n                dp[i] = new long[maxValue + 1];\\n            Array.Fill(dp[1], 1);\\n\\t\\t\\t//dp[i][j] means an strictly increasing array with i length and lastElement = j, (aka max =j )\\n            for(int i = 1; i < dp.Length-1; i++)\\n            {\\n                for(int j = 1; j <= maxValue; j++)\\n                {\\n                    if (dp[i][j] == 0)  continue;\\n                    int k = 2;\\n                    while(k*j <= maxValue)\\n                    {\\n                        dp[i + 1][k * j] = (dp[i + 1][k * j] + dp[i][j])%mod;\\n                        k++;\\n                    }\\n                }\\n            }\\n            //for testcase 38 , IdealArrays(9557,9767), bottom-up query table will occur OUT OF MEMORY on leetcode but works well in local IDE\\n            //create query table, ways to insert n-m element to strictly asc arr(m-length) to make it non-desc as n-length\\n            //long[][] memo = new long[n+1][];\\n            //for (int i = 0; i <= n; i++)\\n            //    memo[i] = new long[n + 1];\\n            //Array.Fill(memo[1], 1);\\n            //for(int i = 2; i <= n; i++)\\n            //{\\n            //    memo[i][i] = 1;\\n            //    for(int j = i + 1; j <= n; j++)\\n            //    {\\n            //        memo[i][j] = (memo[i][j - 1] + memo[i - 1][j - 1])% mod;\\n            //    }\\n            //}\\n            //bottom-up query table will OUT OF MEMORY,so we using top-down memoization\\n            var memo = new Dictionary<int, long>();//using m*10000+n as query key\\n            for (int i = 1; i < dp.Length && i<=n; i++)\\n            {\\n                for(int j=1;j<= maxValue; j++)\\n                {\\n                    if (dp[i][j] == 0) continue;\\n                    res = (res + dp[i][j] * IdealArrays_GetCount(i,n, memo)) % mod;\\n                }\\n            }\\n            return (int)res;\\n        }\\n\\n        private long IdealArrays_GetCount(int i, int n, Dictionary<int,long> dict)\\n        {\\n            if (i == 1) return 1;//special case\\n            if (i == n) return 1;//special case\\n            if (i > n) return 0;//never happen\\n            long mod = 1_000_000_007;\\n            if (dict.ContainsKey(i * 10000 + n))\\n            {\\n                return dict[i * 10000 + n];\\n            }\\n            else\\n            {\\n                //eg. for a 6 x 6 query table, memo[i][j] = memo[i][j - 1] + memo[i - 1][j - 1]\\n                //     |  1  |  2  |  3  |  4  |  5  |  6  |\\n                //  1  |  1  |  1  |  1  |  1  |  1  |  1  |\\n                //  2  |  x  |  1  |  2  |  3  |  4  |  5  |\\n                //  3  |  x  |  x  |  1  |  3  |  6  |  10 |\\n                //  4  |  x  |  x  |  x  |  1  |  4  |  10 |\\n                //  5  |  x  |  x  |  x  |  x  |  1  |  5  |\\n                //  6  |  x  |  x  |  x  |  x  |  x  |  1  |\\n                long res = IdealArrays_GetCount(i, n - 1, dict) + IdealArrays_GetCount(i - 1, n - 1, dict);\\n                res = res % mod;\\n                dict.Add(i * 10000 + n, res );\\n                return res;\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2346126,
                "title": "need-help-mle",
                "content": "class Solution {            // how can i optimize the space,, if you can.do.please tell me\\n\\n//       -- This code show MLE\\n\\n    int count=0;\\n    ArrayList<Integer> al=new ArrayList<>();\\n    public int idealArrays(int n, int maxValue) {\\n        \\n        for(int i=1;i<=maxValue;i++) al.add(i);\\n         generateCout(al,\"\",n);\\n        return count;\\n        \\n    }\\n    \\n    public void generateCout(ArrayList<Integer> l,String ans,int n){\\n        if(l.size()==0) return ;\\n        \\n        if(ans.length()==n){\\n            count++;\\n            return;\\n        }\\n        \\n       for(int i=0;i<l.size();i++){\\n           \\n           int t=l.get(i);\\n           String temp=ans+t;\\n           \\n           ArrayList<Integer> nl=new ArrayList<>();\\n           \\n           for(int k=0;k<l.size();k++){\\n               if(l.get(k)%t==0) nl.add(l.get(k));\\n           }\\n           generateCout(nl,temp,n);\\n           \\n          \\n       }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {            // how can i optimize the space,, if you can.do.please tell me\\n\\n//       -- This code show MLE\\n\\n    int count=0;\\n    ArrayList<Integer> al=new ArrayList<>();\\n    public int idealArrays(int n, int maxValue) {\\n        \\n        for(int i=1;i<=maxValue;i++) al.add(i);\\n         generateCout(al,\"\",n);\\n        return count;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2315998,
                "title": "readable-c-solution-explained-credit-to-huifeng-guan",
                "content": "https://www.youtube.com/watch?v=R7b6DY-3-7o\\n**The key to solve this problem is to find the number of allocations of m same prime factors to n slots:**\\ne.g. maxValue = 8 = 2 \\\\* 2 \\\\* 2 (m = 3) => _ _ _ _ (n = 4)          //allocate three 2s to 4 slots\\nthere are a number of ways to derive an 8:\\n2 2 2 _ => 2, 4, 8, 8   //place one 2 in the first 3 slots individually\\n2 2\\\\*2 _ _ => 2, 8, 8, 8   //place one 2 in the first slot and two 2s in the second\\n......\\n\\nIn code this is done in the initializeDp method (simple dp). The dp result applies to all prime factors. (i.e. it doesn\\'t matter whether the prime factor here is 2, 3 5 or 7...)\\n\\nGiven a last value (the final number we want to get, in previous example it was 8 but let\\'s say we want 28 = 2 \\\\* 2 \\\\* 7 now), the number of permutations (still with n = 4) is **dp[4][2] * dp[4][1]**. Here are some possible allocations:\\n**1, 4, 28, 28**:         (allocation of 2s) _ 2\\\\*2 _ _,        (allocation of 7s) _ _ 7 _\\n**1, 7, 14, 28**:         (allocation of 2s) _ _ 2 2,             (allocation of 7s) _ 7 _ _\\nand there are many more......\\n\\nSince any final number smaller than 28 meets the requirement, the final answer is: last_value(28) + last_value(27) ... + last_value(1).\\n\\nps: I\\'m using a sub-optimal approach to decomposite prime factors. Feel free to make any optimizations. For now it passed all TCs :)\\n\\n```\\nclass Solution {\\npublic:\\n    // How to allocate m same factors to n slots\\n    vector<vector<long>> dp;\\n    int mod;\\n    \\n    Solution() : dp(10001, vector<long>(15, 0)), mod((int)1e9 + 7) {}\\n    \\n    void initializeDp(int n) {\\n        for (int j = 0; j <= 14; ++j)\\n            dp[1][j] = 1;\\n        \\n        for (int i = 2; i <= n; ++i) {\\n            for (int j = 0; j <= 14; ++j) {\\n                for (int k = 0; k <= j; ++k) {\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n                }\\n            }\\n        }\\n    }\\n    \\n    unordered_map<int, int> decomposite(int n) {\\n        unordered_map<int, int> map;\\n        while (n != 1) {\\n            for (int i = 2; i <= n; ++i) {\\n                if (n % i != 0) continue;\\n                if (map.find(i) == map.end())\\n                    map[i] = 0;\\n                map[i]++;\\n                n /= i;\\n                break;\\n            }\\n        }\\n        return map;\\n    }\\n    \\n    int idealArrays(int n, int maxValue) {\\n        int ans = 0;\\n        initializeDp(n);\\n        for (int i = 2; i <= maxValue; ++i) {\\n            int tmp = 1;\\n            auto map = decomposite(i);\\n            for (auto pair : map) {\\n                tmp = (tmp * dp[n][pair.second]) % mod;\\n            }\\n            ans = (ans + tmp) % mod;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // How to allocate m same factors to n slots\\n    vector<vector<long>> dp;\\n    int mod;\\n    \\n    Solution() : dp(10001, vector<long>(15, 0)), mod((int)1e9 + 7) {}\\n    \\n    void initializeDp(int n) {\\n        for (int j = 0; j <= 14; ++j)\\n            dp[1][j] = 1;\\n        \\n        for (int i = 2; i <= n; ++i) {\\n            for (int j = 0; j <= 14; ++j) {\\n                for (int k = 0; k <= j; ++k) {\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n                }\\n            }\\n        }\\n    }\\n    \\n    unordered_map<int, int> decomposite(int n) {\\n        unordered_map<int, int> map;\\n        while (n != 1) {\\n            for (int i = 2; i <= n; ++i) {\\n                if (n % i != 0) continue;\\n                if (map.find(i) == map.end())\\n                    map[i] = 0;\\n                map[i]++;\\n                n /= i;\\n                break;\\n            }\\n        }\\n        return map;\\n    }\\n    \\n    int idealArrays(int n, int maxValue) {\\n        int ans = 0;\\n        initializeDp(n);\\n        for (int i = 2; i <= maxValue; ++i) {\\n            int tmp = 1;\\n            auto map = decomposite(i);\\n            for (auto pair : map) {\\n                tmp = (tmp * dp[n][pair.second]) % mod;\\n            }\\n            ans = (ans + tmp) % mod;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293523,
                "title": "c-dp-math-solution",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll mod=1e9+7;\\n    ll f[10005][15];\\n    int idealArrays(int n, int maxValue) \\n    {\\n        f[0][0]=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            f[i][0]=1;\\n            for(int j=1;j<15;j++)\\n                for(int k=0;k<=j;k++)\\n                    f[i][j]=(f[i][j]+f[i-1][j-k])%mod;\\n        }\\n        ll ans=0;\\n        for(int i=1;i<=maxValue;i++)\\n        {\\n            int x=i;\\n            ll cur=1;\\n            for(int j=2;j*j<=x;j++)\\n            {\\n                int count=0;\\n                while(x%j==0)\\n                {\\n                    count++;\\n                    x/=j;\\n                }\\n                cur=(cur*f[n][count])%mod;\\n            }\\n            if(x!=1)cur=(cur*f[n][1])%mod;\\n            ans=(ans+cur)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll mod=1e9+7;\\n    ll f[10005][15];\\n    int idealArrays(int n, int maxValue) \\n    {\\n        f[0][0]=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            f[i][0]=1;\\n            for(int j=1;j<15;j++)\\n                for(int k=0;k<=j;k++)\\n                    f[i][j]=(f[i][j]+f[i-1][j-k])%mod;\\n        }\\n        ll ans=0;\\n        for(int i=1;i<=maxValue;i++)\\n        {\\n            int x=i;\\n            ll cur=1;\\n            for(int j=2;j*j<=x;j++)\\n            {\\n                int count=0;\\n                while(x%j==0)\\n                {\\n                    count++;\\n                    x/=j;\\n                }\\n                cur=(cur*f[n][count])%mod;\\n            }\\n            if(x!=1)cur=(cur*f[n][1])%mod;\\n            ans=(ans+cur)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290698,
                "title": "c-explore-prime-factorization-isomorphism",
                "content": "```\\n/**\\n * Two important observations:\\n *\\n * 1) You can compute the number of strictly increasing ideal arrays and boostrap\\n *    the number of ideal arrays without this restriction. This is discussed in most voted posts\\n * 2) Let a and b be any two numbers.\\n *    Let (p1)^(k1)*(p2)^(k2)*...*(pn)^(kn) be a\\'s prime factorization\\n *    Let (q1)^(l1)*(q2)^(l2)*...*(qn)^(ln) be b\\'s prime factorization\\n *    Consider the multiset of the primes\\' exponents\\n *    S_a = {k1, k2, ..., kn} and S_b = {l1, l1, ..., ln}\\n *    If S_a = S_b, the number of {strictly increasing or not} ideal arrays of any fixed length\\n *    that end with a and b are the same. Essentially we call a and b isomorphic with respect\\n *    to the prime factorization structure\\n *    \\n *    For example, strictly increasing ideal arrays ending with 12 of length 3 are\\n *    [1, 2, 12], [1, 3, 12], [1, 4, 12], [1, 6, 12], [2, 6, 12], [3, 6, 12]\\n *    and those ending with 50 of the same length are\\n *    [1, 2, 50], [1, 5, 50], [1,25, 50], [1, 10, 50], [2, 10, 50], [5, 10, 50].\\n *    \\n *    This motivates us to find all different kinds of prime factorization structures, which are\\n *    significantly less than the # of numbers to consider\\n */\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int base = 6;\\n    // freqs[i] is the number of numbers that have prime factorizartion encoding i \\n    unordered_map<long long, int> freqs;\\n    // decodings[i] is S_i. Definition of S is given in observation 2 from above\\n    unordered_map<long long, vector<int> > decodings;\\n    // dp[i][j] is the number of strictly increasing ideal array of length i\\n    // that ends with a number of prime factorizartion encoding j\\n    vector<unordered_map<long long, int> > dp;\\n    int maxValue;\\n    int n;\\n    \\n    int modPow(int p, int k) {\\n        if (k == 0) {\\n            return 1;\\n        }\\n        if (k == 1) {\\n            return p;\\n        }\\n        if (k % 2 == 0) {\\n            return modPow((long long) p * p % mod, k / 2);\\n        }\\n        return (long long) p * modPow(p, k - 1) % mod;\\n    }\\n    \\n    long long pow(long long p, long long k) {\\n        if (k == 0) {\\n            return 1;\\n        }\\n        if (k == 1) {\\n            return p;\\n        }\\n        if (k % 2 == 0) {\\n            return pow((long long) p * p, k / 2);\\n        }\\n        return (long long) p * pow(p, k - 1);\\n    }\\n    \\n    int choose(int n, int m) {\\n        if (m * 2 > n) {\\n            m = n - m;\\n        }\\n        long long top = 1;\\n        long long bot = 1;\\n        for (int i = n; i > n - m; i--) {\\n            top *= i;\\n            top %= mod;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            bot *= i;\\n            bot %= mod;\\n        }\\n        \\n        long long inverse = modPow(bot, mod - 2);\\n        return top * inverse % mod;\\n    }\\n    \\n    void sieve() {\\n        vector<vector<int> > factorizations(maxValue + 1);\\n        // Let the prime factorization of i be (p1)^(k1)*(p2)^(k2)*...*(pn)^(kn)\\n        // factorizations[i] is the list [k1, k2, ..., kn], the list of exponents\\n        for (int i = 2; i <= maxValue; i++) {\\n            if (factorizations[i].empty()) {\\n                int p = i;\\n                for (int j = i; j <= maxValue; j += i) {\\n                    factorizations[j].push_back(0);\\n                }\\n                while (p <= maxValue) {\\n                    for (int j = p; j <= maxValue; j += p) {\\n                        factorizations[j].back()++;\\n                    }\\n                    p *= i;\\n                }\\n            }\\n        }\\n        freqs.emplace(0, 1);\\n        decodings.emplace(0, vector<int>());\\n        for (int i = 2; i <= maxValue; i++) {\\n            int encoding = 0;\\n            // Encode factorizations[i] into a long long\\n            // First we convert factorizations[i] into an unordered map\\n            // where map[i] is the frequency of exponent i\\n            // For example, if factorizations[i] is [2, 1, 1]\\n            // 2 occurs once so map[2] = 1\\n            // 1 occurs twice so map[1] = 2\\n            \\n            // With the map, we can encode it into base 6\\n            // The reason we use base 6 is that the biggest product from increasing prime\\n            // less than 10000 is 2*3*5*7*11. Therefore the value of any key is at most 5\\n            for (int e : factorizations[i]) {\\n                encoding += pow(base, e);\\n            }\\n            if (decodings.find(encoding) == decodings.end()) {\\n                decodings.emplace(encoding, move(factorizations[i]));\\n            }\\n            freqs[encoding]++;\\n        }\\n    }\\n    \\n    int BFS(vector<int>& original, long long oldEncoding, int len, int index,\\n            long long acc) {\\n        if (oldEncoding == acc) {\\n            return 0;\\n        }\\n        if (index == original.size()) {\\n            return S(len - 1, acc);\\n        }\\n        int res = 0;\\n        for (int i = 0; i <= original[index]; i++) {\\n            int delta = i == 0 ? 0 : pow(base, i);\\n            res += BFS(original, oldEncoding, len, index + 1, acc + delta);\\n            res %= mod;\\n        }\\n        return res;\\n    }\\n    \\n    /**\\n     * Compute the number of strictly increasing ideal arrays with\\n     * length @param[len] and prime factor exponent encoding @param[encoding]\\n     */\\n    int S(int len, long long encoding) {\\n        if (dp[len].find(encoding) != dp[len].end()) {\\n            return dp[len][encoding];\\n        }\\n        if (len == 1) {\\n            dp[len].emplace(encoding, 1);\\n            return 1;\\n        }\\n        if (encoding == 0) {\\n            return 0;\\n        }\\n        int res = BFS(decodings[encoding], encoding, len, 0, 0);\\n        dp[len].emplace(encoding, res);\\n        return res;\\n    }\\n    \\n    int idealArrays(int n, int maxValue) {\\n        this -> maxValue = maxValue;\\n        this -> n = n;\\n        sieve();\\n        for (auto& p : decodings) {\\n            // For any strictly increasing ideal array ending with a number\\n            // of prime factorization encoding [p.first]\\n            // its length is at most 1 + the sum of the prime exponents\\n            // For example, 12 = 2^2 * 3^1. Suppose we construct the ideal array from\\n            // left to right. Each time we append a new number, it must be some prime factor\\n            // times the last numnber. We only have (2 + 1) prime factors so we can almost\\n            // append (2 + 1) times and the length is at most 1 + (2 + 1) = 4\\n            int maxLen = 1 + accumulate(p.second.begin(), p.second.end(), 0);\\n            maxLen = min(maxLen, n);\\n            if (maxLen >= dp.size()) {\\n                dp.resize(maxLen + 1);\\n            }\\n            for (int i = 1; i <= maxLen; i++) {\\n                S(i, p.first);\\n            }\\n        }\\n        int res = 0;\\n        vector<int> sums(dp.size());\\n        for (int i = 1; i < dp.size(); i++) {\\n            for (auto& p : dp[i]) {\\n                sums[i] += (long long) p.second * freqs[p.first] % mod;\\n            }\\n        }\\n        for (int i = 1; i < sums.size(); i++) {\\n            res += (long long) sums[i] * choose(n - 1, i - 1) % mod;\\n            res %= mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\n/**\\n * Two important observations:\\n *\\n * 1) You can compute the number of strictly increasing ideal arrays and boostrap\\n *    the number of ideal arrays without this restriction. This is discussed in most voted posts\\n * 2) Let a and b be any two numbers.\\n *    Let (p1)^(k1)*(p2)^(k2)*...*(pn)^(kn) be a\\'s prime factorization\\n *    Let (q1)^(l1)*(q2)^(l2)*...*(qn)^(ln) be b\\'s prime factorization\\n *    Consider the multiset of the primes\\' exponents\\n *    S_a = {k1, k2, ..., kn} and S_b = {l1, l1, ..., ln}\\n *    If S_a = S_b, the number of {strictly increasing or not} ideal arrays of any fixed length\\n *    that end with a and b are the same. Essentially we call a and b isomorphic with respect\\n *    to the prime factorization structure\\n *    \\n *    For example, strictly increasing ideal arrays ending with 12 of length 3 are\\n *    [1, 2, 12], [1, 3, 12], [1, 4, 12], [1, 6, 12], [2, 6, 12], [3, 6, 12]\\n *    and those ending with 50 of the same length are\\n *    [1, 2, 50], [1, 5, 50], [1,25, 50], [1, 10, 50], [2, 10, 50], [5, 10, 50].\\n *    \\n *    This motivates us to find all different kinds of prime factorization structures, which are\\n *    significantly less than the # of numbers to consider\\n */\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int base = 6;\\n    // freqs[i] is the number of numbers that have prime factorizartion encoding i \\n    unordered_map<long long, int> freqs;\\n    // decodings[i] is S_i. Definition of S is given in observation 2 from above\\n    unordered_map<long long, vector<int> > decodings;\\n    // dp[i][j] is the number of strictly increasing ideal array of length i\\n    // that ends with a number of prime factorizartion encoding j\\n    vector<unordered_map<long long, int> > dp;\\n    int maxValue;\\n    int n;\\n    \\n    int modPow(int p, int k) {\\n        if (k == 0) {\\n            return 1;\\n        }\\n        if (k == 1) {\\n            return p;\\n        }\\n        if (k % 2 == 0) {\\n            return modPow((long long) p * p % mod, k / 2);\\n        }\\n        return (long long) p * modPow(p, k - 1) % mod;\\n    }\\n    \\n    long long pow(long long p, long long k) {\\n        if (k == 0) {\\n            return 1;\\n        }\\n        if (k == 1) {\\n            return p;\\n        }\\n        if (k % 2 == 0) {\\n            return pow((long long) p * p, k / 2);\\n        }\\n        return (long long) p * pow(p, k - 1);\\n    }\\n    \\n    int choose(int n, int m) {\\n        if (m * 2 > n) {\\n            m = n - m;\\n        }\\n        long long top = 1;\\n        long long bot = 1;\\n        for (int i = n; i > n - m; i--) {\\n            top *= i;\\n            top %= mod;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            bot *= i;\\n            bot %= mod;\\n        }\\n        \\n        long long inverse = modPow(bot, mod - 2);\\n        return top * inverse % mod;\\n    }\\n    \\n    void sieve() {\\n        vector<vector<int> > factorizations(maxValue + 1);\\n        // Let the prime factorization of i be (p1)^(k1)*(p2)^(k2)*...*(pn)^(kn)\\n        // factorizations[i] is the list [k1, k2, ..., kn], the list of exponents\\n        for (int i = 2; i <= maxValue; i++) {\\n            if (factorizations[i].empty()) {\\n                int p = i;\\n                for (int j = i; j <= maxValue; j += i) {\\n                    factorizations[j].push_back(0);\\n                }\\n                while (p <= maxValue) {\\n                    for (int j = p; j <= maxValue; j += p) {\\n                        factorizations[j].back()++;\\n                    }\\n                    p *= i;\\n                }\\n            }\\n        }\\n        freqs.emplace(0, 1);\\n        decodings.emplace(0, vector<int>());\\n        for (int i = 2; i <= maxValue; i++) {\\n            int encoding = 0;\\n            // Encode factorizations[i] into a long long\\n            // First we convert factorizations[i] into an unordered map\\n            // where map[i] is the frequency of exponent i\\n            // For example, if factorizations[i] is [2, 1, 1]\\n            // 2 occurs once so map[2] = 1\\n            // 1 occurs twice so map[1] = 2\\n            \\n            // With the map, we can encode it into base 6\\n            // The reason we use base 6 is that the biggest product from increasing prime\\n            // less than 10000 is 2*3*5*7*11. Therefore the value of any key is at most 5\\n            for (int e : factorizations[i]) {\\n                encoding += pow(base, e);\\n            }\\n            if (decodings.find(encoding) == decodings.end()) {\\n                decodings.emplace(encoding, move(factorizations[i]));\\n            }\\n            freqs[encoding]++;\\n        }\\n    }\\n    \\n    int BFS(vector<int>& original, long long oldEncoding, int len, int index,\\n            long long acc) {\\n        if (oldEncoding == acc) {\\n            return 0;\\n        }\\n        if (index == original.size()) {\\n            return S(len - 1, acc);\\n        }\\n        int res = 0;\\n        for (int i = 0; i <= original[index]; i++) {\\n            int delta = i == 0 ? 0 : pow(base, i);\\n            res += BFS(original, oldEncoding, len, index + 1, acc + delta);\\n            res %= mod;\\n        }\\n        return res;\\n    }\\n    \\n    /**\\n     * Compute the number of strictly increasing ideal arrays with\\n     * length @param[len] and prime factor exponent encoding @param[encoding]\\n     */\\n    int S(int len, long long encoding) {\\n        if (dp[len].find(encoding) != dp[len].end()) {\\n            return dp[len][encoding];\\n        }\\n        if (len == 1) {\\n            dp[len].emplace(encoding, 1);\\n            return 1;\\n        }\\n        if (encoding == 0) {\\n            return 0;\\n        }\\n        int res = BFS(decodings[encoding], encoding, len, 0, 0);\\n        dp[len].emplace(encoding, res);\\n        return res;\\n    }\\n    \\n    int idealArrays(int n, int maxValue) {\\n        this -> maxValue = maxValue;\\n        this -> n = n;\\n        sieve();\\n        for (auto& p : decodings) {\\n            // For any strictly increasing ideal array ending with a number\\n            // of prime factorization encoding [p.first]\\n            // its length is at most 1 + the sum of the prime exponents\\n            // For example, 12 = 2^2 * 3^1. Suppose we construct the ideal array from\\n            // left to right. Each time we append a new number, it must be some prime factor\\n            // times the last numnber. We only have (2 + 1) prime factors so we can almost\\n            // append (2 + 1) times and the length is at most 1 + (2 + 1) = 4\\n            int maxLen = 1 + accumulate(p.second.begin(), p.second.end(), 0);\\n            maxLen = min(maxLen, n);\\n            if (maxLen >= dp.size()) {\\n                dp.resize(maxLen + 1);\\n            }\\n            for (int i = 1; i <= maxLen; i++) {\\n                S(i, p.first);\\n            }\\n        }\\n        int res = 0;\\n        vector<int> sums(dp.size());\\n        for (int i = 1; i < dp.size(); i++) {\\n            for (auto& p : dp[i]) {\\n                sums[i] += (long long) p.second * freqs[p.first] % mod;\\n            }\\n        }\\n        for (int i = 1; i < sums.size(); i++) {\\n            res += (long long) sums[i] * choose(n - 1, i - 1) % mod;\\n            res %= mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288345,
                "title": "java-math-solution",
                "content": "```\\nimport java.math.*;\\nclass Solution {\\n    long mod = (long)1e9 + 7;\\n\\t//  binomial coefficients mCk\\n\\t// number of ways to choose k elements from n elements\\n    private long Combination(int n, int k) {\\n        if (k > n / 2) {\\n            k = n - k;\\n        }\\n        BigInteger res = BigInteger.valueOf(1);\\n        for (int i = 1; i <= k; i++) {\\n            res = res.multiply(BigInteger.valueOf(n + 1 - i)).divide(BigInteger.valueOf(i));\\n        }\\n        return res.mod(BigInteger.valueOf(mod)).longValue();\\n    }\\n\\n    public int idealArrays(int n, int maxValue) {\\n\\t//dp[i] is the number of ideal array of length i that is strictly increasing\\n        long[] dp = new long[maxValue + 1];\\n        for (int i = 1; i <= maxValue; i++) {\\n            backtracking(dp, i, 0, maxValue);\\n        }\\n        long res = 0;\\n        for (int i = 1; i <= Math.min(n, maxValue); i++) {\\n            if (dp[i] == 0) break;\\n            res = (res + dp[i] * Combination(n - 1, i - 1)) % mod;\\n        }\\n        return (int) res;\\n    }\\n\\n    private static void backtracking(long[] dp, int cur, int size, int max) {\\n        ++size;\\n        ++dp[size];\\n        for (int i = 2; i * cur <= max; i++) {\\n            backtracking(dp, cur * i, size, max);\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/c70c9d8c-7953-4d58-a03e-5c8f138ff79c_1657944826.8210645.png)\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nimport java.math.*;\\nclass Solution {\\n    long mod = (long)1e9 + 7;\\n\\t//  binomial coefficients mCk\\n\\t// number of ways to choose k elements from n elements\\n    private long Combination(int n, int k) {\\n        if (k > n / 2) {\\n            k = n - k;\\n        }\\n        BigInteger res = BigInteger.valueOf(1);\\n        for (int i = 1; i <= k; i++) {\\n            res = res.multiply(BigInteger.valueOf(n + 1 - i)).divide(BigInteger.valueOf(i));\\n        }\\n        return res.mod(BigInteger.valueOf(mod)).longValue();\\n    }\\n\\n    public int idealArrays(int n, int maxValue) {\\n\\t//dp[i] is the number of ideal array of length i that is strictly increasing\\n        long[] dp = new long[maxValue + 1];\\n        for (int i = 1; i <= maxValue; i++) {\\n            backtracking(dp, i, 0, maxValue);\\n        }\\n        long res = 0;\\n        for (int i = 1; i <= Math.min(n, maxValue); i++) {\\n            if (dp[i] == 0) break;\\n            res = (res + dp[i] * Combination(n - 1, i - 1)) % mod;\\n        }\\n        return (int) res;\\n    }\\n\\n    private static void backtracking(long[] dp, int cur, int size, int max) {\\n        ++size;\\n        ++dp[size];\\n        for (int i = 2; i * cur <= max; i++) {\\n            backtracking(dp, cur * i, size, max);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281897,
                "title": "why-tle",
                "content": "class Solution {\\npublic:\\n    \\n    int mod=1e9+7;\\n    \\n    int idealArrays(int n,int m) {\\n       \\n        vector<int> nums;\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            nums.push_back(i);\\n        }\\n              \\n        return solve(n,nums,1,dp,0);\\n                 \\n    }\\n    \\n    int solve(int n,vector<int>& nums,int prev,vector<vector<int>>& dp,int i)\\n    {\\n        \\n       if(n==0){        \\n           return 1;     \\n       } \\n        \\n       if(i==nums.size())\\n       {\\n           return 0;\\n       }\\n        \\n       if(dp[n][prev]!=-1){\\n           return dp[n][prev];\\n       }\\n          \\n       int ans=0;\\n        \\n       if(nums[i]%prev==0)\\n       {\\n           ans+=solve(n-1,nums,nums[i],dp,i);\\n           ans%=mod;\\n       }\\n        \\n       ans+=solve(n,nums,prev,dp,i+1);\\n       ans%=mod;\\n             \\n       dp[n][prev]=ans;\\n        \\n         return ans;\\n            \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int mod=1e9+7;\\n    \\n    int idealArrays(int n,int m) {\\n       \\n        vector<int> nums;\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            nums.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2281268,
                "title": "c-2d-dp",
                "content": "#define mod 1000000007\\nclass Solution {\\npublic:\\n\\n    int idealArrays(int n, int maxValue) {\\n        \\n        int k = maxValue;\\n        vector<int> factors[k+1];\\n\\t\\t\\n        //factors of all the numbers \\n        for(int i=1; i<=k; i++)\\n        {\\n            for(int j=(2*i); j<=k; j+=i)\\n            factors[j].push_back(i);\\n        }\\n        \\n        vector<long long> fact(15),ncr(16);\\n        \\n        fact[0]=1;\\n        for(int i=1; i<15; i++)\\n        fact[i]= fact[i-1]*(i*(1LL));\\n            \\n        //max number of unique numbers int the array would be 13\\n\\n        long long p = n-1;\\n        ncr[0] = 0;\\n        ncr[1] = 1;\\n        for(int i=2; i<16; i++)\\n        {\\n            // i is the count of the unique numbers \\n            long long val = 1;\\n            long long deno = fact[i-1];\\n            for(int j=0; j<(i-1); j++)\\n            {\\n                long long x = p-j;\\n                long long common = __gcd(x,deno);\\n                x/=common;\\n                deno/=common;\\n                val*=x;\\n                val%=(mod);\\n            }\\n            ncr[i]=val;\\n        }\\n        \\n        vector<vector<long long>> dp(15,vector<long long>(k+1,0));\\n        \\n        for(int i=1; i<=k; i++)\\n            dp[1][i]=1;\\n        \\n        long long res = k;\\n        \\n        for(int len=2; len<15; len++)\\n        {\\n            for(int i=1; i<=k; i++)\\n            {\\n                long long count=0;\\n                for(auto num: factors[i])\\n                count+=(dp[len-1][num]);\\n                \\n                count%=mod;\\n                dp[len][i]=count;\\n                \\n                // count of array of size len\\n                \\n                res+=((count*ncr[len])%mod);\\n                res%=mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int idealArrays(int n, int maxValue) {\\n        \\n        int k = maxValue;\\n        vector<int> factors[k+1];\\n\\t\\t\\n        //factors of all the numbers \\n        for(int i=1; i<=k; i++)\\n        {\\n            for(int j=(2*i); j<=k; j+=i)\\n            factors[j].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2279901,
                "title": "python-optimized-2d-dp-w-combinatorics-o-mlogmlogn-vs-naive-1d-dp-but-tle-o-mnlogm",
                "content": "2D DP w/ combinatorics\\n\\n```python\\ndef idealArrays(self, n, m):                                                               # O(MlogMlogN)\\n\\n    A = list(itertools.accumulate(range(1, 14), lambda a, i: a * (n - i) // i, initial=1)) # O(logN)\\n    dp = [[not i] * m for i in range(14)]                                                  # O(MlogN)\\n\\n    for i in range(13):                                                                    # O(logN)\\n        for j in range(m):                                                                 # O(M)\\n            for k in range(2 * j + 1, m, j + 1):                                           # O(logM) amortized\\n                dp[i + 1][k] += dp[i][j]\\n\\n    return sum(A[i] * sum(dp[i]) for i in range(14)) % (10 ** 9 + 7)                       # O(MlogN)\\n\\n```\\n\\n1D DP but *TLE :(*\\n\\n```python\\ndef idealArrays(self, n, m):                                                               # O(MNlogM)\\n    dp = [0] + [1] * m\\n    for _ in range(1, n):\\n        for i in range(1, m + 1):\\n            for j in range(2 * i, m + 1, i):\\n                dp[i] += dp[j]\\n    return sum(dp) % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef idealArrays(self, n, m):                                                               # O(MlogMlogN)\\n\\n    A = list(itertools.accumulate(range(1, 14), lambda a, i: a * (n - i) // i, initial=1)) # O(logN)\\n    dp = [[not i] * m for i in range(14)]                                                  # O(MlogN)\\n\\n    for i in range(13):                                                                    # O(logN)\\n        for j in range(m):                                                                 # O(M)\\n            for k in range(2 * j + 1, m, j + 1):                                           # O(logM) amortized\\n                dp[i + 1][k] += dp[i][j]\\n\\n    return sum(A[i] * sum(dp[i]) for i in range(14)) % (10 ** 9 + 7)                       # O(MlogN)\\n\\n```\n```python\\ndef idealArrays(self, n, m):                                                               # O(MNlogM)\\n    dp = [0] + [1] * m\\n    for _ in range(1, n):\\n        for i in range(1, m + 1):\\n            for j in range(2 * i, m + 1, i):\\n                dp[i] += dp[j]\\n    return sum(dp) % (10 ** 9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2275241,
                "title": "racket-multicombination-solution-and-explanation",
                "content": "If you don\\'t know multicombination, see [wikipedia](https://en.wikipedia.org/wiki/Combination).\\nBasically, it means pick `k` same elements and put them into `n` positions, and each position\\ncan contain multiple elements. Its value is `mcomb(n,k) = binomial(n+k-1, k)`.\\n\\nBack to our problem, assume the sequence is `y[0], y[1], ..., y[n-1]`.\\nLet\\'s insert a dummy element `1` in front of the sequence, and get `y[0]=1, y[1], y[2], ..., y[n]`.\\nLet `c[i] = y[i] / y[i-1]`. Then we get\\n\\n```\\nc[1] * c[2] * ... * c[n] = y[n]\\n```\\n\\nwhere `1 <= c[i] <= y[n]`.\\nThat means the number of all possible `c` is product of the multicombination of each prime factor of `y[n]`.\\n\\nWe can enumerate all `y[n]` (`1 <= y[n] <= maxValue`), and get its all prime factors and their multicombination.\\n\\n**Example**\\n\\nLet `y[n]=12`, its prime factors is `2, 2, 3`, `n=3`.\\n\\nThe array `c` may be (length of `c` is `n-1`)\\n\\n```\\n// 2\\'s multicombination\\n// mcomb(n, 2) = 6 times\\n1, 1\\n1, 2\\n2, 1\\n2, 2\\n(2*2), 1\\n1, (2*2)\\n// 3\\'s multicombination\\n// mcomb(n,1) = 3 times\\n1, 1\\n1, 3\\n3, 1\\n```\\n\\nthat is `6 * 3 = 18` sequences. So the number of sequences that length 3 and ends with 12 are 18.\\n\\n**Code**\\n\\n```scheme\\n(define/contract (ideal-arrays n m)\\n  (-> exact-integer? exact-integer? exact-integer?)\\n\\n  (define (mod x) (modulo x (+ #e1e9 7)))\\n\\n  (define-syntax-rule (while cond body ...)\\n    (do () ((not cond))\\n      body ...))\\n\\n  (define (factors x)\\n    (let ([m (make-hash)])\\n      (for ([j (range 2 (add1 (sqrt x)))])\\n        (while (= 0 (modulo x j))\\n          (set! x (/ x j))\\n          (hash-update! m j add1 0)))\\n      (when (> x 1)\\n        (hash-update! m x add1 0))\\n      m))\\n\\n  (define (count-endwith x)\\n    (for/fold ([p 1])\\n              ([(_ fcnt) (factors x)])\\n      (mod (* p (binomial (+ n fcnt -1) fcnt)))))\\n\\n  (for/fold ([ret 0])\\n            ([i (range 1 (add1 m))])\\n    (mod (+ ret (count-endwith i)))))\\n```\\n\\nTime: `O(m * sqrt(m))`.",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```\\nc[1] * c[2] * ... * c[n] = y[n]\\n```\n```\\n// 2\\'s multicombination\\n// mcomb(n, 2) = 6 times\\n1, 1\\n1, 2\\n2, 1\\n2, 2\\n(2*2), 1\\n1, (2*2)\\n// 3\\'s multicombination\\n// mcomb(n,1) = 3 times\\n1, 1\\n1, 3\\n3, 1\\n```\n```scheme\\n(define/contract (ideal-arrays n m)\\n  (-> exact-integer? exact-integer? exact-integer?)\\n\\n  (define (mod x) (modulo x (+ #e1e9 7)))\\n\\n  (define-syntax-rule (while cond body ...)\\n    (do () ((not cond))\\n      body ...))\\n\\n  (define (factors x)\\n    (let ([m (make-hash)])\\n      (for ([j (range 2 (add1 (sqrt x)))])\\n        (while (= 0 (modulo x j))\\n          (set! x (/ x j))\\n          (hash-update! m j add1 0)))\\n      (when (> x 1)\\n        (hash-update! m x add1 0))\\n      m))\\n\\n  (define (count-endwith x)\\n    (for/fold ([p 1])\\n              ([(_ fcnt) (factors x)])\\n      (mod (* p (binomial (+ n fcnt -1) fcnt)))))\\n\\n  (for/fold ([ret 0])\\n            ([i (range 1 (add1 m))])\\n    (mod (+ ret (count-endwith i)))))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273598,
                "title": "same-solution-in-python-gives-tle-but-it-runs-in-c",
                "content": "const int mod = 1e9+7;\\nconst int N = 1e4+1;\\n\\nint dp[15][N];\\nint lengths[N][15];\\n\\nclass Solution {\\n    // lengths[j][k] --> How many unique paths are there that ends at \\'j\\' & have length of \\'k\\'\\n    void CalculateUniquePathLengths () {\\n        memset(lengths, 0, sizeof(lengths));\\n        // cout<<N;\\n\\n        for (int j = 1; j < N; j ++) {\\n            // contribute \\'j\\' to its every multiples\\n            lengths[j][1] = 1;\\n            for (int k = j+j; k < N; k += j) {\\n                for (int i = 0; i < 14; i ++) lengths[k][i+1] += lengths[j][i];\\n            }\\n        }\\n    }\\n    \\n    // How many unique arrangement of length \\'length\\' & having all the values from [1 ..X]\\n    int UniqueArrangements (int length, int mx) {\\n        if (length == 0) return (mx == 0);\\n        if (mx == 0) return 0;\\n        \\n        int &an = dp[mx][length];\\n        if (an != -1) return an;\\n        \\n        an = (UniqueArrangements(length-1, mx) + UniqueArrangements(length-1, mx-1)) % mod;\\n        return an;\\n    }\\n    \\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        CalculateUniquePathLengths();\\n        // cout<<UniqueArrangements(5,2);\\n        int ans = 0;\\n        for (int last = 1; last <= maxValue; last ++) {            \\n            for (int j = 1; j < 15; j ++) {\\n                long long arrangementsWithEverything = UniqueArrangements(n, j);\\n                \\n                ans = (ans + (arrangementsWithEverything * lengths[last][j]) % mod) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\nPython code :\\nclass Solution:\\n    def __init__(self):\\n        self.mod=10**9+7\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        lenn=10**4+1\\n        \\n        lenar=[[0 for i in range(15)]for i in range(lenn)]\\n        @cache\\n        def nouniq(num,x):\\n            if num==0:\\n                if x==0:\\n                    return 1\\n                else:\\n                    return 0\\n                \\n            if x==0:\\n                return 0\\n            \\n            return (nouniq(num-1,x)%self.mod+nouniq(num-1,x-1)%self.mod)%self.mod\\n        \\n        def lennarr():\\n            \\n            for i in range(1,lenn):\\n                j=i+i\\n                lenar[i][1]=1\\n                while(j<lenn):\\n                    for k in range(14):\\n                        \\n                        lenar[j][k+1]+=lenar[i][k]\\n                    \\n                    j+=i\\n                    \\n        \\n        lennarr()\\n#         print(lenar)\\n            \\n        \\n#         print(nouniq(5,2))\\n        ans=0\\n        for i in range(1,maxValue+1):\\n            for j in range(15):\\n                hh=nouniq(n,j)\\n                \\n                ans=(ans+((hh*lenar[i][j])%self.mod))%self.mod\\n                \\n        return ans\\n            \\n            \\n        \\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "class Solution {\\n    // lengths[j][k] --> How many unique paths are there that ends at \\'j\\' & have length of \\'k\\'\\n    void CalculateUniquePathLengths () {\\n        memset(lengths, 0, sizeof(lengths));\\n        // cout<<N;\\n\\n        for (int j = 1; j < N; j ++) {\\n            // contribute \\'j\\' to its every multiples\\n            lengths[j][1] = 1;\\n            for (int k = j+j; k < N; k += j) {\\n                for (int i = 0; i < 14; i ++) lengths[k][i+1] += lengths[j][i];\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 2268500,
                "title": "c-dp-topdown-beats-100-easy-codes",
                "content": "time: `O(maxVal*min(log(maxVal), n))`\\n```\\nconst int mod = 1e9+7;\\nint pascal[10000][15];\\nbool pred = false;\\nclass Solution {\\n    void pre() { // calculate pascal triangle for combinatorics\\n        pascal[0][0] = pascal[1][0] = pascal[1][1] = 1;\\n        for (int i = 2; i < 10000; i++) {\\n            pascal[i][0] = 1;\\n            if (i < 15) pascal[i][i] = 1;\\n            for (int j = 1; j < min(i, 15); j++) {\\n                pascal[i][j] = (pascal[i-1][j-1]+pascal[i-1][j])%mod;\\n            }\\n        }\\n        \\n    }\\n    \\npublic:\\n    int idealArrays(int n, int mv) {        \\n        if (!pred) {\\n            pre();\\n            pred = true;\\n        }\\n        \\n        // 2^0, 2^1, 2^2, .... 2^13 < 10000 < 2^14\\n        // we have depth 14 at most for the search graph\\n        // it means that we have 14 distinct integers at most for a size 10000 ideal array\\n        int maxn = min(n, 14);\\n        auto dp = new int*[maxn];\\n        for (int i = 0; i < maxn; i++) {\\n            dp[i] = new int[mv+1];\\n            fill_n(dp[i], mv+1, -1);\\n        }\\n        int ans = 0;\\n        // ideal arrays with value start from 1, 2, ..., maxValue\\n        for (int v = 1; v <= mv; v++) \\n            ans = (ans+dfs(0, n, v, mv, dp))%mod;\\n        return ans;\\n    }\\n\\n    // ith node, size n array, current val, maxval, dp\\n    int dfs(int i, int n, int v, int mv, int** dp) {   \\n        if (i+1 == n) return 1; // number of distinct values is equal to the desired array size\\n        if (dp[i][v] != -1) return dp[i][v];\\n        \\n        // res: use (i+1) distinct values to form a size n ideal array\\n        // the use v as the rest of values\\n        // ex: i = 1, n = 3, v = 2 => [1, 2, 2]\\n        int res = pascal[n-1][i]; \\n        // enumerate the next distinct value\\n        for (int m = 2; m*v <= mv; m++) {\\n            res = (res+dfs(i+1, n, m*v, mv, dp))%mod;\\n        }\\n        return dp[i][v] = res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int mod = 1e9+7;\\nint pascal[10000][15];\\nbool pred = false;\\nclass Solution {\\n    void pre() { // calculate pascal triangle for combinatorics\\n        pascal[0][0] = pascal[1][0] = pascal[1][1] = 1;\\n        for (int i = 2; i < 10000; i++) {\\n            pascal[i][0] = 1;\\n            if (i < 15) pascal[i][i] = 1;\\n            for (int j = 1; j < min(i, 15); j++) {\\n                pascal[i][j] = (pascal[i-1][j-1]+pascal[i-1][j])%mod;\\n            }\\n        }\\n        \\n    }\\n    \\npublic:\\n    int idealArrays(int n, int mv) {        \\n        if (!pred) {\\n            pre();\\n            pred = true;\\n        }\\n        \\n        // 2^0, 2^1, 2^2, .... 2^13 < 10000 < 2^14\\n        // we have depth 14 at most for the search graph\\n        // it means that we have 14 distinct integers at most for a size 10000 ideal array\\n        int maxn = min(n, 14);\\n        auto dp = new int*[maxn];\\n        for (int i = 0; i < maxn; i++) {\\n            dp[i] = new int[mv+1];\\n            fill_n(dp[i], mv+1, -1);\\n        }\\n        int ans = 0;\\n        // ideal arrays with value start from 1, 2, ..., maxValue\\n        for (int v = 1; v <= mv; v++) \\n            ans = (ans+dfs(0, n, v, mv, dp))%mod;\\n        return ans;\\n    }\\n\\n    // ith node, size n array, current val, maxval, dp\\n    int dfs(int i, int n, int v, int mv, int** dp) {   \\n        if (i+1 == n) return 1; // number of distinct values is equal to the desired array size\\n        if (dp[i][v] != -1) return dp[i][v];\\n        \\n        // res: use (i+1) distinct values to form a size n ideal array\\n        // the use v as the rest of values\\n        // ex: i = 1, n = 3, v = 2 => [1, 2, 2]\\n        int res = pascal[n-1][i]; \\n        // enumerate the next distinct value\\n        for (int m = 2; m*v <= mv; m++) {\\n            res = (res+dfs(i+1, n, m*v, mv, dp))%mod;\\n        }\\n        return dp[i][v] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267505,
                "title": "dfs-memo-please-help-tle",
                "content": "DFS + memo should work logically, but I got TLE for the test [n = 9767, max = 9557]. Can someone please help how to optimize?\\n\\n```\\nclass Solution {\\n    int mod = 1000000007, n, max;\\n    int[][] memo;\\n    \\n    public int idealArrays(int n, int maxValue) {\\n        this.memo = new int[n + 1][maxValue + 1];\\n        this.n = n;\\n        this.max = maxValue;\\n        return dfs(0, 1);\\n    }\\n    \\n\\t// \\'p\\' is the previous value.\\n    int dfs(int i, int p) {\\n        if (i > n) return 0;\\n        if (i == n) return 1;\\n        if (memo[i][p] > 0) return memo[i][p];\\n        \\n        for (int v = p; v <= max; v += p) {\\n            memo[i][p] = (memo[i][p] + dfs(i + 1, v)) % mod;\\n        }\\n        return memo[i][p];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007, n, max;\\n    int[][] memo;\\n    \\n    public int idealArrays(int n, int maxValue) {\\n        this.memo = new int[n + 1][maxValue + 1];\\n        this.n = n;\\n        this.max = maxValue;\\n        return dfs(0, 1);\\n    }\\n    \\n\\t// \\'p\\' is the previous value.\\n    int dfs(int i, int p) {\\n        if (i > n) return 0;\\n        if (i == n) return 1;\\n        if (memo[i][p] > 0) return memo[i][p];\\n        \\n        for (int v = p; v <= max; v += p) {\\n            memo[i][p] = (memo[i][p] + dfs(i + 1, v)) % mod;\\n        }\\n        return memo[i][p];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267096,
                "title": "python-short-solution-with-intuitive-approach-n-logn",
                "content": "**Observations**:\\n   1. The number of distinct elements in the array can not exceed `log2(maxValue)+1`\\n   2.  Let `X` be a set of  `k` distinct numbers whose every element is divided by its previous one, then the number of ways to make the required array using all elements of `X` solely is equal to the number of ways to partition the array into `k` groups.\\n\\nSo a trivial approach we can easily come up with is to caculate the total number of valid sets `X` for  every length `k` from `1` to `log2(maxValue)+1`. The number of valid arrays with `k` distinct elements would then be the number of  valid sets `X` times number of ways to partition the array into `k` groups.\\n\\n<details>\\n<summary>Detail </summary>\\n\\n1. To caculate the number of sets `X` with k distinct elements, we can use the following dynamic programming approach:\\n\\tLet `f(i,k)` be the number of sets `X` with its greatest element is `i`, then `f(i,k)=sum(f(j,k-1) for every j which i is divided by` . To make this process faster we can use bottom up dp with sieve approach.\\n2. To partition an array of length `n` into `k` groups, its the same as putting `k-1` walls among `n-1` holes of that array, which is **`(n-1)C(k-1)`** (combinatoric formula.\\n\\t\\n</details>\\n\\n```python\\n def idealArrays(self, n: int, maxValue: int) -> int:\\n        M = 10 ** 9 + 7\\n        A = [[0] * (maxValue+1) for _ in range(15)]\\n        res = 0\\n        comb = A[0][1] = A[1][1] = 1\\n        for j in range(1, min(15, n+1)):\\n            for i in range(1, maxValue+1):\\n                for k in range(i*2, maxValue+1, i):\\n                    A[j][k] = (A[j][k]+A[j-1][i]) % M\\n            res = (res + sum(A[j]) * comb % M) % M\\n            comb = comb * (n-j) * pow(j,M-2,M) % M \\n        return res \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n def idealArrays(self, n: int, maxValue: int) -> int:\\n        M = 10 ** 9 + 7\\n        A = [[0] * (maxValue+1) for _ in range(15)]\\n        res = 0\\n        comb = A[0][1] = A[1][1] = 1\\n        for j in range(1, min(15, n+1)):\\n            for i in range(1, maxValue+1):\\n                for k in range(i*2, maxValue+1, i):\\n                    A[j][k] = (A[j][k]+A[j-1][i]) % M\\n            res = (res + sum(A[j]) * comb % M) % M\\n            comb = comb * (n-j) * pow(j,M-2,M) % M \\n        return res \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2266997,
                "title": "can-anyone-help-in-optimising-this-solved-it-using-dp-approach-and-has-three-nested-loops",
                "content": "Total no. of arrays of size i and ending with j can be calculated by adding total number of arrays of size (i-1) and ending with each factor of j.\\nCan I somehow reduce it to two nested loops only?\\n```class Solution {\\npublic:\\n    int idealArrays(int n, int maxValue)\\n    {\\n        const int m = 1e9+7;\\n        vector<vector<int>> dp(n+1,vector<int>(maxValue+1,0));\\n        vector<int> v(maxValue+1,-1);\\n        vector<vector<int>> fac(maxValue+1,vector<int>(maxValue+1,-1));\\n        for(int i=1; i<=maxValue; i++)\\n        {\\n            int x=0;\\n            for(int j=1; j<=i; j++)\\n            {\\n                if(i%j==0)\\n                {\\n                    fac[i][j]=j;\\n                    x++;\\n                    x%=m;\\n                }\\n            }\\n            v[i]=x;\\n        }\\n        for(int i=1; i<=maxValue; i++) dp[2][i]=v[i];\\n        \\n        for(int i=2; i<=n; i++) dp[i][1]=1;\\n        \\n        \\n        \\n        for(int i=3; i<=n; i++)\\n        {\\n            for(int j=2; j<=maxValue; j++)\\n            {\\n                for(auto c:fac[j]) if(c>0) {dp[i][j]+=dp[i-1][c]; dp[i][j]%=m;}\\n                \\n            }\\n        }\\n        int y=0;\\n        for(int i=1; i<=maxValue; i++)\\n        {\\n            y+=dp[n][i];\\n            y%=m;\\n        }\\n        return y;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int idealArrays(int n, int maxValue)\\n    {\\n        const int m = 1e9+7;\\n        vector<vector<int>> dp(n+1,vector<int>(maxValue+1,0));\\n        vector<int> v(maxValue+1,-1);\\n        vector<vector<int>> fac(maxValue+1,vector<int>(maxValue+1,-1));\\n        for(int i=1; i<=maxValue; i++)\\n        {\\n            int x=0;\\n            for(int j=1; j<=i; j++)\\n            {\\n                if(i%j==0)\\n                {\\n                    fac[i][j]=j;\\n                    x++;\\n                    x%=m;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2265984,
                "title": "java-straight-forward-solution-for-beginners-detailed-explanation",
                "content": "* Let\\'s understand the example first:\\n3 10\\n\\t\\t\\t\\t\\t\\tone component : (n+power-1) C (power), may have more than 1 items to multiply\\n1  =                 |  1         = 1  -> 111\\n2  = 2(1)          |  3C1       = 3  -> 112 122 222\\n3  = 3(1)          |  3C1       = 3  -> 113 133 333\\n4  = 2(2)          |  4C2       = 6  -> 114 124 144 224 244 444\\n5  = 5(1)          |  3C1       = 3  -> 115 155 555\\n6  = 2(1), 3(1)  |  3C1 * 3C1 = 9  -> 116 126 136 166 226 336 366 266 666\\n7  = 7(1)          |  3C1       = 3  -> 117 177 777\\n8  = 2(3)          |  5C3       = 10 -> 118 128 148 188 228 248 288 448 488 888\\n9  = 3(2)          |  4C2       = 6  -> 119 139 199 339 399 999\\n10 = 2(1), 5(1) |  3C1 * 3C1 = 9  -> 11X 12X 15X 1XX 22X 55X 2XX 5XX XXX\\n                             \\n* The main thought is using main map to save previous results, map_primeDecomposition to save how nums are decomposed by power of primes. For each factors that are purely power of one primes, using previous results to save time (dynamic programming part). For Example: 100 = 2^2 * 5^2 = main.get(4) * main.get(25).\\n\\n* Finally consider modular inverse part, please see the link in the comment. Implementation is easier than proof. The reason to use that is when calculating combination, denominator factorial(m) will exceed the limit, using inv[i] to replace i^-1.\\n\\nPlease upvote if this helps, THX!\\n\\nJava Code:\\n\\n```\\n\\tstatic int mod = (int) 1e9 + 7;\\n\\n    public static int idealArrays(int n, int maxValue) {\\n        // calculate modular inverse\\n        int maxDistinct = (int) (Math.log(maxValue) / Math.log(2)) + 1;\\n        // https://cp-algorithms.com/algebra/module-inverse.html#mod-inv-all-num\\n        long[] invs = new long[maxDistinct + 1];\\n        invs[1] = 1;\\n        for (int i = 2; i < invs.length; i++) {\\n            invs[i] = mod - mod / i * invs[mod % i] % mod;\\n        }\\n\\n        Map<Integer, Long> main = new HashMap<>();\\n        long res = 1;\\n        List<Integer> primeList = new ArrayList<>();\\n        for (int i = 2; i <= maxValue; i++) {\\n            int temp = i;\\n            Map<Integer, Integer> map_primeDecomposition = new HashMap<>();\\n            for (int prime : primeList) {\\n                int ct = 0;\\n                while (temp % prime == 0) {\\n                    ct++;\\n                    temp /= prime;\\n                }\\n                if (ct != 0)\\n                    map_primeDecomposition.put(prime, ct);\\n            }\\n\\n            if (map_primeDecomposition.isEmpty()) {\\n                primeList.add(i);\\n                main.put(i, (long) n);\\n                res = (res + n) % mod;\\n//                System.out.println(i + \" \" + n);\\n            } else {\\n                long tempRes = 1;\\n                for (Map.Entry<Integer, Integer> e : map_primeDecomposition.entrySet()) {\\n                    int prime = e.getKey();\\n                    int power = e.getValue();\\n                    int powerOfPrime = (int) Math.pow(prime, power);\\n                    if (main.containsKey(powerOfPrime))\\n                        tempRes = (tempRes * main.get(powerOfPrime)) % mod;\\n                    else\\n                        tempRes = (tempRes * combination(power, n + power - 1, invs)) % mod;\\n                }\\n                main.put(i, tempRes);\\n                res = (res + tempRes) % mod;\\n//                System.out.println(i + \" \" + tempRes);\\n            }\\n        }\\n\\n        return (int) res;\\n    }\\n\\n    private static long combination(int m, int n, long[] invs) {\\n        long res = 1;\\n        for (int i = 0; i < m; i++) {\\n            res = (res * n) % mod * invs[i + 1] % mod;\\n            n--;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\n\\tstatic int mod = (int) 1e9 + 7;\\n\\n    public static int idealArrays(int n, int maxValue) {\\n        // calculate modular inverse\\n        int maxDistinct = (int) (Math.log(maxValue) / Math.log(2)) + 1;\\n        // https://cp-algorithms.com/algebra/module-inverse.html#mod-inv-all-num\\n        long[] invs = new long[maxDistinct + 1];\\n        invs[1] = 1;\\n        for (int i = 2; i < invs.length; i++) {\\n            invs[i] = mod - mod / i * invs[mod % i] % mod;\\n        }\\n\\n        Map<Integer, Long> main = new HashMap<>();\\n        long res = 1;\\n        List<Integer> primeList = new ArrayList<>();\\n        for (int i = 2; i <= maxValue; i++) {\\n            int temp = i;\\n            Map<Integer, Integer> map_primeDecomposition = new HashMap<>();\\n            for (int prime : primeList) {\\n                int ct = 0;\\n                while (temp % prime == 0) {\\n                    ct++;\\n                    temp /= prime;\\n                }\\n                if (ct != 0)\\n                    map_primeDecomposition.put(prime, ct);\\n            }\\n\\n            if (map_primeDecomposition.isEmpty()) {\\n                primeList.add(i);\\n                main.put(i, (long) n);\\n                res = (res + n) % mod;\\n//                System.out.println(i + \" \" + n);\\n            } else {\\n                long tempRes = 1;\\n                for (Map.Entry<Integer, Integer> e : map_primeDecomposition.entrySet()) {\\n                    int prime = e.getKey();\\n                    int power = e.getValue();\\n                    int powerOfPrime = (int) Math.pow(prime, power);\\n                    if (main.containsKey(powerOfPrime))\\n                        tempRes = (tempRes * main.get(powerOfPrime)) % mod;\\n                    else\\n                        tempRes = (tempRes * combination(power, n + power - 1, invs)) % mod;\\n                }\\n                main.put(i, tempRes);\\n                res = (res + tempRes) % mod;\\n//                System.out.println(i + \" \" + tempRes);\\n            }\\n        }\\n\\n        return (int) res;\\n    }\\n\\n    private static long combination(int m, int n, long[] invs) {\\n        long res = 1;\\n        for (int i = 0; i < m; i++) {\\n            res = (res * n) % mod * invs[i + 1] % mod;\\n            n--;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2265550,
                "title": "c-stars-and-bars-explanation-in-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int idealArrays(int n, int maxValue) {\\n        // compute and store c[i] = C_(i+n-1)^(n-1) in the end\\n        // initial with n=2, c[i] = i+1;\\n        // 16 is enough since 2^14>10^4, we won\\'t see any number has a\\n        // prime factor with exponent>16 in this problem\\n        vector<int> c(16, 1);\\n        for(int i=1; i<16; i++) c[i] = i+1;\\n        for(int k=3; k<=n; k++){\\n          for(int i=1; i<16; i++){\\n            // C_(i+k-1)^(k-1) = C_(i-1+k-1)^(k-1)+C_(i-1+k-1)^(k-1-1)\\n            c[i] = (c[i-1]+c[i])%mod;\\n          }\\n        }\\n      \\n        // [1,1,...,1]\\n        int ret = 1;\\n      \\n        for(int j=2; j<=maxValue; j++){\\n          // count number of ideal arrays end with j\\n          // i.e., distribute each prime factors of j independently to n slots\\n          // for prime factor with exponent 1: C_(n)^(n-1)=n\\n          // for prime factor with exponent k: C_(k+n-1)^(n-1) (stars-bars theorem with >=0 case)\\n          ret = (ret + helper(j, c))%mod;\\n        }\\n      \\n      return ret;\\n    }\\n  \\n  long long helper(int j, vector<int>& c){\\n    int tmp = j;\\n    long long cnt = 1;\\n    for(int p=2; p*p<=j; p++){\\n      int exp = 0;\\n      while(tmp%p==0) {tmp /= p; exp++;}\\n      if(exp>0){\\n        cnt *= c[exp];\\n        cnt %= mod;\\n      }\\n    }\\n    // if j is a prime number\\n    if(tmp>1){\\n      cnt *= c[1];\\n      cnt %= mod;\\n    }\\n    return cnt;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int idealArrays(int n, int maxValue) {\\n        // compute and store c[i] = C_(i+n-1)^(n-1) in the end\\n        // initial with n=2, c[i] = i+1;\\n        // 16 is enough since 2^14>10^4, we won\\'t see any number has a\\n        // prime factor with exponent>16 in this problem\\n        vector<int> c(16, 1);\\n        for(int i=1; i<16; i++) c[i] = i+1;\\n        for(int k=3; k<=n; k++){\\n          for(int i=1; i<16; i++){\\n            // C_(i+k-1)^(k-1) = C_(i-1+k-1)^(k-1)+C_(i-1+k-1)^(k-1-1)\\n            c[i] = (c[i-1]+c[i])%mod;\\n          }\\n        }\\n      \\n        // [1,1,...,1]\\n        int ret = 1;\\n      \\n        for(int j=2; j<=maxValue; j++){\\n          // count number of ideal arrays end with j\\n          // i.e., distribute each prime factors of j independently to n slots\\n          // for prime factor with exponent 1: C_(n)^(n-1)=n\\n          // for prime factor with exponent k: C_(k+n-1)^(n-1) (stars-bars theorem with >=0 case)\\n          ret = (ret + helper(j, c))%mod;\\n        }\\n      \\n      return ret;\\n    }\\n  \\n  long long helper(int j, vector<int>& c){\\n    int tmp = j;\\n    long long cnt = 1;\\n    for(int p=2; p*p<=j; p++){\\n      int exp = 0;\\n      while(tmp%p==0) {tmp /= p; exp++;}\\n      if(exp>0){\\n        cnt *= c[exp];\\n        cnt %= mod;\\n      }\\n    }\\n    // if j is a prime number\\n    if(tmp>1){\\n      cnt *= c[1];\\n      cnt %= mod;\\n    }\\n    return cnt;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265521,
                "title": "anybody-help-me-check-what-s-the-problem-thx",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int idealArrays(int n, int maxValue) {\\n        long mod = 1000000007;\\n        \\n        long[][] dp = new long[maxValue+1][n+1]; \\n        for (int i = 0; i <= maxValue; i++) dp[i][1] = 1;\\n        \\n        for (int i = maxValue; i >= 1; i--){\\n            for (int j = 1; j <= n; j++){\\n                int times = maxValue / i;\\n                for (int m = 1; m <= times; m++){\\n                    dp[i][j] = (dp[i][j] + dp[m*i][j-1]) % mod;\\n                }\\n            }\\n            //System.out.print(1);\\n        }\\n        \\n        long ans = 0;\\n        for (int i = 1; i <= maxValue; i++) {\\n            ans = (ans + dp[i][n]) % mod;\\n            //System.out.println(ans);\\n        }\\n        return (int)ans;\\n    }\\n}\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int idealArrays(int n, int maxValue) {\\n        long mod = 1000000007;\\n        \\n        long[][] dp = new long[maxValue+1][n+1]; \\n        for (int i = 0; i <= maxValue; i++) dp[i][1] = 1;\\n        \\n        for (int i = maxValue; i >= 1; i--){\\n            for (int j = 1; j <= n; j++){\\n                int times = maxValue / i;\\n                for (int m = 1; m <= times; m++){\\n                    dp[i][j] = (dp[i][j] + dp[m*i][j-1]) % mod;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2265500,
                "title": "c-dfs-dfs-memo-dp",
                "content": "DFS\\n```\\ntypedef long long LL;\\n\\nconst int M = 15, N = 10010, mod = 1e9 + 7;\\n\\nclass Solution {\\n    int n, m;\\n    int ans = 0;\\n    int c[N][M] = {};\\n    \\n    void dp(int i, int j)\\n    {\\n        ans = ((LL)ans + c[n - 1][i - 1]) % mod;\\n        if (i == n)\\n            return;\\n        for (int k = j * 2; k <= m; k += j) dp(i + 1, k);\\n    }\\n\\npublic:\\n\\n    int idealArrays(int _n, int _m) {\\n        n = _n, m = _m;\\n        for (int i = 0; i <= n; ++ i) // n\\n        {\\n            for (int j = 0; j < M && j <= i; ++ j) // m \\n            {\\n                if (!j) c[i][j] = 1;\\n                else c[i][j] = ((LL)c[i - 1][j - 1] + c[i - 1][j]) % mod;\\n            }\\n        }\\n        \\n        for (int i = 1; i <= m; ++ i)\\n            dp(1, i);\\n        return ans;\\n    }\\n\\n};\\n\\n/*\\n    C(m, n) = C(m - 1, n) + C(m - 1, n - 1)\\n\\n\\n*/\\n```\\nDFS with memorization\\n```\\ntypedef long long LL;\\n\\nconst int M = 15, N = 10010, mod = 1e9 + 7;\\n\\n\\nclass Solution {\\n    int c[N][M] = {};\\n    int f[M][N] = {}; \\n    /*\\n    dp:\\n        state: f[i][j] - the number of ways of length i and last number is j\\n        transition: f[i + 1][j * k] += f[i][j]\\n                    C(n - 1, i - 1)\\n    */\\npublic:\\n    int dp(int i, int j)\\n    {\\n        if (f[i][j] != -1) return f[i][j];\\n        if (i == 1) return f[i][j] = 1;\\n        \\n        f[i][j] = 0;\\n        if (j != 1)\\n        {\\n            f[i][j] = ((LL)f[i][j] + dp(i - 1, 1)) % mod;\\n        }\\n        for (int k = 2; k <= j / k; ++ k)\\n        {\\n            if (j % k) continue;\\n            f[i][j] = ((LL)f[i][j] + dp(i - 1, k)) % mod;\\n            if (j / k != k) f[i][j] = ((LL)f[i][j] + dp(i - 1, j / k)) % mod;\\n        }\\n        return f[i][j];\\n    }\\n    \\n    int idealArrays(int n, int m) {\\n        \\n        memset(f, -1, sizeof f);\\n        \\n        for (int i = 0; i <= n; ++ i) // n\\n            for (int j = 0; j < M && j <= i; ++ j) // m \\n                if (!j) c[i][j] = 1;\\n                else c[i][j] = ((LL)c[i - 1][j - 1] + c[i - 1][j]) % mod;\\n        \\n        for (int i = 1; i <= n && i <= 14; ++ i)\\n            for (int j = 1; j <= m; ++ j)\\n                dp(i, j);\\n        \\n        \\n        int ans = 0;\\n        for (int i = 1; i <= n && i <= 14; ++ i)  // at most 14 distinct numbers in the sequence\\uFF0C2^0 + 2^1 + ... + 2^13(8x1e3)\\n        {\\n            for (int j = 1; j <= m; ++ j)\\n            {\\n                if (i > n || f[i][j] == -1) continue;\\n                ans = ((LL)ans + (LL)f[i][j] * c[n - 1][i - 1] % mod) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nDP\\n```\\ntypedef long long LL;\\n\\nconst int M = 15, N = 10010, mod = 1e9 + 7;\\n\\nclass Solution {\\n    int c[N][M] = {};\\n    int f[M][N] = {}; \\n    /*\\n    dp:\\n        state: f[i][j] - the number of ways of length i and last number is j\\n        transition: f[i + 1][j * k] = f[i][j]\\n                    C(n - 1, i - 1)\\n    */\\n\\npublic:\\n\\n    int idealArrays(int n, int m) {\\n        for (int i = 0; i <= n; ++ i) // n\\n            for (int j = 0; j < M && j <= i; ++ j) // m \\n                if (!j) c[i][j] = 1;\\n                else c[i][j] = ((LL)c[i - 1][j - 1] + c[i - 1][j]) % mod;\\n\\n        for (int i = 1; i <= m; ++ i) f[1][i] = 1;\\n        for (int i = 1; i < 14; ++ i)\\n        {\\n            for (int j = 1; j <= m; ++ j)\\n            {\\n                for (int k = 2; k * j <= m; ++ k)\\n                {\\n                    int& v = f[i + 1][j * k];\\n                    v = ((LL)v + f[i][j]) % mod;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i <= 14; ++ i) \\n        {\\n            for (int j = 1; j <= m; ++ j)\\n            {\\n                if (i > n) continue;\\n                ans = ((LL)ans + (LL)f[i][j] * c[n - 1][i - 1] % mod) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n\\n/*\\n    C(m, n) = C(m - 1, n) + C(m - 1, n - 1)\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long LL;\\n\\nconst int M = 15, N = 10010, mod = 1e9 + 7;\\n\\nclass Solution {\\n    int n, m;\\n    int ans = 0;\\n    int c[N][M] = {};\\n    \\n    void dp(int i, int j)\\n    {\\n        ans = ((LL)ans + c[n - 1][i - 1]) % mod;\\n        if (i == n)\\n            return;\\n        for (int k = j * 2; k <= m; k += j) dp(i + 1, k);\\n    }\\n\\npublic:\\n\\n    int idealArrays(int _n, int _m) {\\n        n = _n, m = _m;\\n        for (int i = 0; i <= n; ++ i) // n\\n        {\\n            for (int j = 0; j < M && j <= i; ++ j) // m \\n            {\\n                if (!j) c[i][j] = 1;\\n                else c[i][j] = ((LL)c[i - 1][j - 1] + c[i - 1][j]) % mod;\\n            }\\n        }\\n        \\n        for (int i = 1; i <= m; ++ i)\\n            dp(1, i);\\n        return ans;\\n    }\\n\\n};\\n\\n/*\\n    C(m, n) = C(m - 1, n) + C(m - 1, n - 1)\\n\\n\\n*/\\n```\n```\\ntypedef long long LL;\\n\\nconst int M = 15, N = 10010, mod = 1e9 + 7;\\n\\n\\nclass Solution {\\n    int c[N][M] = {};\\n    int f[M][N] = {}; \\n    /*\\n    dp:\\n        state: f[i][j] - the number of ways of length i and last number is j\\n        transition: f[i + 1][j * k] += f[i][j]\\n                    C(n - 1, i - 1)\\n    */\\npublic:\\n    int dp(int i, int j)\\n    {\\n        if (f[i][j] != -1) return f[i][j];\\n        if (i == 1) return f[i][j] = 1;\\n        \\n        f[i][j] = 0;\\n        if (j != 1)\\n        {\\n            f[i][j] = ((LL)f[i][j] + dp(i - 1, 1)) % mod;\\n        }\\n        for (int k = 2; k <= j / k; ++ k)\\n        {\\n            if (j % k) continue;\\n            f[i][j] = ((LL)f[i][j] + dp(i - 1, k)) % mod;\\n            if (j / k != k) f[i][j] = ((LL)f[i][j] + dp(i - 1, j / k)) % mod;\\n        }\\n        return f[i][j];\\n    }\\n    \\n    int idealArrays(int n, int m) {\\n        \\n        memset(f, -1, sizeof f);\\n        \\n        for (int i = 0; i <= n; ++ i) // n\\n            for (int j = 0; j < M && j <= i; ++ j) // m \\n                if (!j) c[i][j] = 1;\\n                else c[i][j] = ((LL)c[i - 1][j - 1] + c[i - 1][j]) % mod;\\n        \\n        for (int i = 1; i <= n && i <= 14; ++ i)\\n            for (int j = 1; j <= m; ++ j)\\n                dp(i, j);\\n        \\n        \\n        int ans = 0;\\n        for (int i = 1; i <= n && i <= 14; ++ i)  // at most 14 distinct numbers in the sequence\\uFF0C2^0 + 2^1 + ... + 2^13(8x1e3)\\n        {\\n            for (int j = 1; j <= m; ++ j)\\n            {\\n                if (i > n || f[i][j] == -1) continue;\\n                ans = ((LL)ans + (LL)f[i][j] * c[n - 1][i - 1] % mod) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\ntypedef long long LL;\\n\\nconst int M = 15, N = 10010, mod = 1e9 + 7;\\n\\nclass Solution {\\n    int c[N][M] = {};\\n    int f[M][N] = {}; \\n    /*\\n    dp:\\n        state: f[i][j] - the number of ways of length i and last number is j\\n        transition: f[i + 1][j * k] = f[i][j]\\n                    C(n - 1, i - 1)\\n    */\\n\\npublic:\\n\\n    int idealArrays(int n, int m) {\\n        for (int i = 0; i <= n; ++ i) // n\\n            for (int j = 0; j < M && j <= i; ++ j) // m \\n                if (!j) c[i][j] = 1;\\n                else c[i][j] = ((LL)c[i - 1][j - 1] + c[i - 1][j]) % mod;\\n\\n        for (int i = 1; i <= m; ++ i) f[1][i] = 1;\\n        for (int i = 1; i < 14; ++ i)\\n        {\\n            for (int j = 1; j <= m; ++ j)\\n            {\\n                for (int k = 2; k * j <= m; ++ k)\\n                {\\n                    int& v = f[i + 1][j * k];\\n                    v = ((LL)v + f[i][j]) % mod;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i <= 14; ++ i) \\n        {\\n            for (int j = 1; j <= m; ++ j)\\n            {\\n                if (i > n) continue;\\n                ans = ((LL)ans + (LL)f[i][j] * c[n - 1][i - 1] % mod) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n\\n/*\\n    C(m, n) = C(m - 1, n) + C(m - 1, n - 1)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264785,
                "title": "easy-understanding-java-with-explanation-no-bigint-no-dp-solution-directly-count",
                "content": "1. For any given possible array ended with x, we prime factorize x.( 1 <= x <= maxValue)\\n2. We need to distribute x\\'s factors among n places, for example x = 15, n = 3, we distribute 3, 5 to 3 places:\\n1 --> (place 3) 3 --> (place 5) 15\\n1 --> (place 5) 5 --> (place 3) 15\\n1 --> (place 15) 15 --> 15\\n(place 15) 15 --> 15 --> 15\\n1 --> 1 --> (place 15) 15\\n3 --> 3 --> 15\\n3 --> 15 --> 15\\n5 --> 5 --> 15\\n5 --> 15 --> 15\\ntotally (1 + 3 - 1)C1 * (1 + 3 - 1)C1 = 9 solutions. \\nsame for other number <= maxValue.\\n3.  For any prime factor p, p^m || x, total distribution solutions for this p = solutions of equation ```x_1 + x_2 + ... + x_n = m``` \\n= (m + n - 1)Cm \\n4. so the final answer = Sum of Product{ (m + n - 1)Cm | for any p^m || x } where 1 <= x <= maxValue.\\n\\n```\\nclass Solution {\\n    long mod = 1000000007L;\\n    int idealArrays(int n, int maxValue) {\\n        // precompute all primes up to maxValue\\n        ArrayList<Integer> primes = new ArrayList<>();\\n        for(int i = 2; i <= maxValue; i++) {\\n            if(isPrime(i)) primes.add(i);\\n        }\\n        // set the last value to i\\n        long ans = 0;\\n        for(int i = maxValue; i >= 1; i--) {\\n            long sol = 1L;\\n            for(Integer prime: primes) {\\n                if(prime > i) break;\\n                int dup = 0, el = i;\\n                while(el % prime == 0) {\\n                    dup++;\\n                    el /= prime;\\n                }\\n                // total solutions for x_1 + x_2 + ... + x_n = dup\\n                sol *= comb(n + dup - 1, dup);\\n                sol %= mod;\\n            }\\n            ans += sol;\\n            ans %= mod;\\n        }\\n        return (int) ans;\\n    }\\n\\n    static long[][] comb = new long[10100][14];\\n    long comb(int n, int r) {\\n        if(r == 0 || r == n) return 1L;\\n        if(r == 1 || r == n - 1) return n;\\n        if(comb[n][r] != 0) return comb[n][r];\\n        comb[n][r] = comb(n - 1, r - 1)% mod + comb(n - 1, r) % mod;\\n        return comb[n][r];\\n    }\\n\\n    boolean isPrime(int x) {\\n        for (int d = 2; d * d <= x; d++) {\\n            if (x % d == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "```x_1 + x_2 + ... + x_n = m```",
                "codeTag": "Unknown"
            },
            {
                "id": 2264647,
                "title": "java-dp",
                "content": "```\\nCan anyone improve it\\'s time complexity ? \\n    class Solution {\\n        int MOD = 1_000_000_000 + 7;\\n\\n        public int idealArrays(int n, int maxValue) {\\n            int[][] dp = new int[n][maxValue + 1];\\n            for (int[] d : dp) Arrays.fill(d, -1);\\n            return ds(0, 1, n, maxValue, dp);\\n        }\\n\\n        private int ds(int ind, int l, int n, int maxValue, int[][] dp) {\\n            // base case\\n            if (ind >= n) {\\n                return 1;\\n            }\\n\\n            if (dp[ind][l] != -1) return dp[ind][l];\\n            int take = 0;\\n\\n            for (int i = l; i <= maxValue; i += l) {\\n                take = (take + ds(ind + 1, i, n, maxValue, dp)) % MOD;\\n            }\\n            return dp[ind][l] = take;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nCan anyone improve it\\'s time complexity ? \\n    class Solution {\\n        int MOD = 1_000_000_000 + 7;\\n\\n        public int idealArrays(int n, int maxValue) {\\n            int[][] dp = new int[n][maxValue + 1];\\n            for (int[] d : dp) Arrays.fill(d, -1);\\n            return ds(0, 1, n, maxValue, dp);\\n        }\\n\\n        private int ds(int ind, int l, int n, int maxValue, int[][] dp) {\\n            // base case\\n            if (ind >= n) {\\n                return 1;\\n            }\\n\\n            if (dp[ind][l] != -1) return dp[ind][l];\\n            int take = 0;\\n\\n            for (int i = l; i <= maxValue; i += l) {\\n                take = (take + ds(ind + 1, i, n, maxValue, dp)) % MOD;\\n            }\\n            return dp[ind][l] = take;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264250,
                "title": "python-combinatorics",
                "content": "Inspired by this post\\nhttps://leetcode.com/problems/count-the-number-of-ideal-arrays/discuss/2261280/Python-Arranging-primes-intro-to-combinatorics\\n\\n```\\nclass Solution:\\n    MOD = int(1E9 + 7)    \\n    \\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        import collections\\n        import math\\n        \\n        from typing import List, Mapping\\n        \\n        # Find all primes less than or equal to `maxValue`.\\n        primes = []\\n        sieve = [False for _ in range(maxValue + 1)]\\n        for p in range(2, maxValue + 1):\\n            if sieve[p]:\\n                continue\\n            primes.append(p)\\n            for q in range(p * p, maxValue + 1, p):\\n                sieve[q] = True\\n            \\n        def get_factors(val: int) -> Mapping[int, int]:  \\n            \"\"\"Find all prime factors and their multiplicities of the input.\"\"\"\\n            factors = collections.defaultdict(lambda: 0)\\n            for p in primes:\\n                if p * p > val:\\n                    break\\n                if val % p != 0:\\n                    continue\\n                while val >= p and val % p == 0:\\n                    factors[p] += 1\\n                    val //= p                \\n            if val > 0:\\n                factors[val] = 1\\n                \\n            return factors                    \\n        \\n        def find_num_ideal_arrays(val: int) -> int:\\n            \"\"\"Find number of ideal arrays that ends with the input value.\"\"\"\\n            total = 1\\n            for factor, multiplicity in get_factors(val).items():\\n                if factor == 1:\\n                    continue\\n                m = multiplicity\\n                # Let p = `factor`, m = `multiplicity` and t = `n - 1`, \\n                # we can plot a lattice where there are m + 1 rows and \\n                # t + 1 columns. In this example, m = 3 and t = 3. \\n                # Each path in the lattice graph maps to a sequence\\n                # where a power of p is multiplied to the corresponding position. \\n                #\\n                # 1   o--o--o--o\\n                #     |  |  |  |\\n                # p   o--o--o--o\\n                #     |  |  |  |\\n                # p^2 o--o--o--o\\n                #     |  |  |  |\\n                # p^3 o--o--o--o\\n                # \\n                total = (total * math.comb(m + n - 1, m)) % self.MOD\\n                \\n            return total\\n                        \\n        total = 1\\n        for val in range(2, maxValue + 1):\\n            total = (total + find_num_ideal_arrays(val)) % self.MOD\\n        return total % self.MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    MOD = int(1E9 + 7)    \\n    \\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        import collections\\n        import math\\n        \\n        from typing import List, Mapping\\n        \\n        # Find all primes less than or equal to `maxValue`.\\n        primes = []\\n        sieve = [False for _ in range(maxValue + 1)]\\n        for p in range(2, maxValue + 1):\\n            if sieve[p]:\\n                continue\\n            primes.append(p)\\n            for q in range(p * p, maxValue + 1, p):\\n                sieve[q] = True\\n            \\n        def get_factors(val: int) -> Mapping[int, int]:  \\n            \"\"\"Find all prime factors and their multiplicities of the input.\"\"\"\\n            factors = collections.defaultdict(lambda: 0)\\n            for p in primes:\\n                if p * p > val:\\n                    break\\n                if val % p != 0:\\n                    continue\\n                while val >= p and val % p == 0:\\n                    factors[p] += 1\\n                    val //= p                \\n            if val > 0:\\n                factors[val] = 1\\n                \\n            return factors                    \\n        \\n        def find_num_ideal_arrays(val: int) -> int:\\n            \"\"\"Find number of ideal arrays that ends with the input value.\"\"\"\\n            total = 1\\n            for factor, multiplicity in get_factors(val).items():\\n                if factor == 1:\\n                    continue\\n                m = multiplicity\\n                # Let p = `factor`, m = `multiplicity` and t = `n - 1`, \\n                # we can plot a lattice where there are m + 1 rows and \\n                # t + 1 columns. In this example, m = 3 and t = 3. \\n                # Each path in the lattice graph maps to a sequence\\n                # where a power of p is multiplied to the corresponding position. \\n                #\\n                # 1   o--o--o--o\\n                #     |  |  |  |\\n                # p   o--o--o--o\\n                #     |  |  |  |\\n                # p^2 o--o--o--o\\n                #     |  |  |  |\\n                # p^3 o--o--o--o\\n                # \\n                total = (total * math.comb(m + n - 1, m)) % self.MOD\\n                \\n            return total\\n                        \\n        total = 1\\n        for val in range(2, maxValue + 1):\\n            total = (total + find_num_ideal_arrays(val)) % self.MOD\\n        return total % self.MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264113,
                "title": "c-math-formula-combinatoric-formula-derivation-no-dp-direct-calculation",
                "content": "Let\\'s just count all the \"ideal\" arrays of length `n` and last number `m`.\\nFinally we have to just add the count for all numbers from `1` to `m`.\\n\\nWe will modify the \"ideal\" array to something which gives us an easier way to count.\\nWe will map the each \"ideal\" array configuration to something explained below:\\n\\nAny ideal array will look like this:\\n\\nf1,f1,f1,... f2,f2,... ,... ,... ,... , fk,fk,fk\\n\\nhere: fk = m, f1 may or may not be 1, and each fi is a non equal factor of f(i+1)\\nNow, define gi = fi/f(i-1), assuming f0 = 1.\\n\\nEach ideal array can be uniqly mapped to the following array\\n\\ng1,g1,g1,... g2,g2,... ,... ,... ,... , gk,gk,gk\\n\\nthe benefit of doing this is that now (g1 * g2 * g3 * * * * gk) = m\\nLet\\'s make one more transformation of the array to make things simple\\n\\nreplace the above array with:\\n\\ng1,1,1,... g2,1,1, g3,1,... ,... ,... ,... , gk,g1,g1\\nor simply each exclusive factor is placed at some index from `1` to `n`\\n\\nSo basically we have to count the number of ways we can distribute the number `m` among `n` places. Some places will not get any contribution hence those will remain `1`.\\nIf we have all such distibutions we can map them to some unique \"ideal\" array each.\\n\\nNow on counting the ways to distribute `m`.\\nFirst factorize `m`. Say m = (p1^e1) * (p2^e2) * * * (pk^ek)\\n\\n**Wrong** way to calculate this (for understanding the counting technique):\\nEach unique prime factor can be placed at any of the `n` indices independent of the others.\\nHence `count` = `n^(e1+e2+....+ek)`\\nBut this recount alot, because we are assuming that every new placement is independent.\\nThat is independent as long as it is not occured before.\\nTo mitigate that we can focus on each unique prime factor independently and multiply the results of each in end.\\nTo place `ei` of same num on `n` places (one place can hold multiple, possiblly zero or all of them) there are `(n-1+ei) choose ei` ways. Or simply `(n-1+ei)C(n-1)`\\n\\nHence final corrected `count` = `(n-1+e1)C(n-1) * (n-1+e2)C(n-1) * * * (n-1+ek)C(n-1)`\\n\\nThe code below just calculates the above expression with a lot of helper methods:\\n```\\nint N=65537;\\nint mod = 1000000007;\\nvector<bool> a(N,false);\\nvector<int> prime;\\nmap<int,int> primeFactorization(unsigned int n){\\n\\tmap<int,int> v;\\n\\tint i=0;\\n\\tint c=0;\\n\\tint l=prime.size();\\n\\tint p;\\n\\tint s = sqrt(n);\\n\\twhile(n>1){\\n\\t\\twhile(i<l&&prime[i]<=s&&n%prime[i])\\ti++;\\n\\t\\tif(i==l||prime[i]>s)\\tp = n;\\n\\t\\telse\\tp = prime[i];\\n\\t\\tc=0;\\n\\t\\twhile(n%p==0){\\n\\t\\t\\tn /= p;\\n\\t\\t\\tc++;\\n\\t\\t}\\n\\t\\tv[p] = c;\\n\\t\\ts = sqrt(n);\\n\\t}\\n\\treturn v;\\n}\\n\\nvoid initializePrimes(){\\n    if(prime.size())    return;\\n\\tint m, n=N;\\n\\ta[0]=a[1]=true;\\n\\tfor(int i=0; i<=sqrt(n); i++){\\n\\t\\tif(a[i])\\tcontinue;\\n\\t\\tprime.push_back(i);\\n\\t\\tm = i*i;\\n\\t\\twhile(m<n){\\n\\t\\t\\ta[m]=true;\\n\\t\\t\\tm += i;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=sqrt(n); i<n; i++)\\n\\t\\tif(!a[i])\\tprime.push_back(i);\\n\\t\\n\\t// cout<<\"Prime size is \"<<prime.size()<<endl;\\n}\\n\\nclass Solution {\\npublic:\\n    long long exp(int b, int e){\\n        long long a = 1;\\n        long long x = b;\\n        while(e){\\n            if(e%2)\\ta = (a*x)%mod;\\n            x = (x*x)%mod;\\n            e = e/2;\\n        }\\n        return a;\\n    }\\n    long long inv(int n){\\n        return exp(n,mod-2);\\n    }\\n    int f(vector<long long> &ncx, int n){\\n        auto fac = primeFactorization(n);\\n        long long ans = 1;\\n        for(auto p: fac)\\n            ans = (ans*ncx[p.second])%mod;\\n        return ans;\\n    }\\n    int idealArrays(int n, int m) {\\n        initializePrimes();\\n        vector<long long> ncx(16,1);\\n        for(int i=1; i<16; i++){\\n            ncx[i] = (ncx[i-1]*(n-1+i))%mod;\\n            ncx[i] = (ncx[i]*inv(i))%mod;\\n        }\\n        int ans = 0;\\n        for(int x=1; x<=m; x++)\\n            ans = (ans + f(ncx,x))%mod;\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nint N=65537;\\nint mod = 1000000007;\\nvector<bool> a(N,false);\\nvector<int> prime;\\nmap<int,int> primeFactorization(unsigned int n){\\n\\tmap<int,int> v;\\n\\tint i=0;\\n\\tint c=0;\\n\\tint l=prime.size();\\n\\tint p;\\n\\tint s = sqrt(n);\\n\\twhile(n>1){\\n\\t\\twhile(i<l&&prime[i]<=s&&n%prime[i])\\ti++;\\n\\t\\tif(i==l||prime[i]>s)\\tp = n;\\n\\t\\telse\\tp = prime[i];\\n\\t\\tc=0;\\n\\t\\twhile(n%p==0){\\n\\t\\t\\tn /= p;\\n\\t\\t\\tc++;\\n\\t\\t}\\n\\t\\tv[p] = c;\\n\\t\\ts = sqrt(n);\\n\\t}\\n\\treturn v;\\n}\\n\\nvoid initializePrimes(){\\n    if(prime.size())    return;\\n\\tint m, n=N;\\n\\ta[0]=a[1]=true;\\n\\tfor(int i=0; i<=sqrt(n); i++){\\n\\t\\tif(a[i])\\tcontinue;\\n\\t\\tprime.push_back(i);\\n\\t\\tm = i*i;\\n\\t\\twhile(m<n){\\n\\t\\t\\ta[m]=true;\\n\\t\\t\\tm += i;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=sqrt(n); i<n; i++)\\n\\t\\tif(!a[i])\\tprime.push_back(i);\\n\\t\\n\\t// cout<<\"Prime size is \"<<prime.size()<<endl;\\n}\\n\\nclass Solution {\\npublic:\\n    long long exp(int b, int e){\\n        long long a = 1;\\n        long long x = b;\\n        while(e){\\n            if(e%2)\\ta = (a*x)%mod;\\n            x = (x*x)%mod;\\n            e = e/2;\\n        }\\n        return a;\\n    }\\n    long long inv(int n){\\n        return exp(n,mod-2);\\n    }\\n    int f(vector<long long> &ncx, int n){\\n        auto fac = primeFactorization(n);\\n        long long ans = 1;\\n        for(auto p: fac)\\n            ans = (ans*ncx[p.second])%mod;\\n        return ans;\\n    }\\n    int idealArrays(int n, int m) {\\n        initializePrimes();\\n        vector<long long> ncx(16,1);\\n        for(int i=1; i<16; i++){\\n            ncx[i] = (ncx[i-1]*(n-1+i))%mod;\\n            ncx[i] = (ncx[i]*inv(i))%mod;\\n        }\\n        int ans = 0;\\n        for(int x=1; x<=m; x++)\\n            ans = (ans + f(ncx,x))%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2264063,
                "title": "whats-wrong-in-my-submission",
                "content": "whats wrong in my submission for this problem\\n```\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>>dp;\\n\\t\\t\\tint solve(int n,int m,int prev){\\n\\t\\t\\t\\tif(n==0)\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\tlong long ans = 0;\\n\\t\\t\\t\\tif(prev!=-1 && dp[n][prev]!=-1)\\n\\t\\t\\t\\t\\treturn dp[n][prev];\\n\\t\\t\\t\\tfor(int i=1;i<=m;i++){\\n\\t\\t\\t\\t\\tif(prev==-1){\\n\\t\\t\\t\\t\\t\\tans+=solve(n-1,m,i)%1000000007;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif(i%prev==0)\\n\\t\\t\\t\\t\\t\\t\\tans+=solve(n-1,m,i)%1000000007;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(prev!=-1)\\n\\t\\t\\t\\t\\tdp[n][prev]=ans%1000000007;\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t\\tint idealArrays(int n, int m) {\\n\\t\\t\\t\\tdp = vector<vector<int>>(n+1,vector<int>(m+1,-1));\\n\\t\\t\\t\\treturn solve(n,m,-1);\\n\\t\\t\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>>dp;\\n\\t\\t\\tint solve(int n,int m,int prev){\\n\\t\\t\\t\\tif(n==0)\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\tlong long ans = 0;\\n\\t\\t\\t\\tif(prev!=-1 && dp[n][prev]!=-1)\\n\\t\\t\\t\\t\\treturn dp[n][prev];\\n\\t\\t\\t\\tfor(int i=1;i<=m;i++){\\n\\t\\t\\t\\t\\tif(prev==-1){\\n\\t\\t\\t\\t\\t\\tans+=solve(n-1,m,i)%1000000007;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif(i%prev==0)\\n\\t\\t\\t\\t\\t\\t\\tans+=solve(n-1,m,i)%1000000007;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(prev!=-1)\\n\\t\\t\\t\\t\\tdp[n][prev]=ans%1000000007;\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t\\tint idealArrays(int n, int m) {\\n\\t\\t\\t\\tdp = vector<vector<int>>(n+1,vector<int>(m+1,-1));\\n\\t\\t\\t\\treturn solve(n,m,-1);\\n\\t\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263780,
                "title": "python-easy-dp-just-a-few-lines",
                "content": "All that matters is the length and the last number. Count from the last number, by the last number. \\xA0Also don\\'t worry about duplicates or you get TLE, just count without then number is C(n,L)\\n```\\nclass Solution(object):\\n    def idealArrays(self, n, maxValue):\\n\\n \\xA0 \\xA0 \\xA0 \\xA0def dp(last,L):\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0k=(last,L)\\n            if k in H: return H[k]\\n            \\n            if L==n:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0H[k]=1 \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0else:\\n\\t\\t\\tH[k]=sum(dp(x,L+1) for x in range(last+last, maxValue+1,last)) + C(n,L)\\n                \\n            return H[k]\\n        \\n        H={}\\n        return dp(1,0)%(10**9+7)\\n\\t\\t",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def idealArrays(self, n, maxValue):\\n\\n \\xA0 \\xA0 \\xA0 \\xA0def dp(last,L):\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0k=(last,L)\\n            if k in H: return H[k]\\n            \\n            if L==n:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0H[k]=1 \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0else:\\n\\t\\t\\tH[k]=sum(dp(x,L+1) for x in range(last+last, maxValue+1,last)) + C(n,L)\\n                \\n            return H[k]\\n        \\n        H={}",
                "codeTag": "Java"
            },
            {
                "id": 2263503,
                "title": "naive-c-dp-solution-easy-to-understand-but-stuck-in-tle",
                "content": "You can use is to understand and someone intelligent can suggest me an optimization. Plssss :) .\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int gia(int s, int n, int maxValue, vector<vector<int>> &dp){\\n        if(n==2){\\n            return (maxValue/s)%1000000007;\\n        }\\n        if(dp[s][n]!=-1){\\n            return dp[s][n];\\n        }\\n        int count = 0;\\n        int i=s;\\n        while(i<=maxValue){\\n            if(i%s==0){\\n                count  = ((count%1000000007) + (gia(i, n-1, maxValue, dp)%1000000007))%1000000007;\\n                //cout<<\"in n-1: \"<<n-1<<\" count: \"<<count<<endl;\\n            }\\n            i++;\\n        }\\n        //cout<<\"n-1: \"<<n-1<<\" count: \"<<count<<endl;\\n        return dp[s][n] = count%1000000007;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        int count = 0;\\n        vector<vector<int>> dp(maxValue+1, vector<int>(n+1,-1));\\n        for(int i = 1; i<=maxValue; i++){\\n           count = ((count%1000000007) + (gia(i, n, maxValue, dp)%1000000007))%1000000007;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int gia(int s, int n, int maxValue, vector<vector<int>> &dp){\\n        if(n==2){\\n            return (maxValue/s)%1000000007;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2263403,
                "title": "c-for-beginner-dp-with-explaination-in-detail-beat-100",
                "content": "This solution is inspired and modified from [hello69\\'s post](https://leetcode.com/problems/count-the-number-of-ideal-arrays/discuss/2261491/C%2B%2B-Accepted-or-DP-or-O(20*n)-space-or-Complete-Explanation). After understanding [hello69\\'s method](https://leetcode.com/problems/count-the-number-of-ideal-arrays/discuss/2261491/C%2B%2B-Accepted-or-DP-or-O(20*n)-space-or-Complete-Explanation), details are explained here.\\n**KEY CONCEPT**\\nA sequence can be decomposed into `prototype` and `value`.\\nFor example [1,1,2,2] => [a,a,b,b] and {1,2}\\nOr, [2,2,4,4] => [a,a,b,b] and {2,4}\\nIf we know how many kinds of `prototype` and how many kinds of `value set` considering there are `i` unique values, just multiply them.\\nWith the `maxValue` limitation, `k` is bounded by `log2(maxValue) + 1`.\\nSo the answer is `sum(prototype[i] * value_set[i] for i from 1 to k)`\\n\\n```\\nclass Solution {\\npublic:\\n    // dp[i][j]: if there are i unique values, how many unique sequences can be formed if the length is j\\n    vector<vector<long long>> dp;\\n    \\n    // prefixSum[i][j]: prefix sum for dp[i][:j]\\n    vector<vector<long long>> prefixSum;\\n    \\n    // choiceDp[i]: how many unique values \"set\" can be chosen when # of i unique values is required\\n    vector<long long> choiceDp;\\n    int n;\\n    int maxValue;\\n    long long mod = 1e9 + 7;\\n    \\n    // DFS, actually\\n    // add the current value to choiceDp[count]: count is the # of unique value\\n    // when the next value is less than maxValue\\n    // e.g., max = 7 and {curr->next} = 1 -> 2 or 2 -> 4 or 3 -> 6\\n    // we can add the next value to choiceDp[count + 1] => choiceDp[count]++\\n    void addChoice(int currentValue, int count) {\\n        choiceDp[count]++;\\n        for (int nextValue = currentValue * 2; nextValue <= maxValue; nextValue += currentValue) {\\n            addChoice(nextValue, count + 1);\\n        }\\n    }\\n    \\n    int idealArrays(int n, int maxValue) {\\n        this->n = n;\\n        this->maxValue = maxValue;\\n        // max unqiue values can be in the sequence is log2(maxValue) + 1\\n        // e.g., maxValue = 8 => [1,2,4,8] => log(8) + 1 = 4\\n        int maxUnique = static_cast<int>(log2(maxValue)) + 1;\\n        dp.resize(maxUnique + 1, vector<long long>(n + 1, 0));\\n        prefixSum.resize(maxUnique + 1, vector<long long>(n + 1, 0));\\n        choiceDp.resize(maxUnique + 1, 0);\\n        \\n        // Compute the # of unique sequences with i unique values and length = j\\n        // We don\\'t care about what their values should be here\\n        // just [a,b,c,d] and a <= b <= c <= d\\n        for (int j = 1; j <= n; ++j) {\\n            dp[1][j] = 1;\\n            prefixSum[1][j] = j;\\n        }\\n        for (int i = 2; i <= maxUnique; ++i) {\\n            for (int j = i; j <= n; ++j) {\\n                // dp[i][j] = dp[i - 1][1] + dp[i - 1][2] + ... + dp[i - 1][j - 1]\\n                // use prefix sum to save time\\n                dp[i][j] = prefixSum[i - 1][j - 1];\\n                prefixSum[i][j] = prefixSum[i][j - 1] + dp[i][j];\\n                dp[i][j] %= mod;\\n                prefixSum[i][j] %= mod;\\n            }\\n        }\\n        \\n        // Compute the choice\\n        for (int j = 1; j <= maxValue; ++j) {\\n            addChoice(j, 1);\\n        }\\n        \\n        // Combine choice and unique sequences\\n        // e.g., [a,a,b,b] is one unique sequence with # of unique values = 2\\n        //       get the # of possible set of {a, b} and multiply\\n        long long res = 0;\\n        for (int i = 1; i <= maxUnique; ++i) {\\n            res += dp[i][n] * choiceDp[i];\\n            res %= mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // dp[i][j]: if there are i unique values, how many unique sequences can be formed if the length is j\\n    vector<vector<long long>> dp;\\n    \\n    // prefixSum[i][j]: prefix sum for dp[i][:j]\\n    vector<vector<long long>> prefixSum;\\n    \\n    // choiceDp[i]: how many unique values \"set\" can be chosen when # of i unique values is required\\n    vector<long long> choiceDp;\\n    int n;\\n    int maxValue;\\n    long long mod = 1e9 + 7;\\n    \\n    // DFS, actually\\n    // add the current value to choiceDp[count]: count is the # of unique value\\n    // when the next value is less than maxValue\\n    // e.g., max = 7 and {curr->next} = 1 -> 2 or 2 -> 4 or 3 -> 6\\n    // we can add the next value to choiceDp[count + 1] => choiceDp[count]++\\n    void addChoice(int currentValue, int count) {\\n        choiceDp[count]++;\\n        for (int nextValue = currentValue * 2; nextValue <= maxValue; nextValue += currentValue) {\\n            addChoice(nextValue, count + 1);\\n        }\\n    }\\n    \\n    int idealArrays(int n, int maxValue) {\\n        this->n = n;\\n        this->maxValue = maxValue;\\n        // max unqiue values can be in the sequence is log2(maxValue) + 1\\n        // e.g., maxValue = 8 => [1,2,4,8] => log(8) + 1 = 4\\n        int maxUnique = static_cast<int>(log2(maxValue)) + 1;\\n        dp.resize(maxUnique + 1, vector<long long>(n + 1, 0));\\n        prefixSum.resize(maxUnique + 1, vector<long long>(n + 1, 0));\\n        choiceDp.resize(maxUnique + 1, 0);\\n        \\n        // Compute the # of unique sequences with i unique values and length = j\\n        // We don\\'t care about what their values should be here\\n        // just [a,b,c,d] and a <= b <= c <= d\\n        for (int j = 1; j <= n; ++j) {\\n            dp[1][j] = 1;\\n            prefixSum[1][j] = j;\\n        }\\n        for (int i = 2; i <= maxUnique; ++i) {\\n            for (int j = i; j <= n; ++j) {\\n                // dp[i][j] = dp[i - 1][1] + dp[i - 1][2] + ... + dp[i - 1][j - 1]\\n                // use prefix sum to save time\\n                dp[i][j] = prefixSum[i - 1][j - 1];\\n                prefixSum[i][j] = prefixSum[i][j - 1] + dp[i][j];\\n                dp[i][j] %= mod;\\n                prefixSum[i][j] %= mod;\\n            }\\n        }\\n        \\n        // Compute the choice\\n        for (int j = 1; j <= maxValue; ++j) {\\n            addChoice(j, 1);\\n        }\\n        \\n        // Combine choice and unique sequences\\n        // e.g., [a,a,b,b] is one unique sequence with # of unique values = 2\\n        //       get the # of possible set of {a, b} and multiply\\n        long long res = 0;\\n        for (int i = 1; i <= maxUnique; ++i) {\\n            res += dp[i][n] * choiceDp[i];\\n            res %= mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263294,
                "title": "python3-300ms-more-pruning",
                "content": "\\n\\n```\\nall_mods = [2] # all primary number\\nfor i in range(3, int(1e4) + 1, 2):\\n    for v in all_mods:\\n        if i % v == 0:\\n            break\\n    else:\\n        all_mods.append(i)\\nmod_set = set(all_mods)\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        ans = 1\\n        for i in range(2, maxValue + 1):\\n            t_ans = 1\\n            for m in all_mods:\\n                v_count = 0\\n                while i % m == 0:\\n                    i //= m\\n                    v_count += 1\\n                if v_count != 0:\\n                    t_ans *= comb(n + v_count - 1, v_count)\\n                    if i == 1:\\n                        break\\n                if i in mod_set:\\n                    t_ans *= n\\n                    break\\n\\n            ans += t_ans\\n        return ans % int(1e9+7)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nall_mods = [2] # all primary number\\nfor i in range(3, int(1e4) + 1, 2):\\n    for v in all_mods:\\n        if i % v == 0:\\n            break\\n    else:\\n        all_mods.append(i)\\nmod_set = set(all_mods)\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        ans = 1\\n        for i in range(2, maxValue + 1):\\n            t_ans = 1\\n            for m in all_mods:\\n                v_count = 0\\n                while i % m == 0:\\n                    i //= m\\n                    v_count += 1\\n                if v_count != 0:\\n                    t_ans *= comb(n + v_count - 1, v_count)\\n                    if i == 1:\\n                        break\\n                if i in mod_set:\\n                    t_ans *= n\\n                    break\\n\\n            ans += t_ans\\n        return ans % int(1e9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263102,
                "title": "my-solution",
                "content": "Let\\'s start from a specific case.\\n**Question**\\nHow many distinct ideal arrays of length `n`, ending with `value` can be constructed?\\n**Try to answer it**\\nAssume that `value` is equal to (`prime_factor_1` ^ `n_1`) * (`prime_factor_2` ^ `n_2`) * (`prime_factor_3` ^ `n_3`) * ... * (`prime_factor_k` ^ `n_k`).\\nLet\\'s consider a specific prime factor, `prime_factor_i` ^ `n_i`.\\nAssume the array is {`e_1`, `e_2`, ..., `e_n`}, we should assign `n_i` `prime_factor_i`\\'s to `n` elements of the ideal array.\\nAssume that\\n`e_1` is assigned to `a_1` `prime_factor_i`,\\n`e_2` is assigned to `a_2` `prime_factor_i`,\\n`...`\\n`e_n` is assigned to `a_n` `prime_factor_i`,\\nwhere `a_1` + `a_2` + ... + `a_n` should be equal to `n_i`.\\nThe question is transformed to find the number of the ways to put `n_i` balls into `n` boxes, it\\'s C(`n` + `n_i` - 1, `n_i`).\\n**A specific example to help understand the above description**\\nFor example, assume `n` is `5`, `value` is `12`.\\n`12 = (2 ^ 2) * (3 ^ 1)`\\n***Case 1***\\nAssume the first `2` is assigned to the first element, the second `2` is assigned to the third element, and the unique `3` is assigned to the fifth element, then the array should be\\n`2, 2, 4, 4, 12`\\n***Case 2***\\nAssume the first `2` is assigned to the second element, the second `2` is assigned to the fourth element, and the unique `3` is assigned to the third element, then the array should be\\n`1, 2, 6, 12, 12`\\n***etc***\\n**The whole target**\\nWe should consider every prime factors, from `prime_factor_1` to `prime_factor_k`, of every ending value, and every ending value from 1 to `maxValue`.\\n*Hope the above desciption is a little helpful.*\\n```\\nclass Solution {\\n private:\\n  static constexpr int mod = 1000000007;\\n  \\n public:\\n  int idealArrays(const int n, const int maxValue) {\\n    int ret = 0;\\n    for (int value = 0; value < maxValue; ++value) {\\n      vector<int> prime_factors = get_prime_factors(value + 1);\\n      int item = 1;\\n      for (const int k : prime_factors) {\\n        item = static_cast<int>((static_cast<long long>(item) * get_ways_to_put_k_balls_into_n_boxes(n, k)) % mod);\\n      }\\n      ret = (ret + item) % mod;\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  /**\\n   * @return a vector,\\n   * each element of which is the number of a specific prime factor of the number `value`\\n   *\\n   * for example,\\n   * if value is 1, return value is {`1`} because the number 1 has only `1` prime factor, that is 1\\n   * if value is 2, return value is {`1`} because the number 2 has only `1` prime factor, that is 2\\n   * if value is 12, return value is {`2`, `1`} because the number 12 (2 * 2 * 3) has `2` prime factor 2 and `1` prime factor 3\\n   * etc\\n   */\\n  vector<int> get_prime_factors(int value) {\\n    vector<int> ret;\\n    for (int factor = 2; factor * factor < value + 1; ++factor) {\\n      if (value % factor != 0) {\\n        continue;\\n      }\\n      \\n      int count = 0;\\n      while (value % factor == 0) {\\n        ++count;\\n        value /= factor;\\n      }\\n      ret.emplace_back(count);\\n    }\\n    if (value != 1) {\\n      ret.emplace_back(1);\\n    }\\n    return ret;\\n  }\\n  \\n  int get_ways_to_put_k_balls_into_n_boxes(const int n, const int k) {\\n    // the result is `C(n + k - 1, k)`\\n    long long factorial_k = 1LL;\\n    for (int i = 1; i < k + 1; ++i) {\\n      factorial_k *= i;\\n    }\\n    \\n    long long ret = 1LL;\\n    for (int i = 1; i < k + 1; ++i) {\\n      long long factor = n + k - i;\\n      const long long gcd = get_gcd(factor, factorial_k);\\n      factor /= gcd;\\n      factorial_k /= gcd;\\n      ret = (ret * factor) % mod;\\n    }\\n    return static_cast<int>(ret);\\n  }\\n  \\n  long long get_gcd(const long long a, const long long b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n private:\\n  static constexpr int mod = 1000000007;\\n  \\n public:\\n  int idealArrays(const int n, const int maxValue) {\\n    int ret = 0;\\n    for (int value = 0; value < maxValue; ++value) {\\n      vector<int> prime_factors = get_prime_factors(value + 1);\\n      int item = 1;\\n      for (const int k : prime_factors) {\\n        item = static_cast<int>((static_cast<long long>(item) * get_ways_to_put_k_balls_into_n_boxes(n, k)) % mod);\\n      }\\n      ret = (ret + item) % mod;\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  /**\\n   * @return a vector,\\n   * each element of which is the number of a specific prime factor of the number `value`\\n   *\\n   * for example,\\n   * if value is 1, return value is {`1`} because the number 1 has only `1` prime factor, that is 1\\n   * if value is 2, return value is {`1`} because the number 2 has only `1` prime factor, that is 2\\n   * if value is 12, return value is {`2`, `1`} because the number 12 (2 * 2 * 3) has `2` prime factor 2 and `1` prime factor 3\\n   * etc\\n   */\\n  vector<int> get_prime_factors(int value) {\\n    vector<int> ret;\\n    for (int factor = 2; factor * factor < value + 1; ++factor) {\\n      if (value % factor != 0) {\\n        continue;\\n      }\\n      \\n      int count = 0;\\n      while (value % factor == 0) {\\n        ++count;\\n        value /= factor;\\n      }\\n      ret.emplace_back(count);\\n    }\\n    if (value != 1) {\\n      ret.emplace_back(1);\\n    }\\n    return ret;\\n  }\\n  \\n  int get_ways_to_put_k_balls_into_n_boxes(const int n, const int k) {\\n    // the result is `C(n + k - 1, k)`\\n    long long factorial_k = 1LL;\\n    for (int i = 1; i < k + 1; ++i) {\\n      factorial_k *= i;\\n    }\\n    \\n    long long ret = 1LL;\\n    for (int i = 1; i < k + 1; ++i) {\\n      long long factor = n + k - i;\\n      const long long gcd = get_gcd(factor, factorial_k);\\n      factor /= gcd;\\n      factorial_k /= gcd;\\n      ret = (ret * factor) % mod;\\n    }\\n    return static_cast<int>(ret);\\n  }\\n  \\n  long long get_gcd(const long long a, const long long b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263056,
                "title": "dp-giving-tle",
                "content": "```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n    public int idealArrays(int n, int maxValue) {\\n        long ways = 0L;\\n        long[][] dp = new long[maxValue+1][n+1];\\n        for(int i=1;i<=maxValue;i++) ways = (ways + numberOfWays(i,n,maxValue,dp))%MOD;\\n        return (int)ways;\\n    }\\n    private long numberOfWays(int start, int length, int maxValue, long[][] dp){\\n        if(length == 1) return 1L;\\n        if(dp[start][length]!=0) return dp[start][length];\\n        long ways = 0L;\\n        for(int multiple=start;multiple<=maxValue;multiple += start){\\n            ways = (ways + numberOfWays(multiple,length-1,maxValue,dp))%MOD;\\n        }\\n        return dp[start][length] = ways;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n    public int idealArrays(int n, int maxValue) {\\n        long ways = 0L;\\n        long[][] dp = new long[maxValue+1][n+1];\\n        for(int i=1;i<=maxValue;i++) ways = (ways + numberOfWays(i,n,maxValue,dp))%MOD;\\n        return (int)ways;\\n    }\\n    private long numberOfWays(int start, int length, int maxValue, long[][] dp){\\n        if(length == 1) return 1L;\\n        if(dp[start][length]!=0) return dp[start][length];\\n        long ways = 0L;\\n        for(int multiple=start;multiple<=maxValue;multiple += start){\\n            ways = (ways + numberOfWays(multiple,length-1,maxValue,dp))%MOD;\\n        }\\n        return dp[start][length] = ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262973,
                "title": "python3-beats-100-100-detailed-explanation-with-an-example",
                "content": "```\\n\"\"\"\\nFor example, consider a case with n = 5 and maxValue = 12.\\nTrivial array has only one type of element and can END WITH 1, ... , maxValue.\\nSo with options = [1,2,...,12], distinct arrays are [1,1,1,1,1], [2,2,2,2,2], ..., [12,12,12,12,12]\\n\\nThe point is, multiples of the last element of the current arrays will be the next options of the last element, if we want to increase the types of elements.\\n\\nWe have options = [1,2,3,4,5,6,7,8,9,10,11,12] for type of element = 1.\\nWe can find the next options of the last element like below.\\n\\nmultiples of 1 -> 2,3,4,5,6,7,8,9,10,11,12\\nmultiples of 2 ->     4,  6,  8,  10,   12\\nmultiples of 3 ->         6,    9,      12\\nmultiples of 4 ->             8,        12\\nmultiples of 5 ->                 10\\nmultiples of 6 ->                       12\\n2*7 = 14 > 12 so we don\\'t have to check from 7.\\n\\nNow we have the following new_options for types of elements = 2. \\n\\nnew_options = [2,3,..,12, 4,6,...,12, 6,9,12, 8,12, 10, 12]\\n\\nNotice that duplicates should be allowed here because their former elements differ.\\nFor example, (1) -> (1,4) and (2) -> (2,4). \\n\\nThe next step is to count number of distinct arrays for fixed types of elements.\\nAs an ideal array is non-decreasing, what we have to do is just determine a position which element increases. \\nFor trivial arrays, we have nothing to do. So we have (5-1)C(0) choices.\\nFor two types of elements, consider a case which we want array with (2,4). As we must put at least one 2, we can start with [2, _, _, _, _]. \\nWe can put 4 in any blank, so we have (5-1)C(1) choices. If we chose the second blank, an ideal array is as follows. \\n[2, _, 4, _, _] --> [2, 2, 4, 4, 4]\\nConsider three types of elements. If we want array with (1,2,4), we must choice 2 blanks among 4. \\nThat is, we have (5-1)C(2) choices. An example is shown below.\\n[1, _, _, _, _] ->  [1, _, 2, _, _] -> [1, _, 2, 4, _] -> [1, 1, 2, 4, 4]\\n\\nTo summarize, we can find the answer as follows.\\nwhile 1<<i <= maxValue:\\n    (answer)   += (number of options of last element) * (number of options of blank)\\n                = len(options) * (n-1) C (i) \\n\\nWhen I did this with list type \\'options\\', I got TLE (44/47).\\nSo I changed the type of \\'options\\' to dict and passed.\\nPlease comment if you found an error. Thank you.\\n\"\"\"\\n\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        options = {option:1 for option in range(1,maxValue+1)}\\n        ans = i = 0\\n        while 1<<i <= maxValue:\\n            ans += sum(options.values())*self.combi(n-1,i)\\n            new_options = defaultdict(int)\\n            for option in options:\\n                for j in range(2,maxValue//option+1):\\n                    new_options[option*j]+=options[option]\\n            options = new_options\\n            i += 1\\n            \\n        return ans%int(1e9+7)\\n  \\n    @cache\\n    def combi(self,n,k):\\n        if k > n:\\n            return 0\\n        if k == 0 or n ==k:\\n            return 1\\n        nume = 1; denom = 1;\\n        for i in range(k):\\n            nume *= n-i\\n            denom*= k-i\\n        return nume//denom\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        options = {option:1 for option in range(1,maxValue+1)}",
                "codeTag": "Java"
            },
            {
                "id": 2262835,
                "title": "c-dp-and-combinations-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int c[10001][16] = {0};\\n    long combinations(int a, int b){\\n        if(a == 0 || b == 0 || a == b)\\n            return 1;\\n        if(c[a][b] != 0)\\n            return c[a][b];\\n        return c[a][b] = (combinations(a-1,b-1) + combinations(a-1,b)) %mod;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        vector<int> step(16,0);\\n        vector<vector<int>> dp(maxValue+1,vector<int>(16,0));\\n        for(int i = maxValue ; i > 0 ; i--){\\n            dp[i][1] = 1;\\n            for(int j = 2 * i ; j <= maxValue ; j += i){\\n                for(int k = 1 ; dp[j][k] != 0 ;k++){\\n                    dp[i][k+1] += dp[j][k];\\n                }\\n            }\\n            for(int j = 1; dp[i][j] != 0 ; j++){\\n                step[j] += dp[i][j];\\n            }\\n        }\\n        long ret = 0;\\n        for(int i = 1 ; step[i] != 0 && i<=n ; i++){\\n            int N = n - i;\\n            long long temp = combinations(n - 1, i-1);\\n            ret += temp * step[i];\\n            ret %= mod;\\n        }\\n        return ret;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int c[10001][16] = {0};\\n    long combinations(int a, int b){\\n        if(a == 0 || b == 0 || a == b)\\n            return 1;\\n        if(c[a][b] != 0)\\n            return c[a][b];\\n        return c[a][b] = (combinations(a-1,b-1) + combinations(a-1,b)) %mod;\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        vector<int> step(16,0);\\n        vector<vector<int>> dp(maxValue+1,vector<int>(16,0));\\n        for(int i = maxValue ; i > 0 ; i--){\\n            dp[i][1] = 1;\\n            for(int j = 2 * i ; j <= maxValue ; j += i){\\n                for(int k = 1 ; dp[j][k] != 0 ;k++){\\n                    dp[i][k+1] += dp[j][k];\\n                }\\n            }\\n            for(int j = 1; dp[i][j] != 0 ; j++){\\n                step[j] += dp[i][j];\\n            }\\n        }\\n        long ret = 0;\\n        for(int i = 1 ; step[i] != 0 && i<=n ; i++){\\n            int N = n - i;\\n            long long temp = combinations(n - 1, i-1);\\n            ret += temp * step[i];\\n            ret %= mod;\\n        }\\n        return ret;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262826,
                "title": "fast-power-o-mlogmlogn",
                "content": "The count of arrays ending with x follows a \"product\" relation, so we can use fast power algo to compute it.\\n```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        M=maxValue+1\\n        def prod(a,b):\\n            c=[0]*M\\n            for i in range(1,M):\\n                for j in range(1,(M+i-1)//i):\\n                    c[i*j]+=a[i]*b[j]\\n            return c\\n        c1=[1]*M\\n        def f(i):\\n            if i==1:\\n                return c1\\n            y=f(i//2)\\n            y=prod(y,y)\\n            return prod(y,c1) if i&1 else y\\n        return sum(f(n))%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        M=maxValue+1\\n        def prod(a,b):\\n            c=[0]*M\\n            for i in range(1,M):\\n                for j in range(1,(M+i-1)//i):\\n                    c[i*j]+=a[i]*b[j]\\n            return c\\n        c1=[1]*M\\n        def f(i):\\n            if i==1:\\n                return c1\\n            y=f(i//2)\\n            y=prod(y,y)\\n            return prod(y,c1) if i&1 else y\\n        return sum(f(n))%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262780,
                "title": "o-m-log-log-m-python3-143ms",
                "content": "## Formula\\n```python\\ndp[i] := number of ideal arrays of length n which ends with i\\n\\nIf i factorized into (i = p1 ^ order1 * p2 ^ order2 ...)\\n\\ndp[i] = H(n, order1) * H(n, order2) * ...\\nwhere H(n, k) = comb(n+k-1, k)\\n```\\n- H(n, k) = [Number_of_combinations_with_repetition](https://en.wikipedia.org/wiki/Combination#Number_of_combinations_with_repetition)\\n## Example\\n```python\\ni = 200 = 2^3 * 5^5, n = 5\\n\\narr = [4,4,20,20,200]\\n\\narr = cumprod(division) where\\ndivision  = [4   1   5   1   10]\\n\\ndivision = division2 * division5\\ndivision2 = [2\\xB2  1   1   1   2\\xB9]  --> H(5, 3) possible choices\\ndivision5 = [1   1   5\\xB9  1   5\\xB9]  --> H(5, 2) possible choices\\n\\n\\u2234 dp[200] = dp[2^3 * 5^2] = H(5, 3) * H(5, 2) = (5*6*7)/(1*2*3) * (5*6)/(1*2) = 35 * 15\\n```\\n\\n## DP\\n```python\\nIf i factorized into (i = p1 ^ order1 * p2 ^ order2 ... p_n ^ order_n)\\ndp[i] = H(n, order1) * H(n, order2) * ... * H(n, order_n)\\n= dp[i // (p_n ^ order_n)] * H(n, order_n)\\n```\\n\\n## Sieve of Eratosthenes\\n```\\nWe can find (p_n = largest_prime_divisor) by Sieve of Eratosthenes\\n```\\n## Solution\\nhttps://leetcode.com/submissions/detail/743238030/\\n```\\nclass Solution:    \\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        mod = 1_000_000_007\\n        m = maxValue\\n\\n        # O(m log log m)\\n        max_prime_divisor = [None] * (m + 1)\\n        for i in range(2, m + 1):\\n            if max_prime_divisor[i] is None:\\n                for j in range(i, m + 1, i):\\n                    max_prime_divisor[j] = i\\n        \\n        # O(m)\\n        # 12 = (2 ** 2) * (3 ** 1) = (quotient[12]) * (max_prime_divisor[12] ** order[12])\\n        order = [None] * (m + 1)\\n        quotient = [None] * (m + 1)\\n        for i in range(2, m + 1):\\n            d = max_prime_divisor[i]\\n            j = i // d\\n            if max_prime_divisor[j] == d:\\n                order[i] = order[j] + 1\\n                quotient[i] = quotient[j]\\n            else:\\n                order[i] = 1\\n                quotient[i] = j\\n        \\n        # O(log m)\\n        # multiset_number[k] := H(n, k) = n/1 * (n+1)/2 * ...\\n        log2_m = m.bit_length()\\n        multiset_number = [None] * log2_m\\n        multiset_number[0] = 1\\n        for i in range(1, log2_m):\\n            multiset_number[i] = multiset_number[i-1] * (n+i-1) // i\\n        for i in range(1, log2_m):\\n            multiset_number[i] %= mod\\n        \\n        # O(m)\\n        #dp[i] = number of ideal arrays end with i\\n        dp = [None] * (m + 1)\\n        dp[1] = 1\\n        answer = dp[1]\\n        for i in range(2, m + 1):\\n            dp[i] = (dp[quotient[i]] * multiset_number[order[i]]) % mod\\n            answer = (answer + dp[i]) % mod\\n        \\n        return answer\\n```\\n## Modular inverse by [Fermat\\'s little theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)\\nIt\\'s not nessecery because python can handle large integer.\\n\\n```\\n\\t\\t# modular power. O(log b)\\n\\t\\tdef mod_power(a: int, b: int, mod: int) -> int:\\n\\t\\t\\tresult = 1\\n\\t\\t\\twhile b > 0:\\n\\t\\t\\t\\tif b & 1:\\n\\t\\t\\t\\t\\tresult = (result * a) % mod\\n\\t\\t\\t\\ta = (a * a) % mod\\n\\t\\t\\t\\tb >>= 1\\n\\t\\t\\treturn result\\n\\n\\t\\t# modular inverse. (a^-1 == a^(p-2) mod p, where p is a prime). O(log mod)\\n\\t\\tdef mod_inverse(i: int, mod: int) -> int:\\n\\t\\t\\treturn mod_power(i, mod-2, mod)\\n\\n\\t\\t# O(log m * log mod)\\n\\t\\t# multiset_number[k] := H(n, k) = n/1 * (n+1)/2 * ...\\n\\t\\tlog2_m = m.bit_length()\\n\\t\\tmultiset_number = [None] * log2_m\\n\\t\\tmultiset_number[0] = 1\\n\\t\\tfor i in range(1, log2_m):\\n\\t\\t\\tinverse = mod_inverse(i, mod)\\n\\t\\t\\ttemp = ((n+i-1) * inverse) % mod\\n\\t\\t\\tmultiset_number[i] = (multiset_number[i-1] * temp) % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\ndp[i] := number of ideal arrays of length n which ends with i\\n\\nIf i factorized into (i = p1 ^ order1 * p2 ^ order2 ...)\\n\\ndp[i] = H(n, order1) * H(n, order2) * ...\\nwhere H(n, k) = comb(n+k-1, k)\\n```\n```python\\ni = 200 = 2^3 * 5^5, n = 5\\n\\narr = [4,4,20,20,200]\\n\\narr = cumprod(division) where\\ndivision  = [4   1   5   1   10]\\n\\ndivision = division2 * division5\\ndivision2 = [2\\xB2  1   1   1   2\\xB9]  --> H(5, 3) possible choices\\ndivision5 = [1   1   5\\xB9  1   5\\xB9]  --> H(5, 2) possible choices\\n\\n\\u2234 dp[200] = dp[2^3 * 5^2] = H(5, 3) * H(5, 2) = (5*6*7)/(1*2*3) * (5*6)/(1*2) = 35 * 15\\n```\n```python\\nIf i factorized into (i = p1 ^ order1 * p2 ^ order2 ... p_n ^ order_n)\\ndp[i] = H(n, order1) * H(n, order2) * ... * H(n, order_n)\\n= dp[i // (p_n ^ order_n)] * H(n, order_n)\\n```\n```\\nWe can find (p_n = largest_prime_divisor) by Sieve of Eratosthenes\\n```\n```\\nclass Solution:    \\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        mod = 1_000_000_007\\n        m = maxValue\\n\\n        # O(m log log m)\\n        max_prime_divisor = [None] * (m + 1)\\n        for i in range(2, m + 1):\\n            if max_prime_divisor[i] is None:\\n                for j in range(i, m + 1, i):\\n                    max_prime_divisor[j] = i\\n        \\n        # O(m)\\n        # 12 = (2 ** 2) * (3 ** 1) = (quotient[12]) * (max_prime_divisor[12] ** order[12])\\n        order = [None] * (m + 1)\\n        quotient = [None] * (m + 1)\\n        for i in range(2, m + 1):\\n            d = max_prime_divisor[i]\\n            j = i // d\\n            if max_prime_divisor[j] == d:\\n                order[i] = order[j] + 1\\n                quotient[i] = quotient[j]\\n            else:\\n                order[i] = 1\\n                quotient[i] = j\\n        \\n        # O(log m)\\n        # multiset_number[k] := H(n, k) = n/1 * (n+1)/2 * ...\\n        log2_m = m.bit_length()\\n        multiset_number = [None] * log2_m\\n        multiset_number[0] = 1\\n        for i in range(1, log2_m):\\n            multiset_number[i] = multiset_number[i-1] * (n+i-1) // i\\n        for i in range(1, log2_m):\\n            multiset_number[i] %= mod\\n        \\n        # O(m)\\n        #dp[i] = number of ideal arrays end with i\\n        dp = [None] * (m + 1)\\n        dp[1] = 1\\n        answer = dp[1]\\n        for i in range(2, m + 1):\\n            dp[i] = (dp[quotient[i]] * multiset_number[order[i]]) % mod\\n            answer = (answer + dp[i]) % mod\\n        \\n        return answer\\n```\n```\\n\\t\\t# modular power. O(log b)\\n\\t\\tdef mod_power(a: int, b: int, mod: int) -> int:\\n\\t\\t\\tresult = 1\\n\\t\\t\\twhile b > 0:\\n\\t\\t\\t\\tif b & 1:\\n\\t\\t\\t\\t\\tresult = (result * a) % mod\\n\\t\\t\\t\\ta = (a * a) % mod\\n\\t\\t\\t\\tb >>= 1\\n\\t\\t\\treturn result\\n\\n\\t\\t# modular inverse. (a^-1 == a^(p-2) mod p, where p is a prime). O(log mod)\\n\\t\\tdef mod_inverse(i: int, mod: int) -> int:\\n\\t\\t\\treturn mod_power(i, mod-2, mod)\\n\\n\\t\\t# O(log m * log mod)\\n\\t\\t# multiset_number[k] := H(n, k) = n/1 * (n+1)/2 * ...\\n\\t\\tlog2_m = m.bit_length()\\n\\t\\tmultiset_number = [None] * log2_m\\n\\t\\tmultiset_number[0] = 1\\n\\t\\tfor i in range(1, log2_m):\\n\\t\\t\\tinverse = mod_inverse(i, mod)\\n\\t\\t\\ttemp = ((n+i-1) * inverse) % mod\\n\\t\\t\\tmultiset_number[i] = (multiset_number[i-1] * temp) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262541,
                "title": "javascript-combination-mod-number-of-factor-1290ms",
                "content": "```\\nconst ll = BigInt, mod = ll(1e9 + 7), N = 1e4 + 15;\\n\\nconst hcomb = (p, q) => p == 0 && q == 0 ? 1 : comb(p + q - 1, q);\\nconst comb_init = () => {\\n    fact[0] = ifact[0] = inv[1] = 1n; // factorial, inverse factorial\\n    for (let i = 2; i < N; i++) inv[i] = (mod - mod / ll(i)) * inv[mod % ll(i)] % mod;\\n    for (let i = 1; i < N; i++) {\\n        fact[i] = fact[i - 1] * ll(i) % mod;\\n        ifact[i] = ifact[i - 1] * inv[i] % mod;\\n    }\\n};\\n\\n// combination mod pick k from n\\nconst comb = (n, k) => {\\n    if (n < k || k < 0) return 0;\\n    return fact[n] * ifact[k] % mod * ifact[n - k] % mod;\\n};\\n\\n/*\\nprerequisite:\\n(number of factors)\\nhttps://www.codechef.com/LTIME01/problems/NUMFACT\\nmy solution: https://www.codechef.com/viewsolution/67461009\\n*/\\nconst number_factor = (n) => {\\n    let m = new Map();\\n    for (let i = 2; i * i <= n; i++) {\\n        while (n % i == 0) {\\n            n /= i;\\n            m.set(i, m.get(i) + 1 || 1);\\n        }\\n    }\\n    if (n > 1) m.set(n, m.get(n) + 1 || 1);\\n    return m;\\n};\\n\\nlet fact, ifact, inv;\\nconst idealArrays = (n, maxValue) => {\\n    fact = Array(N).fill(0), ifact = Array(N).fill(0), inv = Array(N).fill(0);\\n    comb_init();\\n    let res = 0n;\\n    for (let x = 1; x <= maxValue; x++) {\\n        let perm = 1n, m = number_factor(x);\\n        for (const [x, occ] of m) {\\n            perm = perm * hcomb(n, occ) % mod;\\n        }\\n        res += perm;\\n    }\\n    return res % mod;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Combinatorics"
                ],
                "code": "```\\nconst ll = BigInt, mod = ll(1e9 + 7), N = 1e4 + 15;\\n\\nconst hcomb = (p, q) => p == 0 && q == 0 ? 1 : comb(p + q - 1, q);\\nconst comb_init = () => {\\n    fact[0] = ifact[0] = inv[1] = 1n; // factorial, inverse factorial\\n    for (let i = 2; i < N; i++) inv[i] = (mod - mod / ll(i)) * inv[mod % ll(i)] % mod;\\n    for (let i = 1; i < N; i++) {\\n        fact[i] = fact[i - 1] * ll(i) % mod;\\n        ifact[i] = ifact[i - 1] * inv[i] % mod;\\n    }\\n};\\n\\n// combination mod pick k from n\\nconst comb = (n, k) => {\\n    if (n < k || k < 0) return 0;\\n    return fact[n] * ifact[k] % mod * ifact[n - k] % mod;\\n};\\n\\n/*\\nprerequisite:\\n(number of factors)\\nhttps://www.codechef.com/LTIME01/problems/NUMFACT\\nmy solution: https://www.codechef.com/viewsolution/67461009\\n*/\\nconst number_factor = (n) => {\\n    let m = new Map();\\n    for (let i = 2; i * i <= n; i++) {\\n        while (n % i == 0) {\\n            n /= i;\\n            m.set(i, m.get(i) + 1 || 1);\\n        }\\n    }\\n    if (n > 1) m.set(n, m.get(n) + 1 || 1);\\n    return m;\\n};\\n\\nlet fact, ifact, inv;\\nconst idealArrays = (n, maxValue) => {\\n    fact = Array(N).fill(0), ifact = Array(N).fill(0), inv = Array(N).fill(0);\\n    comb_init();\\n    let res = 0n;\\n    for (let x = 1; x <= maxValue; x++) {\\n        let perm = 1n, m = number_factor(x);\\n        for (const [x, occ] of m) {\\n            perm = perm * hcomb(n, occ) % mod;\\n        }\\n        res += perm;\\n    }\\n    return res % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2262433,
                "title": "c-dp-with-primes-o-n-logn-61ms",
                "content": "https://leetcode.com/submissions/detail/743226590/\\n`table[j]` is the number of valid sequences ending in the `j`-th power of any prime number.\\n`dp[i]` is the number of valid sequences ending in any integer `i <= maxValue`. The main loop is constructed such that each `dp[i]` is only computed once and the factors of `i` are computed before `i`.\\n```\\nclass Solution {\\n    enum { mod = int(1e9) + 7 };\\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        vector<int> table(log2(maxValue)+1);\\n        table[0] = 1;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 1; j < table.size(); ++j) {\\n                table[j] = (table[j] + table[j-1]) % mod;\\n            }\\n        }\\n        \\n        set<int> factors;\\n        vector<int> dp(maxValue+1), new_factors;\\n        dp[1] = 1;\\n        for (int j = 2; j <= maxValue; ++j) {\\n            if (dp[j] > 0) continue; // not prime\\n            \\n            for (int k = j, i = 1; k <= maxValue; k *= j, ++i) {\\n                int64_t base_val = dp[k] = table[i];\\n                new_factors.push_back(k); // prime powers\\n                \\n                for (int f: factors) {\\n                    if (k*f > maxValue) break;\\n                    dp[k*f] = base_val * dp[f] % mod;\\n                    new_factors.push_back(k*f); // other composites\\n                }\\n            }\\n            factors.insert(new_factors.begin(), new_factors.end());\\n            new_factors.clear();\\n        }\\n        \\n        int result = 0;\\n        for (int c: dp) {\\n            result = (result + c) % mod;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nBonus: basic DP solution, O(N\\xB2\\xB7logN)\\n```\\n    int idealArrays(int n, int maxValue) {\\n        vector<int> dp(maxValue+1, 1);\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 1; j <= maxValue; ++j) {\\n                int val = 0;\\n                for (int k = j; k <= maxValue; k += j) {\\n                    val = (val + dp[k]) % mod;\\n                }\\n                dp[j] = val;\\n            }\\n        }\\n        int result = 0;\\n        for (int j = 1; j <= maxValue; ++j) {\\n            result = (result + dp[j]) % mod;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    enum { mod = int(1e9) + 7 };\\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        vector<int> table(log2(maxValue)+1);\\n        table[0] = 1;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 1; j < table.size(); ++j) {\\n                table[j] = (table[j] + table[j-1]) % mod;\\n            }\\n        }\\n        \\n        set<int> factors;\\n        vector<int> dp(maxValue+1), new_factors;\\n        dp[1] = 1;\\n        for (int j = 2; j <= maxValue; ++j) {\\n            if (dp[j] > 0) continue; // not prime\\n            \\n            for (int k = j, i = 1; k <= maxValue; k *= j, ++i) {\\n                int64_t base_val = dp[k] = table[i];\\n                new_factors.push_back(k); // prime powers\\n                \\n                for (int f: factors) {\\n                    if (k*f > maxValue) break;\\n                    dp[k*f] = base_val * dp[f] % mod;\\n                    new_factors.push_back(k*f); // other composites\\n                }\\n            }\\n            factors.insert(new_factors.begin(), new_factors.end());\\n            new_factors.clear();\\n        }\\n        \\n        int result = 0;\\n        for (int c: dp) {\\n            result = (result + c) % mod;\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\n    int idealArrays(int n, int maxValue) {\\n        vector<int> dp(maxValue+1, 1);\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 1; j <= maxValue; ++j) {\\n                int val = 0;\\n                for (int k = j; k <= maxValue; k += j) {\\n                    val = (val + dp[k]) % mod;\\n                }\\n                dp[j] = val;\\n            }\\n        }\\n        int result = 0;\\n        for (int j = 1; j <= maxValue; ++j) {\\n            result = (result + dp[j]) % mod;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262034,
                "title": "c-prime-table-permutation-table",
                "content": "```\\nclass Solution {\\nprivate:\\n    const long long MAX=1000000007;\\n    vector<long long> pr;//prime\\n    vector<vector<long long> > cc;// C(n+i-1,i)\\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        int i,j;\\n        long long result=0;\\n        cc.push_back({1});\\n        for (i=1;i<=maxValue;i++) {\\n            vector<int> dv;\\n            long long ti=i;\\n            for (j=0;j<pr.size()&&pr[j]<=ti&&pr[j]*pr[j]<=i;j++) {\\n                if (ti%pr[j]==0) {\\n                    int di=dv.size();\\n                    dv.push_back(0);\\n                    while (ti%pr[j]==0&&ti>1) {\\n                        dv[di]++;\\n                        ti/=pr[j];\\n                    }\\n                }\\n            }\\n            if (dv.size()==0&&i!=1) {\\n                pr.push_back(i);//append prime\\n            }\\n            if (ti!=1) {\\n                dv.push_back(1);//append remained item\\n            }\\n            result=(calc(n,dv)+result)%MAX;\\n        }\\n        return (int)(result%MAX);\\n    }\\n    long long calc(int n,vector<int> &dv) {\\n        long long res=1;\\n        for (int i=0;i<dv.size();i++) {\\n            res=(res*cm(n,dv[i]))%MAX;\\n        }\\n        return res;\\n    }\\n    long long cm(int n, int m) {//make permutation chart\\n        if (cc.size()>m) return cc[m][0];\\n        else {\\n            for (int i=cc.size();i<=m;i++) {\\n                vector<long long> ctmp;\\n                int j;\\n                for (j=0;j<cc[i-1].size();j++) ctmp.push_back(cc[i-1][j]*(n+i-1));\\n                for (j=ctmp.size()-1;j>=0;j--) {\\n                    if (j>0) ctmp[j-1]+=ctmp[j]%i*MAX;\\n                    ctmp[j]/=i;\\n                }\\n                j=0;\\n                while (j<ctmp.size()) {\\n                    if (j==ctmp.size()-1) {\\n                        if (ctmp[j]>=MAX) ctmp.push_back(ctmp[j]/MAX);\\n                    }\\n                    else ctmp[j+1]+=ctmp[j]/MAX;\\n                    ctmp[j]%=MAX;\\n                    j++;\\n                }\\n                cc.push_back(ctmp);\\n            }\\n            return cc[m][0];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const long long MAX=1000000007;\\n    vector<long long> pr;//prime\\n    vector<vector<long long> > cc;// C(n+i-1,i)\\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        int i,j;\\n        long long result=0;\\n        cc.push_back({1});\\n        for (i=1;i<=maxValue;i++) {\\n            vector<int> dv;\\n            long long ti=i;\\n            for (j=0;j<pr.size()&&pr[j]<=ti&&pr[j]*pr[j]<=i;j++) {\\n                if (ti%pr[j]==0) {\\n                    int di=dv.size();\\n                    dv.push_back(0);\\n                    while (ti%pr[j]==0&&ti>1) {\\n                        dv[di]++;\\n                        ti/=pr[j];\\n                    }\\n                }\\n            }\\n            if (dv.size()==0&&i!=1) {\\n                pr.push_back(i);//append prime\\n            }\\n            if (ti!=1) {\\n                dv.push_back(1);//append remained item\\n            }\\n            result=(calc(n,dv)+result)%MAX;\\n        }\\n        return (int)(result%MAX);\\n    }\\n    long long calc(int n,vector<int> &dv) {\\n        long long res=1;\\n        for (int i=0;i<dv.size();i++) {\\n            res=(res*cm(n,dv[i]))%MAX;\\n        }\\n        return res;\\n    }\\n    long long cm(int n, int m) {//make permutation chart\\n        if (cc.size()>m) return cc[m][0];\\n        else {\\n            for (int i=cc.size();i<=m;i++) {\\n                vector<long long> ctmp;\\n                int j;\\n                for (j=0;j<cc[i-1].size();j++) ctmp.push_back(cc[i-1][j]*(n+i-1));\\n                for (j=ctmp.size()-1;j>=0;j--) {\\n                    if (j>0) ctmp[j-1]+=ctmp[j]%i*MAX;\\n                    ctmp[j]/=i;\\n                }\\n                j=0;\\n                while (j<ctmp.size()) {\\n                    if (j==ctmp.size()-1) {\\n                        if (ctmp[j]>=MAX) ctmp.push_back(ctmp[j]/MAX);\\n                    }\\n                    else ctmp[j+1]+=ctmp[j]/MAX;\\n                    ctmp[j]%=MAX;\\n                    j++;\\n                }\\n                cc.push_back(ctmp);\\n            }\\n            return cc[m][0];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261909,
                "title": "python-dp-generate-distinct-values",
                "content": "```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        # consider number of distince values (n_val) to construct ideal array\\n        # for a given set of valid distinct values, the contribution to answer is comb(n-1, n_val-1) \\u63D2\\u677F (see e.g.2)\\n        # consider generating sets of valid distinct values:\\n        # for a state: (last_num, n_val), it can generate n_val+1 sets e.g. [...prev sets...last_num*fator] i.e. state (last_num*factor, n_val). contribution of single state is comb(n-1, n_val-1), imagine the huge branching of states in a tree\\n        # same state can appear multiple times: e.g. n_val=3 then [1,2,6], [1,3,6] both has same last_num, so we use dp.\\n        # dp(state): total contribution of state and all future states generated from it\\n        # time O(num of possible states) << O(n*maxValue), space same\\n        \\n        # memory comb(n-1, n_val-1):\\n        cmr = [0] * n # cmr[n_val-1] = comb(n-1, n_val-1)\\n        cmr[0] = 1\\n        for r in range(1, n):\\n            m = n - 1 #, r = n_val - 1\\n            cmr[r] = cmr[r - 1] * (m - r + 1) // r\\n\\n        # dp(last_num, n_val): total count of idealArray for all future (last_num, n_val) stats generated by current state\\n        memo = dict()\\n        def dp(last_num, n_val):\\n            \\n            if maxValue // last_num < 2 or n_val == n:\\n                # cannot generate more\\n                return cmr[n_val - 1]\\n            \\n            if (last_num, n_val) not in memo:\\n                count = cmr[n_val - 1] # contribution of current state\\n                # contribution from future states:\\n                for factor in range(2, maxValue // last_num + 1):\\n                    count += dp(factor * last_num, n_val + 1)\\n                memo[(last_num, n_val)] = count\\n            \\n            return memo[(last_num, n_val)]\\n        \\n        # sum up all inital states\\n        ans = 0\\n        for i in range(1, maxValue + 1):\\n            ans += dp(i, 1)\\n        \\n        return ans % (10**9 + 7)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        # consider number of distince values (n_val) to construct ideal array\\n        # for a given set of valid distinct values, the contribution to answer is comb(n-1, n_val-1) \\u63D2\\u677F (see e.g.2)\\n        # consider generating sets of valid distinct values:\\n        # for a state: (last_num, n_val), it can generate n_val+1 sets e.g. [...prev sets...last_num*fator] i.e. state (last_num*factor, n_val). contribution of single state is comb(n-1, n_val-1), imagine the huge branching of states in a tree\\n        # same state can appear multiple times: e.g. n_val=3 then [1,2,6], [1,3,6] both has same last_num, so we use dp.\\n        # dp(state): total contribution of state and all future states generated from it\\n        # time O(num of possible states) << O(n*maxValue), space same\\n        \\n        # memory comb(n-1, n_val-1):\\n        cmr = [0] * n # cmr[n_val-1] = comb(n-1, n_val-1)\\n        cmr[0] = 1\\n        for r in range(1, n):\\n            m = n - 1 #, r = n_val - 1\\n            cmr[r] = cmr[r - 1] * (m - r + 1) // r\\n\\n        # dp(last_num, n_val): total count of idealArray for all future (last_num, n_val) stats generated by current state\\n        memo = dict()\\n        def dp(last_num, n_val):\\n            \\n            if maxValue // last_num < 2 or n_val == n:\\n                # cannot generate more\\n                return cmr[n_val - 1]\\n            \\n            if (last_num, n_val) not in memo:\\n                count = cmr[n_val - 1] # contribution of current state\\n                # contribution from future states:\\n                for factor in range(2, maxValue // last_num + 1):\\n                    count += dp(factor * last_num, n_val + 1)\\n                memo[(last_num, n_val)] = count\\n            \\n            return memo[(last_num, n_val)]\\n        \\n        # sum up all inital states\\n        ans = 0\\n        for i in range(1, maxValue + 1):\\n            ans += dp(i, 1)\\n        \\n        return ans % (10**9 + 7)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261890,
                "title": "python3-naive-combinatorics-solution",
                "content": "I did not turn this in on time, but here is my methodology and solution:\\n1. I sensed that for each value <= maxValue,  count(n, value) would be a sum of count(n - 1, factor) for each factor.\\n2. I started on a DP solution, but determined that it would be O(N * maxValue * Log(maxValue)) at best, and knew that the constraints would lead to a RTE. After looking for something faster, I abandoned this approach.\\n3. Even though I studied combinatorics back in college in the 1980s, I decided I needed to find patterns. So I produced a brute-force function to print out counts at multiple levels:\\n    ```    \\n\\tMOD = 1000000007\\n    class Solution:\\n\\n\\t   def idealArrays(self, n: int, maxValue: int) -> int:\\n\\t\\t\\tx1 = self.idealArraysSlow(n, maxValue)\\n\\t\\t\\treturn x1\\n\\n\\t\\tdef idealArraysSlow(self, n: int, maxValue: int) -> int:\\n\\t\\t\\tcounts = [0] + [1] * maxValue\\n\\t\\t\\tfor i in range(2, n + 1):\\n\\t\\t\\t\\tnewCounts = [0] * (maxValue + 1)\\n\\t\\t\\t\\tfor v1 in range(1, maxValue + 1):\\n\\t\\t\\t\\t\\tif counts[v1] == 0:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tv2 = v1\\n\\t\\t\\t\\t\\twhile v2 <= maxValue:\\n\\t\\t\\t\\t\\t\\tnewCounts[v2] += counts[v1]\\n\\t\\t\\t\\t\\t\\tv2 += v1\\n\\t\\t\\t\\tcounts = newCounts\\n\\t\\t\\t\\tprint(\\'i={}, counts={}\\'.format(i, counts))\\n\\t\\t\\treturn sum(counts) % MOD\\n    ```    \\n4. Running this for inputs (5, 25) gave me all the patterns I needed:\\n    ```\\n\\ti=2, counts=[0, 1, 2, 2, 3, 2, 4, 2, 4, 3, 4, 2, 6, 2, 4, 4, 5, 2, 6, 2, 6, 4, 4, 2, 8, 3]\\n\\ti=3, counts=[0, 1, 3, 3, 6, 3, 9, 3, 10, 6, 9, 3, 18, 3, 9, 9, 15, 3, 18, 3, 18, 9, 9, 3, 30, 6]\\n\\ti=4, counts=[0, 1, 4, 4, 10, 4, 16, 4, 20, 10, 16, 4, 40, 4, 16, 16, 35, 4, 40, 4, 40, 16, 16, 4, 80, 10]\\n\\ti=5, counts=[0, 1, 5, 5, 15, 5, 25, 5, 35, 15, 25, 5, 75, 5, 25, 25, 70, 5, 75, 5, 75, 25, 25, 5, 175, 15]\\n\\t```\\n    *  Prime values produce counts[p] = [2, 3, 4, 5].\\n    *  Values of the form (p * q) (like 6) produce counts[p * q] = [4, 9, 16, 25] = counts[p] * counts[q].\\n    *  Values of the form (p^2) (like 4) produce counts [p^2] = [3, 6, 10, 15].\\n    *  Values of the form (p^3) (like 8) produce counts[p^3] = [4, 10, 20, 35].\\n    *  Values of the form (p^2 * q) (like 12) produce counts[p^2 * q] = [6, 18, 40, 75] = counts[p^2] * counts[q].\\n5. At this point, I knew that the exponents of the prime factors were all I needed. For speed, I decided to use memoization at the module level, as this is reused from test case to test case.\\n    ```\\n\\t# Return power distributions of prime factors.\\n\\t# 2 -> [1], 6 -> [1, 1], 8 -> [3], 12 -> [2, 1].\\n\\t@functools.cache\\n\\tdef primeFactorPowers(n: int) -> List[int]:\\n\\t\\tfactors = []\\n\\t\\ti = 2\\n\\t\\twhile i * i <= n:\\n\\t\\t\\twhile n % i == 0:\\n\\t\\t\\t\\tfactors.append(i)\\n\\t\\t\\t\\tn //= i\\n\\t\\t\\ti += 1\\n\\t\\tif n > 1:\\n\\t\\t\\tfactors.append(n)\\n\\t\\tcounts = defaultdict(int)\\n\\t\\tfor f in factors:\\n\\t\\t\\tcounts[f] += 1\\n\\t\\treturn sorted(counts.values())\\n    ```\\n6. I now had 20 minutes left, and all I had to do was convert the primeFactorPowers into their n-choose-k products, about 5 minutes of coding, I figured. Instead, I spend 30 minutes trying to debug my final bit of code. My final solution (cleaned up):\\n    ```\\n\\tclass Solution:\\n\\n\\t\\tdef idealArrays(self, n: int, maxValue: int) -> int:\\n\\t\\t\\tx2 = self.idealArraysFast(n, maxValue)\\n\\t\\t\\treturn x2\\n\\n\\t\\tdef idealArraysFast(self, n: int, maxValue: int) -> int:\\n\\t\\t\\ttotal = 0\\n\\t\\t\\tfor value in range(1, maxValue + 1):\\n\\t\\t\\t\\tprod = 1\\n\\t\\t\\t\\tpfps = primeFactorPowers(value)\\n\\t\\t\\t\\tfor pfp in pfps:\\n\\t\\t\\t\\t\\tfor j in range(1, pfp + 1):\\n\\t\\t\\t\\t\\t\\tprod *= (n + pfp - j)\\n\\t\\t\\t\\t\\t\\tprod //= j\\n\\t\\t\\t\\t\\tprod %= MOD\\n\\t\\t\\t\\ttotal += prod\\n\\t\\t\\treturn total % MOD\\n    ```\\n7. I turned this in about 10 minutes after the contest ended. I had started down a rapid rerun-tweak cycle that ended up with me making random changes to my loop rather than making progress. In retrospect:\\n    *  I should have extracted a standalone function to convert (value, n) to the number of ideal arrays ending in value, so that I could more easily debug my errors.\\n    * I should have written down my patterns on paper, maybe mapped out a Pascal\\'s triangle to refresh my memory.\\n\\t\\n\\n",
                "solutionTags": [],
                "code": "```    \\n\\tMOD = 1000000007\\n    class Solution:\\n\\n\\t   def idealArrays(self, n: int, maxValue: int) -> int:\\n\\t\\t\\tx1 = self.idealArraysSlow(n, maxValue)\\n\\t\\t\\treturn x1\\n\\n\\t\\tdef idealArraysSlow(self, n: int, maxValue: int) -> int:\\n\\t\\t\\tcounts = [0] + [1] * maxValue\\n\\t\\t\\tfor i in range(2, n + 1):\\n\\t\\t\\t\\tnewCounts = [0] * (maxValue + 1)\\n\\t\\t\\t\\tfor v1 in range(1, maxValue + 1):\\n\\t\\t\\t\\t\\tif counts[v1] == 0:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tv2 = v1\\n\\t\\t\\t\\t\\twhile v2 <= maxValue:\\n\\t\\t\\t\\t\\t\\tnewCounts[v2] += counts[v1]\\n\\t\\t\\t\\t\\t\\tv2 += v1\\n\\t\\t\\t\\tcounts = newCounts\\n\\t\\t\\t\\tprint(\\'i={}, counts={}\\'.format(i, counts))\\n\\t\\t\\treturn sum(counts) % MOD\\n    ```\n```\\n\\ti=2, counts=[0, 1, 2, 2, 3, 2, 4, 2, 4, 3, 4, 2, 6, 2, 4, 4, 5, 2, 6, 2, 6, 4, 4, 2, 8, 3]\\n\\ti=3, counts=[0, 1, 3, 3, 6, 3, 9, 3, 10, 6, 9, 3, 18, 3, 9, 9, 15, 3, 18, 3, 18, 9, 9, 3, 30, 6]\\n\\ti=4, counts=[0, 1, 4, 4, 10, 4, 16, 4, 20, 10, 16, 4, 40, 4, 16, 16, 35, 4, 40, 4, 40, 16, 16, 4, 80, 10]\\n\\ti=5, counts=[0, 1, 5, 5, 15, 5, 25, 5, 35, 15, 25, 5, 75, 5, 25, 25, 70, 5, 75, 5, 75, 25, 25, 5, 175, 15]\\n\\t```\n```\\n\\t# Return power distributions of prime factors.\\n\\t# 2 -> [1], 6 -> [1, 1], 8 -> [3], 12 -> [2, 1].\\n\\t@functools.cache\\n\\tdef primeFactorPowers(n: int) -> List[int]:\\n\\t\\tfactors = []\\n\\t\\ti = 2\\n\\t\\twhile i * i <= n:\\n\\t\\t\\twhile n % i == 0:\\n\\t\\t\\t\\tfactors.append(i)\\n\\t\\t\\t\\tn //= i\\n\\t\\t\\ti += 1\\n\\t\\tif n > 1:\\n\\t\\t\\tfactors.append(n)\\n\\t\\tcounts = defaultdict(int)\\n\\t\\tfor f in factors:\\n\\t\\t\\tcounts[f] += 1\\n\\t\\treturn sorted(counts.values())\\n    ```\n```\\n\\tclass Solution:\\n\\n\\t\\tdef idealArrays(self, n: int, maxValue: int) -> int:\\n\\t\\t\\tx2 = self.idealArraysFast(n, maxValue)\\n\\t\\t\\treturn x2\\n\\n\\t\\tdef idealArraysFast(self, n: int, maxValue: int) -> int:\\n\\t\\t\\ttotal = 0\\n\\t\\t\\tfor value in range(1, maxValue + 1):\\n\\t\\t\\t\\tprod = 1\\n\\t\\t\\t\\tpfps = primeFactorPowers(value)\\n\\t\\t\\t\\tfor pfp in pfps:\\n\\t\\t\\t\\t\\tfor j in range(1, pfp + 1):\\n\\t\\t\\t\\t\\t\\tprod *= (n + pfp - j)\\n\\t\\t\\t\\t\\t\\tprod //= j\\n\\t\\t\\t\\t\\tprod %= MOD\\n\\t\\t\\t\\ttotal += prod\\n\\t\\t\\treturn total % MOD\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 2261713,
                "title": "java-183ms-2-dp-solution",
                "content": "High level idea:\\n* We first use DP approach to compute the number of ideal arrays without repeating elements of all possible lengths. The maximum length of such arrays should be log2(maxValue). The recusive function is that given l is the length, and p is the ending element, dp[l][p] is the sum of  all dp[l - 1][q] where p > q and p % q == 0.\\n* We then use DP approach to compute the ways to fill in an ideal array of length n with elements from an ideal array without repeating elements of length l. The recusive function is that given the length of the array is l, and the number of different elements to be used is m, dp[l][m] = dp[l - 1][m] + dp[l -1][m - 1].\\n* For each length l, we can get the product of how many idea arrays of ideal arrays without repeating elements of l (Step 1) and given one of such ideal array, how many ways to fill in a ideal array of length n (Step 2).\\n* Sum up all the products and we get the answer.\\n```\\n    public int idealArrays(int n, int maxValue) {\\n        int m = 0;\\n        long output = 0;\\n\\t\\t\\n\\t\\t// Compute the maximum length of an ideal array without repeating elements\\n        while ((1 << m) <= maxValue) m++;\\n\\t\\t\\n\\t\\tlong[] counts = new long[m + 1], dp1 = new long[maxValue + 1], dp2 = new long[m + 1];\\n        \\n\\t\\t// Compute how many different ideal arrays without repeating elements there are for each length, given the maxValue\\n\\t\\tfor (int i = 1; i <= m; i++) {\\n            long[] next = new long[maxValue + 1];\\n            for (int j = 1; j <= maxValue; j++)\\n                if (i == 1) next[j] = 1;\\n                else {\\n                    int k = j << 1;\\n                    while (k <= maxValue) {\\n                        next[k] = (dp1[j] + next[k]) % 1000000007;\\n                        k += j;\\n                    }\\n                }\\n            for (int j = 1; j <= maxValue; j++) counts[i] = (counts[i] + next[j]) % 1000000007;\\n            dp1 = next;\\n        }\\n\\t\\t\\n\\t\\t// Compute for a ideal array without repeating elements, how many ways can we fill in an array of length n with its elements to form an ideal array\\n        dp2[1] = 1;\\n        for (int i = 2; i <= n; i++) for (int j = m; j > 1; j--) dp2[j] = (dp2[j] + dp2[j - 1]) % 1000000007;\\n\\n        for (int i = 1; i <= m; i++) output = (output + counts[i] * dp2[i]) % 1000000007;\\n        return (int) output;\\n    }\\n```\\nRunning time: O(maxValue * log(maxValue) * log(maxValue) + n * log(maxValue))\\nRunning Space: O(maxValue)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int idealArrays(int n, int maxValue) {\\n        int m = 0;\\n        long output = 0;\\n\\t\\t\\n\\t\\t// Compute the maximum length of an ideal array without repeating elements\\n        while ((1 << m) <= maxValue) m++;\\n\\t\\t\\n\\t\\tlong[] counts = new long[m + 1], dp1 = new long[maxValue + 1], dp2 = new long[m + 1];\\n        \\n\\t\\t// Compute how many different ideal arrays without repeating elements there are for each length, given the maxValue\\n\\t\\tfor (int i = 1; i <= m; i++) {\\n            long[] next = new long[maxValue + 1];\\n            for (int j = 1; j <= maxValue; j++)\\n                if (i == 1) next[j] = 1;\\n                else {\\n                    int k = j << 1;\\n                    while (k <= maxValue) {\\n                        next[k] = (dp1[j] + next[k]) % 1000000007;\\n                        k += j;\\n                    }\\n                }\\n            for (int j = 1; j <= maxValue; j++) counts[i] = (counts[i] + next[j]) % 1000000007;\\n            dp1 = next;\\n        }\\n\\t\\t\\n\\t\\t// Compute for a ideal array without repeating elements, how many ways can we fill in an array of length n with its elements to form an ideal array\\n        dp2[1] = 1;\\n        for (int i = 2; i <= n; i++) for (int j = m; j > 1; j--) dp2[j] = (dp2[j] + dp2[j - 1]) % 1000000007;\\n\\n        for (int i = 1; i <= m; i++) output = (output + counts[i] * dp2[i]) % 1000000007;\\n        return (int) output;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261707,
                "title": "dp-n-log-n-mx",
                "content": "Why this solution is TLE?\\n```\\n    def idealArrays(self, n: int, mx: int) -> int:\\n        modp = 10**9+7     \\n        dp = [[0 for i in range(mx + 1)]\\n                 for i in range(n + 1)]\\n        dp[0][1] = 1\\n        for i in range(n):\\n            for j in range(1, mx + 1):\\n                for k in range(j, mx + 1, j):\\n                    dp[i + 1][k] += dp[i][j]\\n                    dp[i+1][k]%=modp\\n        ans = 0\\n        for i in range(1, mx + 1):\\n            ans += dp[n][i]\\n            ans%=modp\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def idealArrays(self, n: int, mx: int) -> int:\\n        modp = 10**9+7     \\n        dp = [[0 for i in range(mx + 1)]\\n                 for i in range(n + 1)]\\n        dp[0][1] = 1\\n        for i in range(n):\\n            for j in range(1, mx + 1):\\n                for k in range(j, mx + 1, j):\\n                    dp[i + 1][k] += dp[i][j]\\n                    dp[i+1][k]%=modp\\n        ans = 0\\n        for i in range(1, mx + 1):\\n            ans += dp[n][i]\\n            ans%=modp\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2261622,
                "title": "how-to-enumerate",
                "content": "The way that problem description enumerates the sequences makes a hint. Most of the time, the solution can be optimized if we think the problem from another perspective (aka find another way to enumerate and count all the possible sequences)\\n\\n- Enumerate the first number in sequence. PS: This takes O(maxValue)\\n- Enumerate the **Number of Distinct Valus** in sequence. PS: This only takes O(16) as the number of distinct values in a sequence grows expotentially. \\n- Stars and Bars (If we need to fit a length-n sequence with x distinct values, and the values must be sorted. How many ways to fit that?) This is a classic problem of stars and bars, and the answer is pick x - 1 bars from n - 1 stars. \\n\\n```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        \\n        graph = [[] for _ in range(maxValue + 1)]\\n        \\n        for i in range(1, maxValue + 1):\\n            num = i + i\\n            while num <= maxValue:\\n                graph[i].append(num)\\n                num = num + i\\n        \\n        dp = [[-1 for _ in range(maxValue + 1)] for _ in range(20)]\\n        \\n        mod = int(1e9 + 7)\\n        \\n        def dfs(cnt, start):\\n            nonlocal mod\\n            if dp[cnt][start] != -1:\\n                return dp[cnt][start]\\n            if cnt == 1:\\n                return 1\\n            ret = 0\\n            for nxt in graph[start]:\\n                ret = (ret + dfs(cnt - 1, nxt)) % mod\\n            \\n            dp[cnt][start] = ret\\n            return ret\\n        \\n        C = [[0 for _ in range(16)] for _ in range(n + 1)]\\n        \\n            \\n        for i in range(0, n + 1):\\n            for j in range(0, 16):\\n                if j == 0:\\n                    C[i][j] = 1\\n                else:\\n                    C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod\\n\\n    \\n        global_ret = 0\\n        for i in range(1, maxValue + 1):\\n            for x in range(1, 15 + 1):\\n                global_ret = (global_ret + dfs(x, i) * C[n - 1][x - 1]) % mod\\n        \\n        return global_ret\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        \\n        graph = [[] for _ in range(maxValue + 1)]\\n        \\n        for i in range(1, maxValue + 1):\\n            num = i + i\\n            while num <= maxValue:\\n                graph[i].append(num)\\n                num = num + i\\n        \\n        dp = [[-1 for _ in range(maxValue + 1)] for _ in range(20)]\\n        \\n        mod = int(1e9 + 7)\\n        \\n        def dfs(cnt, start):\\n            nonlocal mod\\n            if dp[cnt][start] != -1:\\n                return dp[cnt][start]\\n            if cnt == 1:\\n                return 1\\n            ret = 0\\n            for nxt in graph[start]:\\n                ret = (ret + dfs(cnt - 1, nxt)) % mod\\n            \\n            dp[cnt][start] = ret\\n            return ret\\n        \\n        C = [[0 for _ in range(16)] for _ in range(n + 1)]\\n        \\n            \\n        for i in range(0, n + 1):\\n            for j in range(0, 16):\\n                if j == 0:\\n                    C[i][j] = 1\\n                else:\\n                    C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod\\n\\n    \\n        global_ret = 0\\n        for i in range(1, maxValue + 1):\\n            for x in range(1, 15 + 1):\\n                global_ret = (global_ret + dfs(x, i) * C[n - 1][x - 1]) % mod\\n        \\n        return global_ret\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261618,
                "title": "c-dp-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        int mod=1e9+7;\\n        vector<int>last(maxValue+1,1);\\n        vector<int>current(maxValue+1,0);\\n        for(int i=2;i<=n;i++)\\n        {\\n            current=vector<int>(maxValue+1,0);\\n            for(int j=1;j<=maxValue;j++)\\n            {\\n                for(int k=1;k*j<=maxValue;k++)\\n                {\\n                    current[j]+=last[k*j];\\n                    current[j]%=mod;\\n                }\\n            }\\n            last=current;\\n        }\\n        long long ans=0;\\n        for(int i=1;i<=maxValue;i++)\\n        {\\n            ans+=current[i];\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        int mod=1e9+7;\\n        vector<int>last(maxValue+1,1);\\n        vector<int>current(maxValue+1,0);\\n        for(int i=2;i<=n;i++)\\n        {\\n            current=vector<int>(maxValue+1,0);\\n            for(int j=1;j<=maxValue;j++)\\n            {\\n                for(int k=1;k*j<=maxValue;k++)\\n                {\\n                    current[j]+=last[k*j];\\n                    current[j]%=mod;\\n                }\\n            }\\n            last=current;\\n        }\\n        long long ans=0;\\n        for(int i=1;i<=maxValue;i++)\\n        {\\n            ans+=current[i];\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261605,
                "title": "c-unoptimized-dp-tle",
                "content": "We can idea of DP coming into picture by just trying/writing 2-3 test cases on paper and eventually you\\'ll realize current solution depends on previous iteration solution.\\n\\ne.g for n = 2 , maxValue = 10\\n\\n[0][1] = 1;\\n[0][2] = 1;\\n[0][3] = 1;\\n[0][4] = 1;\\n[0][5] = 1;\\n\\n[1][1] = 1;\\n[1][2] = 2;\\n[1][3] = 2;\\n[1][4] = 3;\\n[1][5] = 2;\\n\\nOn taking sum of 2nd table\\'s output we\\'ll get desired answer.\\n\\nReal challenge of this problem is to optimize this approach. Unfortunately, I couldn\\'t do it.\\n\\nCode ( TLE) :\\n\\n```\\nclass Solution {\\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        vector<vector<long long>> dp(n,vector<long long>(maxValue + 1, 0));\\n        long long ans = 0;\\n        int modl = 1000000007;\\n        for(int i = 0; i <= maxValue; i++)\\n            dp[0][i] = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 1; j <= maxValue; j++)\\n            {\\n                for(int k = 1; k <= sqrt(j); k++)\\n                {\\n                    \\n                    if(j % k == 0)\\n                    {\\n                        int l = j/k;\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k])%modl;\\n                        if(l != k)\\n                            dp[i][j] = (dp[i][j] + dp[i-1][l])%modl;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        for(int i = 1; i <= maxValue; i++)\\n        ans = (ans + dp[n-1][i])%modl;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int idealArrays(int n, int maxValue) {\\n        vector<vector<long long>> dp(n,vector<long long>(maxValue + 1, 0));\\n        long long ans = 0;\\n        int modl = 1000000007;\\n        for(int i = 0; i <= maxValue; i++)\\n            dp[0][i] = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 1; j <= maxValue; j++)\\n            {\\n                for(int k = 1; k <= sqrt(j); k++)\\n                {\\n                    \\n                    if(j % k == 0)\\n                    {\\n                        int l = j/k;\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k])%modl;\\n                        if(l != k)\\n                            dp[i][j] = (dp[i][j] + dp[i-1][l])%modl;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        for(int i = 1; i <= maxValue; i++)\\n        ans = (ans + dp[n-1][i])%modl;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261600,
                "title": "java-dp-tabulation-solution-but-tle",
                "content": "```\\nclass Solution {\\n    public int idealArrays(int n, int maxValue) {\\n        int mod =1000000007;\\n        long [][] dp = new long[n+1][maxValue+1];\\n        for(int i = 0;i<=n;i++){\\n            for(int j = 0;j<=maxValue;j++){\\n                if(i==0||j==0){\\n                    dp[i][j] = 0;\\n                }else if(i==1||j==1){\\n                    dp[i][j] = 1;\\n                } else{\\n                    for(int k = 1;k<=j;k++){\\n                        if(j%k==0){\\n                            dp[i][j] = (dp[i][j]+ dp[i-1][k] ) %mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        long ans = 0;\\n        for(int i = 0;i<=maxValue;i++){\\n            ans = (ans+ dp[n][i] )%mod;\\n        }\\n        return (int) (ans%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int idealArrays(int n, int maxValue) {\\n        int mod =1000000007;\\n        long [][] dp = new long[n+1][maxValue+1];\\n        for(int i = 0;i<=n;i++){\\n            for(int j = 0;j<=maxValue;j++){\\n                if(i==0||j==0){\\n                    dp[i][j] = 0;\\n                }else if(i==1||j==1){\\n                    dp[i][j] = 1;\\n                } else{\\n                    for(int k = 1;k<=j;k++){\\n                        if(j%k==0){\\n                            dp[i][j] = (dp[i][j]+ dp[i-1][k] ) %mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        long ans = 0;\\n        for(int i = 0;i<=maxValue;i++){\\n            ans = (ans+ dp[n][i] )%mod;\\n        }\\n        return (int) (ans%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261573,
                "title": "is-there-a-way-that-takes-less-than-o-n-maxvalues-time-complexity",
                "content": "I think my code takes O(n * maxValues) time and O(maxValues) space complexity.\\nBut, it makes TLE (time limit exceeded).\\n\\nHow can I improve this in JavaScript not to make TLE?\\n\\n```\\n/**\\n * @param {number} n\\n * @param {number} maxValue\\n * @return {number}\\n */\\nvar idealArrays = function(n, maxValue) {\\n  const mod = 1e9 + 7;\\n  let cur = 0;\\n  let arr = Array(2).fill().map(() => Array(maxValue).fill(1));\\n  for (let l = 2; l <= n; l++) {\\n    const prev = arr[cur];\\n    const next = arr[1-cur];\\n    for (let s = 1; s <= maxValue; s++) {\\n      let res = 0;\\n      for (let m = 1; m * s <= maxValue; m++) {\\n        res = (res + prev[m * s - 1]) % mod;\\n      }\\n      next[s-1] = res;\\n    }\\n    cur = 1 - cur;\\n  }\\n  const res = arr[cur].reduce((a, b) => (a + b) % mod, 0);\\n  return res;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} maxValue\\n * @return {number}\\n */\\nvar idealArrays = function(n, maxValue) {\\n  const mod = 1e9 + 7;\\n  let cur = 0;\\n  let arr = Array(2).fill().map(() => Array(maxValue).fill(1));\\n  for (let l = 2; l <= n; l++) {\\n    const prev = arr[cur];\\n    const next = arr[1-cur];\\n    for (let s = 1; s <= maxValue; s++) {\\n      let res = 0;\\n      for (let m = 1; m * s <= maxValue; m++) {\\n        res = (res + prev[m * s - 1]) % mod;\\n      }\\n      next[s-1] = res;\\n    }\\n    cur = 1 - cur;\\n  }\\n  const res = arr[cur].reduce((a, b) => (a + b) % mod, 0);\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261520,
                "title": "getting-tle",
                "content": "class Solution {\\n    \\n    \\n    \\npublic:\\n    \\n    \\n    \\n    // bool check(vector<int>& vec)\\n    // {\\n    //     for(int i=1;i<vec.size();i++)\\n    //     {\\n    //         if(vec[i]%vec[i-1] != 0)\\n    //             return false;\\n    //     }\\n    //     return true;\\n    // }\\n    \\n    \\n    void findval(vector<int>& vec,int& ans,int n,int maxValue)\\n    {\\n        if(vec.size() == n){\\n            // if(check(vec))\\n            // {\\n            //     ans++;\\n            // }\\n            // return;\\n            ans++;\\n            return;\\n        }\\n        for(int i=1;i<=maxValue;i++)\\n        {\\n            if(!vec.empty())\\n            {\\n                int x = vec[vec.size()-1];\\n                if(i%x == 0)\\n                {\\n                    vec.push_back(i);\\n                    findval(vec,ans,n,maxValue);\\n                    vec.pop_back();\\n                }\\n                \\n            }\\n            else{\\n                vec.push_back(i);\\n                findval(vec,ans,n,maxValue);\\n                vec.pop_back();\\n            }\\n            \\n        }\\n    }\\n    int idealArrays(int n, int maxValue) {\\n        vector<int> vec;\\n        int ans = 0;\\n        findval(vec,ans,n,maxValue);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    \\n    \\npublic:\\n    \\n    \\n    \\n    // bool check(vector<int>& vec)\\n    // {\\n    //     for(int i=1;i<vec.size();i++)\\n    //     {\\n    //         if(vec[i]%vec[i-1] != 0)\\n    //             return false;\\n    //     }",
                "codeTag": "Java"
            },
            {
                "id": 2261441,
                "title": "python-brute-force-tle",
                "content": "```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        M = 10**9 + 7\\n        @lru_cache()\\n        def dp(prev, count):\\n            if count == n:\\n                return 1\\n            \\n            res = 0\\n            for nextNum in range(prev, maxValue+1, prev):\\n                res += dp(nextNum, count+1) % M\\n            return (res % M)\\n        \\n        return (dp(1, 0) % M)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        M = 10**9 + 7\\n        @lru_cache()\\n        def dp(prev, count):\\n            if count == n:\\n                return 1\\n            \\n            res = 0\\n            for nextNum in range(prev, maxValue+1, prev):\\n                res += dp(nextNum, count+1) % M\\n            return (res % M)\\n        \\n        return (dp(1, 0) % M)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261434,
                "title": "c-dp-gets-tle",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    int mod = pow(10, 9) + 7;\\n    int dfs(int n, int prev, int maxval, vector<vector<int>> &dp)\\n    {\\n        if (n == 0)\\n            return 1;\\n\\n        if (dp[n][prev] != -1)\\n            return dp[n][prev];\\n\\n        int ways = 0;\\n\\n        for (int i = prev; i <= maxval; i += prev)\\n        {\\n            ways = (ways + dfs(n - 1, i, maxval, dp)) % mod;\\n        }\\n\\n        return dp[n][prev] = ways;\\n    }\\n    int idealArrays(int n, int maxValue)\\n    {\\n        vector<vector<int>> dp(n + 1, vector<int>(\\n                                          maxValue + 1, -1));\\n\\n        return dfs(n, 1, maxValue, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    int mod = pow(10, 9) + 7;\\n    int dfs(int n, int prev, int maxval, vector<vector<int>> &dp)\\n    {\\n        if (n == 0)\\n            return 1;\\n\\n        if (dp[n][prev] != -1)\\n            return dp[n][prev];\\n\\n        int ways = 0;\\n\\n        for (int i = prev; i <= maxval; i += prev)\\n        {\\n            ways = (ways + dfs(n - 1, i, maxval, dp)) % mod;\\n        }\\n\\n        return dp[n][prev] = ways;\\n    }\\n    int idealArrays(int n, int maxValue)\\n    {\\n        vector<vector<int>> dp(n + 1, vector<int>(\\n                                          maxValue + 1, -1));\\n\\n        return dfs(n, 1, maxValue, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261415,
                "title": "applying-backtracking-getting-time-limit-exceeded",
                "content": "class Solution {\\npublic:\\n    int ans=0;\\n    int num=1000000007;\\n    void myfun(int i,int d,int maxdepth,int maxvalue){\\n        if(d==maxdepth){\\n            ans=(ans%num)+1;\\n            return;\\n        }\\n        for(int j=i;j<=maxvalue;j++){\\n            if(j%i)continue;\\n            myfun(j,d+1,maxdepth,maxvalue);\\n        }\\n    }\\n    int idealArrays(int n, int maxvalue) {\\n        for(int i=1;i<=maxvalue;i++){\\n            myfun(i,1,n,maxvalue);\\n        }\\n        return ans%num;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    int num=1000000007;\\n    void myfun(int i,int d,int maxdepth,int maxvalue){\\n        if(d==maxdepth){\\n            ans=(ans%num)+1;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2261404,
                "title": "stars-bars-choosing-non-decreasing-subsequences-of-exponents-of-primes",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.MOD = 1000000007\\n        self.memo = {0: 1}\\n        self.fact = [1 for i in range(10100)]\\n        \\n    def inv(self, x):\\n        if x>1: return self.inv(self.MOD%x)*(self.MOD-self.MOD//x)%self.MOD \\n        else: return x\\n        \\n    def choose(self, n, k):\\n        return ((self.fact[n] * self.inv(self.fact[n-k]) ) % self.MOD )* self.inv(self.fact[k]) %self.MOD\\n    \\n    def factors(self, x):\\n        a = []\\n        i = 2\\n        while x > 1:\\n            re = 0\\n            while x % i == 0:\\n                re += 1\\n                x //= i\\n            if re: a.append(re)\\n            i += 1\\n        return a   \\n    \\n    def h(self, v):\\n        if v in self.memo: return self.memo[v]\\n        self.memo[v] = self.choose(v+self.c, self.c)\\n        return self.memo[v]\\n        \\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        s = 0\\n        self.c = n-1\\n        \\n        for i in range(2,10100):\\n            self.fact[i] = self.fact[i-1] * i % self.MOD\\n\\n        for i in range(1, maxValue+1):\\n            cur = 1\\n            fa = self.factors(i)\\n            for f in fa: cur = (cur*self.h(f))%self.MOD\\n            s = (s+cur)%self.MOD\\n        return s\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.MOD = 1000000007\\n        self.memo = {0: 1}\\n        self.fact = [1 for i in range(10100)]\\n        \\n    def inv(self, x):\\n        if x>1: return self.inv(self.MOD%x)*(self.MOD-self.MOD//x)%self.MOD \\n        else: return x\\n        \\n    def choose(self, n, k):\\n        return ((self.fact[n] * self.inv(self.fact[n-k]) ) % self.MOD )* self.inv(self.fact[k]) %self.MOD\\n    \\n    def factors(self, x):\\n        a = []\\n        i = 2\\n        while x > 1:\\n            re = 0\\n            while x % i == 0:\\n                re += 1\\n                x //= i\\n            if re: a.append(re)\\n            i += 1\\n        return a   \\n    \\n    def h(self, v):\\n        if v in self.memo: return self.memo[v]\\n        self.memo[v] = self.choose(v+self.c, self.c)\\n        return self.memo[v]\\n        \\n    def idealArrays(self, n: int, maxValue: int) -> int:\\n        s = 0\\n        self.c = n-1\\n        \\n        for i in range(2,10100):\\n            self.fact[i] = self.fact[i-1] * i % self.MOD\\n\\n        for i in range(1, maxValue+1):\\n            cur = 1\\n            fa = self.factors(i)\\n            for f in fa: cur = (cur*self.h(f))%self.MOD\\n            s = (s+cur)%self.MOD\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261357,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nNote: all 3 solutions TLE.  I was totally bummed during Contest 301, the bottom-up solution TLE\\'ed too!\\n\\n```\\n# 1. All possibilities are considered via top-down brute-force depth-first-search\\n\\nclass Solution:\\n    def idealArrays(self, N: int, K: int, cnt = 0, MOD = int(1e9 + 7)) -> int:\\n        def go(x, n):\\n            if not n:\\n                return 1\\n            cnt = 0\\n            for y in range(x, K + 1):\\n                if y % x:\\n                    continue\\n                cnt = (cnt + go(y, n - 1)) % MOD\\n            return cnt\\n        for x in range(1, K + 1):\\n            cnt = (cnt + go(x, N - 1)) % MOD\\n        return cnt\\n\\n\\n# 2. Remember each subproblem\\'s optimal solution via a DP memo\\n\\nclass Solution:\\n    def idealArrays(self, N: int, K: int, cnt = 0, MOD = int(1e9 + 7)) -> int:\\n        @cache\\n        def go(x, n):\\n            if not n:\\n                return 1\\n            cnt = 0\\n            for y in range(x, K + 1):\\n                if y % x:\\n                    continue\\n                cnt = (cnt + go(y, n - 1)) % MOD\\n            return cnt\\n        for x in range(1, K + 1):\\n            cnt = (cnt + go(x, N - 1)) % MOD\\n        return cnt\\n\\n\\n# 3. Turn the top-down solution upside-down to create the bottom-up solution\\n\\nclass Solution:\\n    def idealArrays(self, N: int, K: int, cnt = 0, MOD = int(1e9 + 7)) -> int:\\n        dp = [[0] * (N) for _ in range(K + 1)]\\n        for x in range(K + 1):\\n            dp[x][0] = 1\\n        for n in range(1, N):\\n            for x in range(1, K + 1):\\n                for y in range(x, K + 1):\\n                    if y % x:\\n                        continue\\n                    dp[x][n] = (dp[x][n] + dp[y][n - 1]) % MOD\\n        t = 0\\n        for x in range(1, K + 1):\\n            t = (t + dp[x][N - 1]) % MOD\\n        return t\\n```",
                "solutionTags": [],
                "code": "```\\n# 1. All possibilities are considered via top-down brute-force depth-first-search\\n\\nclass Solution:\\n    def idealArrays(self, N: int, K: int, cnt = 0, MOD = int(1e9 + 7)) -> int:\\n        def go(x, n):\\n            if not n:\\n                return 1\\n            cnt = 0\\n            for y in range(x, K + 1):\\n                if y % x:\\n                    continue\\n                cnt = (cnt + go(y, n - 1)) % MOD\\n            return cnt\\n        for x in range(1, K + 1):\\n            cnt = (cnt + go(x, N - 1)) % MOD\\n        return cnt\\n\\n\\n# 2. Remember each subproblem\\'s optimal solution via a DP memo\\n\\nclass Solution:\\n    def idealArrays(self, N: int, K: int, cnt = 0, MOD = int(1e9 + 7)) -> int:\\n        @cache\\n        def go(x, n):\\n            if not n:\\n                return 1\\n            cnt = 0\\n            for y in range(x, K + 1):\\n                if y % x:\\n                    continue\\n                cnt = (cnt + go(y, n - 1)) % MOD\\n            return cnt\\n        for x in range(1, K + 1):\\n            cnt = (cnt + go(x, N - 1)) % MOD\\n        return cnt\\n\\n\\n# 3. Turn the top-down solution upside-down to create the bottom-up solution\\n\\nclass Solution:\\n    def idealArrays(self, N: int, K: int, cnt = 0, MOD = int(1e9 + 7)) -> int:\\n        dp = [[0] * (N) for _ in range(K + 1)]\\n        for x in range(K + 1):\\n            dp[x][0] = 1\\n        for n in range(1, N):\\n            for x in range(1, K + 1):\\n                for y in range(x, K + 1):\\n                    if y % x:\\n                        continue\\n                    dp[x][n] = (dp[x][n] + dp[y][n - 1]) % MOD\\n        t = 0\\n        for x in range(1, K + 1):\\n            t = (t + dp[x][N - 1]) % MOD\\n        return t\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1858440,
                "content": [
                    {
                        "username": "TheBuddhist",
                        "content": "It took 1.5 days for me to solve it, finally solved it, it\\'s quite hard as there are many ways not to think about the actual solution. "
                    }
                ]
            }
        ]
    }
]