[
    {
        "title": "Recover Binary Search Tree",
        "question_content": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.\n&nbsp;\nExample 1:\n\nInput: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n\nExample 2:\n\nInput: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [2, 1000].\n\t-231 <= Node.val <= 231 - 1\n\n&nbsp;\nFollow up: A solution using O(n) space is pretty straight-forward. Could you devise a constant O(1) space solution?",
        "solutions": [
            {
                "id": 32535,
                "title": "no-fancy-algorithm-just-simple-and-powerful-in-order-traversal",
                "content": "This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here. \\n\\nLet's start by writing the in order traversal:\\n\\n    private void traverse (TreeNode root) {\\n       if (root == null)\\n          return;\\n       traverse(root.left);\\n       // Do some business\\n       traverse(root.right);\\n    }\\n\\nSo when we need to print the node values in order, we insert System.out.println(root.val) in the place of \"Do some business\".\\n\\nWhat is the business we are doing here?\\nWe need to find the first and second elements that are not in order right?\\n\\nHow do we find these two elements? For example, we have the following tree that is printed as in order traversal:\\n\\n6, 3, 4, 5, 2\\n\\nWe compare each node with its next one and we can find out that 6 is the first element to swap because 6 > 3 and 2 is the second element to swap because 2 < 5.\\n\\nReally, what we are comparing is the current node and its previous node in the \"in order traversal\". \\n\\nLet us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the \"do some business\" logic as finding the two elements. See the code below:\\n\\n    public class Solution {\\n        \\n        TreeNode firstElement = null;\\n        TreeNode secondElement = null;\\n        // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized\\n        TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);\\n        \\n        public void recoverTree(TreeNode root) {\\n            \\n            // In order traversal to find the two elements\\n            traverse(root);\\n            \\n            // Swap the values of the two nodes\\n            int temp = firstElement.val;\\n            firstElement.val = secondElement.val;\\n            secondElement.val = temp;\\n        }\\n        \\n        private void traverse(TreeNode root) {\\n            \\n            if (root == null)\\n                return;\\n                \\n            traverse(root.left);\\n            \\n            // Start of \"do some business\", \\n            // If first element has not been found, assign it to prevElement (refer to 6 in the example above)\\n            if (firstElement == null && prevElement.val >= root.val) {\\n                firstElement = prevElement;\\n            }\\n        \\n            // If first element is found, assign the second element to the root (refer to 2 in the example above)\\n            if (firstElement != null && prevElement.val >= root.val) {\\n                secondElement = root;\\n            }        \\n            prevElement = root;\\n\\n            // End of \"do some business\"\\n\\n            traverse(root.right);\\n    }\\n\\nAnd we are done, it is just that easy!",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        TreeNode firstElement = null;\\n        TreeNode secondElement = null;\\n        // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized\\n        TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);\\n        \\n        public void recoverTree(TreeNode root) {\\n            \\n            // In order traversal to find the two elements\\n            traverse(root);\\n            \\n            // Swap the values of the two nodes\\n            int temp = firstElement.val;\\n            firstElement.val = secondElement.val;\\n            secondElement.val = temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32559,
                "title": "detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer",
                "content": "To understand this, you need to first understand Morris Traversal or Morris Threading Traversal.\\nIt take use of leaf nodes' right/left pointer to achieve O(1) space Traversal on a Binary Tree.\\nBelow is a standard Inorder Morris Traversal, referred from http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html (a Chinese Blog, while the graphs are great for illustration)\\n\\n    public void morrisTraversal(TreeNode root){\\n    \\t\\tTreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n\\nIn the above code, `System.out.println(root.val);`appear twice, which functions as outputing the Node in ascending order (BST). Since these places are in order, replace them with\\n\\n        if(pre!=null && pre.val > root.val){\\n        \\tif(first==null){first = pre;second = root;}\\n        \\telse{second = root;}\\n      }\\n    pre = root;\\n\\neach time, the pre node and root are in order as `System.out.println(root.val);` outputs them in order.\\n\\nThen, come to how to specify the first wrong node and second wrong node.\\n\\nWhen they are not consecutive, the first time we meet `pre.val > root.val` ensure us the first node is the pre node, since root should be traversal ahead of pre, pre should be at least at small as root. The second time we meet `pre.val > root.val` ensure us the second node is the root node, since we are now looking for a node to replace with out first node, which is found before.\\n\\nWhen they are consecutive, which means the case `pre.val > cur.val` will appear only once. We need to take case this case without destroy the previous analysis. So the first node will still be pre, and the second will be just set to root. Once we meet this case again, the first node will not be affected.\\n\\nBelow is the updated version on Morris Traversal.\\n\\n\\n    public void recoverTree(TreeNode root) {\\n            TreeNode pre = null;\\n            TreeNode first = null, second = null;\\n            // Morris Traversal\\n            TreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t    if(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t        if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t        else{second = root;}\\n    \\t\\t\\t\\t    }\\n    \\t\\t\\t\\t    pre = root;\\n    \\t\\t\\t\\t    \\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tif(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t    if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t    else{second = root;}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tpre = root;\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// swap two node values;\\n    \\t\\tif(first!= null && second != null){\\n    \\t\\t    int t = first.val;\\n    \\t\\t    first.val = second.val;\\n    \\t\\t    second.val = t;\\n    \\t\\t}\\n        }",
                "solutionTags": [],
                "code": "To understand this, you need to first understand Morris Traversal or Morris Threading Traversal.\\nIt take use of leaf nodes' right/left pointer to achieve O(1) space Traversal on a Binary Tree.\\nBelow is a standard Inorder Morris Traversal, referred from http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html (a Chinese Blog, while the graphs are great for illustration)\\n\\n    public void morrisTraversal(TreeNode root){\\n    \\t\\tTreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n\\nIn the above code, `System.out.println(root.val);`appear twice, which functions as outputing the Node in ascending order (BST). Since these places are in order, replace them with\\n\\n        if(pre!=null && pre.val > root.val){\\n        \\tif(first==null){first = pre;second = root;}\\n        \\telse{second = root;}\\n      }\\n    pre = root;\\n\\neach time, the pre node and root are in order as `System.out.println(root.val);` outputs them in order.\\n\\nThen, come to how to specify the first wrong node and second wrong node.\\n\\nWhen they are not consecutive, the first time we meet `pre.val > root.val` ensure us the first node is the pre node, since root should be traversal ahead of pre, pre should be at least at small as root. The second time we meet `pre.val > root.val` ensure us the second node is the root node, since we are now looking for a node to replace with out first node, which is found before.\\n\\nWhen they are consecutive, which means the case `pre.val > cur.val` will appear only once. We need to take case this case without destroy the previous analysis. So the first node will still be pre, and the second will be just set to root. Once we meet this case again, the first node will not be affected.\\n\\nBelow is the updated version on Morris Traversal.\\n\\n\\n    public void recoverTree(TreeNode root) {\\n            TreeNode pre = null;\\n            TreeNode first = null, second = null;\\n            // Morris Traversal\\n            TreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t    if(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t        if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t        else{second = root;}\\n    \\t\\t\\t\\t    }\\n    \\t\\t\\t\\t    pre = root;\\n    \\t\\t\\t\\t    \\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tif(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t    if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t    else{second = root;}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tpre = root;\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// swap two node values;\\n    \\t\\tif(first!= null && second != null){\\n    \\t\\t    int t = first.val;\\n    \\t\\t    first.val = second.val;\\n    \\t\\t    second.val = t;\\n    \\t\\t}\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 32539,
                "title": "tree-deserializer-and-visualizer-for-python",
                "content": "Wrote some tools for my own local testing. For example `deserialize('[1,2,3,null,null,4,null,null,5]')` will turn that into a tree and return the root [as explained in the FAQ](https://leetcode.com/faq/). I also wrote a visualizer. Two examples:\\n\\n`drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))`:\\n\\n![enter image description here][1]\\n\\n`drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))`:\\n\\n![enter image description here][2]\\n\\nHere's the code. If you save it as a Python script and run it, it should as a demo show the above two pictures in turtle windows (one after the other). And you can of course import it from other scripts and then it will only provide the class/functions and not show the demo.\\n\\n    class TreeNode:\\n        def __init__(self, val, left=None, right=None):\\n            self.val = val\\n            self.left = left\\n            self.right = right\\n        def __repr__(self):\\n            return 'TreeNode({})'.format(self.val)\\n        \\n    def deserialize(string):\\n        if string == '{}':\\n            return None\\n        nodes = [None if val == 'null' else TreeNode(int(val))\\n                 for val in string.strip('[]{}').split(',')]\\n        kids = nodes[::-1]\\n        root = kids.pop()\\n        for node in nodes:\\n            if node:\\n                if kids: node.left  = kids.pop()\\n                if kids: node.right = kids.pop()\\n        return root\\n    \\n    def drawtree(root):\\n        def height(root):\\n            return 1 + max(height(root.left), height(root.right)) if root else -1\\n        def jumpto(x, y):\\n            t.penup()\\n            t.goto(x, y)\\n            t.pendown()\\n        def draw(node, x, y, dx):\\n            if node:\\n                t.goto(x, y)\\n                jumpto(x, y-20)\\n                t.write(node.val, align='center', font=('Arial', 12, 'normal'))\\n                draw(node.left, x-dx, y-60, dx/2)\\n                jumpto(x, y-20)\\n                draw(node.right, x+dx, y-60, dx/2)\\n        import turtle\\n        t = turtle.Turtle()\\n        t.speed(0); turtle.delay(0)\\n        h = height(root)\\n        jumpto(0, 30*h)\\n        draw(root, 0, 30*h, 40*h)\\n        t.hideturtle()\\n        turtle.mainloop()\\n        \\n    if __name__ == '__main__':\\n        drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))\\n        drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))\\n\\n  [1]: http://pochmann.org/leetcode/images/tree1.png\\n  [2]: http://pochmann.org/leetcode/images/tree2.png",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "Wrote some tools for my own local testing. For example `deserialize('[1,2,3,null,null,4,null,null,5]')` will turn that into a tree and return the root [as explained in the FAQ](https://leetcode.com/faq/). I also wrote a visualizer. Two examples:\\n\\n`drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))`:\\n\\n![enter image description here][1]\\n\\n`drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))`:\\n\\n![enter image description here][2]\\n\\nHere's the code. If you save it as a Python script and run it, it should as a demo show the above two pictures in turtle windows (one after the other). And you can of course import it from other scripts and then it will only provide the class/functions and not show the demo.\\n\\n    class TreeNode:\\n        def __init__(self, val, left=None, right=None):\\n            self.val = val\\n            self.left = left\\n            self.right = right\\n        def __repr__(self):\\n            return 'TreeNode({})'.format(self.val)\\n        \\n    def deserialize(string):\\n        if string == '{}':\\n            return None\\n        nodes = [None if val == 'null' else TreeNode(int(val))\\n                 for val in string.strip('[]{}').split(',')]\\n        kids = nodes[::-1]\\n        root = kids.pop()\\n        for node in nodes:\\n            if node:\\n                if kids: node.left  = kids.pop()\\n                if kids: node.right = kids.pop()\\n        return root\\n    \\n    def drawtree(root):\\n        def height(root):\\n            return 1 + max(height(root.left), height(root.right)) if root else -1\\n        def jumpto(x, y):\\n            t.penup()\\n            t.goto(x, y)\\n            t.pendown()\\n        def draw(node, x, y, dx):\\n            if node:\\n                t.goto(x, y)\\n                jumpto(x, y-20)\\n                t.write(node.val, align='center', font=('Arial', 12, 'normal'))\\n                draw(node.left, x-dx, y-60, dx/2)\\n                jumpto(x, y-20)\\n                draw(node.right, x+dx, y-60, dx/2)\\n        import turtle\\n        t = turtle.Turtle()\\n        t.speed(0); turtle.delay(0)\\n        h = height(root)\\n        jumpto(0, 30*h)\\n        draw(root, 0, 30*h, 40*h)\\n        t.hideturtle()\\n        turtle.mainloop()\\n        \\n    if __name__ == '__main__':\\n        drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))\\n        drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))\\n\\n  [1]: http://pochmann.org/leetcode/images/tree1.png\\n  [2]: http://pochmann.org/leetcode/images/tree2.png",
                "codeTag": "Java"
            },
            {
                "id": 1962981,
                "title": "idea-inorder-traversal-easy-to-understand",
                "content": "I will try to explain the approach using diagrams and pseudo code : \\n\\n![image](https://assets.leetcode.com/users/images/452c1932-e252-4a64-a745-66cb4ef08b1a_1650349299.0155501.jpeg)\\n![image](https://assets.leetcode.com/users/images/66d468cc-dd11-4a36-958d-6ad68956ef96_1650349307.373912.jpeg)\\n\\nNow try to implement the actual problem.\\nHints : Firstly write the inorder traversal and try to follow the array approach of updating the prev,first and second and you will be able to solve it. \\nHere is my solution : \\n```\\nclass Solution {\\n    TreeNode prev=null,first=null,second=null;\\n    void inorder(TreeNode root){\\n        if(root==null)\\n            return ;\\n        inorder(root.left);\\n        if(prev!=null&&root.val<prev.val){\\n            if(first==null)\\n                first=prev;\\n            second=root;\\n        }\\n        prev=root;\\n        inorder(root.right);\\n    }\\n    public void recoverTree(TreeNode root) {\\n        if(root==null)\\n            return ; \\n        inorder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n}\\n```\\n\\nHope you understood the approach :)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev=null,first=null,second=null;\\n    void inorder(TreeNode root){\\n        if(root==null)\\n            return ;\\n        inorder(root.left);\\n        if(prev!=null&&root.val<prev.val){\\n            if(first==null)\\n                first=prev;\\n            second=root;\\n        }\\n        prev=root;\\n        inorder(root.right);\\n    }\\n    public void recoverTree(TreeNode root) {\\n        if(root==null)\\n            return ; \\n        inorder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32562,
                "title": "share-my-solutions-and-detailed-explanation-with-recursive-iterative-in-order-traversal-and-morris-traversal",
                "content": "In-order traversal is really useful in BST. Following in-order traversal, we should have following order: prev.val < curr.val. If not, then we found at least one incorrectly placed node\\n\\nSo the basic idea is to visit the tree with in-order traversal and search for two swapped nodes. Then swap them back.\\n\\nNow the problem is if we found an incorrect pair where prev.val > curr.val, how do we know which node is the incorrect one?  The answer is it depends on whether we have found incorrect node before. So What is that?\\n\\nSince we get two elements that are swapped by mistake, there must be a smaller TreeNode get a larger value and a larger TreeNode get a smaller value.\\nTheir value are swapped, but the incorrect smaller node is still in smaller tree and incorrect larger node is still in larger tree. So we will visit the incorrect smaller node first, and this node will be detected when we compare its value with next.val, i.e.  when it is treated as prev node. The incorrect larger node will be detected when we compare its value with prev.val. We don't know if it is close or not close to incorrect smaller node, so we should continue search BST and update it if we found another incorrect node.\\n\\nTherefore if it is the first time we found an incorrect pair, the prev node must be the first incorrect node.\\nIf it is not the first time we found an incorrect pair, the curr node must be the second incorrect node, though\\nwe may have corner case that two incorrect nodes are in same pair.\\n\\nRecursive in-order traversal based on above idea:\\n\\n    public void recoverTree(TreeNode root) {\\n        //use inorder traversal to detect incorrect node\\n        \\n        inOrder(root);\\n        \\n\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    TreeNode prev = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void inOrder(TreeNode root){\\n        if(root == null) return;\\n        //search left tree\\n        inOrder(root.left);\\n        \\n        //in inorder traversal of BST, prev should always have smaller value than current value\\n        if(prev != null && prev.val >= root.val){\\n            //incorrect smaller node is always found as prev node\\n            if(first == null) first = prev;\\n          //incorrect larger node is always found as curr(root) node\\n            second = root;\\n        }\\n        \\n        \\n        //update prev node\\n        prev = root;\\n\\n        //search right tree\\n        inOrder(root.right);\\n    }\\n\\n\\niterative in-order traversal based on above idea:\\n\\n\\n    public void recoverTree(TreeNode root) {\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        while(!stack.isEmpty() ||  curr != null){\\n            if(curr != null){\\n                //visit curr's left subtree\\n                stack.push(curr);\\n                curr = curr.left;\\n            }else{\\n                //done left subtree of curr Node\\n                curr = stack.pop();\\n                \\n                //compare curr.val with prev.val if we have one\\n                if(prev != null && curr.val <= prev.val){\\n                    //incorrect smaller node is always found as prev node\\n                    if(first == null) first = prev;\\n                    //incorrect larger node is always found as curr node\\n                    second = curr;         \\n                }  \\n                \\n                //visit curr's right subtree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        //recover swapped nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\nBoth recursive and iterative will occupy O(n) space in worst case, in which the tree is like a LinkedList\\n\\nTo reduce the space to constant space, we have to use Morris-traversal.\\n\\nMorris-traversal is similar to recursive/iterative traversal, but we need to modify the tree structure during the\\ntraversal.  before we visiting the left tree of a root, we will build a back-edge between rightmost node in left tree and the root. So we can go back to the root node after we are done with the left tree. Then we locate the rightmost node in left subtree again, cut the back-edge, recover the tree structure and start visit right subtree. The detection of two incorrect TreeNodes is similar to iterative/recursive in-order traversal.\\nWe don't use extra data structure here, so the space complexity is reduced to O(1) and the time complexity will be O(n)\\n\\nMorris-traversal based on above description:\\n\\n    public void recoverTree(TreeNode root) {\\n    \\t//Morris-traversal\\n    \\t\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode pred = null; //rightmost node in left tree\\n        TreeNode prev = null; \\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            //for each node, we compare it with prev node as we did in in-order-traversal\\n            if(prev != null && curr.val <= prev.val){\\n                if(first == null) first = prev;\\n                second = curr;\\n            }\\n            \\n            if(curr.left != null){\\n                //got left tree, then let's locate its rightmost node in left tree\\n                pred = curr.left;\\n                //we may have visited the left tree before, and connect the rightmost node with curr node (root node)\\n                while(pred.right != null && pred.right != curr){\\n                    pred = pred.right;\\n                }\\n                \\n                if(pred.right == curr){\\n                    //if this left tree has been visited before, then we are done with it\\n                    //cut the connection with currNode and start visit curr's right tree\\n                    pred.right = null;\\n                    prev = curr;\\n                    curr = curr.right;\\n                }else{\\n                    //if this left tree has not been visited before, then we create a back edge from rightmost node\\n                    // to curr node, so we can return to the start point after done the left tree\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n                \\n            }else{\\n                //no left tree, then just visit its right tree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "In-order traversal is really useful in BST. Following in-order traversal, we should have following order: prev.val < curr.val. If not, then we found at least one incorrectly placed node\\n\\nSo the basic idea is to visit the tree with in-order traversal and search for two swapped nodes. Then swap them back.\\n\\nNow the problem is if we found an incorrect pair where prev.val > curr.val, how do we know which node is the incorrect one?  The answer is it depends on whether we have found incorrect node before. So What is that?\\n\\nSince we get two elements that are swapped by mistake, there must be a smaller TreeNode get a larger value and a larger TreeNode get a smaller value.\\nTheir value are swapped, but the incorrect smaller node is still in smaller tree and incorrect larger node is still in larger tree. So we will visit the incorrect smaller node first, and this node will be detected when we compare its value with next.val, i.e.  when it is treated as prev node. The incorrect larger node will be detected when we compare its value with prev.val. We don't know if it is close or not close to incorrect smaller node, so we should continue search BST and update it if we found another incorrect node.\\n\\nTherefore if it is the first time we found an incorrect pair, the prev node must be the first incorrect node.\\nIf it is not the first time we found an incorrect pair, the curr node must be the second incorrect node, though\\nwe may have corner case that two incorrect nodes are in same pair.\\n\\nRecursive in-order traversal based on above idea:\\n\\n    public void recoverTree(TreeNode root) {\\n        //use inorder traversal to detect incorrect node\\n        \\n        inOrder(root);\\n        \\n\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    TreeNode prev = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void inOrder(TreeNode root){\\n        if(root == null) return;\\n        //search left tree\\n        inOrder(root.left);\\n        \\n        //in inorder traversal of BST, prev should always have smaller value than current value\\n        if(prev != null && prev.val >= root.val){\\n            //incorrect smaller node is always found as prev node\\n            if(first == null) first = prev;\\n          //incorrect larger node is always found as curr(root) node\\n            second = root;\\n        }\\n        \\n        \\n        //update prev node\\n        prev = root;\\n\\n        //search right tree\\n        inOrder(root.right);\\n    }\\n\\n\\niterative in-order traversal based on above idea:\\n\\n\\n    public void recoverTree(TreeNode root) {\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        while(!stack.isEmpty() ||  curr != null){\\n            if(curr != null){\\n                //visit curr's left subtree\\n                stack.push(curr);\\n                curr = curr.left;\\n            }else{\\n                //done left subtree of curr Node\\n                curr = stack.pop();\\n                \\n                //compare curr.val with prev.val if we have one\\n                if(prev != null && curr.val <= prev.val){\\n                    //incorrect smaller node is always found as prev node\\n                    if(first == null) first = prev;\\n                    //incorrect larger node is always found as curr node\\n                    second = curr;         \\n                }  \\n                \\n                //visit curr's right subtree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        //recover swapped nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\nBoth recursive and iterative will occupy O(n) space in worst case, in which the tree is like a LinkedList\\n\\nTo reduce the space to constant space, we have to use Morris-traversal.\\n\\nMorris-traversal is similar to recursive/iterative traversal, but we need to modify the tree structure during the\\ntraversal.  before we visiting the left tree of a root, we will build a back-edge between rightmost node in left tree and the root. So we can go back to the root node after we are done with the left tree. Then we locate the rightmost node in left subtree again, cut the back-edge, recover the tree structure and start visit right subtree. The detection of two incorrect TreeNodes is similar to iterative/recursive in-order traversal.\\nWe don't use extra data structure here, so the space complexity is reduced to O(1) and the time complexity will be O(n)\\n\\nMorris-traversal based on above description:\\n\\n    public void recoverTree(TreeNode root) {\\n    \\t//Morris-traversal\\n    \\t\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode pred = null; //rightmost node in left tree\\n        TreeNode prev = null; \\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            //for each node, we compare it with prev node as we did in in-order-traversal\\n            if(prev != null && curr.val <= prev.val){\\n                if(first == null) first = prev;\\n                second = curr;\\n            }\\n            \\n            if(curr.left != null){\\n                //got left tree, then let's locate its rightmost node in left tree\\n                pred = curr.left;\\n                //we may have visited the left tree before, and connect the rightmost node with curr node (root node)\\n                while(pred.right != null && pred.right != curr){\\n                    pred = pred.right;\\n                }\\n                \\n                if(pred.right == curr){\\n                    //if this left tree has been visited before, then we are done with it\\n                    //cut the connection with currNode and start visit curr's right tree\\n                    pred.right = null;\\n                    prev = curr;\\n                    curr = curr.right;\\n                }else{\\n                    //if this left tree has not been visited before, then we create a back edge from rightmost node\\n                    // to curr node, so we can return to the start point after done the left tree\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n                \\n            }else{\\n                //no left tree, then just visit its right tree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 187407,
                "title": "python-short-and-slick-solution-108ms-beats-100-both-stack-and-morris-versions",
                "content": "Here\\'s a full solution using stack-based (iterative) inorder traversal. Just to demonstrate how efficient this code is, I\\'ve included the code for a regular inorder traversal on the right:\\n```python\\ndef recoverTree(self, root):                                               |  def inorder(self, root):\\n    cur, prev, drops, stack = root, TreeNode(float(\\'-inf\\')), [], []        |      cur, stack = root, []\\n    while cur or stack:                                                    |      while cur or stack:\\n        while cur:                                                         |          while cur:\\n            stack.append(cur)                                              |              stack.append(cur)\\n            cur = cur.left                                                 |              cur = cur.left\\n        node = stack.pop()                                                 |          node = stack.pop()\\n        if node.val < prev.val: drops.append((prev, node))                 |          print(node.val)\\n        prev, cur = node, node.right                                       |          cur = node.right\\n    drops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val  |\\n```\\nFull solution using Morris inorder traversal:\\n```python\\ndef recoverTree(self, root):                                               |  def inorderMorris(self, root):\\n    cur, prev, drops = root, TreeNode(float(\\'-inf\\')), []                   |      cur = root\\n    while cur:                                                             |      while cur:\\n        if cur.left:                                                       |          if cur.left:\\n            temp = cur.left                                                |              temp = cur.left\\n            while temp.right and temp.right != cur: temp = temp.right      |              while temp.right and temp.right != cur: temp = temp.right\\n            if not temp.right:                                             |              if not temp.right:\\n                temp.right, cur = cur, cur.left                            |                  temp.right, cur = cur, cur.left\\n                continue                                                   |                  continue\\n            temp.right = None                                              |              temp.right = None\\n        if cur.val < prev.val: drops.append((prev, cur))                   |          print(cur.val)\\n        prev, cur = cur, cur.right                                         |          cur = cur.right\\n    drops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val  |\\n```\\n---\\n\\n### Explanation\\n\\nI don\\'t have any new ideas; just a cool way to implement an old idea.\\n\\nUse whatever inorder traversal you like (recursion/stack = O(log n) extra space, Morris = O(1) extra space). As most people have figured out pretty easily, the idea is to remember the last value you saw and compare it with the current value. If `lastValue > currentValue`, then we know that something is \"wrong\", but it\\'s not immediately clear which values have to be swapped.\\n\\nThere are 2 cases: The values that need to be swapped are either adjacent or not adjacent. If they\\'re adjacent, then there will be one \"drop\"; if they\\'re not adjacent, then there will be two \"drops\".\\n```abc\\nadjacent: ... _ < _ < A > B < _ < _ ...\\n                      ^^^^^\\n                      drop #1\\n\\nnot adjacent: ... _ < _ < A > X < _ < Y > B < _ < _ ... (X may be the same as Y, but it\\'s irrelevant)\\n                          ^^^^^       ^^^^^\\n                          drop #1     drop #2\\n```\\nIn both cases, we want to swap `A` and `B`. So the idea is to keep a `drops` array and append a tuple of `(lastNode, currentNode)` whenever we come across `lastValue > currentValue`. At the end of the traversal, the `drops` array must have either 1 or 2 tuples (otherwise, there would be more than 2 nodes that need to be swapped).\\n\\nHere\\'s the clear but not-so-clean way to swap them:\\n```python\\nif len(drops) == 1: # drops == [(A, B)]\\n    drops[0][0].val, drops[0][1].val = drops[0][1].val, drops[0][0].val\\nelse: # drops == [(A, X), (Y, B)]\\n    drops[0][0].val, drops[1][1].val = drops[1][1].val, drops[0][0].val\\n```\\nHere\\'s the clean but not-so-clear way that gets rid of the conditional branching:\\n```python\\ndrops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val\\n```",
                "solutionTags": [],
                "code": "```python\\ndef recoverTree(self, root):                                               |  def inorder(self, root):\\n    cur, prev, drops, stack = root, TreeNode(float(\\'-inf\\')), [], []        |      cur, stack = root, []\\n    while cur or stack:                                                    |      while cur or stack:\\n        while cur:                                                         |          while cur:\\n            stack.append(cur)                                              |              stack.append(cur)\\n            cur = cur.left                                                 |              cur = cur.left\\n        node = stack.pop()                                                 |          node = stack.pop()\\n        if node.val < prev.val: drops.append((prev, node))                 |          print(node.val)\\n        prev, cur = node, node.right                                       |          cur = node.right\\n    drops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val  |\\n```\n```python\\ndef recoverTree(self, root):                                               |  def inorderMorris(self, root):\\n    cur, prev, drops = root, TreeNode(float(\\'-inf\\')), []                   |      cur = root\\n    while cur:                                                             |      while cur:\\n        if cur.left:                                                       |          if cur.left:\\n            temp = cur.left                                                |              temp = cur.left\\n            while temp.right and temp.right != cur: temp = temp.right      |              while temp.right and temp.right != cur: temp = temp.right\\n            if not temp.right:                                             |              if not temp.right:\\n                temp.right, cur = cur, cur.left                            |                  temp.right, cur = cur, cur.left\\n                continue                                                   |                  continue\\n            temp.right = None                                              |              temp.right = None\\n        if cur.val < prev.val: drops.append((prev, cur))                   |          print(cur.val)\\n        prev, cur = cur, cur.right                                         |          cur = cur.right\\n    drops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val  |\\n```\n```abc\\nadjacent: ... _ < _ < A > B < _ < _ ...\\n                      ^^^^^\\n                      drop #1\\n\\nnot adjacent: ... _ < _ < A > X < _ < Y > B < _ < _ ... (X may be the same as Y, but it\\'s irrelevant)\\n                          ^^^^^       ^^^^^\\n                          drop #1     drop #2\\n```\n```python\\nif len(drops) == 1: # drops == [(A, B)]\\n    drops[0][0].val, drops[0][1].val = drops[0][1].val, drops[0][0].val\\nelse: # drops == [(A, X), (Y, B)]\\n    drops[0][0].val, drops[1][1].val = drops[1][1].val, drops[0][0].val\\n```\n```python\\ndrops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1962281,
                "title": "c-easy-to-understand",
                "content": "If u use inorder traveral, problem will be find 2 mistakes in acending array and swap them\\nFor example array: 1 2 3 4 5 6 7\\n-> swap random two elments -> 1 2 6 4 5 3 7 (swap 3 and 6)\\n-> Question is how can know 2 elements is 3 and 6?\\n-> First: find the first number have index i satisfy arr[i - 1] > arr[i] => first mistake have index i - 1 (in the exam, first mistake is 6)\\n-> Second: continue but don\\'t change first mistake, if arr[i - 1] > arr[i] and u had found the first mistake => second mistake is i;\\nin the example second mistake in the first time is 4 change to 3\\n\\nIn the tree question, to keep compare, u need a variable is previous root.\\nBy @LemonHerbs :\\nif we encounter a tree looking like this:\\n\\n\\t   5\\n\\t  /   \\\\\\n\\t6     8\\n\\t\\t /\\n\\t\\t 4\\nfirstMistake will be assigned to 6, and in the same recursive call, secondMistake will be assigned to 5.\\nThen in the next recursive call, firstMistake will NOT be changed since it is not a null pointer, while secondMistake will be\\nupdated to 4. Then in the following recursions the 2 mistake nodes remain unchanged.\\nWhen inorder() returns to the main function recoverTree(), the 2 mistakes swap values and hence the correct BST.\\n\\n\\t   5\\n\\t  /   \\\\\\n\\t4     8\\n\\t\\t /\\n\\t\\t 6\\nCode:\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\t\\tvoid recoverTree(TreeNode* root) {\\n\\t\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\t\\tinorder(root);\\n\\t\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t\\t}\\n\\n\\t\\tvoid inorder(TreeNode* root) {\\n\\t\\t\\tif(root == nullptr) \\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tinorder(root->left);\\n\\n\\t\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\t\\tfirstMistake = pre;\\n\\t\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\t\\tsecondMistake = root;\\n\\t\\t\\tpre = root;\\n\\n\\t\\t\\tinorder(root->right);\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\t\\tvoid recoverTree(TreeNode* root) {\\n\\t\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\t\\tinorder(root);\\n\\t\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 917430,
                "title": "python-o-n-o-1-morris-traversal-explained",
                "content": "If we want to traverse our tree and do not use any additional memory, than as far as I know, Morris traversal is the only way how to do it. \\n\\nFor more details about Morris traversal, you can look at oficial solution of problem 94: Binary Tree Inorder Traversal: https://leetcode.com/problems/binary-tree-inorder-traversal/solution/.\\n\\nAlso, here we need to use variation of traversal, which keep the original structure of tree.\\n\\nLet us use this traversal and use `node` is current node we are in and `cands` are candidates for our swapped nodes. We will look at oddities in inorder traversal: in BST all numbers will always increase. So, if in inorder traversal some value is less than previous, we need to keep and eye on this node. There can be two main cases:\\n\\n1. We have `1, 2, 3, 4, 5` and swapped nodes are adjacent, for example `1, 2, 4, 3, 5`. In this case, we have only one oddity: `4` and `3`: and we save them to our `cands` list. And we need to change values for the first and for the last nodes in our `cands`.\\n2. We have `1, 2, 3, 4, 5` and swapped nodes are not adjacent, for example `1, 2, 5, 4, 3`. In this case we have two oddities: `5` and `4`; `4` and `3`.  In this case we again need to swap the first and the last nodes.\\n\\nSo, in both cases it is enough to run `cands[0].val, cands[-1].val = cands[-1].val, cands[0].val` to swap our nodes.\\n\\n**Complexity**: time complexity is `O(n)`: because we basically do Morris traverasal plus some additional `O(n)` operations. Space complexity is `O(1)`, becauswe we again do Morris traversal and also we have `node` and `cands`, where `cands` can have maximum size `4`.\\n\\n```\\nclass Solution:\\n    def recoverTree(self, root):\\n        cur, node, cands = root, TreeNode(-float(\"inf\")), []\\n        while cur:\\n            if cur.left:\\n                pre = cur.left\\n                while pre.right and pre.right != cur:\\n                    pre = pre.right\\n                if not pre.right:\\n                    pre.right = cur\\n                    cur = cur.left\\n                else:\\n                    pre.right = None\\n                    if cur.val < node.val:\\n                        cands += [node, cur]\\n                    node = cur\\n                    cur = cur.right\\n            else:\\n                if cur.val < node.val:\\n                    cands += [node, cur]\\n                node = cur\\n                cur = cur.right\\n            \\n        cands[0].val, cands[-1].val = cands[-1].val, cands[0].val\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root):\\n        cur, node, cands = root, TreeNode(-float(\"inf\")), []\\n        while cur:\\n            if cur.left:\\n                pre = cur.left\\n                while pre.right and pre.right != cur:\\n                    pre = pre.right\\n                if not pre.right:\\n                    pre.right = cur\\n                    cur = cur.left\\n                else:\\n                    pre.right = None\\n                    if cur.val < node.val:\\n                        cands += [node, cur]\\n                    node = cur\\n                    cur = cur.right\\n            else:\\n                if cur.val < node.val:\\n                    cands += [node, cur]\\n                node = cur\\n                cur = cur.right\\n            \\n        cands[0].val, cands[-1].val = cands[-1].val, cands[0].val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423225,
                "title": "c-clear-solution-with-explanation",
                "content": "In an inorder traversal, nodes should go from smallest to largest, if not we know there is an issue.\\nFor instance, if we have nodes 10 11 1 6 7 20 27, the inorder traversal should be\\n1 6 7 10 11 20 27. If it is anything else, you know two numbers are swapped. For instance, you could have:\\n1 7 6 10 11 20 27 (SITUATION 1), where two nodes sie by side are swapped, or 1 6  20 10 11 7 27 (SITUATION 2), where two nodes somewhere in the tree are flipped. We need to maintain a pointer to four locations:\\n\\n1. The previous node.  (prev)\\n2. The current node (root)\\n3. Our first flipped node (start)\\n4. Our second flipped node (end)\\n\\nAs we hit the first node in the inorder traversal, we mark it with prev (point prev to it). We then move onto the next node. This is when we want to start makiing the comparison. We then compare the previous node\\'s value to the current node\\'s value. So we\\'d compare 1 to 6. Since 6 is greater than 1, we continue. We compare 6 to 20. Since 20 is greater than 6, we continue. Then we get to 10, and 10 is less than 20, so we move our pointer to point to 20 as our first target. We set our second pointer (end) to the current node, since it may be the situation where the two flipped nodes are side by side (SITUATION 1). If that is NOT the case, our loop will be triggered again, and since our first pointer (start) is already occupied, our second pointer will now change to the second poorly placed node (SITUATION 2\\'s 7)\\n\\n```\\nclass Solution {\\nprivate:\\n    \\n    void markTree(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& end) {\\n        if (!root) return;\\n        markTree(root->left, prev, first, end);\\n        if (prev) {\\n            if (root->val < prev->val) {\\n                if (!first) {\\n                    first = prev;\\n                }\\n                end = root;\\n            }\\n        }\\n        prev = root;\\n        markTree(root->right, prev, first, end);\\n    }\\n    \\n    \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr, *first = nullptr, *end = nullptr;\\n        markTree(root, prev, first, end);\\n        swap(first->val, end->val);\\n        return;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\nprivate:\\n    \\n    void markTree(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& end) {\\n        if (!root) return;\\n        markTree(root->left, prev, first, end);\\n        if (prev) {\\n            if (root->val < prev->val) {\\n                if (!first) {\\n                    first = prev;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 917502,
                "title": "c-o-n-time-o-1-space-short-easy-code-with-explanation",
                "content": "The space O(1) does not consider recursion stack space.\\nThe idea is that, if we swap any 2 values in an ascending sorted array, then we may find irregularity in our array (i.e. arr[i]>arr[i+1]) at 2 places, and if we swap any 2 adjacent numbers then such irregularity occurs at ony 1 place.\\nSo the idea is to traverse the tree in inorder fashion and keeping a check on previous node and comparing the value of current node with previous node of inorder traversal. We save all such pairs of {curr, prev} nodes in an array.\\nThe size of array == 1 if 2 adjacent numbers were swapped, else the size of array == 2.\\nSo we have to accordingly swap the numbers to get back the original tree.\\n```\\nvector<pair<TreeNode*,TreeNode*>> vec;\\n    TreeNode* prev = NULL;\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root) return;\\n        inorder(root->left);\\n        if(prev && prev->val>root->val) vec.push_back({prev,root});\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        if(vec.size()==1)\\n            swap(vec[0].first->val,vec[0].second->val);\\n        if(vec.size()==2)\\n            swap(vec[0].first->val,vec[1].second->val);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<pair<TreeNode*,TreeNode*>> vec;\\n    TreeNode* prev = NULL;\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root) return;\\n        inorder(root->left);\\n        if(prev && prev->val>root->val) vec.push_back({prev,root});\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        if(vec.size()==1)\\n            swap(vec[0].first->val,vec[0].second->val);\\n        if(vec.size()==2)\\n            swap(vec[0].first->val,vec[1].second->val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32580,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explaination",
                "content": "Just use the \"first\" and \"second\" pointer to find the 2 nodes that violate the order. Then change the value of the first node ad the second node by their value.\\n\\n    class Solution {\\n        TreeNode* first=NULL;\\n        TreeNode* second=NULL;\\n        TreeNode* prev = new TreeNode(INT_MIN);\\n    public:\\n        void recoverTree(TreeNode* root) {\\n            help(root);\\n            swp(first->val, second->val);\\n        }\\n        \\n        void help(TreeNode* root){\\n            if(root==NULL)  return;\\n            help(root->left);\\n            if(first==NULL && prev->val >= root->val)   first=prev;\\n            if(first!=NULL && prev->val >= root->val)   second=root;\\n            prev=root;\\n            help(root->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        TreeNode* first=NULL;\\n        TreeNode* second=NULL;\\n        TreeNode* prev = new TreeNode(INT_MIN);\\n    public:\\n        void recoverTree(TreeNode* root) {\\n            help(root);\\n            swp(first->val, second->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32624,
                "title": "python-easy-to-understand-solutions",
                "content": "```\\n\\nclass Solution(object): \\n    def recoverTree(self, root): # O(lg(n)) space\\n        pre = first = second = None\\n        stack = []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                break\\n            node = stack.pop()\\n            if not first and pre and pre.val > node.val:\\n                first = pre\\n            if first and pre and pre.val > node.val:\\n                second = node\\n            pre = node\\n            root = node.right\\n        first.val, second.val = second.val, first.val\\n      \\n    def recoverTree1(self, root): # O(n+lg(n)) space  \\n        res = []\\n        self.dfs(root, res)\\n        first, second = None, None\\n        for i in range(len(res)-1):\\n            if res[i].val > res[i+1].val and not first:\\n                first = res[i]\\n            if res[i].val > res[i+1].val and first:\\n                second = res[i+1]\\n        first.val, second.val = second.val, first.val\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            self.dfs(root.left, res)\\n            res.append(root)\\n            self.dfs(root.right, res)\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\n\\nclass Solution(object): \\n    def recoverTree(self, root): # O(lg(n)) space\\n        pre = first = second = None\\n        stack = []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                break\\n            node = stack.pop()\\n            if not first and pre and pre.val > node.val:\\n                first = pre\\n            if first and pre and pre.val > node.val:\\n                second = node\\n            pre = node\\n            root = node.right\\n        first.val, second.val = second.val, first.val\\n      \\n    def recoverTree1(self, root): # O(n+lg(n)) space  \\n        res = []\\n        self.dfs(root, res)\\n        first, second = None, None\\n        for i in range(len(res)-1):\\n            if res[i].val > res[i+1].val and not first:\\n                first = res[i]\\n            if res[i].val > res[i+1].val and first:\\n                second = res[i+1]\\n        first.val, second.val = second.val, first.val\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            self.dfs(root.left, res)\\n            res.append(root)\\n            self.dfs(root.right, res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962833,
                "title": "beginner-level-illustration-11-line-solution",
                "content": "Pretty sure mine is the easiest one to understand. \\n\\nIf you do not want to spend much time on that, you could read the examples below the orange highlight line and get the idea.\\n\\nIf you do not think so, please comment.\\n\\nIf you have additional questions, please let me know\\n\\n**Please upvote me if you think this is helpful :) Much Appreciated!**\\n\\n![image](https://assets.leetcode.com/users/images/f6d861cd-c19a-4ee2-b377-50851abe09d8_1650345918.5829039.jpeg)\\n\\n****\\n\\nPython Solution\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n\\t\\n        # the idea is the in order BST is always increasing, if not, then there is something wrong\\n        def inorderBST(root):\\n            if not root:    return\\n            \\n            # track left side to start with min\\n            inorderBST(root.left)\\n\\n            # so that the first prev is the smallest node\\n            # and update each time\\n            if self.prev:\\n                \\n                # when order is wrong\\n\\t\\t\\t\\t# check the examples in the illustration\\n                if self.prev.val > root.val:\\n                    if not self.first:\\n                        self.first = self.prev\\n                    self.second = root\\n            \\n            # update the prev node\\n            self.prev = root\\n            \\n            # check right side\\n            inorderBST(root.right)\\n        \\n        \\n        self.first = self.second = self.prev = None\\n        inorderBST(root)\\n        \\n        # swap the two wrong ones\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n        \\n        return\\n```\\n\\n****\\n\\nCompressed 11-line Python Solution\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n\\n        def inorderBST(root):\\n            if not root:    return\\n            \\n            inorderBST(root.left)\\n\\n            if self.prev and self.prev.val > root.val:\\n                if not self.first:  self.first = self.prev\\n                self.second = root\\n            self.prev = root\\n\\n            inorderBST(root.right)\\n        \\n        \\n        self.first = self.second = self.prev = None\\n        inorderBST(root)\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n\\t\\n        # the idea is the in order BST is always increasing, if not, then there is something wrong\\n        def inorderBST(root):\\n            if not root:    return\\n            \\n            # track left side to start with min\\n            inorderBST(root.left)\\n\\n            # so that the first prev is the smallest node\\n            # and update each time\\n            if self.prev:\\n                \\n                # when order is wrong\\n\\t\\t\\t\\t# check the examples in the illustration\\n                if self.prev.val > root.val:\\n                    if not self.first:\\n                        self.first = self.prev\\n                    self.second = root\\n            \\n            # update the prev node\\n            self.prev = root\\n            \\n            # check right side\\n            inorderBST(root.right)\\n        \\n        \\n        self.first = self.second = self.prev = None\\n        inorderBST(root)\\n        \\n        # swap the two wrong ones\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n        \\n        return\\n```\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n\\n        def inorderBST(root):\\n            if not root:    return\\n            \\n            inorderBST(root.left)\\n\\n            if self.prev and self.prev.val > root.val:\\n                if not self.first:  self.first = self.prev\\n                self.second = root\\n            self.prev = root\\n\\n            inorderBST(root.right)\\n        \\n        \\n        self.first = self.second = self.prev = None\\n        inorderBST(root)\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274892,
                "title": "java-easy-inorder-traversal-soln-faster-than-100-explained",
                "content": "Here, we leverage the fact that **Inorder Traversal of a BST gives a sorted list of elements.**\\nIf there are exactly 2 swapped nodes, we can check the mistake in the inorder traversal.\\nFor eg.,\\n`root = [6,2,5,null,null,null,3]`\\nInorder traversal: `[2,6,5,3]` (Not sorted).\\n\\n- First incorrect node/element is **6** because 6 > 5 `(first == null && prev > curr)` => `prev` is the first node.\\n- Second incorrect node/element is **3**, because 5 > 3 `(first != null && prev > curr)`, `curr` is the second node.\\n- To cover the edge-case of 2 consecutive elements to be swapped, we always assign `second = curr`.\\n\\nHence, after swapping, the root becomes: `[2,3,5,6]`.\\n\\nBelow is the code:\\n\\n```\\nclass Solution {\\n    TreeNode prev = null, first = null, second = null;\\n\\n    public void recoverTree(TreeNode root) {\\n        evalSwappedNodes(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\n    private void evalSwappedNodes(TreeNode curr) {\\n        if (curr == null)\\n            return;\\n        evalSwappedNodes(curr.left);\\n        if (prev != null && prev.val > curr.val) {\\n            if (first == null)\\n                first = prev;\\n            second = curr;\\n        }\\n        prev = curr;\\n        evalSwappedNodes(curr.right);\\n    }\\n}\\n```\\n\\n\\n-------------------------------------------------------------------------------------------------------------------\\nIf you find this post helpful, please do upvote!\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev = null, first = null, second = null;\\n\\n    public void recoverTree(TreeNode root) {\\n        evalSwappedNodes(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\n    private void evalSwappedNodes(TreeNode curr) {\\n        if (curr == null)\\n            return;\\n        evalSwappedNodes(curr.left);\\n        if (prev != null && prev.val > curr.val) {\\n            if (first == null)\\n                first = prev;\\n            second = curr;\\n        }\\n        prev = curr;\\n        evalSwappedNodes(curr.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671363,
                "title": "on-paper-explanantion-well-commented-easy-understand",
                "content": "![image](https://assets.leetcode.com/users/akshit0699/image_1591339571.png)\\n\\nCASE 1:\\n4, 15, 7, 10, 14, 5, 17\\nWe reach 7, prev.val(15) >root.val(7) VIOLATION! Hence, found first.\\nfirst = 15(prev) and second = 7(root)\\nWe go to 7,10,14... all obey the sorted order.\\nWe reach 5, prev.val(14) > root.val(5) VIOLATION! Hence, found second.\\nsecond = 5 (root)\\nEverything else in the array is fine.\\nSwap first and second. Done!\\n\\nCase 2:\\n4,5, 7, 10, 15, 14, 17\\nReaches upto 15 safely.\\nComes to 14, VIOLATION. Found first.\\nfirst = 15(prev) and second = 14(root)\\nEverything else works fine.\\nSwap first and second. Done!\\n\\n\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: None Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.first, self.second, self.prevNode = None, None, None # Create three nodes.\\n        self.inOrder(root) # Calling the function\\n        self.first.val, self.second.val = self.second.val, self.first.val \\n        # Swapping the two elements needed to be swapped\\n        \\n    def inOrder(self, root):\\n        if not root:\\n            return\\n        self.inOrder(root.left)\\n        \\n        if self.prevNode: # To handle the case of first node, because we make it prev to begin with\\n            if self.prevNode.val > root.val: # Check property violation\\n                if not self.first: \\n                    self.first = self.prevNode # Found first pair\\n                self.second = root # If the second pair is found then simply assign the smaller element of the   pair as the second guy, it works for single pair easily, as it wont get             updated again in that case.\\n                \\n        self.prevNode = root\\n        \\n        self.inOrder(root.right)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: None Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.first, self.second, self.prevNode = None, None, None # Create three nodes.\\n        self.inOrder(root) # Calling the function\\n        self.first.val, self.second.val = self.second.val, self.first.val \\n        # Swapping the two elements needed to be swapped\\n        \\n    def inOrder(self, root):\\n        if not root:\\n            return\\n        self.inOrder(root.left)\\n        \\n        if self.prevNode: # To handle the case of first node, because we make it prev to begin with\\n            if self.prevNode.val > root.val: # Check property violation\\n                if not self.first: \\n                    self.first = self.prevNode # Found first pair\\n                self.second = root # If the second pair is found then simply assign the smaller element of the   pair as the second guy, it works for single pair easily, as it wont get             updated again in that case.\\n                \\n        self.prevNode = root\\n        \\n        self.inOrder(root.right)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962583,
                "title": "c-2-approach-brute-force-optimal",
                "content": "**1. Brute Force:**\\ntaking a vector, insert value into it according inorder traversal. Then sort, now again traverse the tree (in-order) & check the difference.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    void check(TreeNode* root){\\n        if(!root) return;\\n        check(root->left);\\n        if(v[i]!=root->val) swap(v[i],root->val);\\n        i++;\\n        check(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        sort(v.begin(),v.end());\\n        check(root);\\n    }\\n};\\n```\\n`TC-> O(NlogN), SC-> O(N)+O(N) [1 for vector, 1 for recursion space]`\\n\\n**2. Optimal:**\\n```\\nclass Solution {\\n    TreeNode* first, *last, *prev;\\npublic:\\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        inorder(root->left);\\n        if(prev!=NULL && (root->val<prev->val)){\\n            if(first==NULL){\\n                first=prev;\\n                last=root; \\n            }\\n            else\\n                last=root;\\n        }\\n        prev=root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        first=last=prev=NULL;\\n        inorder(root);\\n        swap(first->val,last->val);\\n    }\\n};\\n```\\n`TC-> O(N), SC->O(N) [for recursion space]`\\n\\n**Upvote if you like it**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    void check(TreeNode* root){\\n        if(!root) return;\\n        check(root->left);\\n        if(v[i]!=root->val) swap(v[i],root->val);\\n        i++;\\n        check(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        sort(v.begin(),v.end());\\n        check(root);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    TreeNode* first, *last, *prev;\\npublic:\\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        inorder(root->left);\\n        if(prev!=NULL && (root->val<prev->val)){\\n            if(first==NULL){\\n                first=prev;\\n                last=root; \\n            }\\n            else\\n                last=root;\\n        }\\n        prev=root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        first=last=prev=NULL;\\n        inorder(root);\\n        swap(first->val,last->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552230,
                "title": "c-morris-traversal-o-1-space",
                "content": "According to question statement there will be only one swap necessary to make recover BST.\\n- From observation inorder traversal in BST gives sorted arrays\\n- Now if there is any nodes in in wrong order it makes array irregular\\n- there can be one or two wrong ordered pairs of elements in inorders traversal array.\\n\\t- If one pair wrong ordered element then keep track of two element in that pair and swap their values.\\n\\t- If two wrong pair exist then swap first element of first pair with second element of second pair\\n\\t\\n\\tExample: \\n\\tBST inorder: **2, 1,** 3 // one pair wrong ordered. here swaping 2 and 1 makes a BST valid\\n\\tBST inorder: 1, **7, 3**, 5, **6, 2,** 8, // two pair wrong ordered. swaping 7 and 2 make valid BST\\n  \\n  **Upvote if you find this helpful. Thanks :)**\\n  \\n```\\nclass Solution {\\n    TreeNode* first{nullptr}, *second{nullptr}, *prev{nullptr};\\npublic:\\n    void verifyNode(TreeNode* node){\\n\\t\\n\\t// check if previous pointer == null or node values are correct inorder traversal i.e prev is smaller than current node\\n        if(prev == nullptr || (prev->val<node->val)){ \\n            prev = node;\\n            return;\\n        }\\n        \\n        if(first == nullptr ){\\n            first = prev;\\n            second = node;\\n        }else{ \\n            second = node;\\n        }\\n    }\\n    void morrisInorder(TreeNode* root){\\n        if(!root)return;\\n        while(root){\\n            if(root->left == nullptr){\\n                verifyNode(root);\\n                root = root->right;\\n            }else{\\n                TreeNode* iter = root->left;\\n                // find predecessor\\n                while(iter->right && iter->right!=root){\\n                    iter = iter->right;\\n                }\\n                \\n                if(iter->right == nullptr)//create morris thread\\n                {\\n                    iter->right = root;\\n                    root = root->left;\\n                }else{\\n                    iter->right = nullptr;\\n                    verifyNode(root);\\n                    root = root->right;\\n                }\\n            }\\n        }\\n    }\\n    void recoverTree(TreeNode* root) {\\n        morrisInorder(root);\\n        swap(first->val, second->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode* first{nullptr}, *second{nullptr}, *prev{nullptr};\\npublic:\\n    void verifyNode(TreeNode* node){\\n\\t\\n\\t// check if previous pointer == null or node values are correct inorder traversal i.e prev is smaller than current node\\n        if(prev == nullptr || (prev->val<node->val)){ \\n            prev = node;\\n            return;\\n        }\\n        \\n        if(first == nullptr ){\\n            first = prev;\\n            second = node;\\n        }else{ \\n            second = node;\\n        }\\n    }\\n    void morrisInorder(TreeNode* root){\\n        if(!root)return;\\n        while(root){\\n            if(root->left == nullptr){\\n                verifyNode(root);\\n                root = root->right;\\n            }else{\\n                TreeNode* iter = root->left;\\n                // find predecessor\\n                while(iter->right && iter->right!=root){\\n                    iter = iter->right;\\n                }\\n                \\n                if(iter->right == nullptr)//create morris thread\\n                {\\n                    iter->right = root;\\n                    root = root->left;\\n                }else{\\n                    iter->right = nullptr;\\n                    verifyNode(root);\\n                    root = root->right;\\n                }\\n            }\\n        }\\n    }\\n    void recoverTree(TreeNode* root) {\\n        morrisInorder(root);\\n        swap(first->val, second->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278113,
                "title": "come-on-in-no-explanation-can-be-more-straightforward-than-graph-for-this-problem",
                "content": "\\nFor BST, if we do the in-order traversal, and add to the list, then the nodes in the list are sorted in acsending order. If we put them in a graph, then it will be like below where:\\n- **dark nodes** represent the tree nodes\\n- **red line** represents the **node values trend**\\n\\n![image](https://assets.leetcode.com/users/images/b6fce400-bbdc-4718-8a2a-3b356d58ff2f_1623906705.6791987.jpeg)\\n\\n\\nSo, if 2 nodes are swapped mistakenly, then the graph will be changed to below graph where:\\n- **yellow nodes** represent the node after swapped mistakendly\\n- **blue line** represents the **changed trend**\\n\\n![image](https://assets.leetcode.com/users/images/3e500bc5-960a-4ac9-a8ce-47714a8163c4_1623906718.23329.jpeg)\\n\\nAs we can see:\\n- The 1st mistaken node is the **peak node** around the its neighbors\\n- The 2nd mistaken node is the **negative peak node** around its neighbors\\n\\n**However!!!** it is easy to ignore that there are **2 peaks**, and **2 negative peaks**!!!\\n\\n![image](https://assets.leetcode.com/users/images/f2eff705-102c-48ac-8912-1c6fdddef120_1623907741.1990602.jpeg)\\n\\n\\n\\nThen we can correct above statement to: \\n- The **1st peak node** is the 1st mistaken node\\n- The **2nd node** or **the last node** is the 2nd mistaken node\\n\\nSo we can add condition to deal with above cases:\\n- If we find a peak node, then it is the 1st mistaken node, and we will not update 1st node in the following process\\n- If we find the any negative peak node, then we just update the 2nd mistaken node directly. Then the last negative peak node will overwrite the previous one which is what we want \\n\\n---\\n**Code**\\n```java\\nclass Solution {\\n    public void recoverTree(TreeNode root) {\\n        List<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n\\n        TreeNode node1 = null;\\n        TreeNode node2 = null;\\n        int n = nodes.size();\\n        for(int i = 0; i < nodes.size(); i++){\\n            if(i == 0){\\n                if(nodes.get(0).val > nodes.get(1).val) node1 = nodes.get(0);\\n            }else if(i == n - 1){\\n                if(nodes.get(i).val < nodes.get(i - 1).val) node2 = nodes.get(i);\\n            }else{\\n                if(node1 == null && nodes.get(i).val > nodes.get(i - 1).val && nodes.get(i).val > nodes.get(i + 1).val)\\n                    node1 = nodes.get(i);\\n                else if(nodes.get(i).val < nodes.get(i - 1).val && nodes.get(i).val < nodes.get(i + 1).val)\\n                    node2 = nodes.get(i);\\n            }\\n        }\\n        \\n        // swap val of node1 and node2, instead of node1 and node2 to keep the structure\\n        int tmp = node1.val;\\n        node1.val = node2.val;\\n        node2.val = tmp;\\n    }\\n    \\n    public void inorder(TreeNode root, List<TreeNode> nodes){\\n        if(root == null) return;\\n        \\n        inorder(root.left, nodes);\\n        nodes.add(root);\\n        inorder(root.right, nodes);\\n    }\\n}\\n```\\n\\n---\\n**Complexity Analysis**\\nTC: O(n)\\nSC: O(n)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public void recoverTree(TreeNode root) {\\n        List<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n\\n        TreeNode node1 = null;\\n        TreeNode node2 = null;\\n        int n = nodes.size();\\n        for(int i = 0; i < nodes.size(); i++){\\n            if(i == 0){\\n                if(nodes.get(0).val > nodes.get(1).val) node1 = nodes.get(0);\\n            }else if(i == n - 1){\\n                if(nodes.get(i).val < nodes.get(i - 1).val) node2 = nodes.get(i);\\n            }else{\\n                if(node1 == null && nodes.get(i).val > nodes.get(i - 1).val && nodes.get(i).val > nodes.get(i + 1).val)\\n                    node1 = nodes.get(i);\\n                else if(nodes.get(i).val < nodes.get(i - 1).val && nodes.get(i).val < nodes.get(i + 1).val)\\n                    node2 = nodes.get(i);\\n            }\\n        }\\n        \\n        // swap val of node1 and node2, instead of node1 and node2 to keep the structure\\n        int tmp = node1.val;\\n        node1.val = node2.val;\\n        node2.val = tmp;\\n    }\\n    \\n    public void inorder(TreeNode root, List<TreeNode> nodes){\\n        if(root == null) return;\\n        \\n        inorder(root.left, nodes);\\n        nodes.add(root);\\n        inorder(root.right, nodes);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32650,
                "title": "share-my-java-solution-using-morris-traversal",
                "content": "The Key idea is to use Morris Traversal which only uses O(1) Space. Here is my code and comments.\\nThe code just uses the variable root as the current node.\\n\\n    public class Solution {\\n      public void recoverTree(TreeNode root) {  \\n    \\n        TreeNode first = null;     // first node need to be swap\\n        TreeNode second = null;    // second node need to be swap\\n        TreeNode pre = new TreeNode(Integer.MIN_VALUE);  //previous node.\\n    \\n        while(root!=null){\\n          TreeNode node = root.left;\\n    \\n          // If left is not null, we need to find the rightmost node of left subtree,\\n          // Set its right child to current node\\n          if(node!=null){ \\n         \\n            //find the rightmost\\n            while(node.right!=null && node.right != root){\\n              node = node.right;\\n            }\\n    \\n            //There are two cases,\\n            //null: first time we access current, set node.right to current and move to left child of current and continue;\\n            //current: we accessed current before, thus we've finished traversing left subtree, set node.right back to null;\\n            if(node.right == null){\\n              node.right = root;\\n              root = root.left;\\n              continue;\\n            }else{\\n              node.right = null;\\n            }\\n          }\\n    \\n          // compare current node with previous node\\n          if(root.val < pre.val ){\\n            // first time we enconter reversed order, we set previous node to first\\n            if( first == null ){\\n              first = pre;\\n            }\\n            //In case that two nodes are successive, we set second to current every time.\\n            second = root;\\n          }\\n          pre = root;\\n          root = root.right;      \\n        }\\n    \\n        //swap the value;\\n        int temp = second.val;\\n        second.val = first.val;\\n        first.val = temp;\\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public void recoverTree(TreeNode root) {  \\n    \\n        TreeNode first = null;     // first node need to be swap\\n        TreeNode second = null;    // second node need to be swap\\n        TreeNode pre = new TreeNode(Integer.MIN_VALUE);  //previous node.\\n    \\n        while(root!=null){\\n          TreeNode node = root.left;\\n    \\n          // If left is not null, we need to find the rightmost node of left subtree,\\n          // Set its right child to current node\\n          if(node!=null){ \\n         \\n            //find the rightmost\\n            while(node.right!=null && node.right != root){\\n              node = node.right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 256055,
                "title": "python-inorder-traversal",
                "content": "Since it\\'s a BST, so an inorder traversal returns a sorted array. And we can easily spot the midplaced nodes **first** and **second** as **first** is larger than the element next to it while **second** is smaller than the element ahead of it.\\n\\nSo we can run an inorder traversal. Between inorder(node.left) and inorder(node.right), we need to compare the current node with its neighbor.\\n\\nWe first identify the **first**, pointed by a helper pointer **prev**. And current **node** would be the node next to **prev** in sorted array. If prev.val >= node.val, we find the first node. Then we identify the **second**, which is now pointed by current **node** so that **prev** points to the node ahead of it. If node.val <= prev.val, we find the second node. So it\\'s like:\\n```\\nif not self.first and self.prev.val >= node.val:\\n\\tself.first = self.prev\\nif self.first and self.prev.val >= node.val:\\n\\tself.second = node\\n```\\nAnd we can combine the logic checks as:\\n```\\nif self.prev.val >= node.val:\\n\\tself.first = self.first or self.prev\\n\\tself.second = node\\n```\\nThere are at most two times of ```self.prev.val >= node.val```. That\\'s when **first** and **second** are not neighboring with each other. In such case, the **second** would be allocated to a false node in the first ```self.prev.val >= node.val``` occasion. But that doesn\\'t matter since it would be corrected in the second ```self.prev.val >= node.val```. Meanwhile, the **second** would be allocated to a correct node in the first and only time of ```self.prev.val >= node.val``` when **first** and **second** are neighbors.\\n\\nEventually, we swap the values between **first** and **second**.\\n```\\ndef recoverTree(root):\\n\\tself.first, self.second, self.prev = None, None, TreeNode(float(\\'-inf\\')) \\n\\tdef inorder(node):\\n\\t\\tif node:\\n\\t\\t\\tinorder(node.left)\\n\\t\\t\\tif self.prev.val >= node.val: \\n\\t\\t\\t\\tself.first = self.first or self.prev\\n\\t\\t\\t\\tself.second = node\\n\\t\\t\\tself.prev = node\\n\\t\\t\\tinorder(node.right)\\n\\tinorder(root)\\n\\tself.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "solutionTags": [],
                "code": "```\\nif not self.first and self.prev.val >= node.val:\\n\\tself.first = self.prev\\nif self.first and self.prev.val >= node.val:\\n\\tself.second = node\\n```\n```\\nif self.prev.val >= node.val:\\n\\tself.first = self.first or self.prev\\n\\tself.second = node\\n```\n```self.prev.val >= node.val```\n```self.prev.val >= node.val```\n```self.prev.val >= node.val```\n```self.prev.val >= node.val```\n```\\ndef recoverTree(root):\\n\\tself.first, self.second, self.prev = None, None, TreeNode(float(\\'-inf\\')) \\n\\tdef inorder(node):\\n\\t\\tif node:\\n\\t\\t\\tinorder(node.left)\\n\\t\\t\\tif self.prev.val >= node.val: \\n\\t\\t\\t\\tself.first = self.first or self.prev\\n\\t\\t\\t\\tself.second = node\\n\\t\\t\\tself.prev = node\\n\\t\\t\\tinorder(node.right)\\n\\tinorder(root)\\n\\tself.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1962276,
                "title": "clear-n-easy-to-understand-code",
                "content": "***INORDER TRAVERSAL APPROACH***\\n```\\nclass Solution {\\n     // Creating three global pointers\\n    TreeNode previous = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        // Finding the two swapped nodes\\n        solve(root);\\n        \\n        //Swaping the value of nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n     //New Function to find the two nodes\\n    public void solve(TreeNode root){\\n        \\n        if(root == null){\\n            return;\\n        }\\n        \\n        //Doing inorder traversal i.e, sarting from left then right\\n        solve(root.left);\\n        \\n        // If current node is smaller than previous, then previous node is invalid\\n        if(previous != null && root.val < previous.val){\\n            \\n            //Storing previous node\\n            if(first == null){\\n                first = previous;\\n            }\\n            \\n            //If both nodes are adjacent, save the current node in that case\\n            second = root;\\n            \\n        }\\n        \\n        //Making current node as previous node\\n        previous = root;\\n        \\n        //Moving to right sub-tree\\n        solve(root.right);\\n        \\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***Time Complexity =O(N)***\\n***Space Complexity = O(N)***\\n\\n<hr>\\n<hr>",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     // Creating three global pointers\\n    TreeNode previous = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        // Finding the two swapped nodes\\n        solve(root);\\n        \\n        //Swaping the value of nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n     //New Function to find the two nodes\\n    public void solve(TreeNode root){\\n        \\n        if(root == null){\\n            return;\\n        }\\n        \\n        //Doing inorder traversal i.e, sarting from left then right\\n        solve(root.left);\\n        \\n        // If current node is smaller than previous, then previous node is invalid\\n        if(previous != null && root.val < previous.val){\\n            \\n            //Storing previous node\\n            if(first == null){\\n                first = previous;\\n            }\\n            \\n            //If both nodes are adjacent, save the current node in that case\\n            second = root;\\n            \\n        }\\n        \\n        //Making current node as previous node\\n        previous = root;\\n        \\n        //Moving to right sub-tree\\n        solve(root.right);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32532,
                "title": "my-javascript-solution",
                "content": "The idea is simple, find the two nodes that are swapped by mistake and then swap back their values. The question is how to find out those two nodes?\\n\\nAs we know, an inorder traversal of BST gives us a sorted array, if two elements in the array are swapped, we can find them out in one scan, that is whenever we see the previous value is larger than the current value, we can mark them.\\n\\nFor example, let's say we have a sorted array [0, 1] and we swap the values, so that array becomes [1, 0], when we scan through, we found that 1 > 0, we know that 1 and 0 are the nodes that are swapped by mistake.\\n\\nTake another example, in this array [0, 1, 2, 5, 4, 3], 3 and 5 are swapped by mistake, when we scan the array, we noticed that 5 > 4 and 4 > 3. How to get 3 and 5? Whenever we find a mistake, if it's the first one, mark both nodes as \"first\" and \"second\", for the second mistake, we just have to update the \"second\", see the codes below.\\n\\nBut we are not there yet, the question asks us to use constant space, so we can't store the values of the BST in an array, that will be O(n) space complexity. The solution is to use DFS and traverse the tree in inorder manner.\\n\\nSo time complexity is O(n), space complexity is O(1) (if we don't care about recursion stack, otherwise it's the height of the tree).\\n\\nBelow is the JavaScript code:\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar recoverTree = function(root) {\\n    // first and second are the two nodes that are swapped by mistake\\n    var prev, first, second;\\n    \\n    function inorder(root) {\\n        if (!root) return;\\n        \\n        inorder(root.left);\\n        \\n        if (prev && prev.val > root.val) {\\n            // Found a mistake\\n            if (!first) first = prev; // Only set the \"first\" once\\n            second = root; // Always update the \"second\"\\n        }\\n        prev = root;\\n        \\n        inorder(root.right);\\n    }\\n    \\n    inorder(root);\\n    \\n    // Swap the values of the two nodes\\n    var temp = first.val;\\n    first.val = second.val;\\n    second.val = temp;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar recoverTree = function(root) {\\n    // first and second are the two nodes that are swapped by mistake\\n    var prev, first, second;\\n    \\n    function inorder(root) {\\n        if (!root) return;\\n        \\n        inorder(root.left);\\n        \\n        if (prev && prev.val > root.val) {\\n            // Found a mistake\\n            if (!first) first = prev; // Only set the \"first\" once\\n            second = root; // Always update the \"second\"\\n        }\\n        prev = root;\\n        \\n        inorder(root.right);\\n    }\\n    \\n    inorder(root);\\n    \\n    // Swap the values of the two nodes\\n    var temp = first.val;\\n    first.val = second.val;\\n    second.val = temp;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32613,
                "title": "real-o-1-space-no-recursion-no-stack-etc-o-n-time-solution-48ms-c",
                "content": "Someone complained that a recursion solution isn't really a O(1) space solution. Ok, here comes the real O(1) solution. No recursion, no stack. Pure Morris traversal. 48 ms, C++ :\\n\\n    class Solution {\\n            TreeNode * wrong_node0 = nullptr, * wrong_node1 = nullptr, * prev = nullptr;\\n            void verify(TreeNode * cur)\\n            {\\n                if (prev != nullptr && prev -> val > cur -> val)\\n                {\\n                    if (wrong_node0 == nullptr)\\n                    {\\n                        wrong_node0 = prev;\\n                        wrong_node1 = cur; // in case the tree has only 2 elements.\\n                    }\\n                    else\\n                        wrong_node1 = cur;\\n                }\\n                prev = cur;\\n            }\\n            void morrisInorder(TreeNode * root)\\n            {\\n                TreeNode * cur = root;\\n                while (cur)\\n                {\\n                    if (cur->left == nullptr)\\n                    {\\n                        verify(cur);       \\n                        cur = cur->right;\\n                        continue;\\n                    }\\n                    TreeNode * pred = cur->left;\\n                    while (pred -> right != nullptr && pred -> right != cur)\\n                        pred = pred -> right; //finding predecessor\\n                    if (pred -> right == nullptr)\\n                    {\\n                        pred -> right = cur;\\n                        cur = cur -> left;\\n                    }else {//pred -> right == cur;\\n                        pred -> right = nullptr;\\n                        verify(cur);\\n                        cur = cur -> right;\\n                    }\\n                }\\n            }\\n        public:\\n            void recoverTree(TreeNode* root) {\\n                morrisInorder(root);\\n                swap(wrong_node0->val, wrong_node1->val);\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n            TreeNode * wrong_node0 = nullptr, * wrong_node1 = nullptr, * prev = nullptr;\\n            void verify(TreeNode * cur)\\n            {\\n                if (prev != nullptr && prev -> val > cur -> val)\\n                {\\n                    if (wrong_node0 == nullptr)\\n                    {\\n                        wrong_node0 = prev;\\n                        wrong_node1 = cur; // in case the tree has only 2 elements.\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1671711,
                "title": "constant-space-easy-in-order-traversal-with-explaination",
                "content": "The space taken by the recursion call is not considered as a space complexity here.\\nThe extra space is usually used to store the inorder traversal list. which is not used in this solution.\\n\\nInOrder traversal for BST means the tree is traversed in sorted order, so if any node breaks the sorted order that wll be our node to swap.\\nthat is the first and last node which breaks the sorting is our culprit !!\\n\\n```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n       \\n        res = []     \\n        startnode = None\\n        prev = None\\n        lastnode = None\\n        \\n        def dfs(root):\\n            nonlocal res, startnode, prev, lastnode\\n            if not root:\\n                return \\n            # go to left  (inorder step 1)  \\n            dfs(root.left)\\n\\t\\t\\t\\n            # do processing....(inorder step 2)\\n\\t\\t\\t# get the first node where the sorted order is broken the first time and the last time\\n            if prev and prev.val > root.val:\\n                if not startnode:\\n                    startnode = prev\\n                lastnode = root\\n                \\n            prev = root\\n\\t\\t\\t\\n            # go to right (inorder step 3)    \\n            dfs(root.right)\\n            \\n        \\n        dfs(root)\\n        # swap the nodes that are not in place\\n        if startnode and lastnode:\\n            startnode.val, lastnode.val = lastnode.val, startnode.val\\n```\\n\\n***Please upvote for motivation***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n       \\n        res = []     \\n        startnode = None\\n        prev = None\\n        lastnode = None\\n        \\n        def dfs(root):\\n            nonlocal res, startnode, prev, lastnode\\n            if not root:\\n                return \\n            # go to left  (inorder step 1)  \\n            dfs(root.left)\\n\\t\\t\\t\\n            # do processing....(inorder step 2)\\n\\t\\t\\t# get the first node where the sorted order is broken the first time and the last time\\n            if prev and prev.val > root.val:\\n                if not startnode:\\n                    startnode = prev\\n                lastnode = root\\n                \\n            prev = root\\n\\t\\t\\t\\n            # go to right (inorder step 3)    \\n            dfs(root.right)\\n            \\n        \\n        dfs(root)\\n        # swap the nodes that are not in place\\n        if startnode and lastnode:\\n            startnode.val, lastnode.val = lastnode.val, startnode.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1450119,
                "title": "intuitive-solution-explained-images",
                "content": "### Main idea - __*Inorder Traversal*__\\n\\n![image](https://assets.leetcode.com/users/images/dfb0dab7-b329-4fe6-9827-155227a556f1_1631084787.5005395.png)\\n![image](https://assets.leetcode.com/users/images/16060ed1-2d8c-479c-8d7f-1bc669f72f60_1631084843.3991785.png)\\n![image](https://assets.leetcode.com/users/images/023279fe-b5f2-4e4d-a203-e67a64e59826_1631016630.4750319.png)\\n![image](https://assets.leetcode.com/users/images/ff7e48bf-0485-4bc3-8d57-eb88a335a137_1631016655.0976954.png)\\n![image](https://assets.leetcode.com/users/images/51ab9566-fe0e-47d7-b418-db0fddef2476_1631016670.453483.png)\\n![image](https://assets.leetcode.com/users/images/6c3a4fcc-6088-413b-a357-6fce3dea0c06_1631016696.4263809.png)\\n\\ncode - \\n\\n```java\\n\\nclass Solution{\\npublic static ArrayList<TreeNode> arr;\\n\\n    public static void dfs(TreeNode root) {\\n        if (root == null) return;\\n        dfs(root.left);\\n        arr.add(root);\\n        dfs(root.right);\\n    }\\n\\n    public static void solve(TreeNode root) {\\n        arr = new ArrayList<TreeNode>();\\n        dfs(root);\\n        TreeNode a = null;\\n        TreeNode b = null;\\n        int n = arr.size();\\n        for (int i = 0; i < n; i++) {\\n            int left = i - 1 >= 0 ? arr.get(i - 1).val : Integer.MIN_VALUE;\\n            int right = i + 1 < n ? arr.get(i + 1).val : Integer.MAX_VALUE;\\n            int curr = arr.get(i).val;\\n            if (curr > left && curr > right && left < right) {\\n                a = arr.get(i);\\n            } else if (curr < left && curr < right && left < right) {\\n                b = arr.get(i);\\n            }\\n        }\\n        if (a != null && b != null) {\\n            int temp = a.val;\\n            a.val = b.val;\\n            b.val = temp;\\n        }\\n    }\\n}\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```java\\n\\nclass Solution{\\npublic static ArrayList<TreeNode> arr;\\n\\n    public static void dfs(TreeNode root) {\\n        if (root == null) return;\\n        dfs(root.left);\\n        arr.add(root);\\n        dfs(root.right);\\n    }\\n\\n    public static void solve(TreeNode root) {\\n        arr = new ArrayList<TreeNode>();\\n        dfs(root);\\n        TreeNode a = null;\\n        TreeNode b = null;\\n        int n = arr.size();\\n        for (int i = 0; i < n; i++) {\\n            int left = i - 1 >= 0 ? arr.get(i - 1).val : Integer.MIN_VALUE;\\n            int right = i + 1 < n ? arr.get(i + 1).val : Integer.MAX_VALUE;\\n            int curr = arr.get(i).val;\\n            if (curr > left && curr > right && left < right) {\\n                a = arr.get(i);\\n            } else if (curr < left && curr < right && left < right) {\\n                b = arr.get(i);\\n            }\\n        }\\n        if (a != null && b != null) {\\n            int temp = a.val;\\n            a.val = b.val;\\n            b.val = temp;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926227,
                "title": "100-fastest-swift-solution-time-o-n-space-o-h",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(h), where h is the height of the binary tree.\\n\\n    private var first: TreeNode?\\n    private var second: TreeNode?\\n    private var prev = TreeNode(Int.min)\\n\\n    \\n    func recoverTree(_ root: TreeNode?) {\\n        traverse(root)\\n\\n        guard let first = first, let second = second else { return }\\n\\n        let tmp = first.val\\n        first.val = second.val\\n        second.val = tmp\\n    }\\n\\n\\n    private func traverse(_ root: TreeNode?) {\\n        guard let root = root else { return }\\n        traverse(root.left)\\n\\n        if first == nil, prev.val >= root.val { first = prev }\\n        if first != nil, prev.val >= root.val { second = root }\\n        prev = root\\n\\n        traverse(root.right)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(h), where h is the height of the binary tree.\\n\\n    private var first: TreeNode?\\n    private var second: TreeNode?\\n    private var prev = TreeNode(Int.min)\\n\\n    \\n    func recoverTree(_ root: TreeNode?) {\\n        traverse(root)\\n\\n        guard let first = first, let second = second else { return }\\n\\n        let tmp = first.val\\n        first.val = second.val\\n        second.val = tmp\\n    }\\n\\n\\n    private func traverse(_ root: TreeNode?) {\\n        guard let root = root else { return }\\n        traverse(root.left)\\n\\n        if first == nil, prev.val >= root.val { first = prev }\\n        if first != nil, prev.val >= root.val { second = root }\\n        prev = root\\n\\n        traverse(root.right)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962740,
                "title": "python-simple-o-n-log-n-beats-94",
                "content": "This solution compares the in-order traversal of the tree, which in a correct binary tree should return the elements sorted in ascending order. We then compare this against the sorted elements and swap as soon as we find a mismatch.\\n\\n```python\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        in_order = []\\n        def inOrder(node):\\n            if node is None:\\n                return\\n            inOrder(node.left)\\n            in_order.append(node)\\n            inOrder(node.right)\\n        \\n        inOrder(root)\\n\\n        sorted_order = sorted(in_order, key=lambda x:x.val)\\n        for i in range(len(in_order)):\\n            if in_order[i] != sorted_order[i]:\\n                in_order[i].val, sorted_order[i].val = sorted_order[i].val, in_order[i].val\\n                return\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        in_order = []\\n        def inOrder(node):\\n            if node is None:\\n                return\\n            inOrder(node.left)\\n            in_order.append(node)\\n            inOrder(node.right)\\n        \\n        inOrder(root)\\n\\n        sorted_order = sorted(in_order, key=lambda x:x.val)\\n        for i in range(len(in_order)):\\n            if in_order[i] != sorted_order[i]:\\n                in_order[i].val, sorted_order[i].val = sorted_order[i].val, in_order[i].val\\n                return\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1356869,
                "title": "python-very-easy-to-understand-idea-inorder",
                "content": "\\n```\\nclass Solution:\\n    \\n    \"\"\"\\n        Brute force kind of thing\\n        -> Inorder Traversal returns sorted array\\n        -> find a swap btwn numbers to make sorted\\n        Make single swap to make array sorted\\n        [1, 2, 3, 4, 10, 6, 9, 5, 10, 12]\\n         x, x, x, x, x, No\\n            prev number is mismatch -> 10 is cause\\n        now go frm right to left\\n        [1, 2, 3, 4, 10, 6, 9, 5, 11, 12]\\n                            No x   x   x\\n                        mismatch with next number -> 5 is the cause\\n        swap 10, 5\\n        \\n        Eg: 2\\n        [3, 2, 1]\\n         x  No -> 3 is the cause\\n        [3, 2, 1]\\n         x  No -> 1 is the cause\\n        swap values -> 1, 3\\n    \"\"\"\\n    \\n    def inorder(self, root, li):\\n        if root is None:\\n            return li\\n        li = self.inorder(root.left, li)\\n        li.append(root)\\n        li = self.inorder(root.right, li)\\n        return li\\n    \\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        li = self.inorder(root, [])\\n        n = len(li)\\n        i, j = 1, n-2\\n        a = li[0]\\n        for i in range(1, n):\\n            if li[i].val < li[i-1].val:\\n                a = li[i-1]\\n                break\\n        b = li[-1]\\n        for i in range(n-2, -1, -1):\\n            if li[i].val > li[i+1].val:\\n                b = li[i+1]\\n                break\\n\\n        a.val,b.val = b.val, a.val\\n\\n```\\n\\nNote: We can do LDR, and RDL for 2 loops to get that root1, root2 values [Constant space Operation]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    \"\"\"\\n        Brute force kind of thing\\n        -> Inorder Traversal returns sorted array\\n        -> find a swap btwn numbers to make sorted\\n        Make single swap to make array sorted\\n        [1, 2, 3, 4, 10, 6, 9, 5, 10, 12]\\n         x, x, x, x, x, No\\n            prev number is mismatch -> 10 is cause\\n        now go frm right to left\\n        [1, 2, 3, 4, 10, 6, 9, 5, 11, 12]\\n                            No x   x   x\\n                        mismatch with next number -> 5 is the cause\\n        swap 10, 5\\n        \\n        Eg: 2\\n        [3, 2, 1]\\n         x  No -> 3 is the cause\\n        [3, 2, 1]\\n         x  No -> 1 is the cause\\n        swap values -> 1, 3\\n    \"\"\"\\n    \\n    def inorder(self, root, li):\\n        if root is None:\\n            return li\\n        li = self.inorder(root.left, li)\\n        li.append(root)\\n        li = self.inorder(root.right, li)\\n        return li\\n    \\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        li = self.inorder(root, [])\\n        n = len(li)\\n        i, j = 1, n-2\\n        a = li[0]\\n        for i in range(1, n):\\n            if li[i].val < li[i-1].val:\\n                a = li[i-1]\\n                break\\n        b = li[-1]\\n        for i in range(n-2, -1, -1):\\n            if li[i].val > li[i+1].val:\\n                b = li[i+1]\\n                break\\n\\n        a.val,b.val = b.val, a.val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448583,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. In-order dfs traverse the tree in ascending order (very Important)\\n2. Save a record of the previous node, if the current node is smaller than the previous node, that means we\\'ve found 2 potential elements that will be swapped.\\n3. Out of the 2 potential elements, we are sure that the bigger one must be swapped, however, the smaller one aren\\'t sure, so we need to continue the dfs.\\n*The idea of the swapping mechanism is exactly the same in \"sorting an almost sorted array\"\\n``` javascript\\nvar recoverTree = function(root) {\\n    let prev = null, big = null, small = null;\\n    let dfs = function(root) {\\n        if (!root) return;\\n        dfs(root.left);\\n        if (prev != null && prev.val > root.val) {\\n            small = root; // potential smaller number that needs to be swapped\\n            if (!big) big = prev; // assured bigger number that needs to be swapped\\n            else return;\\n        }\\n        prev = root;\\n        dfs(root.right);\\n    }\\n    \\n    dfs(root);\\n    [big.val, small.val] = [small.val, big.val];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar recoverTree = function(root) {\\n    let prev = null, big = null, small = null;\\n    let dfs = function(root) {\\n        if (!root) return;\\n        dfs(root.left);\\n        if (prev != null && prev.val > root.val) {\\n            small = root; // potential smaller number that needs to be swapped\\n            if (!big) big = prev; // assured bigger number that needs to be swapped\\n            else return;\\n        }\\n        prev = root;\\n        dfs(root.right);\\n    }\\n    \\n    dfs(root);\\n    [big.val, small.val] = [small.val, big.val];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32646,
                "title": "python-inorder-traversal-solution-based-on-validate-binary-search-tree",
                "content": "    class Solution:\\n    # @param root, a tree node\\n    # @return a tree node\\n    def recoverTree(self, root):\\n        it = self.isValidBST(root)\\n        a, b = next(it)\\n        c = next(it, None)\\n        if c:\\n            _, c = c\\n            a.val, c.val = c.val, a.val\\n        else:\\n            a.val, b.val = b.val, a.val\\n        return root\\n\\n    def isValidBST(self, root):\\n        pre, cur, stack = None, root, []\\n        while stack or cur:\\n            while cur:\\n                stack.append(cur)\\n                cur = cur.left\\n            s = stack.pop()\\n            if pre and s.val <= pre.val:\\n                yield pre, s\\n            pre, cur = s, s.right\\n\\nThis is a simple O(n) space solution.\\n\\nAdd Java solution\\n\\n    TreeNode prev = null;\\n    LinkedList<TreeNode> result = new LinkedList<TreeNode>();\\n\\n    public void recoverTree(TreeNode root) {\\n        isValidBST(root);\\n        TreeNode first = result.poll();\\n        TreeNode last = result.pollLast();\\n        int temp = first.val;\\n        first.val = last.val;\\n        last.val = temp;\\n    }\\n\\n    private void isValidBST(TreeNode root) {\\n        if (root == null)\\n            return;\\n        isValidBST(root.left);\\n        if (prev != null && root.val < prev.val) {\\n            result.add(prev);\\n            result.add(root);\\n        }\\n        prev = root;\\n        isValidBST(root.right);\\n    }",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param root, a tree node\\n    # @return a tree node\\n    def recoverTree(self, root):\\n        it = self.isValidBST(root)\\n        a, b = next(it)\\n        c = next(it, None)\\n        if c:\\n            _, c = c\\n            a.val, c.val = c.val, a.val\\n        else:\\n            a.val, b.val = b.val, a.val\\n        return root\\n\\n    def isValidBST(self, root):\\n        pre, cur, stack = None, root, []\\n        while stack or cur:\\n            while cur:\\n                stack.append(cur)\\n                cur = cur.left\\n            s = stack.pop()\\n            if pre and s.val <= pre.val:\\n                yield pre, s\\n            pre, cur = s, s.right\\n\\nThis is a simple O(n) space solution.\\n\\nAdd Java solution\\n\\n    TreeNode prev = null;\\n    LinkedList<TreeNode> result = new LinkedList<TreeNode>();\\n\\n    public void recoverTree(TreeNode root) {\\n        isValidBST(root);\\n        TreeNode first = result.poll();\\n        TreeNode last = result.pollLast();\\n        int temp = first.val;\\n        first.val = last.val;\\n        last.val = temp;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1962728,
                "title": "easy-to-understand-java",
                "content": "```\\nclass Solution {\\n    private TreeNode first = null;\\n    private TreeNode second = null;\\n    private TreeNode pre = null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        if(root==null) return;\\n\\n        //find swapped nodes\\n        inorder(root);\\n        \\n        //swap the nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        \\n        //find the first node which is at wrong position\\n        if(first==null && (pre==null ||pre.val>=root.val)){\\n            first = pre;\\n        }\\n        \\n        //find the second node which is at wrong position\\n        if(first!=null && pre.val>=root.val){\\n            second = root;\\n        }\\n        \\n        //store previus node to compare\\n        pre = root;\\n        inorder(root.right);\\n    }\\n}\\n```\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote**\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private TreeNode first = null;\\n    private TreeNode second = null;\\n    private TreeNode pre = null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        if(root==null) return;\\n\\n        //find swapped nodes\\n        inorder(root);\\n        \\n        //swap the nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        \\n        //find the first node which is at wrong position\\n        if(first==null && (pre==null ||pre.val>=root.val)){\\n            first = pre;\\n        }\\n        \\n        //find the second node which is at wrong position\\n        if(first!=null && pre.val>=root.val){\\n            second = root;\\n        }\\n        \\n        //store previus node to compare\\n        pre = root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32607,
                "title": "beat-99-fast-java-solution-o-h-space-with-explanation",
                "content": "The basic idea is to use stack to do in-order traversal. In the processing of traversal, keep comparing the current value with the previous value. Since each previous value should be less than the current value, once an exception is found, record the previous node as the First Mistaken Node and the current node as Second. If one more exceptions are found, override the current node to the Second Mistaken Node. Because if a series of mistaken nodes are found, the only possible way to correct them with one swap is to switch the head and tail node. \\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tTreeNode pre = null, first = null, second = null;\\n\\t\\tDeque<TreeNode> stack = new LinkedList<TreeNode>();\\n\\t\\twhile (root != null) {\\n\\t\\t\\tstack.push(root);\\n\\t\\t\\troot = root.left;\\n\\t\\t}\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tTreeNode temp = stack.pop();\\n\\t\\t\\tif (pre != null)\\n\\t\\t\\t\\tif (pre.val > temp.val) {\\n\\t\\t\\t\\t\\tif (first == null)\\n\\t\\t\\t\\t\\t\\tfirst = pre;\\n\\t\\t\\t\\t\\tsecond = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tpre = temp;\\n\\t\\t\\tif (temp.right != null) {\\n\\t\\t\\t\\ttemp = temp.right;\\n\\t\\t\\t\\twhile (temp != null) {\\n\\t\\t\\t\\t\\tstack.push(temp);\\n\\t\\t\\t\\t\\ttemp = temp.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint temp = first.val;\\n\\t\\tfirst.val = second.val;\\n\\t\\tsecond.val = temp;\\n\\t}",
                "solutionTags": [],
                "code": "The basic idea is to use stack to do in-order traversal. In the processing of traversal, keep comparing the current value with the previous value. Since each previous value should be less than the current value, once an exception is found, record the previous node as the First Mistaken Node and the current node as Second. If one more exceptions are found, override the current node to the Second Mistaken Node. Because if a series of mistaken nodes are found, the only possible way to correct them with one swap is to switch the head and tail node. \\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tTreeNode pre = null, first = null, second = null;\\n\\t\\tDeque<TreeNode> stack = new LinkedList<TreeNode>();\\n\\t\\twhile (root != null) {\\n\\t\\t\\tstack.push(root);\\n\\t\\t\\troot = root.left;\\n\\t\\t}\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tTreeNode temp = stack.pop();\\n\\t\\t\\tif (pre != null)\\n\\t\\t\\t\\tif (pre.val > temp.val) {\\n\\t\\t\\t\\t\\tif (first == null)\\n\\t\\t\\t\\t\\t\\tfirst = pre;\\n\\t\\t\\t\\t\\tsecond = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tpre = temp;\\n\\t\\t\\tif (temp.right != null) {\\n\\t\\t\\t\\ttemp = temp.right;\\n\\t\\t\\t\\twhile (temp != null) {\\n\\t\\t\\t\\t\\tstack.push(temp);\\n\\t\\t\\t\\t\\ttemp = temp.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint temp = first.val;\\n\\t\\tfirst.val = second.val;\\n\\t\\tsecond.val = temp;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1138233,
                "title": "self-explanatory-easy-solution-for-hard-question",
                "content": "- Prerequisites [**Validate Binary Search Tree**](https://leetcode.com/problems/validate-binary-search-tree) \\n- My [Solution for Validate BST](https://leetcode.com/problems/validate-binary-search-tree/discuss/1138232/Self-Explanatory-Easy-DFS-Solution)\\n- By Saurav Kumar Gupta\\n- Please **upvote** if it helps you.\\n\\n```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr;\\n        TreeNode *first = nullptr;\\n        TreeNode *second = nullptr;\\n        \\n        stack<TreeNode *> S;\\n        \\n        while(root || !S.empty()) {\\n            while(root) {\\n                S.push(root);\\n                root = root->left;\\n            }\\n            \\n            root = S.top(); S.pop();\\n            \\n            if(prev && prev->val > root->val) {\\n                if(!first) first = prev;\\n                second = root;\\n            }\\n            \\n            prev = root;\\n            root = root->right;\\n        }\\n        \\n        swap(first->val , second->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr;\\n        TreeNode *first = nullptr;\\n        TreeNode *second = nullptr;\\n        \\n        stack<TreeNode *> S;\\n        \\n        while(root || !S.empty()) {\\n            while(root) {\\n                S.push(root);\\n                root = root->left;\\n            }\\n            \\n            root = S.top(); S.pop();\\n            \\n            if(prev && prev->val > root->val) {\\n                if(!first) first = prev;\\n                second = root;\\n            }\\n            \\n            prev = root;\\n            root = root->right;\\n        }\\n        \\n        swap(first->val , second->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32546,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Recover Binary Search Tree** https://leetcode.com/problems/recover-binary-search-tree/?tab=Description\\n\\n**Algorithm**\\n1. Use a tree example: [100, 50, 200, 25, 75, 99, 400]\\n2. Sorted Order: 25,50,75,100,150,200,400\\n3. You can have out of order 50 and 200: 25,**200**,75,100,150,**50**,400. Notice in this case we have 2 out of order pairs: (200,75) and (150,50). Simply swap 200 and 50.\\n4. What if 25/50 or 200/400 are swapped? In that case we will have just one out of order element.\\n5. 3 and 4 give us our algorithm.\\n\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.order = []\\n        self.prev = None\\n        self.inorder(root)\\n        if len(self.order) == 2:\\n            self.swap(self.order[0][0], self.order[1][1])\\n        elif len(self.order) == 1:\\n            self.swap(self.order[0][0], self.order[0][1])\\n        return\\n    \\n    def inorder(self, root):\\n        if root == None:\\n            return\\n        self.inorder(root.left)\\n        if self.prev and self.prev.val > root.val:\\n            self.order.append((self.prev, root))\\n        self.prev = root\\n        self.inorder(root.right)\\n        return\\n    \\n    def swap(self, r1, r2):\\n        r1.val, r2.val = r2.val, r1.val\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.order = []\\n        self.prev = None\\n        self.inorder(root)\\n        if len(self.order) == 2:\\n            self.swap(self.order[0][0], self.order[1][1])\\n        elif len(self.order) == 1:\\n            self.swap(self.order[0][0], self.order[0][1])\\n        return\\n    \\n    def inorder(self, root):\\n        if root == None:\\n            return\\n        self.inorder(root.left)\\n        if self.prev and self.prev.val > root.val:\\n            self.order.append((self.prev, root))\\n        self.prev = root\\n        self.inorder(root.right)\\n        return\\n    \\n    def swap(self, r1, r2):\\n        r1.val, r2.val = r2.val, r1.val\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32592,
                "title": "an-elegent-o-n-time-complexity-and-o-1-space-complexity-algorithm",
                "content": "Note: 1. Given a sequence `{1, 4, 3, 7, 9}`, you find pair `4(!<=)3`, swap this pair and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa02. Given a sequence `{1, 9, 4, 5, 3, 10}`, you get first pair `9(!<=)4` and second pair `5(!<=)3`, swap pair `9(!<=)3` and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa03. Given a sequence, only in two above (general) cases, that you can just swap one pair numbers to convert an unordered sequence into ordered. <br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa04. You can tranverse BST inorder to get above sequence.<br/>So, my alg is:<br/>\\n\\n    void recover(TreeNode *root, TreeNode *&pre, TreeNode *&a, TreeNode *&b) {\\n        if (root)\\n        {\\n            recover(root->left, pre, a, b);\\n            \\n            if (root->val < pre->val)\\n            {\\n                if (!a) a = pre; //a should change once.\\n                b = root; //b could change twice.\\n            }\\n            pre = root;\\n            \\n            recover(root->right, pre, a, b);\\n        }\\n    }\\n    void recoverTree(TreeNode *root) {\\n        if (!root) return;\\n        \\n        TreeNode p(numeric_limits<int>::min());\\n        TreeNode *a, *b, *pre;\\n        a = b = 0;\\n        pre = &p;\\n        recover(root, pre, a, b);\\n        if (a && b)\\n        {\\n            swap(a->val, b->val);\\n        }\\n        return;\\n    }\\n\\nI think this problem requirement is strange. Does O(1) space complexity algorithm exists?\\n<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. Does BST should be tranversed?<br/>&nbsp;&nbsp;&nbsp;&nbsp; 2. If answer of `1` is true, I don't think an O(1) space complexity exists, for there does not exists a BST tranverse algorithm taking O(1) space complexity.<br/>&nbsp;&nbsp;&nbsp;&nbsp;3. If answer of `1` is false, I just wonder how can you find the disordered pair.",
                "solutionTags": [],
                "code": "Note: 1. Given a sequence `{1, 4, 3, 7, 9}`, you find pair `4(!<=)3`, swap this pair and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa02. Given a sequence `{1, 9, 4, 5, 3, 10}`, you get first pair `9(!<=)4` and second pair `5(!<=)3`, swap pair `9(!<=)3` and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa03. Given a sequence, only in two above (general) cases, that you can just swap one pair numbers to convert an unordered sequence into ordered. <br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa04. You can tranverse BST inorder to get above sequence.<br/>So, my alg is:<br/>\\n\\n    void recover(TreeNode *root, TreeNode *&pre, TreeNode *&a, TreeNode *&b) {\\n        if (root)\\n        {\\n            recover(root->left, pre, a, b);\\n            \\n            if (root->val < pre->val)\\n            {\\n                if (!a) a = pre; //a should change once.\\n                b = root; //b could change twice.\\n            }\\n            pre = root;\\n            \\n            recover(root->right, pre, a, b);\\n        }\\n    }\\n    void recoverTree(TreeNode *root) {\\n        if (!root) return;\\n        \\n        TreeNode p(numeric_limits<int>::min());\\n        TreeNode *a, *b, *pre;\\n        a = b = 0;\\n        pre = &p;\\n        recover(root, pre, a, b);\\n        if (a && b)\\n        {\\n            swap(a->val, b->val);\\n        }\\n        return;\\n    }\\n\\nI think this problem requirement is strange. Does O(1) space complexity algorithm exists?\\n<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. Does BST should be tranversed?<br/>&nbsp;&nbsp;&nbsp;&nbsp; 2. If answer of `1` is true, I don't think an O(1) space complexity exists, for there does not exists a BST tranverse algorithm taking O(1) space complexity.<br/>&nbsp;&nbsp;&nbsp;&nbsp;3. If answer of `1` is false, I just wonder how can you find the disordered pair.",
                "codeTag": "Unknown"
            },
            {
                "id": 1962388,
                "title": "c-cheating-with-sort-vector-and-inorder-traversal",
                "content": "Couldn\\'t figure it out the big brain way, so here is the cheater\\'s solution.\\n\\n**SOLVED LIVE ON STREAM.  Everyday 6pm PT. Link in profile**\\n\\n```\\nclass Solution {\\n\\n    void dfs(TreeNode* root, vector<int>& cheat) {\\n        if(!root) return;\\n        \\n        dfs(root->left, cheat);\\n        cheat.push_back(root->val);\\n        dfs(root->right, cheat);\\n    }\\n    \\n    void cheatAgain(TreeNode* root, vector<int>& cheat, int& i) {\\n        if(!root) return;\\n        cheatAgain(root->left, cheat, i);\\n        if(root->val != cheat[i]) {\\n            root->val = cheat[i];\\n        }\\n        i++;\\n        cheatAgain(root->right, cheat, i);\\n        \\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        vector<int> cheat;\\n        dfs(root, cheat);\\n        sort(cheat.begin(), cheat.end());\\n        int i = 0;\\n        cheatAgain(root, cheat, i);\\n        return;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    void dfs(TreeNode* root, vector<int>& cheat) {\\n        if(!root) return;\\n        \\n        dfs(root->left, cheat);\\n        cheat.push_back(root->val);\\n        dfs(root->right, cheat);\\n    }\\n    \\n    void cheatAgain(TreeNode* root, vector<int>& cheat, int& i) {\\n        if(!root) return;\\n        cheatAgain(root->left, cheat, i);\\n        if(root->val != cheat[i]) {\\n            root->val = cheat[i];\\n        }\\n        i++;\\n        cheatAgain(root->right, cheat, i);\\n        \\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        vector<int> cheat;\\n        dfs(root, cheat);\\n        sort(cheat.begin(), cheat.end());\\n        int i = 0;\\n        cheatAgain(root, cheat, i);\\n        return;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917951,
                "title": "python-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=XHx4OQ5BLoE)\\nhttps://www.youtube.com/watch?v=XHx4OQ5BLoE\\n```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        curr = root\\n        prev = TreeNode(float(\\'-inf\\'))\\n        replace = []\\n        stack = []\\n        \\n        while curr or stack:\\n            while curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            \\n            temp = stack.pop()\\n            \\n            if temp.val < prev.val:\\n                replace.append((prev, temp))\\n            \\n            prev = temp\\n            curr = temp.right\\n        \\n        replace[0][0].val, replace[-1][1].val = replace[-1][1].val, replace[0][0].val \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        curr = root\\n        prev = TreeNode(float(\\'-inf\\'))\\n        replace = []\\n        stack = []\\n        \\n        while curr or stack:\\n            while curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            \\n            temp = stack.pop()\\n            \\n            if temp.val < prev.val:\\n                replace.append((prev, temp))\\n            \\n            prev = temp\\n            curr = temp.right\\n        \\n        replace[0][0].val, replace[-1][1].val = replace[-1][1].val, replace[0][0].val \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772201,
                "title": "c-solutions-easy-to-solve",
                "content": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\tfirstMistake = pre;\\n\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\tsecondMistake = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\tfirstMistake = pre;\\n\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\tsecondMistake = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339518,
                "title": "easy-to-understand-inorder-traversal",
                "content": "we first need to find the two nodes that are not valid under the condition for bst i.e the inorder of bst is always sorted, once we find the two nodes, we will normally swap it. \\nDone!!!\\n\\n\\n```\\nclass Solution {\\n    TreeNode prev = null;TreeNode first = null; TreeNode second = null;\\n    \\n    public void inorderHelper(TreeNode root)\\n    {\\n        if(root == null)  return;\\n        \\n        inorderHelper(root.left);\\n        \\n        if(first == null && prev != null && prev.val >= root.val)\\n            first = prev;\\n        \\n        if(first != null && prev.val >= root.val)\\n            second = root;\\n        \\n        prev = root;\\n        \\n        inorderHelper(root.right);\\n    }\\n    \\n    public void swap(TreeNode first, TreeNode second)\\n    {\\n        int temp = first.val;\\n        \\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    public void recoverTree(TreeNode root)\\n    {\\n        prev = null; first = null; second = null;\\n        \\n        inorderHelper(root);\\n        \\n        swap(first,second);\\n    \\n    }\\n}\\n```\\n\\nthe cpp solution for the same\\n```\\nclass Solution {\\npublic:\\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    TreeNode* prev = NULL;\\n    \\n    void inorderRecover(TreeNode*& root)\\n    {\\n        if(!root) return;\\n         \\n        inorderRecover(root->left);\\n        \\n        if(!first && prev && prev->val >= root->val)\\n            first = prev;\\n        \\n        if(first && prev->val >= root->val)\\n            second = root;\\n        \\n        prev = root;\\n        \\n        inorderRecover(root->right);\\n    }\\n    \\n    void swap(TreeNode*& first, TreeNode*& second)\\n    {\\n        int temp = first->val;\\n        \\n        first->val = second->val;\\n        second->val = temp;\\n    }\\n    \\n    void recoverTree(TreeNode* root) \\n    {\\n        inorderRecover(root);\\n        \\n        swap(first,second);\\n    }\\n};\\n```\\n Feel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev = null;TreeNode first = null; TreeNode second = null;\\n    \\n    public void inorderHelper(TreeNode root)\\n    {\\n        if(root == null)  return;\\n        \\n        inorderHelper(root.left);\\n        \\n        if(first == null && prev != null && prev.val >= root.val)\\n            first = prev;\\n        \\n        if(first != null && prev.val >= root.val)\\n            second = root;\\n        \\n        prev = root;\\n        \\n        inorderHelper(root.right);\\n    }\\n    \\n    public void swap(TreeNode first, TreeNode second)\\n    {\\n        int temp = first.val;\\n        \\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    public void recoverTree(TreeNode root)\\n    {\\n        prev = null; first = null; second = null;\\n        \\n        inorderHelper(root);\\n        \\n        swap(first,second);\\n    \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    TreeNode* prev = NULL;\\n    \\n    void inorderRecover(TreeNode*& root)\\n    {\\n        if(!root) return;\\n         \\n        inorderRecover(root->left);\\n        \\n        if(!first && prev && prev->val >= root->val)\\n            first = prev;\\n        \\n        if(first && prev->val >= root->val)\\n            second = root;\\n        \\n        prev = root;\\n        \\n        inorderRecover(root->right);\\n    }\\n    \\n    void swap(TreeNode*& first, TreeNode*& second)\\n    {\\n        int temp = first->val;\\n        \\n        first->val = second->val;\\n        second->val = temp;\\n    }\\n    \\n    void recoverTree(TreeNode* root) \\n    {\\n        inorderRecover(root);\\n        \\n        swap(first,second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225150,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func recoverTree(_ root: TreeNode?) {\\n        var lhs: TreeNode?, rhs: TreeNode?, prev: TreeNode?\\n        func bfs(_ root: TreeNode?) {\\n            guard let node = root else { return }\\n            bfs(node.left)\\n            if lhs == nil, let prev = prev, prev.val > node.val { lhs = prev }\\n            if lhs != nil, rhs == nil || node.val < rhs!.val { rhs = node }\\n            prev = node\\n            bfs(node.right)\\n        }\\n        bfs(root)\\n        if let lhs = lhs, let rhs = rhs {\\n            let tmp = lhs.val\\n            lhs.val = rhs.val\\n            rhs.val = tmp\\n        }\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.034 (0.036) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test1() {\\n        let tree = TreeNode([1,3,nil,nil,2])\\n        solution.recoverTree(tree)\\n        XCTAssertEqual(tree?.val, TreeNode([3,1,nil,nil,2])?.val)\\n    }\\n    \\n    func test2() {\\n        let tree = TreeNode([3,1,4,nil,nil,2])\\n        solution.recoverTree(tree)\\n        XCTAssertEqual(tree?.val, TreeNode([2,1,4,nil,nil,3])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n\\n<details>\\n<summary><b>TreeNode</b></summary>\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ nums: [Int?]) {\\n        var arr = nums\\n        guard !arr.isEmpty, let head = arr.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let root = queue.removeFirst()\\n            if !arr.isEmpty, let val = arr.removeFirst() {\\n                root.left = TreeNode(val)\\n                queue.append(root.left!)\\n            }\\n            if !arr.isEmpty, let val = arr.removeFirst() {\\n                root.right = TreeNode(val)\\n                queue.append(root.right!)\\n            }\\n        }\\n    }\\n}\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Breadth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func recoverTree(_ root: TreeNode?) {\\n        var lhs: TreeNode?, rhs: TreeNode?, prev: TreeNode?\\n        func bfs(_ root: TreeNode?) {\\n            guard let node = root else { return }\\n            bfs(node.left)\\n            if lhs == nil, let prev = prev, prev.val > node.val { lhs = prev }\\n            if lhs != nil, rhs == nil || node.val < rhs!.val { rhs = node }\\n            prev = node\\n            bfs(node.right)\\n        }\\n        bfs(root)\\n        if let lhs = lhs, let rhs = rhs {\\n            let tmp = lhs.val\\n            lhs.val = rhs.val\\n            rhs.val = tmp\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test1() {\\n        let tree = TreeNode([1,3,nil,nil,2])\\n        solution.recoverTree(tree)\\n        XCTAssertEqual(tree?.val, TreeNode([3,1,nil,nil,2])?.val)\\n    }\\n    \\n    func test2() {\\n        let tree = TreeNode([3,1,4,nil,nil,2])\\n        solution.recoverTree(tree)\\n        XCTAssertEqual(tree?.val, TreeNode([2,1,4,nil,nil,3])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ nums: [Int?]) {\\n        var arr = nums\\n        guard !arr.isEmpty, let head = arr.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let root = queue.removeFirst()\\n            if !arr.isEmpty, let val = arr.removeFirst() {\\n                root.left = TreeNode(val)\\n                queue.append(root.left!)\\n            }\\n            if !arr.isEmpty, let val = arr.removeFirst() {\\n                root.right = TreeNode(val)\\n                queue.append(root.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223843,
                "title": "detailed-explanation-of-solution-with-code",
                "content": "Inorder traversal of BST gives the elements in increasing order -> Almost all BST problems are based on this property.\\n\\nSolution 1: Using O(n) space, we can store the inorder traversal of the BST and then find the out-of-order elements, and swap them in the BST.\\nSolution 2: Using constant space and one pass of the BST. Let\\'s dive into it.\\n\\nThink about it. Do you really need to store all the elements to find the out-of-order numbers?\\nNo, you don\\'t. Since there are exactly 2 faulty nodes, we don\\'t need to store the entire traversal. How?\\nWe can keep track of the previously visited node, and compare its value with the current node. Whenever current.val < previous.val, we have found our anomaly.\\n\\nNow there can be 2 possible scenarios. Either the swapped elements are adjacent in the inorder traversal (not in the BST), or they are not.\\n\\nExample 1: Not adjacent\\n\\n        1\\n\\t  /\\n\\t3\\n      \\\\\\n        2\\n\\nThe inorder traversal of this tree is [3,2,1]. Here the swapped nodes are 1 and 3. \\n\\nExample 2: Adjacent\\n\\n        3\\n\\t  /   \\\\\\n\\t1       4\\n\\t      / \\n\\t    2 \\n\\nThe inorder traversal of this tree is [1,3,2,4]. Here the swapped nodes are 3 and 2. \\n\\n**Scenario 1**(Not adjacent) :\\n\\nIf you swap 2 non adjacent numbers in a sorted list, you would move a smaller number among bigger numbers and a bigger number among smaller numbers.\\n\\nFor instance, 1,2,3,4,5,6,7 => If you swap 3 with 6, you would move 6 between 2 and 4 (smaller than 6) and 3 between 5 and 7 (bigger than 3).\\nSo the faulty list will be [1,2,6,4,5,3,7]. Suppose this was our input to begin with. \\nWe will look for the anomaly now.\\n\\nprevious = 1, current = 2 Here previous < current => No anomaly. \\nprevious = 2, current = 6 Here previous < current => No anomaly.\\nprevious = 6, current = 4 Here previous > current => ANOMALY.\\nSimilarly, \\nprevious = 5, current = 3 Here previous > current => ANOMALY.\\n\\n**Scenario 2**(Adjacent)\\n\\nIn this case you will not find a second anomaly. So, swap previous with current.\\n\\nNow when we first encounter the anomaly, the faulty node is previous. But when we encounter 2nd anomaly, faulty node is current.\\n**Why? When you swap 2 non adjacent numbers in a sorted list, you would move a smaller number among bigger numbers and a bigger number among smaller numbers.**\\n\\nAlgorithm: \\n1. Initialise faultyA, faultyB, previous as null.\\n2. Visit every node, and keep track of the previous node.\\n3. if current < previous, then assign previous node to faultyA and current node to faultyB (for Scenario 2)\\n4. if current < previous is encountered again, or, if faultyA != null, assign currentNode to faultyB.\\n5. After traversal is complete, swap the faulty nodes.\\n\\nCode:\\n```\\nclass Solution {\\n    TreeNode faultyA = null;\\n    TreeNode faultyB = null;\\n    TreeNode mPrevious = null;\\n    public void recoverTree(TreeNode root) {\\n        findFaultyNodes(root);\\n        \\n        //Swap faulty nodes\\n        if(faultyA != null && faultyB != null) {\\n            int temp = faultyA.val;\\n            faultyA.val = faultyB.val;\\n            faultyB.val = temp;\\n        }\\n    }\\n    \\n    private void findFaultyNodes(TreeNode node) {\\n        if(node == null) {\\n            return;\\n        }\\n        \\n        findFaultyNodes(node.left);\\n        if(mPrevious != null) {\\n            if(node.val < mPrevious.val) {\\n                if(faultyA == null) {\\n                    faultyA = mPrevious;\\n                    faultyB = node;\\n                } else {\\n                    faultyB = node;\\n                }\\n            }\\n        }\\n        mPrevious = node;\\n        findFaultyNodes(node.right);\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    TreeNode faultyA = null;\\n    TreeNode faultyB = null;\\n    TreeNode mPrevious = null;\\n    public void recoverTree(TreeNode root) {\\n        findFaultyNodes(root);\\n        \\n        //Swap faulty nodes\\n        if(faultyA != null && faultyB != null) {\\n            int temp = faultyA.val;\\n            faultyA.val = faultyB.val;\\n            faultyB.val = temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3035927,
                "title": "c-inorder-traversal",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\nclass Solution {\\npublic:\\n  TreeNode *p = NULL;\\n  TreeNode *k = NULL;\\n  TreeNode *l = NULL;\\n  bool z = true;\\n  void solve(TreeNode *root) {\\n    if (root == NULL)\\n      return;\\n\\n    solve(root->left);\\n    if (z) {\\n      if (p == NULL || p->val < root->val) {\\n        p = root;\\n      } else {\\n        k = p;\\n        l = root;\\n        z = false;\\n        p = root;\\n      }\\n    } else {\\n        if (p == NULL || p->val < root->val) {\\n        p = root;\\n      } else {\\n        l = root;\\n      }\\n    }\\n    solve(root->right);\\n  }\\n\\n  void recoverTree(TreeNode *root) {\\n      solve(root);\\n      swap(k->val,l->val);\\n  }\\n};",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n  TreeNode *p = NULL;\\n  TreeNode *k = NULL;\\n  TreeNode *l = NULL;\\n  bool z = true;\\n  void solve(TreeNode *root) {\\n    if (root == NULL)\\n      return;\\n\\n    solve(root->left);\\n    if (z) {\\n      if (p == NULL || p->val < root->val) {\\n        p = root;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1548861,
                "title": "3-codes-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    vector<TreeNode*> tree;\\n \\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root);\\n        inOrder(root->right);\\n    }\\n  int index = 0;\\n    \\n    void res(TreeNode* root)\\n    {\\n      if(!root)\\n          return;\\n        \\n        res(root->left);\\n        root->val = tree[index++];\\n        res(root->right);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n     inOrder(root);\\n        sort(tree.begin() , tree.end());\\n        res(root);\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n\\n    vector<TreeNode*> tree;\\n \\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root);\\n        inOrder(root->right);\\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n     inOrder(root);\\n            int i, j;\\n        int n = tree.size();\\n    for (i = 0; i < n-1; i++)    \\n    for (j = 0; j < n-i-1; j++)\\n        if (tree[j]->val > tree[j+1]->val)\\n            swap(tree[j]->val, tree[j+1]->val);\\n\\n    }\\n};\\n```\\n```\\nvoid getOrder(TreeNode* root, vector<TreeNode*> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root);\\n        getOrder(root->right, inOrder);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inOrder;\\n        getOrder(root, inOrder);\\n        int n = inOrder.size();\\n        \\n        for(int i = 1; i < n; i++)\\n            if(inOrder[i-1]->val > inOrder[i]->val)\\n            {\\n                int j = n-1;\\n                for(; j >= i; j--)\\n                {if(inOrder[j]->val < inOrder[j-1]->val) break;}\\n                swap(inOrder[j]->val, inOrder[i-1]->val);\\n                break;\\n            }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<TreeNode*> tree;\\n \\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root);\\n        inOrder(root->right);\\n    }\\n  int index = 0;\\n    \\n    void res(TreeNode* root)\\n    {\\n      if(!root)\\n          return;\\n        \\n        res(root->left);\\n        root->val = tree[index++];\\n        res(root->right);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n     inOrder(root);\\n        sort(tree.begin() , tree.end());\\n        res(root);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    vector<TreeNode*> tree;\\n \\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root);\\n        inOrder(root->right);\\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n     inOrder(root);\\n            int i, j;\\n        int n = tree.size();\\n    for (i = 0; i < n-1; i++)    \\n    for (j = 0; j < n-i-1; j++)\\n        if (tree[j]->val > tree[j+1]->val)\\n            swap(tree[j]->val, tree[j+1]->val);\\n\\n    }\\n};\\n```\n```\\nvoid getOrder(TreeNode* root, vector<TreeNode*> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root);\\n        getOrder(root->right, inOrder);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inOrder;\\n        getOrder(root, inOrder);\\n        int n = inOrder.size();\\n        \\n        for(int i = 1; i < n; i++)\\n            if(inOrder[i-1]->val > inOrder[i]->val)\\n            {\\n                int j = n-1;\\n                for(; j >= i; j--)\\n                {if(inOrder[j]->val < inOrder[j-1]->val) break;}\\n                swap(inOrder[j]->val, inOrder[i-1]->val);\\n                break;\\n            }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485362,
                "title": "python3-o-n",
                "content": "```\\n    def inorder(self,root,arr):  # return sorted array of nodes\\n        if not root:\\n            return \\n        self.inorder(root.left,arr)\\n        arr.append(root)\\n        self.inorder(root.right,arr)\\n        return arr\\n    \\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        res = self.inorder(root,[])\\n        n = len(res)\\n                      \\n        a = res[0]      # default 1st wrong value from start\\n        for i in range(1,n):\\n            if res[i].val < res[i-1].val:\\n                a = res[i-1]\\n                break\\n            \\n        b = res[-1]   #default 1st wrong value from end\\n        for i in range(n-2,-1,-1):\\n            if res[i].val > res[i+1].val:\\n                b = res[i+1]\\n                break\\n        a.val,b.val = b.val,a.val       # swap\\n\\t\\t```\\n\\t\\tfeel free to ask Q...\\n\\t\\t#happytohelpu",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def inorder(self,root,arr):  # return sorted array of nodes\\n        if not root:\\n            return \\n        self.inorder(root.left,arr)\\n        arr.append(root)\\n        self.inorder(root.right,arr)\\n        return arr\\n    \\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        res = self.inorder(root,[])\\n        n = len(res)\\n                      \\n        a = res[0]      # default 1st wrong value from start\\n        for i in range(1,n):\\n            if res[i].val < res[i-1].val:\\n                a = res[i-1]\\n                break\\n            \\n        b = res[-1]   #default 1st wrong value from end\\n        for i in range(n-2,-1,-1):\\n            if res[i].val > res[i+1].val:\\n                b = res[i+1]\\n                break\\n        a.val,b.val = b.val,a.val       # swap\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1466323,
                "title": "c-simple-approach",
                "content": "**Please Upvote if you like the Solution!**\\n\\n    TreeNode *prev=NULL,*first=NULL,*second=NULL;\\n    void fixBST(TreeNode* root) \\n    {\\n        if(root==NULL)\\n            return;\\n        fixBST(root->left);\\n        \\n        if(prev!=NULL && root->val<prev->val)\\n        {\\n            if(first==NULL)\\n                first=prev;\\n            second=root;\\n        }\\n        prev=root;\\n        fixBST(root->right);\\n        \\n    }\\n    void recoverTree(TreeNode* root) \\n    {\\n        fixBST(root);\\n        swap(first->val,second->val);\\n    }",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "**Please Upvote if you like the Solution!**\\n\\n    TreeNode *prev=NULL,*first=NULL,*second=NULL;\\n    void fixBST(TreeNode* root) \\n    {\\n        if(root==NULL)\\n            return;\\n        fixBST(root->left);\\n        \\n        if(prev!=NULL && root->val<prev->val)\\n        {\\n            if(first==NULL)\\n                first=prev;\\n            second=root;\\n        }\\n        prev=root;\\n        fixBST(root->right);\\n        \\n    }\\n    void recoverTree(TreeNode* root) \\n    {\\n        fixBST(root);\\n        swap(first->val,second->val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 818965,
                "title": "java-3-different-solutions-morris-traversal-recursive-inorder-traversal-stack",
                "content": "1. main idea is to use inorder traversal because it will keep the order of values.\\n\\nMorris Traversal\\n```\\npublic void recoverTree(TreeNode root) {\\n        TreeNode previous = null;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        // binary tree inorder traversal iteratively\\n        TreeNode parent = null;\\n        TreeNode current = root;\\n        while (current != null) {\\n            if (current.left != null) {\\n                parent = current.left;\\n                while (parent.right != null && parent.right != current) {\\n                    parent = parent.right;\\n                }\\n                if (parent.right == null) {\\n                    parent.right = current;\\n                    current = current.left;\\n                    continue;\\n                } else {\\n                    parent.right = null;\\n                }\\n            }\\n            if (previous != null) {\\n                if (previous.val > current.val) {\\n                    if (first == null) {\\n                        first = previous;\\n                    }\\n                    second = current;\\n                }\\n            }\\n            previous = current;\\n            current = current.right;\\n        }\\n        // swap value\\n        final int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n```\\n\\n2. Recursive Inorder Traversal\\n```\\n public void recoverTree(TreeNode root) {\\n        final List<Integer> values = new ArrayList<>();\\n        final List<TreeNode> treeNodes = new ArrayList<>();\\n        inorderTraversal(root, values, treeNodes);\\n        Collections.sort(values);\\n        for (int i = 0; i < values.size(); i++) {\\n            treeNodes.get(i).val = values.get(i);\\n        }\\n    }\\n\\n    private void inorderTraversal(\\n            TreeNode root,\\n            List<Integer> values,\\n            List<TreeNode> treeNodes\\n    ) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, values, treeNodes);\\n        values.add(root.val);\\n        treeNodes.add(root);\\n        inorderTraversal(root.right, values, treeNodes);\\n    }\\n```\\n3. Stack Iterative Inorder Traversal\\n```\\n    public void recoverTree(TreeNode root) {\\n        TreeNode previous = null;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        // template binary tree inorder traversal iteratively\\n        final Stack<TreeNode> stacks = new Stack<>();\\n        TreeNode current = root;\\n        while (current != null || !stacks.empty()) {\\n            while (current != null) {\\n                stacks.push(current);\\n                current = current.left;\\n            }\\n            current = stacks.pop();\\n            if (previous != null) {\\n                if (previous.val > current.val) {\\n                    if (first == null) {\\n                        first = previous;\\n                    }\\n                    second = current;\\n                }\\n            }\\n            previous = current;\\n            current = current.right;\\n        }\\n        // swap value\\n        final int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void recoverTree(TreeNode root) {\\n        TreeNode previous = null;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        // binary tree inorder traversal iteratively\\n        TreeNode parent = null;\\n        TreeNode current = root;\\n        while (current != null) {\\n            if (current.left != null) {\\n                parent = current.left;\\n                while (parent.right != null && parent.right != current) {\\n                    parent = parent.right;\\n                }\\n                if (parent.right == null) {\\n                    parent.right = current;\\n                    current = current.left;\\n                    continue;\\n                } else {\\n                    parent.right = null;\\n                }\\n            }\\n            if (previous != null) {\\n                if (previous.val > current.val) {\\n                    if (first == null) {\\n                        first = previous;\\n                    }\\n                    second = current;\\n                }\\n            }\\n            previous = current;\\n            current = current.right;\\n        }\\n        // swap value\\n        final int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n```\n```\\n public void recoverTree(TreeNode root) {\\n        final List<Integer> values = new ArrayList<>();\\n        final List<TreeNode> treeNodes = new ArrayList<>();\\n        inorderTraversal(root, values, treeNodes);\\n        Collections.sort(values);\\n        for (int i = 0; i < values.size(); i++) {\\n            treeNodes.get(i).val = values.get(i);\\n        }\\n    }\\n\\n    private void inorderTraversal(\\n            TreeNode root,\\n            List<Integer> values,\\n            List<TreeNode> treeNodes\\n    ) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, values, treeNodes);\\n        values.add(root.val);\\n        treeNodes.add(root);\\n        inorderTraversal(root.right, values, treeNodes);\\n    }\\n```\n```\\n    public void recoverTree(TreeNode root) {\\n        TreeNode previous = null;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        // template binary tree inorder traversal iteratively\\n        final Stack<TreeNode> stacks = new Stack<>();\\n        TreeNode current = root;\\n        while (current != null || !stacks.empty()) {\\n            while (current != null) {\\n                stacks.push(current);\\n                current = current.left;\\n            }\\n            current = stacks.pop();\\n            if (previous != null) {\\n                if (previous.val > current.val) {\\n                    if (first == null) {\\n                        first = previous;\\n                    }\\n                    second = current;\\n                }\\n            }\\n            previous = current;\\n            current = current.right;\\n        }\\n        // swap value\\n        final int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2129607,
                "title": "two-method-with-explanation",
                "content": "**Approch 1  O(N)**\\n1. traverse in inorder you get a sorted element if element is not sorted then mark the two element which are not sorted and swap it \\n2. In the question given only two element are not at it correct  position. you only need to point the two element \\n3. if you do inorder if previous element is greater than current element then you point that element.\\n```\\nclass Solution {\\n    TreeNode first=null, second=null, prev=null;\\n    public void recoverTree(TreeNode root) {\\n        inOrder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    void inOrder(TreeNode root){\\n        if(root==null)return;\\n        inOrder(root.left);\\n        if(prev!=null && prev.val>root.val){\\n            if(first==null)\\n            first=prev;\\n            second=root; \\n        }\\n        prev=root;\\n        inOrder(root.right);\\n    }\\n}\\n```\\n***Approch 2 O(NLOGN)***\\n1. in this approch inorder travese and store the element in the list and then sort the list and then traverse inorder if the list value if diffrent then root.val then store that list element to the root.val\\n```\\nclass Solution {\\n    int i=0;\\n    List <Integer> list;\\n    public void recoverTree(TreeNode root) {\\n        list=new ArrayList<>();\\n        inOrder(root);\\n        Collections.sort(list);\\n        change(root,list);\\n    }\\n    void inOrder(TreeNode root){\\n        if(root==null)return ;\\n        inOrder(root.left);\\n        list.add(root.val);\\n        inOrder(root.right);\\n    }\\n    void change(TreeNode root , List<Integer>list){\\n        if(root==null) return ;\\n        change(root.left,list);\\n        if(list.get(i)!=root.val){\\n           root.val=list.get(i); \\n        }\\n        i++;\\n        change(root.right,list);\\n    }\\n}\\n```\\n**please upvote \\nTHANKYOU***\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode first=null, second=null, prev=null;\\n    public void recoverTree(TreeNode root) {\\n        inOrder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    void inOrder(TreeNode root){\\n        if(root==null)return;\\n        inOrder(root.left);\\n        if(prev!=null && prev.val>root.val){\\n            if(first==null)\\n            first=prev;\\n            second=root; \\n        }\\n        prev=root;\\n        inOrder(root.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int i=0;\\n    List <Integer> list;\\n    public void recoverTree(TreeNode root) {\\n        list=new ArrayList<>();\\n        inOrder(root);\\n        Collections.sort(list);\\n        change(root,list);\\n    }\\n    void inOrder(TreeNode root){\\n        if(root==null)return ;\\n        inOrder(root.left);\\n        list.add(root.val);\\n        inOrder(root.right);\\n    }\\n    void change(TreeNode root , List<Integer>list){\\n        if(root==null) return ;\\n        change(root.left,list);\\n        if(list.get(i)!=root.val){\\n           root.val=list.get(i); \\n        }\\n        i++;\\n        change(root.right,list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963483,
                "title": "c-o-n-time-best-optimized-approach-recursive",
                "content": "Here I am using recusive approach to traverse the BST ;\\nYou can also use stack to traverse both will take same space ,depends on you as you wish ;\\n\\n\\n****upvote if it helps you****\\n\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\n\\tTreeNode*first;\\n    TreeNode*prev;\\n    TreeNode*last;\\n    void inorder(TreeNode*root){\\n        if(root==NULL) return ;\\n        inorder(root->left);\\n        if(prev!=NULL &&  (root->val < prev->val)) {\\n            if(first==NULL) {// this means that this the first voilation of rule;\\n                first = prev;\\n                last = root;\\n            }\\n            else \\n                last = root;    // if this is the second voilation of rule ;\\n        }\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        first = last = prev = NULL;\\n        inorder(root);\\n        if(first && last) swap(first->val, last->val);\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "Here I am using recusive approach to traverse the BST ;\\nYou can also use stack to traverse both will take same space ,depends on you as you wish ;\\n\\n\\n****upvote if it helps you****\\n\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\n\\tTreeNode*first;\\n    TreeNode*prev;\\n    TreeNode*last;\\n    void inorder(TreeNode*root){\\n        if(root==NULL) return ;\\n        inorder(root->left);\\n        if(prev!=NULL &&  (root->val < prev->val)) {\\n            if(first==NULL) {// this means that this the first voilation of rule;\\n                first = prev;\\n                last = root;\\n            }\\n            else \\n                last = root;    // if this is the second voilation of rule ;\\n        }\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        first = last = prev = NULL;\\n        inorder(root);\\n        if(first && last) swap(first->val, last->val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1962655,
                "title": "java-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n     TreeNode prev = null,first=null,second=null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        helper(root);\\n        swap(first,second);\\n        return ;\\n    }\\n    void swap(TreeNode a,TreeNode b)\\n    {\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n      void helper(TreeNode root)\\n    {\\n        if(root == null)\\n            return ;\\n        helper(root.left);\\n        \\n        if(prev!=null &&  prev.val > root.val)\\n        {\\n            if(first == null)\\n            {\\n                first = prev;\\n            }\\n            second = root;\\n        }\\n         \\n        prev = root;\\n        helper(root.right);\\n    }\\n    \\n  \\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n     TreeNode prev = null,first=null,second=null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        helper(root);\\n        swap(first,second);\\n        return ;\\n    }\\n    void swap(TreeNode a,TreeNode b)\\n    {\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n      void helper(TreeNode root)\\n    {\\n        if(root == null)\\n            return ;\\n        helper(root.left);\\n        \\n        if(prev!=null &&  prev.val > root.val)\\n        {\\n            if(first == null)\\n            {\\n                first = prev;\\n            }\\n            second = root;\\n        }\\n         \\n        prev = root;\\n        helper(root.right);\\n    }\\n    \\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962302,
                "title": "python-o-1-space-14-lines-of-code",
                "content": "```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        done = True\\n        def recur(node, not_less_than, not_greater_than):\\n            nonlocal done\\n            if not_less_than and node.val < not_less_than.val:\\n                node.val, not_less_than.val = not_less_than.val, node.val\\n                done = True                \\n            if not_greater_than and node.val > not_greater_than.val:\\n                node.val, not_greater_than.val = not_greater_than.val, node.val\\n                done = True                \\n            if not done and node.left: recur(node.left, not_less_than, node)\\n            if not done and node.right: recur(node.right, node, not_greater_than)\\n        while done:                \\n            done = False\\n            recur(root, None, None)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        done = True\\n        def recur(node, not_less_than, not_greater_than):\\n            nonlocal done\\n            if not_less_than and node.val < not_less_than.val:\\n                node.val, not_less_than.val = not_less_than.val, node.val\\n                done = True                \\n            if not_greater_than and node.val > not_greater_than.val:\\n                node.val, not_greater_than.val = not_greater_than.val, node.val\\n                done = True                \\n            if not done and node.left: recur(node.left, not_less_than, node)\\n            if not done and node.right: recur(node.right, node, not_greater_than)\\n        while done:                \\n            done = False\\n            recur(root, None, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811866,
                "title": "c-clean-concise-inorder-traversal-98-4-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\n    TreeNode *prev=NULL,*first=NULL,*second=NULL;\\n    \\n    void recover(TreeNode* root){\\n        if(root==NULL){\\n            return;\\n        }\\n        recover(root->left);\\n        if(prev!=NULL && root->val < prev->val){\\n            if(first==NULL){\\n                first=prev;\\n            }\\n            second=root;\\n        }\\n        prev=root;\\n        recover(root->right);  \\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        recover(root);  \\n        swap(first->val,second->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    TreeNode *prev=NULL,*first=NULL,*second=NULL;\\n    \\n    void recover(TreeNode* root){\\n        if(root==NULL){\\n            return;\\n        }\\n        recover(root->left);\\n        if(prev!=NULL && root->val < prev->val){\\n            if(first==NULL){\\n                first=prev;\\n            }\\n            second=root;\\n        }\\n        prev=root;\\n        recover(root->right);  \\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        recover(root);  \\n        swap(first->val,second->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548853,
                "title": "c-o-n-solution-preorder-vector",
                "content": "```\\n    void getOrder(TreeNode* root, vector<TreeNode*> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root);\\n        getOrder(root->right, inOrder);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inOrder;\\n        getOrder(root, inOrder);\\n        int n = inOrder.size();\\n        \\n        for(int i = 1; i < n; i++) // Just swap the 2 values which are not in Order \\n            if(inOrder[i-1]->val > inOrder[i]->val)\\n            {\\n                int j = n-1;\\n                for(; j >= i; j--)\\n                {if(inOrder[j]->val < inOrder[j-1]->val) break;}\\n                swap(inOrder[j]->val, inOrder[i-1]->val);\\n                break;\\n            }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void getOrder(TreeNode* root, vector<TreeNode*> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root);\\n        getOrder(root->right, inOrder);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inOrder;\\n        getOrder(root, inOrder);\\n        int n = inOrder.size();\\n        \\n        for(int i = 1; i < n; i++) // Just swap the 2 values which are not in Order \\n            if(inOrder[i-1]->val > inOrder[i]->val)\\n            {\\n                int j = n-1;\\n                for(; j >= i; j--)\\n                {if(inOrder[j]->val < inOrder[j-1]->val) break;}\\n                swap(inOrder[j]->val, inOrder[i-1]->val);\\n                break;\\n            }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1306519,
                "title": "c-recursion-o-1-memory",
                "content": "class Solution {\\n\\n\\t TreeNode *first=NULL,*second=NULL,*prev=NULL;   \\n    public:\\n    void fix(TreeNode *root){\\n        if(!root) return;\\n        fix(root->left);\\n        \\n        if(prev && root->val<prev->val){\\n            if(!first) first=prev;\\n            second=root;\\n        }\\n        \\n        prev=root;\\n        fix(root->right);\\n    }\\n    \\n    void recoverTree(TreeNode *root) {\\n        fix(root);\\n        swap(first->val,second->val);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n\\t TreeNode *first=NULL,*second=NULL,*prev=NULL;   \\n    public:\\n    void fix(TreeNode *root){\\n        if(!root) return;\\n        fix(root->left);\\n        \\n        if(prev && root->val<prev->val){\\n            if(!first) first=prev;\\n            second=root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 917307,
                "title": "java-dfs-comments",
                "content": "If you liked this solution, please upvote it\\n\\n```\\nclass Solution {\\n    TreeNode x, y, prev;\\n    public void recoverTree(TreeNode root) {\\n        if (root == null) return;\\n\\t\\t// first find x and y\\n        find(root);\\n\\t\\t// then swap\\n        swap(x, y);\\n    }\\n\\t\\t\\n\\t// goind to the end on left\\n    // looking for the first node, which val is greater than parent (left > root)\\n\\t// if will be writen to X\\n\\t// Then from top to bottom checking for the next value\\n\\t// in this case parent (prev) value should be greater than next; (root > right)\\n    public void find(TreeNode root) {\\n        if (root == null) return;\\n        find(root.left);\\n\\t\\tif (prev != null && prev.val > root.val) {\\n            y = root;\\n            if (x == null) {\\n                x = prev;\\n            } else {\\n                return;\\n            }\\n        }\\n        prev = root;\\n        find(root.right);\\n    }\\n    \\n    private void swap(TreeNode one, TreeNode two) {\\n        int tmp = one.val;\\n        one.val = two.val;\\n        two.val = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode x, y, prev;\\n    public void recoverTree(TreeNode root) {\\n        if (root == null) return;\\n\\t\\t// first find x and y\\n        find(root);\\n\\t\\t// then swap\\n        swap(x, y);\\n    }\\n\\t\\t\\n\\t// goind to the end on left\\n    // looking for the first node, which val is greater than parent (left > root)\\n\\t// if will be writen to X\\n\\t// Then from top to bottom checking for the next value\\n\\t// in this case parent (prev) value should be greater than next; (root > right)\\n    public void find(TreeNode root) {\\n        if (root == null) return;\\n        find(root.left);\\n\\t\\tif (prev != null && prev.val > root.val) {\\n            y = root;\\n            if (x == null) {\\n                x = prev;\\n            } else {\\n                return;\\n            }\\n        }\\n        prev = root;\\n        find(root.right);\\n    }\\n    \\n    private void swap(TreeNode one, TreeNode two) {\\n        int tmp = one.val;\\n        one.val = two.val;\\n        two.val = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660186,
                "title": "worst-sol-ever",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    void recoverTree(TreeNode* root) {\\n     sol1(root);\\n        sort(v.begin(),v.end());\\n       sol2(root);\\n    }\\n    void sol1(TreeNode* n){\\n        if(!n)return;\\n        sol1(n->left);\\n        v.push_back(n->val);\\n        sol1(n->right);\\n    }\\n     void sol2(TreeNode* n){\\n         if(!n) return;\\n         sol2(n->left);\\n         n->val=v[i++];\\n         sol2(n->right);\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    void recoverTree(TreeNode* root) {\\n     sol1(root);\\n        sort(v.begin(),v.end());\\n       sol2(root);\\n    }\\n    void sol1(TreeNode* n){\\n        if(!n)return;\\n        sol1(n->left);\\n        v.push_back(n->val);\\n        sol1(n->right);\\n    }\\n     void sol2(TreeNode* n){\\n         if(!n) return;\\n         sol2(n->left);\\n         n->val=v[i++];\\n         sol2(n->right);\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338595,
                "title": "python-solution-with-comments-faster-than-99",
                "content": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n    # Idea: During in-order traversal, we keep checking that whether a node\\'s value is strictly larger than it\\'s predecessor\\'s value. If not, then abnormal nodes exist in the position.\\n        \\n        self.first, self.second, self.prev = None, None, TreeNode(float(\\'-inf\\'))\\n\\n        def inorder(node):\\n            if node:\\n                inorder(node.left)\\n                # find the abnormity -- self.prev.val >= node.val\\n                if self.prev.val >= node.val:\\n                    # When we find the first abnormal node first,\\n                    # we need to record the second one at the same time.\\n                    # When the first one is already found, we only need to update the second one\\n                    if not self.first:\\n                        self.first = self.prev\\n                    self.second = node\\n                self.prev = node  # prev is the pointer traversing the whole tree in in-order\\n                inorder(node.right)\\n\\n        inorder(root)\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n```\\n\\n- time complexity O(n)\\n- space complexity O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n    # Idea: During in-order traversal, we keep checking that whether a node\\'s value is strictly larger than it\\'s predecessor\\'s value. If not, then abnormal nodes exist in the position.\\n        \\n        self.first, self.second, self.prev = None, None, TreeNode(float(\\'-inf\\'))\\n\\n        def inorder(node):\\n            if node:\\n                inorder(node.left)\\n                # find the abnormity -- self.prev.val >= node.val\\n                if self.prev.val >= node.val:\\n                    # When we find the first abnormal node first,\\n                    # we need to record the second one at the same time.\\n                    # When the first one is already found, we only need to update the second one\\n                    if not self.first:\\n                        self.first = self.prev\\n                    self.second = node\\n                self.prev = node  # prev is the pointer traversing the whole tree in in-order\\n                inorder(node.right)\\n\\n        inorder(root)\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111021,
                "title": "o-n-space-c-solution",
                "content": "```\\n  void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> nodes;\\n        vector<int> vals;\\n        \\n        inorder(root, nodes, vals);\\n        sort(vals.begin(), vals.end());\\n        for (int i = 0; i < vals.size(); i++)\\n            nodes[i]->val = vals[i];\\n    }\\n    \\n    void inorder(TreeNode* root, vector<TreeNode*>& nodes, vector<int>& vals) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left, nodes, vals);\\n        nodes.push_back(root);\\n        vals.push_back(root->val);\\n        inorder(root->right, nodes, vals);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> nodes;\\n        vector<int> vals;\\n        \\n        inorder(root, nodes, vals);\\n        sort(vals.begin(), vals.end());\\n        for (int i = 0; i < vals.size(); i++)\\n            nodes[i]->val = vals[i];\\n    }\\n    \\n    void inorder(TreeNode* root, vector<TreeNode*>& nodes, vector<int>& vals) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left, nodes, vals);\\n        nodes.push_back(root);\\n        vals.push_back(root->val);\\n        inorder(root->right, nodes, vals);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32609,
                "title": "4ms-java-solution",
                "content": "    public class Solution {\\n        \\n         TreeNode first = null, second = null, pre = null;\\n        public void recoverTree(TreeNode root) {\\n            if(root==null)return;\\n            dfs(root);\\n            if(first!=null&&second!=null){\\n                int temp = first.val;\\n                first.val = second.val;\\n                second.val = temp;\\n            }\\n            \\n        }\\n        public void  dfs(TreeNode root){\\n            if(root.left!=null)dfs(root.left);\\n            if(pre!=null&&pre.val>root.val)\\n                {\\n                    if(first==null) first = pre;\\n                    if(first!=null)second = root;\\n                }\\n            pre = root;\\n            if(root.right!=null)dfs(root.right);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n         TreeNode first = null, second = null, pre = null;\\n        public void recoverTree(TreeNode root) {\\n            if(root==null)return;\\n            dfs(root);\\n            if(first!=null&&second!=null){\\n                int temp = first.val;\\n                first.val = second.val;\\n                second.val = temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 32617,
                "title": "18-line-of-cpp-solution-48ms-dfs",
                "content": "    class Solution {\\n    public:\\n        TreeNode* errorNodes[3];\\n        TreeNode* preNode = NULL;\\n        int found = 0;\\n    \\n        void dfs(TreeNode* node) {\\n            if (NULL != node->left) dfs(node->left);\\n            if (NULL != preNode) {\\n                if (preNode->val > node->val){\\n                    errorNodes[found] = preNode;\\n                    errorNodes[++found] = node;\\n                }\\n            }\\n            preNode = node;\\n            if (NULL != node->right && found <= 1) dfs(node->right);\\n        }\\n    \\n        void recoverTree(TreeNode* root) {\\n            dfs(root);\\n            if (0 != found) swap(errorNodes[0]->val, errorNodes[found]->val);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* errorNodes[3];\\n        TreeNode* preNode = NULL;\\n        int found = 0;\\n    \\n        void dfs(TreeNode* node) {\\n            if (NULL != node->left) dfs(node->left);\\n            if (NULL != preNode) {\\n                if (preNode->val > node->val){\\n                    errorNodes[found] = preNode;\\n                    errorNodes[++found] = node;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3516912,
                "title": "easy-c-solution-using-inorder-traversal",
                "content": "\\n# Approach\\nPLS UPVOTE IF YOU FIND THE SOLUTION EASY \\uD83D\\uDE09\\uD83D\\uDE09 \\nusing Inorder traversal , it can be done but dont use a vector to store the elements but keep 2 pointer so that at end u can swap them   \\nNow lets see.\\n1)Take 3 pointer prev ,start, end and intialize them with null  \\n2)Make a inorder function and the pointers  and the root \\n3)For the first iteration prev,will be null so put it at last after  the condition check \\n4)2nd iteration onwards prev wont be null so now check if first is null if yes then first will be prev and end will be root and then prev will be root \\n5)If everything goes according to the plan then first can be changed only one time when first is null\\nsame\\xA0for\\xA0the\\xA0second\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& end) {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        // AS IN INORDER TRAVERSAL LNR SO LEFT TRAVERSAL WILL TAKE PLACE\\n        inorder(root->left, prev, first, end);\\n        if (prev!=NULL) \\n        {\\n            if (root->val < prev->val)\\n            {\\n                if(first==NULL)\\n                {\\n                    first = prev;\\n                }\\n            end = root;\\n            }\\n        }\\n        prev = root;\\n        inorder(root->right, prev, first, end);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr, *first = nullptr, *end = nullptr;\\n        inorder(root, prev, first, end);\\n        swap(first->val, end->val);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& end) {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        // AS IN INORDER TRAVERSAL LNR SO LEFT TRAVERSAL WILL TAKE PLACE\\n        inorder(root->left, prev, first, end);\\n        if (prev!=NULL) \\n        {\\n            if (root->val < prev->val)\\n            {\\n                if(first==NULL)\\n                {\\n                    first = prev;\\n                }\\n            end = root;\\n            }\\n        }\\n        prev = root;\\n        inorder(root->right, prev, first, end);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr, *first = nullptr, *end = nullptr;\\n        inorder(root, prev, first, end);\\n        swap(first->val, end->val);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433687,
                "title": "java-100-faster-solution-using-inorder-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(log N) or O(H)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/f174fa1b-9f48-4193-9faf-7ca6c8884de1_1681883532.8229592.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private TreeNode first;   // The first node that violates the BST property\\n    private TreeNode middle;  // The middle node that violates the BST property\\n    private TreeNode last;    // The last node that violates the BST property\\n    private TreeNode prev;    // The previous node during the inorder traversal\\n\\n    public void inorder(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n\\n        // Traverse the left subtree\\n        inorder(root.left);\\n\\n        // Check if the current node violates the BST property\\n        if(prev != null && (root.val < prev.val)){\\n            // If this is the first time we\\'ve found a violation,\\n            // set first and middle to the nodes that violate the BST property\\n            if(first == null){\\n                first = prev;\\n                middle = root;\\n            }\\n            // If we\\'ve already found a violation, set last to the node that violates the BST property\\n            else{\\n                last = root;\\n            }\\n        }\\n        // Set prev to the current node, so that we can compare it to the next node\\n        prev = root;\\n\\n        // Traverse the right subtree\\n        inorder(root.right);\\n    }\\n\\n    public void recoverTree(TreeNode root) {\\n        // Initialize the variables\\n        first = middle = last = null;\\n        // Initialize prev to a node with the minimum possible value, so that it will not violate the BST property\\n        prev = new TreeNode(Integer.MIN_VALUE);\\n\\n        // Perform an inorder traversal of the tree\\n        inorder(root);\\n\\n        // Swap the values of the nodes that violate the BST property, if any\\n        if(first != null && last != null){\\n            // If there are two nodes that violate the BST property,\\n            // and they are not adjacent to each other, swap the values of the first and last nodes\\n            int temp = first.val;\\n            first.val = last.val;\\n            last.val = temp;\\n        }\\n        else if(first != null && middle != null){\\n            // If there are two nodes that violate the BST property,\\n            // and they are adjacent to each other, swap the values of the first and middle nodes\\n            int temp = first.val;\\n            first.val = middle.val;\\n            middle.val = temp;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private TreeNode first;   // The first node that violates the BST property\\n    private TreeNode middle;  // The middle node that violates the BST property\\n    private TreeNode last;    // The last node that violates the BST property\\n    private TreeNode prev;    // The previous node during the inorder traversal\\n\\n    public void inorder(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n\\n        // Traverse the left subtree\\n        inorder(root.left);\\n\\n        // Check if the current node violates the BST property\\n        if(prev != null && (root.val < prev.val)){\\n            // If this is the first time we\\'ve found a violation,\\n            // set first and middle to the nodes that violate the BST property\\n            if(first == null){\\n                first = prev;\\n                middle = root;\\n            }\\n            // If we\\'ve already found a violation, set last to the node that violates the BST property\\n            else{\\n                last = root;\\n            }\\n        }\\n        // Set prev to the current node, so that we can compare it to the next node\\n        prev = root;\\n\\n        // Traverse the right subtree\\n        inorder(root.right);\\n    }\\n\\n    public void recoverTree(TreeNode root) {\\n        // Initialize the variables\\n        first = middle = last = null;\\n        // Initialize prev to a node with the minimum possible value, so that it will not violate the BST property\\n        prev = new TreeNode(Integer.MIN_VALUE);\\n\\n        // Perform an inorder traversal of the tree\\n        inorder(root);\\n\\n        // Swap the values of the nodes that violate the BST property, if any\\n        if(first != null && last != null){\\n            // If there are two nodes that violate the BST property,\\n            // and they are not adjacent to each other, swap the values of the first and last nodes\\n            int temp = first.val;\\n            first.val = last.val;\\n            last.val = temp;\\n        }\\n        else if(first != null && middle != null){\\n            // If there are two nodes that violate the BST property,\\n            // and they are adjacent to each other, swap the values of the first and middle nodes\\n            int temp = first.val;\\n            first.val = middle.val;\\n            middle.val = temp;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963163,
                "title": "two-approaches-easy-understanding-solution",
                "content": "# BY TWO METHODS\\n**In O(n) Space**\\n```\\n//Please upvote if you like my solution :)\\nvoid solve(TreeNode* root,vector<TreeNode*> &inf){\\n        if(!root) return;\\n        solve(root->left,inf);\\n        inf.push_back(root);\\n        solve(root->right,inf);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inf;\\n        solve(root,inf);\\n        TreeNode* first, *second;\\n        for(int i=0;i<inf.size()-1;i++){\\n            if(inf[i]->val > inf[i+1]->val){\\n                first = inf[i];\\n                break;\\n            }\\n        }\\n        for(int i=inf.size()-1;i>=0;i--){\\n            if(inf[i]->val < first->val){\\n                second = inf[i];\\n                break;\\n            }\\n        }\\n        swap(first->val,second->val);\\n    }\\n```\\n**In O(1) Space**\\n```\\n//Please upvote if you like my solution :)\\nvoid inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        if(root->val < prev->val){\\n            if(!first){\\n                first = prev;\\n                middle = root;\\n            }else{\\n                last = root;\\n            }\\n        }\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    TreeNode* first, *last , *middle , *prev;\\n    void recoverTree(TreeNode* root) {\\n        first = last = middle = NULL;\\n        prev = new TreeNode(INT_MIN);\\n        inorder(root);\\n        if(!last) swap(first->val,middle->val);\\n        else swap(first->val,last->val);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n//Please upvote if you like my solution :)\\nvoid solve(TreeNode* root,vector<TreeNode*> &inf){\\n        if(!root) return;\\n        solve(root->left,inf);\\n        inf.push_back(root);\\n        solve(root->right,inf);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inf;\\n        solve(root,inf);\\n        TreeNode* first, *second;\\n        for(int i=0;i<inf.size()-1;i++){\\n            if(inf[i]->val > inf[i+1]->val){\\n                first = inf[i];\\n                break;\\n            }\\n        }\\n        for(int i=inf.size()-1;i>=0;i--){\\n            if(inf[i]->val < first->val){\\n                second = inf[i];\\n                break;\\n            }\\n        }\\n        swap(first->val,second->val);\\n    }\\n```\n```\\n//Please upvote if you like my solution :)\\nvoid inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        if(root->val < prev->val){\\n            if(!first){\\n                first = prev;\\n                middle = root;\\n            }else{\\n                last = root;\\n            }\\n        }\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    TreeNode* first, *last , *middle , *prev;\\n    void recoverTree(TreeNode* root) {\\n        first = last = middle = NULL;\\n        prev = new TreeNode(INT_MIN);\\n        inorder(root);\\n        if(!last) swap(first->val,middle->val);\\n        else swap(first->val,last->val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1476690,
                "title": "c-use-inorder-traversal",
                "content": "```\\nTreeNode *node_1 = NULL, *node_2 = NULL, *prev = NULL;\\n\\nvoid recoverTree(TreeNode* root) {\\n    // write your code here\\n    if (root == NULL) return;\\n    \\n    inorder(root);\\n    if (node_1 && node_2)\\n        swap(node_1->val, node_2->val);\\n}\\n\\nvoid inorder(TreeNode *root) {\\n    if (root == NULL) return;\\n    inorder(root->left);\\n    if (prev != NULL && root->val < prev->val) {\\n        if (node_1 == NULL) {\\n            node_1 = prev;\\n        } \\n        if (node_1 != NULL) {\\n            node_2 = root;\\n        }\\n    }\\n    prev = root;\\n    inorder(root->right);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTreeNode *node_1 = NULL, *node_2 = NULL, *prev = NULL;\\n\\nvoid recoverTree(TreeNode* root) {\\n    // write your code here\\n    if (root == NULL) return;\\n    \\n    inorder(root);\\n    if (node_1 && node_2)\\n        swap(node_1->val, node_2->val);\\n}\\n\\nvoid inorder(TreeNode *root) {\\n    if (root == NULL) return;\\n    inorder(root->left);\\n    if (prev != NULL && root->val < prev->val) {\\n        if (node_1 == NULL) {\\n            node_1 = prev;\\n        } \\n        if (node_1 != NULL) {\\n            node_2 = root;\\n        }\\n    }\\n    prev = root;\\n    inorder(root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917661,
                "title": "java-recover-bst-100-well-explained",
                "content": "\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n \\n    private TreeNode prev, node1, node2;\\n\\t //for a BST inorder traversal returns an increasing order, we keep a track of previous value and do inorder, if any value is smaller than prev, than we need to swap it with other similar value\\n  //since only 2 nodes were swapped this works\\n  \\n    public void recoverTree(TreeNode root) {\\n      inOrder(root);\\n      int temp = node2.val;\\n      node2.val = node1.val;\\n      node1.val = temp;\\n    }\\n  \\n  private void inOrder(TreeNode root){\\n    if(root==null)\\n      return;\\n\\n      inOrder(root.left);\\n      if(prev!=null && prev.val>root.val){\\n\\t  \\n        if(node1==null)\\n          node1 = prev;\\n        node2 = root;\\n      }\\n      prev = root;\\n      inOrder(root.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n \\n    private TreeNode prev, node1, node2;\\n\\t //for a BST inorder traversal returns an increasing order, we keep a track of previous value and do inorder, if any value is smaller than prev, than we need to swap it with other similar value\\n  //since only 2 nodes were swapped this works\\n  \\n    public void recoverTree(TreeNode root) {\\n      inOrder(root);\\n      int temp = node2.val;\\n      node2.val = node1.val;\\n      node1.val = temp;\\n    }\\n  \\n  private void inOrder(TreeNode root){\\n    if(root==null)\\n      return;\\n\\n      inOrder(root.left);\\n      if(prev!=null && prev.val>root.val){\\n\\t  \\n        if(node1==null)\\n          node1 = prev;\\n        node2 = root;\\n      }\\n      prev = root;\\n      inOrder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531700,
                "title": "python-3-recursive-o-n",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        nodes = []\\n        values = []\\n        self.inorder(root, nodes, values)\\n        values.sort()\\n        for i in range(len(nodes)):\\n            nodes[i].val = values[i]\\n        \\n    def inorder(self, root, nodes, values):\\n        if root:\\n            self.inorder(root.left, nodes, values)\\n            nodes.append(root)\\n            values.append(root.val)\\n            self.inorder(root.right, nodes, values)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        nodes = []\\n        values = []\\n        self.inorder(root, nodes, values)\\n        values.sort()\\n        for i in range(len(nodes)):\\n            nodes[i].val = values[i]\\n        \\n    def inorder(self, root, nodes, values):\\n        if root:\\n            self.inorder(root.left, nodes, values)\\n            nodes.append(root)\\n            values.append(root.val)\\n            self.inorder(root.right, nodes, values)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231800,
                "title": "python-solution",
                "content": "Idea: We use the property that the inorder traversal of a BST is increasing. If two elements of a BST are swapped, then we can use inorder traversal to detect the two points where the increasing property breaks down. \\n\\nWe illustrate the algorithm with an example:\\n\\nSuppose the inorder traversal of a BST is the following: `[1,3,8,6,7,5,10]`. We initialize two pointers `left = None`, and `right = None` to denote the two elements that have been swapped. We use a pointer `trav` to denote the current node we are visiting during the traversal, and a pointer `prev` to denote the previous node. Suppose `prev.val > trav.val`, and `left == None`, (in this example, `prev.val = 8`, `trav.val = 6`) it means that we are at the first point where the increasing property breaks down. We assign `left = prev`, and another pointer `curr = trav` to record the current node. We continue with our tree traversal, and suppose  we are again in the scenario where `prev.val > trav.val`, but this time, `left != None`, (in this example, `prev.val = 7`, `trav.val = 5`) it means that we are at the second point where the increasing property breaks down. We assign `right = trav`. Finally, we swap the value of `left` and `right`: `left.val, right.val == right.val, left.val`.\\n\\nOne caveat is that, after the tree traversal, it might happen that `right` is still `None`. This happens whenever the two elements swapped are right next to each other. For example, if the inorder traversal of a tree yields `[1,3,5,7,6,8,10]`. Then after the traversal, we will find that `left.val = 7`, `curr.val = 6`, `right = None`. In this case, we just need to swap the value of `left` and `curr`: `left.val, curr.val = curr.val, left.val`. \\n\\nTime complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        trav = root\\n        prev = None\\n        left = None\\n        right = None\\n        while stack or trav:\\n            if trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            else:\\n                u = stack.pop()\\n                if prev and prev.val > u.val:\\n                    if not left:\\n                        left = prev\\n                        curr = u\\n                    else:\\n                        right = u\\n                prev = u\\n                trav = u.right\\n        if right:\\n            left.val, right.val = right.val, left.val\\n        else:\\n            left.val, curr.val = curr.val, left.val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        trav = root\\n        prev = None\\n        left = None\\n        right = None\\n        while stack or trav:\\n            if trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            else:\\n                u = stack.pop()\\n                if prev and prev.val > u.val:\\n                    if not left:\\n                        left = prev\\n                        curr = u\\n                    else:\\n                        right = u\\n                prev = u\\n                trav = u.right\\n        if right:\\n            left.val, right.val = right.val, left.val\\n        else:\\n            left.val, curr.val = curr.val, left.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32530,
                "title": "std-cout-influence-test-result",
                "content": "The following cpp code can pass a specific test case\\n```\\n...\\nTreeNode *now;\\n...\\nwhile (now != NULL) {\\n...\\n}\\n```\\nLater I add a std::cout like this:\\n```\\n...\\nTreeNode *now;\\n...\\nwhile (now != NULL) {\\nstd::cout << now->val << std::endl;\\n...\\n}\\n```\\nSurprisingly,  the result, or the structure of the tree changed. It seems that std::cout influenced result, because if I annotate the line, the result will come back to an expected one. \\nMaybe something is wrong with pointers causing a memory pollution. Maybe the compiler misunderstood my code while optimizing it. But I can't understand how std::cout did it?",
                "solutionTags": [],
                "code": "```\\n...\\nTreeNode *now;\\n...\\nwhile (now != NULL) {\\n...\\n}\\n```\n```\\n...\\nTreeNode *now;\\n...\\nwhile (now != NULL) {\\nstd::cout << now->val << std::endl;\\n...\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 32637,
                "title": "javascript-solution-with-inorder-traversal",
                "content": "    var recoverTree = function(root) {\\n      var node1, node2;\\n      var prev = new TreeNode(-Number.MAX_VALUE);\\n      traverse(root);\\n      var tmp = node1.val;\\n      node1.val = node2.val;\\n      node2.val = tmp;\\n      function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        if (node.val < prev.val) {\\n          node2 = node;\\n          if (!node1) node1 = prev;\\n        }\\n        prev = node;\\n        traverse(node.right);\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var recoverTree = function(root) {\\n      var node1, node2;\\n      var prev = new TreeNode(-Number.MAX_VALUE);\\n      traverse(root);\\n      var tmp = node1.val;\\n      node1.val = node2.val;\\n      node2.val = tmp;\\n      function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        if (node.val < prev.val) {\\n          node2 = node;\\n          if (!node1) node1 = prev;\\n        }\\n        prev = node;\\n        traverse(node.right);\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 32614,
                "title": "a-concise-java-solution-using-morris-inorder-o-n-time-o-1-space",
                "content": "    public class Solution {\\n        public void recoverTree(TreeNode root) {\\n            TreeNode first = null, second = null;\\n            TreeNode pre = new TreeNode(Integer.MIN_VALUE);\\n            while (root != null)\\n            {\\n                if (root.left != null)\\n                {\\n                    TreeNode p = root.left;\\n                    while (p.right != null && p.right != root)\\n                        p = p.right;\\n                    if (p.right == null)\\n                    {\\n                        p.right = root;\\n                        root = root.left;\\n                        continue;\\n                    }\\n                    else\\n                        p.right = null;\\n                }\\n                if (root.val < pre.val)\\n                {\\n                    if (first == null)\\n                    {\\n                        first = pre;\\n                    }\\n                    second = root;\\n                }\\n                pre = root;\\n                root = root.right;\\n            }\\n            int tmp = first.val;\\n            first.val = second.val;\\n            second.val = tmp;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void recoverTree(TreeNode root) {\\n            TreeNode first = null, second = null;\\n            TreeNode pre = new TreeNode(Integer.MIN_VALUE);\\n            while (root != null)\\n            {\\n                if (root.left != null)\\n                {\\n                    TreeNode p = root.left;\\n                    while (p.right != null && p.right != root)\\n                        p = p.right;\\n                    if (p.right == null)\\n                    {\\n                        p.right = root;\\n                        root = root.left;\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3554734,
                "title": "morris-traversal-o-1-s-c-c-code-with-explanation",
                "content": "# Please Do Upvote if it\\'s helpful \\n\\n# Intuition\\n* As we know the inorder traversal of a bst gives the nodes in sorted order and in this only two nodes aren\\'t in their sorted pos.\\n* We will find them and swap their values.\\n* We will use Morris Trversal for inorder to solve this problem.\\n* Morris Traversal will reduce the space complexity to O(1).\\n\\n\\n# Approach\\n\\n* Here we can see 2 cases\\n* *Case-1:* The swapped nodes aren\\'t adjacents.\\n    - eg: here is the inorder of a bst: `3 25 7 8 10 15 5`. See the node `25` and `5` are swapped and they aren\\'t adjacents.\\n* *Case-2:* The swapped nodes are adjacents.\\n    - eg: here is the inorder of a bst: `3 5 8 7 10 15 25`. See the node `8` and `7` are swapped and they are adjacents.\\n\\n* We will take 3 pointers first,mid and last.\\n* first will point to the node which violates the sorted condition first.\\n* mid will point to the next node of first (in inorder traversal).\\n* last will point to the node which violates the sorted condition second.\\n\\n* we will take another pointer prev which will point the last visited node in inorder.\\n* everytime we need to check if the curr node\\'s val is less than it\\'s prev node\\'s value or not if yes then the node violates the sorted condition.\\n\\n* In case-2 the sorted condition gets violated only 1 time. So the last pointer will be null in this case. So we will swap the first and middle.\\n* In case-1 the sorted condition gets violated 2 times so none of the 3 pointers will be null. So here we will swap first and last.\\n\\n---\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *first,*mid,*last,*prev;\\n        first=mid=last=nullptr;\\n        prev=new TreeNode(INT_MIN);\\n        TreeNode *curr=root;\\n        while(curr){\\n            if(!curr->left){ // left was done and we are at curr node\\n                // curr node is less than it\\'s inorder predecessor (not folllowing sorted conditi[[[[[[[[[[[[]()]()]()]()]()]()]()]()]()]()]()]()on)\\n                if(curr->val<prev->val){\\n                    // condition gets violated for the first time\\n                    if(!first){\\n                        first=prev;\\n                        mid=curr;\\n                    }\\n                    else last=curr;\\n                }\\n                prev=curr;\\n                curr=curr->right;\\n            }\\n            else{\\n                TreeNode *now=curr->left;\\n                while(now->right && now->right!=curr)\\n                    now=now->right;\\n                if(!now->right){\\n                    now->right=curr;\\n                    curr=curr->left;\\n                }\\n                else{\\n                    now->right=nullptr;\\n                    if(curr->val<prev->val){\\n                        if(!first){\\n                            first=prev;\\n                            mid=curr;\\n                        }\\n                        else last=curr;\\n                    }\\n                    prev=curr;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        if(!last) swap(first->val,mid->val); // Case-2\\n        else swap(first->val,last->val); // Case-1\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *first,*mid,*last,*prev;\\n        first=mid=last=nullptr;\\n        prev=new TreeNode(INT_MIN);\\n        TreeNode *curr=root;\\n        while(curr){\\n            if(!curr->left){ // left was done and we are at curr node\\n                // curr node is less than it\\'s inorder predecessor (not folllowing sorted conditi[[[[[[[[[[[[]()]()]()]()]()]()]()]()]()]()]()]()on)\\n                if(curr->val<prev->val){\\n                    // condition gets violated for the first time\\n                    if(!first){\\n                        first=prev;\\n                        mid=curr;\\n                    }\\n                    else last=curr;\\n                }\\n                prev=curr;\\n                curr=curr->right;\\n            }\\n            else{\\n                TreeNode *now=curr->left;\\n                while(now->right && now->right!=curr)\\n                    now=now->right;\\n                if(!now->right){\\n                    now->right=curr;\\n                    curr=curr->left;\\n                }\\n                else{\\n                    now->right=nullptr;\\n                    if(curr->val<prev->val){\\n                        if(!first){\\n                            first=prev;\\n                            mid=curr;\\n                        }\\n                        else last=curr;\\n                    }\\n                    prev=curr;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        if(!last) swap(first->val,mid->val); // Case-2\\n        else swap(first->val,last->val); // Case-1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280265,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector <int> nodes;\\n    int i = 0;\\nprivate:\\n    void traversal(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        traversal(root->left, nodes);\\n        nodes.push_back(root->val);\\n        traversal(root->right, nodes);    \\n    }\\n    void inorder(TreeNode* root, vector <int> nodes, int& i) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left, nodes, i);\\n        if (root->val != nodes[i])\\n            root->val = nodes[i];\\n        i++;    \\n        inorder(root->right, nodes, i);    \\n    }        \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        traversal(root, nodes);\\n        sort(nodes.begin(), nodes.end());\\n        inorder(root, nodes, i);\\n    }\\n};\\n```\\n\\n# Approach 2\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    TreeNode* prev = new TreeNode(INT_MIN);\\n    TreeNode* first = NULL;\\n    TreeNode* middle = NULL;\\n    TreeNode* last = NULL;\\nprivate:\\n    void inorder(TreeNode* root) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left);\\n        if (prev->val > root->val) {\\n            if (first == NULL) {\\n                first = prev;\\n                middle = root;\\n            } else {\\n                last = root;\\n            }\\n        }  \\n        prev = root; \\n        inorder(root->right);    \\n    }        \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        if (last != NULL)\\n            swap(first->val, last->val);\\n        else\\n            swap(first->val, middle->val);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector <int> nodes;\\n    int i = 0;\\nprivate:\\n    void traversal(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        traversal(root->left, nodes);\\n        nodes.push_back(root->val);\\n        traversal(root->right, nodes);    \\n    }\\n    void inorder(TreeNode* root, vector <int> nodes, int& i) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left, nodes, i);\\n        if (root->val != nodes[i])\\n            root->val = nodes[i];\\n        i++;    \\n        inorder(root->right, nodes, i);    \\n    }        \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        traversal(root, nodes);\\n        sort(nodes.begin(), nodes.end());\\n        inorder(root, nodes, i);\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    TreeNode* prev = new TreeNode(INT_MIN);\\n    TreeNode* first = NULL;\\n    TreeNode* middle = NULL;\\n    TreeNode* last = NULL;\\nprivate:\\n    void inorder(TreeNode* root) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left);\\n        if (prev->val > root->val) {\\n            if (first == NULL) {\\n                first = prev;\\n                middle = root;\\n            } else {\\n                last = root;\\n            }\\n        }  \\n        prev = root; \\n        inorder(root->right);    \\n    }        \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        if (last != NULL)\\n            swap(first->val, last->val);\\n        else\\n            swap(first->val, middle->val);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992577,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* first=NULL;\\n    TreeNode* sec=NULL;\\n    TreeNode* prev=NULL;\\n    void dfs(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n        dfs(root->left);\\n        if(prev && prev->val>root->val)\\n        {\\n            if(first==NULL)\\n            first=prev;\\n            sec=root;\\n        }\\n        prev=root;\\n        dfs(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        dfs(root);\\n        int t=first->val;\\n        first->val=sec->val;\\n        sec->val=t;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* first=NULL;\\n    TreeNode* sec=NULL;\\n    TreeNode* prev=NULL;\\n    void dfs(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n        dfs(root->left);\\n        if(prev && prev->val>root->val)\\n        {\\n            if(first==NULL)\\n            first=prev;\\n            sec=root;\\n        }\\n        prev=root;\\n        dfs(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        dfs(root);\\n        int t=first->val;\\n        first->val=sec->val;\\n        sec->val=t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892538,
                "title": "easy-to-understand",
                "content": "\\n\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        inorder_nodes = []\\n        def inorder(root):\\n            if root:\\n                inorder(root.left)\\n                inorder_nodes.append(root)\\n                inorder(root.right)\\n                 \\n        inorder(root)\\n        sorted_nodes = sorted(inorder_nodes, key = lambda x: x.val)\\n        \\n        wrong = []\\n        for (i, node) in enumerate(sorted_nodes):\\n            if inorder_nodes[i].val != node.val:\\n                wrong.append(node)\\n                \\n        wrong[0].val, wrong[1].val = wrong[1].val, wrong[0].val\\n```\\n\\nThe time complexity of this solution is O(n log n), where n is the number of nodes in the tree. This is because the DFS traversal takes O(n) time, and sorting the keys in the dictionary takes O(n log n) time.\\n\\nThe space complexity of this solution is O(n), where n is the number of nodes in the tree. This is because the nodes dictionary and the sorted_keys list both take up O(n) space.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        inorder_nodes = []\\n        def inorder(root):\\n            if root:\\n                inorder(root.left)\\n                inorder_nodes.append(root)\\n                inorder(root.right)\\n                 \\n        inorder(root)\\n        sorted_nodes = sorted(inorder_nodes, key = lambda x: x.val)\\n        \\n        wrong = []\\n        for (i, node) in enumerate(sorted_nodes):\\n            if inorder_nodes[i].val != node.val:\\n                wrong.append(node)\\n                \\n        wrong[0].val, wrong[1].val = wrong[1].val, wrong[0].val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671908,
                "title": "2-approaches-with-line-to-line-explanation",
                "content": "Best Approach Using Inorder Traversal\\n    *TC: O(N)  \\n\\tSC: O(1)*\\n    \"prev\" stores the previous value in \"Inorder Travesal\"\\n   \"f\" -> first mis-placed element, \\n\\t\"s\" -> second im-positioned element \\n```\\nclass Solution {\\npublic:\\n    TreeNode *f=0,*s=0,*prev=new TreeNode(INT_MIN);\\n    void recoverTree(TreeNode* root) {\\n       traverse(root);\\n        int t=f->val;\\n        f->val=s->val;\\n        s->val=t;\\n    }\\n    void traverse(TreeNode* root){\\n        if(!root)return;\\n        traverse(root->left);\\n\\t\\t//if first element itself not found and and an order mis-match found in inorder, assing it to first element i.e. \\'f\\'\\n        if(!f and prev->val>root->val)f=prev;\\n\\t\\t\\n\\t\\t//if first element already found and and an order mis-match found in inorder, assing it to second element i.e. \\'s\\'\\n        if(f and prev->val>root->val)s=root;\\n        prev=root;\\n        traverse(root->right);\\n    }\\n};\\n```\\n\\n```\\n\\nSecond Approach\\nUsing Property: Inorder Travesal must give Sorted Result *TC: O(N)  SC: O(N)*\\n\\n vector<int>v;\\n    void recoverTree(TreeNode* root) {\\n\\t\\t//any tree traversal to store values of tree\\n        inorder(root);\\n\\t\\t// genearting inorder travesal of BST by sorting\\n        sort(v.begin(),v.end());\\n        int k=0;\\n\\t\\t//Level Order Traversal to assign values from sorted array to tree simply (copying)\\n        create(root,k);\\n    }\\n\\t//Any Travesal Method, Here Using Inorder\\n    void inorder(TreeNode* root){\\n        if(!root)return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n        return ;   \\n    }\\n\\t\\n\\t//Inorder for copying sorted values from array\\n    void create(TreeNode* root,int &k){\\n        if(!root)return;\\n        if(root->left) {create(root->left,k);}\\n        root->val=v[k++];\\n        if(root->right) create(root->right,k);\\n         return ; \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *f=0,*s=0,*prev=new TreeNode(INT_MIN);\\n    void recoverTree(TreeNode* root) {\\n       traverse(root);\\n        int t=f->val;\\n        f->val=s->val;\\n        s->val=t;\\n    }\\n    void traverse(TreeNode* root){\\n        if(!root)return;\\n        traverse(root->left);\\n\\t\\t//if first element itself not found and and an order mis-match found in inorder, assing it to first element i.e. \\'f\\'\\n        if(!f and prev->val>root->val)f=prev;\\n\\t\\t\\n\\t\\t//if first element already found and and an order mis-match found in inorder, assing it to second element i.e. \\'s\\'\\n        if(f and prev->val>root->val)s=root;\\n        prev=root;\\n        traverse(root->right);\\n    }\\n};\\n```\n```\\n\\nSecond Approach\\nUsing Property: Inorder Travesal must give Sorted Result *TC: O(N)  SC: O(N)*\\n\\n vector<int>v;\\n    void recoverTree(TreeNode* root) {\\n\\t\\t//any tree traversal to store values of tree\\n        inorder(root);\\n\\t\\t// genearting inorder travesal of BST by sorting\\n        sort(v.begin(),v.end());\\n        int k=0;\\n\\t\\t//Level Order Traversal to assign values from sorted array to tree simply (copying)\\n        create(root,k);\\n    }\\n\\t//Any Travesal Method, Here Using Inorder\\n    void inorder(TreeNode* root){\\n        if(!root)return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n        return ;   \\n    }\\n\\t\\n\\t//Inorder for copying sorted values from array\\n    void create(TreeNode* root,int &k){\\n        if(!root)return;\\n        if(root->left) {create(root->left,k);}\\n        root->val=v[k++];\\n        if(root->right) create(root->right,k);\\n         return ; \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451929,
                "title": "simple-c-inorder-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* first, *second, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(first->val, second->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(first == nullptr && root->val < pre->val)\\n\\t\\t\\tfirst = pre;\\n\\t\\tif(first != nullptr && root->val < pre->val)\\n\\t\\t\\tsecond = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```\\n**Please Upvote\\nthank you!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* first, *second, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(first->val, second->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(first == nullptr && root->val < pre->val)\\n\\t\\t\\tfirst = pre;\\n\\t\\tif(first != nullptr && root->val < pre->val)\\n\\t\\t\\tsecond = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967352,
                "title": "c-3-approaches-with-explanation-brute-optimised",
                "content": "Brute Force O(nlogn) time complexity and O(n) space\\n\\nAlgorithm:\\n\\n1. Traverse with Inorder Traversal and store data in Array\\n2. sort that Array\\n3. copy that Array with One more Inorder Traversal\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,vector<int> &v){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,v);\\n    \\n        v.push_back(root->val);\\n               \\n        rec(root->right,v);\\n        \\n    }\\n    \\n    void rec_add(TreeNode* root,vector<int> &v,int &i){\\n         if(root == NULL) return;\\n        \\n        rec_add(root->left,v,i);\\n    \\n        root->val = v[i++];\\n               \\n        rec_add(root->right,v,i);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        vector<int> v;\\n        \\n        rec(root,v);\\n        sort(v.begin(),v.end());\\n        int i = 0;\\n        \\n        rec_add(root,v,i);\\n    }\\n\\n};\\n```\\n\\nO(n) time complexity and O(n) space\\n\\nIn this solution we reduced the time of sorting part , as we know that there will be exactly 2 numbers which are not in place we have to find them\\n\\nso we will traverse on array the first element we get with a[i] < a[i-1] at i-1 will be first one to swap , after geting this i-1 we will go for 2nd element we will store every num from first element with a[i] < a[i-1] and at last we end up getting 2nd number to be swaped.\\n\\nAlgorithm:\\n\\n1.Traverse Inorder on BST and store in Array\\n2.find first element and 2nd element to be swaped\\n3.swap that 2 numbers\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,vector<TreeNode*> &v){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,v);\\n    \\n        v.push_back(root);\\n               \\n        rec(root->right,v);\\n        \\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        vector<TreeNode*> v;\\n        \\n        rec(root,v);\\n       \\n        int swap_idx = -1;\\n        int swap_idx2 = -1;\\n        \\n        int i;\\n        \\n        for(i = 1;i<v.size();i++){\\n            if( v[i]->val < v[i-1]->val){\\n                if(swap_idx == -1 ){ \\n                \\n                 swap_idx = i-1;\\n                 swap_idx2 = i;\\n                \\n                }\\n                else {\\n                    \\n                    swap_idx2 = i;\\n                \\n                }\\n            }\\n        }\\n         \\n             int t = v[swap_idx]->val;\\n             v[swap_idx]->val = v[swap_idx2]->val;\\n             v[swap_idx2]->val = t;\\n        \\n    }\\n\\n};\\n```\\n\\nOptimised : O(n) time complexty with O(1) space complexity\\n\\nHere to get those 2 nodes to be swaped we will maintain 3 TreeNodes prev,TreeNode first,TreeNode second \\nand while traversing Inorderly we will check for those conditions as prev->val > root->val and update 1st and second node\\nafter rec calls ends we will have those 2 nodes finally we will swap them\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,TreeNode* &prev,TreeNode* &first,TreeNode* &second){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,prev,first,second);\\n    \\n        if(root->val < prev->val){\\n            \\n            if(first == NULL){\\n                first = prev;\\n                second = root;\\n            }else{\\n                second = root;\\n            }\\n            \\n        }\\n \\n        prev = root;\\n        rec(root->right,prev,first,second);\\n        \\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        TreeNode* prev = new TreeNode(INT_MIN);\\n        TreeNode* a = NULL;\\n        TreeNode* b = NULL;\\n        \\n        rec(root,prev,a,b);\\n        \\n        int t = a->val;\\n        a->val = b->val;\\n        b->val = t;\\n       \\n    }\\n\\n};\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,vector<int> &v){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,v);\\n    \\n        v.push_back(root->val);\\n               \\n        rec(root->right,v);\\n        \\n    }\\n    \\n    void rec_add(TreeNode* root,vector<int> &v,int &i){\\n         if(root == NULL) return;\\n        \\n        rec_add(root->left,v,i);\\n    \\n        root->val = v[i++];\\n               \\n        rec_add(root->right,v,i);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        vector<int> v;\\n        \\n        rec(root,v);\\n        sort(v.begin(),v.end());\\n        int i = 0;\\n        \\n        rec_add(root,v,i);\\n    }\\n\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,vector<TreeNode*> &v){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,v);\\n    \\n        v.push_back(root);\\n               \\n        rec(root->right,v);\\n        \\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        vector<TreeNode*> v;\\n        \\n        rec(root,v);\\n       \\n        int swap_idx = -1;\\n        int swap_idx2 = -1;\\n        \\n        int i;\\n        \\n        for(i = 1;i<v.size();i++){\\n            if( v[i]->val < v[i-1]->val){\\n                if(swap_idx == -1 ){ \\n                \\n                 swap_idx = i-1;\\n                 swap_idx2 = i;\\n                \\n                }\\n                else {\\n                    \\n                    swap_idx2 = i;\\n                \\n                }\\n            }\\n        }\\n         \\n             int t = v[swap_idx]->val;\\n             v[swap_idx]->val = v[swap_idx2]->val;\\n             v[swap_idx2]->val = t;\\n        \\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,TreeNode* &prev,TreeNode* &first,TreeNode* &second){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,prev,first,second);\\n    \\n        if(root->val < prev->val){\\n            \\n            if(first == NULL){\\n                first = prev;\\n                second = root;\\n            }else{\\n                second = root;\\n            }\\n            \\n        }\\n \\n        prev = root;\\n        rec(root->right,prev,first,second);\\n        \\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        TreeNode* prev = new TreeNode(INT_MIN);\\n        TreeNode* a = NULL;\\n        TreeNode* b = NULL;\\n        \\n        rec(root,prev,a,b);\\n        \\n        int t = a->val;\\n        a->val = b->val;\\n        b->val = t;\\n       \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963371,
                "title": "2-java-solution-from-extra-space-to-optimized",
                "content": "\\n**Approach 1->**\\n\\nFirst thing that comes into mind is that in-order traversal is sorted. so if we store in-order of tree to list and then we just need to find two nodes on which we want to swap values. i.e. start and end node.\\n1.iterate the list to check first occurence where ith element > i+1th element. now,we have start node \\n2.if we have start node with us . now check further if any value exists whose value is smaller then start node. store it as end node and break out of loop\\n3.now just swap start and end values.\\n\\nexample->\\ninorder if suppose is -> \\n-33,321,55,71,231,-13,399\\nfirst we will get start as 321. as 321>55\\nnow, we have start then we meet 321<399 condition. in such case -13 will be end.\\n\\n```\\npublic void recoverTree(TreeNode root) {\\n\\t\\tList<TreeNode> list = new ArrayList<>();\\n\\t\\tinorder(root, list);\\n\\t\\tint start = -1;\\n\\t\\tint end = list.size() - 1;\\n\\t\\tfor (int i = 0; i < list.size() - 1; i++) {\\n\\t\\t\\tif (start == -1 && list.get(i).val > list.get(i + 1).val) {\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t} else if (start != -1 && list.get(start).val < list.get(i + 1).val) {\\n\\t\\t\\t\\tend = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint temp = list.get(start).val;\\n\\t\\tlist.get(start).val = list.get(end).val;\\n\\t\\tlist.get(end).val = temp;\\n\\t}\\n\\n\\tprivate void inorder(TreeNode root, List<TreeNode> list) {\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorder(root.left, list);\\n\\t\\t\\tlist.add(root);\\n\\t\\t\\tinorder(root.right, list);\\n\\t\\t}\\n\\t}\\n```\\n\\n\\n**Approach 2->**\\n\\n1. we can observe that at a time we just need ith and i+1th node to compare. i.e. prev and curr element. and once found start and end node also needed. i.e. total 4 nodes can serve the purpose. instead of entire list.\\n2. just convert above iterative loop into recursive approach->\\n```\\npublic class Solution {\\n\\n\\tTreeNode start = null;\\n\\tTreeNode end = null;\\n\\tTreeNode prev = null;\\n\\n\\tpublic void recoverTree(TreeNode root) {\\n\\t\\tprev = new TreeNode(Integer.MIN_VALUE);\\n\\t\\tinorder(root);\\n\\t\\tint temp = start.val;\\n\\t\\t//case where last node itself needed to be swapped\\n\\t\\tif (end == null) {\\n\\t\\t\\tend = prev;\\n\\t\\t}\\n\\t\\tstart.val = end.val;\\n\\t\\tend.val = temp;\\n\\t}\\n\\n\\tprivate void inorder(TreeNode root) {\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorder(root.left);\\n\\t\\t\\tif (start == null && prev.val > root.val) {\\n\\t\\t\\t\\tstart = prev;\\n\\t\\t\\t} else if (start != null && start.val < root.val) {\\n\\t\\t\\t\\tend = prev;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tprev = root;\\n\\t\\t\\tinorder(root.right);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic void recoverTree(TreeNode root) {\\n\\t\\tList<TreeNode> list = new ArrayList<>();\\n\\t\\tinorder(root, list);\\n\\t\\tint start = -1;\\n\\t\\tint end = list.size() - 1;\\n\\t\\tfor (int i = 0; i < list.size() - 1; i++) {\\n\\t\\t\\tif (start == -1 && list.get(i).val > list.get(i + 1).val) {\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t} else if (start != -1 && list.get(start).val < list.get(i + 1).val) {\\n\\t\\t\\t\\tend = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint temp = list.get(start).val;\\n\\t\\tlist.get(start).val = list.get(end).val;\\n\\t\\tlist.get(end).val = temp;\\n\\t}\\n\\n\\tprivate void inorder(TreeNode root, List<TreeNode> list) {\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorder(root.left, list);\\n\\t\\t\\tlist.add(root);\\n\\t\\t\\tinorder(root.right, list);\\n\\t\\t}\\n\\t}\\n```\n```\\npublic class Solution {\\n\\n\\tTreeNode start = null;\\n\\tTreeNode end = null;\\n\\tTreeNode prev = null;\\n\\n\\tpublic void recoverTree(TreeNode root) {\\n\\t\\tprev = new TreeNode(Integer.MIN_VALUE);\\n\\t\\tinorder(root);\\n\\t\\tint temp = start.val;\\n\\t\\t//case where last node itself needed to be swapped\\n\\t\\tif (end == null) {\\n\\t\\t\\tend = prev;\\n\\t\\t}\\n\\t\\tstart.val = end.val;\\n\\t\\tend.val = temp;\\n\\t}\\n\\n\\tprivate void inorder(TreeNode root) {\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorder(root.left);\\n\\t\\t\\tif (start == null && prev.val > root.val) {\\n\\t\\t\\t\\tstart = prev;\\n\\t\\t\\t} else if (start != null && start.val < root.val) {\\n\\t\\t\\t\\tend = prev;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tprev = root;\\n\\t\\t\\tinorder(root.right);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963292,
                "title": "python-easy-python-solution-using-inorder-traversal-and-array",
                "content": "# If You Like My Solution Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\tclass Solution:\\n\\t\\tdef recoverTree(self, root: Optional[TreeNode]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify root in-place instead.\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tarray = []\\n\\n\\t\\t\\tdef InOrder(node):\\n\\n\\t\\t\\t\\tif node != None:\\n\\n\\t\\t\\t\\t\\tInOrder(node.left)\\n\\t\\t\\t\\t\\tarray.append(node)\\n\\t\\t\\t\\t\\tInOrder(node.right)\\n\\n\\t\\t\\tInOrder(root)\\n\\n\\t\\t\\tlength = len(array)\\n\\n\\t\\t\\tfirst_node = array[0]\\n\\n\\t\\t\\tsecond_node = array[-1]\\n\\n\\t\\t\\tfor i in range(1,length):\\n\\t\\t\\t\\tif array[i].val < array[i-1].val:\\n\\t\\t\\t\\t\\tfirst_node = array[i-1]\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tfor i in range(length-2,-1,-1):\\n\\t\\t\\t\\tif array[i].val > array[i+1].val:\\n\\t\\t\\t\\t\\tsecond_node = array[i+1]\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tfirst_node.val , second_node.val = second_node.val , first_node.val",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "# If You Like My Solution Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\tclass Solution:\\n\\t\\tdef recoverTree(self, root: Optional[TreeNode]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify root in-place instead.\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tarray = []\\n\\n\\t\\t\\tdef InOrder(node):\\n\\n\\t\\t\\t\\tif node != None:\\n\\n\\t\\t\\t\\t\\tInOrder(node.left)\\n\\t\\t\\t\\t\\tarray.append(node)\\n\\t\\t\\t\\t\\tInOrder(node.right)\\n\\n\\t\\t\\tInOrder(root)\\n\\n\\t\\t\\tlength = len(array)\\n\\n\\t\\t\\tfirst_node = array[0]\\n\\n\\t\\t\\tsecond_node = array[-1]\\n\\n\\t\\t\\tfor i in range(1,length):\\n\\t\\t\\t\\tif array[i].val < array[i-1].val:\\n\\t\\t\\t\\t\\tfirst_node = array[i-1]\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tfor i in range(length-2,-1,-1):\\n\\t\\t\\t\\tif array[i].val > array[i+1].val:\\n\\t\\t\\t\\t\\tsecond_node = array[i+1]\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tfirst_node.val , second_node.val = second_node.val , first_node.val",
                "codeTag": "Java"
            },
            {
                "id": 1962494,
                "title": "go-inorder-dfs-clear-solution",
                "content": "```\\nfunc recoverTree(root *TreeNode)  {\\n    var prev, first, second *TreeNode\\n    \\n    var dfs func(node *TreeNode)\\n    dfs = func(node *TreeNode) {\\n        if node == nil { return }\\n        dfs(node.Left)\\n        if prev != nil {\\n            if first == nil && prev.Val >= node.Val { first = prev }\\n            if first != nil && prev.Val >= node.Val { second = node }\\n        }\\n        prev = node\\n        dfs(node.Right)\\n    }\\n    dfs(root)\\n\\t\\n    first.Val, second.Val = second.Val, first.Val\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc recoverTree(root *TreeNode)  {\\n    var prev, first, second *TreeNode\\n    \\n    var dfs func(node *TreeNode)\\n    dfs = func(node *TreeNode) {\\n        if node == nil { return }\\n        dfs(node.Left)\\n        if prev != nil {\\n            if first == nil && prev.Val >= node.Val { first = prev }\\n            if first != nil && prev.Val >= node.Val { second = node }\\n        }\\n        prev = node\\n        dfs(node.Right)\\n    }\\n    dfs(root)\\n\\t\\n    first.Val, second.Val = second.Val, first.Val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1962329,
                "title": "two-js-solutions-recursive-and-iterative",
                "content": "# Iterative Solution: \\n```\\nconst recoverTree = function (root) {\\n\\tconst stack = [];\\n\\tlet node = root,\\n\\t\\tprev = null,\\n\\t\\tx = null,\\n\\t\\ty = null;\\n\\twhile (stack.length || node) {\\n\\t\\tif (node) {\\n\\t\\t\\tstack.push(node);\\n\\t\\t\\tnode = node.left;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tnode = stack.pop();\\n\\t\\tif (prev && prev.val > node.val) {\\n\\t\\t\\ty = node;\\n\\t\\t\\tif (!x) x = prev;\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tprev = node;\\n\\t\\tnode = node.right;\\n\\t}\\n\\t[x.val, y.val] = [y.val, x.val];\\n};\\n```\\n# Recursive Solution:\\n```\\nconst recoverTree = function (root) {\\n\\tlet x = null,\\n\\t\\ty = null,\\n\\t\\tprev = null;\\n\\tconst dfs = (node) => {\\n\\t\\tif (!node) return;\\n\\t\\tdfs(node.left);\\n\\t\\tif (prev && node.val < prev.val) {\\n\\t\\t\\tif (x == null) x = prev;\\n\\t\\t\\ty = node;\\n\\t\\t}\\n\\t\\tprev = node;\\n\\t\\tdfs(node.right);\\n\\t};\\n\\tdfs(root);\\n\\t[x.val, y.val] = [y.val, x.val];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst recoverTree = function (root) {\\n\\tconst stack = [];\\n\\tlet node = root,\\n\\t\\tprev = null,\\n\\t\\tx = null,\\n\\t\\ty = null;\\n\\twhile (stack.length || node) {\\n\\t\\tif (node) {\\n\\t\\t\\tstack.push(node);\\n\\t\\t\\tnode = node.left;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tnode = stack.pop();\\n\\t\\tif (prev && prev.val > node.val) {\\n\\t\\t\\ty = node;\\n\\t\\t\\tif (!x) x = prev;\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tprev = node;\\n\\t\\tnode = node.right;\\n\\t}\\n\\t[x.val, y.val] = [y.val, x.val];\\n};\\n```\n```\\nconst recoverTree = function (root) {\\n\\tlet x = null,\\n\\t\\ty = null,\\n\\t\\tprev = null;\\n\\tconst dfs = (node) => {\\n\\t\\tif (!node) return;\\n\\t\\tdfs(node.left);\\n\\t\\tif (prev && node.val < prev.val) {\\n\\t\\t\\tif (x == null) x = prev;\\n\\t\\t\\ty = node;\\n\\t\\t}\\n\\t\\tprev = node;\\n\\t\\tdfs(node.right);\\n\\t};\\n\\tdfs(root);\\n\\t[x.val, y.val] = [y.val, x.val];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534309,
                "title": "c-solution-with-easy-to-understand-explanation",
                "content": "```\\n    void recoverTree(TreeNode* root) {\\n        // when inorder traversing a BST, we would traverse the node with the values in increasing order\\n        // if there are only two nodes in the BST that their values are wrong, there\\'s only one situation:\\n        // a node with a larger value appears before a node with a smaller value in the inorder traversal result\\n        // during the inorder traversing, the first node which value is greater than the its successor must be one of the wrong nodes which has a larger value\\n        // for the smaller value wrong node, we can see that its value must be smaller than its predecessor\\n        // we can see that the last node which value is smaller than its predecessor in the inorder traversal must be the smaller wrong node.\\n        // to better understanding we can see that for an inorder traversal result 1 2 6 4 5 3 7\\n        // the first node that its value greater than its successor is the node with value 6\\n        // and the last node which value is smaller than its predecessor is the node with value 3\\n        // for an other example, 1 3 2 4\\n        // 3 is the first value which is greater than its successor and 2 is the last value which value is smaller than its predecessor\\n        TreeNode* largeNode = NULL;\\n        TreeNode* smallNode = NULL;\\n        TreeNode* preNode = NULL;\\n        inorderTraversal(root, largeNode, smallNode, preNode);\\n        int smallVal = smallNode->val;\\n        smallNode->val = largeNode->val;\\n        largeNode->val = smallVal;\\n    }\\n    \\n    void inorderTraversal(TreeNode* node, TreeNode*& largeNode, TreeNode*& smallNode, TreeNode*& preNode) {\\n        if (node == NULL) {\\n            return;\\n        }\\n        inorderTraversal(node->left, largeNode, smallNode, preNode);\\n        // the first node has no predecessor so we can\\'t tell whether it\\'s greater or smaller than its predecessor\\n        if (preNode != NULL && node->val < preNode->val) {\\n            // largeNode equals NULL means preNode is the first node whose value is greater than its successor\\n            // so preNode is the wrong larger node\\n            if (largeNode == NULL) {\\n                largeNode = preNode;\\n            }\\n            // there maybe two nodes with a smaller value than its predecessor, the successor of the larger wrong node and the real smaller wrong node\\n            // the last smallNode is the smaller wrong node which we want to get\\n            smallNode = node;\\n        }\\n        // node becomes preNode of the next node after being traversed\\n        preNode = node;\\n        inorderTraversal(node->right, largeNode, smallNode, preNode);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void recoverTree(TreeNode* root) {\\n        // when inorder traversing a BST, we would traverse the node with the values in increasing order\\n        // if there are only two nodes in the BST that their values are wrong, there\\'s only one situation:\\n        // a node with a larger value appears before a node with a smaller value in the inorder traversal result\\n        // during the inorder traversing, the first node which value is greater than the its successor must be one of the wrong nodes which has a larger value\\n        // for the smaller value wrong node, we can see that its value must be smaller than its predecessor\\n        // we can see that the last node which value is smaller than its predecessor in the inorder traversal must be the smaller wrong node.\\n        // to better understanding we can see that for an inorder traversal result 1 2 6 4 5 3 7\\n        // the first node that its value greater than its successor is the node with value 6\\n        // and the last node which value is smaller than its predecessor is the node with value 3\\n        // for an other example, 1 3 2 4\\n        // 3 is the first value which is greater than its successor and 2 is the last value which value is smaller than its predecessor\\n        TreeNode* largeNode = NULL;\\n        TreeNode* smallNode = NULL;\\n        TreeNode* preNode = NULL;\\n        inorderTraversal(root, largeNode, smallNode, preNode);\\n        int smallVal = smallNode->val;\\n        smallNode->val = largeNode->val;\\n        largeNode->val = smallVal;\\n    }\\n    \\n    void inorderTraversal(TreeNode* node, TreeNode*& largeNode, TreeNode*& smallNode, TreeNode*& preNode) {\\n        if (node == NULL) {\\n            return;\\n        }\\n        inorderTraversal(node->left, largeNode, smallNode, preNode);\\n        // the first node has no predecessor so we can\\'t tell whether it\\'s greater or smaller than its predecessor\\n        if (preNode != NULL && node->val < preNode->val) {\\n            // largeNode equals NULL means preNode is the first node whose value is greater than its successor\\n            // so preNode is the wrong larger node\\n            if (largeNode == NULL) {\\n                largeNode = preNode;\\n            }\\n            // there maybe two nodes with a smaller value than its predecessor, the successor of the larger wrong node and the real smaller wrong node\\n            // the last smallNode is the smaller wrong node which we want to get\\n            smallNode = node;\\n        }\\n        // node becomes preNode of the next node after being traversed\\n        preNode = node;\\n        inorderTraversal(node->right, largeNode, smallNode, preNode);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402315,
                "title": "c-solution-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    int i=0;\\n    void find(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        find(root->left);\\n        v.push_back(root->val);\\n        find(root->right);\\n    }\\n    void check(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        check(root->left);\\n         root->val=v[i++];\\n        check(root->right);\\n    }\\n    void recoverTree(TreeNode* root)\\n    {\\n        find(root);\\n        sort(v.begin(),v.end());\\n        check(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    int i=0;\\n    void find(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        find(root->left);\\n        v.push_back(root->val);\\n        find(root->right);\\n    }\\n    void check(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        check(root->left);\\n         root->val=v[i++];\\n        check(root->right);\\n    }\\n    void recoverTree(TreeNode* root)\\n    {\\n        find(root);\\n        sort(v.begin(),v.end());\\n        check(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381752,
                "title": "simple-recursion-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    TreeNode* prev =NULL;\\n    \\n    void help(TreeNode*root){\\n        \\n        \\n    if(root == NULL) return;\\n    help(root->left);\\n    if(prev && first==NULL && prev->val>root->val) first = prev;\\n    if(prev && first!=NULL && prev->val>root->val) second = root;\\n    prev = root;\\n    help(root->right);\\n        \\n        \\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        \\n    help(root);\\n    swap(first->val,second->val);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    TreeNode* prev =NULL;\\n    \\n    void help(TreeNode*root){\\n        \\n        \\n    if(root == NULL) return;\\n    help(root->left);\\n    if(prev && first==NULL && prev->val>root->val) first = prev;\\n    if(prev && first!=NULL && prev->val>root->val) second = root;\\n    prev = root;\\n    help(root->right);\\n        \\n        \\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        \\n    help(root);\\n    swap(first->val,second->val);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282486,
                "title": "o-1-space-time-complexity",
                "content": "```\\nclass Solution {\\n    TreeNode first=null;\\n    TreeNode second=null;\\n    TreeNode prev=null;\\n    \\n    public void fix(TreeNode root){\\n        if(root==null) return;\\n        \\n        //traverse for left\\n        fix(root.left);\\n        \\n        //check for mistake\\n        if(prev!=null&&root.val<prev.val){\\n            if(first==null) first=prev;\\n            second=root;\\n        }\\n        \\n        //update previous to be root\\n        prev=root;\\n        \\n        //traverse for right\\n        fix(root.right);\\n    }\\n    \\n    public void recoverTree(TreeNode root) {\\n        fix(root);\\n        \\n        //swap first and second\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode first=null;\\n    TreeNode second=null;\\n    TreeNode prev=null;\\n    \\n    public void fix(TreeNode root){\\n        if(root==null) return;\\n        \\n        //traverse for left\\n        fix(root.left);\\n        \\n        //check for mistake\\n        if(prev!=null&&root.val<prev.val){\\n            if(first==null) first=prev;\\n            second=root;\\n        }\\n        \\n        //update previous to be root\\n        prev=root;\\n        \\n        //traverse for right\\n        fix(root.right);\\n    }\\n    \\n    public void recoverTree(TreeNode root) {\\n        fix(root);\\n        \\n        //swap first and second\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194053,
                "title": "python-easy-and-understandable",
                "content": "```\\nimport math\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        first = None\\n        sec = None\\n        prev = TreeNode(-math.inf)\\n        def check(root):\\n            nonlocal prev,first,sec\\n            if root==None:\\n                return\\n            check(root.left)\\n            if root.val<prev.val:\\n                if not first:\\n                    first = prev\\n                sec = root\\n            prev = root\\n            check(root.right)\\n        check(root)\\n        first.val,sec.val = sec.val,first.val\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nimport math\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        first = None\\n        sec = None\\n        prev = TreeNode(-math.inf)\\n        def check(root):\\n            nonlocal prev,first,sec\\n            if root==None:\\n                return\\n            check(root.left)\\n            if root.val<prev.val:\\n                if not first:\\n                    first = prev\\n                sec = root\\n            prev = root\\n            check(root.right)\\n        check(root)\\n        first.val,sec.val = sec.val,first.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920369,
                "title": "python3-morris-in-order-traversal-generator-recover-binary-search-tree",
                "content": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        def morrisInOrder(root):\\n            while root:\\n                if not root.left:\\n                    yield root\\n                    root = root.right\\n                else:    \\n                    prev = root.left\\n                    while prev.right and prev.right != root:\\n                        prev = prev.right\\n                    if not prev.right:\\n                        prev.right = root\\n                        root = root.left\\n                    else:\\n                        yield root\\n                        prev.right = None\\n                        root = root.right\\n        prev, first, second = None, None, None\\n        for curr in morrisInOrder(root):\\n            if prev and prev.val > curr.val:\\n                if not first:\\n                    first = prev\\n                second = curr\\n            prev = curr\\n        first.val, second.val = second.val, first.val \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        def morrisInOrder(root):\\n            while root:\\n                if not root.left:\\n                    yield root\\n                    root = root.right\\n                else:    \\n                    prev = root.left\\n                    while prev.right and prev.right != root:\\n                        prev = prev.right\\n                    if not prev.right:\\n                        prev.right = root\\n                        root = root.left\\n                    else:\\n                        yield root\\n                        prev.right = None\\n                        root = root.right\\n        prev, first, second = None, None, None\\n        for curr in morrisInOrder(root):\\n            if prev and prev.val > curr.val:\\n                if not first:\\n                    first = prev\\n                second = curr\\n            prev = curr\\n        first.val, second.val = second.val, first.val \\n```",
                "codeTag": "Java"
            },
            {
                "id": 856474,
                "title": "commented-fully-explained",
                "content": "```\\n// There are two nodes not in their places, so one will be larger than the other, \\n// let\\'s say a is the larger node and b is the smaller node and both of them needs\\n// to be swapped in order to correct the binary search tree, so now, surely a is \\n// taking the place of a smaller number(b), so a will come earlier in the inorder\\n// traversal, so whenever we find a pair not following the non dec order in the \\n// inorder traversal, the first element is always the prev node. And to handle case\\n// when only the first occuring problematic pair needs to be sorted, we assign\\n// second to the current node as well, but if we a pair like this again, we will \\n// simply assign second to the current node as it is taking a place of a bigger node\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n// first points to first misplaced node and second points\\n// to the second one, prev points to the prev node in the\\n// inorder traversal.\\nTreeNode * first = NULL;\\nTreeNode * second = NULL;\\nTreeNode * prev = new TreeNode(INT_MIN);\\n    \\n    void recoverTree(TreeNode* root) \\n    {\\n        if(!root)\\n            return;\\n        \\n        find(root);\\n        swap(first->val, second->val);   \\n    }\\n    \\n    void find(TreeNode * root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        find(root->left);\\n        \\n        // in case we find inorder is not in non dec order, we assign first\\n        // as prev, we have talked about in brief earlier.\\n        if(prev->val > root->val && first ==NULL)\\n            first = prev;\\n        \\n        \\n        // we have not used else if here to avoid corner cases, whenever some\\n        // pair not following the non dec order occurs, we assign first and second\\n        // pointers to the nodes respectively, to handle the case where only both \\n        // of them are to be swapped. If we find some other node not following the \\n        // order, we will assign second to that node as this if condition will\\n        // satisfy for that as well.\\n        if(prev->val > root->val && first !=NULL)\\n            second = root;\\n        \\n        prev = root;   \\n        \\n        find(root->right);\\n        \\n        return;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// There are two nodes not in their places, so one will be larger than the other, \\n// let\\'s say a is the larger node and b is the smaller node and both of them needs\\n// to be swapped in order to correct the binary search tree, so now, surely a is \\n// taking the place of a smaller number(b), so a will come earlier in the inorder\\n// traversal, so whenever we find a pair not following the non dec order in the \\n// inorder traversal, the first element is always the prev node. And to handle case\\n// when only the first occuring problematic pair needs to be sorted, we assign\\n// second to the current node as well, but if we a pair like this again, we will \\n// simply assign second to the current node as it is taking a place of a bigger node\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n// first points to first misplaced node and second points\\n// to the second one, prev points to the prev node in the\\n// inorder traversal.\\nTreeNode * first = NULL;\\nTreeNode * second = NULL;\\nTreeNode * prev = new TreeNode(INT_MIN);\\n    \\n    void recoverTree(TreeNode* root) \\n    {\\n        if(!root)\\n            return;\\n        \\n        find(root);\\n        swap(first->val, second->val);   \\n    }\\n    \\n    void find(TreeNode * root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        find(root->left);\\n        \\n        // in case we find inorder is not in non dec order, we assign first\\n        // as prev, we have talked about in brief earlier.\\n        if(prev->val > root->val && first ==NULL)\\n            first = prev;\\n        \\n        \\n        // we have not used else if here to avoid corner cases, whenever some\\n        // pair not following the non dec order occurs, we assign first and second\\n        // pointers to the nodes respectively, to handle the case where only both \\n        // of them are to be swapped. If we find some other node not following the \\n        // order, we will assign second to that node as this if condition will\\n        // satisfy for that as well.\\n        if(prev->val > root->val && first !=NULL)\\n            second = root;\\n        \\n        prev = root;   \\n        \\n        find(root->right);\\n        \\n        return;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543745,
                "title": "simple-and-efficient-java-solution-runs-in-1ms-in-order-traversal",
                "content": "```\\nclass Solution {\\n    private int preVal = Integer.MIN_VALUE;\\n    private TreeNode first;\\n    private TreeNode second;\\n    \\n    public void recoverTree(TreeNode root) {\\n        traverse(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if(root == null)\\n            return;\\n        \\n        traverse(root.left);\\n        \\n        if(preVal > root.val) second = root;\\n        if(second == null) first = root;\\n        preVal = root.val;\\n        \\n        traverse(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int preVal = Integer.MIN_VALUE;\\n    private TreeNode first;\\n    private TreeNode second;\\n    \\n    public void recoverTree(TreeNode root) {\\n        traverse(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if(root == null)\\n            return;\\n        \\n        traverse(root.left);\\n        \\n        if(preVal > root.val) second = root;\\n        if(second == null) first = root;\\n        preVal = root.val;\\n        \\n        traverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533030,
                "title": "java-simple-in-order-traversal-constant-space-with-detailed-explanation",
                "content": "When we meet BST, there are two features must be appeared in mind\\n1, in-order traversal is ascending\\n2, `root.left.val < root.val && root.right.val > root.val`, and recursively.\\n\\nThis question use first feature.\\n\\nIf we print the in-order array, correct BST\\'s picture will be a ascending line,\\nbut if we swap two node\\'s value, there will be two obviously point.\\n![image](https://assets.leetcode.com/users/yoha/image_1583660730.png)\\na is correct, b and c is two situation with swap.\\n```\\n    TreeNode pre = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    boolean one = false;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n\\t\\t// do swap\\n        int tmp = first.val;\\n        first.val = second.val;\\n        second.val = tmp;\\n    }\\n    \\n    private void inorder(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left);\\n        if (pre != null) {\\n            if (pre.val > root.val) {\\n                if (!one) {\\n                    first = pre;\\n                    one = true;\\n                }\\n                second = root;\\n            }\\n        }\\n        pre = root;\\n        inorder(root.right);\\n    }\\n```\\nAbove is recursion method, and you could use Stack to implement iterative method.",
                "solutionTags": [],
                "code": "```\\n    TreeNode pre = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    boolean one = false;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n\\t\\t// do swap\\n        int tmp = first.val;\\n        first.val = second.val;\\n        second.val = tmp;\\n    }\\n    \\n    private void inorder(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left);\\n        if (pre != null) {\\n            if (pre.val > root.val) {\\n                if (!one) {\\n                    first = pre;\\n                    one = true;\\n                }\\n                second = root;\\n            }\\n        }\\n        pre = root;\\n        inorder(root.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256063,
                "title": "java-in-order-traversal-with-detailed-analysis-of-the-in-order-solution",
                "content": "There are several facts to know to solve this problem:\\nLet\\'s consider the in-order traversal of a normal bst, the sequence will be:\\n```\\n1 2 3 4 5 6\\n```\\nIf we swap any two nodes, like 2 and 5, the sequence can be:\\n```\\n1 [5] 3 4 [2] 6\\n```\\nSo how to detect the first node and the second node? We can keep checking that whether a node\\'s value is strictly larger than it\\'s predecessor\\'s value. If at some point this rule is broken, we know that there is some abnormal nodes. Let\\'s see when this will happen:\\nWhen we check 3, we will find 5 > 3. The rule is broken, and 5 is the **predecessor** of 3.\\nWhen we check 6, we will find 6 > 2. The rule is broken again, and 2 is the **predecessor** of 6.\\n\\nYou will find that no matter which nodes we swap, we can obey this rule to get the first and the second node that we need to swap them back. \\n\\nThere is another fact about how to keep track of the predecessor. For in-order traversal, we keep going left until there is no left child, then visit the node, and then visit right child. Thus, if the node choose to go left, there is no predecessor update. After the node visited itself and start going right, there should be a predecessor-update. \\n\\nAnd finally, according to these two facts, we can find the first & second node, with O(logn) space complexity and O(n) time complexity.\\n\\n```\\nclass Solution {\\n    TreeNode first = null, second = null, pred = null;\\n    public void recoverTree(TreeNode root) {\\n        recover(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void recover(TreeNode node) {\\n        if (node == null) return;\\n        recover(node.left);\\n        if (first == null && pred != null && pred.val > node.val) {\\n            first = pred;\\n        }\\n        if (first != null && pred.val > node.val) {\\n            second = node;\\n        }\\n        pred = node;\\n        recover(node.right);    \\n    }  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1 2 3 4 5 6\\n```\n```\\n1 [5] 3 4 [2] 6\\n```\n```\\nclass Solution {\\n    TreeNode first = null, second = null, pred = null;\\n    public void recoverTree(TreeNode root) {\\n        recover(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void recover(TreeNode node) {\\n        if (node == null) return;\\n        recover(node.left);\\n        if (first == null && pred != null && pred.val > node.val) {\\n            first = pred;\\n        }\\n        if (first != null && pred.val > node.val) {\\n            second = node;\\n        }\\n        pred = node;\\n        recover(node.right);    \\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244861,
                "title": "in-place-solution-with-explanation-44ms-and-28-4mb-beats-96-12-and-87-5-repectively",
                "content": "First of all, **Keep in mind there are only two elements place are wrong in BST**\\n\\nSo here are three different scenarios and its base solution for this problem:\\n1. One larger node locates at the left side of a subtree. try to find it, and store the larger node as ```largerNode```and its parent as ```tmpNode```. Swap the value of ```largerNode``` and ```tmpNode```.\\n2. One smaller node locates at the right side of a subtree. try to find it, and store the smaller node ```smallerNode``` and its parent as ```tmpNode```. Swap the value of ```smallerNode``` and ```tmpNode```.\\n3. Both 1 and 2 happens, swap ```largerNode``` and ```smallerNode```.\\n\\nBut the solution in 1 and 2 are not stable, obviously, so as 3. Considering BST [1,2,null,3]. after using current solution in case 1, the result BST is [2,1,null,3]. Recall, **only two elements place are wrong**. we need to thoroughly find every node which are larger than its parent or even higher - grandparent. But there are **Only two wrong placed elements**, image we reach TreeNode(5), and its left children or grandchildren are TreeNode(6), TreeNode(7), TreeNode(8). Swap the TreeNode(6) or TreeNode(7) cannot help us fix the BST, since TreeNode(8) is still larger than its grandparents. **Thus, for case 1, this reminder us we only need to save the largest node locates at left side of a subtree whose root has smaller value, the problem only could be solved by swapping the largest node and the subtree root (where the violation begins).** This also could be proven by contradiction, if this cannot fix BST for case 1, any other swap cannot as well.\\n\\nTo avoid of using any container, we only could solve it recursively, BFS or DFS. With above analysis, since we need to find the largest or smallest violation node exhaustively, DFS is the first choice. \\n\\nRecall above case 1-3 are highly depends on the given BST structure, our solution would need to try to find both ```largerNode``` and ```smallerNode```, and the make swap decision depends on whether ```largerNode``` and ```smallerNode``` is found after DFS finished.\\n\\n**Another DFS feature with BST is, the search order is predefined, left or right.** Assume left first, so that the search would firstly find ```largerNode``` and then ```smallerNode```. In each DFS, we also need to update the minimal node value and maximum node vaule to check the violation for current node, and more importantly, **find largeNode as larger as possible, find smallNode as smaller as possible, which violate BST feature**. \\n\\nWith above analysis, remaining issue is how to update search space in each DFS. Similarly, this also have three different scenarios:\\n1. No violation, using current node as a division point, search space for left children (curMinNode, curNode), search space for right childeren (curNode, curMaxNode)\\n2. Violate curMaxNode, which means the largeNode show at the left side of the subtree(or root). For left children, same search space as current one, due to this violation node may swap away, and we need to keep current maxNode smaller to narrow down the space for its left children. For right children, assume we may swap curNode with curMaxNode, so that the curNode becomes its grandparents, and curNode->right is its grandparent\\'s left grandchildren but its prarent\\'s right children, so that the search space is (curMaxNode, curNode)\\n3. Violate curMinNode, which means the smallNode show at the right side of the subtree (or root). Similar as 2, but with symmetry.\\n\\nAfter all, here is the solution:\\n\\n```\\nclass Solution {\\n    TreeNode* largeNode = nullptr;\\n    TreeNode* smallNode = nullptr; \\n    TreeNode* tmpNode = nullptr;\\n    \\n    void swapNodeValue(TreeNode* a, TreeNode* b) {\\n        if (!a || !b) return;\\n        int tVal = a->val;\\n        a->val = b->val;\\n        b->val = tVal;\\n        return;\\n    }\\n\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        dfs(root, nullptr, nullptr);\\n        if (largeNode && smallNode) {\\n            swapNodeValue(largeNode, smallNode);\\n        } else if (largeNode) {\\n            swapNodeValue(largeNode, tmpNode);\\n        } else if (smallNode) {\\n            swapNodeValue(smallNode, tmpNode);\\n        }\\n        return;\\n    }\\n    \\n    void dfs(TreeNode* node, TreeNode* minNode, TreeNode* maxNode) {\\n        if (node == nullptr) return;\\n\\t\\t// this is largeNode only if it is larger than its upper limit\\n        if (maxNode && node->val > maxNode->val) {\\n            if (!tmpNode) tmpNode = maxNode;\\n            if (!largeNode) largeNode = node;\\n            if (node->val > largeNode->val) largeNode = node;\\n            dfs(node->left, minNode, maxNode);\\n            dfs(node->right, maxNode, node);\\n            return;\\n        }\\n\\t\\t// this is smallNode only if it is larget than its lower limit\\n        if (minNode && node->val < minNode->val) {\\n            if (!tmpNode) tmpNode = minNode;\\n            if (!smallNode) smallNode = node;\\n            if (node->val < smallNode->val) smallNode = node;\\n            dfs(node->left, node, maxNode);\\n            dfs(node->right, minNode, maxNode);\\n            return;\\n        }\\n        dfs(node->left, minNode, node);\\n        dfs(node->right, node, maxNode);\\n        return;\\n    }\\n};\\n```\\n\\nWe only need to store ```tmpNode``` once for case 1 or case 2. When case 3 happens, we only need to swap ```largeNode``` and ```smallNode```, so that ```tmpNode```is not useful anymore.\\n\\nOverall, this is a good practice to solve tree problem using recursion, with the constant space challenge (stricktly speaking, function overheads also takes space in each recursion, I\\'d like to say it is IN-PLACE solution). It helps me a lot to utilize tree features and DFS in problem solving. Althought it is also my most failure submissions problem so far, but it feels really great when you finally solve it on your own **:)**\\n\\n",
                "solutionTags": [],
                "code": "```largerNode```\n```tmpNode```\n```largerNode```\n```tmpNode```\n```smallerNode```\n```tmpNode```\n```smallerNode```\n```tmpNode```\n```largerNode```\n```smallerNode```\n```largerNode```\n```smallerNode```\n```largerNode```\n```smallerNode```\n```largerNode```\n```smallerNode```\n```\\nclass Solution {\\n    TreeNode* largeNode = nullptr;\\n    TreeNode* smallNode = nullptr; \\n    TreeNode* tmpNode = nullptr;\\n    \\n    void swapNodeValue(TreeNode* a, TreeNode* b) {\\n        if (!a || !b) return;\\n        int tVal = a->val;\\n        a->val = b->val;\\n        b->val = tVal;\\n        return;\\n    }\\n\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        dfs(root, nullptr, nullptr);\\n        if (largeNode && smallNode) {\\n            swapNodeValue(largeNode, smallNode);\\n        } else if (largeNode) {\\n            swapNodeValue(largeNode, tmpNode);\\n        } else if (smallNode) {\\n            swapNodeValue(smallNode, tmpNode);\\n        }\\n        return;\\n    }\\n    \\n    void dfs(TreeNode* node, TreeNode* minNode, TreeNode* maxNode) {\\n        if (node == nullptr) return;\\n\\t\\t// this is largeNode only if it is larger than its upper limit\\n        if (maxNode && node->val > maxNode->val) {\\n            if (!tmpNode) tmpNode = maxNode;\\n            if (!largeNode) largeNode = node;\\n            if (node->val > largeNode->val) largeNode = node;\\n            dfs(node->left, minNode, maxNode);\\n            dfs(node->right, maxNode, node);\\n            return;\\n        }\\n\\t\\t// this is smallNode only if it is larget than its lower limit\\n        if (minNode && node->val < minNode->val) {\\n            if (!tmpNode) tmpNode = minNode;\\n            if (!smallNode) smallNode = node;\\n            if (node->val < smallNode->val) smallNode = node;\\n            dfs(node->left, node, maxNode);\\n            dfs(node->right, minNode, maxNode);\\n            return;\\n        }\\n        dfs(node->left, minNode, node);\\n        dfs(node->right, node, maxNode);\\n        return;\\n    }\\n};\\n```\n```tmpNode```\n```largeNode```\n```smallNode```\n```tmpNode```",
                "codeTag": "Java"
            },
            {
                "id": 223902,
                "title": "inorder-traversal-logical-thinking",
                "content": "> How do we detect swapped nodes?\\n> Inorder traversal of BST meets nodes in the sorted order - the swapped nodes break this rule.\\n\\n> We observe that 1 swap results in 1 or 2 decreasing flow\\n-  1 decreasing:\\ne.g. [1 2 3 4 5]\\nswap 2 and 3 to [1 3 2 4 5]\\n3 -> 2 decreasing -- the second to swap right after the first to swap\\n- 2 decreasing:\\ne.g. [1 2 3 4 5]\\nswap 2 and 4 to [1 4 3 2 5]\\n4 -> 3 decreasing\\n3 -> 2 decreasing -- the second to swap is the latter element of the second decreasing flow  \\n\\n****\\n> Scala\\n```\\n  var prevNode, fstToSwap, sndToSwap: TreeNode = _\\n\\n  def recoverTree(root: TreeNode): Unit = {\\n    prevNode = null\\n    fstToSwap = null\\n    sndToSwap = null\\n    \\n    inorderTraverse(root)\\n    \\n    val fstToSwapValue = fstToSwap.value\\n    fstToSwap.value = sndToSwap.value\\n    sndToSwap.value = fstToSwapValue\\n  }\\n  \\n  def inorderTraverse(root: TreeNode): Unit = {\\n    if (root != null) {\\n      inorderTraverse(root.left)\\n      \\n      if (prevNode != null && prevNode.value > root.value && fstToSwap == null) fstToSwap = prevNode\\n      if (prevNode != null && prevNode.value > root.value && fstToSwap != null) sndToSwap = root\\n\\n      prevNode = root\\n      \\n      inorderTraverse(root.right)\\n    }\\n  }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n  var prevNode, fstToSwap, sndToSwap: TreeNode = _\\n\\n  def recoverTree(root: TreeNode): Unit = {\\n    prevNode = null\\n    fstToSwap = null\\n    sndToSwap = null\\n    \\n    inorderTraverse(root)\\n    \\n    val fstToSwapValue = fstToSwap.value\\n    fstToSwap.value = sndToSwap.value\\n    sndToSwap.value = fstToSwapValue\\n  }\\n  \\n  def inorderTraverse(root: TreeNode): Unit = {\\n    if (root != null) {\\n      inorderTraverse(root.left)\\n      \\n      if (prevNode != null && prevNode.value > root.value && fstToSwap == null) fstToSwap = prevNode\\n      if (prevNode != null && prevNode.value > root.value && fstToSwap != null) sndToSwap = root\\n\\n      prevNode = root\\n      \\n      inorderTraverse(root.right)\\n    }\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 187755,
                "title": "go-solution",
                "content": "```\\nfunc Swap(x, y *TreeNode) {\\n    x.Val, y.Val = y.Val, x.Val\\n}\\n\\nfunc Inorder(c chan *TreeNode, root *TreeNode) {\\n    if root == nil {\\n        return\\n    }\\n    Inorder(c, root.Left)\\n    c <- root\\n    Inorder(c, root.Right)\\n}\\n\\nfunc recoverTree(root *TreeNode) {\\n    c := make(chan *TreeNode)\\n    go func() {\\n        Inorder(c, root)\\n        close(c)\\n    }()\\n\\n    var first, second *TreeNode\\n    prev := <-c\\n    for x := range c {\\n        if x.Val < prev.Val {\\n            if first == nil {\\n                first = prev\\n            } \\n            if first != nil {\\n                second = x\\n            }\\n        }\\n        prev = x\\n    }\\n    Swap(first, second)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc Swap(x, y *TreeNode) {\\n    x.Val, y.Val = y.Val, x.Val\\n}\\n\\nfunc Inorder(c chan *TreeNode, root *TreeNode) {\\n    if root == nil {\\n        return\\n    }\\n    Inorder(c, root.Left)\\n    c <- root\\n    Inorder(c, root.Right)\\n}\\n\\nfunc recoverTree(root *TreeNode) {\\n    c := make(chan *TreeNode)\\n    go func() {\\n        Inorder(c, root)\\n        close(c)\\n    }()\\n\\n    var first, second *TreeNode\\n    prev := <-c\\n    for x := range c {\\n        if x.Val < prev.Val {\\n            if first == nil {\\n                first = prev\\n            } \\n            if first != nil {\\n                second = x\\n            }\\n        }\\n        prev = x\\n    }\\n    Swap(first, second)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32582,
                "title": "simple-python-solution-with-real-o-1-space-by-using-morris-traversal-with-comments",
                "content": "\\n    def recoverTree(self, root):\\n        cur, prev, first, second, predec = root, None, None, None, None\\n        while cur:\\n            if cur.left is None:  # I have no left child so it's my turn\\n                if predec is not None and cur.val < predec.val:\\n                    if not first:\\n                        first = predec\\n                    second = cur\\n                predec = cur\\n                cur = cur.right  # After visit, go right\\n            else:\\n                # I need to find my predecessor and make me its right child\\n                # Second check in right is to make sure that I don't loop\\n                prev = cur.left\\n                while prev.right is not None and prev.right != cur:\\n                    prev = prev.right\\n                if prev.right is None:  # Not visited yet\\n                    prev.right = cur\\n                    cur = cur.left\\n                else:  # It's my turn\\n                    if predec is not None and cur.val < predec.val:\\n                        if not first:\\n                            first = predec\\n                        second = cur\\n                    predec = cur\\n                    # I remove the link after having visited\\n                    prev.right = None\\n                    cur = cur.right\\n        first.val, second.val = second.val, first.val",
                "solutionTags": [],
                "code": "\\n    def recoverTree(self, root):\\n        cur, prev, first, second, predec = root, None, None, None, None\\n        while cur:\\n            if cur.left is None:  # I have no left child so it's my turn\\n                if predec is not None and cur.val < predec.val:\\n                    if not first:\\n                        first = predec\\n                    second = cur\\n                predec = cur\\n                cur = cur.right  # After visit, go right\\n            else:\\n                # I need to find my predecessor and make me its right child\\n                # Second check in right is to make sure that I don't loop\\n                prev = cur.left\\n                while prev.right is not None and prev.right != cur:\\n                    prev = prev.right\\n                if prev.right is None:  # Not visited yet\\n                    prev.right = cur\\n                    cur = cur.left\\n                else:  # It's my turn\\n                    if predec is not None and cur.val < predec.val:\\n                        if not first:\\n                            first = predec\\n                        second = cur\\n                    predec = cur\\n                    # I remove the link after having visited\\n                    prev.right = None\\n                    cur = cur.right\\n        first.val, second.val = second.val, first.val",
                "codeTag": "Python3"
            },
            {
                "id": 32604,
                "title": "18ms-java-solution-with-in-order-traversal-and-sorting-o-nlogn-time-and-o-n-space",
                "content": "    public class Solution {\\n        public void recoverTree(TreeNode root) {\\n            // in-order traversal of treenodes, followed by sorting and reassignment of values\\n            List<TreeNode> inorder = inorder(root);\\n            List<Integer> inorderNumbers = new ArrayList<Integer>();\\n            for (TreeNode node : inorder) {\\n                inorderNumbers.add(node.val);\\n            }\\n            inorderNumbers.sort(null);\\n            for (int i = 0; i < inorder.size(); i++) {\\n                inorder.get(i).val = inorderNumbers.get(i);\\n            }\\n        }\\n        \\n        private List<TreeNode> inorder (TreeNode root) {\\n            List<TreeNode> result = new ArrayList<TreeNode>();\\n            if (root == null) {\\n                return result;\\n            }\\n            result.addAll(inorder(root.left));\\n            result.add(root);\\n            result.addAll(inorder(root.right));\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void recoverTree(TreeNode root) {\\n            // in-order traversal of treenodes, followed by sorting and reassignment of values\\n            List<TreeNode> inorder = inorder(root);\\n            List<Integer> inorderNumbers = new ArrayList<Integer>();\\n            for (TreeNode node : inorder) {\\n                inorderNumbers.add(node.val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 32649,
                "title": "is-there-any-other-solution-which-doesn-t-apply-morris-traversal-to-satisfy-o-1-space-complexity",
                "content": "    // my solution is just applying the morris inorder traversal\\n    // O(2N) time complexity, O(1) space complexity\\n        \\n    TreeNode *first = NULL;\\n        TreeNode *second = NULL;\\n        TreeNode *previous = NULL;\\n        \\n        void recoverTree(TreeNode *root) {\\n            if (!root) return;\\n            previous = new TreeNode(INT_MIN);\\n            \\n            morris_inorder(root);\\n            int t = first->val;\\n            first->val = second->val;\\n            second->val = t;\\n        }\\n        \\n        void morris_inorder(TreeNode *root) {\\n            TreeNode *cur = root, *pre = NULL;\\n            \\n            while (cur) {\\n    \\t\\t    if (cur->left == NULL) {\\n    \\t\\t        if (cur->val <= previous->val && !first) first = previous;\\n    \\t\\t\\t    if (cur->val <= previous->val && first) second = cur;\\n    \\t\\t\\t    previous = cur;\\n    \\t\\t\\t    cur = cur->right;\\n     \\t\\t    }\\n     \\t\\t    else {\\n     \\t\\t\\t    // find the predecessor\\n     \\t\\t\\t    pre = cur->left;\\n     \\t\\t\\t    while (pre->right && pre->right != cur)\\n     \\t\\t\\t\\t    pre = pre->right;\\n    \\n     \\t\\t\\t    if (pre->right == NULL) {\\n     \\t\\t\\t\\t    // set the backtrace link\\n     \\t\\t\\t\\t    pre->right = cur;\\n     \\t\\t\\t\\t    cur = cur->left;\\n     \\t\\t\\t    }\\n     \\t\\t\\t    else {\\n     \\t\\t\\t        if (cur->val <= previous->val && !first) first = previous;\\n    \\t\\t\\t        if (cur->val <= previous->val && first) second = cur;\\n    \\t\\t\\t        previous = cur;\\n     \\t\\t\\t\\t    pre->right = NULL;\\n     \\t\\t\\t\\t    cur = cur->right;\\n     \\t\\t\\t    }\\n     \\t\\t    }\\n     \\t    }\\n        }",
                "solutionTags": [],
                "code": "    // my solution is just applying the morris inorder traversal\\n    // O(2N) time complexity, O(1) space complexity\\n        \\n    TreeNode *first = NULL;\\n        TreeNode *second = NULL;\\n        TreeNode *previous = NULL;\\n        \\n        void recoverTree(TreeNode *root) {\\n            if (!root) return;\\n            previous = new TreeNode(INT_MIN);\\n            \\n            morris_inorder(root);\\n            int t = first->val;\\n            first->val = second->val;\\n            second->val = t;\\n        }\\n        \\n        void morris_inorder(TreeNode *root) {\\n            TreeNode *cur = root, *pre = NULL;\\n            \\n            while (cur) {\\n    \\t\\t    if (cur->left == NULL) {\\n    \\t\\t        if (cur->val <= previous->val && !first) first = previous;\\n    \\t\\t\\t    if (cur->val <= previous->val && first) second = cur;\\n    \\t\\t\\t    previous = cur;\\n    \\t\\t\\t    cur = cur->right;\\n     \\t\\t    }\\n     \\t\\t    else {\\n     \\t\\t\\t    // find the predecessor\\n     \\t\\t\\t    pre = cur->left;\\n     \\t\\t\\t    while (pre->right && pre->right != cur)\\n     \\t\\t\\t\\t    pre = pre->right;\\n    \\n     \\t\\t\\t    if (pre->right == NULL) {\\n     \\t\\t\\t\\t    // set the backtrace link\\n     \\t\\t\\t\\t    pre->right = cur;\\n     \\t\\t\\t\\t    cur = cur->left;\\n     \\t\\t\\t    }\\n     \\t\\t\\t    else {\\n     \\t\\t\\t        if (cur->val <= previous->val && !first) first = previous;\\n    \\t\\t\\t        if (cur->val <= previous->val && first) second = cur;\\n    \\t\\t\\t        previous = cur;\\n     \\t\\t\\t\\t    pre->right = NULL;\\n     \\t\\t\\t\\t    cur = cur->right;\\n     \\t\\t\\t    }\\n     \\t\\t    }\\n     \\t    }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3758168,
                "title": "java-solution-with-inorder-traversal-beats-100",
                "content": "# Intuition\\n-  We will traverse the tree in inorder fashion and check whether previous node had value less than the root.\\n- If yes, than note both of them.\\n- After the traversal we  will simply, swap both the nodes.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n) (Stack space for recursion)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private TreeNode prev = null , first = null , sec = null;\\n    public void recoverTree(TreeNode root) {\\n        helper(root);\\n        swap(first , sec);\\n        return;\\n    }\\n    private void swap (TreeNode a , TreeNode b){\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n    private void helper (TreeNode root){\\n        if(root == null)\\n        return;\\n\\n        helper(root.left);\\n\\n        if(prev != null && prev.val > root.val){\\n            if(first == null)\\n                first = prev;\\n            sec = root;\\n        }\\n\\n        prev = root;\\n\\n        helper(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private TreeNode prev = null , first = null , sec = null;\\n    public void recoverTree(TreeNode root) {\\n        helper(root);\\n        swap(first , sec);\\n        return;\\n    }\\n    private void swap (TreeNode a , TreeNode b){\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n    private void helper (TreeNode root){\\n        if(root == null)\\n        return;\\n\\n        helper(root.left);\\n\\n        if(prev != null && prev.val > root.val){\\n            if(first == null)\\n                first = prev;\\n            sec = root;\\n        }\\n\\n        prev = root;\\n\\n        helper(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647453,
                "title": "easy-c-solution-inorder-efficient",
                "content": "# Intuition\\nSo the intuition here was that the inorder traversal of a binary search tree is always sorted . so if we find any element while traversing through the BST that it\\'s value is smaller than the previos node we visited we simple swap them until we traverse through the whole BST.\\n\\n# Approach\\nSo the basic approach here is maintaining four pointers previous , first, middle, last.\\ninitially the previous pointer holds the value of minimum integer value and others are null.\\nwhen we find the first elemnt we simply make it prev then if the value of root is less then previous means in inorder if the value is smaller of the enct elemnt while traversing through the bst it means it is not acceptaable and we will make it first violation into our code but that is not the end of the code , we keep traversing through the binary search tree to find the last violation and if we find last violation we simply swap first and last but if that is not the case we swap our first violation with middle elemnt whol violated the traversal.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity:O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private: \\n    TreeNode* prev;\\n    TreeNode* first;\\n    TreeNode* middle;\\n    TreeNode* last;\\n    private:\\n    void inorder( TreeNode* root){\\n        if(root==NULL) return;\\n        inorder( root->left);\\n        if( prev!=NULL && root->val < prev->val){\\n            if(first==NULL){\\n                first = prev;\\n                middle = root;\\n            }\\n            else last = root;\\n        }\\n        prev = root;\\n        inorder(root-> right);\\n    }\\npublic:\\n\\n    void recoverTree(TreeNode* root) {\\n        first = middle = last = NULL;\\n        prev = new TreeNode(INT_MIN);\\n        inorder(root);\\n         if( first && last){\\n            swap(first -> val, last->val);\\n        }\\n        \\n        else if( first && middle ){\\n            swap(first->val, middle-> val);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private: \\n    TreeNode* prev;\\n    TreeNode* first;\\n    TreeNode* middle;\\n    TreeNode* last;\\n    private:\\n    void inorder( TreeNode* root){\\n        if(root==NULL) return;\\n        inorder( root->left);\\n        if( prev!=NULL && root->val < prev->val){\\n            if(first==NULL){\\n                first = prev;\\n                middle = root;\\n            }\\n            else last = root;\\n        }\\n        prev = root;\\n        inorder(root-> right);\\n    }\\npublic:\\n\\n    void recoverTree(TreeNode* root) {\\n        first = middle = last = NULL;\\n        prev = new TreeNode(INT_MIN);\\n        inorder(root);\\n         if( first && last){\\n            swap(first -> val, last->val);\\n        }\\n        \\n        else if( first && middle ){\\n            swap(first->val, middle-> val);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519166,
                "title": "pure-o-1-solution-using-morris-traversal",
                "content": "# Approach\\n1) Initialise the previous, start, middle, and end pointers with null.\\n2) Use Morris Traversal to perform an inorder traversal.\\n3) Keep the first and last numbers that are not in ascending sequence, and the middle element is the number next to the first.\\n4) Swap first and last if there is a second (final) descending element; otherwise, swap first and mid.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode* prev = NULL, *first = NULL, *mid = NULL, *last = NULL;\\n        TreeNode* cur = root;\\n        while(cur){\\n            if(!cur -> left){\\n                if(prev and cur -> val < prev -> val){\\n                    if(!first){\\n                        first = prev;\\n                        mid = cur;\\n                    }\\n                    else last = cur;\\n                }\\n                prev = cur;\\n                cur = cur -> right;\\n            }\\n            else{\\n                TreeNode* temp = cur -> left;\\n                while(temp -> right and temp -> right != cur) temp = temp -> right;\\n                if(!temp -> right){\\n                    temp -> right = cur;\\n                    cur = cur -> left;\\n                }\\n                else{\\n                    temp -> right = NULL;\\n                    if(prev and cur -> val < prev -> val){\\n                        if(!first){\\n                            first = prev;\\n                            mid = cur;\\n                        }\\n                        else last = cur;\\n                    }\\n                    prev = cur;\\n                    cur = cur -> right;\\n                }\\n            }\\n        }\\n        if(first and last) swap(first -> val, last -> val);\\n        else if(first and mid) swap(first -> val, mid -> val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode* prev = NULL, *first = NULL, *mid = NULL, *last = NULL;\\n        TreeNode* cur = root;\\n        while(cur){\\n            if(!cur -> left){\\n                if(prev and cur -> val < prev -> val){\\n                    if(!first){\\n                        first = prev;\\n                        mid = cur;\\n                    }\\n                    else last = cur;\\n                }\\n                prev = cur;\\n                cur = cur -> right;\\n            }\\n            else{\\n                TreeNode* temp = cur -> left;\\n                while(temp -> right and temp -> right != cur) temp = temp -> right;\\n                if(!temp -> right){\\n                    temp -> right = cur;\\n                    cur = cur -> left;\\n                }\\n                else{\\n                    temp -> right = NULL;\\n                    if(prev and cur -> val < prev -> val){\\n                        if(!first){\\n                            first = prev;\\n                            mid = cur;\\n                        }\\n                        else last = cur;\\n                    }\\n                    prev = cur;\\n                    cur = cur -> right;\\n                }\\n            }\\n        }\\n        if(first and last) swap(first -> val, last -> val);\\n        else if(first and mid) swap(first -> val, mid -> val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187784,
                "title": "recover-binary-search-tree-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this problem, we need to recover the binary search tree by fixing two nodes that were swapped by mistake. The solution to this problem can be achieved in two steps. In the first step, we will find the two nodes that are swapped, and in the second step, we will swap the nodes.\\n\\nTo find the two nodes that are swapped, we will use Morris Inorder Traversal. Morris Inorder Traversal is a space-optimized inorder traversal algorithm that allows us to traverse the tree using constant space.\\n\\nAlgorithm:\\n\\n1. Initialize two pointers current and pre to root.\\n2. While current is not null, do the following:\\na. If the current node does not have a left child, then move to the right child of the current node.\\nb. Else, find the inorder predecessor of the current node, i.e., the rightmost node in the left subtree of the current node.\\ni. If the right child of the inorder predecessor is null, then set it to the current node and move to the left child of the current node.\\nii. If the right child of the inorder predecessor is current, then set it to null, check if the pre node is not null, and if pre.val > current.val, then update the second node as current. Also, if pre is not null, then set pre.right to null. Finally, move to the right child of the current node.\\n3. If second node is not null, then swap the values of the first and second nodes.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the number of nodes in the binary search tree.\\n\\n- Space complexity:\\nO(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        first, second, pre = None, None, None\\n        current = root\\n        \\n        while current is not None:\\n            if current.left is None:\\n                if pre is not None and pre.val > current.val:\\n                    if first is None:\\n                        first = pre\\n                    second = current\\n                pre = current\\n                current = current.right\\n            else:\\n                node = current.left\\n                while node.right is not None and node.right != current:\\n                    node = node.right\\n                if node.right is None:\\n                    node.right = current\\n                    current = current.left\\n                else:\\n                    node.right = None\\n                    if pre is not None and pre.val > current.val:\\n                        if first is None:\\n                            first = pre\\n                        second = current\\n                    pre = current\\n                    current = current.right\\n        \\n        if first is not None and second is not None:\\n            first.val, second.val = second.val, first.val\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        first, second, pre = None, None, None\\n        current = root\\n        \\n        while current is not None:\\n            if current.left is None:\\n                if pre is not None and pre.val > current.val:\\n                    if first is None:\\n                        first = pre\\n                    second = current\\n                pre = current\\n                current = current.right\\n            else:\\n                node = current.left\\n                while node.right is not None and node.right != current:\\n                    node = node.right\\n                if node.right is None:\\n                    node.right = current\\n                    current = current.left\\n                else:\\n                    node.right = None\\n                    if pre is not None and pre.val > current.val:\\n                        if first is None:\\n                            first = pre\\n                        second = current\\n                    pre = current\\n                    current = current.right\\n        \\n        if first is not None and second is not None:\\n            first.val, second.val = second.val, first.val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172286,
                "title": "c-brute-force-nlogn",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Depth-First Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfs(TreeNode* root, vector<int>& vec) {\\n        if(!root) return;\\n        dfs(root -> left, vec);\\n        vec.push_back(root -> val);\\n        dfs(root -> right, vec);\\n    }\\n    void in(TreeNode* root, vector<int>& vec, int &i) {\\n        if(!root) return;\\n        // i++;\\n        in(root -> left, vec, i);\\n        if(root -> val != vec[i]) root -> val = vec[i];\\n        i++;\\n        in(root -> right, vec, i);\\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        vector<int> vec;\\n        dfs(root, vec);\\n        sort(vec.begin(), vec.end());\\n        int i = 0;\\n        in(root, vec, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfs(TreeNode* root, vector<int>& vec) {\\n        if(!root) return;\\n        dfs(root -> left, vec);\\n        vec.push_back(root -> val);\\n        dfs(root -> right, vec);\\n    }\\n    void in(TreeNode* root, vector<int>& vec, int &i) {\\n        if(!root) return;\\n        // i++;\\n        in(root -> left, vec, i);\\n        if(root -> val != vec[i]) root -> val = vec[i];\\n        i++;\\n        in(root -> right, vec, i);\\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        vector<int> vec;\\n        dfs(root, vec);\\n        sort(vec.begin(), vec.end());\\n        int i = 0;\\n        in(root, vec, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034824,
                "title": "solution-using-inorder-traversal-explained-in-details",
                "content": "# Intuition\\nA major property of Binary Search Tree is that if you get the inorder traversal of the tree, the resultant array will be sorted. Therefore, to solve this question, we can traverse the tree in an inorder fashion to obtain the sorted array which will have exactly two elements swapped. Then we can traverse the tree again and fix the swapped elements.\\n\\n# Approach\\nWe do an inorder traversal of the tree. Run a loop on the resultant array to obtain the swapped elements and save then in two globally declared variables. Traverse the tree again and swap the elements when when encountered!\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int a, b;\\n\\n    void inorder(TreeNode*& root) {\\n        if (!root) \\n            return;\\n        \\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    void swap(TreeNode*& root) {\\n        if (!root) \\n            return;\\n        \\n        if (root->val == a)\\n            root->val = b;\\n        else if (root->val == b) \\n            root->val = a;\\n        \\n        swap(root->left);\\n        swap(root->right);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n\\n        for(int i = 0; i < v.size()-1; i++) {\\n            if (v[i] > v[i+1]) {\\n                a = v[i];\\n                break;\\n            }\\n        }\\n\\n        for(int i = v.size()-1; i > 0; i--) {\\n            if (v[i] < v[i-1]) {\\n                b = v[i];\\n                break;\\n            }\\n        }\\n\\n        swap(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int a, b;\\n\\n    void inorder(TreeNode*& root) {\\n        if (!root) \\n            return;\\n        \\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    void swap(TreeNode*& root) {\\n        if (!root) \\n            return;\\n        \\n        if (root->val == a)\\n            root->val = b;\\n        else if (root->val == b) \\n            root->val = a;\\n        \\n        swap(root->left);\\n        swap(root->right);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n\\n        for(int i = 0; i < v.size()-1; i++) {\\n            if (v[i] > v[i+1]) {\\n                a = v[i];\\n                break;\\n            }\\n        }\\n\\n        for(int i = v.size()-1; i > 0; i--) {\\n            if (v[i] < v[i-1]) {\\n                b = v[i];\\n                break;\\n            }\\n        }\\n\\n        swap(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796037,
                "title": "c-inorder-traversal",
                "content": "Please upvote if u like the solution\\n```\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root, vector<TreeNode*>& v) {\\n        if (root == NULL) return;\\n        inorderTraversal(root->left, v);\\n        v.push_back(root);\\n        inorderTraversal(root->right, v);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> v;\\n        inorderTraversal(root, v);\\n        pair<TreeNode*, TreeNode*> p{v[0], v.back()};\\n        for (int i = 1; i < v.size() - 1; ++ i ) {\\n            if (v[i]->val > v[i - 1]->val && v[i]->val > v[i + 1]->val && v[i - 1]->val < v[i + 1]->val) p.first = v[i];\\n            if (v[i]->val < v[i - 1]->val && v[i]->val < v[i + 1]->val && v[i - 1]->val < v[i + 1]->val) p.second = v[i];\\n        }\\n        swap(p.first->val, p.second->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root, vector<TreeNode*>& v) {\\n        if (root == NULL) return;\\n        inorderTraversal(root->left, v);\\n        v.push_back(root);\\n        inorderTraversal(root->right, v);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> v;\\n        inorderTraversal(root, v);\\n        pair<TreeNode*, TreeNode*> p{v[0], v.back()};\\n        for (int i = 1; i < v.size() - 1; ++ i ) {\\n            if (v[i]->val > v[i - 1]->val && v[i]->val > v[i + 1]->val && v[i - 1]->val < v[i + 1]->val) p.first = v[i];\\n            if (v[i]->val < v[i - 1]->val && v[i]->val < v[i + 1]->val && v[i - 1]->val < v[i + 1]->val) p.second = v[i];\\n        }\\n        swap(p.first->val, p.second->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674879,
                "title": "inorder-traversal-best-explanation-easy-java",
                "content": "\\n#### **Explanation:**\\nif two values are swapped then its inorder will be something like this\\n 2 3 4 **8** 6 7 **5**\\n\\nin this case \\n  - first element will always be greater than its next element (8>6)\\n  - second element will always be lesser than its prev element (5<7)\\n\\nusing this, we can mark first and second element during inorder traversal.\\nand then we will swap the value of these two nodes.\\n\\n#### **Solution:**\\n\\n```\\nclass Solution {\\n    TreeNode first=null;\\n    TreeNode second=null;\\n    TreeNode prev=new TreeNode(Integer.MIN_VALUE);\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        \\n\\t\\t// swap values\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n\\t\\t\\n        //mark first node\\n        if(first==null && prev.val>root.val)\\n            first=prev;\\n\\t\\t\\t\\n\\t\\t// mark second node\\n        if(first!=null && prev.val>root.val)\\n            second=root;\\n        \\n        prev=root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode first=null;\\n    TreeNode second=null;\\n    TreeNode prev=new TreeNode(Integer.MIN_VALUE);\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        \\n\\t\\t// swap values\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n\\t\\t\\n        //mark first node\\n        if(first==null && prev.val>root.val)\\n            first=prev;\\n\\t\\t\\t\\n\\t\\t// mark second node\\n        if(first!=null && prev.val>root.val)\\n            second=root;\\n        \\n        prev=root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668048,
                "title": "c-highly-commented-code-recursive-and-morris-both-free-meme",
                "content": "For complexity analysis and other stuff, **please** go [here](https://garmadon.notion.site/Recover-Binary-Search-Tree-f6bf43525e5a4a66be4c875e4740385d).\\n\\n**Recursive inorder traversal way**\\n```\\n//Global variables\\nTreeNode* firstNode = NULL;\\nTreeNode* secondNode = NULL;\\nTreeNode* prevNode = NULL;\\n\\n//Recursive inorder traversal to find the anomaly\\nvoid inorder(TreeNode* root)\\n{\\n    if(root != NULL)\\n    {\\n        inorder(root->left);\\n        \\n        //if this isn\\'t the first node you\\'re checking \\n        //and it\\'s value is less than prevNode, then \\n        //something\\'s fishy!\\n        if(prevNode != NULL and prevNode->val > root->val)\\n        {\\n            //if you haven\\'t found the first anomaly, then this is it!\\n            if(firstNode == NULL)\\n            firstNode = prevNode;\\n            \\n            //the current element may also be the anomaly\\n            secondNode = root;\\n        }\\n\\n        //update prevNode with the current node\\n        prevNode = root;\\n\\n        inorder(root->right);\\n    }\\n}\\n\\n//Program starts here\\nvoid recoverTree(TreeNode* root) \\n{\\n    //edge case - if 0 or 1 elements exist, return\\n    if(root == NULL or (root->left == NULL and root->right == NULL))\\n        return;        \\n\\n    //Search the BST using inorder traversal\\n    inorder(root);\\n\\n    //if there actually exists an anomaly... \\n    if(firstNode and secondNode)\\n        //...fix it\\n        swap(firstNode->val, secondNode->val);\\n}\\n```\\n\\n**Morris Inorder traversal way**\\n```\\n//Global variables\\nTreeNode* firstNode = NULL;\\nTreeNode* secondNode = NULL;\\nTreeNode* prevNode = NULL;\\n\\n//Program starts here\\nvoid recoverTree(TreeNode* root) \\n{\\n    //edge case - if 0 or 1 elements exist, return\\n    if(root == NULL or (root->left == NULL and root->right == NULL))\\n        return;        \\n\\n    //Search the BST using inorder traversal\\n    inorder(root);\\n\\n    //if there actually exists an anomaly... \\n    if(firstNode and secondNode)\\n        //...fix it\\n        swap(firstNode->val, secondNode->val);\\n}\\n\\n//-------------------------------\\n\\n//Inorder using Morris Traversal\\nvoid inorder(TreeNode* root) \\n{\\n    //Initialise a pointer to traverse the tree\\n    TreeNode* curr = root;\\n\\n    while(curr != NULL)\\n    {\\n        //if there\\'s no left subtree, all you need to do is...\\n        if(curr->left == NULL)\\n        {\\n            //...find anomalies and...\\n            findAnomaly(curr);\\n            //traverse the right subtree.\\n            curr = curr->right;\\n        }\\n        //But if there is a left subtree,\\n        else\\n        {\\n            //Create a new pointer on left subtree\\'s root, \\n            TreeNode* findRight = curr->left;\\n\\n            //and go to the extreme right, until you find NULL or \\n            //a thread (link) to curr\\n            while(findRight->right != NULL and findRight->right != curr)\\n            {\\n                findRight = findRight->right;\\n            }\\n\\n            //If the extreme right is a NULL, create a thread to curr, \\n            //because that\\'s where we\\'ll go after this subtree is traversed\\n            if(findRight->right == NULL)\\n            {\\n                //Create the thread (link) to curr\\n                findRight->right = curr;\\n                //Now curr can traverse the left subtree (safely, lol)\\n                curr = curr->left;\\n            }\\n            //If the extreme right was a link to curr, \\n            //the left subtree has already been visited\\n            else \\n            {\\n                //So remove the link to curr \\n                findRight->right = NULL;\\n                //Find anomalies\\n                findAnomaly(curr);\\n                //And start traversing the right subtree\\n                curr = curr->right;\\n            }\\n        }\\n    }        \\n}\\n\\nvoid findAnomaly(TreeNode* root)\\n{\\n    //if this isn\\'t the first node you\\'re checking \\n    //and it\\'s value is less than prevNode, then \\n    //something\\'s fishy!\\n    if(prevNode != NULL and prevNode->val > root->val)\\n    {\\n        //if you haven\\'t found the first anomaly, then this is it!\\n        if(firstNode == NULL)\\n        firstNode = prevNode;\\n        \\n        //the current element may also be the anomaly\\n        secondNode = root;\\n    }\\n\\n    //update prevNode with the current node\\n    prevNode = root;\\n}\\n```\\n\\nFREE MEME\\n![image](https://assets.leetcode.com/users/images/9f989468-842e-4389-a3b0-05ba669e6e6e_1665049640.0128303.png)\\n\\n*Don\\'t you illiterate people forget to upvote!*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//Global variables\\nTreeNode* firstNode = NULL;\\nTreeNode* secondNode = NULL;\\nTreeNode* prevNode = NULL;\\n\\n//Recursive inorder traversal to find the anomaly\\nvoid inorder(TreeNode* root)\\n{\\n    if(root != NULL)\\n    {\\n        inorder(root->left);\\n        \\n        //if this isn\\'t the first node you\\'re checking \\n        //and it\\'s value is less than prevNode, then \\n        //something\\'s fishy!\\n        if(prevNode != NULL and prevNode->val > root->val)\\n        {\\n            //if you haven\\'t found the first anomaly, then this is it!\\n            if(firstNode == NULL)\\n            firstNode = prevNode;\\n            \\n            //the current element may also be the anomaly\\n            secondNode = root;\\n        }\\n\\n        //update prevNode with the current node\\n        prevNode = root;\\n\\n        inorder(root->right);\\n    }\\n}\\n\\n//Program starts here\\nvoid recoverTree(TreeNode* root) \\n{\\n    //edge case - if 0 or 1 elements exist, return\\n    if(root == NULL or (root->left == NULL and root->right == NULL))\\n        return;        \\n\\n    //Search the BST using inorder traversal\\n    inorder(root);\\n\\n    //if there actually exists an anomaly... \\n    if(firstNode and secondNode)\\n        //...fix it\\n        swap(firstNode->val, secondNode->val);\\n}\\n```\n```\\n//Global variables\\nTreeNode* firstNode = NULL;\\nTreeNode* secondNode = NULL;\\nTreeNode* prevNode = NULL;\\n\\n//Program starts here\\nvoid recoverTree(TreeNode* root) \\n{\\n    //edge case - if 0 or 1 elements exist, return\\n    if(root == NULL or (root->left == NULL and root->right == NULL))\\n        return;        \\n\\n    //Search the BST using inorder traversal\\n    inorder(root);\\n\\n    //if there actually exists an anomaly... \\n    if(firstNode and secondNode)\\n        //...fix it\\n        swap(firstNode->val, secondNode->val);\\n}\\n\\n//-------------------------------\\n\\n//Inorder using Morris Traversal\\nvoid inorder(TreeNode* root) \\n{\\n    //Initialise a pointer to traverse the tree\\n    TreeNode* curr = root;\\n\\n    while(curr != NULL)\\n    {\\n        //if there\\'s no left subtree, all you need to do is...\\n        if(curr->left == NULL)\\n        {\\n            //...find anomalies and...\\n            findAnomaly(curr);\\n            //traverse the right subtree.\\n            curr = curr->right;\\n        }\\n        //But if there is a left subtree,\\n        else\\n        {\\n            //Create a new pointer on left subtree\\'s root, \\n            TreeNode* findRight = curr->left;\\n\\n            //and go to the extreme right, until you find NULL or \\n            //a thread (link) to curr\\n            while(findRight->right != NULL and findRight->right != curr)\\n            {\\n                findRight = findRight->right;\\n            }\\n\\n            //If the extreme right is a NULL, create a thread to curr, \\n            //because that\\'s where we\\'ll go after this subtree is traversed\\n            if(findRight->right == NULL)\\n            {\\n                //Create the thread (link) to curr\\n                findRight->right = curr;\\n                //Now curr can traverse the left subtree (safely, lol)\\n                curr = curr->left;\\n            }\\n            //If the extreme right was a link to curr, \\n            //the left subtree has already been visited\\n            else \\n            {\\n                //So remove the link to curr \\n                findRight->right = NULL;\\n                //Find anomalies\\n                findAnomaly(curr);\\n                //And start traversing the right subtree\\n                curr = curr->right;\\n            }\\n        }\\n    }        \\n}\\n\\nvoid findAnomaly(TreeNode* root)\\n{\\n    //if this isn\\'t the first node you\\'re checking \\n    //and it\\'s value is less than prevNode, then \\n    //something\\'s fishy!\\n    if(prevNode != NULL and prevNode->val > root->val)\\n    {\\n        //if you haven\\'t found the first anomaly, then this is it!\\n        if(firstNode == NULL)\\n        firstNode = prevNode;\\n        \\n        //the current element may also be the anomaly\\n        secondNode = root;\\n    }\\n\\n    //update prevNode with the current node\\n    prevNode = root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464305,
                "title": "java-recursion",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode a;\\n    TreeNode b;\\n    TreeNode prev = new TreeNode(Integer.MIN_VALUE);\\n\\n    void inorder(TreeNode root) {\\n        if (root == null)\\n            return;\\n        inorder(root.left);\\n        if (root.val < prev.val && a == null) {\\n            a = prev;\\n            b = root;\\n        } else if (root.val < prev.val && a != null) {\\n            b = root;\\n        }\\n        prev = root;\\n        inorder(root.right);\\n    }\\n\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode a;\\n    TreeNode b;\\n    TreeNode prev = new TreeNode(Integer.MIN_VALUE);\\n\\n    void inorder(TreeNode root) {\\n        if (root == null)\\n            return;\\n        inorder(root.left);\\n        if (root.val < prev.val && a == null) {\\n            a = prev;\\n            b = root;\\n        } else if (root.val < prev.val && a != null) {\\n            b = root;\\n        }\\n        prev = root;\\n        inorder(root.right);\\n    }\\n\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394811,
                "title": "c-o-n-time-o-1-space",
                "content": "* Assume we have been given a sorted array where only 2 elements are swapped and the array then becomes unsorted.\\n\\n* How to find the Two swapped elements ?? \\n\\n* We keep traversing the array and when the previous element becomes greater than next element, we can say there is a violation. **prev > next** and we store the index in some variable.\\n\\n* And When at some point in array , next violation occurs we store that position in some other variable.\\n\\n* In BST this behaviour can be achieved by keeping a `prev` pointer just behind the `root` pointer and checking the **violation condition**.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode *f  = nullptr , *s = nullptr , *prev = nullptr ;\\n    void solve(TreeNode * root){\\n        if(!root) return ;\\n        solve(root->left) ;\\n        if(!prev) prev = root ;\\n        else{\\n            if(prev ->val > root->val){\\n                if(!f) f = prev ;\\n                s = root ;\\n            }\\n        }\\n        prev = root ;\\n        \\n        solve(root->right) ;\\n        \\n    }\\n    void recoverTree(TreeNode* root) {\\n        solve(root) ;\\n        swap(f->val,s->val) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *f  = nullptr , *s = nullptr , *prev = nullptr ;\\n    void solve(TreeNode * root){\\n        if(!root) return ;\\n        solve(root->left) ;\\n        if(!prev) prev = root ;\\n        else{\\n            if(prev ->val > root->val){\\n                if(!f) f = prev ;\\n                s = root ;\\n            }\\n        }\\n        prev = root ;\\n        \\n        solve(root->right) ;\\n        \\n    }\\n    void recoverTree(TreeNode* root) {\\n        solve(root) ;\\n        swap(f->val,s->val) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346135,
                "title": "c-in-order-traversal-solution",
                "content": "1. Do the inorder traversal and store the the value in inorder.\\n2. sort the vector in increasing order, because BST inorder traversal is increasing.\\n3. Traverse the tree in inorder again, but this time change the value of node according to previously sorted array.\\n```c++\\nclass Solution {\\npublic:\\n\\t//This function will do the inorder traversal and store the value in vector v.\\n    void makeTree(TreeNode* root, vector<int>& v){\\n        if(!root) return;\\n        makeTree(root->left, v);\\n        v.push_back(root->val);\\n        makeTree(root->right, v);\\n    }\\n\\t//This function will change the value of old given BST according to sorted data value.\\n    void changeNodeVal(TreeNode* root, vector<int>::iterator& it){\\n        if(!root) return;\\n        changeNodeVal(root->left, it);\\n        root->val = *it; it++;\\n        changeNodeVal(root->right, it);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<int> v;\\n        makeTree(root, v);\\n        sort(v.begin(), v.end());\\n\\t\\t//creating & Passing vector iterator to the function so that we won\\'t lose the track.\\n        vector<int>::iterator it = v.begin();\\n        changeNodeVal(root, it);\\n        return;\\n    }\\n};\\n```\\n\\nIf you have any doubt or optimization, comment below.\\n**Upvote if found useful. plz :)**\\nThanks, have a nice day!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n\\t//This function will do the inorder traversal and store the value in vector v.\\n    void makeTree(TreeNode* root, vector<int>& v){\\n        if(!root) return;\\n        makeTree(root->left, v);\\n        v.push_back(root->val);\\n        makeTree(root->right, v);\\n    }\\n\\t//This function will change the value of old given BST according to sorted data value.\\n    void changeNodeVal(TreeNode* root, vector<int>::iterator& it){\\n        if(!root) return;\\n        changeNodeVal(root->left, it);\\n        root->val = *it; it++;\\n        changeNodeVal(root->right, it);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<int> v;\\n        makeTree(root, v);\\n        sort(v.begin(), v.end());\\n\\t\\t//creating & Passing vector iterator to the function so that we won\\'t lose the track.\\n        vector<int>::iterator it = v.begin();\\n        changeNodeVal(root, it);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345652,
                "title": "java-easy-understandable",
                "content": "```\\nclass Solution {\\n\\tTreeNode first = null;\\n\\tTreeNode second = null;\\n\\tTreeNode prev = null;\\n\\n\\tpublic void recoverTree(TreeNode root) {\\n\\t\\tinOrder(root);\\n\\t\\tif (first != null && second != null) {\\n\\t\\t\\tint temp = first.val;\\n\\t\\t\\tfirst.val = second.val;\\n\\t\\t\\tsecond.val = temp;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void inOrder(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tinOrder(root.left);\\n\\t\\tif (prev != null && root.val < prev.val) {\\n\\t\\t\\tif (first == null) {\\n\\t\\t\\t\\tfirst = prev;\\n\\t\\t\\t\\tsecond = root;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecond = root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprev = root;\\n\\t\\tinOrder(root.right);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tTreeNode first = null;\\n\\tTreeNode second = null;\\n\\tTreeNode prev = null;\\n\\n\\tpublic void recoverTree(TreeNode root) {\\n\\t\\tinOrder(root);\\n\\t\\tif (first != null && second != null) {\\n\\t\\t\\tint temp = first.val;\\n\\t\\t\\tfirst.val = second.val;\\n\\t\\t\\tsecond.val = temp;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void inOrder(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tinOrder(root.left);\\n\\t\\tif (prev != null && root.val < prev.val) {\\n\\t\\t\\tif (first == null) {\\n\\t\\t\\t\\tfirst = prev;\\n\\t\\t\\t\\tsecond = root;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecond = root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprev = root;\\n\\t\\tinOrder(root.right);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312758,
                "title": "java-optimizing-from-o-n-extra-space-to-o-1-excluding-call-stack",
                "content": "The question asks us to swap two values in a BST to make it valid.\\n##### But how do we know which elements are to be swapped?\\nAs we know the inorder traversal of a BST is in ascending order. We need to swap the first greatest element with the last smallest element.\\nFor eg. If we have our inorder traversal as: 5 2 3 4 1, we need to swap 5 and 1 such that 5 > 2 (first greatest element) and 4 > 1 (last smallest element)\\n\\nA very straight-forward approach will be storing the inorder traversal of the invalid BST provided to us in a List and then checking which elements are to be swapped.\\n\\n### Approach: \\n\\n```\\n    public void recoverTree(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        getInorderList(root, list);\\n\\n        int i = 1;\\n        Integer first = null, second = null; \\n\\n        // Getting the first largest element and last smallest element\\n        while (i < list.size()) {\\n            if (first == null && list.get(i - 1) > list.get(i))\\n                first = list.get(i - 1);\\n            if (first != null && list.get(i - 1) > list.get(i))\\n                second = list.get(i);\\n            \\n            i++;\\n        }\\n\\n        swapValues(root, first, second);\\n    }\\n    \\n    public void getInorderList(TreeNode root, List<Integer> list) {\\n        if (root == null)\\n            return;\\n\\n        getInorderList(root.left, list);\\n        list.add(root.val);\\n        getInorderList(root.right, list);\\n    }\\n\\n    // Swapping the values of the two nodes in BST\\n    public void swapValues(TreeNode root, Integer num1, Integer num2) {\\n        if (root == null)\\n            return;\\n\\n        if (root.val == num1) \\n            root.val = num2;\\n        else if (root.val == num2)\\n            root.val = num1;\\n\\n        swapValues(root.left, num1, num2);\\n        swapValues(root.right, num1, num2);\\n    }\\n```\\n\\t\\nThis approach is time consuming and it uses extra O(n) space, to further optimize it, we can directly keep track of first and second nodes to be swapped while inorder traversing.\\n\\n### Optimized Approach:\\n\\n```\\n    // First and second nodes\\'s values are to be swapped\\n    // Prev is used to compare current node to previous node\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    TreeNode prev = new TreeNode(Integer.MIN_VALUE);\\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tinorder(root);\\n\\n        // Swapping the values\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    public void inorder(TreeNode root) {\\n        if (root == null)\\n            return;\\n\\n        inorder(root.left);\\n\\n        // If first isn\\'t assigned we will make first equals to the greater value (prev)\\n        // If first is assigned we keep updating second to the smaller value (root)\\n        if (first == null && prev.val > root.val)\\n            first = prev;\\n        if (first != null && prev.val > root.val)\\n            second = root;\\n\\n        prev = root;\\n\\n        inorder(root.right);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n    public void recoverTree(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        getInorderList(root, list);\\n\\n        int i = 1;\\n        Integer first = null, second = null; \\n\\n        // Getting the first largest element and last smallest element\\n        while (i < list.size()) {\\n            if (first == null && list.get(i - 1) > list.get(i))\\n                first = list.get(i - 1);\\n            if (first != null && list.get(i - 1) > list.get(i))\\n                second = list.get(i);\\n            \\n            i++;\\n        }\\n\\n        swapValues(root, first, second);\\n    }\\n    \\n    public void getInorderList(TreeNode root, List<Integer> list) {\\n        if (root == null)\\n            return;\\n\\n        getInorderList(root.left, list);\\n        list.add(root.val);\\n        getInorderList(root.right, list);\\n    }\\n\\n    // Swapping the values of the two nodes in BST\\n    public void swapValues(TreeNode root, Integer num1, Integer num2) {\\n        if (root == null)\\n            return;\\n\\n        if (root.val == num1) \\n            root.val = num2;\\n        else if (root.val == num2)\\n            root.val = num1;\\n\\n        swapValues(root.left, num1, num2);\\n        swapValues(root.right, num1, num2);\\n    }\\n```\n```\\n    // First and second nodes\\'s values are to be swapped\\n    // Prev is used to compare current node to previous node\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    TreeNode prev = new TreeNode(Integer.MIN_VALUE);\\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tinorder(root);\\n\\n        // Swapping the values\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    public void inorder(TreeNode root) {\\n        if (root == null)\\n            return;\\n\\n        inorder(root.left);\\n\\n        // If first isn\\'t assigned we will make first equals to the greater value (prev)\\n        // If first is assigned we keep updating second to the smaller value (root)\\n        if (first == null && prev.val > root.val)\\n            first = prev;\\n        if (first != null && prev.val > root.val)\\n            second = root;\\n\\n        prev = root;\\n\\n        inorder(root.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086394,
                "title": "c-inorder",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* prev = NULL;\\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        if(!first && prev && prev->val >= root->val) first = prev;\\n        if(first && prev->val >= root->val) second = root;\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        int temp = first->val;\\n        first->val = second->val;\\n        second->val = temp;\\n    }\\n};\\n// please upvote if you like\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* prev = NULL;\\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        if(!first && prev && prev->val >= root->val) first = prev;\\n        if(first && prev->val >= root->val) second = root;\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        int temp = first->val;\\n        first->val = second->val;\\n        second->val = temp;\\n    }\\n};\\n// please upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989317,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n    TreeNode prev = null, first = null, second = null;\\n\\n    public void recoverTree(TreeNode root) {\\n        evalSwappedNodes(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\n    private void evalSwappedNodes(TreeNode curr) {\\n        if (curr == null)\\n            return;\\n        evalSwappedNodes(curr.left);\\n        if (prev != null && prev.val > curr.val) {\\n            if (first == null)\\n                first = prev;\\n            second = curr;\\n        }\\n        prev = curr;\\n        evalSwappedNodes(curr.right);\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\tfirstMistake = pre;\\n\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\tsecondMistake = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```\\n\\n***Python***\\n```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n        in_order = []\\n        def inOrder(node):\\n            if node is None:\\n                return\\n            inOrder(node.left)\\n            in_order.append(node)\\n            inOrder(node.right)\\n        \\n        inOrder(root)\\n\\n        sorted_order = sorted(in_order, key=lambda x:x.val)\\n        for i in range(len(in_order)):\\n            if in_order[i] != sorted_order[i]:\\n                in_order[i].val, sorted_order[i].val = sorted_order[i].val, in_order[i].val\\n                return\\n```\\n\\n***JavaScript***\\n```\\nvar recoverTree = function(root) {\\n    let pre = null, n1 = null, n2 = null\\n    \\n    const dfs = (root) => {\\n        if (!root) return\\n        dfs(root.left)\\n        if (pre && pre.val > root.val) {\\n            n2 = root\\n            if (!n1) n1 = pre\\n        }\\n        pre = root\\n        dfs(root.right)\\n    }\\n    \\n    dfs(root)\\n    swap(n1, n2)\\n};\\n\\nconst swap = (n1, n2) => [n1.val, n2.val] = [n2.val, n1.val]\\n```\\n\\n***Kotlin***\\n```\\n  class Solution {\\n\\n  fun recoverTree(root: TreeNode?): Unit {\\n    var first: TreeNode? = null\\n    var second: TreeNode? = null\\n    var pre: TreeNode = TreeNode(Int.MIN_VALUE)\\n\\n    fun traverse(node: TreeNode?){\\n        if (node == null) return\\n        traverse(node.left)\\n\\n        if (first == null && pre.`val` > node.`val`){\\n            first = pre\\n        }\\n        if (first != null && pre.`val` > node.`val`){\\n            second = node\\n        }\\n        pre = node\\n\\n        traverse(node.right)\\n    }\\n    traverse(root)\\n    val temp = first!!.`val`\\n    first!!.`val` = second!!.`val`\\n    second!!.`val` = temp\\n\\t}\\n\\t}\\n```\\n\\n***Swift***\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(h), where h is the height of the binary tree.\\n\\n    private var first: TreeNode?\\n    private var second: TreeNode?\\n    private var prev = TreeNode(Int.min)\\n\\n    \\n    func recoverTree(_ root: TreeNode?) {\\n        traverse(root)\\n\\n        guard let first = first, let second = second else { return }\\n\\n        let tmp = first.val\\n        first.val = second.val\\n        second.val = tmp\\n    }\\n\\n\\n    private func traverse(_ root: TreeNode?) {\\n        guard let root = root else { return }\\n        traverse(root.left)\\n\\n        if first == nil, prev.val >= root.val { first = prev }\\n        if first != nil, prev.val >= root.val { second = root }\\n        prev = root\\n\\n        traverse(root.right)\\n    }\\n\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***\\n***\"Open your eyes.\"***",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev = null, first = null, second = null;\\n\\n    public void recoverTree(TreeNode root) {\\n        evalSwappedNodes(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\n    private void evalSwappedNodes(TreeNode curr) {\\n        if (curr == null)\\n            return;\\n        evalSwappedNodes(curr.left);\\n        if (prev != null && prev.val > curr.val) {\\n            if (first == null)\\n                first = prev;\\n            second = curr;\\n        }\\n        prev = curr;\\n        evalSwappedNodes(curr.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\tfirstMistake = pre;\\n\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\tsecondMistake = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```\n```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n        in_order = []\\n        def inOrder(node):\\n            if node is None:\\n                return\\n            inOrder(node.left)\\n            in_order.append(node)\\n            inOrder(node.right)\\n        \\n        inOrder(root)\\n\\n        sorted_order = sorted(in_order, key=lambda x:x.val)\\n        for i in range(len(in_order)):\\n            if in_order[i] != sorted_order[i]:\\n                in_order[i].val, sorted_order[i].val = sorted_order[i].val, in_order[i].val\\n                return\\n```\n```\\nvar recoverTree = function(root) {\\n    let pre = null, n1 = null, n2 = null\\n    \\n    const dfs = (root) => {\\n        if (!root) return\\n        dfs(root.left)\\n        if (pre && pre.val > root.val) {\\n            n2 = root\\n            if (!n1) n1 = pre\\n        }\\n        pre = root\\n        dfs(root.right)\\n    }\\n    \\n    dfs(root)\\n    swap(n1, n2)\\n};\\n\\nconst swap = (n1, n2) => [n1.val, n2.val] = [n2.val, n1.val]\\n```\n```\\n  class Solution {\\n\\n  fun recoverTree(root: TreeNode?): Unit {\\n    var first: TreeNode? = null\\n    var second: TreeNode? = null\\n    var pre: TreeNode = TreeNode(Int.MIN_VALUE)\\n\\n    fun traverse(node: TreeNode?){\\n        if (node == null) return\\n        traverse(node.left)\\n\\n        if (first == null && pre.`val` > node.`val`){\\n            first = pre\\n        }\\n        if (first != null && pre.`val` > node.`val`){\\n            second = node\\n        }\\n        pre = node\\n\\n        traverse(node.right)\\n    }\\n    traverse(root)\\n    val temp = first!!.`val`\\n    first!!.`val` = second!!.`val`\\n    second!!.`val` = temp\\n\\t}\\n\\t}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(h), where h is the height of the binary tree.\\n\\n    private var first: TreeNode?\\n    private var second: TreeNode?\\n    private var prev = TreeNode(Int.min)\\n\\n    \\n    func recoverTree(_ root: TreeNode?) {\\n        traverse(root)\\n\\n        guard let first = first, let second = second else { return }\\n\\n        let tmp = first.val\\n        first.val = second.val\\n        second.val = tmp\\n    }\\n\\n\\n    private func traverse(_ root: TreeNode?) {\\n        guard let root = root else { return }\\n        traverse(root.left)\\n\\n        if first == nil, prev.val >= root.val { first = prev }\\n        if first != nil, prev.val >= root.val { second = root }\\n        prev = root\\n\\n        traverse(root.right)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963268,
                "title": "c-o-1-space-solution-w-full-explanations",
                "content": "**Case 1**: When both faulty node are not consecutive then swap( a with c) . Because bigger value must have \\ngone to array starting(a ) and smaller value(c) must have come to array ending side.\\n{ ![image](https://assets.leetcode.com/users/images/e3288207-2d6c-4d1f-ab40-80b282c16ada_1650358332.8541582.png)\\n\\n**Case 2**: When both faulty nodes are consecutive , all you need to do is swap both nodes value.\\n![image](https://assets.leetcode.com/users/images/56bacd50-4531-404a-8ecb-358711053a92_1650358332.8427744.png)\\t\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t//first and second fault in an inorder sorted arrray\\n\\t\\tTreeNode *f=NULL,*s=NULL;\\n\\t\\tTreeNode *prev=new TreeNode(INT_MIN);\\n\\t\\tvoid help(TreeNode *root,TreeNode *parent)\\n\\t\\t{\\n\\t\\t\\tif(root){\\n\\t\\t\\t\\thelp(root->left,root);\\n\\t\\t\\t\\tif(root->val<prev->val){\\n\\t\\t\\t\\t\\tif(f==s)\\n\\t\\t\\t\\t\\t\\tf=prev;\\n\\t\\t\\t\\t\\t\\ts=root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\ts=root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev=root;\\n\\t\\t\\t\\thelp(root->right,root);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid recoverTree(TreeNode* root) {\\n\\t\\t\\thelp(root,nullptr);\\n\\t\\t\\tswap(f->val,s->val);\\n\\t\\t}\\n\\t};\\n\\t\\nPlease **Upvote** IF It was **helpful** !\\t",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t//first and second fault in an inorder sorted arrray\\n\\t\\tTreeNode *f=NULL,*s=NULL;\\n\\t\\tTreeNode *prev=new TreeNode(INT_MIN);\\n\\t\\tvoid help(TreeNode *root,TreeNode *parent)\\n\\t\\t{\\n\\t\\t\\tif(root){\\n\\t\\t\\t\\thelp(root->left,root);\\n\\t\\t\\t\\tif(root->val<prev->val){\\n\\t\\t\\t\\t\\tif(f==s)\\n\\t\\t\\t\\t\\t\\tf=prev;\\n\\t\\t\\t\\t\\t\\ts=root;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1963094,
                "title": "python-inorder-solution-very-simple",
                "content": "We first get all the contents of a input BST using inorder traversal and store the contents in the list named as \"dfs\".\\n\\nIf you have noticed, then you would know that the inorder traversal of a BST is always sorted. So inorder to recover our original(correct) BST, we need to sort the list dfs.\\nNow we have to change the values of input BST. i.e we have to insert the sorted values into the tree. We do this by using same inorder travesal.\\nAnd all the stuff is done. No fancy alogirthm.Just 2 inorder traversal. \\n\\n(You could also avoid writing the same inorder function twice by passing the two differnt smaller functions for getting and inserting. refer to the first comment. Thanks to Tom.)\\n\\n```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        dfs = []\\n        def inorder(root):\\n            \\n            if not root: return root\\n            inorder(root.left)\\n            dfs.append(root.val)\\n            inorder(root.right)\\n            \\n            \\n        inorder(root)\\n        dfs.sort()\\n        \\n        def inorder2(root):\\n            if not root: return root\\n            inorder2(root.left)\\n            root.val = dfs.pop(0)\\n            inorder2(root.right)\\n        \\n        inorder2(root)\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        dfs = []\\n        def inorder(root):\\n            \\n            if not root: return root\\n            inorder(root.left)\\n            dfs.append(root.val)\\n            inorder(root.right)\\n            \\n            \\n        inorder(root)\\n        dfs.sort()\\n        \\n        def inorder2(root):\\n            if not root: return root\\n            inorder2(root.left)\\n            root.val = dfs.pop(0)\\n            inorder2(root.right)\\n        \\n        inorder2(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1962956,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    vector<TreeNode*>t;\\n    void inorder(TreeNode *root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        t.push_back(root);\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        TreeNode *first,*mid,*last;\\n        first=mid=last=NULL;\\n        for(int i=0;i<t.size()-1;i++)\\n        {\\n            if(!first && t[i]->val>t[i+1]->val)\\n            {\\n                first=t[i];\\n                mid=t[i+1];\\n            }\\n            else if(t[i]->val>t[i+1]->val)\\n            {\\n                last=t[i+1];\\n            }\\n        }\\n        if(first && last)\\n            swap(first->val,last->val);\\n        else if(first && mid)\\n            swap(first->val,mid->val);\\n    }\\n};",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<TreeNode*>t;\\n    void inorder(TreeNode *root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        t.push_back(root);\\n        inorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1962779,
                "title": "o-n-time-o-h-space-c",
                "content": "The idea is simple: When you do inorder traversal, you should going up (increasing) normally. If you notice going down, then something is off. \\nO(H) space is because of the recursion stack.\\n```\\nclass Solution {\\n    TreeNode *n1{nullptr}, *n2{nullptr}, *lastnode{nullptr}; //n1: first anomly, n2: second anomly, lastnode: last visited node\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        swap(n1->val, n2->val);\\n    }\\n    \\n    void inorder(TreeNode* root){\\n        if(not root) return;\\n        inorder(root->left);\\n        if(lastnode and root->val < lastnode->val){\\n            if(n1) {\\n                n2 = root;\\n                return;\\n            }\\n            else //first anomly. Let n2 be current root first, in case it is ajacent swap\\n                n1 = lastnode, n2 = root;\\n        }\\n        lastnode = root;\\n        inorder(root->right);\\n    }\\n};\\n```\\nYou can check [Morris  Traversal](https://leetcode.com/problems/recover-binary-search-tree/discuss/1964374/O(1)-space-oror-O(n)-time-oror-Morris-traversal) for a true O(1) space solution. Although the difference is pretty small for the samples used here, after testing. (I guess tree provided are quite balanced)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode *n1{nullptr}, *n2{nullptr}, *lastnode{nullptr}; //n1: first anomly, n2: second anomly, lastnode: last visited node\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        swap(n1->val, n2->val);\\n    }\\n    \\n    void inorder(TreeNode* root){\\n        if(not root) return;\\n        inorder(root->left);\\n        if(lastnode and root->val < lastnode->val){\\n            if(n1) {\\n                n2 = root;\\n                return;\\n            }\\n            else //first anomly. Let n2 be current root first, in case it is ajacent swap\\n                n1 = lastnode, n2 = root;\\n        }\\n        lastnode = root;\\n        inorder(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962490,
                "title": "simple-and-efficient-java-o-n-solution",
                "content": "The Solution is Based on a observation that,\\n1. Since Inorder traversal gives sorted order, so we start looking from smaller values to larger values and hence we first get bigger part of the swapped integers\\n2. once we get the bigger part that is when x,y,z and x<y and y>z then we are sure that we need to remove y from this position\\n3. Henceforth we start finding a smaller value \\n```\\n\\nclass Solution {\\n    TreeNode big,small,prev;\\n    public void recoverTree(TreeNode root) {\\n        big=null;small=null;prev=null;\\n        rec(root);\\n        if(big!=null && small!=null){\\n            int temp=big.val;\\n            big.val=small.val;\\n            small.val=temp;     \\n        }\\n    }\\n    \\n    private void rec(TreeNode root){\\n        if(root==null) return ;\\n        rec(root.left);\\n        if(big!=null){\\n            if(small==null && root.val>big.val) big=root;\\n            else if(small!=null && root.val<small.val){\\n                small=root;\\n            }else if(small==null && root.val<prev.val){\\n                small=root;\\n            }\\n        }else{\\n            big=root;\\n        }\\n        prev=root;\\n        rec(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    TreeNode big,small,prev;\\n    public void recoverTree(TreeNode root) {\\n        big=null;small=null;prev=null;\\n        rec(root);\\n        if(big!=null && small!=null){\\n            int temp=big.val;\\n            big.val=small.val;\\n            small.val=temp;     \\n        }\\n    }\\n    \\n    private void rec(TreeNode root){\\n        if(root==null) return ;\\n        rec(root.left);\\n        if(big!=null){\\n            if(small==null && root.val>big.val) big=root;\\n            else if(small!=null && root.val<small.val){\\n                small=root;\\n            }else if(small==null && root.val<prev.val){\\n                small=root;\\n            }\\n        }else{\\n            big=root;\\n        }\\n        prev=root;\\n        rec(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962486,
                "title": "python-simple-morris-space-o-1",
                "content": "We can use Morris Traversal which takes space **O(1)**. We will be using inorder variant to go through the BST in increasing order.\\n\\n```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"                \\n        curr, prev, a, b = root, None, None, None        \\n        while curr:\\n            if not curr.left:   \\n\\t\\t\\t\\t# find the node that is violating the ordering \\n                if prev and curr.val < prev.val:\\t\\t\\t\\t\\t\\n                    if not a: # find the first node to swap\\n                        a = prev\\n                    b = curr                   \\n                prev = curr\\n                curr = curr.right                \\n            else:\\n                temp = curr.left\\n                while temp.right and temp.right is not curr:\\n                    temp = temp.right\\n                if temp.right is curr:\\n                    temp.right = None \\n                    if prev and curr.val < prev.val:\\n                        if not a:\\n                            a = prev\\n                        b = curr   \\n                    prev = curr\\n                    curr = curr.right\\n                else:\\n                    temp.right = curr\\n                    curr = curr.left\\n\\n\\t\\t# swap bide values\\n        a.val,b.val = b.val, a.val\\n```\\n\\n**Time = O(N) - Iterate through all nodes\\nSpace = O(1)**\\n\\n---\\n***Please upvote if you find it useful. Also feel free to share your thoughts in comments*.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"                \\n        curr, prev, a, b = root, None, None, None        \\n        while curr:\\n            if not curr.left:   \\n\\t\\t\\t\\t# find the node that is violating the ordering \\n                if prev and curr.val < prev.val:\\t\\t\\t\\t\\t\\n                    if not a: # find the first node to swap\\n                        a = prev\\n                    b = curr                   \\n                prev = curr\\n                curr = curr.right                \\n            else:\\n                temp = curr.left\\n                while temp.right and temp.right is not curr:\\n                    temp = temp.right\\n                if temp.right is curr:\\n                    temp.right = None \\n                    if prev and curr.val < prev.val:\\n                        if not a:\\n                            a = prev\\n                        b = curr   \\n                    prev = curr\\n                    curr = curr.right\\n                else:\\n                    temp.right = curr\\n                    curr = curr.left\\n\\n\\t\\t# swap bide values\\n        a.val,b.val = b.val, a.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962414,
                "title": "c-fast-easy-inordertraversal-explained",
                "content": "In the question, we do inorder traversal and find out the wrong placed numbers and there are two cases for that:\\n(i) both nodes are adjacent and hence there wont be third number wrong placed.\\n(ii)otherwise, if a number is misplaced, it\\'s next element will also seem to be mispalced as we\\'re checking with parent node. hence we store both parent and root as first and middle.\\n\\nWe\\'ll swap first and last if both nodes are separated or will swap first and middle if both nodes are adjacent.\\n#HareKrishna!\\n\\n```\\nclass Solution {\\n    #define Node TreeNode\\n    Node*prev;\\n    Node*first;\\n    Node*middle;\\n    Node*last;\\n    void solve(Node*root)\\n    {\\n        if(root==NULL)\\n            return;\\n        solve(root->left);\\n        if(root->val<prev->val)\\n        {\\n            if(first==NULL)\\n            {\\n                first=prev;\\n                middle=root;\\n            }\\n            else\\n            {\\n                last=root;\\n            }\\n        }\\n        prev=root;\\n        solve(root->right);\\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        first=middle=last=NULL;\\n        prev=new Node(INT_MIN); //keeps track of parent node\\n        solve(root);\\n        if(first&&last)\\n        {\\n            swap(first->val,last->val);\\n        }\\n        else\\n            swap(first->val,middle->val);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    #define Node TreeNode\\n    Node*prev;\\n    Node*first;\\n    Node*middle;\\n    Node*last;\\n    void solve(Node*root)\\n    {\\n        if(root==NULL)\\n            return;\\n        solve(root->left);\\n        if(root->val<prev->val)\\n        {\\n            if(first==NULL)\\n            {\\n                first=prev;\\n                middle=root;\\n            }\\n            else\\n            {\\n                last=root;\\n            }\\n        }\\n        prev=root;\\n        solve(root->right);\\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        first=middle=last=NULL;\\n        prev=new Node(INT_MIN); //keeps track of parent node\\n        solve(root);\\n        if(first&&last)\\n        {\\n            swap(first->val,last->val);\\n        }\\n        else\\n            swap(first->val,middle->val);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734486,
                "title": "using-inorder-traversal-and-then-sorting-elements",
                "content": "If we do traversal(here inorder) in the tree and store the values in an arraylist and sort the arraylist, we can get the right tree after inserting the sorted values in the tree again by inorder traversal.\\n```\\n//Doing inorderTraversal in the tree and then storing it in an arraylist and then sorting the list and again inserting the sorted values in the tree by doing inorder traversal.\\nclass Solution {\\n    ArrayList<Integer> list=new ArrayList<>();\\n    int count=0;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        Collections.sort(list); // Sorting the list \\n        insertinorder(root);\\n        \\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val); // Adding to the list\\n        inorder(root.right);\\n    }\\n\\tpublic void insertinorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        insertinorder(root.left);\\n        root.val=list.get(count); // Changing the value of the node as per the sorted list\\n        count++;\\n        insertinorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Doing inorderTraversal in the tree and then storing it in an arraylist and then sorting the list and again inserting the sorted values in the tree by doing inorder traversal.\\nclass Solution {\\n    ArrayList<Integer> list=new ArrayList<>();\\n    int count=0;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        Collections.sort(list); // Sorting the list \\n        insertinorder(root);\\n        \\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val); // Adding to the list\\n        inorder(root.right);\\n    }\\n\\tpublic void insertinorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        insertinorder(root.left);\\n        root.val=list.get(count); // Changing the value of the node as per the sorted list\\n        count++;\\n        insertinorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680987,
                "title": "c-in-order-traversal-only-3-extra-treenode",
                "content": "````\\nclass Solution {\\npublic:\\n    TreeNode* prev;\\n    TreeNode* x;\\n    TreeNode* y;\\n    void bfs(TreeNode* root){\\n        if(!root) return;\\n        bfs(root->left); // for in-order traversal: 1) left, 2) visit, 3) right\\n        \\n        if(prev && prev->val > root->val){\\n            if(!x){ // it is the first time we meet an unsorted value\\n                x = prev;\\n                y = root;\\n            } \\n            else if(x){ // if there is a second time it means we have to update the node\\n                y = root; \\n                return; // there are no more unsorted nodes, so we can exit\\n            } \\n        }\\n        prev = root;\\n        \\n        bfs(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        bfs(root); // by in-order traversal we go through the tree in a sorted order\\n        swap(x->val,y->val); // swap the values which make the tree unsorted\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* prev;\\n    TreeNode* x;\\n    TreeNode* y;\\n    void bfs(TreeNode* root){\\n        if(!root) return;\\n        bfs(root->left); // for in-order traversal: 1) left, 2) visit, 3) right\\n        \\n        if(prev && prev->val > root->val){\\n            if(!x){ // it is the first time we meet an unsorted value\\n                x = prev;\\n                y = root;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1529163,
                "title": "c-solution",
                "content": "```\\n    \\n    private TreeNode firstNode = null;\\n    private TreeNode secondNode = null;\\n    private TreeNode prev = new TreeNode(Int32.MinValue);\\n    \\n    public void RecoverTree(TreeNode root) {\\n        \\n        if(root == null)\\n            return;\\n        \\n        dfs(root);        \\n        int tmp = firstNode.val;\\n        firstNode.val = secondNode.val;\\n        secondNode.val = tmp;\\n    }\\n    \\n    private void dfs(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        dfs(root.left);\\n        \\n        if(firstNode == null && root.val < prev.val)\\n            firstNode = prev;\\n        \\n        if(firstNode != null && root.val < prev.val)\\n            secondNode = root;\\n        \\n        prev = root;\\n        \\n        dfs(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    \\n    private TreeNode firstNode = null;\\n    private TreeNode secondNode = null;\\n    private TreeNode prev = new TreeNode(Int32.MinValue);\\n    \\n    public void RecoverTree(TreeNode root) {\\n        \\n        if(root == null)\\n            return;\\n        \\n        dfs(root);        \\n        int tmp = firstNode.val;\\n        firstNode.val = secondNode.val;\\n        secondNode.val = tmp;\\n    }\\n    \\n    private void dfs(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        dfs(root.left);\\n        \\n        if(firstNode == null && root.val < prev.val)\\n            firstNode = prev;\\n        \\n        if(firstNode != null && root.val < prev.val)\\n            secondNode = root;\\n        \\n        prev = root;\\n        \\n        dfs(root.right);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1507268,
                "title": "c-easy-to-understand-2-methods-o-1-space",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Time complexity O(N)\\nspace complexity O(N)**\\n```\\nclass Solution {\\npublic:\\n    TreeNode *first=NULL,*second=NULL;\\n    TreeNode* prev=new TreeNode(INT_MIN);\\n    void inorder(TreeNode* root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,v);\\n        if(first==NULL&&prev->val>root->val)\\n        first=prev;\\n        if(first!=NULL&&prev->val>root->val)\\n        second=root;\\n        prev=root;\\n        inorder(root->right,v);\\n    }    \\n    void recoverTree(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root,v);\\n        int temp=second->val;\\n        second->val=first->val;\\n        first->val=temp;\\n    }\\n};\\n```\\n**Time complexity O(N)\\nSpace complexity O(1)**\\n```\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *first=NULL,*second=NULL;\\n    TreeNode* prev=new TreeNode(INT_MIN);\\n    void inorder(TreeNode* root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,v);\\n        if(first==NULL&&prev->val>root->val)\\n        first=prev;\\n        if(first!=NULL&&prev->val>root->val)\\n        second=root;\\n        prev=root;\\n        inorder(root->right,v);\\n    }    \\n    void recoverTree(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root,v);\\n        int temp=second->val;\\n        second->val=first->val;\\n        first->val=temp;\\n    }\\n};\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466747,
                "title": "c-super-simple-and-clean",
                "content": "///2 Nodes of a BST are swapped by mistake. Recover the BST by reverse swapping those swapped nodes.\\n    /// Solution: Since BST Inorder traversal gives elements in increasing order, we can traverse bst in inorder and look \\n    /// for nodes which violates the increasing order.\\n    /// We just have to find and swap the violating keys\\n    /// \\n    /// There can be 2 cases.\\n    /// Case 1: When adjucent nodes are swapped  i.e. eg: 1,2,4,3,5,6\\n    ///  In this case we get only one violation (3) and that and it\\'s previous (4) needed to be swapped.\\n    ///  i.e. swap 4 and 3 and we get 1,2,3,4,5,6\\n    ///  \\n    /// Case 2: When non adjucent nodes are swapped i.e. eg: 1,6,3,4,5,2  {6 and 2 are swapped}\\n    /// Then first violation\\'s = 3\\n    /// 2nd violation = 2\\n    /// Swap previous of first violation with 2nd violation\\n    /// and we get 1,2,3,4,5,6\\n```\\n\\npublic class Solution {\\n    public void RecoverTree(TreeNode root) {\\n            TreeNode First = null;\\n            TreeNode Second = null;\\n            TreeNode Prev = null;\\n            InOrder(root,ref First,ref Second,ref Prev);\\n        \\n            var a = First.val;\\n            First.val = Second.val;\\n            Second.val = a;\\n    }\\n    public static void InOrder(TreeNode root, ref TreeNode First, ref TreeNode Second, ref TreeNode Prev)\\n        {\\n            if (root == null) return;\\n            InOrder(root.left,ref First, ref Second, ref Prev);\\n            if (Prev != null && root.val <Prev.val )\\n            {\\n                if (First == null) First = Prev;\\n                Second = root;\\n            }\\n\\n            Prev = root;\\n            InOrder(root.right, ref First, ref Second, ref Prev);\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public void RecoverTree(TreeNode root) {\\n            TreeNode First = null;\\n            TreeNode Second = null;\\n            TreeNode Prev = null;\\n            InOrder(root,ref First,ref Second,ref Prev);\\n        \\n            var a = First.val;\\n            First.val = Second.val;\\n            Second.val = a;\\n    }\\n    public static void InOrder(TreeNode root, ref TreeNode First, ref TreeNode Second, ref TreeNode Prev)\\n        {\\n            if (root == null) return;\\n            InOrder(root.left,ref First, ref Second, ref Prev);\\n            if (Prev != null && root.val <Prev.val )\\n            {\\n                if (First == null) First = Prev;\\n                Second = root;\\n            }\\n\\n            Prev = root;\\n            InOrder(root.right, ref First, ref Second, ref Prev);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413793,
                "title": "nice-explanation-inorder-traversal-c-implementation-time-o-n",
                "content": "the key to solve this problem is : The **inorder traversal** of a BST produces a sorted array\\n\\n1.  a simple method is to store inorder traversal of the input tree in an auxiliary array. Sort the auxiliary       array. Finally, insert the auxiliary array elements back to the BST, keeping the structure of the BST         same. The time complexity of this method is O(nLogn) and the auxiliary space needed is O(n).w can     also make here some optimization by using insertion sort(for minimum complexity).\\n\\n2.  We can solve this in O(n) time and with a single traversal of the given BST. Since inorder traversal        of BST is always a sorted array, the problem can be reduced to a problem where two elements of a      sorted array are swapped. \\n\\n     Example : For example, Nodes 2 and 3 are swapped in [1,2,3]. \\n                      The inorder traversal of the given tree is [3,2,1] \\n\\tIf we observe carefully, during inorder traversal, we find node 2 is smaller than the previous visited      node 3. Here save the context of node 3 (previous node). Again, we find that node 1 is smaller      than the previous node 2. This time, we save the context of node 1 (the current node ). Finally, swap the two node\\u2019s values.\\n\\t\\n\\tExample, Nodes 2 and 3 are swapped in [1,2,3,4]. \\n  The inorder traversal of the given tree is [1,3,2,4]\\n  unlike previous example ,here only one point exists where a node value is smaller than the previous    node value.\\n  \\n    so, here we can note that when two elements of a sorted array are swapped. \\n   There are two cases that we need to handle:\\n   Firts : The swapped nodes are not adjacent in the inorder traversal of the BST. \\n   Second :  The swapped nodes are adjacent in the inorder traversal of BST.\\n   \\n    we can handle two cases by using FirstNode , SecondNode , PreviousNode For every node (except     the leftmost node of the tree), keep track of its previous node in prev. The current node being processed is stored in the curr.\\nIf during the traversal, we find a node that violates the BST order  previousNode->val > CurrentNode->val .we store PreviousNode into fFirst and CurrentNode into Second.\\nDuring further traversal, if we find another node that violates the BST criteria , previousNode->val > CurrentNode->val. but since, the First node had been already assigned a value. so we assign the current node(which violates BST criteria) to Second.\\nAfter execution of inorder traversal. swap the data of First and Second nodes and The tree gets fixed.\\n\\n\\n```\\n    void RecoverBinarySearchTree(TreeNode* CurrentNode ,TreeNode* &PreviousNode ,TreeNode* &First, TreeNode* &Second) {\\n        if(CurrentNode == NULL) return;\\n        RecoverBinarySearchTree(CurrentNode->left,PreviousNode,First,Second);\\n        if(PreviousNode != NULL && PreviousNode->val > CurrentNode->val) {\\n            if(First == NULL){\\n                First = PreviousNode;\\n                Second = CurrentNode;\\n            }else Second = CurrentNode;\\n        }\\n        PreviousNode = CurrentNode;\\n        RecoverBinarySearchTree(CurrentNode->right,PreviousNode,First,Second);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        TreeNode* First = NULL; TreeNode* Second = NULL; TreeNode* PreviousNode = NULL;\\n        RecoverBinarySearchTree(root,PreviousNode,First,Second);\\n        int temp = First->val;\\n        First->val = Second->val;\\n        Second->val = temp;\\n    }\\n```\\nTime Complexity : O(n)\\nSpace Complexity : O(1), nor data structure neither recursion stack space used.\\n\\nnote : in above code we pass First,Second and PreviousNode to function by refrence\\n          and it\\'s important! \\n\\t\\t  if we take a simple tset case : \\n\\t\\t  ![image](https://assets.leetcode.com/users/images/2b7f8775-5d5d-4d77-a017-03d57b0fb24c_1629391275.4167056.png)\\n1. here we pass to function :  node(1) and First = NULL , Second = NULL  and Previous = NULL\\n2. we will go to left : node(3) and  First = NULL , Second = NULL  and Previous = NULL\\n    and we go to left we will find NULL node so we will return and  update PreviousNode = node(3) \\n3. we will go to right : node(2) left is NULL and we will find previous is not NULL and previous is greater     than current node so it\\'s ok we will update First = PreviousNode , Second = CurrentNode\\n\\tand update PerviousNode : node(2) and it\\'s so important to keep track it with others node\\n\\tand will find right is NULL and i will return to : node : (3) , First :node(3) , Second : node(1) and     PreviousNode : node(2) and this why i call it by refrence to save it\\'s value when i return !\\n\\t\\ni hope you find this is helpful !\\n\\t\\t  \\n\\t\\t  \\n\\t\\t \\n\\t\\t  \\n\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\n    void RecoverBinarySearchTree(TreeNode* CurrentNode ,TreeNode* &PreviousNode ,TreeNode* &First, TreeNode* &Second) {\\n        if(CurrentNode == NULL) return;\\n        RecoverBinarySearchTree(CurrentNode->left,PreviousNode,First,Second);\\n        if(PreviousNode != NULL && PreviousNode->val > CurrentNode->val) {\\n            if(First == NULL){\\n                First = PreviousNode;\\n                Second = CurrentNode;\\n            }else Second = CurrentNode;\\n        }\\n        PreviousNode = CurrentNode;\\n        RecoverBinarySearchTree(CurrentNode->right,PreviousNode,First,Second);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        TreeNode* First = NULL; TreeNode* Second = NULL; TreeNode* PreviousNode = NULL;\\n        RecoverBinarySearchTree(root,PreviousNode,First,Second);\\n        int temp = First->val;\\n        First->val = Second->val;\\n        Second->val = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1384474,
                "title": "c-o-1-space-well-commented",
                "content": "```\\nclass Solution {\\n    public:\\n    vector<pair<TreeNode*,TreeNode*>> vec; // To store pairs that violates BST  \\n    TreeNode* prev = NULL; // keep track of previous node\\n    \\n    void solve(TreeNode* root)\\n    {\\n        if(root == NULL)  return; // Base Condition\\n        \\n        solve(root->left); // First left\\n        // Than deal with Val \\n        \\n        /* if statement says : if previous node exists and previous node has a value more than next or any root that comes to the \\n\\t\\tright of prev than\\tin such case it violates BST condition so push that pair in vec for now, will deal withit later */\\n        if(prev && prev->val > root->val) vec.push_back({prev,root}); \\n        \\n        prev = root; // keep updating prev, for checking BST condition further\\n        solve(root->right); // At last right, this is inorder manner\\n    }\\n    \\n    void recoverTree(TreeNode* root) \\n    {    \\n        solve(root); // Inorder traversal\\n        \\n        /* If just 2 adjacent nodes violated BST , than there will be 1 key value pair in           \\n\\t\\tvec and we will swap it and problem is solved */\\n        if(vec.size() == 1) \\n            swap(vec[0].first->val, vec[0].second->val);\\n        \\n        /* We know its given in question that only 2 nodes of the tree were swapped, but what if those 2 nodes are not adjacent, in that case \\n\\t\\twe have 2 key value pairs which shows there is irregularity in 4 elements. (so size of vec is 2). eg: 1 2 3 4 , we change it to : 4 2 3 1 \\n\\t\\twhich leads to inconsistency in {4,2} and {3,1} so to solve it we swap first of 0th and second of 1th which are 4 and 1 respectively, \\n\\t\\twe can get 1 2 3 4 back, same is done below : */\\n        if(vec.size() == 2)\\n            swap(vec[0].first->val, vec[1].second->val);\\n    }\\n};\\n\\n// Time : O(N)\\n// Space : O(1)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    vector<pair<TreeNode*,TreeNode*>> vec; // To store pairs that violates BST  \\n    TreeNode* prev = NULL; // keep track of previous node\\n    \\n    void solve(TreeNode* root)\\n    {\\n        if(root == NULL)  return; // Base Condition\\n        \\n        solve(root->left); // First left\\n        // Than deal with Val \\n        \\n        /* if statement says : if previous node exists and previous node has a value more than next or any root that comes to the \\n\\t\\tright of prev than\\tin such case it violates BST condition so push that pair in vec for now, will deal withit later */\\n        if(prev && prev->val > root->val) vec.push_back({prev,root}); \\n        \\n        prev = root; // keep updating prev, for checking BST condition further\\n        solve(root->right); // At last right, this is inorder manner\\n    }\\n    \\n    void recoverTree(TreeNode* root) \\n    {    \\n        solve(root); // Inorder traversal\\n        \\n        /* If just 2 adjacent nodes violated BST , than there will be 1 key value pair in           \\n\\t\\tvec and we will swap it and problem is solved */\\n        if(vec.size() == 1) \\n            swap(vec[0].first->val, vec[0].second->val);\\n        \\n        /* We know its given in question that only 2 nodes of the tree were swapped, but what if those 2 nodes are not adjacent, in that case \\n\\t\\twe have 2 key value pairs which shows there is irregularity in 4 elements. (so size of vec is 2). eg: 1 2 3 4 , we change it to : 4 2 3 1 \\n\\t\\twhich leads to inconsistency in {4,2} and {3,1} so to solve it we swap first of 0th and second of 1th which are 4 and 1 respectively, \\n\\t\\twe can get 1 2 3 4 back, same is done below : */\\n        if(vec.size() == 2)\\n            swap(vec[0].first->val, vec[1].second->val);\\n    }\\n};\\n\\n// Time : O(N)\\n// Space : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379643,
                "title": "java-o-1-space-simple-in-order-traversal-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n    \\n    // It is true that if we swap any 2 nodes in a BST, both of those nodes\\n    // will break the rules of a BST. They are lawbreakers! (naughty). We need\\n    // to keep track of both of them. Left is the leftmost lawbreaker and right is \\n    // the rightmost lawbreaker aaccording to the BST\\'s in-order sequence.\\n    private TreeNode lawbreakerLeft, lawbreakerRight;\\n    \\n    // To check whether a node is a lawbreaker we need to see whether the current node\\n    // of an in-order traversal is not... well... in-order. If this was a BST of ascending\\n    // order, the highest value would be the current node and the second highest would be\\n    // the previous that we visited - unless we have a lawbreaker on our hands.\\n    private TreeNode secondHighestValue, highestValue;\\n    \\n    public void recoverTree(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        // Start performing the in-order traversal recursively.\\n        traverse(root);\\n        \\n        // Swap the values of the two lawbreakers so they are abiding the law once more.\\n        int temp = lawbreakerLeft.val;\\n        lawbreakerLeft.val = lawbreakerRight.val;\\n        lawbreakerRight.val = temp;\\n    }\\n    \\n    public void traverse(TreeNode curr) {\\n        if (curr == null) {\\n            return;\\n        }\\n        \\n        // As per in-order traversal rules, we will go left as much as possible, then visit the\\n        // current node, then go right. The rest of this method does just that.\\n        traverse(curr.left);\\n        \\n        // The special part comes with the \"visiting\" of the current node. The first thing we do\\n        // is make note of the current value. Since this is in-order traversal of a BST, the current value\\n        // must be the largest value, and the previously visited value must be the the second largest.\\n        secondHighestValue = highestValue;\\n        highestValue = curr;\\n        \\n        // If for some reason the previous value is greater than the current value... We have found a lawbreaker.\\n        //\\n        // The null check here is just for the case that we\\'re at the leftmost node, in which we can\\'t have set the previous\\n        // value just yet.\\n        if (secondHighestValue != null && secondHighestValue.val > highestValue.val) {\\n            \\n            // If we have not yet found our first lawbreaker, we must set it, while remembering to swap the\\n            // secondHighest and highest value around so that the ordering is correct. Otherwise we can be in a position\\n            // in the next recursion where the highest is not in fact the actual highest. We also set the right in the case that\\n            // by chance the two nodes that were swapped are right next to each other (otherwise it will be skipped).\\n            if (lawbreakerLeft == null) {\\n                lawbreakerLeft = secondHighestValue;\\n                lawbreakerRight = highestValue;\\n                \\n                highestValue = lawbreakerLeft;\\n            } else {\\n                // If the left lawbreaker has been found then we have found a right lawbreaker. You may notice if this has\\n                // already been set then we overwrite it - this is because we always set the right when we find the left most one\\n                // for that one-off case in the previous comment, but if it is not the case the right most lawbreaker node will\\n                // exist somewhere else in the tree.\\n                lawbreakerRight = highestValue;\\n            }\\n        }\\n        \\n        // Finally go and visit the right node!\\n        traverse(curr.right);\\n    }\\n}\\n```\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // It is true that if we swap any 2 nodes in a BST, both of those nodes\\n    // will break the rules of a BST. They are lawbreakers! (naughty). We need\\n    // to keep track of both of them. Left is the leftmost lawbreaker and right is \\n    // the rightmost lawbreaker aaccording to the BST\\'s in-order sequence.\\n    private TreeNode lawbreakerLeft, lawbreakerRight;\\n    \\n    // To check whether a node is a lawbreaker we need to see whether the current node\\n    // of an in-order traversal is not... well... in-order. If this was a BST of ascending\\n    // order, the highest value would be the current node and the second highest would be\\n    // the previous that we visited - unless we have a lawbreaker on our hands.\\n    private TreeNode secondHighestValue, highestValue;\\n    \\n    public void recoverTree(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        // Start performing the in-order traversal recursively.\\n        traverse(root);\\n        \\n        // Swap the values of the two lawbreakers so they are abiding the law once more.\\n        int temp = lawbreakerLeft.val;\\n        lawbreakerLeft.val = lawbreakerRight.val;\\n        lawbreakerRight.val = temp;\\n    }\\n    \\n    public void traverse(TreeNode curr) {\\n        if (curr == null) {\\n            return;\\n        }\\n        \\n        // As per in-order traversal rules, we will go left as much as possible, then visit the\\n        // current node, then go right. The rest of this method does just that.\\n        traverse(curr.left);\\n        \\n        // The special part comes with the \"visiting\" of the current node. The first thing we do\\n        // is make note of the current value. Since this is in-order traversal of a BST, the current value\\n        // must be the largest value, and the previously visited value must be the the second largest.\\n        secondHighestValue = highestValue;\\n        highestValue = curr;\\n        \\n        // If for some reason the previous value is greater than the current value... We have found a lawbreaker.\\n        //\\n        // The null check here is just for the case that we\\'re at the leftmost node, in which we can\\'t have set the previous\\n        // value just yet.\\n        if (secondHighestValue != null && secondHighestValue.val > highestValue.val) {\\n            \\n            // If we have not yet found our first lawbreaker, we must set it, while remembering to swap the\\n            // secondHighest and highest value around so that the ordering is correct. Otherwise we can be in a position\\n            // in the next recursion where the highest is not in fact the actual highest. We also set the right in the case that\\n            // by chance the two nodes that were swapped are right next to each other (otherwise it will be skipped).\\n            if (lawbreakerLeft == null) {\\n                lawbreakerLeft = secondHighestValue;\\n                lawbreakerRight = highestValue;\\n                \\n                highestValue = lawbreakerLeft;\\n            } else {\\n                // If the left lawbreaker has been found then we have found a right lawbreaker. You may notice if this has\\n                // already been set then we overwrite it - this is because we always set the right when we find the left most one\\n                // for that one-off case in the previous comment, but if it is not the case the right most lawbreaker node will\\n                // exist somewhere else in the tree.\\n                lawbreakerRight = highestValue;\\n            }\\n        }\\n        \\n        // Finally go and visit the right node!\\n        traverse(curr.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370723,
                "title": "99-faster",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n\\n**Explanation :-** 1. There can be two cases where nodes are need to be swapped in the inorder traversal i.e. either they are adjacant to each other or are far from each other. \\n\\n**(a)** For example, Nodes 5 and 25 are swapped in {3 5 7 8 10 15 20 25}. \\n The inorder traversal of the given tree is 3 **25** 7 8 10 15 20 **5**\\nIf we observe carefully, during inorder traversal, we find node 7 is smaller than the previous visited node 25. Here save the context of node 25 (previous node). Again, we find that node 5 is smaller than the previous node 20. This time, we save the context of node 5 ( current node ). Finally swap the two node\\u2019s values.\\n\\n**(b)** The swapped nodes are adjacent in the inorder traversal of BST.\\n\\n  For example, Nodes 7 and 8 are swapped in {3 5 7 8 10 15 20 25}. \\n  The inorder traversal of the given tree is 3 5 **8** **7** 10 15 20 25 \\nUnlike case #1, here only one point exists where a node value is smaller than previous node value. e.g. node 7 is smaller than node 8.\\n\\n**How to Solve?** \\n**In case #1**\\nWe will maintain three pointers, first, prev and second. When we find the first point where current node value is smaller than previous node value, we update the first with the previous node. When we find the second point where current node value is smaller than previous node value, we update the second with the current node. Second will be updated when nodes are not adjacent.\\n**In case #2**\\nWe will find the first and second point only once when two swapped nodes of BST are adjacent.\\n```\\nclass Solution {\\npublic:\\n      void inorder(TreeNode *root , TreeNode *&first , TreeNode *&second , TreeNode *&prev)\\n      {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        inorder(root -> left , first , second , prev);\\n        if(prev != NULL && prev -> val > root -> val)\\n        {\\n            if(first == NULL)\\n            {\\n                first = prev;\\n            }\\n            second = root;\\n        }\\n        prev = root;\\n        inorder(root -> right , first , second , prev);\\n     }\\n    \\n    void recoverTree(TreeNode* root)\\n    {\\n       TreeNode *first , *second , *prev;\\n       first = second = prev = NULL;\\n       inorder(root , first , second , prev);\\n       swap(first -> val , second -> val);\\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n      void inorder(TreeNode *root , TreeNode *&first , TreeNode *&second , TreeNode *&prev)\\n      {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        inorder(root -> left , first , second , prev);\\n        if(prev != NULL && prev -> val > root -> val)\\n        {\\n            if(first == NULL)\\n            {\\n                first = prev;\\n            }\\n            second = root;\\n        }\\n        prev = root;\\n        inorder(root -> right , first , second , prev);\\n     }\\n    \\n    void recoverTree(TreeNode* root)\\n    {\\n       TreeNode *first , *second , *prev;\\n       first = second = prev = NULL;\\n       inorder(root , first , second , prev);\\n       swap(first -> val , second -> val);\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347121,
                "title": "java-easy-recursive-solution-inorder",
                "content": "```\\nclass Solution {\\n    TreeNode prev=null,first=null,second=null;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left);\\n        if(prev!=null && root.val<prev.val){\\n            if(first==null){\\n                first=prev;\\n            }\\n              second=root; \\n        }\\n        prev=root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev=null,first=null,second=null;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left);\\n        if(prev!=null && root.val<prev.val){\\n            if(first==null){\\n                first=prev;\\n            }\\n              second=root; \\n        }\\n        prev=root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314888,
                "title": "deal-with-duplicate-values-swap-nodes-instead-of-just-values-w-python-implementation",
                "content": "Submitting a solution that passes all test cases of this problem is simple. However, there are two points of this problem setting that really do NOT make sense. Neither does the official solution article take them into account:\\n1. According to the official solution article and all test cases used in this problem, we know that it\\'s assumed that there are no duplicate values in a tree, which is however never stated in the problem description.\\nIn general, the definition of BST includes \"equal\" situation, namely: the value in each node is **greater than or equal to** (less than or equal to) any values stored in its left (right) subtree. So a BST does not necessarily have unique value for each node. \\nSo the question would be be: \"how to handle duplicate cases?\" which is raised already by many other guys in the Discussion part (see: https://leetcode.com/problems/recover-binary-search-tree/discuss/32673/Does-the-BST-in-this-problem-include-duplicate-nodes, https://leetcode.com/problems/recover-binary-search-tree/discuss/32656/How-to-handle-the-case-when-there-are-duplicate-values-in-the-BST, and [etc](https://leetcode.com/problems/recover-binary-search-tree/discuss?currentPage=1&orderBy=most_relevant&query=duplicate).)\\n\\n2. It is assumed in this problem that it is the **values**(i.e., key of the node) of two nodes that got swapped. In a more reasonable setting, the two **TreeNodes** are swapped other than the mere values. (For example, in real application, a tree node might carry some satellite data.) In such scenarios,  we want a solution that swap nodes instead of just their (key) values.\\n\\n**To address the above concerns:**\\n\\n\\nThis is a more general solution that is able to handle duplicate values (only 1 pass)\\n```\\n# This solution uses stack. You can also do the similar thing with recursion or Morris traversal\\n# This solution is able to deal with duplicate values; therefore it\\'s a more general solution\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(H) where H is the height of the tree. In the worst case it can deteriorate to O(N)\\nclass Solution:\\n    def recoverTree(self, root: TreeNode):\\n        \"\"\"\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        x = y = pred = None\\n        \\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            \\n            ### this is what we do to each traversed node ###\\n            if pred:\\n                if x is None:\\n                    if root.val < pred.val:\\n                        x = pred \\n                        y = root\\n                else:\\n                    if root.val <= y.val:\\n                        y = root\\n                    if root.val > x.val:\\n                        break\\n            if pred is None or root.val != pred.val:\\n                pred = root\\n            ### this is what we do to each traversed node ###\\n                \\n            root = root.right\\n        x.val, y.val = y.val, x.val\\n```\\n\\n\\nIf you also want to consider swapping nodes instead of values, here is what you need:\\n```\\n# This solution:\\n#    1. is able to deal with duplicate values\\n#    2. swaps nodes instead of values\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(H) where H is the height of the tree. In the worst case it can deteriorate to O(N)\\nclass Solution:\\n    def recoverTree(self, root: TreeNode):\\n        \"\"\"\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        x = y = pred = None\\n        parent = None\\n        while stack or root:\\n            while root:\\n                stack.append((root, parent))\\n                root, parent = root.left, root\\n            root, parent = stack.pop()\\n            \\n            ### this is what we do to each traversed node ###\\n            if pred:\\n                if x is None:\\n                    if root.val < pred.val:\\n                        x, x_parent = pred, pred_parent\\n                        y, y_parent = root, parent\\n                else:\\n                    if root.val <= y.val:\\n                        y, y_parent = root, parent\\n                    if root.val > x.val:\\n                        break\\n            if pred is None or root.val != pred.val:\\n                pred, pred_parent = root, parent\\n            ### this is what we do to each traversed node ###\\n                \\n            root, parent = root.right, root\\n        swap_nodes(x, y, x_parent, y_parent)\\n    \\ndef swap_nodes(x: TreeNode, y: TreeNode, x_parent: TreeNode, y_parent: TreeNode):\\n    if x_parent is y:\\n        if y_parent:\\n            if y_parent.left is y:\\n                y_parent.left = x\\n            else:\\n                y_parent.right = x\\n        if y.left is x:\\n            x.left, x.right, y.left, y.right = y, y.right, x.left, x.right\\n        else:\\n            x.left, x.right, y.left, y.right = y.left, y, x.left, x.right\\n\\n    elif y_parent is x:\\n        if x_parent:\\n            if x_parent.left is x:\\n                x_parent.left = y\\n            else:\\n                x_parent.right = y\\n        if x.left is y:\\n            x.left, x.right, y.left, y.right = y.left, y.right, x, x.right\\n        else:\\n            x.left, x.right, y.left, y.right = y.left, y.right, x.left, x\\n\\n    else:    \\n        x.left, x.right, y.left, y.right = y.left, y.right, x.left, x.right\\n        if x_parent:\\n            if x_parent.left is x:\\n                x_parent.left = y\\n            else:\\n                x_parent.right = y\\n        if y_parent:\\n            if y_parent.left is y:\\n                y_parent.left = x\\n            else:\\n                y_parent.right = x\\n```\\n\\n\\nFinally, I provide an optimal solution which has the asymtotically best time & space complexity (O(n) time and O(1) space) and also takes into account the aforementioned two points, using Morris traversal.\\n\\n```\\n# Morris traversal\\n# This solution:\\n#    1. is able to deal with duplicate values\\n#    2. swaps nodes instead of values\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(1)\\nclass Solution:\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        x = y = predecessor = pred = None\\n        \\n        node = root\\n        while node:\\n            if not node.left: \\n                \\n                ### this is what we do to each traversed node ###\\n                if pred:\\n                    if x is None:\\n                        if node.val < pred.val:\\n                            x = pred \\n                            y = node\\n                    else:\\n                        if node.val <= y.val:\\n                            y = node\\n                if pred is None or node.val != pred.val:\\n                    pred = node\\n                ### this is what we do to each traversed node ###\\n                \\n                node = node.right            \\n            else:\\n                predecessor = node.left\\n                while predecessor.right and predecessor.right is not node:\\n                    predecessor = predecessor.right\\n                \\n                if not predecessor.right:\\n                    predecessor.right = node\\n                    node = node.left\\n                else:\\n                    predecessor.right = None \\n                    \\n                    ### this is what we do to each traversed node ###\\n                    if pred:\\n                        if x is None:\\n                            if node.val < pred.val:\\n                                x = pred \\n                                y = node\\n                        else:\\n                            if node.val <= y.val:\\n                                y = node\\n                    if pred is None or node.val != pred.val:\\n                        pred = node\\n                    ### this is what we do to each traversed node ###\\n                    \\n                    node = node.right \\n                    \\n        x_parent, y_parent = self.morris_preorder(root, x, y)\\n        swap_nodes(x, y, x_parent, y_parent)\\n    \\n    def morris_preorder(self, root, x, y):\\n        \\'\\'\\'\\n        This is used to find the parents of x, y in linear time and constant space\\n        \\'\\'\\'\\n        node, parent = root, None\\n        while node:\\n            if not node.left: \\n                \\n                ### check if we meet the parent ###\\n                if node is x:\\n                    x_parent = parent\\n                elif node is y:\\n                    y_parent = parent\\n                ### check if we meet the parent ###\\n                \\n                node, parent = node.right, node            \\n            else:\\n                predecessor = node.left\\n                while predecessor.right and predecessor.right is not node:\\n                    predecessor = predecessor.right\\n                \\n                if not predecessor.right:\\n                    \\n                    ### check if we meet the parent ###\\n                    if node is x:\\n                        x_parent = parent\\n                    elif node is y:\\n                        y_parent = parent\\n                    ### check if we meet the parent ###\\n                    \\n                    predecessor.right = node\\n                    node, parent = node.left, node\\n                else:\\n                    predecessor.right = None                     \\n                    node, parent = node.right, node\\n                    \\n        return x_parent, y_parent\\n```\\nNote that if your implementation swaps nodes instead of values, then the code won\\'t pass the test cases of this problem, since in some cases it swaps the root node and the LeetCode testing code of this problem won\\'t change the pointer to the original root to the new root so that you eventually end up with a subtree instead of the original entire tree.",
                "solutionTags": [],
                "code": "```\\n# This solution uses stack. You can also do the similar thing with recursion or Morris traversal\\n# This solution is able to deal with duplicate values; therefore it\\'s a more general solution\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(H) where H is the height of the tree. In the worst case it can deteriorate to O(N)\\nclass Solution:\\n    def recoverTree(self, root: TreeNode):\\n        \"\"\"\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        x = y = pred = None\\n        \\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            \\n            ### this is what we do to each traversed node ###\\n            if pred:\\n                if x is None:\\n                    if root.val < pred.val:\\n                        x = pred \\n                        y = root\\n                else:\\n                    if root.val <= y.val:\\n                        y = root\\n                    if root.val > x.val:\\n                        break\\n            if pred is None or root.val != pred.val:\\n                pred = root\\n            ### this is what we do to each traversed node ###\\n                \\n            root = root.right\\n        x.val, y.val = y.val, x.val\\n```\n```\\n# This solution:\\n#    1. is able to deal with duplicate values\\n#    2. swaps nodes instead of values\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(H) where H is the height of the tree. In the worst case it can deteriorate to O(N)\\nclass Solution:\\n    def recoverTree(self, root: TreeNode):\\n        \"\"\"\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        x = y = pred = None\\n        parent = None\\n        while stack or root:\\n            while root:\\n                stack.append((root, parent))\\n                root, parent = root.left, root\\n            root, parent = stack.pop()\\n            \\n            ### this is what we do to each traversed node ###\\n            if pred:\\n                if x is None:\\n                    if root.val < pred.val:\\n                        x, x_parent = pred, pred_parent\\n                        y, y_parent = root, parent\\n                else:\\n                    if root.val <= y.val:\\n                        y, y_parent = root, parent\\n                    if root.val > x.val:\\n                        break\\n            if pred is None or root.val != pred.val:\\n                pred, pred_parent = root, parent\\n            ### this is what we do to each traversed node ###\\n                \\n            root, parent = root.right, root\\n        swap_nodes(x, y, x_parent, y_parent)\\n    \\ndef swap_nodes(x: TreeNode, y: TreeNode, x_parent: TreeNode, y_parent: TreeNode):\\n    if x_parent is y:\\n        if y_parent:\\n            if y_parent.left is y:\\n                y_parent.left = x\\n            else:\\n                y_parent.right = x\\n        if y.left is x:\\n            x.left, x.right, y.left, y.right = y, y.right, x.left, x.right\\n        else:\\n            x.left, x.right, y.left, y.right = y.left, y, x.left, x.right\\n\\n    elif y_parent is x:\\n        if x_parent:\\n            if x_parent.left is x:\\n                x_parent.left = y\\n            else:\\n                x_parent.right = y\\n        if x.left is y:\\n            x.left, x.right, y.left, y.right = y.left, y.right, x, x.right\\n        else:\\n            x.left, x.right, y.left, y.right = y.left, y.right, x.left, x\\n\\n    else:    \\n        x.left, x.right, y.left, y.right = y.left, y.right, x.left, x.right\\n        if x_parent:\\n            if x_parent.left is x:\\n                x_parent.left = y\\n            else:\\n                x_parent.right = y\\n        if y_parent:\\n            if y_parent.left is y:\\n                y_parent.left = x\\n            else:\\n                y_parent.right = x\\n```\n```\\n# Morris traversal\\n# This solution:\\n#    1. is able to deal with duplicate values\\n#    2. swaps nodes instead of values\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(1)\\nclass Solution:\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        x = y = predecessor = pred = None\\n        \\n        node = root\\n        while node:\\n            if not node.left: \\n                \\n                ### this is what we do to each traversed node ###\\n                if pred:\\n                    if x is None:\\n                        if node.val < pred.val:\\n                            x = pred \\n                            y = node\\n                    else:\\n                        if node.val <= y.val:\\n                            y = node\\n                if pred is None or node.val != pred.val:\\n                    pred = node\\n                ### this is what we do to each traversed node ###\\n                \\n                node = node.right            \\n            else:\\n                predecessor = node.left\\n                while predecessor.right and predecessor.right is not node:\\n                    predecessor = predecessor.right\\n                \\n                if not predecessor.right:\\n                    predecessor.right = node\\n                    node = node.left\\n                else:\\n                    predecessor.right = None \\n                    \\n                    ### this is what we do to each traversed node ###\\n                    if pred:\\n                        if x is None:\\n                            if node.val < pred.val:\\n                                x = pred \\n                                y = node\\n                        else:\\n                            if node.val <= y.val:\\n                                y = node\\n                    if pred is None or node.val != pred.val:\\n                        pred = node\\n                    ### this is what we do to each traversed node ###\\n                    \\n                    node = node.right \\n                    \\n        x_parent, y_parent = self.morris_preorder(root, x, y)\\n        swap_nodes(x, y, x_parent, y_parent)\\n    \\n    def morris_preorder(self, root, x, y):\\n        \\'\\'\\'\\n        This is used to find the parents of x, y in linear time and constant space\\n        \\'\\'\\'\\n        node, parent = root, None\\n        while node:\\n            if not node.left: \\n                \\n                ### check if we meet the parent ###\\n                if node is x:\\n                    x_parent = parent\\n                elif node is y:\\n                    y_parent = parent\\n                ### check if we meet the parent ###\\n                \\n                node, parent = node.right, node            \\n            else:\\n                predecessor = node.left\\n                while predecessor.right and predecessor.right is not node:\\n                    predecessor = predecessor.right\\n                \\n                if not predecessor.right:\\n                    \\n                    ### check if we meet the parent ###\\n                    if node is x:\\n                        x_parent = parent\\n                    elif node is y:\\n                        y_parent = parent\\n                    ### check if we meet the parent ###\\n                    \\n                    predecessor.right = node\\n                    node, parent = node.left, node\\n                else:\\n                    predecessor.right = None                     \\n                    node, parent = node.right, node\\n                    \\n        return x_parent, y_parent\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264842,
                "title": "o-n-time-o-1-space-handles-duplicates-explanation-and-lessons-learned",
                "content": "I feel that the few comments I perused mostly contained code of which I did not fully understand what to do with it. Also I have a slight criticism to the task because it does not say that node-values are distinct, albeit in the test cases they are. For my solution, I will not assume that they are.\\n\\nThings I learned:\\n1) **Morris traversal**, you can traverse a binary tree with constant space (note that the recursion stack also counts as space). There are better explanations out in the internet, so I am not going to explain it. My function *inOrderTraversal* is an implementation of it.\\n2) **Pointers to member functions**, first time I encountered them and heard that they are difficult to normal function pointers. You have this crazy ->* syntax. Something to learn.\\n3) **Reduce to easier problems**. In my opinion this is the secret behind every good problem solver and it helped me understand the solution here to. I will jut down my thinking.\\n\\nHow I found my solution:\\nNormally, I do not like to bother people with how I came up with my solution (who cares), but here I do, since it gives me insights into how to solve general problems.\\n1) *First considering a list (ordered) with distinct values. Write one down and swap a) two consecutive values, b) two values one apart, c) two values two apart*. You will notices that in the resulting list the swapped values are found easily: It is the first value, which is larger then the follow-up value and the last value, which is smaller than its predecessor. Let us call them *firstFaulty* and *lastFaulty*.\\n2) *Now consider lists with non-distinct values.* You will notice that you have to replace *firstFaulty* by the last item, which has the value *firstFaulty* and *lastFaulty* with the first value which is equal to *lastFaulty*. I think you can quickly figure out that this is correct on paper and thus I will omit a proof of formal correctness. If you want to see one, quickly shoot me a comment and I will provide one.\\n3) *Now consider the general problem with trees*. Can we transform a tree into an ordered list? Not using O(1) space and \\'remembering\\' the tree-structure. But we can go through the tree in-order using *Morris-traversal* and O(1) space; it is similar to transforming the tree into a singly-linked list. We will traverse through our tree twice. First finding *firstFaulty* and *lastFaulty* as described in 1), then updating them as described in 2). Voila that is our algorithm.\\n\\nThe implementation was also a bit tricky. To avoid duplication of code, I only implemented the Morris-traversal once and learned a lot about method-function pointers in the process. But this is at most interesting to the C++-nerds among us; if at all.\\n\\n```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        firstFaulty=lastFaulty=0;\\n        previous=0;\\n        inOrderTraversal(root, &Solution::findFirstLastFaulty);\\n        if(firstFaulty){\\n            handleDuplicateValues(root);\\n            swap(firstFaulty->val,lastFaulty->val);\\n        }\\n    }\\nprivate:\\n    TreeNode* firstFaulty;\\n    TreeNode* lastFaulty;\\n    TreeNode* previous=0;\\n    bool lastFaultyFound;\\n    \\n    void inOrderTraversal(TreeNode *root, void (Solution::*check)(TreeNode*)){\\n        TreeNode* current=root;\\n        \\n        while(current){\\n            if(! current->left){\\n                (this->*check)(current);\\n                current=current->right;\\n            }else{\\n                TreeNode* predecessor=current->left;\\n                while(predecessor->right && predecessor->right!=current){\\n                    predecessor=predecessor->right;\\n                }\\n                if(!predecessor->right){\\n                    predecessor->right=current;\\n                    current=current->left;\\n                }else{\\n                    predecessor->right=0;\\n                    (this->*check)(current);\\n                    current=current->right;\\n                }\\n            }\\n        }\\n    }\\n    void findFirstLastFaulty(TreeNode* node){\\n        if(previous && previous->val > node->val){\\n            if(!firstFaulty)\\n                firstFaulty=previous;\\n            lastFaulty=node;\\n        }\\n        previous=node;\\n    }\\n    void handleDuplicateValues(TreeNode *root){\\n        lastFaultyFound=false;\\n        inOrderTraversal(root, &Solution::incorporateSimilarValues);\\n    }\\n    void incorporateSimilarValues(TreeNode* node){\\n        if(!lastFaultyFound && node->val == lastFaulty->val){\\n            lastFaultyFound=true;\\n            lastFaulty=node;\\n        }\\n        if(node->val == firstFaulty->val){\\n            firstFaulty=node;\\n        }\\n    }\\n};\\n```\\n\\n**Please comment** if you have questions, want explanations or even better find some way I can improve. I hope to use this site to learn how to explain well and code clean, next to helping people understanding how to solve problems (or learning from people how to solve problems -- thanks for the folks in prior discussions mentioning Morris traversal!).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        firstFaulty=lastFaulty=0;\\n        previous=0;\\n        inOrderTraversal(root, &Solution::findFirstLastFaulty);\\n        if(firstFaulty){\\n            handleDuplicateValues(root);\\n            swap(firstFaulty->val,lastFaulty->val);\\n        }\\n    }\\nprivate:\\n    TreeNode* firstFaulty;\\n    TreeNode* lastFaulty;\\n    TreeNode* previous=0;\\n    bool lastFaultyFound;\\n    \\n    void inOrderTraversal(TreeNode *root, void (Solution::*check)(TreeNode*)){\\n        TreeNode* current=root;\\n        \\n        while(current){\\n            if(! current->left){\\n                (this->*check)(current);\\n                current=current->right;\\n            }else{\\n                TreeNode* predecessor=current->left;\\n                while(predecessor->right && predecessor->right!=current){\\n                    predecessor=predecessor->right;\\n                }\\n                if(!predecessor->right){\\n                    predecessor->right=current;\\n                    current=current->left;\\n                }else{\\n                    predecessor->right=0;\\n                    (this->*check)(current);\\n                    current=current->right;\\n                }\\n            }\\n        }\\n    }\\n    void findFirstLastFaulty(TreeNode* node){\\n        if(previous && previous->val > node->val){\\n            if(!firstFaulty)\\n                firstFaulty=previous;\\n            lastFaulty=node;\\n        }\\n        previous=node;\\n    }\\n    void handleDuplicateValues(TreeNode *root){\\n        lastFaultyFound=false;\\n        inOrderTraversal(root, &Solution::incorporateSimilarValues);\\n    }\\n    void incorporateSimilarValues(TreeNode* node){\\n        if(!lastFaultyFound && node->val == lastFaulty->val){\\n            lastFaultyFound=true;\\n            lastFaulty=node;\\n        }\\n        if(node->val == firstFaulty->val){\\n            firstFaulty=node;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139057,
                "title": "simple-java-dfs-beating-100-in-time",
                "content": "```\\nclass Solution {\\n    TreeNode left=null;\\n    TreeNode right=null;\\n    TreeNode last=null;\\n    public void recoverTree(TreeNode root) {\\n        dfs(root);\\n        int temp=left.val;\\n        left.val=right.val;\\n        right.val=temp;\\n    }\\n    private void dfs(TreeNode root){\\n        if(root==null) return;\\n        dfs(root.left);\\n        if(last!=null && left==null && last.val>root.val) left=last;\\n        if(last!=null && last.val>root.val) right=root;\\n        last=root;\\n        dfs(root.right);   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode left=null;\\n    TreeNode right=null;\\n    TreeNode last=null;\\n    public void recoverTree(TreeNode root) {\\n        dfs(root);\\n        int temp=left.val;\\n        left.val=right.val;\\n        right.val=temp;\\n    }\\n    private void dfs(TreeNode root){\\n        if(root==null) return;\\n        dfs(root.left);\\n        if(last!=null && left==null && last.val>root.val) left=last;\\n        if(last!=null && last.val>root.val) right=root;\\n        last=root;\\n        dfs(root.right);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053192,
                "title": "simple-c-o-1-inorder-traversal",
                "content": "```\\nclass Solution {\\n\\n        TreeNode* prev {};\\n        TreeNode* badNode1 {};\\n        TreeNode* badNode2 {};\\n\\n        void locateBadNodes(TreeNode* node) {\\n                if(node) {\\n                        locateBadNodes(node->left);\\n                        if(prev && prev->val > node->val) {\\n                                if(!badNode1) {\\n                                        badNode1 = prev;\\n                                        badNode2 = node;\\n                                }       else {\\n                                        badNode2 = node;\\n                                        return;\\n                                }\\n                        }\\n                        prev = node;\\n                        locateBadNodes(node->right);\\n                }\\n        }\\n\\npublic:\\n\\n        void recoverTree(TreeNode* root) {\\n                        locateBadNodes(root);\\n                        if(badNode1 && badNode2) {\\n                                std::swap(badNode1->val, badNode2->val);\\n                        }\\n        }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n        TreeNode* prev {};\\n        TreeNode* badNode1 {};\\n        TreeNode* badNode2 {};\\n\\n        void locateBadNodes(TreeNode* node) {\\n                if(node) {\\n                        locateBadNodes(node->left);\\n                        if(prev && prev->val > node->val) {\\n                                if(!badNode1) {\\n                                        badNode1 = prev;\\n                                        badNode2 = node;\\n                                }       else {\\n                                        badNode2 = node;\\n                                        return;\\n                                }\\n                        }\\n                        prev = node;\\n                        locateBadNodes(node->right);\\n                }\\n        }\\n\\npublic:\\n\\n        void recoverTree(TreeNode* root) {\\n                        locateBadNodes(root);\\n                        if(badNode1 && badNode2) {\\n                                std::swap(badNode1->val, badNode2->val);\\n                        }\\n        }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918268,
                "title": "python-inorder-traverse",
                "content": "Inorder traverse the tree, store the vals of nodes into a vector. Then sort the vals and change the val of nodes in order.\\n```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n\\t    def inorder(root):\\n            if not root: return []\\n            return inorder(root.left)+[root]+inorder(root.right)\\n            \\n        v=inorder(root)\\n        vals = sorted(x.val for x in v)\\n        \\n        for i in range(len(v)):\\n            v[i].val = vals[i]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n\\t    def inorder(root):\\n            if not root: return []\\n            return inorder(root.left)+[root]+inorder(root.right)\\n            \\n        v=inorder(root)\\n        vals = sorted(x.val for x in v)\\n        \\n        for i in range(len(v)):\\n            v[i].val = vals[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917633,
                "title": "intutive-inorder-traversal",
                "content": "First time I am posting my solution:\\n\\nDo inorder traversal. Find the node whose previous value and current node is not in order. (prevElement > currElement)\\nKeep track of first node and last node encountered like this and swap them.\\n**Explanation:** \\n1.The inorder traversal of BST should always give us ascending order but not when nodes are swapped.\\n2.Now if we know the point where the order is violated, we can find the nodes which violate it and then swap them.\\n```\\nclass Solution {\\nTreeNode preNode = null;\\nTreeNode firstNode =null, secondNode =null;\\n\\npublic void recoverTree(TreeNode root) {\\n    inorderTraversal(root);\\n    int temp = firstNode.val;\\n    firstNode.val = secondNode.val;\\n    secondNode.val = temp;\\n}\\npublic void inorderTraversal(TreeNode curr) {\\n    if(curr == null)\\n        return;\\n    inorderTraversal(curr.left);\\n    //Do the work\\n    if(preNode != null) {\\n        if(preNode.val > curr.val) {\\n            if(firstNode == null) {\\n                firstNode = preNode;\\n            }\\n            secondNode = curr;\\n        }\\n    }\\n    preNode = curr;\\n    inorderTraversal(curr.right);\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nTreeNode preNode = null;\\nTreeNode firstNode =null, secondNode =null;\\n\\npublic void recoverTree(TreeNode root) {\\n    inorderTraversal(root);\\n    int temp = firstNode.val;\\n    firstNode.val = secondNode.val;\\n    secondNode.val = temp;\\n}\\npublic void inorderTraversal(TreeNode curr) {\\n    if(curr == null)\\n        return;\\n    inorderTraversal(curr.left);\\n    //Do the work\\n    if(preNode != null) {\\n        if(preNode.val > curr.val) {\\n            if(firstNode == null) {\\n                firstNode = preNode;\\n            }\\n            secondNode = curr;\\n        }\\n    }\\n    preNode = curr;\\n    inorderTraversal(curr.right);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917330,
                "title": "c-simple-inorder-traversal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&bs){\\n        if(root==NULL){\\n            return;\\n        }\\n        inorder(root->left,bs);\\n        bs.push_back(root->val);\\n        inorder(root->right,bs);\\n    }\\n    void recover(TreeNode* root,int &a,int &b,TreeNode* &r){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->val==a && root!=r){\\n            root->val=b;\\n            r=root;\\n        }else if(root->val==b && root!=r){\\n            root->val=a;\\n            r=root;\\n        }\\n        recover(root->left,a,b,r);\\n        recover(root->right,a,b,r);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<int>bs;\\n        inorder(root,bs);\\n        int a=-1,b=-1;\\n        int count=0;\\n        for(int i=0;i<bs.size()-1;i++){\\n            if(bs[i]>bs[i+1] && count==0){\\n                a=i;\\n                count++;\\n            }else if(bs[i]>bs[i+1] && count==1){\\n                b=bs[i+1];\\n                break;\\n            }\\n        }\\n        if(b==-1){\\n            b=bs[a+1];\\n        }\\n        a=bs[a];\\n        TreeNode* r;\\n        recover(root,a,b,r);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&bs){\\n        if(root==NULL){\\n            return;\\n        }\\n        inorder(root->left,bs);\\n        bs.push_back(root->val);\\n        inorder(root->right,bs);\\n    }\\n    void recover(TreeNode* root,int &a,int &b,TreeNode* &r){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->val==a && root!=r){\\n            root->val=b;\\n            r=root;\\n        }else if(root->val==b && root!=r){\\n            root->val=a;\\n            r=root;\\n        }\\n        recover(root->left,a,b,r);\\n        recover(root->right,a,b,r);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<int>bs;\\n        inorder(root,bs);\\n        int a=-1,b=-1;\\n        int count=0;\\n        for(int i=0;i<bs.size()-1;i++){\\n            if(bs[i]>bs[i+1] && count==0){\\n                a=i;\\n                count++;\\n            }else if(bs[i]>bs[i+1] && count==1){\\n                b=bs[i+1];\\n                break;\\n            }\\n        }\\n        if(b==-1){\\n            b=bs[a+1];\\n        }\\n        a=bs[a];\\n        TreeNode* r;\\n        recover(root,a,b,r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916653,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    boolean swapped = true;\\n    public void recoverTree(TreeNode root) {\\n        while(swapped) {\\n            swapped = false;\\n            dfs(root, null, null);\\n        }\\n    }\\n    \\n    public void dfs(TreeNode root, TreeNode min, TreeNode max) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        if(max != null) {\\n            if (root.val > max.val) {\\n                swapped = swapped || true;\\n                swap(root, max);   \\n            }\\n        }\\n        \\n        if(min != null) {\\n            if(root.val < min.val) {\\n                swapped = swapped || true;\\n                swap(root, min);\\n            }\\n        }\\n        \\n        dfs(root.left, min, root);\\n        dfs(root.right, root, max);\\n        \\n    }\\n    \\n    private void swap(TreeNode a, TreeNode b) {\\n        int tmp = a.val;\\n        a.val = b.val;\\n        b.val = tmp;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean swapped = true;\\n    public void recoverTree(TreeNode root) {\\n        while(swapped) {\\n            swapped = false;\\n            dfs(root, null, null);\\n        }\\n    }\\n    \\n    public void dfs(TreeNode root, TreeNode min, TreeNode max) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        if(max != null) {\\n            if (root.val > max.val) {\\n                swapped = swapped || true;\\n                swap(root, max);   \\n            }\\n        }\\n        \\n        if(min != null) {\\n            if(root.val < min.val) {\\n                swapped = swapped || true;\\n                swap(root, min);\\n            }\\n        }\\n        \\n        dfs(root.left, min, root);\\n        dfs(root.right, root, max);\\n        \\n    }\\n    \\n    private void swap(TreeNode a, TreeNode b) {\\n        int tmp = a.val;\\n        a.val = b.val;\\n        b.val = tmp;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831158,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\n    TreeNode *prev = NULL;\\n    TreeNode *mistake1 = NULL, *mistake2 = NULL;\\n    \\n    void inorder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        if (prev and root->val < prev->val) {\\n            if (!mistake1)\\n                mistake1 = prev;\\n            \\n            if (mistake1)\\n                mistake2 = root;\\n        }\\n    \\n        prev = root;\\n        \\n        inorder(root->right);\\n    }\\n    \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        \\n        swap(mistake1->val, mistake2->val);\\n        \\n        return;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    TreeNode *prev = NULL;\\n    TreeNode *mistake1 = NULL, *mistake2 = NULL;\\n    \\n    void inorder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        if (prev and root->val < prev->val) {\\n            if (!mistake1)\\n                mistake1 = prev;\\n            \\n            if (mistake1)\\n                mistake2 = root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 791960,
                "title": "intuitive-solution-explaining-no-fancy-code",
                "content": "```\\nclass Solution {\\n    /*\\n\\t\\n\\tWe know the inorder of a binary search tree is a sorted array. \\n\\t\\n    The idea is essentailly to solve the problem:\\n    Recover an almost sorted array with TWO elements swapped. Swap them back to make \\n    the array sorted. \\n    \\n\\tSo, let\\'s first get the inorder list and find the two mismatched values\\n\\t\\n    To find the two values: \\n\\tTraverse the array from left side and find the first out of order element \\n\\t(element which is bigger than next element).\\n\\tTraverse from rightmost side and find the first out of order element \\n\\t(element at i which is smaller than previous element at i-1).\\n    \\n    */\\n\\t//Time: O(N)\\n\\t//Space: O(N)\\n    TreeNode m1 = null;\\n    TreeNode m2 = null;\\n    public void recoverTree(TreeNode root) {\\n        List<Integer> lst = new ArrayList<>();\\n        getInorder(root, lst);\\n        \\n        // An almost sorted array with two elements swapped\\n        int mismatch1 = 0;\\n        int mismatch2 = 0;\\n        // from left to right\\n        for(int i = 0; i < lst.size()-1; i++){\\n            if(lst.get(i) > lst.get(i+1)){\\n                mismatch1 = lst.get(i);\\n                break;\\n            }\\n        }\\n        \\n        // from right to left\\n        for(int i = lst.size()-1; i > 0; i--){\\n            if(lst.get(i) < lst.get(i-1)){\\n                mismatch2 = lst.get(i);\\n                break;\\n            }\\n        }\\n        \\n        // find the two nodes with val to mismatch1 and 2\\n        dfs(root, mismatch1, mismatch2);\\n        \\n        // swap the value\\n        int temp = m1.val;\\n        m1.val = m2.val;\\n        m2.val = temp;\\n    }\\n    \\n    public void getInorder(TreeNode root, List<Integer> lst){\\n        if(root == null) return;\\n        getInorder(root.left, lst);\\n        lst.add(root.val);\\n        getInorder(root.right, lst);\\n    }\\n    \\n    public void dfs(TreeNode root, int mismatch1, int mismatch2){\\n        if(root == null) return;\\n        if(root.val == mismatch1){\\n            m1 = root;\\n        }else if(root.val == mismatch2){\\n            m2 = root;\\n        }\\n        \\n        dfs(root.left, mismatch1, mismatch2);\\n        dfs(root.right, mismatch1, mismatch2);\\n    }\\n    \\n}\\n```\\n\\nA slightly shorter version without populating into a List.\\nSame idea but just finding two mismatch while traversing \\nin inorder forward and backward\\n\\n```\\n// Time: O(N)\\n// Space: O(1) except the recursive stack\\nclass Solution {\\n    TreeNode m1 = null;\\n    TreeNode m2 = null;\\n    boolean foundM1 = false;\\n    boolean foundM2 = false;\\n    public void recoverTree(TreeNode root) {\\n        inorderForward(root); // forward\\n        inorderBackward(root); // backward\\n       \\n        int temp = m1.val;\\n        m1.val = m2.val;\\n        m2.val = temp;\\n    }\\n    \\n    public void inorderForward(TreeNode root){\\n        if(root == null) return;\\n        inorderForward(root.left);\\n        \\n        if(m1 != null && m1.val > root.val){\\n            foundM1 = true;\\n            return;\\n        }\\n        if(!foundM1)\\n            m1 = root;\\n        inorderForward(root.right);\\n    }\\n    \\n    public void inorderBackward(TreeNode root){\\n        if(root == null) return;\\n        inorderBackward(root.right);\\n        if(m2 != null && m2.val < root.val){\\n            foundM2 = true;\\n            return;\\n        }\\n       \\n        if(!foundM2)\\n            m2 = root;\\n        inorderBackward(root.left);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n\\t\\n\\tWe know the inorder of a binary search tree is a sorted array. \\n\\t\\n    The idea is essentailly to solve the problem:\\n    Recover an almost sorted array with TWO elements swapped. Swap them back to make \\n    the array sorted. \\n    \\n\\tSo, let\\'s first get the inorder list and find the two mismatched values\\n\\t\\n    To find the two values: \\n\\tTraverse the array from left side and find the first out of order element \\n\\t(element which is bigger than next element).\\n\\tTraverse from rightmost side and find the first out of order element \\n\\t(element at i which is smaller than previous element at i-1).\\n    \\n    */\\n\\t//Time: O(N)\\n\\t//Space: O(N)\\n    TreeNode m1 = null;\\n    TreeNode m2 = null;\\n    public void recoverTree(TreeNode root) {\\n        List<Integer> lst = new ArrayList<>();\\n        getInorder(root, lst);\\n        \\n        // An almost sorted array with two elements swapped\\n        int mismatch1 = 0;\\n        int mismatch2 = 0;\\n        // from left to right\\n        for(int i = 0; i < lst.size()-1; i++){\\n            if(lst.get(i) > lst.get(i+1)){\\n                mismatch1 = lst.get(i);\\n                break;\\n            }\\n        }\\n        \\n        // from right to left\\n        for(int i = lst.size()-1; i > 0; i--){\\n            if(lst.get(i) < lst.get(i-1)){\\n                mismatch2 = lst.get(i);\\n                break;\\n            }\\n        }\\n        \\n        // find the two nodes with val to mismatch1 and 2\\n        dfs(root, mismatch1, mismatch2);\\n        \\n        // swap the value\\n        int temp = m1.val;\\n        m1.val = m2.val;\\n        m2.val = temp;\\n    }\\n    \\n    public void getInorder(TreeNode root, List<Integer> lst){\\n        if(root == null) return;\\n        getInorder(root.left, lst);\\n        lst.add(root.val);\\n        getInorder(root.right, lst);\\n    }\\n    \\n    public void dfs(TreeNode root, int mismatch1, int mismatch2){\\n        if(root == null) return;\\n        if(root.val == mismatch1){\\n            m1 = root;\\n        }else if(root.val == mismatch2){\\n            m2 = root;\\n        }\\n        \\n        dfs(root.left, mismatch1, mismatch2);\\n        dfs(root.right, mismatch1, mismatch2);\\n    }\\n    \\n}\\n```\n```\\n// Time: O(N)\\n// Space: O(1) except the recursive stack\\nclass Solution {\\n    TreeNode m1 = null;\\n    TreeNode m2 = null;\\n    boolean foundM1 = false;\\n    boolean foundM2 = false;\\n    public void recoverTree(TreeNode root) {\\n        inorderForward(root); // forward\\n        inorderBackward(root); // backward\\n       \\n        int temp = m1.val;\\n        m1.val = m2.val;\\n        m2.val = temp;\\n    }\\n    \\n    public void inorderForward(TreeNode root){\\n        if(root == null) return;\\n        inorderForward(root.left);\\n        \\n        if(m1 != null && m1.val > root.val){\\n            foundM1 = true;\\n            return;\\n        }\\n        if(!foundM1)\\n            m1 = root;\\n        inorderForward(root.right);\\n    }\\n    \\n    public void inorderBackward(TreeNode root){\\n        if(root == null) return;\\n        inorderBackward(root.right);\\n        if(m2 != null && m2.val < root.val){\\n            foundM2 = true;\\n            return;\\n        }\\n       \\n        if(!foundM2)\\n            m2 = root;\\n        inorderBackward(root.left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779010,
                "title": "python-in-order-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        # get in-order traversal, sort, check the difference\\n        container = []\\n        def traverse(node):\\n            if not node:\\n                return\\n            traverse(node.left)\\n            container.append((node.val, node))\\n            traverse(node.right)\\n        traverse(root)\\n        target = sorted(container)\\n        for i in range(len(container)):\\n            currNode, targetNode = container[i][1], target[i][1]\\n            if currNode != targetNode:\\n                currNode.val, targetNode.val = targetNode.val, currNode.val\\n                break\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        # get in-order traversal, sort, check the difference\\n        container = []\\n        def traverse(node):\\n            if not node:\\n                return\\n            traverse(node.left)\\n            container.append((node.val, node))\\n            traverse(node.right)\\n        traverse(root)\\n        target = sorted(container)\\n        for i in range(len(container)):\\n            currNode, targetNode = container[i][1], target[i][1]\\n            if currNode != targetNode:\\n                currNode.val, targetNode.val = targetNode.val, currNode.val\\n                break\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 744137,
                "title": "simple-golang-in-order-and-pointer-based-solution",
                "content": "```\\n/*\\nWe need to find the first and second elements that are not in order right?\\n\\nHow do we find these two elements? For example, we have the following tree that is printed as in order traversal:\\n\\n6, 3, 4, 5, 2\\n\\nWe compare each node with its next one and we can find out that 6 is the first element to swap because 6 > 3 and 2 is the second element to swap because 2 < 5.\\n\\nReally, what we are comparing is the current node and its previous node in the \"in order traversal\".\\n\\ncc https://leetcode.com/problems/recover-binary-search-tree/discuss/32535/No-Fancy-Algorithm-just-Simple-and-Powerful-In-Order-Traversal\\n*/\\nfunc recoverTree(root *TreeNode)  {\\n    var prevEle,firstEle,secondEle *TreeNode\\n    firstEle,secondEle = nil,nil\\n    INT_MIN := -1*int(1e10)\\n    prevEle = &TreeNode{Val:INT_MIN,Left:nil,Right:nil}\\n    traverse(root,&prevEle,&firstEle,&secondEle)\\n    if firstEle != nil && secondEle!= nil{\\n        firstEle.Val,secondEle.Val = secondEle.Val,firstEle.Val\\n    }\\n}\\n\\nfunc traverse(root *TreeNode, prevEle,firstEle,secondEle **TreeNode) {\\n    if root==nil{\\n        return\\n    }\\n    traverse(root.Left,prevEle,firstEle,secondEle)\\n    //fmt.Println(root.Val,(*prevEle).Val,*firstEle,*secondEle)\\n    if *firstEle == nil && (*prevEle).Val >= root.Val{\\n        *firstEle = *prevEle    \\n    }\\n    if *firstEle != nil && (*prevEle).Val >= root.Val{\\n        *secondEle = root    \\n    }\\n    *prevEle = root\\n    traverse(root.Right,prevEle,firstEle,secondEle)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/*\\nWe need to find the first and second elements that are not in order right?\\n\\nHow do we find these two elements? For example, we have the following tree that is printed as in order traversal:\\n\\n6, 3, 4, 5, 2\\n\\nWe compare each node with its next one and we can find out that 6 is the first element to swap because 6 > 3 and 2 is the second element to swap because 2 < 5.\\n\\nReally, what we are comparing is the current node and its previous node in the \"in order traversal\".\\n\\ncc https://leetcode.com/problems/recover-binary-search-tree/discuss/32535/No-Fancy-Algorithm-just-Simple-and-Powerful-In-Order-Traversal\\n*/\\nfunc recoverTree(root *TreeNode)  {\\n    var prevEle,firstEle,secondEle *TreeNode\\n    firstEle,secondEle = nil,nil\\n    INT_MIN := -1*int(1e10)\\n    prevEle = &TreeNode{Val:INT_MIN,Left:nil,Right:nil}\\n    traverse(root,&prevEle,&firstEle,&secondEle)\\n    if firstEle != nil && secondEle!= nil{\\n        firstEle.Val,secondEle.Val = secondEle.Val,firstEle.Val\\n    }\\n}\\n\\nfunc traverse(root *TreeNode, prevEle,firstEle,secondEle **TreeNode) {\\n    if root==nil{\\n        return\\n    }\\n    traverse(root.Left,prevEle,firstEle,secondEle)\\n    //fmt.Println(root.Val,(*prevEle).Val,*firstEle,*secondEle)\\n    if *firstEle == nil && (*prevEle).Val >= root.Val{\\n        *firstEle = *prevEle    \\n    }\\n    if *firstEle != nil && (*prevEle).Val >= root.Val{\\n        *secondEle = root    \\n    }\\n    *prevEle = root\\n    traverse(root.Right,prevEle,firstEle,secondEle)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712943,
                "title": "c-concise-morris-traversal",
                "content": "We know Inorder Traversal of BST gives elements in increasing order and if a pair of elements are swapped in BST then we will have two junction points at which increasing sequence is not followed. If all elements are distinct in BST, then at those junction points first element is greater than second element(which comes just after first element in Inorder Traversal).\\n\\nIn code below flag=0 represents 1st junction point and flag=1 represents 2nd junction point, also a and b represents first and second element respectively at a junction.\\nWe need to store first element at 1st junction and second element at 2nd junction and swap them at last to correct BST.\\nFor example Inorder traversal of a BST is given **[1, 2, 3, 4, 5, 6, 7, 8]** and **3 & 7** are swapped.\\nSo sequence we will have **[1, 2, 7, 4, 5, 6, 3, 8]** making **7,4** and **6,3** two junctions. Store *needed* values in variables and swap them at 2nd junction.\\nIf **4 & 5** is swapped then the two junctions will overlap and in this we need to do swapping of variables outside while loop.\\n\\nInorder Traversal can be done using recursion or stack, but then space complexity will be O(h) where h is height of tree.\\nUse Morris Traversal to do Inorder Traversal for O(1) space complexity.\\nTime Complexity: O(n).\\n\\nSee Morris Traversal at : https://youtu.be/wGXB9OWhPTg?list=PLrmLmBdmIlpv_jNDXtJGYTPNQ2L1gdHxu\\n\\n    class Solution {\\n    public:\\n    void recoverTree(TreeNode* A) {\\n        TreeNode *root=A;\\n        TreeNode *a=NULL, *b=NULL;\\n        int flag=0;\\n        TreeNode *l, *r;\\n        \\n        while(root){\\n            if(root->left==NULL){\\n                a=b;\\n                b=root;\\n                \\n                if(a && b && flag==0 && a->val>b->val){\\n                    l=a;\\n                    r=b;\\n                    flag=1;\\n                }\\n                else if(a && b && flag==1 && a->val>b->val){\\n                    r=b;\\n                    swap(l->val,r->val);\\n                    flag=2;\\n                }\\n                \\n                root=root->right;\\n            }\\n            else{\\n                TreeNode* pred=root->left;\\n                while(pred->right!=root && pred->right!=NULL){\\n                    pred=pred->right;\\n                }\\n                \\n                if(pred->right==NULL){\\n                    pred->right=root;\\n                    root=root->left;\\n                }\\n                else{\\n                    pred->right=NULL;\\n                    a=b;\\n                    b=root;\\n\\n                    if(a && b && flag==0 && a->val>b->val){\\n                        l=a;\\n                        r=b;\\n                        flag=1;\\n                    }\\n                    else if(a && b && flag==1 && a->val>b->val){\\n                        r=b;\\n                        swap(l->val,r->val);\\n                        flag=2;\\n                    }\\n                    \\n                    root=root->right;\\n                }\\n            }\\n        }\\n        \\n        if(flag==1) swap(l->val,r->val);\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    void recoverTree(TreeNode* A) {\\n        TreeNode *root=A;\\n        TreeNode *a=NULL, *b=NULL;\\n        int flag=0;\\n        TreeNode *l, *r;\\n        \\n        while(root){\\n            if(root->left==NULL){\\n                a=b;\\n                b=root;\\n                \\n                if(a && b && flag==0 && a->val>b->val){\\n                    l=a;\\n                    r=b;\\n                    flag=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 544391,
                "title": "go-inorder-traversal-solution",
                "content": "```\\nfunc recoverTree(root *TreeNode) {\\n\\tvar first, second, prev *TreeNode\\n\\ttraverse(root, &first, &second, &prev)\\n\\tfirst.Val, second.Val = second.Val, first.Val\\n}\\n\\nfunc traverse(root *TreeNode, first, second, prev **TreeNode) {\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\ttraverse(root.Left, first, second, prev)\\n\\tif *prev != nil && (*prev).Val >= root.Val {\\n\\t\\tif *first == nil {\\n\\t\\t\\t*first = *prev\\n\\t\\t}\\n\\t\\t*second = root\\n\\t}\\n\\t*prev = root\\n\\ttraverse(root.Right, first, second, prev)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc recoverTree(root *TreeNode) {\\n\\tvar first, second, prev *TreeNode\\n\\ttraverse(root, &first, &second, &prev)\\n\\tfirst.Val, second.Val = second.Val, first.Val\\n}\\n\\nfunc traverse(root *TreeNode, first, second, prev **TreeNode) {\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\ttraverse(root.Left, first, second, prev)\\n\\tif *prev != nil && (*prev).Val >= root.Val {\\n\\t\\tif *first == nil {\\n\\t\\t\\t*first = *prev\\n\\t\\t}\\n\\t\\t*second = root\\n\\t}\\n\\t*prev = root\\n\\ttraverse(root.Right, first, second, prev)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489570,
                "title": "java-solution-2ms-beats-90-java-submissions",
                "content": "My approach is simple I maintain two nodes (First and sec) and a node to keep track of prev Node.\\nWhenever I have prev node and value in prev is > val of current node (In Inorder Traversal) I check if I have first node == null or not.. If i have first == null -> I make sure first node will be prev (as prev.val > cur_node.val) and also i keep track of sec, make sec = cur_node\\n**Time Complexity -> O(N)**\\n**Space Complexity -> O(h) where h - height of BST O(logN)**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode first;\\n    public TreeNode sec;\\n    public TreeNode prev;\\n    public void recover(TreeNode root) {\\n        if (root == null) return;\\n        // go to left side \\n        recover(root.left);\\n        if (prev != null && prev.val > root.val) {\\n            if (first == null) {\\n                first = prev;\\n            }\\n            sec = root;\\n        }\\n        prev = root;\\n        // go to right side\\n        recover(root.right);\\n    }\\n    public void recoverTree(TreeNode root) {\\n        recover(root);\\n        // swap the nodes\\n        if (first != null) {\\n            int tmp = first.val;\\n            first.val = sec.val;\\n            sec.val = tmp;\\n        }\\n    }\\n}\\n**Here is my code for swapping two nodes to correct a BST**\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode first;\\n    public TreeNode sec;\\n    public TreeNode prev;\\n    public void recover(TreeNode root) {\\n        if (root == null) return;\\n        // go to left side \\n        recover(root.left);\\n        if (prev != null && prev.val > root.val) {\\n            if (first == null) {\\n                first = prev;\\n            }\\n            sec = root;\\n        }\\n        prev = root;\\n        // go to right side\\n        recover(root.right);\\n    }\\n    public void recoverTree(TreeNode root) {\\n        recover(root);\\n        // swap the nodes\\n        if (first != null) {\\n            int tmp = first.val;\\n            first.val = sec.val;\\n            sec.val = tmp;\\n        }\\n    }\\n}\\n**Here is my code for swapping two nodes to correct a BST**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466643,
                "title": "2ms-java-solution-96-5-with-explanation",
                "content": "Let\\'s start with hypothesis that one swapped element is in the left subtree and another is in the right subtree.  In a valid BST we expect largest element in left subtree should be less than smallest element in the right subtree.  Let\\'s find largest element on the left and smallest element on the right.\\nIf largest on the left is larger than smallest on the right - congrats  - we have found two anomalies, let\\'s swap them and we are done.  If not, let\\'s check hypotehsis that root is one of the swapped elements, by checking the largest and smallest in subtrees against the root.  If the hypothesis that root is one of the swapped elements turns out to be wrong as well, the swap has happened in one of the subtrees, either in the left or right, so we apply our method recursively to left and right subtrees.\\n\\n```\\nclass Solution {\\n    \\n    public void recoverTree(TreeNode root) {\\n        if (root== null) {\\n            return;\\n        }\\n        TreeNode largest = findLargest(root.left, root);\\n        TreeNode smallest = findSmallest(root.right, root);       \\n        if (largest.val > smallest.val) {  //two anomalies are found\\n            swap(largest, smallest);\\n        } else if (smallest.val < root.val) { //root is one of the swapped elements\\n            swap(root, smallest);\\n        } else if (largest.val > root.val) {  //root is one of the swapped elements\\n            swap(largest, root); \\n        } else {  // swap has happened in one of the subtrees\\n            recoverTree(root.left);\\n            recoverTree(root.right);\\n        }\\n    }\\n    \\n\\n        \\n    TreeNode findLargest(TreeNode root, TreeNode max) {\\n        if (root==null) return max;\\n        if (root.val > max.val) {\\n            max = root;\\n        }\\n        TreeNode left = findLargest(root.left, max);\\n        if (left.val > max.val) {\\n            max = left;\\n        }\\n        TreeNode right = findLargest(root.right, max);\\n        if (right.val > max.val) {\\n            max = right;\\n        }\\n        return max;\\n    }\\n    \\n    TreeNode findSmallest(TreeNode root, TreeNode min) {\\n        if (root==null) return min;\\n        if (root.val < min.val) {\\n            min = root;\\n        }\\n        TreeNode left = findSmallest(root.left, min);\\n        if (left.val < min.val) {\\n            min = left;\\n        }\\n        TreeNode right = findSmallest(root.right, min);\\n        if (right.val < min.val) {\\n            min = right;\\n        }\\n        return min;\\n    }\\n    \\n    void swap(TreeNode a, TreeNode b) {\\n        int temp  = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public void recoverTree(TreeNode root) {\\n        if (root== null) {\\n            return;\\n        }\\n        TreeNode largest = findLargest(root.left, root);\\n        TreeNode smallest = findSmallest(root.right, root);       \\n        if (largest.val > smallest.val) {  //two anomalies are found\\n            swap(largest, smallest);\\n        } else if (smallest.val < root.val) { //root is one of the swapped elements\\n            swap(root, smallest);\\n        } else if (largest.val > root.val) {  //root is one of the swapped elements\\n            swap(largest, root); \\n        } else {  // swap has happened in one of the subtrees\\n            recoverTree(root.left);\\n            recoverTree(root.right);\\n        }\\n    }\\n    \\n\\n        \\n    TreeNode findLargest(TreeNode root, TreeNode max) {\\n        if (root==null) return max;\\n        if (root.val > max.val) {\\n            max = root;\\n        }\\n        TreeNode left = findLargest(root.left, max);\\n        if (left.val > max.val) {\\n            max = left;\\n        }\\n        TreeNode right = findLargest(root.right, max);\\n        if (right.val > max.val) {\\n            max = right;\\n        }\\n        return max;\\n    }\\n    \\n    TreeNode findSmallest(TreeNode root, TreeNode min) {\\n        if (root==null) return min;\\n        if (root.val < min.val) {\\n            min = root;\\n        }\\n        TreeNode left = findSmallest(root.left, min);\\n        if (left.val < min.val) {\\n            min = left;\\n        }\\n        TreeNode right = findSmallest(root.right, min);\\n        if (right.val < min.val) {\\n            min = right;\\n        }\\n        return min;\\n    }\\n    \\n    void swap(TreeNode a, TreeNode b) {\\n        int temp  = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319748,
                "title": "swift-100-beaten-using-van-morrison-traversal-o-n-lewptie-lewpz",
                "content": "The harder you lewp, the more you poop.\\n\\n```\\nclass Solution {\\n    func recoverTree(_ root: TreeNode?) {\\n        \\n        var node: TreeNode! = root\\n        var prev: TreeNode!\\n        var parent: TreeNode!\\n        \\n        var swap1: TreeNode!\\n        var swap2: TreeNode!\\n        \\n        while node !== nil {\\n            \\n            if node.left === nil {\\n                if parent !== nil && node !== nil && parent.val > node.val {\\n                    if swap1 == nil { swap1 = parent }\\n                    swap2 = node\\n                }\\n                \\n                parent = node\\n                node = node.right\\n            } else {\\n                \\n                prev = node.left\\n                while prev.right !== nil && prev.right !== node { prev = prev.right }\\n                \\n                if prev.right === nil {\\n                    prev.right = node\\n                    node = node.left\\n                } else {\\n                    if parent !== nil && node !== nil && parent.val > node.val {\\n                        if swap1 == nil { swap1 = parent }\\n                        swap2 = node\\n                    }\\n                    parent = node\\n                    node = node.right\\n                    prev.right = nil\\n                }\\n            }\\n        }\\n        \\n        if swap1 !== nil && swap2 !== nil {\\n            var hold = swap1.val\\n            swap1.val = swap2.val\\n            swap2.val = hold\\n        }\\n    }\\n}\\n```\\n\\nKaboom, baby. We got the nukez.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func recoverTree(_ root: TreeNode?) {\\n        \\n        var node: TreeNode! = root\\n        var prev: TreeNode!\\n        var parent: TreeNode!\\n        \\n        var swap1: TreeNode!\\n        var swap2: TreeNode!\\n        \\n        while node !== nil {\\n            \\n            if node.left === nil {\\n                if parent !== nil && node !== nil && parent.val > node.val {\\n                    if swap1 == nil { swap1 = parent }\\n                    swap2 = node\\n                }\\n                \\n                parent = node\\n                node = node.right\\n            } else {\\n                \\n                prev = node.left\\n                while prev.right !== nil && prev.right !== node { prev = prev.right }\\n                \\n                if prev.right === nil {\\n                    prev.right = node\\n                    node = node.left\\n                } else {\\n                    if parent !== nil && node !== nil && parent.val > node.val {\\n                        if swap1 == nil { swap1 = parent }\\n                        swap2 = node\\n                    }\\n                    parent = node\\n                    node = node.right\\n                    prev.right = nil\\n                }\\n            }\\n        }\\n        \\n        if swap1 !== nil && swap2 !== nil {\\n            var hold = swap1.val\\n            swap1.val = swap2.val\\n            swap2.val = hold\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319133,
                "title": "c-using-morrison-traversal-o-n-no-recursion-no-bad-looping",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        TreeNode *aNode = root;\\n        TreeNode *aPrev = NULL;\\n        TreeNode *aParent = NULL;\\n        \\n        TreeNode *aSwap1 = NULL;\\n        TreeNode *aSwap2 = NULL;\\n        \\n        while (aNode != NULL) {\\n            \\n            if (!aNode->left) {\\n                \\n                if (aParent != NULL && aNode != NULL && aParent->val > aNode->val) {\\n                    if (aSwap1 == NULL) { aSwap1 = aParent; }\\n                    aSwap2 = aNode;\\n                }\\n                \\n                aParent = aNode;\\n                aNode = aNode->right;\\n            } else {\\n             \\n                aPrev = aNode->left;\\n                while (aPrev->right != NULL && aPrev->right != aNode) {\\n                    aPrev = aPrev->right;\\n                }\\n                \\n                if (aPrev->right == NULL) {\\n                    aPrev->right = aNode;\\n                    aNode = aNode->left;\\n                } else {\\n                    aPrev->right = NULL;\\n                    if (aParent != NULL && aNode != NULL && aParent->val > aNode->val) {\\n                        if (aSwap1 == NULL) { aSwap1 = aParent; }\\n                        aSwap2 = aNode;\\n                    }\\n                    aParent = aNode;\\n                    aNode = aNode->right;\\n                }\\n            }\\n        }\\n        if (aSwap1 != NULL && aSwap2 != NULL) { swap(aSwap1->val, aSwap2->val); }\\n    }\\n    \\n    \\n};\\n```\\n\\nKaboom, awesome. Enjoy.",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        TreeNode *aNode = root;\\n        TreeNode *aPrev = NULL;\\n        TreeNode *aParent = NULL;\\n        \\n        TreeNode *aSwap1 = NULL;\\n        TreeNode *aSwap2 = NULL;\\n        \\n        while (aNode != NULL) {\\n            \\n            if (!aNode->left) {\\n                \\n                if (aParent != NULL && aNode != NULL && aParent->val > aNode->val) {\\n                    if (aSwap1 == NULL) { aSwap1 = aParent; }\\n                    aSwap2 = aNode;\\n                }\\n                \\n                aParent = aNode;\\n                aNode = aNode->right;\\n            } else {\\n             \\n                aPrev = aNode->left;\\n                while (aPrev->right != NULL && aPrev->right != aNode) {\\n                    aPrev = aPrev->right;\\n                }\\n                \\n                if (aPrev->right == NULL) {\\n                    aPrev->right = aNode;\\n                    aNode = aNode->left;\\n                } else {\\n                    aPrev->right = NULL;\\n                    if (aParent != NULL && aNode != NULL && aParent->val > aNode->val) {\\n                        if (aSwap1 == NULL) { aSwap1 = aParent; }\\n                        aSwap2 = aNode;\\n                    }\\n                    aParent = aNode;\\n                    aNode = aNode->right;\\n                }\\n            }\\n        }\\n        if (aSwap1 != NULL && aSwap2 != NULL) { swap(aSwap1->val, aSwap2->val); }\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317222,
                "title": "java-inorder-traversal",
                "content": "Simple Java traversal.\\n\\n   \\n\\tpublic void recoverTree(TreeNode root) {\\n       \\n\\t    if (root == null) return;\\n\\t\\t\\n        TreeNode n1 = null, n2 = null;\\n        TreeNode last = null;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while (root != null) {\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            TreeNode cur = stack.pop();\\n            if (last != null) {\\n                if (cur.val < last.val) {\\n                    n2 = cur;\\n                    if (n1 == null) n1 = last;\\n                }\\n            }\\n            last = cur;\\n            if (cur.right != null) {\\n                cur = cur.right;\\n                while (cur != null) {\\n                    stack.push(cur);\\n                    cur = cur.left;\\n                }\\n            } else {\\n                while (!stack.isEmpty() && stack.peek().right == cur) {\\n                    cur = stack.pop();\\n                }\\n            }\\n        }\\n        \\n        int temp = n1.val;\\n        n1.val = n2.val;\\n        n2.val = temp;\\n    }",
                "solutionTags": [],
                "code": "Simple Java traversal.\\n\\n   \\n\\tpublic void recoverTree(TreeNode root) {\\n       \\n\\t    if (root == null) return;\\n\\t\\t\\n        TreeNode n1 = null, n2 = null;\\n        TreeNode last = null;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while (root != null) {\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            TreeNode cur = stack.pop();\\n            if (last != null) {\\n                if (cur.val < last.val) {\\n                    n2 = cur;\\n                    if (n1 == null) n1 = last;\\n                }\\n            }\\n            last = cur;\\n            if (cur.right != null) {\\n                cur = cur.right;\\n                while (cur != null) {\\n                    stack.push(cur);\\n                    cur = cur.left;\\n                }\\n            } else {\\n                while (!stack.isEmpty() && stack.peek().right == cur) {\\n                    cur = stack.pop();\\n                }\\n            }\\n        }\\n        \\n        int temp = n1.val;\\n        n1.val = n2.val;\\n        n2.val = temp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 295724,
                "title": "java-solution-with-explanation",
                "content": "**Idea**\\nIt is not hard to see that in-order traversal on BST should reveal misplaced elements. But the key point to understand is how do you judge which elements are misplaced when you do in-order since you only have min element to compare curr with and no max.\\nThat is, say BST min property violated at  `curr`, we found the first element (`min`) that is misplaced.\\nIf there is another element violating min property, then we found the two elements we need (`val1` is `min` identified eralier and `val2` is `curr`). But there could be a case, you do not see another element violating min property. In that case, both `min` and `curr` when we saw min property violated must be the elements swapped For ex: `[3,1,4,null,null,2]`.\\n\\n```\\nclass Solution {\\n    TreeNode val1 = null, val2 = null;\\n    TreeNode min = null;\\n    public void recoverTree(TreeNode root) {\\n        walk(root);\\n        int tmp = val1.val;\\n        val1.val = val2.val;\\n        val2.val = tmp;\\n    }\\n    private void walk(TreeNode curr){\\n        if(curr == null) return;\\n        walk(curr.left);\\n        if(min != null && curr.val < min.val){\\n            if(val1 == null){\\n                val1 = min;\\n                val2 = curr;\\n            }else\\n                val2 = curr; //override previous val2 since there are only two misplaced elems\\n        }\\n        min = curr;\\n        walk(curr.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode val1 = null, val2 = null;\\n    TreeNode min = null;\\n    public void recoverTree(TreeNode root) {\\n        walk(root);\\n        int tmp = val1.val;\\n        val1.val = val2.val;\\n        val2.val = tmp;\\n    }\\n    private void walk(TreeNode curr){\\n        if(curr == null) return;\\n        walk(curr.left);\\n        if(min != null && curr.val < min.val){\\n            if(val1 == null){\\n                val1 = min;\\n                val2 = curr;\\n            }else\\n                val2 = curr; //override previous val2 since there are only two misplaced elems\\n        }\\n        min = curr;\\n        walk(curr.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229230,
                "title": "python-in-order-traversal",
                "content": "Inspired by the brilient solution and explanation from @qwl5004 ([Link](https://leetcode.com/problems/recover-binary-search-tree/discuss/32535/No-Fancy-Algorithm-just-Simple-and-Powerful-In-Order-Traversal)). Here is the python version of the solution:\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def __init__(self):\\n        self.prevEle = TreeNode(-float(\\'inf\\'))\\n        self.firstEle = None\\n        self.secondEle = None\\n    \\n    def inOrder(self, root):\\n        if not root:\\n            return\\n        self.inOrder(root.left)\\n        \\n        if not self.firstEle and (root.val < self.prevEle.val):\\n            self.firstEle = self.prevEle\\n        if self.firstEle and (root.val < self.prevEle.val):\\n            self.secondEle = root\\n        \\n        self.prevEle = root\\n        self.inOrder(root.right)\\n    \\n    \\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        \\n        self.inOrder(root)\\n        if not self.firstEle or not self.secondEle:\\n            return\\n        self.firstEle.val, self.secondEle.val = self.secondEle.val, self.firstEle.val\\n        return\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def __init__(self):\\n        self.prevEle = TreeNode(-float(\\'inf\\'))\\n        self.firstEle = None\\n        self.secondEle = None\\n    \\n    def inOrder(self, root):\\n        if not root:\\n            return\\n        self.inOrder(root.left)\\n        \\n        if not self.firstEle and (root.val < self.prevEle.val):\\n            self.firstEle = self.prevEle\\n        if self.firstEle and (root.val < self.prevEle.val):\\n            self.secondEle = root\\n        \\n        self.prevEle = root\\n        self.inOrder(root.right)\\n    \\n    \\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        \\n        self.inOrder(root)\\n        if not self.firstEle or not self.secondEle:\\n            return\\n        self.firstEle.val, self.secondEle.val = self.secondEle.val, self.firstEle.val\\n        return\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567676,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1565658,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1723131,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1566715,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1567858,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1787057,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1575663,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1568921,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1575958,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1572172,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1567676,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1565658,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1723131,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1566715,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1567858,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1787057,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1575663,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1568921,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1575958,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1572172,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1963829,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 1572798,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 1572032,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 1571212,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2071864,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2049985,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2027652,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2026209,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2004429,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 1991777,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Right Side View",
        "question_content": "<p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" style=\"width: 401px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,5,null,4]\n<strong>Output:</strong> [1,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3]\n<strong>Output:</strong> [1,3]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 56012,
                "title": "my-simple-accepted-solution-java",
                "content": "The core idea of this algorithm: \\n\\n1.Each depth of the tree only select one node.  \\n2. View depth is current size of result list.\\n\\nHere is the code: \\n\\n    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            rightView(root, result, 0);\\n            return result;\\n        }\\n        \\n        public void rightView(TreeNode curr, List<Integer> result, int currDepth){\\n            if(curr == null){\\n                return;\\n            }\\n            if(currDepth == result.size()){\\n                result.add(curr.val);\\n            }\\n            \\n            rightView(curr.right, result, currDepth + 1);\\n            rightView(curr.left, result, currDepth + 1);\\n            \\n        }\\n    }\\n\\t\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            rightView(root, result, 0);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56003,
                "title": "my-c-solution-modified-preorder-traversal",
                "content": "    class Solution {\\n    public:\\n        void recursion(TreeNode *root, int level, vector<int> &res)\\n        {\\n            if(root==NULL) return ;\\n            if(res.size()<level) res.push_back(root->val);\\n            recursion(root->right, level+1, res);\\n            recursion(root->left, level+1, res);\\n        }\\n        \\n        vector<int> rightSideView(TreeNode *root) {\\n            vector<int> res;\\n            recursion(root, 1, res);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void recursion(TreeNode *root, int level, vector<int> &res)\\n        {\\n            if(root==NULL) return ;\\n            if(res.size()<level) res.push_back(root->val);\\n            recursion(root->right, level+1, res);\\n            recursion(root->left, level+1, res);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56064,
                "title": "5-9-lines-python-48-ms",
                "content": "Solution 1: **Recursive, combine right and left:** 5 lines, 56 ms\\n\\nCompute the right view of both right and left left subtree, then combine them. For very unbalanced trees, this can be O(n^2), though.\\n\\n    def rightSideView(self, root):\\n        if not root:\\n            return []\\n        right = self.rightSideView(root.right)\\n        left = self.rightSideView(root.left)\\n        return [root.val] + right + left[len(right):]\\n\\n---\\n\\nSolution 2: **Recursive, first come first serve:** 9 lines, 48 ms\\n\\nDFS-traverse the tree right-to-left, add values to the view whenever we first reach a new record depth. This is O(n).\\n\\n    def rightSideView(self, root):\\n        def collect(node, depth):\\n            if node:\\n                if depth == len(view):\\n                    view.append(node.val)\\n                collect(node.right, depth+1)\\n                collect(node.left, depth+1)\\n        view = []\\n        collect(root, 0)\\n        return view\\n\\n---\\n\\nSolution 3: **Iterative, level-by-level:** 7 lines, 48 ms\\n\\nTraverse the tree level by level and add the last value of each level to the view. This is O(n).\\n\\n    def rightSideView(self, root):\\n        view = []\\n        if root:\\n            level = [root]\\n            while level:\\n                view += level[-1].val,\\n                level = [kid for node in level for kid in (node.left, node.right) if kid]\\n        return view",
                "solutionTags": [
                    "Python"
                ],
                "code": "Solution 1: **Recursive, combine right and left:** 5 lines, 56 ms\\n\\nCompute the right view of both right and left left subtree, then combine them. For very unbalanced trees, this can be O(n^2), though.\\n\\n    def rightSideView(self, root):\\n        if not root:\\n            return []\\n        right = self.rightSideView(root.right)\\n        left = self.rightSideView(root.left)\\n        return [root.val] + right + left[len(right):]\\n\\n---\\n\\nSolution 2: **Recursive, first come first serve:** 9 lines, 48 ms\\n\\nDFS-traverse the tree right-to-left, add values to the view whenever we first reach a new record depth. This is O(n).\\n\\n    def rightSideView(self, root):\\n        def collect(node, depth):\\n            if node:\\n                if depth == len(view):\\n                    view.append(node.val)\\n                collect(node.right, depth+1)\\n                collect(node.left, depth+1)\\n        view = []\\n        collect(root, 0)\\n        return view\\n\\n---\\n\\nSolution 3: **Iterative, level-by-level:** 7 lines, 48 ms\\n\\nTraverse the tree level by level and add the last value of each level to the view. This is O(n).\\n\\n    def rightSideView(self, root):\\n        view = []\\n        if root:\\n            level = [root]\\n            while level:\\n                view += level[-1].val,\\n                level = [kid for node in level for kid in (node.left, node.right) if kid]\\n        return view",
                "codeTag": "Python3"
            },
            {
                "id": 56076,
                "title": "reverse-level-order-traversal-java",
                "content": "    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            // reverse level traversal\\n            List<Integer> result = new ArrayList();\\n            Queue<TreeNode> queue = new LinkedList();\\n            if (root == null) return result;\\n            \\n            queue.offer(root);\\n            while (queue.size() != 0) {\\n                int size = queue.size();\\n                for (int i=0; i<size; i++) {\\n                    TreeNode cur = queue.poll();\\n                    if (i == 0) result.add(cur.val);\\n                    if (cur.right != null) queue.offer(cur.right);\\n                    if (cur.left != null) queue.offer(cur.left);\\n                }\\n                \\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            // reverse level traversal\\n            List<Integer> result = new ArrayList();\\n            Queue<TreeNode> queue = new LinkedList();\\n            if (root == null) return result;\\n            \\n            queue.offer(root);\\n            while (queue.size() != 0) {\\n                int size = queue.size();\\n                for (int i=0; i<size; i++) {\\n                    TreeNode cur = queue.poll();\\n                    if (i == 0) result.add(cur.val);\\n                    if (cur.right != null) queue.offer(cur.right);\\n                    if (cur.left != null) queue.offer(cur.left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3176211,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n        queue<TreeNode*> q;\\n        if(root==NULL)\\n        return ans;\\n        q.push(root);\\n        while(1)\\n        {\\n            int size=q.size();\\n            if(size==0)\\n            return ans;\\n            vector<int> data;\\n            while(size--)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                data.push_back(temp->val);\\n                if(temp->left!=NULL)\\n                q.push(temp->left);\\n                if(temp->right!=NULL)\\n                q.push(temp->right);\\n            }\\n            ans.push_back(data.back());\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom collections import deque\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        queue = deque()\\n        if root is None:\\n            return []\\n        \\n        if root.left is None and root.right is None:\\n            return [root.val]\\n        \\n        result = []\\n        queue.append(root)\\n        while queue:\\n            child_queue = deque()\\n            prev = -1\\n            while queue:\\n                curr = queue.popleft()\\n\\n                if curr.left is not None:\\n                    child_queue.append(curr.left)\\n\\n                if curr.right is not None:\\n                    child_queue.append(curr.right)\\n                \\n                prev = curr\\n            \\n            result.append(prev.val)\\n            queue = child_queue\\n        \\n        return result\\n```\\n\\n```Java []\\nclass Solution {\\n    int maxlevel = 0;\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list  = new ArrayList<>();\\n        right(root,1,list);\\n        return list ;\\n    }\\n    void right(TreeNode root,int level,List<Integer> list){\\n        if(root==null){\\n            return ;\\n        }\\n        if(maxlevel<level){\\n            list.add(root.val);\\n            maxlevel=level;\\n        }\\n        right(root.right,level+1,list);\\n        right(root.left,level+1,list);\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n        queue<TreeNode*> q;\\n        if(root==NULL)\\n        return ans;\\n        q.push(root);\\n        while(1)\\n        {\\n            int size=q.size();\\n            if(size==0)\\n            return ans;\\n            vector<int> data;\\n            while(size--)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                data.push_back(temp->val);\\n                if(temp->left!=NULL)\\n                q.push(temp->left);\\n                if(temp->right!=NULL)\\n                q.push(temp->right);\\n            }\\n            ans.push_back(data.back());\\n        }\\n    }\\n};\\n```\n```Python3 []\\nfrom collections import deque\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        queue = deque()\\n        if root is None:\\n            return []\\n        \\n        if root.left is None and root.right is None:\\n            return [root.val]\\n        \\n        result = []\\n        queue.append(root)\\n        while queue:\\n            child_queue = deque()\\n            prev = -1\\n            while queue:\\n                curr = queue.popleft()\\n\\n                if curr.left is not None:\\n                    child_queue.append(curr.left)\\n\\n                if curr.right is not None:\\n                    child_queue.append(curr.right)\\n                \\n                prev = curr\\n            \\n            result.append(prev.val)\\n            queue = child_queue\\n        \\n        return result\\n```\n```Java []\\nclass Solution {\\n    int maxlevel = 0;\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list  = new ArrayList<>();\\n        right(root,1,list);\\n        return list ;\\n    }\\n    void right(TreeNode root,int level,List<Integer> list){\\n        if(root==null){\\n            return ;\\n        }\\n        if(maxlevel<level){\\n            list.add(root.val);\\n            maxlevel=level;\\n        }\\n        right(root.right,level+1,list);\\n        right(root.left,level+1,list);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56241,
                "title": "c-bfs-dfs",
                "content": "BFS (level-order traversal) is a good fit to this problem: just add the last node in each level to the result.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<int> view;\\n        queue<TreeNode*> todo;\\n        todo.push(root);\\n        while (!todo.empty()) {\\n            int n = todo.size();\\n            for (int i = 0; i < n; i++) {\\n                TreeNode* node = todo.front();\\n                todo.pop();\\n                if (i == n - 1) {\\n                    view.push_back(node -> val);\\n                }\\n                if (node -> left) {\\n                    todo.push(node -> left);\\n                }\\n                if (node -> right) {\\n                    todo.push(node -> right);\\n                }\\n            }\\n        }\\n        return view;\\n    }\\n};\\n```\\n\\nIt can also be solved using DFS.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> view;\\n        rightView(root, view, 0);\\n        return view;\\n    }\\nprivate:\\n    void rightView(TreeNode* root, vector<int>& view, int level) {\\n        if (!root) {\\n            return;\\n        }\\n        if (view.size() == level) {\\n            view.push_back(root -> val);\\n        }\\n        rightView(root -> right, view, level + 1);\\n        rightView(root -> left, view, level + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<int> view;\\n        queue<TreeNode*> todo;\\n        todo.push(root);\\n        while (!todo.empty()) {\\n            int n = todo.size();\\n            for (int i = 0; i < n; i++) {\\n                TreeNode* node = todo.front();\\n                todo.pop();\\n                if (i == n - 1) {\\n                    view.push_back(node -> val);\\n                }\\n                if (node -> left) {\\n                    todo.push(node -> left);\\n                }\\n                if (node -> right) {\\n                    todo.push(node -> right);\\n                }\\n            }\\n        }\\n        return view;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> view;\\n        rightView(root, view, 0);\\n        return view;\\n    }\\nprivate:\\n    void rightView(TreeNode* root, vector<int>& view, int level) {\\n        if (!root) {\\n            return;\\n        }\\n        if (view.size() == level) {\\n            view.push_back(root -> val);\\n        }\\n        rightView(root -> right, view, level + 1);\\n        rightView(root -> left, view, level + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56248,
                "title": "python-easy-to-understand-bfs-solution-level-by-level",
                "content": "```\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        deque = collections.deque()\\n        if root:\\n            deque.append(root)\\n        res = []\\n        while deque:\\n            size, val = len(deque), 0\\n            for _ in range(size):\\n                node = deque.popleft()\\n                val = node.val # store last value in each level\\n                if node.left:\\n                    deque.append(node.left)\\n                if node.right:\\n                    deque.append(node.right)\\n            res.append(val)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        deque = collections.deque()\\n        if root:\\n            deque.append(root)\\n        res = []\\n        while deque:\\n            size, val = len(deque), 0\\n            for _ in range(size):\\n                node = deque.popleft()\\n                val = node.val # store last value in each level\\n                if node.left:\\n                    deque.append(node.left)\\n                if node.right:\\n                    deque.append(node.right)\\n            res.append(val)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266055,
                "title": "c-python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nThe demand of the question is to get the nodes at ```i``` level that are rightmost.\\nAny nodes left to that would not be included in answer.\\n\\n\\n**Level order traversal could help but that uses addtional space for the QUEUE**\\n\\n**APPROACH with no extra space**\\n\\nMaintain an array / vector.\\n\\n* TRAVERSAL -> **ROOT ->RIGHT -> LEFT** This is the way traversal is done in array so that rightmost node at ```i``` level is visited first.\\n\\n* When at ```i``` level, check in array/vector, if there is an element already present at index```i``` in the array. \\n[ index represents the level in tree ]->**[element at index i is rightmost node at level i]**\\n* If at that level, *element is present,*, just continue the traversal.\\n* Else if no element is present at index ```i``` -> add that node to answer ```[res]``` at the ```i``` index.\\n\\n![image](https://assets.leetcode.com/users/images/91ac2026-ca9a-46f0-9c30-69138cf4127c_1657511747.9057133.jpeg)\\n![image](https://assets.leetcode.com/users/images/34815618-d722-485c-a276-94e1d7aa5caf_1657511962.541216.png)\\n\\n\\n\\n**UPVOTE IF HELPFuuL**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve(TreeNode* root, vector<int> res, int lvl){\\n        if (root==NULL){\\n            return res;\\n        }\\n        if (res.size()==lvl){                 // root\\n            res.push_back(root->val);\\n        }\\n        res = solve(root->right , res , lvl + 1);     // right\\n        res = solve(root->left , res , lvl + 1);       // left\\n        return res;\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        res = solve( root , res , 0 );\\n        return res;\\n    }\\n};\\n```\\n**UPVOTE IF HELPFuuL**\\n**PYTHON**\\n```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def solve(root, lvl):\\n        \\tif root:\\n        \\t\\tif len(res)==lvl:\\n        \\t\\t\\tres.append(root.val)\\n        \\t\\tsolve(root.right, lvl + 1)\\n        \\t\\tsolve(root.left, lvl + 1)\\n        \\treturn \\n\\n        res = []\\n        solve(root,0)\\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3fa693e3-7795-467c-969d-59986cf0595f_1657516166.1903412.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```i```\n```i```\n```i```\n```i```\n```i```\n```[res]```\n```i```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve(TreeNode* root, vector<int> res, int lvl){\\n        if (root==NULL){\\n            return res;\\n        }\\n        if (res.size()==lvl){                 // root\\n            res.push_back(root->val);\\n        }\\n        res = solve(root->right , res , lvl + 1);     // right\\n        res = solve(root->left , res , lvl + 1);       // left\\n        return res;\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        res = solve( root , res , 0 );\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def solve(root, lvl):\\n        \\tif root:\\n        \\t\\tif len(res)==lvl:\\n        \\t\\t\\tres.append(root.val)\\n        \\t\\tsolve(root.right, lvl + 1)\\n        \\t\\tsolve(root.left, lvl + 1)\\n        \\treturn \\n\\n        res = []\\n        solve(root,0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56203,
                "title": "simple-c-solution-btw-i-like-clean-codes",
                "content": "    class Solution {\\n    public:\\n        void dfs(TreeNode* root, int lv, vector<int> &res){\\n            if(!root)   return;\\n            if(lv>=res.size()) res.push_back(root->val);\\n            dfs(root->right,lv+1,res);\\n            dfs(root->left,lv+1,res);\\n        }\\n\\n        vector<int> rightSideView(TreeNode* root) {\\n            vector<int> res;\\n            dfs(root, 0, res);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void dfs(TreeNode* root, int lv, vector<int> &res){\\n            if(!root)   return;\\n            if(lv>=res.size()) res.push_back(root->val);\\n            dfs(root->right,lv+1,res);\\n            dfs(root->left,lv+1,res);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 559238,
                "title": "python-2-solutions-bfs-dfs-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS - Level by Level**\\n```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if root == None: return []\\n        ans = []\\n        q = deque([root])\\n        while q:\\n            lastNode = None\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                lastNode = cur\\n                if cur.left != None:\\n                    q.append(cur.left)\\n                if cur.right != None:\\n                    q.append(cur.right)\\n            ans.append(lastNode.val)\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 100` is the nunber of nodes in the binary tree.\\n- Space: `O(N)`, it\\'s the size of queue in the worst case.\\n\\n---\\n**\\u2714\\uFE0F Solution 2: DFS**\\n```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans = []\\n        \\n        def dfs(root, depth):\\n            if root == None: return\\n            if depth == len(self.ans):  # When we meet this `depth` for the first time, let\\'s add the first node as the right side most node.\\n                self.ans.append(root.val)\\n            dfs(root.right, depth + 1)  # Go right side first\\n            dfs(root.left, depth + 1)\\n            \\n        dfs(root, 0)\\n        return self.ans\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 100` is the nunber of nodes in the binary tree.\\n- Space: `O(H)`, where `H` is the height of the binary tree, it\\'s the depth of stack memory.\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if root == None: return []\\n        ans = []\\n        q = deque([root])\\n        while q:\\n            lastNode = None\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                lastNode = cur\\n                if cur.left != None:\\n                    q.append(cur.left)\\n                if cur.right != None:\\n                    q.append(cur.right)\\n            ans.append(lastNode.val)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans = []\\n        \\n        def dfs(root, depth):\\n            if root == None: return\\n            if depth == len(self.ans):  # When we meet this `depth` for the first time, let\\'s add the first node as the right side most node.\\n                self.ans.append(root.val)\\n            dfs(root.right, depth + 1)  # Go right side first\\n            dfs(root.left, depth + 1)\\n            \\n        dfs(root, 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549960,
                "title": "javascript-52ms-dfs",
                "content": "```\\nvar rightSideView = function(root) {\\n    if (!root) return [];\\n    let res = [];\\n    pre(root, 0);\\n    return res;\\n    \\n    function pre(node, h) {\\n        if (!node) return;\\n        res[h] = node.val;\\n        pre(node.left, h+1);\\n        pre(node.right, h+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar rightSideView = function(root) {\\n    if (!root) return [];\\n    let res = [];\\n    pre(root, 0);\\n    return res;\\n    \\n    function pre(node, h) {\\n        if (!node) return;\\n        res[h] = node.val;\\n        pre(node.left, h+1);\\n        pre(node.right, h+1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56178,
                "title": "simple-java-solution-w-recursion-2ms",
                "content": "    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            ArrayList list = new ArrayList();\\n            rightSideView(root, 0, list);\\n            \\n            return list;\\n        }\\n        \\n        public void rightSideView(TreeNode root, int level, ArrayList list) {\\n            if(root == null) return;\\n\\n            if(list.size() == level)\\n                list.add(root.val);\\n\\n            rightSideView(root.right, level + 1, list);\\n            rightSideView(root.left, level + 1, list);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            ArrayList list = new ArrayList();\\n            rightSideView(root, 0, list);\\n            \\n            return list;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3125913,
                "title": "java-all-tree-views-easy-fast",
                "content": "# Intuition\\n\\n<p>\\n    Code for All Views of a tree\\n</p>\\n<p>\\n    Meathod Of Solving -> Just Imagine the tree visual and think any traversal meathod, U can carry on further\\uD83D\\uDE01\\uD83D\\uDE09.\\n<p>\\n    Note: I have provided some sample test cases for practice\\n</p>\\n<p>\\n    <b><h3>Upvote If U feel Helpful!!!\\uD83D\\uDE0E\\u270C\\uFE0F\\uD83D\\uDE09</h3></b>\\n</p>\\n\\n# Test Case:\\n```\\nInput: 1 3 2\\n       1\\n    /    \\\\\\n   3      2\\nOutput: 1 2\\n\\nInput: 10 20 30 40 60\\n     10\\n    /   \\\\\\n  20     30\\n /   \\\\\\n40  60 \\nOutput: 10 30 60\\n\\n```\\n\\n# Right View -> Recursion\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        var list = new ArrayList<Integer>();\\n        rec(root,list,0);\\n        return list;\\n    }\\n    void rec(TreeNode root,ArrayList<Integer> list, int depth){\\n        if (root == null) return;\\n        if(list.size()==depth) list.add(root.val);\\n        if(root.right!=null) rec(root.right,list,depth+1);\\n        if(root.left!=null) rec(root.left,list,depth+1);\\n    }\\n}\\n```\\n\\n# Test Case:\\n```\\nInput: 1 3 2\\n\\n   1\\n /  \\\\\\n3    2\\n\\nOutput: 1 3\\n\\nInput: 4 5 2 null null 3 1 6 7\\n\\n      4\\n    /   \\\\\\n   5     2\\n       /   \\\\\\n      3     1\\n    /  \\\\\\n   6    7\\n\\nOutput: 4 5 3 6\\n```\\n\\n# Left View -> Recursion\\n```\\n/* A Binary Tree node\\nclass Node\\n{\\n    int data;\\n    Node left, right;\\n\\n    Node(int item)\\n    {\\n        data = item;\\n        left = right = null;\\n    }\\n}*/\\nclass Tree\\n{\\n    //Function to return list containing elements of left view of binary tree.\\n    ArrayList<Integer> leftView(Node root)\\n    {\\n      // Your code here\\n      var list = new ArrayList<Integer>();\\n      rec(root,list,0);\\n      return list;\\n    }\\n    void rec(Node root, ArrayList<Integer> list, int depth){\\n        if(root==null) return;\\n        if(list.size()==depth) list.add(root.data);\\n        if(root.left!=null) rec(root.left,list,depth+1);\\n        if(root.right!=null) rec(root.right,list,depth+1);\\n    }\\n}\\n```\\n# Test Case:\\n```\\nInput: 1 2 3\\n\\n      1\\n   /    \\\\\\n  2      3\\n\\nOutput: 2 1 3\\n\\nInput: 10 20 30 40 60 90 100\\n\\n       10\\n    /      \\\\\\n  20        30\\n /   \\\\    /    \\\\\\n40   60  90    100\\n\\nOutput: 40 20 10 30 100\\n```\\n# Top View -> Lvl Order Traversal\\n```\\n/*\\nclass Node{\\n    int data;\\n    Node left;\\n    Node right;\\n    Node(int data){\\n        this.data = data;\\n        left=null;\\n        right=null;\\n    }\\n}\\n*/\\n\\nclass Pair{\\n    int ind;\\n    Node root;\\n    Pair(int _ind, Node _root){\\n        ind = _ind;\\n        root = _root;\\n    }\\n}\\n\\nclass Solution\\n{\\n    //Function to return a list of nodes visible from the top view \\n    //from left to right in Binary Tree.\\n    static ArrayList<Integer> topView(Node root)\\n    {\\n        // add your code\\n        var map = new TreeMap<Integer,Integer>();\\n        var q = new LinkedList<Pair>();\\n        var list = new ArrayList<Integer>();\\n        if(root==null) return list;\\n        q.add(new Pair(0,root));\\n        while(!q.isEmpty()){\\n            Pair pair = q.poll();\\n            int pos = pair.ind;\\n            Node node = pair.root;\\n            if(!map.containsKey(pos)) map.put(pos,node.data);\\n            if(node.left!=null) q.add(new Pair(pos-1,node.left));\\n            if(node.right!=null) q.add(new Pair(pos+1,node.right));\\n            \\n        }\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            list.add(entry.getValue());\\n        } return list;\\n    }\\n}\\n```\\n# Test Case:\\n```\\nInput: 1 3 2\\n\\n       1\\n     /   \\\\\\n    3     2\\n\\nOutput: 3 1 2\\n\\nInput: 10 20 30 40 60\\n\\n         10\\n       /    \\\\\\n      20    30\\n     /  \\\\\\n    40   60\\n\\nOutput: 40 20 60 30\\n```\\n\\n# Bottom View -> Lvl Order Traversal\\n```\\n/*\\nclass Node{\\n    int data;\\n    Node left;\\n    Node right;\\n    Node(int data){\\n        this.data = data;\\n        left=null;\\n        right=null;\\n    }\\n}\\n*/\\nclass Pair{\\n    int ind;\\n    Node root;\\n    Pair(int _ind, Node _root){\\n        ind = _ind;\\n        root = _root;\\n    }\\n}\\n\\nclass Solution\\n{\\n    //Function to return a list of nodes visible from the bottom view \\n    //from left to right in Binary Tree.\\n    static ArrayList<Integer> bottomView(Node root)\\n    {\\n        // add your code\\n        var map = new TreeMap<Integer,Integer>();\\n        var q = new LinkedList<Pair>();\\n        var list = new ArrayList<Integer>();\\n        if(root==null) return list;\\n        q.add(new Pair(0,root));\\n        while(!q.isEmpty()){\\n            Pair pair = q.poll();\\n            int pos = pair.ind;\\n            Node node = pair.root;\\n            if(!map.containsKey(pos)) map.put(pos,node.data);\\n            if(map.containsKey(pos)) map.replace(pos,node.data);\\n            if(node.left!=null) q.add(new Pair(pos-1,node.left));\\n            if(node.right!=null) q.add(new Pair(pos+1,node.right));\\n            \\n        }\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            list.add(entry.getValue());\\n        } return list;\\n    }\\n```\\n\\n<!-- ![image.png](https://assets.leetcode.com/users/images/2fe91f99-1d3b-47be-ba81-241e64c732fc_1675058149.943284.png) -->",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nInput: 1 3 2\\n       1\\n    /    \\\\\\n   3      2\\nOutput: 1 2\\n\\nInput: 10 20 30 40 60\\n     10\\n    /   \\\\\\n  20     30\\n /   \\\\\\n40  60 \\nOutput: 10 30 60\\n\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        var list = new ArrayList<Integer>();\\n        rec(root,list,0);\\n        return list;\\n    }\\n    void rec(TreeNode root,ArrayList<Integer> list, int depth){\\n        if (root == null) return;\\n        if(list.size()==depth) list.add(root.val);\\n        if(root.right!=null) rec(root.right,list,depth+1);\\n        if(root.left!=null) rec(root.left,list,depth+1);\\n    }\\n}\\n```\n```\\nInput: 1 3 2\\n\\n   1\\n /  \\\\\\n3    2\\n\\nOutput: 1 3\\n\\nInput: 4 5 2 null null 3 1 6 7\\n\\n      4\\n    /   \\\\\\n   5     2\\n       /   \\\\\\n      3     1\\n    /  \\\\\\n   6    7\\n\\nOutput: 4 5 3 6\\n```\n```\\n/* A Binary Tree node\\nclass Node\\n{\\n    int data;\\n    Node left, right;\\n\\n    Node(int item)\\n    {\\n        data = item;\\n        left = right = null;\\n    }\\n}*/\\nclass Tree\\n{\\n    //Function to return list containing elements of left view of binary tree.\\n    ArrayList<Integer> leftView(Node root)\\n    {\\n      // Your code here\\n      var list = new ArrayList<Integer>();\\n      rec(root,list,0);\\n      return list;\\n    }\\n    void rec(Node root, ArrayList<Integer> list, int depth){\\n        if(root==null) return;\\n        if(list.size()==depth) list.add(root.data);\\n        if(root.left!=null) rec(root.left,list,depth+1);\\n        if(root.right!=null) rec(root.right,list,depth+1);\\n    }\\n}\\n```\n```\\nInput: 1 2 3\\n\\n      1\\n   /    \\\\\\n  2      3\\n\\nOutput: 2 1 3\\n\\nInput: 10 20 30 40 60 90 100\\n\\n       10\\n    /      \\\\\\n  20        30\\n /   \\\\    /    \\\\\\n40   60  90    100\\n\\nOutput: 40 20 10 30 100\\n```\n```\\n/*\\nclass Node{\\n    int data;\\n    Node left;\\n    Node right;\\n    Node(int data){\\n        this.data = data;\\n        left=null;\\n        right=null;\\n    }\\n}\\n*/\\n\\nclass Pair{\\n    int ind;\\n    Node root;\\n    Pair(int _ind, Node _root){\\n        ind = _ind;\\n        root = _root;\\n    }\\n}\\n\\nclass Solution\\n{\\n    //Function to return a list of nodes visible from the top view \\n    //from left to right in Binary Tree.\\n    static ArrayList<Integer> topView(Node root)\\n    {\\n        // add your code\\n        var map = new TreeMap<Integer,Integer>();\\n        var q = new LinkedList<Pair>();\\n        var list = new ArrayList<Integer>();\\n        if(root==null) return list;\\n        q.add(new Pair(0,root));\\n        while(!q.isEmpty()){\\n            Pair pair = q.poll();\\n            int pos = pair.ind;\\n            Node node = pair.root;\\n            if(!map.containsKey(pos)) map.put(pos,node.data);\\n            if(node.left!=null) q.add(new Pair(pos-1,node.left));\\n            if(node.right!=null) q.add(new Pair(pos+1,node.right));\\n            \\n        }\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            list.add(entry.getValue());\\n        } return list;\\n    }\\n}\\n```\n```\\nInput: 1 3 2\\n\\n       1\\n     /   \\\\\\n    3     2\\n\\nOutput: 3 1 2\\n\\nInput: 10 20 30 40 60\\n\\n         10\\n       /    \\\\\\n      20    30\\n     /  \\\\\\n    40   60\\n\\nOutput: 40 20 60 30\\n```\n```\\n/*\\nclass Node{\\n    int data;\\n    Node left;\\n    Node right;\\n    Node(int data){\\n        this.data = data;\\n        left=null;\\n        right=null;\\n    }\\n}\\n*/\\nclass Pair{\\n    int ind;\\n    Node root;\\n    Pair(int _ind, Node _root){\\n        ind = _ind;\\n        root = _root;\\n    }\\n}\\n\\nclass Solution\\n{\\n    //Function to return a list of nodes visible from the bottom view \\n    //from left to right in Binary Tree.\\n    static ArrayList<Integer> bottomView(Node root)\\n    {\\n        // add your code\\n        var map = new TreeMap<Integer,Integer>();\\n        var q = new LinkedList<Pair>();\\n        var list = new ArrayList<Integer>();\\n        if(root==null) return list;\\n        q.add(new Pair(0,root));\\n        while(!q.isEmpty()){\\n            Pair pair = q.poll();\\n            int pos = pair.ind;\\n            Node node = pair.root;\\n            if(!map.containsKey(pos)) map.put(pos,node.data);\\n            if(map.containsKey(pos)) map.replace(pos,node.data);\\n            if(node.left!=null) q.add(new Pair(pos-1,node.left));\\n            if(node.right!=null) q.add(new Pair(pos+1,node.right));\\n            \\n        }\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            list.add(entry.getValue());\\n        } return list;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051930,
                "title": "python-simple-dfs-explained",
                "content": "Like in many other problems about binary trees, we need to somehow traverse our tree, using dfs (inorder, preorder or postorder) or bfs. There are different solutions here, I use almost **inorder** traversal, with just one small change: instead of going `Left -> Node -> Right`, we will go `Right -> Node -> Left`. In this way we first visit nodes on the right side of our tree. Algorithm will look like this:\\n\\n1. Create `ans` dictionary, which for each level `H` will keep the rightest node.\\n2. Traverse tree: first visit right children and if we do not have this `H` in `ans` yet, we put it there, then visit left children. Note again that with this order of traversal we always will put the rightest node for each level and next time we visit this level we will do nothing.\\n3. Finally, create list from our dictionary.\\n\\n**Complexity**: time complexity is `O(n)` for classical dfs, space is `O(h)`, again classical complexity for dfs as well as this amount of space we need to keep in our answer.\\n\\n```\\nclass Solution:\\n    def rightSideView(self, root):\\n        ans = {}\\n        def dfs(node, H):\\n            if not node: return \\n            \\n            dfs(node.right, H + 1)\\n            if H not in ans: ans[H] = node.val\\n            dfs(node.left, H + 1)\\n            \\n        dfs(root, 0)\\n        return [ans[i] for i in range(len(ans))]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rightSideView(self, root):\\n        ans = {}\\n        def dfs(node, H):\\n            if not node: return \\n            \\n            dfs(node.right, H + 1)\\n            if H not in ans: ans[H] = node.val\\n            dfs(node.left, H + 1)\\n            \\n        dfs(root, 0)\\n        return [ans[i] for i in range(len(ans))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052166,
                "title": "c-bfs-o-n-0ms-beats-100-easy-to-understand",
                "content": "**EXPLANATION (Easy)**\\n- Traverse the whole tree in **level order** fashion using **BFS** along with storing the **last processed node** (here it is stored in **```curr```**).\\n- Keep a **tag** ( here **```nullptr```**) at the **end of each level** to know that a particular level has *ended*.\\n- Whenever a level ends store the **last processed node value** to the **ans** vector.\\n- Return **ans**.\\n\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        vector<int>ans;\\n        if(root==nullptr)\\n            return ans;\\n        \\n        queue<TreeNode*>q;\\n        \\n        q.push(root); // Initially push the root node\\n        q.push(nullptr); // Then push nullptr, as level=0 contains only the root node\\n        \\n        TreeNode* curr;\\n        \\n        while(!q.empty()){\\n            if(q.front()!=nullptr){ // if the end of current level is not reached\\n                \\n                curr=q.front(); // keep the current node\\n                \\n                // push the left and right child of curr node into the queue if exists\\n                if(curr->left) q.push(curr->left);              \\n                if(curr->right) q.push(curr->right);\\n                \\n                q.pop(); //remove curr node from queue\\n            }\\n            else{ // nullptr signifies the end of the current level, so need to add the last element of this level to ans\\n                \\n                // last element of the level = last deleted element of queue from front\\n                ans.push_back(curr->val); // curr contains the last deleted element of queue from front\\n                \\n                q.pop(); // remove the nullptr, as this level has been processed \\n                \\n                //if the queue is not empty then again push nullptr to keep a tag at the end of the next level\\n                if(!q.empty()) q.push(nullptr);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**TIME COMPLEXITY**\\n**O(n)** [ *Since, each node is traversed exactly once* ]\\n\\n**SPACE COMPLEXITY**\\n**O(w)** [ *\\'w\\' is the maximum width of the tree* ]",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```curr```\n```nullptr```\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        vector<int>ans;\\n        if(root==nullptr)\\n            return ans;\\n        \\n        queue<TreeNode*>q;\\n        \\n        q.push(root); // Initially push the root node\\n        q.push(nullptr); // Then push nullptr, as level=0 contains only the root node\\n        \\n        TreeNode* curr;\\n        \\n        while(!q.empty()){\\n            if(q.front()!=nullptr){ // if the end of current level is not reached\\n                \\n                curr=q.front(); // keep the current node\\n                \\n                // push the left and right child of curr node into the queue if exists\\n                if(curr->left) q.push(curr->left);              \\n                if(curr->right) q.push(curr->right);\\n                \\n                q.pop(); //remove curr node from queue\\n            }\\n            else{ // nullptr signifies the end of the current level, so need to add the last element of this level to ans\\n                \\n                // last element of the level = last deleted element of queue from front\\n                ans.push_back(curr->val); // curr contains the last deleted element of queue from front\\n                \\n                q.pop(); // remove the nullptr, as this level has been processed \\n                \\n                //if the queue is not empty then again push nullptr to keep a tag at the end of the next level\\n                if(!q.empty()) q.push(nullptr);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56230,
                "title": "share-my-java-iterative-solution-based-on-level-order-traversal",
                "content": "    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> ret = new ArrayList<Integer>();\\n            if(root == null) return ret;\\n            Queue<TreeNode> q = new LinkedList<TreeNode>();\\n            q.offer(root);\\n            while(!q.isEmpty()){\\n                int cnt = q.size();\\n                for(int i = 0;i < cnt;i++){\\n                    TreeNode cur = q.poll();\\n                    if(i == cnt-1){\\n                        ret.add(cur.val);\\n                    }\\n                    if(cur.left != null){\\n                        q.offer(cur.left);\\n                    } \\n                    if(cur.right != null){\\n                        q.offer(cur.right);\\n                    } \\n                }\\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> ret = new ArrayList<Integer>();\\n            if(root == null) return ret;\\n            Queue<TreeNode> q = new LinkedList<TreeNode>();\\n            q.offer(root);\\n            while(!q.isEmpty()){\\n                int cnt = q.size();\\n                for(int i = 0;i < cnt;i++){\\n                    TreeNode cur = q.poll();\\n                    if(i == cnt-1){\\n                        ret.add(cur.val);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 56142,
                "title": "9ms-c-bfs-o-n-time-concise-with-explanation",
                "content": "**9ms C++ iterative, concise code with explanation**\\n\\nUsing a queue **mQ** to perform level order traversal. In the beginning of a level traversal, the last element is pushed into result array **ret**. The core idea is similar with [Binary Tree Level Order Traversal][1]\\n\\nO(n) time, O(logn) space\\n\\n    class Solution {\\n    public:\\n        vector<int> rightSideView(TreeNode *root) {\\n            queue<TreeNode*>mQ;\\n            vector<int> ret;\\n            if(!root)return ret;\\n            mQ.push(root);\\n            while(!mQ.empty()){\\n                ret.push_back(mQ.back()->val);\\n                for(int i=mQ.size();i>0;i--){\\n                    TreeNode *tn=mQ.front();\\n                    mQ.pop();\\n                    if(tn->left)mQ.push(tn->left);\\n                    if(tn->right)mQ.push(tn->right);\\n                }\\n            }\\n            return ret;\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/binary-tree-level-order-traversal/",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> rightSideView(TreeNode *root) {\\n            queue<TreeNode*>mQ;\\n            vector<int> ret;\\n            if(!root)return ret;\\n            mQ.push(root);\\n            while(!mQ.empty()){\\n                ret.push_back(mQ.back()->val);\\n                for(int i=mQ.size();i>0;i--){\\n                    TreeNode *tn=mQ.front();\\n                    mQ.pop();\\n                    if(tn->left)mQ.push(tn->left);\\n                    if(tn->right)mQ.push(tn->right);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2269412,
                "title": "c-beats-96-recursive-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Solution  : Reverse PreOrder Traversal (Recursive)**\\n**Time complexity: O(N)**\\n**Space complexity: O(Height)**\\n\\n```\\n//! Using Reverse PreOrder Traversal (Recursive)\\nclass Solution {\\npublic:\\n    void RightView(TreeNode* root, int level, vector<int>&ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        if(level == ans.size())\\n            ans.push_back(root->val);\\n        \\n        RightView(root->right, level+1, ans);\\n        RightView(root->left, level+1, ans);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        RightView(root, 0, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//! Using Reverse PreOrder Traversal (Recursive)\\nclass Solution {\\npublic:\\n    void RightView(TreeNode* root, int level, vector<int>&ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        if(level == ans.size())\\n            ans.push_back(root->val);\\n        \\n        RightView(root->right, level+1, ans);\\n        RightView(root->left, level+1, ans);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        RightView(root, 0, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56062,
                "title": "java-solution-using-divide-and-conquer",
                "content": "    public List<Integer> rightSideView(TreeNode root) {\\n        if(root==null)\\n            return new ArrayList<Integer>();\\n        List<Integer> left = rightSideView(root.left);\\n        List<Integer> right = rightSideView(root.right);\\n        List<Integer> re = new ArrayList<Integer>();\\n        re.add(root.val);\\n        for(int i=0;i<Math.max(left.size(), right.size());i++){\\n            if(i>=right.size())\\n                re.add(left.get(i));\\n            else\\n                re.add(right.get(i));\\n        }\\n        return re;\\n    }",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "    public List<Integer> rightSideView(TreeNode root) {\\n        if(root==null)\\n            return new ArrayList<Integer>();\\n        List<Integer> left = rightSideView(root.left);\\n        List<Integer> right = rightSideView(root.right);\\n        List<Integer> re = new ArrayList<Integer>();\\n        re.add(root.val);\\n        for(int i=0;i<Math.max(left.size(), right.size());i++){\\n            if(i>=right.size())\\n                re.add(left.get(i));\\n            else\\n                re.add(right.get(i));\\n        }\\n        return re;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56229,
                "title": "python-solution",
                "content": "    # Definition for a binary tree node.\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution(object):\\n        def rightSideView(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: List[int]\\n            \"\"\"\\n            if root==None:\\n                return []\\n            ans=[root.val]\\n            left=ans+self.rightSideView(root.left)\\n            right=ans+self.rightSideView(root.right)\\n            if len(right)>=len(left):\\n                return right\\n            return right+left[len(right):]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # Definition for a binary tree node.\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution(object):\\n        def rightSideView(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: List[int]\\n            \"\"\"\\n            if root==None:\\n                return []\\n            ans=[root.val]\\n            left=ans+self.rightSideView(root.left)\\n            right=ans+self.rightSideView(root.right)\\n            if len(right)>=len(left):\\n                return right\\n            return right+left[len(right):]",
                "codeTag": "Java"
            },
            {
                "id": 2265940,
                "title": "beats-100-two-simple-solutions-recursive-queue-explanation",
                "content": "Our goal is to find the rightmost node of each layer, I use two ways to solve this problem.\\nThe first is Recursive, which is faster but relatively more difficult to understand.\\nWe always iterate the right node of the tree, if the size of the list is equal to the height of the node, we add the val. (This layer is over~)\\nIf we put the right node\\'s val into list, the size of list will increase, so when we iterate the left node in this layer, depth will not be equal to the size of the list!\\n\\n**Recursive**\\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        helper(root, list, 0);\\n        return list;\\n    }\\n    \\n    private void helper(TreeNode node, List<Integer> list, int depth) {\\n        if (node != null) {\\n            if (depth == list.size())\\n                list.add(node.val);\\n            \\n            helper(node.right, list, depth + 1);\\n            helper(node.left, list, depth + 1);\\n        }\\n    }\\n}\\n```\\nThe second way use queue. We need to find the rightmost node of each layer, so each time we can iterate current layer\\'s nodes(during the iteration, add the next layer\\'s nodes), when we meet the last node in the layer, we add it into list.\\n**Queue**\\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        \\n        if (root == null)\\n            return list;\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n    \\n        while (!queue.isEmpty()) {\\n            int size = queue.size(); // store the number of nodes of current layer\\n            TreeNode node = null;\\n            while (size > 0) {\\n                node = queue.poll();\\n                if (node.left != null) // add next layer\\'s node\\n                    queue.offer(node.left);\\n                if (node.right != null)\\n                    queue.offer(node.right);\\n                size--;\\n            }\\n            list.add(node.val); // add the val of last node\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\nPlease vote if it helps\\uD83D\\uDE06",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        helper(root, list, 0);\\n        return list;\\n    }\\n    \\n    private void helper(TreeNode node, List<Integer> list, int depth) {\\n        if (node != null) {\\n            if (depth == list.size())\\n                list.add(node.val);\\n            \\n            helper(node.right, list, depth + 1);\\n            helper(node.left, list, depth + 1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        \\n        if (root == null)\\n            return list;\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n    \\n        while (!queue.isEmpty()) {\\n            int size = queue.size(); // store the number of nodes of current layer\\n            TreeNode node = null;\\n            while (size > 0) {\\n                node = queue.poll();\\n                if (node.left != null) // add next layer\\'s node\\n                    queue.offer(node.left);\\n                if (node.right != null)\\n                    queue.offer(node.right);\\n                size--;\\n            }\\n            list.add(node.val); // add the val of last node\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407352,
                "title": "easy-c-bfs-solution",
                "content": "**Do upvote if found useful and encourage me to document more!**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> v;\\n        if(root==NULL)\\n            return v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int count=q.size();\\n            for(int i=0;i<count;i++){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(i==count-1)\\n                    v.push_back(curr->val);\\n                if(curr->left!=NULL)\\n                    q.push(curr->left);\\n                if(curr->right!=NULL)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> v;\\n        if(root==NULL)\\n            return v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int count=q.size();\\n            for(int i=0;i<count;i++){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(i==count-1)\\n                    v.push_back(curr->val);\\n                if(curr->left!=NULL)\\n                    q.push(curr->left);\\n                if(curr->right!=NULL)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56292,
                "title": "recursive-solution",
                "content": "    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            \\n            if(root == null) return res;\\n            \\n            visitLevel(root, 1, res);\\n            return res;\\n        }\\n        \\n        public void visitLevel(TreeNode root, int level, List<Integer> res){\\n            \\n            if(root == null) return;\\n            if(level > res.size()){\\n                res.add(root.val);    \\n            }\\n            \\n            visitLevel(root.right, level+1, res);\\n            visitLevel(root.left, level+1, res);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            \\n            if(root == null) return res;\\n            \\n            visitLevel(root, 1, res);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56210,
                "title": "python-straightforward-bfs",
                "content": "    def rightSideView(self, root):\\n        res, nxtL= [], [root] if root else []\\n        while nxtL:\\n            res.append(nxtL[-1].val) # right most val as to output\\n            curL, nxtL = nxtL, []\\n            for i in curL: # build the next level\\n                if i.left: nxtL.append(i.left)\\n                if i.right: nxtL.append(i.right)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def rightSideView(self, root):\\n        res, nxtL= [], [root] if root else []\\n        while nxtL:\\n            res.append(nxtL[-1].val) # right most val as to output\\n            curL, nxtL = nxtL, []\\n            for i in curL: # build the next level\\n                if i.left: nxtL.append(i.left)\\n                if i.right: nxtL.append(i.right)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1053080,
                "title": "c-super-simple-and-easy-recursive-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int height) {\\n        if (!root) return;\\n        if (height == res.size())\\n            res.push_back(root->val);\\n        dfs(root->right, height + 1);\\n        dfs(root->left, height + 1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        dfs(root, 0);\\n        return res;\\n    }\\n\\nprivate:\\n    vector<int> res;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int height) {\\n        if (!root) return;\\n        if (height == res.size())\\n            res.push_back(root->val);\\n        dfs(root->right, height + 1);\\n        dfs(root->left, height + 1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        dfs(root, 0);\\n        return res;\\n    }\\n\\nprivate:\\n    vector<int> res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805562,
                "title": "simple-c-recursive-approach-comments-included",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\t// h is the current level of the node, maxh is the maximum level reached at any given point of time.\\n    void traverse(TreeNode* root, int h, int& maxh, vector<int>& ans){\\n        if(!root) return ;\\n\\t\\t// if level is greater than maximum level then it will be seen at the right side. Try to visualize it.\\n        if(h > maxh){\\n            ans.push_back(root->val);\\n\\t\\t\\tmaxh = h;\\n        }\\n\\t\\t// first visiting the right side for right view.\\n        traverse(root->right, h+1, maxh, ans);\\n        \\n        traverse(root->left, h+1, maxh, ans);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        if(!root) return {};\\n        vector<int> ans;\\n        int maxh = 0;\\n        ans.push_back(root->val);\\n        traverse(root, 0, maxh, ans);\\n        return ans;\\n    }\\n};\\n```\\nIf you have any query, then do ask in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\t// h is the current level of the node, maxh is the maximum level reached at any given point of time.\\n    void traverse(TreeNode* root, int h, int& maxh, vector<int>& ans){\\n        if(!root) return ;\\n\\t\\t// if level is greater than maximum level then it will be seen at the right side. Try to visualize it.\\n        if(h > maxh){\\n            ans.push_back(root->val);\\n\\t\\t\\tmaxh = h;\\n        }\\n\\t\\t// first visiting the right side for right view.\\n        traverse(root->right, h+1, maxh, ans);\\n        \\n        traverse(root->left, h+1, maxh, ans);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        if(!root) return {};\\n        vector<int> ans;\\n        int maxh = 0;\\n        ans.push_back(root->val);\\n        traverse(root, 0, maxh, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382850,
                "title": "simple-javascript-bfs-solution-using-queue",
                "content": "BFS by layer, and only add the last one of each layer into the result array\\n\\n```\\nvar rightSideView = function(root) {\\n    const result = [];\\n    const queue = [];\\n    \\n    if (root === null) return result;\\n    \\n    queue.push(root);\\n    while(queue.length !== 0) {\\n        let size = queue.length;\\n        for (let i = 0; i < size; i++) {\\n            let n = queue.shift();\\n            if (i === size - 1) result.push(n.val);\\n            if (n.left !== null) queue.push(n.left);\\n            if (n.right !== null) queue.push(n.right);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar rightSideView = function(root) {\\n    const result = [];\\n    const queue = [];\\n    \\n    if (root === null) return result;\\n    \\n    queue.push(root);\\n    while(queue.length !== 0) {\\n        let size = queue.length;\\n        for (let i = 0; i < size; i++) {\\n            let n = queue.shift();\\n            if (i === size - 1) result.push(n.val);\\n            if (n.left !== null) queue.push(n.left);\\n            if (n.right !== null) queue.push(n.right);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2266347,
                "title": "c-using-both-level-order-and-faster-recursive-approach",
                "content": "**APPROACH - 1**\\n\\n* We know that in level order we visit the left most element int he end so we can simply push that in the `ans`.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        if(root==NULL)return ans;\\n        \\n\\t\\tqueue<TreeNode*>q;\\n        q.push(root);\\n        \\n\\t\\t// Level order transversal\\n\\t\\twhile(!q.empty()){\\n            int s=q.size();\\n            int dat=0;\\n\\t\\t\\t\\n            while(s){\\n                TreeNode*temp=q.front();\\n                q.pop();\\n                dat=temp->val;\\n                if(temp->left!=NULL)q.push(temp->left);\\n                if(temp->right!=NULL)q.push(temp->right);\\n                s--;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Simply push ush the last value\\n            ans.push_back(dat);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---\\n**APPROACH - 2 (MUCH FASTER AND MORE MEMORY EFFICIENT)**\\n\\n* We can also transverse DFS but with right node first along with an `ans vector`.\\n* Which represent the last visited value on the respective level.\\n* We will recursively update the last value on the particular level as we travel.\\n```\\nclass Solution {\\npublic:\\n\\n\\t// Recursive function\\n    void helper(TreeNode* root, vector<int> &ans, int i){\\n        if(root == NULL) return;\\n        \\n        if(i == ans.size())\\n            ans.push_back(root->val);\\n        \\n\\t\\t// Right first DFS\\n        helper(root->right, ans, i+1);\\n        helper(root->left, ans, i+1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        if(root==NULL)return ans;\\n        \\n\\t\\tqueue<TreeNode*>q;\\n        q.push(root);\\n        \\n\\t\\t// Level order transversal\\n\\t\\twhile(!q.empty()){\\n            int s=q.size();\\n            int dat=0;\\n\\t\\t\\t\\n            while(s){\\n                TreeNode*temp=q.front();\\n                q.pop();\\n                dat=temp->val;\\n                if(temp->left!=NULL)q.push(temp->left);\\n                if(temp->right!=NULL)q.push(temp->right);\\n                s--;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Simply push ush the last value\\n            ans.push_back(dat);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n\\t// Recursive function\\n    void helper(TreeNode* root, vector<int> &ans, int i){\\n        if(root == NULL) return;\\n        \\n        if(i == ans.size())\\n            ans.push_back(root->val);\\n        \\n\\t\\t// Right first DFS\\n        helper(root->right, ans, i+1);\\n        helper(root->left, ans, i+1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265539,
                "title": "simple-solution-both-iterative-and-recursive-solutions",
                "content": "**Upvote** if you like efficient solution code!\\n\\n**Join our discord** to meet other people preparing for interviews!\\n**https://discord.gg/Aj2uT5rP**\\n\\n**Iterative Level-Order Traversal**\\nKey idea: Go through level by level through the tree. Append the last node in each level to the result.\\n\\n```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        q = deque([root])\\n        ans = []\\n        while q:\\n            length = len(q)\\n            ans.append(q[-1].val)\\n            for _ in range(length):\\n                node = q.popleft()\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n        return ans\\n```\\n**Time Complexity**: O(n) - go through each node in the tree\\n**Space Complexity**: O(max_level) - max number of nodes in a level of the tree. Worst case, all nodes are in one level so O(n). \\n\\n\\n**Recursive Modified Pre-order Traversal**\\nKey idea: Go to the rightmost node first, in case the rightmost path doesn\\'t reach the max height, recurse on the left subtree. Since we are visiting the rightmost nodes first, if this is the first time we reach a certain depth, append it to the result.\\n```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        \\n        def dfs(node, depth):\\n            if not node:\\n                return\\n            if depth == len(ans):\\n                ans.append(node.val)\\n            dfs(node.right, depth + 1)\\n            dfs(node.left, depth + 1)\\n            \\n        dfs(root, 0)\\n        return ans        \\n```\\n**Time Complexity**: O(n) - go through each node in the tree\\n**Space Complexity**: O(height) - stack space for the recursion is at most the height of the tree. Worst case, the tree is degenerate (i.e. all nodes in a line) so O(n).\\n",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        q = deque([root])\\n        ans = []\\n        while q:\\n            length = len(q)\\n            ans.append(q[-1].val)\\n            for _ in range(length):\\n                node = q.popleft()\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        \\n        def dfs(node, depth):\\n            if not node:\\n                return\\n            if depth == len(ans):\\n                ans.append(node.val)\\n            dfs(node.right, depth + 1)\\n            dfs(node.left, depth + 1)\\n            \\n        dfs(root, 0)\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 56155,
                "title": "o-n-java-solution-i-myself-was-asked-this-question-by-amazon-in-phone-interview",
                "content": "    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> res = new LinkedList<Integer>();\\n        if(root == null) return res;\\n        List<TreeNode> candidates = new LinkedList<TreeNode>();\\n        candidates.add(root);\\n        while(!candidates.isEmpty()) {\\n            List<TreeNode> temp = new LinkedList<TreeNode>();\\n            res.add(candidates.get(0).val);\\n            for(TreeNode curr : candidates) {\\n                if(curr.right != null)\\n                    temp.add(curr.right);\\n                if(curr.left != null)\\n                    temp.add(curr.left);\\n            }\\n            candidates = temp;\\n        }\\n        return res;\\n    }\\n\\n**A variation of this question is to print a tree one level at a time.**",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> res = new LinkedList<Integer>();\\n        if(root == null) return res;\\n        List<TreeNode> candidates = new LinkedList<TreeNode>();\\n        candidates.add(root);\\n        while(!candidates.isEmpty()) {\\n            List<TreeNode> temp = new LinkedList<TreeNode>();\\n            res.add(candidates.get(0).val);\\n            for(TreeNode curr : candidates) {\\n                if(curr.right != null)\\n                    temp.add(curr.right);\\n                if(curr.left != null)\\n                    temp.add(curr.left);\\n            }\\n            candidates = temp;\\n        }\\n        return res;\\n    }\\n\\n**A variation of this question is to print a tree one level at a time.**",
                "codeTag": "Unknown"
            },
            {
                "id": 2267091,
                "title": "binary-tree-right-side-view-java-solution-level-order-traversal",
                "content": "**Approach:**\\nWe will do the level order traversal of the tree and keep on taking the last element of each level.\\n![image](https://assets.leetcode.com/users/images/70c2fefd-674e-46f0-b61b-6e2400c7d3db_1657526215.1977708.jpeg)\\n\\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if(root==null)\\n            return ans;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            int r = q.peek().val;\\n            while(size-- > 0)\\n            {\\n                TreeNode temp = q.poll();\\n                r = temp.val;\\n                if(temp.left != null)\\n                    q.offer(temp.left);\\n                if(temp.right != null)\\n                    q.offer(temp.right);\\n            }\\n            ans.add(r);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if(root==null)\\n            return ans;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            int r = q.peek().val;\\n            while(size-- > 0)\\n            {\\n                TreeNode temp = q.poll();\\n                r = temp.val;\\n                if(temp.left != null)\\n                    q.offer(temp.left);\\n                if(temp.right != null)\\n                    q.offer(temp.right);\\n            }\\n            ans.add(r);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56263,
                "title": "java-solution-using-recursion",
                "content": "    public class Solution {\\n  \\n\\n     public List<Integer> rightSideView(TreeNode root) {\\n    \\t\\tArrayList<Integer> result = new ArrayList<Integer>();\\n    \\t\\tif (root == null) return result;\\n    \\t\\treturn helper(root, result, 0);\\n    \\t}\\n\\n\\tpublic List<Integer> helper(TreeNode root, ArrayList<Integer> result,\\n\\t\\t\\tint height) {\\n\\t\\tif (height == result.size()) {\\n\\t\\t\\tresult.add(root.val);\\n\\t\\t}\\n\\n\\t\\tif (root.right != null) {\\n\\t\\t\\thelper(root.right, result, height + 1);\\n\\n\\t\\t}\\n\\t\\tif (root.left != null) {\\n\\t\\t\\thelper(root.left, result, height + 1);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n\\nComments: height == result.size() is the core part in this recursion, it limits the amount of Node add to the result in each level(height) of the Tree.\\n\\nSome thoughts: If the questions is asking for a left view of the binary tree, just swap the order of \\n\\n    if (root.right != null) {\\n\\t\\t\\thelper(root.right, result, height + 1);\\n\\n\\t\\t}\\nand\\n\\n    if (root.left != null) {\\n        helper(root.left, result, height + 1);\\n    }\\n\\nMoreover, if it's asking of the \"x-ray view\" of the binary tree, for example, display the second element from the right view(given a valid tree). The solution could be adding a counter inside\\n\\n    if (height == result.size()) {\\n\\t\\tresult.add(root.val);\\n    }\\n\\nand keep track of the counter.",
                "solutionTags": [],
                "code": "class Solution {\\n  \\n\\n     public List<Integer> rightSideView(TreeNode root) {\\n    \\t\\tArrayList<Integer> result = new ArrayList<Integer>();\\n    \\t\\tif (root == null) return result;\\n    \\t\\treturn helper(root, result, 0);\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1006996,
                "title": "c-beginner-step-by-step-explanation",
                "content": "### T = O(n) & S = O(n) due to queue \\n### stepwise\\n**1.** declare a vector storing int values\\n**2.** declare a queue storing node type value(TreeNode*)\\n**3.** push root into queue\\n**4.** work until queue is not empty\\n**5.** iterate until last element present in queue and push last element of current queue size\\n**6.** check for left and right node if null or not\\n**7.** Repeat steps from 4 to 6\\n**8.** return the vector.\\n\\n```\\nvector<int> rightSideView(TreeNode* root) {\\n        if(!root) {\\n            return {};\\n        }\\n        vector<int> v; //store values of nodes in the rightmost\\n        queue<TreeNode*> Q; //store node type values in queue \\n        Q.push(root); //push root\\n        while(!Q.empty()) { //repeat steps until queue is not empty\\n            \\n            int size = Q.size();  // current size of queue\\n            for(int i = 0; i < size; i++) {\\n              TreeNode* t = Q.front(); //declare a temp node and put front node of queue\\n                Q.pop(); \\n                if(i==size-1) {   //if node is rightmost \\n                    v.push_back(t->val); //push the value of rightmost node into vector\\n                }\\n                if(t->left) {   //if temp->left != NULL then push into queue\\n                    Q.push(t->left);\\n                }\\n                if(t->right) { //if temp->right != NULL then push into queue\\n                    Q.push(t->right);\\n                }\\n            }  \\n        }\\n        return v; //finally we have all values\\n    }\\n```\\n\\n**Do upvote if liked my solution and explanation :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nvector<int> rightSideView(TreeNode* root) {\\n        if(!root) {\\n            return {};\\n        }\\n        vector<int> v; //store values of nodes in the rightmost\\n        queue<TreeNode*> Q; //store node type values in queue \\n        Q.push(root); //push root\\n        while(!Q.empty()) { //repeat steps until queue is not empty\\n            \\n            int size = Q.size();  // current size of queue\\n            for(int i = 0; i < size; i++) {\\n              TreeNode* t = Q.front(); //declare a temp node and put front node of queue\\n                Q.pop(); \\n                if(i==size-1) {   //if node is rightmost \\n                    v.push_back(t->val); //push the value of rightmost node into vector\\n                }\\n                if(t->left) {   //if temp->left != NULL then push into queue\\n                    Q.push(t->left);\\n                }\\n                if(t->right) { //if temp->right != NULL then push into queue\\n                    Q.push(t->right);\\n                }\\n            }  \\n        }\\n        return v; //finally we have all values\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807741,
                "title": "java-100-faster-step-by-steo-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(log N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/397fadc1-2654-4031-a5a7-9b43568d0105_1690163803.475731.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        // Call the recursive rightView function to populate the right side view of the tree\\n        rightView(root, result, 0);\\n        return result;\\n    }\\n    \\n    // Recursive function to populate the right side view of the tree\\n    public void rightView(TreeNode curr, List<Integer> result, int currDepth){\\n        // If the current node is null, we have reached the end of the tree or a leaf node\\n        if(curr == null){\\n            return;\\n        }\\n        \\n        // If the current depth is equal to the size of the result list, it means we are\\n        // visiting the rightmost node at this depth for the first time\\n        // So, add the current node\\'s value to the result list for the right side view\\n        if(currDepth == result.size()){\\n            result.add(curr.val);\\n        }\\n        \\n        // Recursively call the rightView function on the right and left subtrees, \\n        // incrementing the current depth by 1 for each recursive call\\n        // The right subtree is processed before the left subtree, ensuring that the rightmost \\n        // node at each depth is added to the result list\\n        rightView(curr.right, result, currDepth + 1);\\n        rightView(curr.left, result, currDepth + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        // Call the recursive rightView function to populate the right side view of the tree\\n        rightView(root, result, 0);\\n        return result;\\n    }\\n    \\n    // Recursive function to populate the right side view of the tree\\n    public void rightView(TreeNode curr, List<Integer> result, int currDepth){\\n        // If the current node is null, we have reached the end of the tree or a leaf node\\n        if(curr == null){\\n            return;\\n        }\\n        \\n        // If the current depth is equal to the size of the result list, it means we are\\n        // visiting the rightmost node at this depth for the first time\\n        // So, add the current node\\'s value to the result list for the right side view\\n        if(currDepth == result.size()){\\n            result.add(curr.val);\\n        }\\n        \\n        // Recursively call the rightView function on the right and left subtrees, \\n        // incrementing the current depth by 1 for each recursive call\\n        // The right subtree is processed before the left subtree, ensuring that the rightmost \\n        // node at each depth is added to the result list\\n        rightView(curr.right, result, currDepth + 1);\\n        rightView(curr.left, result, currDepth + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266920,
                "title": "bfs-and-in-order-traversal-fully-explained-with-image-o-n",
                "content": "Upvote if you found it helpful <3\\n\\n# Intuition\\nWe are standing on the right side of the tree, which nodes do we see?\\n\\nWe will see a node for every level, but which node? the right-most node\\n\\n![image](https://assets.leetcode.com/users/images/aca04950-9a6e-4c79-abd7-c906b11e291d_1657523426.5545232.png)\\n\\nThe right most node isn\\'t blocked on it\\'s level, since this is what we\\'ll see from the right side.\\n\\nNow we just need to traverse the tree in the right order.\\n\\nWe will go about it with DFS, we will keep track of the levels and append the **left childs first**, **then the right childs**.\\n\\nThis way, if there is a right child, it will override the left child (block it, so the left isn\\'t seen anymore)\\n\\nWe will hold a dictionary that will save the nodes that we see on every level, and then we will return the values of the dictionary (since we don\\'t care about the node level)\\n\\n# Code\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        \\n        # Queue has (node, level) elements\\n        bfs_queue = deque([(root, 1)])\\n        \\n        # result has the rightmost element in each level\\n        answer_dict = {}\\n        \\n        while bfs_queue:\\n            node, level = bfs_queue.popleft()\\n            answer_dict[level] = node.val\\n            if node.left:\\n                bfs_queue.append((node.left, level + 1))\\n            if node.right:\\n                bfs_queue.append((node.right, level + 1))\\n        \\n        return answer_dict.values()\\n```\\n\\n# Complexity Analysis\\n* Time - O(n). We do a single traversal of the tree\\n* Space - O(n). We have a queue for the BFS\\n\\n\\n# In order traversal\\nWe can achieve the same thing with in-order traversal, because the right-most element on every level is visited last.\\n\\nI add the example for demonstration and learning purposes :)\\n\\nThis time we use an array directly, and the index is the `level-1` value.\\n\\n```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        \\n        answer = []\\n        self.in_order_traversal(root, 1, answer)\\n        return answer\\n    \\n    def in_order_traversal(self, root, level, answer):\\n        if not root: return\\n        \\n        self.in_order_traversal(root.left, level + 1, answer)\\n        \\n        # If it\\'s the first time on this level, let\\'s increase our array to match.\\n        while len(answer) < level:\\n\\t\\t\\t# we don\\'t care about the value we append, it will be over written anyway.\\n            answer.append(0)\\n        \\n        answer[level-1] = root.val\\n        self.in_order_traversal(root.right, level + 1, answer)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        \\n        # Queue has (node, level) elements\\n        bfs_queue = deque([(root, 1)])\\n        \\n        # result has the rightmost element in each level\\n        answer_dict = {}\\n        \\n        while bfs_queue:\\n            node, level = bfs_queue.popleft()\\n            answer_dict[level] = node.val\\n            if node.left:\\n                bfs_queue.append((node.left, level + 1))\\n            if node.right:\\n                bfs_queue.append((node.right, level + 1))\\n        \\n        return answer_dict.values()\\n```\n```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        \\n        answer = []\\n        self.in_order_traversal(root, 1, answer)\\n        return answer\\n    \\n    def in_order_traversal(self, root, level, answer):\\n        if not root: return\\n        \\n        self.in_order_traversal(root.left, level + 1, answer)\\n        \\n        # If it\\'s the first time on this level, let\\'s increase our array to match.\\n        while len(answer) < level:\\n\\t\\t\\t# we don\\'t care about the value we append, it will be over written anyway.\\n            answer.append(0)\\n        \\n        answer[level-1] = root.val\\n        self.in_order_traversal(root.right, level + 1, answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392858,
                "title": "top-view-bottom-view",
                "content": "#### approach 1 : Top View\\n\\nstep1 : handle edge case\\n\\nstep2 : \\n`map`, for tracking horizontal distance\\n`queue`, for tracking level order traversal\\n\\nstep4 : \\ndo normal,\\nlevel order traversal\\n\\nstep5 : \\nalong with level order traversal,\\nwe need to track the horizontal_distance also\\n\\nso, for that we need map\\n\\n\\n<hr> \\n\\n```\\n topView(root)\\n    {\\n        if(!root) return\\n    \\n        let map = new Map()\\n\\n        let queue = []\\n        queue.push([root, 0])             <----------------\\n\\t\\tlet node = 0, horizontal_distance = 0\\n        \\n\\n        while(queue.length > 0){\\n            const temp = queue.shift()\\n\\n            node = temp[0]              <---------\\n            horizontal_distance = temp[1]   <-----------\\n            \\n            \\n            if(!map.has(horizontal_distance))   <-------------\\n                map.set(horizontal_distance, node.val)\\n\\n            \\n            if(node.left != null)\\n                queue.push([node.left, horizontal_distance - 1]) <--------\\n                \\n            if(node.right != null)\\n                queue.push([node.right,horizontal_distance + 1]) <--------\\n        }\\n\\n\\n        let sortedMap = new Map([...map].sort(function(a,b){return a[0] - b[0]}))\\n        return Array.from(sortedMap.values())\\n        // let res = []\\n        // for(let [k,v] of sortedMap){\\n        //     res.push(v)\\n        // }\\n        // return res\\n    }\\n\\n```\\n\\n<hr> <br> <br><br><br> \\n\\n#### Bottom View : \\n\\nhere , we need to update the map,\\nfor the higher level\\'s node( niche wale level)\\n\\n\\n```\\n bottomView(root)\\n    {\\n        if(!root) return\\n    \\n        let map = new Map()\\n\\n        let queue = []\\n        queue.push([root, 0])          \\n\\t\\tlet node = 0, horizontal_distance = 0\\n        \\n\\n        while(queue.length > 0){\\n            const temp = queue.shift()\\n\\n            node = temp[0]              \\n            horizontal_distance = temp[1]  \\n            \\n            \\n            //if(!map.has(horizontal_distance))   <-------------\\n                map.set(horizontal_distance, node.val)\\n\\n            \\n            if(node.left != null)\\n                queue.push([node.left, horizontal_distance - 1])\\n                \\n            if(node.right != null)\\n                queue.push([node.right,horizontal_distance + 1])\\n        }\\n\\n\\n        let sortedMap = new Map([...map].sort(function(a,b){return a[0] - b[0]}))\\n        return Array.from(sortedMap.values())\\n   \\n    }\\n\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n topView(root)\\n    {\\n        if(!root) return\\n    \\n        let map = new Map()\\n\\n        let queue = []\\n        queue.push([root, 0])             <----------------\\n\\t\\tlet node = 0, horizontal_distance = 0\\n        \\n\\n        while(queue.length > 0){\\n            const temp = queue.shift()\\n\\n            node = temp[0]              <---------\\n            horizontal_distance = temp[1]   <-----------\\n            \\n            \\n            if(!map.has(horizontal_distance))   <-------------\\n                map.set(horizontal_distance, node.val)\\n\\n            \\n            if(node.left != null)\\n                queue.push([node.left, horizontal_distance - 1]) <--------\\n                \\n            if(node.right != null)\\n                queue.push([node.right,horizontal_distance + 1]) <--------\\n        }\\n\\n\\n        let sortedMap = new Map([...map].sort(function(a,b){return a[0] - b[0]}))\\n        return Array.from(sortedMap.values())\\n        // let res = []\\n        // for(let [k,v] of sortedMap){\\n        //     res.push(v)\\n        // }\\n        // return res\\n    }\\n\\n```\n```\\n bottomView(root)\\n    {\\n        if(!root) return\\n    \\n        let map = new Map()\\n\\n        let queue = []\\n        queue.push([root, 0])          \\n\\t\\tlet node = 0, horizontal_distance = 0\\n        \\n\\n        while(queue.length > 0){\\n            const temp = queue.shift()\\n\\n            node = temp[0]              \\n            horizontal_distance = temp[1]  \\n            \\n            \\n            //if(!map.has(horizontal_distance))   <-------------\\n                map.set(horizontal_distance, node.val)\\n\\n            \\n            if(node.left != null)\\n                queue.push([node.left, horizontal_distance - 1])\\n                \\n            if(node.right != null)\\n                queue.push([node.right,horizontal_distance + 1])\\n        }\\n\\n\\n        let sortedMap = new Map([...map].sort(function(a,b){return a[0] - b[0]}))\\n        return Array.from(sortedMap.values())\\n   \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300340,
                "title": "dfs-recursive-0-ms-and-bfs-iterative-1-ms-clean-code-in-java",
                "content": "Recursive DFS solution (Accepted 0ms):\\n```\\n/*\\nKeeping track of depth, i.e when going to a child node, increase depth and when coming back, decrease depth.\\nAt each new level (depth), add the rightmost node to the answer list.\\nSince we go to the **right child first** and then the left, when we arrive on a new level **for the first time**, we shall always arrive at the rightmost node.\\n*/\\nclass Solution {\\n    \\n    int depth = 0;\\n    List<Integer> ans = new ArrayList<>();\\n    \\n    public List<Integer> rightSideView(TreeNode root) {\\n        \\n        if(root == null)\\n            return ans;\\n        \\n        depth++;\\n        \\n        if (ans.size() < depth)\\n            ans.add(root.val);\\n        \\n        ans = rightSideView(root.right);\\n        ans = rightSideView(root.left);\\n        \\n        depth--;\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nIterative BFS solution (without changing the signature of question, Accepted 1ms) :\\n```\\nclass Solution {\\n    \\n    public List<Integer> rightSideView(TreeNode root) {\\n        \\n        // create array to store answer\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        // check for edge case\\n        if (root == null)\\n            return ans;\\n        \\n        // make queue to store the nodes breadth first, add root\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        \\n        queue.add(root);\\n        queue.add(null); // a null indicates that the current level has ended, the next level begin from next node in the queue\\n        \\n        while (queue.size() != 0)\\n        {\\n            // get the first element from queue\\n            TreeNode cur = queue.remove();\\n            \\n            // if we get null, move to next level, check if queue is empty else it will result in infinite loop\\n            if (cur == null)\\n            {\\n                if (queue.size() == 0)\\n                    break;\\n                \\n                queue.add(null);\\n            }\\n            \\n            else\\n            {\\n                // the last element of each level (the element before null) will be seen from the right side\\n                if (queue.peek() == null)\\n                    ans.add(cur.val);\\n                \\n                // add the children of current element in queue, as part of the next level\\n                if (cur.left != null)\\n                    queue.add(cur.left);\\n                \\n                if (cur.right != null)\\n                    queue.add(cur.right);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\nKeeping track of depth, i.e when going to a child node, increase depth and when coming back, decrease depth.\\nAt each new level (depth), add the rightmost node to the answer list.\\nSince we go to the **right child first** and then the left, when we arrive on a new level **for the first time**, we shall always arrive at the rightmost node.\\n*/\\nclass Solution {\\n    \\n    int depth = 0;\\n    List<Integer> ans = new ArrayList<>();\\n    \\n    public List<Integer> rightSideView(TreeNode root) {\\n        \\n        if(root == null)\\n            return ans;\\n        \\n        depth++;\\n        \\n        if (ans.size() < depth)\\n            ans.add(root.val);\\n        \\n        ans = rightSideView(root.right);\\n        ans = rightSideView(root.left);\\n        \\n        depth--;\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public List<Integer> rightSideView(TreeNode root) {\\n        \\n        // create array to store answer\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        // check for edge case\\n        if (root == null)\\n            return ans;\\n        \\n        // make queue to store the nodes breadth first, add root\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        \\n        queue.add(root);\\n        queue.add(null); // a null indicates that the current level has ended, the next level begin from next node in the queue\\n        \\n        while (queue.size() != 0)\\n        {\\n            // get the first element from queue\\n            TreeNode cur = queue.remove();\\n            \\n            // if we get null, move to next level, check if queue is empty else it will result in infinite loop\\n            if (cur == null)\\n            {\\n                if (queue.size() == 0)\\n                    break;\\n                \\n                queue.add(null);\\n            }\\n            \\n            else\\n            {\\n                // the last element of each level (the element before null) will be seen from the right side\\n                if (queue.peek() == null)\\n                    ans.add(cur.val);\\n                \\n                // add the children of current element in queue, as part of the next level\\n                if (cur.left != null)\\n                    queue.add(cur.left);\\n                \\n                if (cur.right != null)\\n                    queue.add(cur.right);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114121,
                "title": "my-python-dfs-solution",
                "content": "```\\ndef rightSideView(self, root: TreeNode) -> List[int]:\\n        # Step 1: identify the end of the level\\n        # Step 2: add last node to the result\\n        \\n        # dfs\\n        # 1) prioritize right side\\n        # 2) keep track level of nodes\\n        \\n        res = []\\n        self.dfs(root, 0, res)\\n        return res\\n    \\n    def dfs(self, node, curLevel, res):\\n        if not node: #base case to return\\n            return\\n        \\n        if curLevel >= len(res): #push the value in\\n            res.append(node.val)\\n            \\n        #preorder traversal\\n        if node.right:\\n            self.dfs(node.right, curLevel+1, res)\\n        if node.left:\\n            self.dfs(node.left, curLevel+1, res)\\n# T: O(N)\\n# S: O(N)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef rightSideView(self, root: TreeNode) -> List[int]:\\n        # Step 1: identify the end of the level\\n        # Step 2: add last node to the result\\n        \\n        # dfs\\n        # 1) prioritize right side\\n        # 2) keep track level of nodes\\n        \\n        res = []\\n        self.dfs(root, 0, res)\\n        return res\\n    \\n    def dfs(self, node, curLevel, res):\\n        if not node: #base case to return\\n            return\\n        \\n        if curLevel >= len(res): #push the value in\\n            res.append(node.val)\\n            \\n        #preorder traversal\\n        if node.right:\\n            self.dfs(node.right, curLevel+1, res)\\n        if node.left:\\n            self.dfs(node.left, curLevel+1, res)\\n# T: O(N)\\n# S: O(N)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 383023,
                "title": "simplest-python-recursion",
                "content": "The logic is simple:\\ni. get the right side view of the left and right sub-trees, minus the current node\\nii. if the left sub-tree is taller than the right sub-tree, append the end of the left sub-tree\\niii. otherwise the left sub-tree is totally blocked by the right sub-tree in the right side view.\\n\\n```\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        else:\\n            left = self.rightSideView(root.left)\\n            right = self.rightSideView(root.right)\\n            if len(right) >= len(left):\\n                return [root.val] + right\\n            else:\\n                return [root.val] + right + left[len(right):]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        else:\\n            left = self.rightSideView(root.left)\\n            right = self.rightSideView(root.right)\\n            if len(right) >= len(left):\\n                return [root.val] + right\\n            else:\\n                return [root.val] + right + left[len(right):]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171119,
                "title": "python-bfs-dfs",
                "content": "### 199. Binary Tree Right Side View\\n```\\n> \\u7C7B\\u578B\\uFF1ABFS | DFS\\n> Time Complexity O(N)\\n> Space Complexity O(N)\\n```\\n\\n\\u601D\\u8DEF1\\uFF1ABFS, Level Order\\uFF0C\\u6253\\u5370\\u6700\\u53F3\\u8FB9\\n\\n```python\\nfrom collections import deque\\nclass Solution:\\n    def rightSideView(self, root):\\n        if not root: return []\\n        q, res = deque([root]), []\\n        while q:\\n            res.append(q[-1].val)\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                if cur.left:\\n                    q.append(cur.left)\\n                if cur.right:\\n                    q.append(cur.right)\\n        return res\\n```\\n\\n\\u601D\\u8DEF2\\uFF1A DFS\\uFF0C\\u5148\\u9012\\u5F52\\u53F3\\uFF0C\\u540E\\u9012\\u5F52\\u5DE6\\uFF0C\\u8BB0\\u5F55\\u4E00\\u4E2A\\u6DF1\\u5EA6\\uFF0C\\u5F53\\u8FDB\\u5165\\u65B0\\u7684\\u4E00\\u5C42\\u6DF1\\u5EA6\\uFF0C\\u5C06\\u5F53\\u524Droot.val\\u653E\\u5165return\\u6570\\u7EC4\\u91CC\\u3002\\n\\n```python\\nclass Solution:\\n    def rightSideView(self, root):\\n        self.res = []\\n        self.dfs(root, 0)\\n        return self.res\\n    \\n    def dfs(self, node, depth):\\n        if not node: return\\n        if depth == len(self.res):\\n            self.res.append(node.val)\\n        self.dfs(node.right, depth+1)\\n        self.dfs(node.left, depth+1)\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ABFS | DFS\\n> Time Complexity O(N)\\n> Space Complexity O(N)\\n```\n```python\\nfrom collections import deque\\nclass Solution:\\n    def rightSideView(self, root):\\n        if not root: return []\\n        q, res = deque([root]), []\\n        while q:\\n            res.append(q[-1].val)\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                if cur.left:\\n                    q.append(cur.left)\\n                if cur.right:\\n                    q.append(cur.right)\\n        return res\\n```\n```python\\nclass Solution:\\n    def rightSideView(self, root):\\n        self.res = []\\n        self.dfs(root, 0)\\n        return self.res\\n    \\n    def dfs(self, node, depth):\\n        if not node: return\\n        if depth == len(self.res):\\n            self.res.append(node.val)\\n        self.dfs(node.right, depth+1)\\n        self.dfs(node.left, depth+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265611,
                "title": "python3-dfs-recursion-10-lines-t-m-98-70",
                "content": "```\\nclass Solution:\\n                        # The plan here is to dfs the tree, right-first\\n                        # (opposite of  the usual left-first method), and\\n                        # keeping track of the tree levels as we proceed. The \\n                        # first node we visit on each level is the right-side view \\n                        # node. We know it\\'s the first because the level will be\\n                        # one greater than the length of the current answer list.\\n\\n    def rightSideView(self, root: TreeNode) -> list[int]:\\n        ans =[]\\n        \\n        def dfs(node =root,level=1):\\n            if not node: return\\n            \\n            if len(ans) < level: \\n                ans.append(node.val)\\n            dfs(node.right,level+1)         #  <--- right first\\n            dfs(node.left ,level+1)         #  <--- then left\\n\\n            return \\n\\n        dfs()\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n                        # The plan here is to dfs the tree, right-first\\n                        # (opposite of  the usual left-first method), and\\n                        # keeping track of the tree levels as we proceed. The \\n                        # first node we visit on each level is the right-side view \\n                        # node. We know it\\'s the first because the level will be\\n                        # one greater than the length of the current answer list.\\n\\n    def rightSideView(self, root: TreeNode) -> list[int]:\\n        ans =[]\\n        \\n        def dfs(node =root,level=1):\\n            if not node: return\\n            \\n            if len(ans) < level: \\n                ans.append(node.val)\\n            dfs(node.right,level+1)         #  <--- right first\\n            dfs(node.left ,level+1)         #  <--- then left\\n\\n            return \\n\\n        dfs()\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1299911,
                "title": "simple-c-recursive-solution-0ms-faster-than-100-clean-code-and-easy-to-understand",
                "content": "Approach : We have to store a global variable ``` maxLevel ``` to ensure the maxLevel upto which we have calculated the right side view of the tree and then we recursively check if current level is greater than maxLevel. Then only we will append the new variable in ```ans``` array.\\n\\nPS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments \\uD83D\\uDE42. Thanks for reading.\\n\\n    vector<int>ans ;\\n    \\n    int maxLevel = 0 ;\\n    \\n    void rightView(TreeNode* root,int level){\\n        \\n        if(root == NULL)\\n            return ;\\n        \\n        if(level>maxLevel)\\n        {\\n            ans.push_back(root->val);\\n            maxLevel += 1 ;\\n        }\\n        \\n        if(root->right)\\n            rightView(root->right,level+1);\\n        \\n        if(root->left)\\n            rightView(root->left,level+1);\\n        \\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        rightView(root,1);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "``` maxLevel ```\n```ans```",
                "codeTag": "Unknown"
            },
            {
                "id": 56167,
                "title": "dfs-solution-better-than-90-solutions",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            if (root == null){\\n                return res;\\n            }\\n            dfs (root, res, 0);\\n            return res;\\n        }\\n        \\n        public void dfs (TreeNode root, List<Integer> res, int level){\\n            if (root == null){\\n                return;\\n            }\\n            if (res.size() == level){\\n                res.add (root.val);\\n            }\\n            if (root.right != null){\\n                dfs (root.right, res, level + 1);\\n            }\\n            if (root.left != null){\\n                dfs (root.left, res, level + 1);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            if (root == null){\\n                return res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 56183,
                "title": "simple-java-solution-with-bfs",
                "content": "    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if(root==null) return result;\\n            Queue<TreeNode> q = new LinkedList<TreeNode>();\\n            q.add(root);\\n            while(q.size()>0){\\n                int size = q.size();\\n                for(int i=0;i<size;i++){\\n                    TreeNode node= q.poll();\\n                    if(i==size-1)\\n                        result.add(node.val);\\n                    if(node.left!=null) q.add(node.left);\\n                    if(node.right!=null) q.add(node.right);\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if(root==null) return result;\\n            Queue<TreeNode> q = new LinkedList<TreeNode>();\\n            q.add(root);\\n            while(q.size()>0){\\n                int size = q.size();\\n                for(int i=0;i<size;i++){\\n                    TreeNode node= q.poll();\\n                    if(i==size-1)\\n                        result.add(node.val);\\n                    if(node.left!=null) q.add(node.left);\\n                    if(node.right!=null) q.add(node.right);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1052104,
                "title": "c-4-steps-4ms-level-order-traversal-approach-o-n-time",
                "content": "### T = O(N) & S = O(logN)\\n\\n***Explanation :***\\n\\n1. Use `vector v` to store rightmost nodes.\\n2. Use `Queue  Q` to store level wise values.\\n3. At `every level` we will iterate from `(0 -> current Q.size())`  then store `(Q.size()-1)`**th** value into `vector v`.\\n4. ***Congrats*** you have all your `righmost nodes` values in `vector v`, Simply return vector  **: )**\\n\\n\\n```\\n vector<int> rightSideView(TreeNode* root) {\\n        if(!root) {\\n            return {};\\n        }\\n        vector<int> v; //store values of nodes in the rightmost\\n        queue<TreeNode*> Q; //store node type values in queue \\n        Q.push(root); //push root\\n        while(!Q.empty()) { //repeat steps until queue is not empty\\n            \\n            int size = Q.size();  // current size of queue\\n            for(int i = 0; i < size; i++) {\\n              TreeNode* t = Q.front(); //declare a temp node and put front node of queue\\n                Q.pop(); \\n                if(i==size-1) {   //if node is rightmost \\n                    v.push_back(t->val); //push the value of rightmost node into vector\\n                }\\n                if(t->left) {   //if temp->left != NULL then push into queue\\n                    Q.push(t->left);\\n                }\\n                if(t->right) { //if temp->right != NULL then push into queue\\n                    Q.push(t->right);\\n                }\\n            }  \\n        }\\n        return v; //finally we have all values\\n    }\\n```\\n\\n***If you feel any doubt feel free to comment : )***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n vector<int> rightSideView(TreeNode* root) {\\n        if(!root) {\\n            return {};\\n        }\\n        vector<int> v; //store values of nodes in the rightmost\\n        queue<TreeNode*> Q; //store node type values in queue \\n        Q.push(root); //push root\\n        while(!Q.empty()) { //repeat steps until queue is not empty\\n            \\n            int size = Q.size();  // current size of queue\\n            for(int i = 0; i < size; i++) {\\n              TreeNode* t = Q.front(); //declare a temp node and put front node of queue\\n                Q.pop(); \\n                if(i==size-1) {   //if node is rightmost \\n                    v.push_back(t->val); //push the value of rightmost node into vector\\n                }\\n                if(t->left) {   //if temp->left != NULL then push into queue\\n                    Q.push(t->left);\\n                }\\n                if(t->right) { //if temp->right != NULL then push into queue\\n                    Q.push(t->right);\\n                }\\n            }  \\n        }\\n        return v; //finally we have all values\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1051937,
                "title": "python-c-bfs-explained",
                "content": "Trick here, is that we **always** need to store nodes of the left, because nodes on the right might end, but on the left tree will keep going down, so left\\'s nodes children might become *right side view* nodes.\\nSolution here is to go *down* one level and get right most value\\n\\n## Better example\\n```\\n         5 => [5]\\n        / \\\\\\n       4   6\\n      / \\\\\\n     3   2\\n    /\\n   1\\n\\n         5\\n        / \\\\\\n       4   6 => [5, 6]\\n      / \\\\\\n     3   2\\n    /\\n   1\\n\\n         5\\n        / \\\\\\n       4   6\\n      / \\\\\\n     3   2  => [5, 6, 2]\\n    /\\n   1\\n         5\\n        / \\\\\\n       4   6\\n      / \\\\\\n     3   2\\n    /\\n   1   => [5, 6, 2, 1]\\n ```\\n\\n## Python code:\\n```\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        result = []\\n        stack = [root] if root else []\\n        while stack:\\n            newStack = []\\n            result.append(stack[-1].val)\\n            for n in stack:\\n                if n.left: newStack.append(n.left)\\n                if n.right: newStack.append(n.right)\\n            stack = newStack\\n        return result\\n```\\n\\n## C++ code:\\n```\\nclass Solution {\\n  public:\\n    vector<int> rightSideView(TreeNode* root) {\\n      vector<int> result;\\n      vector<TreeNode*> stack;\\n      if (root) stack.push_back(root);\\n      while (stack.size()) {\\n        result.push_back(stack.back()->val);\\n        vector<TreeNode*> newStack;\\n        for (TreeNode* n : stack) {\\n          if (n->left) newStack.push_back(n->left);\\n          if (n->right) newStack.push_back(n->right);\\n        }\\n        stack = newStack;\\n      }\\n      return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n         5 => [5]\\n        / \\\\\\n       4   6\\n      / \\\\\\n     3   2\\n    /\\n   1\\n\\n         5\\n        / \\\\\\n       4   6 => [5, 6]\\n      / \\\\\\n     3   2\\n    /\\n   1\\n\\n         5\\n        / \\\\\\n       4   6\\n      / \\\\\\n     3   2  => [5, 6, 2]\\n    /\\n   1\\n         5\\n        / \\\\\\n       4   6\\n      / \\\\\\n     3   2\\n    /\\n   1   => [5, 6, 2, 1]\\n ```\n```\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        result = []\\n        stack = [root] if root else []\\n        while stack:\\n            newStack = []\\n            result.append(stack[-1].val)\\n            for n in stack:\\n                if n.left: newStack.append(n.left)\\n                if n.right: newStack.append(n.right)\\n            stack = newStack\\n        return result\\n```\n```\\nclass Solution {\\n  public:\\n    vector<int> rightSideView(TreeNode* root) {\\n      vector<int> result;\\n      vector<TreeNode*> stack;\\n      if (root) stack.push_back(root);\\n      while (stack.size()) {\\n        result.push_back(stack.back()->val);\\n        vector<TreeNode*> newStack;\\n        for (TreeNode* n : stack) {\\n          if (n->left) newStack.push_back(n->left);\\n          if (n->right) newStack.push_back(n->right);\\n        }\\n        stack = newStack;\\n      }\\n      return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220522,
                "title": "199-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- The idea is to perform a level order traversal of the tree and keep track of the last node at each level.\\n- We can use a queue to perform the traversal. We start by adding the root to the queue.\\n- At each level, we keep track of the length of the queue at the beginning of the level. We iterate over this length and pop the first element of the queue. If we are at the last element of the level, we add its value to the result list.\\n- We then add the left and right children of the current node to the queue, if they exist.\\n- Finally, we return the result list containing the right side view of the tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        result = []\\n        queue = collections.deque()\\n        queue.append(root)\\n        while queue:\\n            level_len = len(queue)\\n            for i in range(level_len):\\n                node = queue.popleft()\\n                if i == level_len - 1:\\n                    result.append(node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        result = []\\n        queue = collections.deque()\\n        queue.append(root)\\n        while queue:\\n            level_len = len(queue)\\n            for i in range(level_len):\\n                node = queue.popleft()\\n                if i == level_len - 1:\\n                    result.append(node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180039,
                "title": "elegant-bfs-approach-with-explanation",
                "content": "# Intuition\\nWe need to consider the tree top-down level by level and find the right most nodes for each level.\\n\\n# Approach\\nWe use Breadth-First Search implemented via queue. After traversing each level we find the right most node and collect its value in the result list.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n\\n        rigthElements = []\\n        queue = [root]\\n        while queue:\\n            for _ in range(len(queue)):\\n                node = queue.pop(0)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n\\n            rigthElements.append(node.val)\\n\\n        return rigthElements\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n\\n        rigthElements = []\\n        queue = [root]\\n        while queue:\\n            for _ in range(len(queue)):\\n                node = queue.pop(0)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n\\n            rigthElements.append(node.val)\\n\\n        return rigthElements\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052029,
                "title": "javascript-clean-and-simple-bfs",
                "content": "```javascript\\nvar rightSideView = function(root) {\\n    if(!root) return []\\n    \\n    let queue = [root];\\n    const result = [root.val]\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        for(let node of queue) {\\n            if(node.left) next.push(node.left);\\n            if(node.right) next.push(node.right);\\n        }\\n        if(next.length) result.push(next[next.length-1].val);\\n        queue = next;\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nvar rightSideView = function(root) {\\n    if(!root) return []\\n    \\n    let queue = [root];\\n    const result = [root.val]\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        for(let node of queue) {\\n            if(node.left) next.push(node.left);\\n            if(node.right) next.push(node.right);\\n        }\\n        if(next.length) result.push(next[next.length-1].val);\\n        queue = next;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1051914,
                "title": "python-bfs",
                "content": "We need the rightmost entry of each level. Since we go level-by-level it is BFS.\\nOne thing is, we only want to add the last element of each level. Traverse the nodes from right-to-left and store the depth of each node. Add a node to answer only if its depth is larger than the maximum depth observed so far, i.e. `d > prev_d` below.\\n\\n```python\\nfrom collections import deque\\nclass Solution:\\n    def rightSideView(self, root):\\n        if not root: return []\\n        \\n        ans = []\\n        que = deque([(root, 0)])\\n        prev_d = -1\\n        while que:\\n            node, d = que.popleft()\\n            if node.right: que.append((node.right, d+1))\\n            if node.left: que.append((node.left, d+1))\\n            if d>prev_d: ans.append(node.val)\\n            prev_d = d\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import deque\\nclass Solution:\\n    def rightSideView(self, root):\\n        if not root: return []\\n        \\n        ans = []\\n        que = deque([(root, 0)])\\n        prev_d = -1\\n        while que:\\n            node, d = que.popleft()\\n            if node.right: que.append((node.right, d+1))\\n            if node.left: que.append((node.left, d+1))\\n            if d>prev_d: ans.append(node.val)\\n            prev_d = d\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755360,
                "title": "easy-to-understand-dfs-bfs-faster-simple-python-solutions",
                "content": "The DFS part (recursive)\\n\\n```\\n\\tdef dfs(self, root):\\n\\t\\tout = []\\n\\t\\tdef rec(node, level):\\n\\t\\t\\tif node:\\n\\t\\t\\t\\tif len(out) > level:\\n\\t\\t\\t\\t\\tout[level] = node.val\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tout.append(node.val)\\n\\t\\t\\t\\trec(node.left, level + 1)\\n\\t\\t\\t\\trec(node.right, level + 1)\\n\\n\\t\\trec(root, 0)\\n\\treturn out\\n    \\n```\\n\\n\\nThe BFS part (Iterative)\\n\\n```\\ndef bfs(self, root):\\n        if not root: return []\\n        queue = deque()\\n        queue.append(root)\\n        arr = []\\n        while len(queue):\\n            temp = deque()\\n            tarr = []\\n            while len(queue):\\n                top = queue.popleft()\\n                tarr.append(top.val)\\n                if top.left: temp.append(top.left)\\n                if top.right: temp.append(top.right)\\n            _ = len(tarr) and arr.append(tarr[-1])\\n            queue = temp\\n        return arr\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\tdef dfs(self, root):\\n\\t\\tout = []\\n\\t\\tdef rec(node, level):\\n\\t\\t\\tif node:\\n\\t\\t\\t\\tif len(out) > level:\\n\\t\\t\\t\\t\\tout[level] = node.val\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tout.append(node.val)\\n\\t\\t\\t\\trec(node.left, level + 1)\\n\\t\\t\\t\\trec(node.right, level + 1)\\n\\n\\t\\trec(root, 0)\\n\\treturn out\\n    \\n```\n```\\ndef bfs(self, root):\\n        if not root: return []\\n        queue = deque()\\n        queue.append(root)\\n        arr = []\\n        while len(queue):\\n            temp = deque()\\n            tarr = []\\n            while len(queue):\\n                top = queue.popleft()\\n                tarr.append(top.val)\\n                if top.left: temp.append(top.left)\\n                if top.right: temp.append(top.right)\\n            _ = len(tarr) and arr.append(tarr[-1])\\n            queue = temp\\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 751120,
                "title": "c-bfs-vs-dfs-solutions-compared-and-explained-100-time-80-space",
                "content": "So, pretty straightfoward solution, if you ask me: BFS is the way to go and while I see it doable also with a DFS approach (either storing a lot more data in or building a painfully tricky backtrack system), I will once again fully and passionately embrace the [KISS approach](https://en.wikipedia.org/wiki/KISS_principle) on this one.\\n\\nWe start creating an empty vector `res`; if the tree is empty itself (ie: `!root`, then we just return it).\\n\\nIf not, we know we have at least one layer to grind through our BFS routine: we can initialise a queue container `layer` to store all the nodes at each level as we go and we pre-populate it with `root`.\\n\\nA few more support variable might be worth initialisation here and we are going to dive into our breadth first search until `layer` has at least one surviving element.\\n\\nUnlike other similar problems, here we can start directly from the end result - we push the rightmost value of each `layer` into `res`. And then we move on to populate `layer` for the next iteration, extracting each single note and checking if it has any `left` or `right` children to pass down.\\n\\nOnce there are no more nodess to be scanned, we are finally done and we can return `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        // exiting with an empty tree\\n        if (!root) return res;\\n        // some useful variable initialisation\\n        queue<TreeNode*> layer;\\n        layer.push(root);\\n        int len;\\n        TreeNode *currNode;\\n        // BFS loop\\n        while (layer.size()) {\\n            // first of all, let\\'s update res\\n            res.push_back(layer.back()->val);\\n            // then let\\'s prepare layer for the next run\\n            len = layer.size();\\n            while (len--) {\\n                currNode = layer.front();\\n                layer.pop();\\n                if (currNode->left) layer.push(currNode->left);\\n                if (currNode->right) layer.push(currNode->right);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nCan we do better? Probably, since queues are hardly the top performing solution you might get for this kind of problem.\\n\\nAnd going with a DFS is still cool, nevertheless.\\n\\nTo solve this problem, we then refactored and created `res` at class level and then called the helper function `dfs` to populate it.\\n\\nThis function is taking 2 parameters, `root` (our starting node) and `layer` (defaulted to `0`).\\n\\nAt each call, we will:\\n* just `return` is `root` is `NULL`;\\n* store the value of the current node:\\n\\t* replacing the current value of `res[layer]` when there was already one (`res.size() > layer`), since we proceed with a preorder, so we know that the last element is always the rightmost);\\n\\t* add it to `res` otherwise;\\n* recursively call it `dfs` on the `left` and `right` branches.\\n\\nOnce done, we can just return `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // support variable\\n    vector<int> res;\\n    void dfs(TreeNode *root, int layer = 0) {\\n        // edge case: no node\\n        if (!root) return;\\n        // updating the node on that layer if existing\\n        if (res.size() > layer) res[layer] = root->val;\\n        // adding it to res if there was no previous element\\n        else res.push_back(root->val);\\n        // recursive calls\\n        dfs(root->left, ++layer);\\n        dfs(root->right, layer);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        // exiting with an empty tree\\n        if (!root) return res;\\n        // some useful variable initialisation\\n        queue<TreeNode*> layer;\\n        layer.push(root);\\n        int len;\\n        TreeNode *currNode;\\n        // BFS loop\\n        while (layer.size()) {\\n            // first of all, let\\'s update res\\n            res.push_back(layer.back()->val);\\n            // then let\\'s prepare layer for the next run\\n            len = layer.size();\\n            while (len--) {\\n                currNode = layer.front();\\n                layer.pop();\\n                if (currNode->left) layer.push(currNode->left);\\n                if (currNode->right) layer.push(currNode->right);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // support variable\\n    vector<int> res;\\n    void dfs(TreeNode *root, int layer = 0) {\\n        // edge case: no node\\n        if (!root) return;\\n        // updating the node on that layer if existing\\n        if (res.size() > layer) res[layer] = root->val;\\n        // adding it to res if there was no previous element\\n        else res.push_back(root->val);\\n        // recursive calls\\n        dfs(root->left, ++layer);\\n        dfs(root->right, layer);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56195,
                "title": "concise-java-solution-based-on-bfs",
                "content": "The basic idea is using level by level BFS to traverse the tree: add the right-most node of each level to the  result.\\n\\n**Runtime complexity = O(n)**\\n\\nn is the number of the nodes in the tree: because each node is visited only once, so the runtime complexity is O(n).\\n\\n    public List<Integer> rightSideView(TreeNode root) {\\n    \\tList<Integer>res = new ArrayList<Integer>();\\n    \\tif (root == null) return res;\\n    \\tQueue<TreeNode>queue = new LinkedList<TreeNode>();\\n    \\t\\n    \\tqueue.offer(root);\\t\\t\\n    \\twhile (!queue.isEmpty()) {//Level by level BFS \\n    \\t\\tint count = queue.size();\\n    \\t\\tfor (int i = 0; i < count; i++) {\\n    \\t\\t\\tTreeNode node = queue.poll();\\n    \\t\\t\\tif (i == count - 1) // The right-most node of the current level\\n    \\t\\t\\t\\tres.add(node.val);\\n    \\t\\t\\tif (node.left != null)\\n    \\t\\t\\t\\tqueue.offer(node.left);\\n    \\t\\t\\tif (node.right != null)\\n    \\t\\t\\t\\tqueue.offer(node.right);\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "The basic idea is using level by level BFS to traverse the tree: add the right-most node of each level to the  result.\\n\\n**Runtime complexity = O(n)**\\n\\nn is the number of the nodes in the tree: because each node is visited only once, so the runtime complexity is O(n).\\n\\n    public List<Integer> rightSideView(TreeNode root) {\\n    \\tList<Integer>res = new ArrayList<Integer>();\\n    \\tif (root == null) return res;\\n    \\tQueue<TreeNode>queue = new LinkedList<TreeNode>();\\n    \\t\\n    \\tqueue.offer(root);\\t\\t\\n    \\twhile (!queue.isEmpty()) {//Level by level BFS \\n    \\t\\tint count = queue.size();\\n    \\t\\tfor (int i = 0; i < count; i++) {\\n    \\t\\t\\tTreeNode node = queue.poll();\\n    \\t\\t\\tif (i == count - 1) // The right-most node of the current level\\n    \\t\\t\\t\\tres.add(node.val);\\n    \\t\\t\\tif (node.left != null)\\n    \\t\\t\\t\\tqueue.offer(node.left);\\n    \\t\\t\\tif (node.right != null)\\n    \\t\\t\\t\\tqueue.offer(node.right);\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3708277,
                "title": "clean-python-3-10-solution-without-deque",
                "content": "# Intuition\\nThis Python 3.10 solution leverages the enhanced readability and functionality provided by the latest version of Python\\'s typing system. The approach ditches the deque data structure for a simple list, presenting a cleaner and more elegant solution.\\n\\n# Approach\\nThe strategy of this solution is to employ a classic breadth-first search (BFS) technique, facilitated by a queue data structure. This queue is not the traditional double-ended queue (deque), but a standard list. We iteratively traverse the binary tree level by level, from left to right. During this traversal, the rightmost node at each level is the one visible from the right side. By keeping track of the nodes in our queue, we ensure that the rightmost node is always added to our result list, providing the correct output for the problem.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: up to $$O(n/2)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rightSideView(self, root: TreeNode | None) -> List[int]:\\n        if not root:\\n            return []\\n\\n        ans = []        \\n        q = [root]\\n\\n        while q:            \\n            ans.append(q[-1].val)\\n            q = [child for node in q for child in (node.left, node.right) if child]\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rightSideView(self, root: TreeNode | None) -> List[int]:\\n        if not root:\\n            return []\\n\\n        ans = []        \\n        q = [root]\\n\\n        while q:            \\n            ans.append(q[-1].val)\\n            q = [child for node in q for child in (node.left, node.right) if child]\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775274,
                "title": "visual-explaination-bfs-python-easy",
                "content": "![image](https://assets.leetcode.com/users/images/8fd72686-e397-411c-a9db-6ee4c0aa3c5b_1645001232.0804284.png)\\n\\n\\n* Traverse level wise.\\n* Append `LAST` element of each level to `new list.`\\n*` RETURN list.`\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        a=self.bfs(root)\\n        res=[]\\n        for i in a:\\n            res.append(i[-1])\\n        return res\\n        \\n        #BFS TRAVERSAL    \\n    def bfs(self,root):\\n            res=[]\\n            q=collections.deque()\\n            q.append(root)\\n\\n            while q:\\n                level=[]\\n                len_q=len(q)\\n                for i in range(len_q):\\n                    node=q.popleft()\\n                    if node:\\n                        level.append(node.val)\\n                        q.append(node.left)\\n                        q.append(node.right)\\n                if level:\\n                    res.append(level)\\n            return res\\n       \\n        \\n        \\n        \\n```\\nPlease **UPVOTE  \\u23CF\\uFE0F if it helped you.**",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        a=self.bfs(root)\\n        res=[]\\n        for i in a:\\n            res.append(i[-1])\\n        return res\\n        \\n        #BFS TRAVERSAL    \\n    def bfs(self,root):\\n            res=[]\\n            q=collections.deque()\\n            q.append(root)\\n\\n            while q:\\n                level=[]\\n                len_q=len(q)\\n                for i in range(len_q):\\n                    node=q.popleft()\\n                    if node:\\n                        level.append(node.val)\\n                        q.append(node.left)\\n                        q.append(node.right)\\n                if level:\\n                    res.append(level)\\n            return res\\n       \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510330,
                "title": "javascript-super-easy-bfs-solution",
                "content": "```\\nvar rightSideView = function(root) {\\n    if(!root) return [];\\n    const q = [root];\\n    const result = [];\\n    while(q.length){\\n        const size = q.length;\\n        result.push(q[size-1].val);\\n        for(let i=0; i<size; i++){\\n            const node = q.shift();\\n            node.left && q.push(node.left);\\n            node.right && q.push(node.right);\\n        }\\n    }\\n    return result;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nvar rightSideView = function(root) {\\n    if(!root) return [];\\n    const q = [root];\\n    const result = [];\\n    while(q.length){\\n        const size = q.length;\\n        result.push(q[size-1].val);\\n        for(let i=0; i<size; i++){\\n            const node = q.shift();\\n            node.left && q.push(node.left);\\n            node.right && q.push(node.right);\\n        }\\n    }\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 708928,
                "title": "python-bfs-97-80",
                "content": "```\\nclass Solution:\\n    def rightSideView(self, root):\\n        if not root:\\n            return []\\n        \\n        results, q = [root.val], [root]\\n        \\n        while q:\\n            next_level = []\\n            for node in q:\\n                if node.left:\\n                    next_level.append(node.left)\\n                if node.right:\\n                    next_level.append(node.right)\\n            if next_level:\\n                results.append(next_level[-1].val)\\n            q = next_level\\n        \\n        return results",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rightSideView(self, root):\\n        if not root:\\n            return []\\n        \\n        results, q = [root.val], [root]\\n        \\n        while q:\\n            next_level = []\\n            for node in q:\\n                if node.left:\\n                    next_level.append(node.left)\\n                if node.right:\\n                    next_level.append(node.right)\\n            if next_level:\\n                results.append(next_level[-1].val)\\n            q = next_level\\n        \\n        return results",
                "codeTag": "Java"
            },
            {
                "id": 671688,
                "title": "intuitive-javascript-solution-with-9-lines-of-code-recursive-dfs-memory-o-h-time-o-n",
                "content": "\\n```\\nvar rightSideView = function(root) {\\n    \\n  const result = []\\n\\n  var traverse = function(node,level){\\n      if (!node) return\\n      result[level] = node.val\\n      traverse(node.left,level+1)\\n      traverse(node.right,level+1)\\n  }\\n  \\n  traverse(root,0)\\n  return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar rightSideView = function(root) {\\n    \\n  const result = []\\n\\n  var traverse = function(node,level){\\n      if (!node) return\\n      result[level] = node.val\\n      traverse(node.left,level+1)\\n      traverse(node.right,level+1)\\n  }\\n  \\n  traverse(root,0)\\n  return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413132,
                "title": "bfs-java-2-x-100-solution-with-explanation",
                "content": "BFS is really useful in the tree stucture and 2D DP solution based matrix, It is worth time to master this algorithem!\\nThe basic idea is that BFS will find all the child node in the same level, and we just need to reutrn the last node value for each level.\\n\\n[Othe questions can solve by BFS:]\\n102,103\\tBinary Tree Level Order Traversal \\n116,117 Populating Next Right Pointers in Each Node  \\n429\\tN-ary Tree Level Order Traversal\\n513, 515 Find Bottom Left Tree Value\\n\\nHere is my code:\\n```\\npublic List<Integer> rightSideView(TreeNode root) {\\n        Queue<TreeNode> q= new ArrayDeque<>();\\n        List<Integer> res = new ArrayList<>();\\n        if(root == null) return res;\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i< size; i++){\\n                TreeNode node = q.poll();\\n                if(i == size-1) res.add(node.val);\\n                if(node.left != null) q.offer(node.left);\\n                if(node.right != null) q.offer(node.right);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic List<Integer> rightSideView(TreeNode root) {\\n        Queue<TreeNode> q= new ArrayDeque<>();\\n        List<Integer> res = new ArrayList<>();\\n        if(root == null) return res;\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i< size; i++){\\n                TreeNode node = q.poll();\\n                if(i == size-1) res.add(node.val);\\n                if(node.left != null) q.offer(node.left);\\n                if(node.right != null) q.offer(node.right);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56153,
                "title": "o-n-java-solution-using-level-order-traversal",
                "content": "    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            Queue<TreeNode> queue = new LinkedList<>();\\n            List<Integer> rst = new ArrayList<>();\\n            if(root == null) return rst;\\n            \\n            queue.offer(root);\\n            while(!queue.isEmpty()){\\n                int levelNum = queue.size();\\n                for(int i = 0; i < levelNum; i++){\\n                    if(queue.peek().left != null) queue.offer(queue.peek().left);\\n                    if(queue.peek().right != null) queue.offer(queue.peek().right);\\n                    if(i == levelNum - 1) rst.add(queue.poll().val);\\n                    else queue.poll();\\n                }\\n            }\\n            return rst;\\n        }\\n    }\\n\\nUsing level order traversal and put the last one of each level into the result list.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            Queue<TreeNode> queue = new LinkedList<>();\\n            List<Integer> rst = new ArrayList<>();\\n            if(root == null) return rst;\\n            \\n            queue.offer(root);\\n            while(!queue.isEmpty()){\\n                int levelNum = queue.size();\\n                for(int i = 0; i < levelNum; i++){\\n                    if(queue.peek().left != null) queue.offer(queue.peek().left);\\n                    if(queue.peek().right != null) queue.offer(queue.peek().right);\\n                    if(i == levelNum - 1) rst.add(queue.poll().val);\\n                    else queue.poll();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3648112,
                "title": "c-easy-method",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    void dfs(TreeNode* root, int l){\\n        if(root==NULL)return;\\n        if(m.find(l)==m.end()){\\n            m[l]=root->val;\\n        }\\n        dfs(root->right,l+1);\\n        dfs(root->left,l+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>a;\\n        if(!root)return a;\\n        dfs(root,1);\\n        for(auto i:m)a.push_back(i.second);\\n        return a;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/ce7300c9-d190-497c-aad5-363de8fd7bb8_1686996867.939819.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    void dfs(TreeNode* root, int l){\\n        if(root==NULL)return;\\n        if(m.find(l)==m.end()){\\n            m[l]=root->val;\\n        }\\n        dfs(root->right,l+1);\\n        dfs(root->left,l+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>a;\\n        if(!root)return a;\\n        dfs(root,1);\\n        for(auto i:m)a.push_back(i.second);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265618,
                "title": "java-solution-recursion",
                "content": "```java \\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        ArrayList<Integer> a = new ArrayList<Integer>();\\n        traverse(root,a,0);\\n        return a;\\n    }\\n    \\n    private void traverse(TreeNode root,ArrayList<Integer> a,int c)\\n    {\\n        if(root==null)\\n            return;\\n        if(c==a.size())    //level no. should be equal to index no. in list\\n        a.add(root.val);\\n        traverse(root.right,a,c+1);\\n        traverse(root.left,a,c+1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        ArrayList<Integer> a = new ArrayList<Integer>();\\n        traverse(root,a,0);\\n        return a;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1951025,
                "title": "java-1ms-bfs-explanation-simple-o-n",
                "content": "The trick to solve this problem is to fully understand either **Breadth-First-Search (BFS) or Depth-First-Search (DFS)**.  Without understanding and being very comfortable with these concepts, this problem will be tricky. If you are not familiar with both of these concept, I would recommend reading up on them more. They are extremely useful when it comes to graph traversal.\\n\\nFor this problem, I chose to use **Breadth-First-Search (BFS) to solve it**. This seemed the most natural to me as the question lends itself well to **Level-Order Traversal**.\\n\\nThe idea is simple as long as you have a good understanding of **Breadth-First-Search (BFS)**. We just need to add the last element in each level to the output result List\\\\<Integer\\\\>.\\n\\n*See below the solution for a quick explanation of Breadth-First-Search (BFS) as it relates to this problem.*\\n\\nIt is also worth mentioning, I saw a clever solution to the problem using recursion and **Depth-First-Search (DFS)** which I had not originally thought of. I personally would prefer a **Breadth-First** approach to this problem, but the **Depth-First solution is clever** and I will post a [link to one written in Python](https://leetcode.com/problems/binary-tree-right-side-view/discuss/1950338/DFS-python-solution.).\\n\\n**Runtime Complexity - O(N)**\\n**Memory Complexity - O(N)**\\nwhere N is the number of nodes in the input Tree.\\n```\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        if(root == null) return toReturn;\\n        \\n        Queue<TreeNode> nodeQueue = new LinkedList<>();\\n        nodeQueue.offer(root);\\n        \\n        while(!nodeQueue.isEmpty()) {\\n            int levelSize = nodeQueue.size();\\n            \\n            for(int i = 0; i < levelSize; i++) {\\n                TreeNode currentNode = nodeQueue.poll();\\n                \\n                if(currentNode.left != null) nodeQueue.offer(currentNode.left);\\n                if(currentNode.right != null) nodeQueue.offer(currentNode.right);\\n                \\n                if(i == levelSize - 1) toReturn.add(currentNode.val);\\n            }\\n        }\\n        \\n        return toReturn;\\n    }\\n```\\n\\nThe entire **idea of Breadth-First-Search (BFS)** for those unfamiliar, is to search a **graph** from some starting point in the order of visiting the current nodes closest **neighbors first**. In the **context of a tree**, that is **each level / height of the tree**. Put in another way, **Breadth-First-Search (BFS)** searches \"wide\" (from left to right) first before going deeper.\\n\\nThe true trick to **implementing Breadth-First-Search (BFS)** and being able to distinguish between elements from a single level from elements currently being added for the next level, is to keep track of the **size of the queue before starting the traversal of the current level**.\\n\\nThis is because, prior to the start of a level, the queue will only contain items from the level that is about to be processed. That being said, if we only iterate nodeQueue.size() times, then we can add new deeper nodes to the queue without those nodes being mixed with nodes from the current level.",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        if(root == null) return toReturn;\\n        \\n        Queue<TreeNode> nodeQueue = new LinkedList<>();\\n        nodeQueue.offer(root);\\n        \\n        while(!nodeQueue.isEmpty()) {\\n            int levelSize = nodeQueue.size();\\n            \\n            for(int i = 0; i < levelSize; i++) {\\n                TreeNode currentNode = nodeQueue.poll();\\n                \\n                if(currentNode.left != null) nodeQueue.offer(currentNode.left);\\n                if(currentNode.right != null) nodeQueue.offer(currentNode.right);\\n                \\n                if(i == levelSize - 1) toReturn.add(currentNode.val);\\n            }\\n        }\\n        \\n        return toReturn;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 753031,
                "title": "c-simple-o-n-recursive-solution-using-preorder-traversal",
                "content": "```\\npublic class Solution {\\n    public IList<int> RightSideView(TreeNode root) {\\n        List<int> result = new List<int>();\\n        RightSideDFS(root, 1, result);\\n        return result;\\n    }\\n    \\n    private void RightSideDFS(TreeNode node, int depth, List<int> result) {\\n        if (node == null)\\n            return;\\n        if (result.Count < depth)\\n            result.Add(node.val);\\n        RightSideDFS(node.right, depth+1, result);\\n        RightSideDFS(node.left, depth+1, result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> RightSideView(TreeNode root) {\\n        List<int> result = new List<int>();\\n        RightSideDFS(root, 1, result);\\n        return result;\\n    }\\n    \\n    private void RightSideDFS(TreeNode node, int depth, List<int> result) {\\n        if (node == null)\\n            return;\\n        if (result.Count < depth)\\n            result.Add(node.val);\\n        RightSideDFS(node.right, depth+1, result);\\n        RightSideDFS(node.left, depth+1, result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56159,
                "title": "clear-c-bfs-solution",
                "content": "    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        if(!root)\\n            return res;\\n        queue<TreeNode*> que;\\n        que.push(root);\\n        int count = 1;\\n        while(!que.empty()){\\n            TreeNode *temp = que.front();\\n            que.pop();\\n            if(temp->left)\\n                que.push(temp->left);\\n            if(temp->right)\\n                que.push(temp->right);\\n            count--;\\n            if(count == 0){\\n                count = que.size();\\n                res.push_back(temp->val);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        if(!root)\\n            return res;\\n        queue<TreeNode*> que;\\n        que.push(root);\\n        int count = 1;\\n        while(!que.empty()){\\n            TreeNode *temp = que.front();\\n            que.pop();\\n            if(temp->left)\\n                que.push(temp->left);\\n            if(temp->right)\\n                que.push(temp->right);\\n            count--;\\n            if(count == 0){\\n                count = que.size();\\n                res.push_back(temp->val);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56251,
                "title": "java-solution-of-10-lines-code-dfs",
                "content": "    public class Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        help(root,1,result);\\n        return result;\\n    }\\n    public void help(TreeNode root, int depth, List<Integer> result){\\n        if(root==null) return;\\n        if(result.size()<depth) result.add(root.val);\\n        help(root.right,depth+1,result);\\n        help(root.left,depth+1,result);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        help(root,1,result);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 56258,
                "title": "my-4ms-c-iteratvie-solution",
                "content": "My c++ solution is based on level order traversal. The run time is 4ms.\\n\\n    vector<int> rightSideView(TreeNode* root){\\n    \\tvector<int> res;\\n    \\tif (!root)\\n    \\t\\treturn res;\\n    \\tqueue<TreeNode*> q;\\n    \\tq.push(root);\\n    \\tint len;\\n    \\tTreeNode* t;\\n    \\twhile(!q.empty()){\\n    \\t\\tlen = q.size();\\n    \\t\\tfor(int i = 0; i < len; ++i){\\n    \\t\\t\\tt = q.front();\\n    \\t\\t\\tq.pop();\\t\\t\\t\\n    \\t\\t\\tif(t->left)\\n    \\t\\t\\t\\tq.push(t->left);\\n    \\t\\t\\tif(t->right)\\n    \\t\\t\\t\\tq.push(t->right);\\n    \\t\\t}\\n    \\t\\tres.push_back(t->val);\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "My c++ solution is based on level order traversal. The run time is 4ms.\\n\\n    vector<int> rightSideView(TreeNode* root){\\n    \\tvector<int> res;\\n    \\tif (!root)\\n    \\t\\treturn res;\\n    \\tqueue<TreeNode*> q;\\n    \\tq.push(root);\\n    \\tint len;\\n    \\tTreeNode* t;\\n    \\twhile(!q.empty()){\\n    \\t\\tlen = q.size();\\n    \\t\\tfor(int i = 0; i < len; ++i){\\n    \\t\\t\\tt = q.front();\\n    \\t\\t\\tq.pop();\\t\\t\\t\\n    \\t\\t\\tif(t->left)\\n    \\t\\t\\t\\tq.push(t->left);\\n    \\t\\t\\tif(t->right)\\n    \\t\\t\\t\\tq.push(t->right);\\n    \\t\\t}\\n    \\t\\tres.push_back(t->val);\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56291,
                "title": "18-line-recursive-c-solution-in-7-ms",
                "content": "    class Solution {\\n        int level = 0;//number of numbers that have been \"seen\".\\n        vector<int> answer;\\n    public:\\n        vector<int> rightSideView(TreeNode *root) {\\n            if (root!=NULL) travDown(root,0);\\n            return answer;\\n        }\\n        void travDown(TreeNode* nd, int N){//travel down, always go right first\\n            if (N>=level) {\\n                answer.push_back(nd->val);\\n                level++;\\n            }\\n            ++N;\\n            if (nd->right!=NULL) travDown(nd->right,N);\\n            if (nd->left!=NULL) travDown(nd->left,N);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        int level = 0;//number of numbers that have been \"seen\".\\n        vector<int> answer;\\n    public:\\n        vector<int> rightSideView(TreeNode *root) {\\n            if (root!=NULL) travDown(root,0);\\n            return answer;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56304,
                "title": "my-7ms-c-accepted-code",
                "content": "     /**\\n    * Definition for binary tree\\n    * struct TreeNode {\\n    *     int val;\\n    *     TreeNode *left;\\n    *     TreeNode *right;\\n    *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n    * };\\n    */\\n    class Solution {\\n    public:\\n    \\tvector<int> rightSideView(TreeNode *root) {\\n    \\t\\tvector<int> right_side;\\n    \\t\\trightSide(root, right_side, 0);\\n    \\t\\treturn right_side;\\n    \\t}\\n    \\tvoid rightSide(TreeNode *r, vector<int> &a, int i)\\n    \\t{\\n    \\t\\tif (r == NULL)return;\\n    \\t\\tif (i == a.size())\\n    \\t\\t\\ta.push_back(r->val);\\n    \\t\\trightSide(r->right, a, i + 1);\\n    \\t\\trightSide(r->left, a, i + 1);\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvector<int> rightSideView(TreeNode *root) {\\n    \\t\\tvector<int> right_side;\\n    \\t\\trightSide(root, right_side, 0);\\n    \\t\\treturn right_side;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3831809,
                "title": "c-solutions-recursive-solution-with-visulaization-easy-to-understand",
                "content": "![IMG_3019.jpg](https://assets.leetcode.com/users/images/40da9fd4-2645-479a-bf08-b7f7c94d172b_1690608755.8318143.jpeg)\\n![IMG_3020.jpg](https://assets.leetcode.com/users/images/0b552e33-d467-4444-b393-faf0645d6209_1690608768.7683325.jpeg)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        int level = 0;\\n        rightside(root, level, ans);\\n        return ans;\\n    }\\n\\nprivate:\\n    void rightside(TreeNode* root, int level, std::vector<int>& ans) {\\n        if (root == NULL) {\\n            return ;\\n        }\\n\\n        if (ans.size() == level) {\\n            ans.push_back(root->val);\\n        }\\n\\n        rightside(root->right, level + 1, ans);\\n        rightside(root->left, level + 1, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        int level = 0;\\n        rightside(root, level, ans);\\n        return ans;\\n    }\\n\\nprivate:\\n    void rightside(TreeNode* root, int level, std::vector<int>& ans) {\\n        if (root == NULL) {\\n            return ;\\n        }\\n\\n        if (ans.size() == level) {\\n            ans.push_back(root->val);\\n        }\\n\\n        rightside(root->right, level + 1, ans);\\n        rightside(root->left, level + 1, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625528,
                "title": "simple-solution-in-c-using-maps-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>m,m1;\\n    void inorder(TreeNode *root,int c)\\n    {\\n        if(root!=NULL)\\n        {\\n            if(m1[c]==0)\\n            {\\n                m1[c]=1;\\n                m[c]=root->val;\\n            }\\n            inorder(root->right,c+1);\\n            inorder(root->left,c+1);\\n        }\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        inorder(root,1);\\n        vector<int>v;\\n        for(auto l:m)\\n        {\\n            v.push_back(l.second);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>m,m1;\\n    void inorder(TreeNode *root,int c)\\n    {\\n        if(root!=NULL)\\n        {\\n            if(m1[c]==0)\\n            {\\n                m1[c]=1;\\n                m[c]=root->val;\\n            }\\n            inorder(root->right,c+1);\\n            inorder(root->left,c+1);\\n        }\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        inorder(root,1);\\n        vector<int>v;\\n        for(auto l:m)\\n        {\\n            v.push_back(l.second);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265980,
                "title": "c-bfs-2method-while-currsize-0-and-using-a-mark-point-with-null-100-0ms",
                "content": "IF you understand please give a **UPVOTE**\\u2B06\\uFE0F\\n**In lymann language** : the Question says if we put a mirror at the right of the tree then return all those nodes who can see their face in mirror.\\n**In Coding Language** : we have to return all those nodes which are rightmost at their respective levels.\\n### Method-1\\n\\n##### Everytime we insert the first node in ans vector ( becoz we traverse left <-- right)  \\nthe first node is desired node. After that we just pushes the other nodes and their respective childs and pop accordingly.\\nHere\\'s the code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return {};\\n        }\\n        vector<int> v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.size()!=0)\\n        {\\n           int s=q.size();\\n            v.push_back(q.front()->val);\\n            while(s>0)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->right) \\n                {\\n                    q.push(node->right);\\n                }\\n                if(node->left) \\n                {\\n                    q.push(node->left);\\n                }\\n                s--;\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n```\\n### Method 2\\nIt\\'s like a mark point\\nIn this approach we insert NULL at the end of level so that when we encounter after the particular node aftr that queue.front ==NULL  then it shows that its a desired node .Wwe push again NULL it will go to the last of the queue and signify the end of next level.\\ntheir are three of cases:\\ni) encounter the null : just leave the node;\\nii) meet with the node with next is NULL ;\\niii) other between nodes just put their child nodes.\\nHere\\'s the code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return {};\\n        }\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(q.size()!=0)\\n        {\\n            auto node=q.front();\\n            q.pop();\\n            if(node==NULL)\\n            {\\n                continue;\\n            }\\n            else if(q.front()==NULL)\\n            {\\n                ans.push_back(node->val);\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n                q.push(NULL);\\n            }\\n            else\\n            {\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nIF you understand please give a **UPVOTE**\\u2B06\\uFE0F\\n\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return {};\\n        }\\n        vector<int> v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.size()!=0)\\n        {\\n           int s=q.size();\\n            v.push_back(q.front()->val);\\n            while(s>0)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->right) \\n                {\\n                    q.push(node->right);\\n                }\\n                if(node->left) \\n                {\\n                    q.push(node->left);\\n                }\\n                s--;\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return {};\\n        }\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(q.size()!=0)\\n        {\\n            auto node=q.front();\\n            q.pop();\\n            if(node==NULL)\\n            {\\n                continue;\\n            }\\n            else if(q.front()==NULL)\\n            {\\n                ans.push_back(node->val);\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n                q.push(NULL);\\n            }\\n            else\\n            {\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265840,
                "title": "simple-java-solution-w-video-explanation-1ms",
                "content": "*Please **Upvote** if you find this helpful*\\n\\n**Video Explanation**\\n[Binary Tree Right Side View | YouTube](https://www.youtube.com/watch?v=kZcqs4BZgjY&feature=youtu.be)\\n\\n**Java Solution**\\n```\\n//1ms\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        dfs(root,ans,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, List<Integer> ans, int depth){\\n        if(root == null)return;\\n        \\n        if(depth == ans.size()) ans.add(root.val);\\n        \\n        dfs(root.right,ans,depth+1);\\n        dfs(root.left,ans,depth+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n//1ms\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        dfs(root,ans,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, List<Integer> ans, int depth){\\n        if(root == null)return;\\n        \\n        if(depth == ans.size()) ans.add(root.val);\\n        \\n        dfs(root.right,ans,depth+1);\\n        dfs(root.left,ans,depth+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265812,
                "title": "go-python-c-java-iterative-bfs-w-comments",
                "content": "<iframe src=\"https://leetcode.com/playground/NMEs9yiU/shared\" frameBorder=\"0\" width=\"900\" height=\"600\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Go"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/NMEs9yiU/shared\" frameBorder=\"0\" width=\"900\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1861280,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t\\tview = []\\n\\t\\t\\tqueue = []\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn view\\n\\t\\t\\tqueue.append(root)\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tfor i in range(len(queue)):\\n\\t\\t\\t\\t\\tnode = queue.pop(0)\\n\\t\\t\\t\\t\\tif node.left:  queue.append(node.left)\\n\\t\\t\\t\\t\\tif node.right: queue.append(node.right)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tview.append(node.val)     #this will be at right most \\n\\t\\t\\treturn view\\n\\t\\t\\t\\n\\t\\t\\t\\'\\'\\' If any doubt regarding solution please ask \\n\\t\\t\\t if you like it please upvote\\'\\'\\'\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t\\tview = []\\n\\t\\t\\tqueue = []\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn view\\n\\t\\t\\tqueue.append(root)\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tfor i in range(len(queue)):\\n\\t\\t\\t\\t\\tnode = queue.pop(0)\\n\\t\\t\\t\\t\\tif node.left:  queue.append(node.left)\\n\\t\\t\\t\\t\\tif node.right: queue.append(node.right)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tview.append(node.val)     #this will be at right most \\n\\t\\t\\treturn view\\n\\t\\t\\t\\n\\t\\t\\t\\'\\'\\' If any doubt regarding solution please ask \\n\\t\\t\\t if you like it please upvote\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 1823845,
                "title": "golang-dfs-100-time-and-space",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc rightSideView(root *TreeNode) []int {\\n    output := []int{}\\n\\tvar recurse func(root *TreeNode, level int)\\n\\trecurse = func(root *TreeNode, level int) {\\n\\t\\tif root == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif level == len(output) {\\n\\t\\t\\toutput = append(output, root.Val)\\n\\t\\t}\\n\\n\\t\\tif root.Right != nil {\\n\\t\\t\\trecurse(root.Right, level + 1)\\n\\t\\t}\\n\\n\\t\\tif root.Left != nil {\\n\\t\\t\\trecurse(root.Left, level + 1)\\n\\t\\t}\\n\\t}\\n\\n\\trecurse(root, 0)\\n\\treturn output\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc rightSideView(root *TreeNode) []int {\\n    output := []int{}\\n\\tvar recurse func(root *TreeNode, level int)\\n\\trecurse = func(root *TreeNode, level int) {\\n\\t\\tif root == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif level == len(output) {\\n\\t\\t\\toutput = append(output, root.Val)\\n\\t\\t}\\n\\n\\t\\tif root.Right != nil {\\n\\t\\t\\trecurse(root.Right, level + 1)\\n\\t\\t}\\n\\n\\t\\tif root.Left != nil {\\n\\t\\t\\trecurse(root.Left, level + 1)\\n\\t\\t}\\n\\t}\\n\\n\\trecurse(root, 0)\\n\\treturn output\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765813,
                "title": "idiomatic-rust-0-ms-solution-using-bfs",
                "content": "Interacting with trees and other data structures with rust can be a pain because of the issues needing mutable pointers to an immutable object. Definitely read the [Smart pointers](/https://doc.rust-lang.org/book/ch15-00-smart-pointers.html/) Chapter of the rust documentation, if you haven\\'t already/don\\'t know about smart pointers.\\n\\nHigh level overview, the question employs a  little misdirection so you won\\'t immediately realize it is a problem that can easily be solved by breadth-first-search (BFS). The wording given is basically the same as return the rightmost value for every row in the tree. If you recall, BFS traverses the tree by each row in left to right order, if you keep track of each row, you\\'ll be traversing the tree in level-order-traversal. So we\\'ll just get each of the row\\'s last value and push it onto the ans array. There are a lot of BFS and level-order-traversal resources, so I will focus on satisfying with the Rust compilier instead :) All comments are in line.\\n\\nFirst let\\'s look at the function declaration: `pub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32>`\\nRust is a strongly typed language, so we need to know the type of the each root node. It\\'s the [Option enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html) containing a smart pointer to a `TreeNode` struct. \\n\\n```\\npub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n\\t// Create the vector that we will return, notice rust compiler can figure out the type\\n\\tlet mut ans = vec![]; \\n\\t\\n\\t// Create Vec<Rc<RefCell<TreeNode>> we will use to do our BFS\\n\\t// We no longer use Option<T> because it we will only push onto this vec\\n\\t// if the enum is some (which we will enforce with pattern matching.\\n\\n\\tlet mut bfs = vec![]; \\n\\t\\n\\t// First example of pattern matching. If root contains something,\\n\\t// we\\'ll push the inner part of the enum onto the back of our bfs queue.\\n\\t// If it contains nothing, we\\'ll do nothing a.k.a. ()\\n\\tmatch root {\\n\\t\\tSome(x) => bfs.push(x),\\n\\t\\tNone => ()\\n\\t}\\n    \\n\\t// main loop of BFS, keep going if there is something in the queue.\\n\\twhile bfs.len() != 0 {\\n\\t\\t// First think we want to do is get the value of the TreeNode at the rightmost val\\n\\t\\t// of the bfs vec\\n\\t\\tans.push(bfs[bfs.len()-1].borrow().val);\\n        // Note we have to borrow the node to get access to follow the smart pointer to \\n\\t\\t// the struct itself.\\n\\t\\t\\n\\t\\t// now we\\'re ready to find the next row/level\\n\\t\\tlet mut row = vec![];\\n\\t\\tfor node in bfs.iter() {\\n\\t\\t\\t// another match statement as before, except this time we borrow the left value as a reference.\\n\\t\\t\\tmatch node.borrow().left.as_ref() {\\n\\t\\t\\t\\t// only push onto row if the node actually contains something.\\n\\t\\t\\t\\tSome(x) => row.push(Rc::clone(x)), \\n\\t\\t\\t\\tNone => (),\\n\\t\\t\\t};\\n\\t\\t\\t// We also have to clone the pointer, as opposed to before. Why? Both the TreeNode and our row will \\n\\t\\t\\t// point to the leaf in the tree. That\\'s a problem because rust worries about things like double\\n\\t\\t\\t// free errors. You need to do the reference counting yourself, and the memory will only be deallocated\\n\\t\\t\\t// when there are no strong references to a particular struct/object. \\n\\t\\t\\t// This is basically manual garbage collection and does incur a runtime penalty\\n\\t\\t\\t\\n\\t\\t\\t// Nothing fancy rustwise here. just the same thing \\n\\t\\t\\tmatch node.borrow().right.as_ref() {\\n\\t\\t\\t\\tSome(x) => row.push(Rc::clone(x)),\\n\\t\\t\\t\\tNone => (),\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\t// make the queue equal to the row we just built, and go back to the while loop.\\n\\t\\tbfs = row;\\n\\t}\\n\\t// return ans\\n\\tans\\n}\\n",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "Interacting with trees and other data structures with rust can be a pain because of the issues needing mutable pointers to an immutable object. Definitely read the [Smart pointers](/https://doc.rust-lang.org/book/ch15-00-smart-pointers.html/) Chapter of the rust documentation, if you haven\\'t already/don\\'t know about smart pointers.\\n\\nHigh level overview, the question employs a  little misdirection so you won\\'t immediately realize it is a problem that can easily be solved by breadth-first-search (BFS). The wording given is basically the same as return the rightmost value for every row in the tree. If you recall, BFS traverses the tree by each row in left to right order, if you keep track of each row, you\\'ll be traversing the tree in level-order-traversal. So we\\'ll just get each of the row\\'s last value and push it onto the ans array. There are a lot of BFS and level-order-traversal resources, so I will focus on satisfying with the Rust compilier instead :) All comments are in line.\\n\\nFirst let\\'s look at the function declaration: `pub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32>`\\nRust is a strongly typed language, so we need to know the type of the each root node. It\\'s the [Option enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html) containing a smart pointer to a `TreeNode` struct. \\n\\n```\\npub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n\\t// Create the vector that we will return, notice rust compiler can figure out the type\\n\\tlet mut ans = vec![]; \\n\\t\\n\\t// Create Vec<Rc<RefCell<TreeNode>> we will use to do our BFS\\n\\t// We no longer use Option<T> because it we will only push onto this vec\\n\\t// if the enum is some (which we will enforce with pattern matching.\\n\\n\\tlet mut bfs = vec![]; \\n\\t\\n\\t// First example of pattern matching. If root contains something,\\n\\t// we\\'ll push the inner part of the enum onto the back of our bfs queue.\\n\\t// If it contains nothing, we\\'ll do nothing a.k.a. ()\\n\\tmatch root {\\n\\t\\tSome(x) => bfs.push(x),\\n\\t\\tNone => ()\\n\\t}\\n    \\n\\t// main loop of BFS, keep going if there is something in the queue.\\n\\twhile bfs.len() != 0 {\\n\\t\\t// First think we want to do is get the value of the TreeNode at the rightmost val\\n\\t\\t// of the bfs vec\\n\\t\\tans.push(bfs[bfs.len()-1].borrow().val);\\n        // Note we have to borrow the node to get access to follow the smart pointer to \\n\\t\\t// the struct itself.\\n\\t\\t\\n\\t\\t// now we\\'re ready to find the next row/level\\n\\t\\tlet mut row = vec![];\\n\\t\\tfor node in bfs.iter() {\\n\\t\\t\\t// another match statement as before, except this time we borrow the left value as a reference.\\n\\t\\t\\tmatch node.borrow().left.as_ref() {\\n\\t\\t\\t\\t// only push onto row if the node actually contains something.\\n\\t\\t\\t\\tSome(x) => row.push(Rc::clone(x)), \\n\\t\\t\\t\\tNone => (),\\n\\t\\t\\t};\\n\\t\\t\\t// We also have to clone the pointer, as opposed to before. Why? Both the TreeNode and our row will \\n\\t\\t\\t// point to the leaf in the tree. That\\'s a problem because rust worries about things like double\\n\\t\\t\\t// free errors. You need to do the reference counting yourself, and the memory will only be deallocated\\n\\t\\t\\t// when there are no strong references to a particular struct/object. \\n\\t\\t\\t// This is basically manual garbage collection and does incur a runtime penalty\\n\\t\\t\\t\\n\\t\\t\\t// Nothing fancy rustwise here. just the same thing \\n\\t\\t\\tmatch node.borrow().right.as_ref() {\\n\\t\\t\\t\\tSome(x) => row.push(Rc::clone(x)),\\n\\t\\t\\t\\tNone => (),\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\t// make the queue equal to the row we just built, and go back to the while loop.\\n\\t\\tbfs = row;\\n\\t}\\n\\t// return ans\\n\\tans\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 327960,
                "title": "python-solution-with-no-additional-space-and-96-61-faster",
                "content": "The idea is to do reverse preorder traversal and add only one (right most) node at each level:\\n\\n```\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        res, max_level = [], -1\\n        \\n        def traverse_tree(node, level):\\n            nonlocal res, max_level\\n            if not node:\\n                return\\n            if max_level < level:\\n                res.append(node.val)\\n                max_level = level\\n            traverse_tree(node.right, level + 1)\\n            traverse_tree(node.left, level + 1)\\n        \\n        traverse_tree(root, 0)\\n        return res\\n```\\n\\nWe traverse the tree from right to left.  The variable max_level is used to track if we have already added the right most element for that level. The time complexity is O(n) and space complexity is O(1). If we consider recursion, then it is O(n) for call stack.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        res, max_level = [], -1\\n        \\n        def traverse_tree(node, level):\\n            nonlocal res, max_level\\n            if not node:\\n                return\\n            if max_level < level:\\n                res.append(node.val)\\n                max_level = level\\n            traverse_tree(node.right, level + 1)\\n            traverse_tree(node.left, level + 1)\\n        \\n        traverse_tree(root, 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254146,
                "title": "java-dfs-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root == null)\\n            return result;\\n        rightSideViewHelper(root, result, 0);\\n        return result;\\n    }\\n    \\n    private void rightSideViewHelper(TreeNode node, List<Integer> result, int level){\\n        if(node == null)\\n            return;\\n        \\n        if(result.size() == level){\\n            result.add(node.val);            \\n        }\\n        \\n        rightSideViewHelper(node.right, result, level+1);\\n        rightSideViewHelper(node.left, result, level+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root == null)\\n            return result;\\n        rightSideViewHelper(root, result, 0);\\n        return result;\\n    }\\n    \\n    private void rightSideViewHelper(TreeNode node, List<Integer> result, int level){\\n        if(node == null)\\n            return;\\n        \\n        if(result.size() == level){\\n            result.add(node.val);            \\n        }\\n        \\n        rightSideViewHelper(node.right, result, level+1);\\n        rightSideViewHelper(node.left, result, level+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56189,
                "title": "java-easy-solution-beats-90-using-dfs",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> view = new ArrayList<Integer>();\\n            if(null==root) return view;\\n            dfs(view, root, 1);\\n            return view;\\n        }\\n        private void dfs(List<Integer> view, TreeNode root, int layer){\\n            if(root == null) return;\\n            if(layer > view.size()) view.add(root.val);\\n            dfs(view, root.right, layer+1);\\n            dfs(view, root.left, layer+1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> view = new ArrayList<Integer>();\\n            if(null==root) return view;\\n            dfs(view, root, 1);\\n            return view;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4092411,
                "title": "c-dfs-pre-order-traversal-easy",
                "content": "# Intution\\n    We will use DFS instead of BFS because it is more space optimized.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    \\n    We will Traverse through root->right->left unlike trivial\\n    pre-order traversal which is root->left->right.\\n\\n    Whenever the traversal level equals to ans size, we push the root \\n    value in ans, which will be right View.\\n    \\n    Similarly for left view we can use trivial PreOrder Traversal i.e,\\n    root->left->right.\\n\\n    Go through the code for more clear concept.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      void helper(TreeNode* root,vector<int>&ans,int level){\\n        if(root== NULL)\\n        return;\\n        if(ans.size() == level){\\n            ans.push_back(root->val);\\n        }\\n        helper(root->right,ans,level+1);\\n        helper(root->left,ans,level+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n        int level = 0;\\n        helper(root,ans,level);\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(number of nodes)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(height of tree)\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      void helper(TreeNode* root,vector<int>&ans,int level){\\n        if(root== NULL)\\n        return;\\n        if(ans.size() == level){\\n            ans.push_back(root->val);\\n        }\\n        helper(root->right,ans,level+1);\\n        helper(root->left,ans,level+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n        int level = 0;\\n        helper(root,ans,level);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955744,
                "title": "2-easy-c-solutions-recursive-and-iterative-approach-beats-100",
                "content": "# Code\\n```\\n// Iterative solution\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL)\\n            return ans;\\n    \\n        map<int, int> mp;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            pair<TreeNode*, int> temp = q.front();\\n            q.pop();\\n\\n            TreeNode *node = temp.first;\\n            int level = temp.second;\\n\\n            mp[level] = node->val;\\n        \\n            if(node->left != NULL)\\n                q.push({node->left, level+1});\\n            if(node->right != NULL)\\n                q.push({node->right, level+1});\\n        }\\n\\n        for(auto it : mp)\\n            ans.push_back(it.second);\\n        \\n        return ans;\\n    }\\n};\\n\\n// Recursive solution\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root, int level, vector<int> &ans){\\n        if(root==NULL) \\n            return ;\\n        \\n        if(ans.size()<level) \\n            ans.push_back(root->val);\\n        \\n        recursion(root->right, level+1, ans);\\n        recursion(root->left, level+1, ans);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode *root) {\\n        vector<int> ans;\\n        recursion(root, 1, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Iterative solution\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL)\\n            return ans;\\n    \\n        map<int, int> mp;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            pair<TreeNode*, int> temp = q.front();\\n            q.pop();\\n\\n            TreeNode *node = temp.first;\\n            int level = temp.second;\\n\\n            mp[level] = node->val;\\n        \\n            if(node->left != NULL)\\n                q.push({node->left, level+1});\\n            if(node->right != NULL)\\n                q.push({node->right, level+1});\\n        }\\n\\n        for(auto it : mp)\\n            ans.push_back(it.second);\\n        \\n        return ans;\\n    }\\n};\\n\\n// Recursive solution\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root, int level, vector<int> &ans){\\n        if(root==NULL) \\n            return ;\\n        \\n        if(ans.size()<level) \\n            ans.push_back(root->val);\\n        \\n        recursion(root->right, level+1, ans);\\n        recursion(root->left, level+1, ans);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode *root) {\\n        vector<int> ans;\\n        recursion(root, 1, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571333,
                "title": "easy-c-dfs-bfs-both-codes",
                "content": "\\n\\n\\n\\n# THE DFS Code\\n```\\n\\nclass Solution {\\npublic:\\nvoid helper(TreeNode* root,int level, vector<int>&t)\\n{\\n     if(root==NULL) return ;\\n        if(t.size()==level) t.push_back(root->val);\\n        helper(root->right, level+1,t);\\n        helper(root->left, level+1,t);\\n\\n}\\n    vector<int> rightSideView(TreeNode* root) {\\n    if(!root)\\n    return {};\\n\\n    vector<int>t;\\n    \\n   helper(root,0,t);      \\n\\n    return t;\\n     }\\n};\\n```\\n\\n# THE BFS CODE\\n\\n```\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> rightSideView(TreeNode* root) {\\n    if(!root)\\n    return {};\\n\\n    vector<int>temp;\\n    \\n       \\n  queue<TreeNode*> q;\\n  q.push(root);\\n  while(!q.empty())\\n  {\\n       int sz=q.size();\\n       for(int i=0;i<sz;i++)\\n       {\\n            auto it=q.front();\\n            if(i==sz-1)\\n            temp.push_back(q.front()->val);\\n           if(it->left)\\n            q.push(it->left);\\n           if(it->right)\\n            q.push(it->right);\\n          \\n            q.pop();\\n       }\\n  }\\n\\n    return temp;\\n     }\\n};\\n```\\n\\n\\nPlease upvote if you like it.\\nAny suggestion would be highly appreciated thanks for clicking in",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\nvoid helper(TreeNode* root,int level, vector<int>&t)\\n{\\n     if(root==NULL) return ;\\n        if(t.size()==level) t.push_back(root->val);\\n        helper(root->right, level+1,t);\\n        helper(root->left, level+1,t);\\n\\n}\\n    vector<int> rightSideView(TreeNode* root) {\\n    if(!root)\\n    return {};\\n\\n    vector<int>t;\\n    \\n   helper(root,0,t);      \\n\\n    return t;\\n     }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> rightSideView(TreeNode* root) {\\n    if(!root)\\n    return {};\\n\\n    vector<int>temp;\\n    \\n       \\n  queue<TreeNode*> q;\\n  q.push(root);\\n  while(!q.empty())\\n  {\\n       int sz=q.size();\\n       for(int i=0;i<sz;i++)\\n       {\\n            auto it=q.front();\\n            if(i==sz-1)\\n            temp.push_back(q.front()->val);\\n           if(it->left)\\n            q.push(it->left);\\n           if(it->right)\\n            q.push(it->right);\\n          \\n            q.pop();\\n       }\\n  }\\n\\n    return temp;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428186,
                "title": "beats-100-dfs-using-recursion",
                "content": "\\n\\n# Approach\\nLet\\'s take an example which will cover almost all test cases. \\n\\n`Visualize a tree :- [1,2,3,4,null,null,null and an empty list =[]`\\n\\n![WhatsApp Image 2023-04-18 at 00.28.27.jpeg](https://assets.leetcode.com/users/images/92f74e24-251f-4c61-aa86-3b6e636ef1e2_1681757958.9612167.jpeg)\\n\\n\\nThe root of the tree is at a depth 0. and size of the list is also 0 at first so \\n\\n`if (depth==list.size())\\nlist.add(root.val)`\\n\\nSo our list becomes \\n\\n`list=[1]`\\n\\nNow we use recursion to traverse the right subtree and apply the aforementioned logic until we get `list=[1,3]` before traversing the left subtree.\\n\\nAs we traverse the left subtree, when we reach node 2, we won\\'t add it to list because `depth(node2)=1) which is not equal to list.size() =2`\\n\\nThen when we reach node 4, `depth==list.size()` so we add it to list and the list becomes `list=[1,3,4]`\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer>list = new ArrayList();\\n        recursion(root,list,0);\\n        return list;\\n    }\\n    public void recursion (TreeNode root, List<Integer> list, int depth) {\\n        if (root==null)\\n        return;\\n\\n        if(depth==list.size())\\n        list.add(root.val);\\n\\n        recursion(root.right,list,depth+1);\\n        recursion(root.left,list,depth+1);\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer>list = new ArrayList();\\n        recursion(root,list,0);\\n        return list;\\n    }\\n    public void recursion (TreeNode root, List<Integer> list, int depth) {\\n        if (root==null)\\n        return;\\n\\n        if(depth==list.size())\\n        list.add(root.val);\\n\\n        recursion(root.right,list,depth+1);\\n        recursion(root.left,list,depth+1);\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356560,
                "title": "solution-using-both-approach-bfs-and-dfs-in-c",
                "content": "\\n\\n# Code\\n```\\n                                DFS\\npreorder krenge serch bs differ itnhoga left ke jgh right child pehle view krwayenge -and jb level or vector ans ka size same hoga hum wo element store kr lenge kyunki wo us level ka sbse right element hoga\\n t.c:O(n)\\n s.c:O(height)\\n\\nclass Solution {\\npublic:\\n vector<int> answer; \\n    void dfs(TreeNode* root,int level=0){\\n        if(!root)return;\\n        if(answer.size()==level)answer.push_back(root->val);\\n        dfs(root->right,level+1);  \\n        dfs(root->left,level+1);  \\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n      dfs(root);\\n      return answer;\\n    }\\n};\\n                                 BFS\\nLevel order serch where we will see the rightmost element\\n t.c:O(n)\\n s.c:O(n)\\n\\nclass Solution {\\npublic:\\n vector<int> answer; \\n    vector<int> rightSideView(TreeNode* root) {\\n      if(!root)return answer;\\n      int size;\\n      TreeNode* top;\\n      queue<TreeNode*> q;\\n      q.push(root);\\n      while(!q.empty()){\\n      size=q.size();\\n      for(int i=0;i<size;i++){\\n        top=q.front();\\n        q.pop();\\n        if(top->left)q.push(top->left);\\n        if(top->right)q.push(top->right);\\n      }\\n       answer.push_back(top->val);\\n      }\\n      return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n                                DFS\\npreorder krenge serch bs differ itnhoga left ke jgh right child pehle view krwayenge -and jb level or vector ans ka size same hoga hum wo element store kr lenge kyunki wo us level ka sbse right element hoga\\n t.c:O(n)\\n s.c:O(height)\\n\\nclass Solution {\\npublic:\\n vector<int> answer; \\n    void dfs(TreeNode* root,int level=0){\\n        if(!root)return;\\n        if(answer.size()==level)answer.push_back(root->val);\\n        dfs(root->right,level+1);  \\n        dfs(root->left,level+1);  \\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n      dfs(root);\\n      return answer;\\n    }\\n};\\n                                 BFS\\nLevel order serch where we will see the rightmost element\\n t.c:O(n)\\n s.c:O(n)\\n\\nclass Solution {\\npublic:\\n vector<int> answer; \\n    vector<int> rightSideView(TreeNode* root) {\\n      if(!root)return answer;\\n      int size;\\n      TreeNode* top;\\n      queue<TreeNode*> q;\\n      q.push(root);\\n      while(!q.empty()){\\n      size=q.size();\\n      for(int i=0;i<size;i++){\\n        top=q.front();\\n        q.pop();\\n        if(top->left)q.push(top->left);\\n        if(top->right)q.push(top->right);\\n      }\\n       answer.push_back(top->val);\\n      }\\n      return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355761,
                "title": "simple-to-understand-c-solution",
                "content": "# Approach\\nThis problem can be solved using both DFS and BFS.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> answer;\\n    vector<int> rightSideView(TreeNode* root) {\\n        if(root == NULL){\\n            return answer;\\n        }\\n        dfs(root,0);\\n        return answer;\\n    }\\n    void dfs(TreeNode* root,int lvl){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(lvl == answer.size()){\\n            answer.push_back(root->val);\\n        }\\n        dfs(root->right,lvl+1);\\n        dfs(root->left,lvl+1);\\n\\n    }\\n};  \\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> answer;\\n    vector<int> rightSideView(TreeNode* root) {\\n        if(root == NULL){\\n            return answer;\\n        }\\n        dfs(root,0);\\n        return answer;\\n    }\\n    void dfs(TreeNode* root,int lvl){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(lvl == answer.size()){\\n            answer.push_back(root->val);\\n        }\\n        dfs(root->right,lvl+1);\\n        dfs(root->left,lvl+1);\\n\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252612,
                "title": "c-easy-recursive-solution",
                "content": "<!-- # Intuition -->\\n<!-- Right Side View - Set of nodes visible when the tree is seen from the right side.  -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<int> &ans, int level)\\n    {\\n        // base case\\n        if (root == NULL)\\n        {\\n            return ; \\n        }\\n\\n        // we entered a new level \\n        if (level == ans.size())\\n        {\\n            ans.push_back(root -> val) ; \\n        }\\n\\n        solve(root -> right, ans, level + 1) ; \\n        solve(root -> left, ans, level + 1 ) ; \\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans ; \\n        int level = 0 ; \\n\\n        solve(root, ans, level) ;\\n        \\n        return ans ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/bb6c318f-9c6e-4df4-99cd-4a29f658aa43_1677859076.491966.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<int> &ans, int level)\\n    {\\n        // base case\\n        if (root == NULL)\\n        {\\n            return ; \\n        }\\n\\n        // we entered a new level \\n        if (level == ans.size())\\n        {\\n            ans.push_back(root -> val) ; \\n        }\\n\\n        solve(root -> right, ans, level + 1) ; \\n        solve(root -> left, ans, level + 1 ) ; \\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans ; \\n        int level = 0 ; \\n\\n        solve(root, ans, level) ;\\n        \\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225070,
                "title": "c-bfs-dfs",
                "content": "# Approach 1\\nBFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<int> view;\\n        queue<TreeNode*> todo;\\n        todo.push(root);\\n        while (!todo.empty()) {\\n            int n = todo.size();\\n            for (int i = 0; i < n; i++) {\\n                TreeNode* node = todo.front();\\n                todo.pop();\\n                if (i == n - 1) {\\n                    view.push_back(node -> val);\\n                }\\n                if (node -> left) {\\n                    todo.push(node -> left);\\n                }\\n                if (node -> right) {\\n                    todo.push(node -> right);\\n                }\\n            }\\n        }\\n        return view;\\n    }\\n};\\n```\\n\\n# Approach 2\\nDFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector <int> ans;\\n        traversal(root, 0, ans);\\n        return ans;\\n    }\\nprivate:\\n    void traversal(TreeNode* root, int level, vector <int>& ans) {\\n        if (root == NULL)\\n            return;\\n        if (ans.size() == level)\\n            ans.push_back(root->val);\\n        traversal(root->right, level + 1, ans); \\n        traversal(root->left, level + 1, ans);        \\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<int> view;\\n        queue<TreeNode*> todo;\\n        todo.push(root);\\n        while (!todo.empty()) {\\n            int n = todo.size();\\n            for (int i = 0; i < n; i++) {\\n                TreeNode* node = todo.front();\\n                todo.pop();\\n                if (i == n - 1) {\\n                    view.push_back(node -> val);\\n                }\\n                if (node -> left) {\\n                    todo.push(node -> left);\\n                }\\n                if (node -> right) {\\n                    todo.push(node -> right);\\n                }\\n            }\\n        }\\n        return view;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector <int> ans;\\n        traversal(root, 0, ans);\\n        return ans;\\n    }\\nprivate:\\n    void traversal(TreeNode* root, int level, vector <int>& ans) {\\n        if (root == NULL)\\n            return;\\n        if (ans.size() == level)\\n            ans.push_back(root->val);\\n        traversal(root->right, level + 1, ans); \\n        traversal(root->left, level + 1, ans);        \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087412,
                "title": "beats-100-best-c-solution",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        if(root==NULL)\\n        return ans;\\n\\n        while(1){\\n\\n            int size=q.size();\\nif(size==0)\\nreturn ans;\\nint data=0;\\nwhile(size>0){\\nTreeNode* temp =q.front();\\nq.pop();\\ndata=temp->val;\\n\\nif(temp->left !=NULL)\\nq.push(temp->left);\\n\\nif(temp->right!=NULL)\\nq.push(temp->right);\\n\\nsize--;\\n}\\nans.push_back(data);\\n        }\\n   return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        if(root==NULL)\\n        return ans;\\n\\n        while(1){\\n\\n            int size=q.size();\\nif(size==0)\\nreturn ans;\\nint data=0;\\nwhile(size>0){\\nTreeNode* temp =q.front();\\nq.pop();\\ndata=temp->val;\\n\\nif(temp->left !=NULL)\\nq.push(temp->left);\\n\\nif(temp->right!=NULL)\\nq.push(temp->right);\\n\\nsize--;\\n}\\nans.push_back(data);\\n        }\\n   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935783,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int>& ans, int h)\\n    {\\n        if(!root)\\n            return;\\n        if(h==ans.size())\\n        ans.push_back(root->val);\\n        f(root->right,ans,h+1);\\n        f(root->left,ans,h+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int>& ans, int h)\\n    {\\n        if(!root)\\n            return;\\n        if(h==ans.size())\\n        ans.push_back(root->val);\\n        f(root->right,ans,h+1);\\n        f(root->left,ans,h+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680849,
                "title": "python-3-simple-bfs-solution",
                "content": "```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        ans = []\\n        if not root: return ans\\n        \\n        q = [root]\\n        \\n        while q:\\n            lv = []\\n            \\n            ans.append(q[-1].val)\\n            \\n            for node in q:\\n                if node.left: lv.append(node.left)\\n                if node.right: lv.append(node.right)\\n            \\n            q = lv\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        ans = []\\n        if not root: return ans\\n        \\n        q = [root]\\n        \\n        while q:\\n            lv = []\\n            \\n            ans.append(q[-1].val)\\n            \\n            for node in q:\\n                if node.left: lv.append(node.left)\\n                if node.right: lv.append(node.right)\\n            \\n            q = lv\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602768,
                "title": "c-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        vector<int> result;\\n        if(root) q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                if(i==(size-1)) result.push_back(curr->val);\\n                if(curr->left) q.push(curr->left);\\n                if(curr->right) q.push(curr->right);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        vector<int> result;\\n        if(root) q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                if(i==(size-1)) result.push_back(curr->val);\\n                if(curr->left) q.push(curr->left);\\n                if(curr->right) q.push(curr->right);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568234,
                "title": "javascript-diagram-easy-to-understand",
                "content": "**Iterative Solution**\\n\\nWhen you first look at this problem, one may think you should follow the rightmost path and add it to an array. This may work for the example testcase, but it is not the correct answer. If the left child has more levels than the right child, you will still see them when looking from the right, but this solution does not capture this case.\\n![image](https://assets.leetcode.com/users/images/b329291c-520c-4832-bfb8-88f0a83bca42_1663009178.848718.jpeg)\\n\\nA simple **breadth-first traversal** will capture each level and you will be able to use the rightmost value of each of these levels.\\n![image](https://assets.leetcode.com/users/images/6a6af1c6-50d5-45ca-bc97-2975d180ecac_1663009198.459198.jpeg)\\n\\nFirstly, let\\'s create a base case to return an empty array in case root is null.\\n```\\n    if(!r) return [];\\n```\\nSecond, lets initialize vals to an empty array and queue to an array with the root.\\n```\\n    let vals = [], q = [ r ];\\n```\\nThird, lets iterate through the queue using a while loop. As well as declaring the variable size to be the current length of the queue, and declaring level to an empty array. We will fill this level array with all of the values from this level of the binary tree. Size is used in the below for loop to cut us off from adding values from the next level.\\n```\\n    while(q.length){\\n        let size = q.length;\\n        let lvl = [];\\n```\\nLets access each of the nodes currently in the queue. Push them into the level array. If the node has a right or left child, lets add them to the queue. Since we are utilizing the for loop, we will not access these children until the next while iteration.\\n```\\n        for(let i = 0; i < size; i++){\\n            let c = q.shift();\\n            lvl.push(c.val);\\n            if(c.left) q.push(c.left);\\n            if(c.right) q.push(c.right);\\n        }\\n```\\nAfter we create each level array, let\\'s add the rightmost value from that level to the values array.\\n```\\n        vals.push(lvl.at(-1));\\n    }\\n```\\nFinally, return the values array. It now consists of the rightmost value from each level of the binary tree.\\n```\\n    return vals;\\n```\\n\\nHere is the final iterative solution.\\n```\\nfunction rightSideView (r) {\\n    if(!r) return [];\\n    let vals = [];\\n    let q = [ r ];\\n    \\n    while(q.length){\\n        let size = q.length;\\n        let lvl = [];\\n        for(let i = 0; i < size; i++){\\n            let c = q.shift();\\n            lvl.push(c.val);\\n            if(c.left) q.push(c.left);\\n            if(c.right) q.push(c.right);\\n        }\\n        vals.push(lvl.at(-1));\\n    }\\n    return vals;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    if(!r) return [];\\n```\n```\\n    let vals = [], q = [ r ];\\n```\n```\\n    while(q.length){\\n        let size = q.length;\\n        let lvl = [];\\n```\n```\\n        for(let i = 0; i < size; i++){\\n            let c = q.shift();\\n            lvl.push(c.val);\\n            if(c.left) q.push(c.left);\\n            if(c.right) q.push(c.right);\\n        }\\n```\n```\\n        vals.push(lvl.at(-1));\\n    }\\n```\n```\\n    return vals;\\n```\n```\\nfunction rightSideView (r) {\\n    if(!r) return [];\\n    let vals = [];\\n    let q = [ r ];\\n    \\n    while(q.length){\\n        let size = q.length;\\n        let lvl = [];\\n        for(let i = 0; i < size; i++){\\n            let c = q.shift();\\n            lvl.push(c.val);\\n            if(c.left) q.push(c.left);\\n            if(c.right) q.push(c.right);\\n        }\\n        vals.push(lvl.at(-1));\\n    }\\n    return vals;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2520730,
                "title": "python-bfs-queue-easy",
                "content": "```\\nclass Solution:\\n\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        res = []\\n        \\n        q = collections.deque()\\n        \\n        q.append(root)\\n        \\n        while q:\\n            \\n            qlen = len(q)\\n            \\n            level = []\\n            \\n            for i in range(qlen):\\n                node = q.popleft()\\n                if node:\\n                    level.append(node.val)\\n                    q.append(node.left)\\n                    q.append(node.right)\\n            if level:\\n                res.append(level[-1])\\n        \\n        return res         \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        res = []\\n        \\n        q = collections.deque()\\n        \\n        q.append(root)\\n        \\n        while q:\\n            \\n            qlen = len(q)\\n            \\n            level = []\\n            \\n            for i in range(qlen):\\n                node = q.popleft()\\n                if node:\\n                    level.append(node.val)\\n                    q.append(node.left)\\n                    q.append(node.right)\\n            if level:\\n                res.append(level[-1])\\n        \\n        return res         \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266254,
                "title": "easy-understandable-level-order-traversal",
                "content": "Simply use BFS (right-to-left level order) to get the right side view of every level of the tree using queue data structure.\\n* Start by adding root node in the queue\\n* Add top of queue to result list, as the top will be the rightmost node of the level. \\n* Then for the remaining nodes in the entire level add their children to the queue (first right then left child) by removing each one of them.\\n* Repeat 2nd and 3rd step until the queue becomes empty.\\n\\n**Pls note:** Taking queue of pair of TreeNode(to access children) and Integer(to check for level). \\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> l = new ArrayList<>();\\n        if(root == null) return l;\\n        \\n        // first -> node\\n        // second-> node level\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        \\n        // Starting traversal with root node having level 0\\n        int level = 0;\\n        q.add(new Pair(root, level));\\n        \\n        while(!q.isEmpty()){\\n            \\n            // Node at the top of the queue (for rightmost node of the level)\\n            l.add(q.peek().getKey().val);\\n            \\n            // Clear the complete level from queue after adding children in queue\\n            while(q.peek() != null && q.peek().getValue() == level){\\n                TreeNode temp = q.remove().getKey();\\n                if(temp.right != null) q.add(new Pair(temp.right, level+1));\\n                if(temp.left != null) q.add(new Pair(temp.left, level+1));\\n            }\\n            \\n            level++;\\n        }\\n        \\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> l = new ArrayList<>();\\n        if(root == null) return l;\\n        \\n        // first -> node\\n        // second-> node level\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        \\n        // Starting traversal with root node having level 0\\n        int level = 0;\\n        q.add(new Pair(root, level));\\n        \\n        while(!q.isEmpty()){\\n            \\n            // Node at the top of the queue (for rightmost node of the level)\\n            l.add(q.peek().getKey().val);\\n            \\n            // Clear the complete level from queue after adding children in queue\\n            while(q.peek() != null && q.peek().getValue() == level){\\n                TreeNode temp = q.remove().getKey();\\n                if(temp.right != null) q.add(new Pair(temp.right, level+1));\\n                if(temp.left != null) q.add(new Pair(temp.left, level+1));\\n            }\\n            \\n            level++;\\n        }\\n        \\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265974,
                "title": "c-solution",
                "content": "```\\nvoid input(struct TreeNode* root, int* returnSize, int* ans, int now){\\n    if(root == NULL){\\n        return;\\n    }\\n    if(now > *returnSize){\\n        ans[*returnSize] = root->val;\\n        *returnSize += 1;\\n    }\\n    input(root->right, returnSize, ans, now+1);\\n    input(root->left, returnSize, ans, now+1);\\n}\\n\\nint* rightSideView(struct TreeNode* root, int* returnSize){\\n    if (root == NULL){\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    int* ans = malloc(sizeof(int)*100);\\n    *returnSize = 0;\\n    input(root, returnSize, ans, 1);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid input(struct TreeNode* root, int* returnSize, int* ans, int now){\\n    if(root == NULL){\\n        return;\\n    }\\n    if(now > *returnSize){\\n        ans[*returnSize] = root->val;\\n        *returnSize += 1;\\n    }\\n    input(root->right, returnSize, ans, now+1);\\n    input(root->left, returnSize, ans, now+1);\\n}\\n\\nint* rightSideView(struct TreeNode* root, int* returnSize){\\n    if (root == NULL){\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    int* ans = malloc(sizeof(int)*100);\\n    *returnSize = 0;\\n    input(root, returnSize, ans, 1);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2177979,
                "title": "c-bfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        vector<int> ans;\\n        if( !root) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while( !q.empty()){\\n            int siz = q.size();\\n            while(siz--){\\n                TreeNode* p = q.front();\\n                q.pop();\\n                if( siz == 0 ) {\\n                    ans.push_back(p->val);\\n                }\\n                if( p->left ) q.push(p->left);\\n                if( p->right) q.push(p->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        vector<int> ans;\\n        if( !root) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while( !q.empty()){\\n            int siz = q.size();\\n            while(siz--){\\n                TreeNode* p = q.front();\\n                q.pop();\\n                if( siz == 0 ) {\\n                    ans.push_back(p->val);\\n                }\\n                if( p->left ) q.push(p->left);\\n                if( p->right) q.push(p->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750766,
                "title": "cpp-100-faster-0ms",
                "content": "upvote if u understand \\n```\\n vector<int> rightSideView(TreeNode* root) {\\n        vector<int> v;\\n        if(root==NULL)\\n            return v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode* t=q.front();\\n            q.pop();\\n            if(t==NULL)\\n            {\\n                if(q.empty())\\n                    break;\\n                q.push(NULL);\\n                continue;\\n            }\\n            if(q.front()==NULL)\\n                v.push_back(t->val);\\n            \\n            if(t->left)\\n                q.push(t->left);\\n            if(t->right)\\n                q.push(t->right);\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n vector<int> rightSideView(TreeNode* root) {\\n        vector<int> v;\\n        if(root==NULL)\\n            return v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode* t=q.front();\\n            q.pop();\\n            if(t==NULL)\\n            {\\n                if(q.empty())\\n                    break;\\n                q.push(NULL);\\n                continue;\\n            }\\n            if(q.front()==NULL)\\n                v.push_back(t->val);\\n            \\n            if(t->left)\\n                q.push(t->left);\\n            if(t->right)\\n                q.push(t->right);\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745865,
                "title": "right-left-top-bottom-view-of-binary-tree",
                "content": "\\nright view of tree using bfs\\n```\\nvector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode *> pending;\\n        if(!root) return {};\\n        vector<int> answer;\\n        pending.push(root);\\n        while(!pending.empty()){\\n            int len = pending.size();\\n            while(len--){\\n                TreeNode * curr = pending.front();\\n                pending.pop();\\n                if(curr->left)pending.push(curr->left);\\n                if(curr->right)pending.push(curr->right);\\n                if(len == 0){\\n                    answer.push_back(curr->val);\\n                }\\n            }\\n        }\\n        return answer;\\n```\\n\\nleft side view\\n```\\nvector<int> leftSideView(TreeNode* root) {\\n        \\n        queue<TreeNode *> pending;\\n        if(!root) return {};\\n        vector<int> answer;\\n        pending.push(root);\\n        while(!pending.empty()){\\n            int len = pending.size();\\n            int initLen = len;\\n            while(len--){\\n                TreeNode * curr = pending.front();\\n                pending.pop();\\n                if(curr->left)pending.push(curr->left);\\n                if(curr->right)pending.push(curr->right);\\n                if(len == initLen-1){\\n                    answer.push_back(curr->val);\\n                }\\n            }\\n        }\\n        return answer;\\n```\\n\\ntop view\\n```\\nvector<int> topView(TreeNode* root) {\\n        \\n        vector<int> answer;\\n        stack<pair<int,TreeNode *>> pending;\\n        TreeNode * curr = root, * prev = NULL;\\n        map<int,int> pos2val;\\n        int pos=0;\\n        while(!pending.empty() || curr){\\n            while(curr){\\n                pending.push(make_pair(pos--,exchange(curr,curr->left)));\\n            }\\n            int idx = pending.top().first;\\n            TreeNode * top = pending.top().second;\\n            if(!top->right || prev == top->right){\\n                pending.pop();\\n                prev = top;\\n                pos2val[idx] = top->val;\\n            }else{\\n                curr = top->right;\\n                pos = idx+1;\\n            }\\n        }\\n        for(auto i = pos2val.begin(); i!=pos2val.end();i++){\\n            answer.push_back(i->second);\\n        }\\n        return answer;\\n```\\n\\nbottom view\\ni think this solution will fail when some elements of right subtree will overlap the elements of the left subtree.\\nalso when two elements at the same depth come at the same position which one should we choose ? Any comments and suggestions are welcome.\\n```\\nvector<int> bottomView(TreeNode* root) {\\n        \\n        vector<int> answer;\\n        stack<pair<int,TreeNode *>> pending;\\n        TreeNode * curr = root, * prev = NULL;\\n        map<int,int> pos2val;\\n        int pos=0;\\n        while(!pending.empty() || curr){\\n            while(curr){\\n                pending.push(make_pair(pos--,exchange(curr,curr->left)));\\n            }\\n            int idx = pending.top().first;\\n            TreeNode * top = pending.top().second;\\n            if(!top->right || prev == top->right){\\n                pending.pop();\\n                prev = top;\\n                if(pos2val.find(idx)==pos2val.end()){\\n                    pos2val[idx] = top->val;  \\n                }\\n                \\n            }else{\\n                curr = top->right;\\n                pos = idx+1;\\n            }\\n        }\\n        for(auto i = pos2val.begin(); i!=pos2val.end();i++){\\n            answer.push_back(i->second);\\n        }\\n        return answer;\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nvector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode *> pending;\\n        if(!root) return {};\\n        vector<int> answer;\\n        pending.push(root);\\n        while(!pending.empty()){\\n            int len = pending.size();\\n            while(len--){\\n                TreeNode * curr = pending.front();\\n                pending.pop();\\n                if(curr->left)pending.push(curr->left);\\n                if(curr->right)pending.push(curr->right);\\n                if(len == 0){\\n                    answer.push_back(curr->val);\\n                }\\n            }\\n        }\\n        return answer;\\n```\n```\\nvector<int> leftSideView(TreeNode* root) {\\n        \\n        queue<TreeNode *> pending;\\n        if(!root) return {};\\n        vector<int> answer;\\n        pending.push(root);\\n        while(!pending.empty()){\\n            int len = pending.size();\\n            int initLen = len;\\n            while(len--){\\n                TreeNode * curr = pending.front();\\n                pending.pop();\\n                if(curr->left)pending.push(curr->left);\\n                if(curr->right)pending.push(curr->right);\\n                if(len == initLen-1){\\n                    answer.push_back(curr->val);\\n                }\\n            }\\n        }\\n        return answer;\\n```\n```\\nvector<int> topView(TreeNode* root) {\\n        \\n        vector<int> answer;\\n        stack<pair<int,TreeNode *>> pending;\\n        TreeNode * curr = root, * prev = NULL;\\n        map<int,int> pos2val;\\n        int pos=0;\\n        while(!pending.empty() || curr){\\n            while(curr){\\n                pending.push(make_pair(pos--,exchange(curr,curr->left)));\\n            }\\n            int idx = pending.top().first;\\n            TreeNode * top = pending.top().second;\\n            if(!top->right || prev == top->right){\\n                pending.pop();\\n                prev = top;\\n                pos2val[idx] = top->val;\\n            }else{\\n                curr = top->right;\\n                pos = idx+1;\\n            }\\n        }\\n        for(auto i = pos2val.begin(); i!=pos2val.end();i++){\\n            answer.push_back(i->second);\\n        }\\n        return answer;\\n```\n```\\nvector<int> bottomView(TreeNode* root) {\\n        \\n        vector<int> answer;\\n        stack<pair<int,TreeNode *>> pending;\\n        TreeNode * curr = root, * prev = NULL;\\n        map<int,int> pos2val;\\n        int pos=0;\\n        while(!pending.empty() || curr){\\n            while(curr){\\n                pending.push(make_pair(pos--,exchange(curr,curr->left)));\\n            }\\n            int idx = pending.top().first;\\n            TreeNode * top = pending.top().second;\\n            if(!top->right || prev == top->right){\\n                pending.pop();\\n                prev = top;\\n                if(pos2val.find(idx)==pos2val.end()){\\n                    pos2val[idx] = top->val;  \\n                }\\n                \\n            }else{\\n                curr = top->right;\\n                pos = idx+1;\\n            }\\n        }\\n        for(auto i = pos2val.begin(); i!=pos2val.end();i++){\\n            answer.push_back(i->second);\\n        }\\n        return answer;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1636033,
                "title": "2-approaches-dfs-iterative-simple-easy-c",
                "content": "Implementation\\n\\n**BFS\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        if(!root) return res;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n         while(!q.empty()){            \\n            int size = q.size();\\n            res.push_back(q.front()->val);\\n            \\n            for(int itr = 0; itr < size; itr++){\\n                TreeNode* temp = q.front();\\n                q.pop();                \\n                                \\n                if(temp->right) q.push(temp->right);\\n                if(temp->left) q.push(temp->left);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**DFS\\nTime Complexity = O(N), Space Complexity = O(H), where H is the height of the binary tree**\\n```\\nclass Solution {\\npublic:\\n    void findRightSideView(TreeNode* root, vector<int> &res, int level){\\n        if(!root) return;\\n        if(level > res.size()) res.push_back(root->val);\\n        findRightSideView(root->right, res, level+1);\\n        findRightSideView(root->left, res, level+1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        findRightSideView(root, res, 1);\\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        if(!root) return res;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n         while(!q.empty()){            \\n            int size = q.size();\\n            res.push_back(q.front()->val);\\n            \\n            for(int itr = 0; itr < size; itr++){\\n                TreeNode* temp = q.front();\\n                q.pop();                \\n                                \\n                if(temp->right) q.push(temp->right);\\n                if(temp->left) q.push(temp->left);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void findRightSideView(TreeNode* root, vector<int> &res, int level){\\n        if(!root) return;\\n        if(level > res.size()) res.push_back(root->val);\\n        findRightSideView(root->right, res, level+1);\\n        findRightSideView(root->left, res, level+1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        findRightSideView(root, res, 1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588558,
                "title": "java-easy-solution-0ms-100-faster-recursion",
                "content": "**Code**\\n```java\\npublic List<Integer> rightSideView(TreeNode root) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\trightViewUtil(root, list, 0);\\n\\treturn list;\\n}\\n\\npublic void rightViewUtil(TreeNode root, List<Integer> list, int level) {\\n\\tif(root == null) return;\\n\\n\\tif(level == list.size()) {\\n\\t\\tlist.add(root.val);\\n\\t}\\n\\n\\trightViewUtil(root.right, list, level+1);\\n\\trightViewUtil(root.left, list, level+1);\\n}\\n```\\n\\n**Explanation**\\nThe point here is to move level wise to each node and add that if it is the first node from the right side which is what we want.\\n\\nHope it helps\\nDo upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```java\\npublic List<Integer> rightSideView(TreeNode root) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\trightViewUtil(root, list, 0);\\n\\treturn list;\\n}\\n\\npublic void rightViewUtil(TreeNode root, List<Integer> list, int level) {\\n\\tif(root == null) return;\\n\\n\\tif(level == list.size()) {\\n\\t\\tlist.add(root.val);\\n\\t}\\n\\n\\trightViewUtil(root.right, list, level+1);\\n\\trightViewUtil(root.left, list, level+1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582380,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        rightView(root, 0, list);\\n        return list;\\n    }\\n    private void rightView(TreeNode root, int depth, List<Integer> list){\\n        if(root == null)    return;\\n        if(depth == list.size())  list.add(root.val);\\n        rightView(root.right, depth+1, list);\\n        rightView(root.left, depth+1, list);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar rightSideView = function(root) {\\n    let list = []\\n    rightView(root, 0, list)\\n    return list\\n};\\n\\nfunction rightView(root, depth, list){\\n    if(!root)   return\\n    if(depth == list.length)    list.push(root.val)\\n    rightView(root.right, depth+1, list)\\n    rightView(root.left, depth+1, list)\\n}\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        lst = []\\n        self.rightView(root, 0, lst)\\n        return lst\\n    \\n    def rightView(self, root, depth, lst):\\n        if not root:\\n            return \\n        if depth == len(lst):\\n            lst.append(root.val)\\n        self.rightView(root.right, depth+1, lst)\\n        self.rightView(root.left, depth+1, lst)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        rightView(root, 0, list);\\n        return list;\\n    }\\n    private void rightView(TreeNode root, int depth, List<Integer> list){\\n        if(root == null)    return;\\n        if(depth == list.size())  list.add(root.val);\\n        rightView(root.right, depth+1, list);\\n        rightView(root.left, depth+1, list);\\n    }\\n}\\n```\n```\\nvar rightSideView = function(root) {\\n    let list = []\\n    rightView(root, 0, list)\\n    return list\\n};\\n\\nfunction rightView(root, depth, list){\\n    if(!root)   return\\n    if(depth == list.length)    list.push(root.val)\\n    rightView(root.right, depth+1, list)\\n    rightView(root.left, depth+1, list)\\n}\\n```\n```\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        lst = []\\n        self.rightView(root, 0, lst)\\n        return lst\\n    \\n    def rightView(self, root, depth, lst):\\n        if not root:\\n            return \\n        if depth == len(lst):\\n            lst.append(root.val)\\n        self.rightView(root.right, depth+1, lst)\\n        self.rightView(root.left, depth+1, lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085732,
                "title": "python-simple-solution-beats-99-submissions",
                "content": "Baiscally, the idea of finding the view from the right hand side is focusing on the right branch. \\nThe fastest solution can finish all work within one look on all nodes. How?\\n\\nThe right side view is looking at the rightest node, when there are several nodes of same height. Hence, the idea is find the right most node.\\nWe set a global variable h, to represent the deepest height we have achieved. When we update h, as long as we ensure that the node with height greater than h is the right most possible node, we append it to the answer list.\\n\\nThe right most property is guaranteed by always searching the right branch first. By doing so, for nodes of same height, we guaranteed the right most node to be the one update global h and be appended to the list.\\n\"\"\"\\nclass Solution(object):\\n\\n    def rightSideView(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = []\\n        self.h = -1\\n        def prog(root,height):\\n            if root is None:\\n                return\\n            if height > self.h:\\n                ans.append(root.val)\\n                self.h = height\\n            prog(root.right, height + 1)\\n            prog(root.left, height + 1)\\n        prog(root,0)\\n        return ans\\n\"\"\"",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Baiscally, the idea of finding the view from the right hand side is focusing on the right branch. \\nThe fastest solution can finish all work within one look on all nodes. How?\\n\\nThe right side view is looking at the rightest node, when there are several nodes of same height. Hence, the idea is find the right most node.\\nWe set a global variable h, to represent the deepest height we have achieved. When we update h, as long as we ensure that the node with height greater than h is the right most possible node, we append it to the answer list.\\n\\nThe right most property is guaranteed by always searching the right branch first. By doing so, for nodes of same height, we guaranteed the right most node to be the one update global h and be appended to the list.\\n\"\"\"\\nclass Solution(object):\\n\\n    def rightSideView(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = []\\n        self.h = -1\\n        def prog(root,height):\\n            if root is None:\\n                return\\n            if height > self.h:\\n                ans.append(root.val)\\n                self.h = height\\n            prog(root.right, height + 1)\\n            prog(root.left, height + 1)\\n        prog(root,0)\\n        return ans\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 1052359,
                "title": "python-level-traverse-using-bfs-w-comment",
                "content": "```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\'\\'\\'\\nw: level order traversal\\nh: traverse the tree level by level\\n    only record the last node of each level\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        res = []\\n        deque = collections.deque([root])\\n        \\n        while deque:\\n            size = len(deque)\\n            \\n            for i in range(size):\\n                node = deque.popleft()\\n                if i == size - 1:\\n                    res.append(node.val)\\n                \\n                if node.left:\\n                    deque.append(node.left)\\n                \\n                if node.right:\\n                    deque.append(node.right)\\n            \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\'\\'\\'\\nw: level order traversal\\nh: traverse the tree level by level\\n    only record the last node of each level\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        res = []\\n        deque = collections.deque([root])\\n        \\n        while deque:\\n            size = len(deque)\\n            \\n            for i in range(size):\\n                node = deque.popleft()\\n                if i == size - 1:\\n                    res.append(node.val)\\n                \\n                if node.left:\\n                    deque.append(node.left)\\n                \\n                if node.right:\\n                    deque.append(node.right)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773284,
                "title": "faster-than-90-c",
                "content": "\\n    class Solution {\\n    public:\\n        vector<int> rightSideView(TreeNode *root) {\\n           if(root==NULL)\\n              return {};\\n\\t       vector<int> v;\\n           queue<TreeNode*> q;\\n           q.push(root);\\n           TreeNode *temp;\\n           int len;\\n           while(!q.empty()){\\n              len=q.size();\\n              for(int i=0;i<len;i++){\\n                   temp=q.front();\\n                   q.pop();\\n                   if(i==len-1)\\n                        v.push_back(temp->val);\\n\\n                  if(temp->left) q.push(temp->left);\\n                  if(temp->right) q.push(temp->right);\\n               }\\n           }\\n         return v;\\n       }\\n    };\\n\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> rightSideView(TreeNode *root) {\\n           if(root==NULL)\\n              return {}",
                "codeTag": "Java"
            },
            {
                "id": 650387,
                "title": "javascript-bfs",
                "content": "\\tvar rightSideView = function(root) {\\n\\t\\tif(!root) return []\\n\\n\\t\\tlet queue = [[0,root]], levelObj={},result=[]\\n\\n\\n\\t\\twhile(queue.length>0){\\n\\t\\t\\tlet [level, current] = queue.shift()\\n\\t\\t\\tif(!levelObj[level]) levelObj[level]=[]\\n\\t\\t\\tlevelObj[level].push(current.val)\\n\\n\\t\\t\\tif(current.left) queue.push([level+1,current.left])\\n\\t\\t\\tif(current.right) queue.push([level+1,current.right])\\n\\n\\t\\t}\\n\\n\\t\\tfor(let key in levelObj){\\n\\t\\t\\t// push each level last value\\n\\t\\t\\tresult.push(levelObj[key][levelObj[key].length-1])\\n\\t\\t}\\n\\t\\treturn result\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "\\tvar rightSideView = function(root) {\\n\\t\\tif(!root) return []\\n\\n\\t\\tlet queue = [[0,root]], levelObj={},result=[]\\n\\n\\n\\t\\twhile(queue.length>0){\\n\\t\\t\\tlet [level, current] = queue.shift()\\n\\t\\t\\tif(!levelObj[level]) levelObj[level]=[]\\n\\t\\t\\tlevelObj[level].push(current.val)\\n\\n\\t\\t\\tif(current.left) queue.push([level+1,current.left])\\n\\t\\t\\tif(current.right) queue.push([level+1,current.right])\\n\\n\\t\\t}\\n\\n\\t\\tfor(let key in levelObj){\\n\\t\\t\\t// push each level last value\\n\\t\\t\\tresult.push(levelObj[key][levelObj[key].length-1])\\n\\t\\t}\\n\\t\\treturn result\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 497922,
                "title": "java-100-solution",
                "content": "```\\nclass Solution {\\n    List<Integer> res;\\n    public List<Integer> rightSideView(TreeNode root) {\\n        res = new ArrayList<>();\\n        helper(0,root);\\n        return res;\\n    }\\n    private void helper(int index , TreeNode cur){\\n        if(cur == null){\\n            return;\\n        }\\n        if(index == res.size()){\\n            res.add(cur.val);\\n        }\\n        helper(index+1,cur.right);\\n        helper(index+1,cur.left);\\n    }     \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer> res;\\n    public List<Integer> rightSideView(TreeNode root) {\\n        res = new ArrayList<>();\\n        helper(0,root);\\n        return res;\\n    }\\n    private void helper(int index , TreeNode cur){\\n        if(cur == null){\\n            return;\\n        }\\n        if(index == res.size()){\\n            res.add(cur.val);\\n        }\\n        helper(index+1,cur.right);\\n        helper(index+1,cur.left);\\n    }     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363020,
                "title": "simple-c-solution",
                "content": "My simple C# solution \\n     \\n  ```\\nvoid helper(TreeNode root,IList<int> lst,int level)\\n        {\\n            if (root == null) return;\\n            if(level>lst.Count)\\n            {\\n                lst.Add(root.val);\\n            }\\n            helper(root.right, lst, level + 1);\\n            helper(root.left, lst, level + 1);\\n        }\\n        public IList<int> RightSideView(TreeNode root)\\n        {\\n            IList<int> list = new List<int>();\\n            helper(root, list, 1);\\n            return list;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid helper(TreeNode root,IList<int> lst,int level)\\n        {\\n            if (root == null) return;\\n            if(level>lst.Count)\\n            {\\n                lst.Add(root.val);\\n            }\\n            helper(root.right, lst, level + 1);\\n            helper(root.left, lst, level + 1);\\n        }\\n        public IList<int> RightSideView(TreeNode root)\\n        {\\n            IList<int> list = new List<int>();\\n            helper(root, list, 1);\\n            return list;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 335805,
                "title": "rust-solution",
                "content": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    fn traversal(node: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>, level: usize) {\\n        if let Some(node) = node {\\n            if level == res.len() {\\n                res.push(node.borrow().val);\\n            }\\n            Self::traversal(node.borrow().right.clone(), res, level+1);\\n            Self::traversal(node.borrow().left.clone(), res, level+1);            \\n        }\\n\\n    }\\n    \\n    pub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut res: Vec<i32> = vec![];\\n        Self::traversal(root, &mut res, 0);\\n        res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    fn traversal(node: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>, level: usize) {\\n        if let Some(node) = node {\\n            if level == res.len() {\\n                res.push(node.borrow().val);\\n            }\\n            Self::traversal(node.borrow().right.clone(), res, level+1);\\n            Self::traversal(node.borrow().left.clone(), res, level+1);            \\n        }\\n\\n    }\\n    \\n    pub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut res: Vec<i32> = vec![];\\n        Self::traversal(root, &mut res, 0);\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 319566,
                "title": "java-2-approaches",
                "content": "Iterative:\\n\\n```\\npublic List<Integer> rightSideView(TreeNode root) {\\n      List<Integer> res = new ArrayList<>();\\n      if (root == null) {\\n          return res;\\n      }\\n      LinkedList<TreeNode> list = new LinkedList<>();\\n      list.add(root);\\n      while(!list.isEmpty()) {\\n         int n = list.size();\\n         for (int i = 0; i < n; i++) {\\n            TreeNode node = list.remove();\\n            if (i + 1 == n) {\\n               res.add(node.val);\\n            }\\n            if (node.left != null) {\\n               list.add(node.left);\\n            }\\n            if (node.right != null) {\\n               list.add(node.right);\\n            }\\n         }\\n      }\\n      return res;\\n   }\\n```\\n\\nRecursive:\\n\\n```\\nList<Integer> righSideViewResult = new ArrayList<>();\\n   void rightViewUtil(TreeNode node, int level, int[] maxLevel) {\\n      if (node == null)\\n         return;\\n      if (maxLevel[0] < level) {\\n         righSideViewResult.add(node.val);\\n         maxLevel[0] = level;\\n      }\\n      rightViewUtil(node.right, level + 1, maxLevel);\\n      rightViewUtil(node.left, level + 1, maxLevel);\\n   }\\n\\n   public List<Integer> rightSideView(TreeNode node) {\\n      rightViewUtil(node, 1, new int[] {0});\\n      return righSideViewResult;\\n   }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> rightSideView(TreeNode root) {\\n      List<Integer> res = new ArrayList<>();\\n      if (root == null) {\\n          return res;\\n      }\\n      LinkedList<TreeNode> list = new LinkedList<>();\\n      list.add(root);\\n      while(!list.isEmpty()) {\\n         int n = list.size();\\n         for (int i = 0; i < n; i++) {\\n            TreeNode node = list.remove();\\n            if (i + 1 == n) {\\n               res.add(node.val);\\n            }\\n            if (node.left != null) {\\n               list.add(node.left);\\n            }\\n            if (node.right != null) {\\n               list.add(node.right);\\n            }\\n         }\\n      }\\n      return res;\\n   }\\n```\n```\\nList<Integer> righSideViewResult = new ArrayList<>();\\n   void rightViewUtil(TreeNode node, int level, int[] maxLevel) {\\n      if (node == null)\\n         return;\\n      if (maxLevel[0] < level) {\\n         righSideViewResult.add(node.val);\\n         maxLevel[0] = level;\\n      }\\n      rightViewUtil(node.right, level + 1, maxLevel);\\n      rightViewUtil(node.left, level + 1, maxLevel);\\n   }\\n\\n   public List<Integer> rightSideView(TreeNode node) {\\n      rightViewUtil(node, 1, new int[] {0});\\n      return righSideViewResult;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287507,
                "title": "swift-bfs",
                "content": "```\\nclass Solution {\\n    func rightSideView(_ root: TreeNode?) -> [Int] {\\n        guard let root = root else { return [] }\\n        var queue = [root]\\n        var ans = [root.val]\\n        while !queue.isEmpty {\\n            let count = queue.count\\n            var added = false\\n            for i in 0..<count {\\n                let curr = queue.removeFirst()\\n                if let val = (curr.right?.val ?? curr.left?.val), !added {\\n                    ans.append(val)\\n                    added = true\\n                }\\n                if let right = curr.right {\\n                    queue.append(right)\\n                }\\n                if let left = curr.left {\\n                    queue.append(left)\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func rightSideView(_ root: TreeNode?) -> [Int] {\\n        guard let root = root else { return [] }\\n        var queue = [root]\\n        var ans = [root.val]\\n        while !queue.isEmpty {\\n            let count = queue.count\\n            var added = false\\n            for i in 0..<count {\\n                let curr = queue.removeFirst()\\n                if let val = (curr.right?.val ?? curr.left?.val), !added {\\n                    ans.append(val)\\n                    added = true\\n                }\\n                if let right = curr.right {\\n                    queue.append(right)\\n                }\\n                if let left = curr.left {\\n                    queue.append(left)\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246638,
                "title": "javascript-dfs-5-lines",
                "content": "```\\nvar rightSideView = function(root, depth = 0, result = []) {\\n    if(root == null) return result\\n    result[depth] = root.val\\n    rightSideView(root.left, depth+1, result)\\n    rightSideView(root.right, depth+1, result)\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rightSideView = function(root, depth = 0, result = []) {\\n    if(root == null) return result\\n    result[depth] = root.val\\n    rightSideView(root.left, depth+1, result)\\n    rightSideView(root.right, depth+1, result)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 221004,
                "title": "swift-12ms",
                "content": "```\\nfunc rightSideView(_ root: TreeNode?) -> [Int] {\\n        guard let node = root else { return [] }\\n        var queue: [TreeNode] = []\\n        queue.append(node)\\n        var result: [Int] = []\\n        \\n        while !queue.isEmpty {\\n            \\n            var count = queue.count - 1\\n            \\n            while count >= 0 {\\n                let node = queue.removeFirst()\\n                if count == 0 { result.append(node.val) }\\n                if let leftChild = node.left { queue.append(leftChild) }\\n                if let rightChild = node.right  { queue.append(rightChild) }\\n                count -= 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc rightSideView(_ root: TreeNode?) -> [Int] {\\n        guard let node = root else { return [] }\\n        var queue: [TreeNode] = []\\n        queue.append(node)\\n        var result: [Int] = []\\n        \\n        while !queue.isEmpty {\\n            \\n            var count = queue.count - 1\\n            \\n            while count >= 0 {\\n                let node = queue.removeFirst()\\n                if count == 0 { result.append(node.val) }\\n                if let leftChild = node.left { queue.append(leftChild) }\\n                if let rightChild = node.right  { queue.append(rightChild) }\\n                count -= 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207417,
                "title": "javascript",
                "content": "```\\nvar rightSideView = function(root) {\\n    let result = []\\n    dfs(root, 0)\\n    \\n    function dfs(root, level) {\\n        if(!root)\\n            return\\n        if(!result[level])\\n            result.push(root.val)\\n        dfs(root.right, level + 1)\\n        dfs(root.left, level + 1)\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rightSideView = function(root) {\\n    let result = []\\n    dfs(root, 0)\\n    \\n    function dfs(root, level) {\\n        if(!root)\\n            return\\n        if(!result[level])\\n            result.push(root.val)\\n        dfs(root.right, level + 1)\\n        dfs(root.left, level + 1)\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56188,
                "title": "sharing-my-c-solution-iterative-bfs-using-a-queue-documented-code",
                "content": "    vector<int> rightSideView(TreeNode* root) \\n    {\\n        vector<int> ret;        // This is the vector we will return\\n        queue<TreeNode*> q;     // This is how we will track levels\\n        \\n        if(!root)               // If we have no root, we see nothing\\n            return ret;\\n            \\n        q.push(root);           // Push root node onto the queue\\n        \\n        while(!q.empty())       // Loop until we're out of nodes\\n        {\\n            ret.push_back(q.front()->val);  // Ever time we reach this line, we will be on the right most node\\n            \\n            int count = q.size();           // This is to make sure that we break at every level\\n            \\n            while(count > 0)                // While node at a given level are in the queue\\n            {\\n                if(q.front()->right)            // Enqueue their children right to left\\n                    q.push(q.front()->right);\\n                if(q.front()->left)\\n                    q.push(q.front()->left);\\n                    \\n                q.pop();                        // Pop the node who's children you enqueued off\\n                \\n                count--;                        // decrese the level count\\n            }\\n            \\n            // Because we enqueued right to left, the right most node will be at the front\\n            // of the queue, so when we reset to the top of the while loop, we record it\\n        }\\n        \\n        return ret;\\n    }",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "    vector<int> rightSideView(TreeNode* root) \\n    {\\n        vector<int> ret;        // This is the vector we will return\\n        queue<TreeNode*> q;     // This is how we will track levels\\n        \\n        if(!root)               // If we have no root, we see nothing\\n            return ret;\\n            \\n        q.push(root);           // Push root node onto the queue\\n        \\n        while(!q.empty())       // Loop until we're out of nodes\\n        {\\n            ret.push_back(q.front()->val);  // Ever time we reach this line, we will be on the right most node\\n            \\n            int count = q.size();           // This is to make sure that we break at every level\\n            \\n            while(count > 0)                // While node at a given level are in the queue\\n            {\\n                if(q.front()->right)            // Enqueue their children right to left\\n                    q.push(q.front()->right);\\n                if(q.front()->left)\\n                    q.push(q.front()->left);\\n                    \\n                q.pop();                        // Pop the node who's children you enqueued off\\n                \\n                count--;                        // decrese the level count\\n            }\\n            \\n            // Because we enqueued right to left, the right most node will be at the front\\n            // of the queue, so when we reset to the top of the while loop, we record it\\n        }\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56202,
                "title": "my-2ms-level-order-easy-to-uderstand",
                "content": "Using level Order Travaling:Travel each level ,find the last TreeNode of the level and add its val into our result .\\n\\u5199\\u82f1\\u8bed\\u53ea\\u80fd\\u8d39\\u52b2\\u554a\\uff0c\\u4e2d\\u6587\\u5427\\uff0c\\u5c42\\u5e8f\\u904d\\u5386\\uff0c\\u627e\\u5230\\u6bcf\\u5c42\\u91cc\\u9762\\u6700\\u540e\\u90a3\\u4e2a\\u8282\\u70b9\\uff0c\\u52a0\\u5230\\u7ed3\\u679c\\u96c6\\u5408\\u91cc\\uff0c\\u8017\\u65f6\\u4e24\\u6beb\\u79d2\\uff0c\\u7ed9\\u522b\\u4eba\\u4e00\\u4e2a\\u53c2\\u8003\\u5427\\u3002\\n\\n  public class Solution {\\n\\n      public List<Integer> rightSideView(TreeNode root) {\\n          List<Integer> res=new ArrayList<Integer>();\\n          if(root==null) return res;\\n          Queue<TreeNode> queue=new LinkedList<TreeNode>();\\n          queue.add(root);\\n          while(queue.size()!=0){\\n            int level=queue.size();\\n            for(int i=1;i<=level;i++){\\n               TreeNode temp=queue.poll();\\n               if(level==i) res.add(temp.val);\\n               if(temp.left!=null) queue.add(temp.left);\\n               if(temp.right!=null) queue.add(temp.right);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n      public List<Integer> rightSideView(TreeNode root) {\\n          List<Integer> res=new ArrayList<Integer>();\\n          if(root==null) return res;\\n          Queue<TreeNode> queue=new LinkedList<TreeNode>();\\n          queue.add(root);\\n          while(queue.size()!=0){\\n            int level=queue.size();\\n            for(int i=1;i<=level;i++){\\n               TreeNode temp=queue.poll();\\n               if(level==i) res.add(temp.val);\\n               if(temp.left!=null) queue.add(temp.left);\\n               if(temp.right!=null) queue.add(temp.right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 56302,
                "title": "java-solution-using-depth-first-search",
                "content": "If we visit right child first, then we just need to add the node to result if we visit a new level. The code is quite simple\\n\\n    public class Solution {\\n        private List<Integer> r = new ArrayList<>();\\n        private int cur = 0;\\n        public List<Integer> rightSideView(TreeNode root) {\\n            gen(root,1,r);\\n            return r;\\n        }\\n        \\n        public void gen(TreeNode root, int level, List<Integer> r){\\n            if(root == null){\\n                return;\\n            }\\n            if(level>cur){\\n                r.add(root.val);\\n                cur = level;\\n            }\\n            gen(root.right,level+1,r);\\n            gen(root.left,level+1,r);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        private List<Integer> r = new ArrayList<>();\\n        private int cur = 0;\\n        public List<Integer> rightSideView(TreeNode root) {\\n            gen(root,1,r);\\n            return r;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3700974,
                "title": "easy-to-understand-c-solution-using-bfs",
                "content": "Please upvote if you liked it!\\n\\n```\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root){return ans;}\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s = q.size();\\n            TreeNode * elem = q.front();\\n            q.pop();\\n            ans.push_back(elem->val);\\n            if(elem->right){q.push(elem->right);}\\n            if(elem->left){q.push(elem->left);}\\n            for(int i = 1;i<s;++i){\\n                TreeNode * temp = q.front();\\n                q.pop();      \\n            if(temp->right){q.push(temp->right);}\\n            if(temp->left){q.push(temp->left);}\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "Please upvote if you liked it!\\n\\n```\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root){return ans;}\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s = q.size();\\n            TreeNode * elem = q.front();\\n            q.pop();\\n            ans.push_back(elem->val);\\n            if(elem->right){q.push(elem->right);}\\n            if(elem->left){q.push(elem->left);}\\n            for(int i = 1;i<s;++i){\\n                TreeNode * temp = q.front();\\n                q.pop();      \\n            if(temp->right){q.push(temp->right);}\\n            if(temp->left){q.push(temp->left);}\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3545612,
                "title": "day-415-dfs-bfs-0ms-100-python-java-c-explained",
                "content": "\\n\\n\\n# Code for recursive\\n```java []\\npublic List<Integer> rightSideView(TreeNode root) {\\n    List<Integer> A = new ArrayList<>();\\n    rec(root,0,A);\\n    return A;        \\n}\\nvoid rec(TreeNode root,int level,List<Integer> A){\\n    if(root==null) return;\\n    if(level==A.size()) A.add(root.val);//every first node in that level is part of right side \\n    rec(root.right,level+1,A);\\n    rec(root.left,level+1,A);//level order from right side view\\n}\\n```\\n\\n# code for iterative \\n\\n```java []\\npublic List<Integer> rightSideView(TreeNode root) {\\n    List<Integer> A = new ArrayList<>();\\n    if(root==null) return  A;\\n    Queue<TreeNode> q  = new LinkedList<>();\\n    q.add(root);\\n    while(!q.isEmpty()){\\n        int size = q.size();\\n        for(int i=0;i<size;i++){\\n            TreeNode node = q.poll();\\n            if(i==size-1)A.add(node.val);//every last node in that level is part of right side \\n            if(node.left!=null) q.add(node.left);\\n            if(node.right!=null)q.add(node.right);\\n        }\\n    }\\nreturn A;\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(h)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Tree"
                ],
                "code": "```java []\\npublic List<Integer> rightSideView(TreeNode root) {\\n    List<Integer> A = new ArrayList<>();\\n    rec(root,0,A);\\n    return A;        \\n}\\nvoid rec(TreeNode root,int level,List<Integer> A){\\n    if(root==null) return;\\n    if(level==A.size()) A.add(root.val);//every first node in that level is part of right side \\n    rec(root.right,level+1,A);\\n    rec(root.left,level+1,A);//level order from right side view\\n}\\n```\n```java []\\npublic List<Integer> rightSideView(TreeNode root) {\\n    List<Integer> A = new ArrayList<>();\\n    if(root==null) return  A;\\n    Queue<TreeNode> q  = new LinkedList<>();\\n    q.add(root);\\n    while(!q.isEmpty()){\\n        int size = q.size();\\n        for(int i=0;i<size;i++){\\n            TreeNode node = q.poll();\\n            if(i==size-1)A.add(node.val);//every last node in that level is part of right side \\n            if(node.left!=null) q.add(node.left);\\n            if(node.right!=null)q.add(node.right);\\n        }\\n    }\\nreturn A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522883,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    IList<int> ans = new List<int>();\\n    public IList<int> RightSideView(TreeNode root) {\\n        Helper(root, 0);\\n        return ans;\\n    }\\n\\n    void Helper(TreeNode root, int level)\\n    {\\n        if(root == null)\\n        {\\n            return;\\n        }\\n\\n        if(ans.Count == level)\\n        {\\n            ans.Add(root.val);\\n        }\\n\\n        Helper(root.right, level+1);\\n        Helper(root.left, level+1);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    IList<int> ans = new List<int>();\\n    public IList<int> RightSideView(TreeNode root) {\\n        Helper(root, 0);\\n        return ans;\\n    }\\n\\n    void Helper(TreeNode root, int level)\\n    {\\n        if(root == null)\\n        {\\n            return;\\n        }\\n\\n        if(ans.Count == level)\\n        {\\n            ans.Add(root.val);\\n        }\\n\\n        Helper(root.right, level+1);\\n        Helper(root.left, level+1);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467506,
                "title": "python-simple-clean-solution-using-bfs",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return root\\n        q = [root]\\n        ans = []\\n        while q:\\n            t = q.copy()\\n            q.clear()\\n\\n            r = 0\\n            for node in t:\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n                r = node.val\\n            ans.append(r)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return root\\n        q = [root]\\n        ans = []\\n        while q:\\n            t = q.copy()\\n            q.clear()\\n\\n            r = 0\\n            for node in t:\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n                r = node.val\\n            ans.append(r)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294502,
                "title": "easy-solution-o-n-space-and-time-complexity",
                "content": "> # Approach\\nLet\\'s traverse the given tree in level order and all right most node of every level will be visible if we see the tree in right view so add all right most node value into output list which is returned as right view.\\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        if(root==null) return new LinkedList<>();\\n        LinkedList<List<Integer>> lists = new LinkedList<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        TreeNode curr = root;\\n        queue.add(root);\\n        while(queue.size()>0){\\n            int size = queue.size();\\n            LinkedList<Integer> list = new LinkedList<>();\\n            while(size>0){\\n                curr=queue.poll();\\n                list.add(curr.val);\\n                if(curr.left!=null) queue.add(curr.left);\\n                if(curr.right!=null) queue.add(curr.right);\\n                size--;\\n            }\\n            lists.add(list);\\n        }\\n        LinkedList<Integer> res = new LinkedList<>();\\n        for(int i=0;i<lists.size();i++){\\n            res.add(lists.get(i).get(lists.get(i).size()-1));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        if(root==null) return new LinkedList<>();\\n        LinkedList<List<Integer>> lists = new LinkedList<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        TreeNode curr = root;\\n        queue.add(root);\\n        while(queue.size()>0){\\n            int size = queue.size();\\n            LinkedList<Integer> list = new LinkedList<>();\\n            while(size>0){\\n                curr=queue.poll();\\n                list.add(curr.val);\\n                if(curr.left!=null) queue.add(curr.left);\\n                if(curr.right!=null) queue.add(curr.right);\\n                size--;\\n            }\\n            lists.add(list);\\n        }\\n        LinkedList<Integer> res = new LinkedList<>();\\n        for(int i=0;i<lists.size();i++){\\n            res.add(lists.get(i).get(lists.get(i).size()-1));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277600,
                "title": "left-and-right-side-view-of-a-binary-trees-iterative-and-recursive-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor right side view just view the tree along the right boundary and it will be 1,3,7,6 and for left side it will be 1,2,4,6\\n![WhatsApp Image 2023-03-09 at 23.54.22.jpg](https://assets.leetcode.com/users/images/8d614aa7-0157-435a-81c1-d87d402a1874_1678386299.3958485.jpeg)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1,3,7,6 are the last nodes of the level so we can simply calculate the level order traversal or any recursive traversal and can find the views. Also, 1,2,4,6 are first nodes of the levels so it can be found using the traversals\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nright side view of binary tree using recursive traversals\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root ,int level , vector<int> & ans){\\n        if(root==NULL) return;\\n        if(ans.size() == level) ans.push_back(root->val);\\n        dfs(root -> right ,  level + 1 , ans);\\n        dfs(root-> left ,  level + 1 , ans) ;\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        dfs(root , 0 , ans);\\n        return ans;\\n    }\\n\\n};\\nleft side view of binary tree using recursive traversal\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root ,int level , vector<int> & ans){\\n        if(root==NULL) return;\\n        if(ans.size() == level) ans.push_back(root->val);\\n        dfs(root -> left ,  level + 1 , ans);\\n        dfs(root-> right,  level + 1 , ans) ;\\n    }\\n    vector<int> leftSideView(TreeNode* root) {\\n        vector<int> ans;\\n        dfs(root , 0 , ans);\\n        return ans;\\n    }\\n};\\nRight side view of binary tree iterative solution\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n       vector<int> result;\\n       queue<TreeNode* > q;\\n       q.push(root);\\n       if(root == NULL) return {};\\n       while( !q.empty() ) {\\n           int n = q.size();\\n           while(n--) {\\n               root = q.front();\\n               q.pop();\\n               \\n               if(root->left)\\n                    q.push(root->left);\\n                if(root->right)\\n                    q.push(root->right);\\n           }\\n           result.emplace_back(root->val);\\n       }\\n       return result;\\n    }\\n};\\nBinary tree left side view using iterative traversal \\n \\n    vector<int> leftSideView(TreeNode* root) {\\n       vector<int> result;\\n       queue<TreeNode* > q;\\n       q.push(root);\\n       if(root == NULL) return {};\\n       while( !q.empty() ) {\\n           int n = q.size();\\n           while(n--) {\\n               root = q.front();\\n               q.pop();\\n               \\n               if(root->right)\\n                    q.push(root->right);\\n                if(root->left)\\n                    q.push(root->left);\\n           }\\n           result.emplace_back(root->val);\\n       }\\n       return result;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nright side view of binary tree using recursive traversals\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root ,int level , vector<int> & ans){\\n        if(root==NULL) return;\\n        if(ans.size() == level) ans.push_back(root->val);\\n        dfs(root -> right ,  level + 1 , ans);\\n        dfs(root-> left ,  level + 1 , ans) ;\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        dfs(root , 0 , ans);\\n        return ans;\\n    }\\n\\n};\\nleft side view of binary tree using recursive traversal\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root ,int level , vector<int> & ans){\\n        if(root==NULL) return;\\n        if(ans.size() == level) ans.push_back(root->val);\\n        dfs(root -> left ,  level + 1 , ans);\\n        dfs(root-> right,  level + 1 , ans) ;\\n    }\\n    vector<int> leftSideView(TreeNode* root) {\\n        vector<int> ans;\\n        dfs(root , 0 , ans);\\n        return ans;\\n    }\\n};\\nRight side view of binary tree iterative solution\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n       vector<int> result;\\n       queue<TreeNode* > q;\\n       q.push(root);\\n       if(root == NULL) return {};\\n       while( !q.empty() ) {\\n           int n = q.size();\\n           while(n--) {\\n               root = q.front();\\n               q.pop();\\n               \\n               if(root->left)\\n                    q.push(root->left);\\n                if(root->right)\\n                    q.push(root->right);\\n           }\\n           result.emplace_back(root->val);\\n       }\\n       return result;\\n    }\\n};\\nBinary tree left side view using iterative traversal \\n \\n    vector<int> leftSideView(TreeNode* root) {\\n       vector<int> result;\\n       queue<TreeNode* > q;\\n       q.push(root);\\n       if(root == NULL) return {};\\n       while( !q.empty() ) {\\n           int n = q.size();\\n           while(n--) {\\n               root = q.front();\\n               q.pop();\\n               \\n               if(root->right)\\n                    q.push(root->right);\\n                if(root->left)\\n                    q.push(root->left);\\n           }\\n           result.emplace_back(root->val);\\n       }\\n       return result;\\n    }\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145406,
                "title": "c-bfs",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Breadth-First Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> vec;\\n        if(!root) return vec;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.size()) {\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                root = q.front();\\n                q.pop();\\n                if(i == size - 1) vec.push_back(root -> val);\\n                if(root -> left) q.push(root -> left);\\n                if(root -> right) q.push(root -> right);\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> vec;\\n        if(!root) return vec;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.size()) {\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                root = q.front();\\n                q.pop();\\n                if(i == size - 1) vec.push_back(root -> val);\\n                if(root -> left) q.push(root -> left);\\n                if(root -> right) q.push(root -> right);\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117601,
                "title": "5-line-code-c-easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root, int level, vector<int> &ans){\\n        // Base Case\\n        if(root == NULL) return;\\n        if(level == ans.size()) ans.push_back(root -> val);\\n        solve(root->right,level+1,ans);\\n        solve(root->left,level+1,ans);\\n\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root, int level, vector<int> &ans){\\n        // Base Case\\n        if(root == NULL) return;\\n        if(level == ans.size()) ans.push_back(root -> val);\\n        solve(root->right,level+1,ans);\\n        solve(root->left,level+1,ans);\\n\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058417,
                "title": "100-beat-0ms-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int l=0;\\nvoid tra(TreeNode *root,vector<int>&ans,int k){\\n    if(root==0){\\n        return;\\n    }\\n    k++;\\n    if(l<k){\\n        ans.push_back(root->val);\\n        l=max(l,k);\\n    }\\n    tra(root->right,ans,k);\\n    tra(root->left,ans,k);\\n}\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n   int k=0;\\n   tra(root,ans,k);\\n   return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int l=0;\\nvoid tra(TreeNode *root,vector<int>&ans,int k){\\n    if(root==0){\\n        return;\\n    }\\n    k++;\\n    if(l<k){\\n        ans.push_back(root->val);\\n        l=max(l,k);\\n    }\\n    tra(root->right,ans,k);\\n    tra(root->left,ans,k);\\n}\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n   int k=0;\\n   tra(root,ans,k);\\n   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940688,
                "title": "c-bfs-level-wise-dfs",
                "content": "**If Helpful Please Like Or Upvoke**\\n```\\nclass Solution {\\npublic:\\n          \\n    vector<int> rightSideView(TreeNode* root) {\\n         vector<int>v;\\n        if(!root) return v;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n       \\n        while(!q.empty()){\\n            int n=q.size();\\n          for(int i=0; i<n; i++){\\n              TreeNode* node =q.front();q.pop();\\n              if(i==n-1)v.push_back(node->val);\\n              if(node->left)q.push(node->left);\\n              if(node->right)q.push(node->right);\\n          }\\n        \\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n**DFS**\\n```\\nclass Solution {\\npublic:\\n          void f(TreeNode* root, int level, vector<int>&v ){\\n             if(root==NULL) return ;\\n              if(v.size()==level){\\n                  v.push_back(root->val);\\n              }\\n              f(root->right, level+1, v);\\n              f(root->left, level+1, v);\\n         }\\n    vector<int> rightSideView(TreeNode* root) {\\n           vector<int>v;\\n           f( root, 0, v);\\n        return v; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n          \\n    vector<int> rightSideView(TreeNode* root) {\\n         vector<int>v;\\n        if(!root) return v;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n       \\n        while(!q.empty()){\\n            int n=q.size();\\n          for(int i=0; i<n; i++){\\n              TreeNode* node =q.front();q.pop();\\n              if(i==n-1)v.push_back(node->val);\\n              if(node->left)q.push(node->left);\\n              if(node->right)q.push(node->right);\\n          }\\n        \\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n          void f(TreeNode* root, int level, vector<int>&v ){\\n             if(root==NULL) return ;\\n              if(v.size()==level){\\n                  v.push_back(root->val);\\n              }\\n              f(root->right, level+1, v);\\n              f(root->left, level+1, v);\\n         }\\n    vector<int> rightSideView(TreeNode* root) {\\n           vector<int>v;\\n           f( root, 0, v);\\n        return v; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935779,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int>& ans, int h)\\n    {\\n        if(!root)\\n            return;\\n        if(h==ans.size())\\n        ans.push_back(root->val);\\n        f(root->right,ans,h+1);\\n        f(root->left,ans,h+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int>& ans, int h)\\n    {\\n        if(!root)\\n            return;\\n        if(h==ans.size())\\n        ans.push_back(root->val);\\n        f(root->right,ans,h+1);\\n        f(root->left,ans,h+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751650,
                "title": "easy-c-solution-level-order-traversal",
                "content": "Here is my C++ Solution using Level Order Traversal:- \\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if (root==NULL)return ans;\\n        // har level ke end ka element:\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (!q.empty()){\\n            int size= q.size();\\n            int ele;\\n            for (int i=0; i<size; i++){\\n                ele= q.front()->val;  \\n                if (q.front()->left)q.push(q.front()->left);\\n                if (q.front()->right)q.push(q.front()->right);\\n                q.pop();\\n            }\\n            ans.push_back(ele);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if (root==NULL)return ans;\\n        // har level ke end ka element:\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (!q.empty()){\\n            int size= q.size();\\n            int ele;\\n            for (int i=0; i<size; i++){\\n                ele= q.front()->val;  \\n                if (q.front()->left)q.push(q.front()->left);\\n                if (q.front()->right)q.push(q.front()->right);\\n                q.pop();\\n            }\\n            ans.push_back(ele);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622581,
                "title": "accepted-dfs-and-bfs-approaches-with-good-explanations-easy-to-understand",
                "content": "**Read the below both approaches to understand the logic.**\\n\\n***Please upvote if you like it!!***\\n\\n**Approach 1 : (BFS using queue)**\\n\\n1. Take a queue data structure and push root into it.\\n2. Take a loop iterate until queue became empty.\\n\\t* At each iteration take sz as current size of queue and declare temp as node variable\\n\\t\\t* Take a another loop inside previous loop iterate it until sz became zero.\\n\\t\\t* Set temp as front node of queue and pop front value of queue.\\n\\t\\t* push left and right node of temp node if not NULL.\\n\\t* push last temp node value into our ans vector.\\n3. At the end return ans node. \\n\\n**C++ Code:-**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int sz=q.size();\\n            TreeNode* temp;\\n            while(sz--){\\n                temp=q.front();\\n                q.pop();\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            ans.push_back(temp->val);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2: (DFS)**\\nApproach: \\n\\n1. Create an vector data structure inside both the left and the right side view function\\n2. Call for the recursive _left and recursive_right function respectively with the (root,level,vector). Here level will be initially passed as 0.\\n3. Return the vector.\\n4. Now in the recursive_left function\\n\\t* If vector size is equal to the level then push_back its node value to the vector data structure.\\n\\t* Otherwise call recursive_left for (node->left,level+1,vector)\\n\\t* Call recursive_left for (node->right,level+1,vector)\\n5. Now in the recursive_right function\\n\\t* If vector size is equal to the level then push_back its node value to the vector data structure.\\n\\t* Otherwise call recursive_right for (node->right,level+1,vector)\\n\\t* Call recursive_right for (node->left,level+1,vector)\\n\\n***Tip:*** The Code for the Left and the Right View is almost identical. \\n\\nIn the Right view code first, you have to call the recursive function for the right then the left node\\n**AND**\\nIn the Right view code first, you have to call the recursive function for the Left than the right node\\n\\n**~Time Complexity: O(N)**\\n**~Space Complexity: O(H) (H -> Height of the Tree)**\\n\\n**Paper dry run:**\\n\\n![image](https://assets.leetcode.com/users/images/8b1f0561-a363-4cdc-bee4-d01d91ed2b1f_1664104871.5050604.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,vector<int>& ans,int len){\\n        if(!root) return;\\n        if(ans.size()==len){\\n            ans.push_back(root->val);\\n        }\\n        solve(root->right,ans,len+1);\\n        solve(root->left,ans,len+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root,ans,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int sz=q.size();\\n            TreeNode* temp;\\n            while(sz--){\\n                temp=q.front();\\n                q.pop();\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            ans.push_back(temp->val);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,vector<int>& ans,int len){\\n        if(!root) return;\\n        if(ans.size()==len){\\n            ans.push_back(root->val);\\n        }\\n        solve(root->right,ans,len+1);\\n        solve(root->left,ans,len+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root,ans,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608331,
                "title": "199-binary-tree-right-side-view",
                "content": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> ans=new ArrayList<>();\\n        getAns(ans,root,0);\\n            return ans;\\n    }\\n    public void getAns(List<Integer> ans,TreeNode root, int level)\\n    {\\n        if(root==null) // base case\\n            return ;\\n        if(level==ans.size())\\n            ans.add(root.val);\\n        // just observe how smartly we have used the rec \\n        // even on the left the level is +1 that\\'s how it working\\n          getAns(ans,root.right,level+1);\\n          getAns(ans,root.left,level+1);\\n    }\\n}\\n// if you find my simple sol helpful pls upvote :)",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> ans=new ArrayList<>();\\n        getAns(ans,root,0);\\n            return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2602767,
                "title": "c-simple-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i=0;i<n;i++){\\n                TreeNode* temp = q.front();\\n                if(i==n-1){\\n                    ans.push_back(temp->val);\\n                }\\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n                q.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i=0;i<n;i++){\\n                TreeNode* temp = q.front();\\n                if(i==n-1){\\n                    ans.push_back(temp->val);\\n                }\\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n                q.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597266,
                "title": "my-java-solution-1ms-using-queue-using-recursion-4-lines",
                "content": "by using queue :\\n```\\npublic List<Integer> rightSideView(TreeNode root) {        \\n        List<Integer> res= new ArrayList<Integer>();\\n        if(root == null){\\n            return res;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        TreeNode last = root;\\n        res.add(root.val);\\n        queue.add(null);\\n        while(!queue.isEmpty()){\\n            TreeNode curr = queue.poll();\\n            if(curr == null){\\n                if(queue.isEmpty()){\\n                    break;\\n                }\\n                res.add(last.val);\\n                queue.add(null);\\n            }\\n            else{\\n                if(curr.left != null){\\n                    queue.add(curr.left);\\n                    last = curr.left;\\n                }\\n                if(curr.right != null){\\n                    queue.add(curr.right);\\n                    last = curr.right;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n```\\nusing recursion :\\n```\\n public void helper(TreeNode root,List<Integer> res , int currLevel){\\n        if(root == null) return;\\n        if(res.size() == currLevel) res.add(root.val);\\n        helper(root.right , res,currLevel + 1);\\n        helper(root.left , res,currLevel + 1);\\n    }\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        helper(root , res , 0);\\n        return res;\\n    }\\n```\\n**If this helps you , then Upvote.**",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> rightSideView(TreeNode root) {        \\n        List<Integer> res= new ArrayList<Integer>();\\n        if(root == null){\\n            return res;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        TreeNode last = root;\\n        res.add(root.val);\\n        queue.add(null);\\n        while(!queue.isEmpty()){\\n            TreeNode curr = queue.poll();\\n            if(curr == null){\\n                if(queue.isEmpty()){\\n                    break;\\n                }\\n                res.add(last.val);\\n                queue.add(null);\\n            }\\n            else{\\n                if(curr.left != null){\\n                    queue.add(curr.left);\\n                    last = curr.left;\\n                }\\n                if(curr.right != null){\\n                    queue.add(curr.right);\\n                    last = curr.right;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n```\n```\\n public void helper(TreeNode root,List<Integer> res , int currLevel){\\n        if(root == null) return;\\n        if(res.size() == currLevel) res.add(root.val);\\n        helper(root.right , res,currLevel + 1);\\n        helper(root.left , res,currLevel + 1);\\n    }\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        helper(root , res , 0);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2470140,
                "title": "simple-easy-java-solution-by-recursion",
                "content": "```\\n    public List<Integer> rightSideView(TreeNode root) {\\n      List <Integer> result = new ArrayList<Integer>();\\n      rightView(root, result , 0);\\n      return result ;\\n    }\\n    public void rightView(TreeNode root, List <Integer> result ,int currDepth){\\n      // null\\n      if ( root == null){\\n        return ;\\n      }\\n\\t  //If Height is equal to size of ds add it\\n      if ( currDepth == result.size()){\\n        result.add(root.val);\\n      }\\n     //right side\\n      rightView(root.right , result , currDepth + 1);\\n     //left  side\\n      rightView(root.left , result , currDepth + 1);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public List<Integer> rightSideView(TreeNode root) {\\n      List <Integer> result = new ArrayList<Integer>();\\n      rightView(root, result , 0);\\n      return result ;\\n    }\\n    public void rightView(TreeNode root, List <Integer> result ,int currDepth){\\n      // null\\n      if ( root == null){\\n        return ;\\n      }\\n\\t  //If Height is equal to size of ds add it\\n      if ( currDepth == result.size()){\\n        result.add(root.val);\\n      }\\n     //right side\\n      rightView(root.right , result , currDepth + 1);\\n     //left  side\\n      rightView(root.left , result , currDepth + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2284291,
                "title": "simple-depth-first-search-using-queue-of-treenode",
                "content": "```\\nclass Solution {\\n\\tpublic List<Integer> rightSideView(TreeNode root) {\\n\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn list;\\n\\t\\t}\\n\\t\\tqueue.add(root);\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\troot = queue.poll();\\n\\t\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\t\\tlist.add(root.val);\\n\\t\\t\\t\\tif (root.right != null)\\n\\t\\t\\t\\t\\tqueue.add(root.right);\\n\\t\\t\\t\\tif (root.left != null)\\n\\t\\t\\t\\t\\tqueue.add(root.left);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic List<Integer> rightSideView(TreeNode root) {\\n\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn list;\\n\\t\\t}\\n\\t\\tqueue.add(root);\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\troot = queue.poll();\\n\\t\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\t\\tlist.add(root.val);\\n\\t\\t\\t\\tif (root.right != null)\\n\\t\\t\\t\\t\\tqueue.add(root.right);\\n\\t\\t\\t\\tif (root.left != null)\\n\\t\\t\\t\\t\\tqueue.add(root.left);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269884,
                "title": "bfs-and-dfs-solution-c",
                "content": "# DFS Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        \\n        \\n      // we are maintaining an mx int for max level we reached        \\n        int mx = 0;\\n        push_right(root,ans,mx,1);\\n        return ans;\\n    }\\n    \\n    void push_right(TreeNode* root,vector<int> &ans,int &max,int h){\\n        \\n        if(root == NULL) return;\\n        \\n        // if we have reached any right node before on the same height or less we will skip this step\\n        if(max < h){\\n            max = h;\\n            ans.push_back(root->val);\\n        }\\n        \\n        // we will iterate as Right then left so that we will have right sided nodes\\n        push_right(root->right,ans,max,h+1);\\n        push_right(root->left,ans,max,h+1);\\n        \\n    }\\n    \\n};\\n```\\n\\n# BFS Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        vector<int> ans;\\n        \\n        if(root == NULL) return ans;\\n        \\n        queue<pair<TreeNode*,int>> q;  \\n        q.push(make_pair(root,0));\\n        \\n        pair<TreeNode*,int> temp;\\n        \\n        ans.push_back(root->val);\\n        int i;\\n        \\n        while(!q.empty()){\\n            \\n        temp = q.front();\\n        i = temp.second;    \\n        q.pop();\\n         if(ans.size() < i+1){\\n                ans.push_back(temp.first->val);\\n            }else{\\n                ans[i] = temp.first->val;\\n            }\\n            \\n        if(temp.first->left != NULL){ \\n            q.push(make_pair(temp.first->left,i+1));\\n        }   \\n        \\n        if(temp.first->right != NULL){\\n              q.push(make_pair(temp.first->right,i+1));\\n        }    \\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        \\n        \\n      // we are maintaining an mx int for max level we reached        \\n        int mx = 0;\\n        push_right(root,ans,mx,1);\\n        return ans;\\n    }\\n    \\n    void push_right(TreeNode* root,vector<int> &ans,int &max,int h){\\n        \\n        if(root == NULL) return;\\n        \\n        // if we have reached any right node before on the same height or less we will skip this step\\n        if(max < h){\\n            max = h;\\n            ans.push_back(root->val);\\n        }\\n        \\n        // we will iterate as Right then left so that we will have right sided nodes\\n        push_right(root->right,ans,max,h+1);\\n        push_right(root->left,ans,max,h+1);\\n        \\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        vector<int> ans;\\n        \\n        if(root == NULL) return ans;\\n        \\n        queue<pair<TreeNode*,int>> q;  \\n        q.push(make_pair(root,0));\\n        \\n        pair<TreeNode*,int> temp;\\n        \\n        ans.push_back(root->val);\\n        int i;\\n        \\n        while(!q.empty()){\\n            \\n        temp = q.front();\\n        i = temp.second;    \\n        q.pop();\\n         if(ans.size() < i+1){\\n                ans.push_back(temp.first->val);\\n            }else{\\n                ans[i] = temp.first->val;\\n            }\\n            \\n        if(temp.first->left != NULL){ \\n            q.push(make_pair(temp.first->left,i+1));\\n        }   \\n        \\n        if(temp.first->right != NULL){\\n              q.push(make_pair(temp.first->right,i+1));\\n        }    \\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269275,
                "title": "c-fast-simple-easy-solution-binary-tree-right-side-view",
                "content": "class Solution {\\npublic:\\n\\n    void helper(TreeNode* root, vector<int> &ans, int i){\\n        if(root == NULL) return;\\n        \\n        if(i == ans.size())\\n            ans.push_back(root->val);\\n        \\n        helper(root->right, ans, i+1);\\n        helper(root->left, ans, i+1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans, 0);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    void helper(TreeNode* root, vector<int> &ans, int i){\\n        if(root == NULL) return;\\n        \\n        if(i == ans.size())\\n            ans.push_back(root->val);\\n        \\n        helper(root->right, ans, i+1);\\n        helper(root->left, ans, i+1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2267389,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        queue<TreeNode*> q; // bfs queue \\n        if(root) q.push(root);\\n        while(!q.empty()){\\n            int l=q.size();\\n            ans.push_back(0);\\n            // look at all nodes at the current level \\n            while(l--){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n                ans[ans.size()-1]=node->val; // at the end of the loop, the right most value at the current level will be there at that position.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        queue<TreeNode*> q; // bfs queue \\n        if(root) q.push(root);\\n        while(!q.empty()){\\n            int l=q.size();\\n            ans.push_back(0);\\n            // look at all nodes at the current level \\n            while(l--){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n                ans[ans.size()-1]=node->val; // at the end of the loop, the right most value at the current level will be there at that position.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266472,
                "title": "c-recursive-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    unordered_map<int,int> m;\\n    void right(TreeNode* root, int level ,int max_level){\\n      if(root==NULL)return;\\n        \\n      if(max_level < level){\\n          m[level]++;\\n          if(m[level]==1){\\n          res.push_back(root->val);\\n          max_level = level;\\n          }    \\n      }  \\n      right(root->right,level+1,max_level);\\n      right(root->left,level+1,max_level);  \\n        \\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n       int max_level =0;\\n       right(root,1,max_level);\\n      return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    unordered_map<int,int> m;\\n    void right(TreeNode* root, int level ,int max_level){\\n      if(root==NULL)return;\\n        \\n      if(max_level < level){\\n          m[level]++;\\n          if(m[level]==1){\\n          res.push_back(root->val);\\n          max_level = level;\\n          }    \\n      }  \\n      right(root->right,level+1,max_level);\\n      right(root->left,level+1,max_level);  \\n        \\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n       int max_level =0;\\n       right(root,1,max_level);\\n      return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266364,
                "title": "easy-c-sol-recursive-iterative-time-o-n",
                "content": "```\\n// Iterative Sol :: Time : O(N) :: Aux_Space : O(N)\\n\\n /**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n\\n        if(!root)\\n            return {};\\n\\n        vector<int> res;\\n\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n\\n            int n = q.size();\\n\\n            for(int i=0;i<n;i++){\\n\\n                TreeNode*curr = q.front();\\n                q.pop();\\n\\n                if(i == n-1)\\n                    res.push_back(curr->val);\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n// Recursive Sol :: Time : O(N) :: Aux_Space : O(H) [H is the Height of the Tree]\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void reversePreorder(TreeNode* root, int level , vector<int> &res){\\n\\n        if(root == NULL)\\n            return;\\n\\n        if(res.size() == level){\\n            res.push_back(root->val);\\n        }\\n\\n        reversePreorder(root->right,level+1,res);\\n        reversePreorder(root->left,level+1,res);\\n\\n    }\\n\\n    vector<int> rightSideView(TreeNode* root) {\\n\\n        vector<int> res;\\n\\n        reversePreorder(root,0,res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n\\n        if(!root)\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 2266106,
                "title": "c-iterative-recursive-approach",
                "content": "**Upvote if you like it :)**\\n\\n**Intuition:**\\nThe main intuition of the problem is that we basically need to get the `i` level nodes that are `rightmost`.\\nOnly the one\\'s in the `right` of each `level` are consider and pushed in to the `answer`.\\n\\n**Iterative Approach:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root)\\n            return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode * node = q.front();\\n                q.pop();\\n                if(i==size-1)\\n                    ans.push_back(node->val);\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n****\\n**Time Complexity:O(N)**\\n**Space Complexity: O(Maximum Level)**\\n****\\n**Recursive Approach:**\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int level, vector<int>&res){\\n        if(!root)\\n            return;\\n        if(res.size()==level) res.push_back(root->val);\\n        dfs(root->right,level+1,res);\\n        dfs(root->left,level+1,res);\\n    }\\n\\n    vector<int> rightSideView(TreeNode* root){\\n        vector<int> res;\\n        dfs(root,0,res);\\n        return res;\\n    }\\n};\\n```\\n****\\n**Time Complexity:O(N)**\\n**Space Complexity: O(Height of the Tree)**\\n****",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root)\\n            return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode * node = q.front();\\n                q.pop();\\n                if(i==size-1)\\n                    ans.push_back(node->val);\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int level, vector<int>&res){\\n        if(!root)\\n            return;\\n        if(res.size()==level) res.push_back(root->val);\\n        dfs(root->right,level+1,res);\\n        dfs(root->left,level+1,res);\\n    }\\n\\n    vector<int> rightSideView(TreeNode* root){\\n        vector<int> res;\\n        dfs(root,0,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265802,
                "title": "optimised-easy-recursive-solution-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode *root,vector<int>&ans,int level)\\n{\\n   if(root==NULL)\\n   return;\\n   if(ans.size()==level)\\n   ans.push_back(root->val);\\n   solve(root->right,ans,level+1);\\n    solve(root->left,ans,level+1);\\n}\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n  solve(root,ans,0);\\n  return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode *root,vector<int>&ans,int level)\\n{\\n   if(root==NULL)\\n   return;\\n   if(ans.size()==level)\\n   ans.push_back(root->val);\\n   solve(root->right,ans,level+1);\\n    solve(root->left,ans,level+1);\\n}\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n  solve(root,ans,0);\\n  return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219802,
                "title": "0ms-100-fast-java-solution-recursive-approach",
                "content": "```\\nclass Solution {\\n    \\n    private int maxL = 0;\\n    \\n    private List<Integer> rViewCalc(List<Integer> ls, TreeNode root, int level) {\\n        \\n        if(root == null)\\n            return ls;\\n        \\n        if(maxL < level) {\\n            \\n            ls.add(root.val);\\n            maxL = level;\\n        }\\n        \\n        rViewCalc(ls, root.right, level + 1);\\n        rViewCalc(ls, root.left, level + 1);\\n        \\n        return ls;        \\n    }\\n    \\n    public List<Integer> rightSideView(TreeNode root) {\\n        \\n        List<Integer> rView = new ArrayList<Integer>();\\n        \\n        return rViewCalc(rView, root, 1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int maxL = 0;\\n    \\n    private List<Integer> rViewCalc(List<Integer> ls, TreeNode root, int level) {\\n        \\n        if(root == null)\\n            return ls;\\n        \\n        if(maxL < level) {\\n            \\n            ls.add(root.val);\\n            maxL = level;\\n        }\\n        \\n        rViewCalc(ls, root.right, level + 1);\\n        rViewCalc(ls, root.left, level + 1);\\n        \\n        return ls;        \\n    }\\n    \\n    public List<Integer> rightSideView(TreeNode root) {\\n        \\n        List<Integer> rView = new ArrayList<Integer>();\\n        \\n        return rViewCalc(rView, root, 1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205588,
                "title": "simple-c-o-n-solution-recursive-2ms",
                "content": "Order of Traversal => root -> right -> left\\nFor each level(height) maintain a map, to check if we have taken a node from this level or not.\\nThe order of our traversal ensures that we visit rightmost node at any level first. Push that node in answer vector and mark that level as visited or 1.\\n**Recursive implementation of the above idea**:\\n```\\nclass Solution {\\npublic:\\n    map<int, int> m;\\n    vector<int> ans;\\n    void rec(TreeNode *root, int h) {\\n        if(root == NULL) return;\\n        if(m[h] == 0) {\\n            ans.push_back(root -> val);\\n            m[h] = 1;\\n        }\\n        rec(root -> right, h + 1);\\n        rec(root -> left, h + 1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        rec(root, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, int> m;\\n    vector<int> ans;\\n    void rec(TreeNode *root, int h) {\\n        if(root == NULL) return;\\n        if(m[h] == 0) {\\n            ans.push_back(root -> val);\\n            m[h] = 1;\\n        }\\n        rec(root -> right, h + 1);\\n        rec(root -> left, h + 1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        rec(root, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156122,
                "title": "c-solution-for-binary-tree-right-side-view-with-comments",
                "content": "Solution for **Binary Tree Right Side View** :)\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL) return ans;\\n        // queue to store the nodes\\n        queue<TreeNode*> q;\\n        \\n        // push the root node first\\n        q.push(root);\\n        \\n        // iterate till q is not empty\\n        while(!q.empty())\\n        {\\n            // check the size of the queue which will be equal to the\\n            // number of nodes in that particular level\\n            int n = q.size();\\n            int val;\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* cur = q.front();\\n                q.pop();\\n                // update the val variable such that\\n                // it always stores the last node of that level\\n                val = cur->val;\\n                \\n                // check if left child is not null and push into queue\\n                if(cur->left != NULL) q.push(cur->left);\\n                // check if right child is not null and push into queue\\n                if(cur->right != NULL) q.push(cur->right);\\n            }\\n            \\n            // append val to the vector\\n            ans.push_back(val);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL) return ans;\\n        // queue to store the nodes\\n        queue<TreeNode*> q;\\n        \\n        // push the root node first\\n        q.push(root);\\n        \\n        // iterate till q is not empty\\n        while(!q.empty())\\n        {\\n            // check the size of the queue which will be equal to the\\n            // number of nodes in that particular level\\n            int n = q.size();\\n            int val;\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* cur = q.front();\\n                q.pop();\\n                // update the val variable such that\\n                // it always stores the last node of that level\\n                val = cur->val;\\n                \\n                // check if left child is not null and push into queue\\n                if(cur->left != NULL) q.push(cur->left);\\n                // check if right child is not null and push into queue\\n                if(cur->right != NULL) q.push(cur->right);\\n            }\\n            \\n            // append val to the vector\\n            ans.push_back(val);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099208,
                "title": "recursive-solution-using-preorder-approch",
                "content": "\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> rightSideView(TreeNode* root,int level=0) {\\n        if(!root) return {};\\n        if(ans.size()==level) ans.push_back(root->val);\\n        rightSideView(root->right , level+1); //call for right\\n        rightSideView(root->left , level+1);  //call for left\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> rightSideView(TreeNode* root,int level=0) {\\n        if(!root) return {}",
                "codeTag": "Java"
            },
            {
                "id": 2094856,
                "title": "python3-o-n-time-easy-to-understand-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        res = []\\n        if not root: return res\\n        \\n        q = collections.deque()\\n        q.append(root)\\n        \\n        while q:\\n            res.append(q[-1].val)  # the top element of q is the right-most\\n            n = len(q)             # popping all elements of a level at a time\\n            for i in range(n):     # first n nodes of q are nodes of current level\\n                node = q.popleft()\\n                if node.left: q.append(node.left)\\n                if node.right: q.append(node.right)\\n        \\n        return res\\n    \\n# Instead of using array as a queue we should use collections.deque()\\n# as pop() 0\\'th element from deque is of O(1) time.\\n\\n# Time: O(N)\\n# Space: O(N)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        res = []\\n        if not root: return res\\n        \\n        q = collections.deque()\\n        q.append(root)\\n        \\n        while q:\\n            res.append(q[-1].val)  # the top element of q is the right-most\\n            n = len(q)             # popping all elements of a level at a time\\n            for i in range(n):     # first n nodes of q are nodes of current level\\n                node = q.popleft()\\n                if node.left: q.append(node.left)\\n                if node.right: q.append(node.right)\\n        \\n        return res\\n    \\n# Instead of using array as a queue we should use collections.deque()\\n# as pop() 0\\'th element from deque is of O(1) time.\\n\\n# Time: O(N)\\n# Space: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784233,
                "title": "easy-to-understand-simplest-stack-version-during-an-interview-java",
                "content": "\\n\\tclass Solution {\\n\\t\\tpublic List<Integer> rightSideView(TreeNode root) {\\n\\t\\t\\tint height = 0; \\n\\t\\t\\tList<Integer> ans = new ArrayList<>();\\n\\t\\t\\tif(root == null) return ans;\\n        \\n        Node newRoot = new Node(root, height);\\n        \\n        Deque<Node> stack = new ArrayDeque<>();\\n        \\n        stack.push(newRoot);\\n        \\n        while(!stack.isEmpty()){\\n            Node n = stack.pop();\\n            TreeNode cur = n.node;\\n            height = n.height;\\n            \\n            if(height == ans.size()) ans.add(cur.val);\\n            \\n            \\n            if(cur.left != null) stack.push(new Node(cur.left, height + 1));\\n            if(cur.right != null) stack.push(new Node(cur.right, height + 1));\\n            \\n        }\\n        return ans;\\n    }\\n\\t}\\n\\n\\tclass Node{\\n\\t\\tTreeNode node;\\n\\t\\tint height;\\n    \\n    public Node(TreeNode node, int height){\\n        this.node = node;\\n        this.height = height;\\n    }\\n\\t}\\n\\t\\n\\tN is number of all the nodes in this tree\\n\\tTime : O(N) //time would be always O(N) no matter which method you use, this is tree traversal\\n\\t\\n\\tH is height of the tree;\\n\\tSpace: O(H) \\n\\tmax space would be \"a straight line\" all the way from the \"root\" (actually, left of root) of the tree to its any leaf node\\n\\t\\n\\t\\n\\tInstead of using two stack, one for treversing the whole tree, one for storing the height, \\n\\twe, on the other hand, \\n\\tcreate a class and encapsulate both of the TreeNode and its height to this class.\\n\\twe treverse the tree with the order node -> right -> left, \\n\\tsince each time when we are at a new level, \\n\\twe want to add the the right most node.val to our final list;\\n\\t\\n\\tPlease let me know if you have any question, I will try to make everyone understand if possible :)\\n\\t\\n\\tI was actually asked to solve this question using stack, during an interview, \\n\\tso I think it would be helpful to share my thought on this question to the public \\n\\tso we all can better prepare for our next techical interview!!!",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<Integer> rightSideView(TreeNode root) {\\n\\t\\t\\tint height = 0; \\n\\t\\t\\tList<Integer> ans = new ArrayList<>();\\n\\t\\t\\tif(root == null) return ans;\\n        \\n        Node newRoot = new Node(root, height);\\n        \\n        Deque<Node> stack = new ArrayDeque<>();\\n        \\n        stack.push(newRoot);\\n        \\n        while(!stack.isEmpty()){\\n            Node n = stack.pop();\\n            TreeNode cur = n.node;\\n            height = n.height;\\n            \\n            if(height == ans.size()) ans.add(cur.val);\\n            \\n            \\n            if(cur.left != null) stack.push(new Node(cur.left, height + 1));\\n            if(cur.right != null) stack.push(new Node(cur.right, height + 1));\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1683523,
                "title": "c-0ms-faster-than-100-and-99-21-less-memory-used",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    //just to initialise the size of our result vector\\n    //height = number of elements in the vector\\n    //Geeks for Geeks function code for height of a tree\\n    int maxDepth(TreeNode* node){ \\n        if (!node) return 0;\\n        else{ \\n            /* compute the depth of each subtree */\\n            int lDepth = maxDepth(node->left); \\n            int rDepth = maxDepth(node->right); \\n\\n            /* use the larger one */\\n            if (lDepth > rDepth) \\n                return(lDepth + 1); \\n            else return(rDepth + 1); \\n        } \\n    }\\n    //all we have to do is to use the rightmost node in every level\\n    //we keep updating the index with the newest value obtained\\n    //which is the rightmost since we traverse from left to right\\n    void fill(vector<int> &nums, TreeNode* root, int level){\\n        //base case\\n        if(level == n) return;\\n        if(!root) return;\\n        //recursive case\\n        nums[level] = root->val;\\n        fill(nums, root->left, level+1);\\n        fill(nums, root->right, level+1);\\n        return;\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        n = maxDepth(root);\\n        if(!n) return {};\\n        vector<int> res(n);\\n        fill(res, root, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    //just to initialise the size of our result vector\\n    //height = number of elements in the vector\\n    //Geeks for Geeks function code for height of a tree\\n    int maxDepth(TreeNode* node){ \\n        if (!node) return 0;\\n        else{ \\n            /* compute the depth of each subtree */\\n            int lDepth = maxDepth(node->left); \\n            int rDepth = maxDepth(node->right); \\n\\n            /* use the larger one */\\n            if (lDepth > rDepth) \\n                return(lDepth + 1); \\n            else return(rDepth + 1); \\n        } \\n    }\\n    //all we have to do is to use the rightmost node in every level\\n    //we keep updating the index with the newest value obtained\\n    //which is the rightmost since we traverse from left to right\\n    void fill(vector<int> &nums, TreeNode* root, int level){\\n        //base case\\n        if(level == n) return;\\n        if(!root) return;\\n        //recursive case\\n        nums[level] = root->val;\\n        fill(nums, root->left, level+1);\\n        fill(nums, root->right, level+1);\\n        return;\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        n = maxDepth(root);\\n        if(!n) return {};\\n        vector<int> res(n);\\n        fill(res, root, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674849,
                "title": "java-1-ms-easy-solution-with-comments",
                "content": "```\\n//LOGIC::\\n// AFTER ADDING A LEVEL IN QUEUE LAST ELEMENT WILL ALWAYS BE RIGHT SIDE ELEMENT SO WHEN I REACHES LAST ELEMENT IN QUEUE IT WILL GIVE US RIGHT SIDE ELEMENT IN  BINARY TREE\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list=new ArrayList<>();\\n        if(root==null)\\n        {\\n            return new ArrayList<>();\\n        }\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode t=q.poll();\\n                 if(i==n-1)\\n                {\\n                    list.add(t.val);\\n                }\\n                if(t.left!=null)\\n                {\\n                    q.add(t.left);\\n                }\\n                if(t.right!=null)\\n                {\\n                    q.add(t.right);\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n//LOGIC::\\n// AFTER ADDING A LEVEL IN QUEUE LAST ELEMENT WILL ALWAYS BE RIGHT SIDE ELEMENT SO WHEN I REACHES LAST ELEMENT IN QUEUE IT WILL GIVE US RIGHT SIDE ELEMENT IN  BINARY TREE\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list=new ArrayList<>();\\n        if(root==null)\\n        {\\n            return new ArrayList<>();\\n        }\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode t=q.poll();\\n                 if(i==n-1)\\n                {\\n                    list.add(t.val);\\n                }\\n                if(t.left!=null)\\n                {\\n                    q.add(t.left);\\n                }\\n                if(t.right!=null)\\n                {\\n                    q.add(t.right);\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567599,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1921663,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567413,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1896366,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1842676,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568432,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1573517,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1859798,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569652,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566727,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567599,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1921663,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567413,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1896366,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1842676,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568432,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1573517,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1859798,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569652,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566727,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566643,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1573508,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1947874,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1574568,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1574249,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1960118,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1683458,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1576036,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 2062131,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 2040481,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 2022521,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 2017223,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1998303,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1995494,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1987889,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1984873,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1979876,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1977882,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1961950,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1945465,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1933755,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1892256,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1866797,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1862311,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1862300,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1856699,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1854654,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1832936,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1812112,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1793001,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            }
        ]
    },
    {
        "title": "Bulls and Cows",
        "question_content": "<p>You are playing the <strong><a href=\"https://en.wikipedia.org/wiki/Bulls_and_Cows\" target=\"_blank\">Bulls and Cows</a></strong> game with your friend.</p>\n\n<p>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:</p>\n\n<ul>\n\t<li>The number of &quot;bulls&quot;, which are digits in the guess that are in the correct position.</li>\n\t<li>The number of &quot;cows&quot;, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.</li>\n</ul>\n\n<p>Given the secret number <code>secret</code> and your friend&#39;s guess <code>guess</code>, return <em>the hint for your friend&#39;s guess</em>.</p>\n\n<p>The hint should be formatted as <code>&quot;xAyB&quot;</code>, where <code>x</code> is the number of bulls and <code>y</code> is the number of cows. Note that both <code>secret</code> and <code>guess</code> may contain duplicate digits.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> secret = &quot;1807&quot;, guess = &quot;7810&quot;\n<strong>Output:</strong> &quot;1A3B&quot;\n<strong>Explanation:</strong> Bulls are connected with a &#39;|&#39; and cows are underlined:\n&quot;1807&quot;\n  |\n&quot;<u>7</u>8<u>10</u>&quot;</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> secret = &quot;1123&quot;, guess = &quot;0111&quot;\n<strong>Output:</strong> &quot;1A1B&quot;\n<strong>Explanation:</strong> Bulls are connected with a &#39;|&#39; and cows are underlined:\n&quot;1123&quot;        &quot;1123&quot;\n  |      or     |\n&quot;01<u>1</u>1&quot;        &quot;011<u>1</u>&quot;\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>\n\t<li><code>secret.length == guess.length</code></li>\n\t<li><code>secret</code> and <code>guess</code> consist of digits only.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 74621,
                "title": "one-pass-java-solution",
                "content": "The idea is to iterate over the numbers in `secret` and in `guess` and count all bulls right away. For cows maintain an array that stores count of the number appearances in `secret` and in `guess`. Increment cows when either number from `secret` was already seen in `guest` or vice versa.\\n\\n\\n    public String getHint(String secret, String guess) {\\n        int bulls = 0;\\n        int cows = 0;\\n        int[] numbers = new int[10];\\n        for (int i = 0; i<secret.length(); i++) {\\n            int s = Character.getNumericValue(secret.charAt(i));\\n            int g = Character.getNumericValue(guess.charAt(i));\\n            if (s == g) bulls++;\\n            else {\\n                if (numbers[s] < 0) cows++;\\n                if (numbers[g] > 0) cows++;\\n                numbers[s] ++;\\n                numbers[g] --;\\n            }\\n        }\\n        return bulls + \"A\" + cows + \"B\";\\n    }\\n\\nA slightly more concise version:\\n\\n    public String getHint(String secret, String guess) {\\n        int bulls = 0;\\n        int cows = 0;\\n        int[] numbers = new int[10];\\n        for (int i = 0; i<secret.length(); i++) {\\n            if (secret.charAt(i) == guess.charAt(i)) bulls++;\\n            else {\\n                if (numbers[secret.charAt(i)-'0']++ < 0) cows++;\\n                if (numbers[guess.charAt(i)-'0']-- > 0) cows++;\\n            }\\n        }\\n        return bulls + \"A\" + cows + \"B\";\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is to iterate over the numbers in `secret` and in `guess` and count all bulls right away. For cows maintain an array that stores count of the number appearances in `secret` and in `guess`. Increment cows when either number from `secret` was already seen in `guest` or vice versa.\\n\\n\\n    public String getHint(String secret, String guess) {\\n        int bulls = 0;\\n        int cows = 0;\\n        int[] numbers = new int[10];\\n        for (int i = 0; i<secret.length(); i++) {\\n            int s = Character.getNumericValue(secret.charAt(i));\\n            int g = Character.getNumericValue(guess.charAt(i));\\n            if (s == g) bulls++;\\n            else {\\n                if (numbers[s] < 0) cows++;\\n                if (numbers[g] > 0) cows++;\\n                numbers[s] ++;\\n                numbers[g] --;\\n            }\\n        }\\n        return bulls + \"A\" + cows + \"B\";\\n    }\\n\\nA slightly more concise version:\\n\\n    public String getHint(String secret, String guess) {\\n        int bulls = 0;\\n        int cows = 0;\\n        int[] numbers = new int[10];\\n        for (int i = 0; i<secret.length(); i++) {\\n            if (secret.charAt(i) == guess.charAt(i)) bulls++;\\n            else {\\n                if (numbers[secret.charAt(i)-'0']++ < 0) cows++;\\n                if (numbers[guess.charAt(i)-'0']-- > 0) cows++;\\n            }\\n        }\\n        return bulls + \"A\" + cows + \"B\";\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 74618,
                "title": "c-4ms-straight-forward-solution-two-pass-o-n-time",
                "content": "The idea is simple, if two char is match, add aCnt, otherwise, record it and process bCnt in second pass.\\n\\n    class Solution {\\n    public:\\n        // only contains digits \\n        string getHint(string secret, string guess) {\\n            int aCnt = 0;\\n            int bCnt = 0;\\n            vector<int> sVec(10, 0); // 0 ~ 9 for secret\\n            vector<int> gVec(10, 0); // 0 ~ 9 for guess \\n            if (secret.size() != guess.size() || secret.empty()) { return \"0A0B\"; }\\n            for (int i = 0; i < secret.size(); ++i) {\\n                char c1 = secret[i]; char c2 = guess[i];\\n                if (c1 == c2) {\\n                    ++aCnt; \\n                } else {\\n                    ++sVec[c1-'0'];\\n                    ++gVec[c2-'0'];\\n                }\\n            }\\n            // count b \\n            for (int i = 0; i < sVec.size(); ++i) {\\n                bCnt += min(sVec[i], gVec[i]);\\n            }\\n            return to_string(aCnt) + 'A' + to_string(bCnt) + 'B';\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        // only contains digits \\n        string getHint(string secret, string guess) {\\n            int aCnt = 0;\\n            int bCnt = 0;\\n            vector<int> sVec(10, 0); // 0 ~ 9 for secret\\n            vector<int> gVec(10, 0); // 0 ~ 9 for guess \\n            if (secret.size() != guess.size() || secret.empty()) { return \"0A0B\"; }",
                "codeTag": "Java"
            },
            {
                "id": 74629,
                "title": "my-3ms-java-solution-may-help-u",
                "content": "    public class Solution {\\n        public String getHint(String secret, String guess) {\\n            int len = secret.length();\\n    \\t\\tint[] secretarr = new int[10];\\n    \\t\\tint[] guessarr = new int[10];\\n    \\t\\tint bull = 0, cow = 0;\\n    \\t\\tfor (int i = 0; i < len; ++i) {\\n    \\t\\t\\tif (secret.charAt(i) == guess.charAt(i)) {\\n    \\t\\t\\t\\t++bull;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\t++secretarr[secret.charAt(i) - '0'];\\n    \\t\\t\\t\\t++guessarr[guess.charAt(i) - '0'];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tfor (int i = 0; i < 10; ++i) {\\n    \\t\\t\\tcow += Math.min(secretarr[i], guessarr[i]);\\n    \\t\\t}\\n    \\t\\treturn \"\" + bull + \"A\" + cow + \"B\";\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String getHint(String secret, String guess) {\\n            int len = secret.length();\\n    \\t\\tint[] secretarr = new int[10];\\n    \\t\\tint[] guessarr = new int[10];\\n    \\t\\tint bull = 0, cow = 0;\\n    \\t\\tfor (int i = 0; i < len; ++i) {\\n    \\t\\t\\tif (secret.charAt(i) == guess.charAt(i)) {\\n    \\t\\t\\t\\t++bull;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 74644,
                "title": "python-3-lines-solution",
                "content": "use `Counter` to count `guess` and `secret` and sum their overlap. Then use `zip` to count `A`.\\n\\n        s, g = Counter(secret), Counter(guess)\\n        a = sum(i == j for i, j in zip(secret, guess))\\n        return '%sA%sB' % (a, sum((s & g).values()) - a)",
                "solutionTags": [
                    "Python"
                ],
                "code": "use `Counter` to count `guess` and `secret` and sum their overlap. Then use `zip` to count `A`.\\n\\n        s, g = Counter(secret), Counter(guess)\\n        a = sum(i == j for i, j in zip(secret, guess))\\n        return '%sA%sB' % (a, sum((s & g).values()) - a)",
                "codeTag": "Unknown"
            },
            {
                "id": 74616,
                "title": "3-lines-in-python",
                "content": "    def getHint(self, secret, guess):\\n        bulls = sum(map(operator.eq, secret, guess))\\n        both = sum(min(secret.count(x), guess.count(x)) for x in set(guess))\\n        return \\'%dA%dB\\' % (bulls, both - bulls)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def getHint(self, secret, guess):\\n        bulls = sum(map(operator.eq, secret, guess))\\n        both = sum(min(secret.count(x), guess.count(x)) for x in set(guess))\\n        return \\'%dA%dB\\' % (bulls, both - bulls)",
                "codeTag": "Python3"
            },
            {
                "id": 74735,
                "title": "very-easy-solution-using-two-arrays",
                "content": "    public class Solution {\\n    public String getHint(String secret, String guess) {\\n        int temp = 0;\\n        int bulls = 0;\\n        int[] nums1 = new int[10];\\n        int[] nums2 = new int[10];\\n        for(int i = 0; i < secret.length(); i++){\\n            char s = secret.charAt(i);\\n            char g = guess.charAt(i);\\n            if(s == g){\\n                bulls++;\\n            }\\n            else{\\n                nums1[s - '0']++;\\n                nums2[g - '0']++;\\n            }\\n        }\\n        int cows = 0;\\n        for(int i = 0; i < 10; i++){\\n            cows += Math.min(nums1[i], nums2[i]);\\n        }\\n        String res = bulls + \"A\" + cows + \"B\";\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String getHint(String secret, String guess) {\\n        int temp = 0;\\n        int bulls = 0;\\n        int[] nums1 = new int[10];\\n        int[] nums2 = new int[10];\\n        for(int i = 0; i < secret.length(); i++){\\n            char s = secret.charAt(i);\\n            char g = guess.charAt(i);\\n            if(s == g){\\n                bulls++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 839444,
                "title": "python-simple-solution-with-counters-explained",
                "content": "Easy, but interesting problem, because it can be solved in different ways.\\n\\n1. Let us first evaluate number of bulls `B`: by definition it is number of places with the same digit in `secret` and `guess`: so let us just traverse our strings and count it.\\n2. Now, let us evaluate both number of cows and bulls: `B_C`: we need to count each digit in `secret` and in `guess` and choose the smallest of these two numbers.  Evaluate sum for each digit.\\n3. Finally, number of cows will be `B_C - B`, so we just return return the answer!\\n\\n**Complexity**: both time and space complexity is `O(1)`. Imagine, that we have not `4` lengths, but `n`, then we have `O(n)` time complexity and `O(10)` space complexity to keep our counters.\\n\\n```\\nclass Solution:\\n    def getHint(self, secret, guess):\\n        B = sum([x==y for x,y in zip(secret, guess)])\\n\\t\\tCount_sec = Counter(secret)\\n        Count_gue = Counter(guess)\\n        B_C = sum([min(Count_sec[elem], Count_gue[elem]) for elem in Count_sec])\\n        return str(B) + \"A\" + str(B_C-B) + \"B\"\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret, guess):\\n        B = sum([x==y for x,y in zip(secret, guess)])\\n\\t\\tCount_sec = Counter(secret)\\n        Count_gue = Counter(guess)\\n        B_C = sum([min(Count_sec[elem], Count_gue[elem]) for elem in Count_sec])\\n        return str(B) + \"A\" + str(B_C-B) + \"B\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74820,
                "title": "c-one-pass-o-n-time-o-1-space",
                "content": "    class Solution {\\n    public:\\n        string getHint(string secret, string guess) {\\n            unordered_map<char, int> s_map;\\n            unordered_map<char, int> g_map;\\n            int n = secret.size();\\n            int A = 0, B = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                char s = secret[i], g = guess[i];\\n                if (s == g)\\n                    A++;\\n                else\\n                {\\n                    (s_map[g] > 0) ? s_map[g]--, B++ : g_map[g]++;\\n                    (g_map[s] > 0) ? g_map[s]--, B++ : s_map[s]++; \\n                }\\n            }\\n            return to_string(A) + \"A\" + to_string(B) + \"B\";;\\n        }         \\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string getHint(string secret, string guess) {\\n            unordered_map<char, int> s_map;\\n            unordered_map<char, int> g_map;\\n            int n = secret.size();\\n            int A = 0, B = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                char s = secret[i], g = guess[i];\\n                if (s == g)\\n                    A++;\\n                else\\n                {\\n                    (s_map[g] > 0) ? s_map[g]--, B++ : g_map[g]++;\\n                    (g_map[s] > 0) ? g_map[s]--, B++ : s_map[s]++; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 74788,
                "title": "java-solution-with-two-buckets",
                "content": "    public class Solution {\\n        public String getHint(String secret, String guess) {\\n            int bull = 0, cow = 0;\\n            \\n            int[] sarr = new int[10];\\n            int[] garr = new int[10];\\n            \\n            for(int i = 0; i < secret.length(); i++){\\n                if(secret.charAt(i) != guess.charAt(i)){\\n                    sarr[secret.charAt(i)-'0']++;\\n                    garr[guess.charAt(i)-'0']++;\\n                }else{\\n                    bull++;\\n                }\\n            }\\n            \\n            for(int i = 0; i <= 9; i++){\\n                cow += Math.min(sarr[i], garr[i]);\\n            }\\n            \\n            return (bull + \"A\" + cow + \"B\");\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String getHint(String secret, String guess) {\\n            int bull = 0, cow = 0;\\n            \\n            int[] sarr = new int[10];\\n            int[] garr = new int[10];\\n            \\n            for(int i = 0; i < secret.length(); i++){\\n                if(secret.charAt(i) != guess.charAt(i)){\\n                    sarr[secret.charAt(i)-'0']++;\\n                    garr[guess.charAt(i)-'0']++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 74765,
                "title": "javascript-solution",
                "content": "    function getHint(secret, guess) {\\n      var map = {};\\n      var A = 0;\\n      var B = 0;\\n      for (var i = 0; i < 10; i++) map[i] = 0;\\n      for (i = 0; i < secret.length; i++) {\\n        if (secret[i] === guess[i]) A++;\\n        else {\\n          map[secret[i]]++;\\n          B += map[secret[i]] <= 0 ? 1 : 0;\\n          map[guess[i]]--;\\n          B += map[guess[i]] >= 0 ? 1 : 0;\\n        }\\n      }\\n      return A + 'A' + B + 'B';\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function getHint(secret, guess) {\\n      var map = {};\\n      var A = 0;\\n      var B = 0;\\n      for (var i = 0; i < 10; i++) map[i] = 0;\\n      for (i = 0; i < secret.length; i++) {\\n        if (secret[i] === guess[i]) A++;\\n        else {\\n          map[secret[i]]++;\\n          B += map[secret[i]] <= 0 ? 1 : 0;\\n          map[guess[i]]--;\\n          B += map[guess[i]] >= 0 ? 1 : 0;\\n        }\\n      }\\n      return A + 'A' + B + 'B';\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 74716,
                "title": "java-solution-without-hashing-3ms",
                "content": "public String getHint(String secret, String guess) {\\n        \\n        if(secret.length() == 0){return \"0A0B\";}\\n        \\n        int bull = 0;\\n        int cow = 0;\\n        int [] result = new int [10];\\n        \\n        for(int i = 0;i<secret.length();i++)\\n        {\\n            int x = secret.charAt(i) - 48;\\n            int y = guess.charAt(i) - 48;\\n            \\n            if(x == y)\\n            {\\n                bull++;\\n            }\\n            else\\n            {\\n                if(result[x] < 0){cow++;}\\n                result[x]++;\\n                \\n                if(result[y] > 0){cow++;}\\n                result[y]--;\\n            }\\n        }\\n        \\n        return bull+\"A\"+cow+\"B\";\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public String getHint(String secret, String guess) {\\n        \\n        if(secret.length() == 0){return \"0A0B\";}\\n        \\n        int bull = 0;\\n        int cow = 0;\\n        int [] result = new int [10];\\n        \\n        for(int i = 0;i<secret.length();i++)\\n        {\\n            int x = secret.charAt(i) - 48;\\n            int y = guess.charAt(i) - 48;\\n            \\n            if(x == y)\\n            {\\n                bull++;\\n            }\\n            else\\n            {\\n                if(result[x] < 0){cow++;}\\n                result[x]++;\\n                \\n                if(result[y] > 0){cow++;}\\n                result[y]--;\\n            }\\n        }\\n        \\n        return bull+\"A\"+cow+\"B\";\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 563661,
                "title": "fast-and-easy-to-understand-python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        \\n\\t\\t# The main idea is to understand that cow cases contain the bull cases\\n\\t\\t\\n\\t\\t# This loop will take care of \"bull\" cases\\n        bull=0\\n        for i in range(len(secret)):\\n            bull += int(secret[i] == guess[i])\\n        \\n\\t\\t# This loop will take care of \"cow\" cases\\n        cows=0\\n        for c in set(secret):\\n            cows += min(secret.count(c), guess.count(c))\\n        \\n        return f\"{bull}A{cows-bull}B\"\\n```\\n\\nI hope that helps :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        \\n\\t\\t# The main idea is to understand that cow cases contain the bull cases\\n\\t\\t\\n\\t\\t# This loop will take care of \"bull\" cases\\n        bull=0\\n        for i in range(len(secret)):\\n            bull += int(secret[i] == guess[i])\\n        \\n\\t\\t# This loop will take care of \"cow\" cases\\n        cows=0\\n        for c in set(secret):\\n            cows += min(secret.count(c), guess.count(c))\\n        \\n        return f\"{bull}A{cows-bull}B\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74775,
                "title": "python-dict-solution",
                "content": "    class Solution(object):\\n        def getHint(self, secret, guess):\\n            \"\"\"\\n            :type secret: str\\n            :type guess: str\\n            :rtype: str\\n                    \"\"\"\\n            d = {}\\n            bull, cow = 0,0\\n    \\n            for index,s in enumerate(secret):\\n                if guess[index] == s:\\n                    bull += 1\\n                else:\\n                    d[s] = d.get(s,0) + 1\\n    \\n            for index,s in enumerate(secret):\\n                if (guess[index] != s) & (d.get(guess[index],0) != 0):\\n            \\t    cow += 1\\n            \\t    d[guess[index]] -= 1\\n            \\t    \\n            return str(bull) + \"A\" + str(cow) + \"B\"",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n        def getHint(self, secret, guess):\\n            \"\"\"\\n            :type secret: str\\n            :type guess: str\\n            :rtype: str\\n                    \"\"\"\\n            d = {}",
                "codeTag": "Java"
            },
            {
                "id": 74722,
                "title": "python-simple-solution",
                "content": "    class Solution(object):\\n        def getHint(self, secret, guess):\\n            \"\"\"\\n            :type secret: str\\n            :type guess: str\\n            :rtype: str\\n            \"\"\"\\n            bulls = 0\\n            l1, l2 = [0]*10, [0]*10\\n            nums1, nums2 = map(int, secret), map(int, guess)\\n            length = len(secret)\\n            for i in xrange(length):\\n                if nums1[i] == nums2[i]:\\n                    bulls += 1\\n                else:\\n                    l1[nums1[i]] += 1\\n                    l2[nums2[i]] += 1\\n            cows = sum(map(min, zip(l1,l2)))\\n            return '%dA%dB' % (bulls, cows)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def getHint(self, secret, guess):\\n            \"\"\"\\n            :type secret: str\\n            :type guess: str\\n            :rtype: str\\n            \"\"\"\\n            bulls = 0\\n            l1, l2 = [0]*10, [0]*10\\n            nums1, nums2 = map(int, secret), map(int, guess)\\n            length = len(secret)\\n            for i in xrange(length):\\n                if nums1[i] == nums2[i]:\\n                    bulls += 1\\n                else:\\n                    l1[nums1[i]] += 1\\n                    l2[nums2[i]] += 1\\n            cows = sum(map(min, zip(l1,l2)))\\n            return '%dA%dB' % (bulls, cows)",
                "codeTag": "Java"
            },
            {
                "id": 74738,
                "title": "easy-java-solution",
                "content": "    public class Solution {\\n    public String getHint(String secret, String guess) {\\n        int bull = 0, cow = 0;\\n        int[] array = new int[10];\\n        \\n        for(int i = 0; i < secret.length(); i++) {\\n            char s = secret.charAt(i);\\n            char g = guess.charAt(i);\\n            if(s == g){\\n                bull++;\\n            }else {\\n                if(array[s - '0'] < 0) {\\n                    cow++;\\n                }\\n                array[s - '0']++;\\n                \\n                if(array[g - '0'] > 0) {\\n                    cow++;\\n                }\\n                array[g -'0']--;\\n            }\\n        }\\n        return bull + \"A\" + cow + \"B\";\\n    }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public String getHint(String secret, String guess) {\\n        int bull = 0, cow = 0;\\n        int[] array = new int[10];\\n        \\n        for(int i = 0; i < secret.length(); i++) {\\n            char s = secret.charAt(i);\\n            char g = guess.charAt(i);\\n            if(s == g){\\n                bull++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2742641,
                "title": "java-hashmap-frequency-array-clean",
                "content": "### **Please Upvote** :D\\n##### 1. Using HashMap to store character frequency:\\n```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bulls = 0, cows = 0;\\n\\n        Map<Character, Integer> secretFreq = new HashMap<>();\\n        Map<Character, Integer> guessFreq = new HashMap<>();\\n\\n        for (int i = 0; i < secret.length(); i++) {\\n            char s = secret.charAt(i);\\n            char g = guess.charAt(i);\\n\\n            if (s == g) bulls++;\\n            else {\\n                secretFreq.put(s, secretFreq.getOrDefault(s, 0) + 1);\\n                guessFreq.put(g, guessFreq.getOrDefault(g, 0) + 1);\\n            }\\n        }\\n\\n        for (char c : secretFreq.keySet()) {\\n            if (guessFreq.containsKey(c)) {\\n                cows += Math.min(secretFreq.get(c), guessFreq.get(c));\\n            }\\n        }\\n\\n        return bulls + \"A\" + cows + \"B\";\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n\\n```\\n##### 2. Using Arrays to store character frequency:\\n```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bulls = 0, cows = 0;\\n\\n        int[] secretFreq = new int[10],\\n        guessFreq = new int[10];\\n\\n        for (int i = 0; i < secret.length(); i++) {\\n            char s = secret.charAt(i);\\n            char g = guess.charAt(i);\\n\\n            if (s == g) bulls++;\\n            else {\\n                secretFreq[s - \\'0\\']++;\\n                guessFreq[g - \\'0\\']++;\\n            }\\n        }\\n\\n        for (int i = 0; i < 10; i++) {\\n            cows += Math.min(secretFreq[i], guessFreq[i]);\\n        }\\n\\n        return bulls + \"A\" + cows + \"B\";\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bulls = 0, cows = 0;\\n\\n        Map<Character, Integer> secretFreq = new HashMap<>();\\n        Map<Character, Integer> guessFreq = new HashMap<>();\\n\\n        for (int i = 0; i < secret.length(); i++) {\\n            char s = secret.charAt(i);\\n            char g = guess.charAt(i);\\n\\n            if (s == g) bulls++;\\n            else {\\n                secretFreq.put(s, secretFreq.getOrDefault(s, 0) + 1);\\n                guessFreq.put(g, guessFreq.getOrDefault(g, 0) + 1);\\n            }\\n        }\\n\\n        for (char c : secretFreq.keySet()) {\\n            if (guessFreq.containsKey(c)) {\\n                cows += Math.min(secretFreq.get(c), guessFreq.get(c));\\n            }\\n        }\\n\\n        return bulls + \"A\" + cows + \"B\";\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n\\n```\n```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bulls = 0, cows = 0;\\n\\n        int[] secretFreq = new int[10],\\n        guessFreq = new int[10];\\n\\n        for (int i = 0; i < secret.length(); i++) {\\n            char s = secret.charAt(i);\\n            char g = guess.charAt(i);\\n\\n            if (s == g) bulls++;\\n            else {\\n                secretFreq[s - \\'0\\']++;\\n                guessFreq[g - \\'0\\']++;\\n            }\\n        }\\n\\n        for (int i = 0; i < 10; i++) {\\n            cows += Math.min(secretFreq[i], guessFreq[i]);\\n        }\\n\\n        return bulls + \"A\" + cows + \"B\";\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643035,
                "title": "clean-and-crisp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        unordered_map<char, int> m;\\n        int b =0;\\n        int c=0;\\n        for(int i =0;i<secret.size();i++){\\n            if(secret[i]== guess[i]){\\n                b++;\\n            }\\n            else{\\n                m[secret[i]]++;\\n            }\\n        }\\n\\n        for(int i =0;i<secret.size();i++){\\n            if(secret[i]!= guess[i]){\\n                if(m[guess[i]]>0){\\n                    c++;\\n                    m[guess[i]]--;\\n                }\\n            }\\n        }\\n        string a = to_string(b) + \"A\" + to_string(c) + \"B\";\\n        return a ;\\n    }\\n};\\n//upvote pls",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        unordered_map<char, int> m;\\n        int b =0;\\n        int c=0;\\n        for(int i =0;i<secret.size();i++){\\n            if(secret[i]== guess[i]){\\n                b++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2778842,
                "title": "8ms-solution-c",
                "content": "Here is the code for C++ along with explanation in comments:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        vector<int> cowsS(10, 0);\\n        vector<int> cowsG(10, 0);\\n\\n        int bulls{0}, cows{0};\\n        for (int i{0}; i<secret.size(); ++i) {\\n            // if the numbers in the positions match then it\\'s a bull\\n            if (secret[i]==guess[i]) bulls++;\\n            else {\\n                // we add bulls corresponding to the numbers (eg, if secret[i]=5)\\n                // ascii of 5 is 53 and ascii of 0 is 48 and therefore 53-48 = 5 which is the poition given in secret[i]\\n                cowsS[secret[i]-\\'0\\']++;\\n                cowsG[guess[i]-\\'0\\']++;\\n            }\\n        }\\n\\n        for (int i{0}; i<cowsG.size(); ++i) {\\n            // let\\'s day cowsS[4]=5, it means that \\'4\\' is present 5 times in secret\\n            // same goes for cowsS. The minimum of either gives the number of matches (the extra ones can\\'t match)\\n            cows+=min(cowsG[i], cowsS[i]);\\n        }\\n\\n        // to_string converts ascii to integer. (eg., \\'5\\' to 5)\\n        return to_string(bulls)+\\'A\\'+to_string(cows)+\\'B\\';\\n\\n    }\\n};\\n```\\n\\n*Upvote solution if the explanation helped you understand* \\uD83D\\uDE04\\n\\n*Happy coding!*",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        vector<int> cowsS(10, 0);\\n        vector<int> cowsG(10, 0);\\n\\n        int bulls{0}, cows{0};\\n        for (int i{0}; i<secret.size(); ++i) {\\n            // if the numbers in the positions match then it\\'s a bull\\n            if (secret[i]==guess[i]) bulls++;\\n            else {\\n                // we add bulls corresponding to the numbers (eg, if secret[i]=5)\\n                // ascii of 5 is 53 and ascii of 0 is 48 and therefore 53-48 = 5 which is the poition given in secret[i]\\n                cowsS[secret[i]-\\'0\\']++;\\n                cowsG[guess[i]-\\'0\\']++;\\n            }\\n        }\\n\\n        for (int i{0}; i<cowsG.size(); ++i) {\\n            // let\\'s day cowsS[4]=5, it means that \\'4\\' is present 5 times in secret\\n            // same goes for cowsS. The minimum of either gives the number of matches (the extra ones can\\'t match)\\n            cows+=min(cowsG[i], cowsS[i]);\\n        }\\n\\n        // to_string converts ascii to integer. (eg., \\'5\\' to 5)\\n        return to_string(bulls)+\\'A\\'+to_string(cows)+\\'B\\';\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839635,
                "title": "c-super-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess)\\n    {\\n        map<char,int> secretMap, guessMap;\\n        int bulls = 0, cows = 0;\\n        \\n        for (size_t i = 0; i < secret.length(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bulls++;\\n            }\\n            else\\n            {\\n                secretMap[secret[i]]++;\\n                guessMap[guess[i]]++;\\n            }\\n        }\\n        \\n        for(auto x: secretMap)\\n        {\\n            if (guessMap.find(x.first) != guessMap.end())     \\n            {\\n                cows += min(x.second, guessMap[x.first]);\\n            }\\n        }\\n        \\n        return to_string(bulls) + \"A\" + to_string(cows) + \"B\";\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess)\\n    {\\n        map<char,int> secretMap, guessMap;\\n        int bulls = 0, cows = 0;\\n        \\n        for (size_t i = 0; i < secret.length(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bulls++;\\n            }\\n            else\\n            {\\n                secretMap[secret[i]]++;\\n                guessMap[guess[i]]++;\\n            }\\n        }\\n        \\n        for(auto x: secretMap)\\n        {\\n            if (guessMap.find(x.first) != guessMap.end())     \\n            {\\n                cows += min(x.second, guessMap[x.first]);\\n            }\\n        }\\n        \\n        return to_string(bulls) + \"A\" + to_string(cows) + \"B\";\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74785,
                "title": "my-concise-java-solution",
                "content": "    public String getHint(String secret, String guess) {\\n        int a=0,b=0;\\n        int[] digits=new int[10];\\n        for(int i=0;i<secret.length();i++){\\n            if(secret.charAt(i)==guess.charAt(i)) a++;\\n            else{\\n                if(++digits[secret.charAt(i)-'0']<=0) b++;\\n                if(--digits[guess.charAt(i)-'0']>=0) b++;\\n            }\\n        }\\n        return a+\"A\"+b+\"B\";\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String getHint(String secret, String guess) {\\n        int a=0,b=0;\\n        int[] digits=new int[10];\\n        for(int i=0;i<secret.length();i++){\\n            if(secret.charAt(i)==guess.charAt(i)) a++;\\n            else{\\n                if(++digits[secret.charAt(i)-'0']<=0) b++;\\n                if(--digits[guess.charAt(i)-'0']>=0) b++;\\n            }\\n        }\\n        return a+\"A\"+b+\"B\";\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 492044,
                "title": "javascript-93-83-one-pass",
                "content": "```\\n/**\\n * @param {string} secret\\n * @param {string} guess\\n * @return {string}\\n */\\nvar getHint = function(secret, guess) {\\n  let bull = 0;\\n  let cow = 0;\\n  const map = {};\\n  for (let i = 0; i < secret.length; i++) {\\n    const s = secret.charAt(i);\\n    const g = guess.charAt(i);\\n    if (s === g) {\\n      bull++;\\n    } else {\\n      if (map[s] < 0) cow++;\\n      if (map[g] > 0) cow++;\\n      map[s] = parseInt(map[s] || \\'0\\') + 1;\\n      map[g] = parseInt(map[g] || \\'0\\') - 1;\\n    }\\n  }\\n  return `${bull}A${cow}B`;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} secret\\n * @param {string} guess\\n * @return {string}\\n */\\nvar getHint = function(secret, guess) {\\n  let bull = 0;\\n  let cow = 0;\\n  const map = {};\\n  for (let i = 0; i < secret.length; i++) {\\n    const s = secret.charAt(i);\\n    const g = guess.charAt(i);\\n    if (s === g) {\\n      bull++;\\n    } else {\\n      if (map[s] < 0) cow++;\\n      if (map[g] > 0) cow++;\\n      map[s] = parseInt(map[s] || \\'0\\') + 1;\\n      map[g] = parseInt(map[g] || \\'0\\') - 1;\\n    }\\n  }\\n  return `${bull}A${cow}B`;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 74789,
                "title": "4ms-c-one-array-clean-solution",
                "content": "    class Solution {\\n    public:\\n        string getHint(string secret, string guess) {\\n            int map[10] = {0};\\n            int a = 0, b = 0;\\n            for (int i = 0; i < guess.size(); ++i) {\\n                if (guess[i] == secret[i]) ++a;\\n                ++map[guess[i] - '0'];\\n            }\\n            for (int i = 0; i < secret.size(); ++i) {\\n                if (map[secret[i] - '0']-- > 0) ++b;\\n            }\\n            return to_string(a) + \"A\" + to_string(b - a) + \"B\";\\n        }\\n    };\\n\\n`a` stores \"bulls\" while `b` stores sum of \"bulls\" and \"cows\". <br>\\nWe only need to build one hash map for \"guess\". First loop is to build hash map as well as to find \"bulls\". The second one is to find all \"guess\" numbers existing in \"secret\". When there is a match, we reduce the value for this number to handle situation like (\"11\" \"10\"). <br>\\nTime: O(n) Space: O(1)",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string getHint(string secret, string guess) {\\n            int map[10] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2724321,
                "title": "python-o-n-solution-using-hashmap-with-explanation-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        # Dictionary for Lookup\\n        lookup = Counter(secret)\\n        \\n        x, y = 0, 0\\n        \\n        # First finding numbers which are at correct position and updating x\\n        for i in range(len(guess)):\\n            if secret[i] == guess[i]:\\n                x+=1\\n                lookup[secret[i]]-=1\\n        \\n        # Finding numbers which are present in secret but not at correct position \\n        for i in range(len(guess)):\\n            if guess[i] in lookup and secret[i] != guess[i] and lookup[guess[i]]>0:\\n                y+=1\\n                lookup[guess[i]]-=1\\n        \\n\\t\\t# The reason for using two for loop is in this problem we have \\n\\t\\t# to give first priority to number which are at correct position,\\n\\t\\t# Therefore we are first updating x value\\n\\t\\t\\n        return \"{}A{}B\".format(x, y)\\n```\\n**If you\\'re interested in learning Python, check out my blog. https://www.python-techs.com/**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        # Dictionary for Lookup\\n        lookup = Counter(secret)\\n        \\n        x, y = 0, 0\\n        \\n        # First finding numbers which are at correct position and updating x\\n        for i in range(len(guess)):\\n            if secret[i] == guess[i]:\\n                x+=1\\n                lookup[secret[i]]-=1\\n        \\n        # Finding numbers which are present in secret but not at correct position \\n        for i in range(len(guess)):\\n            if guess[i] in lookup and secret[i] != guess[i] and lookup[guess[i]]>0:\\n                y+=1\\n                lookup[guess[i]]-=1\\n        \\n\\t\\t# The reason for using two for loop is in this problem we have \\n\\t\\t# to give first priority to number which are at correct position,\\n\\t\\t# Therefore we are first updating x value\\n\\t\\t\\n        return \"{}A{}B\".format(x, y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839588,
                "title": "java-simple-solution-o-n-with-video-explanation",
                "content": "<iframe width=\"650\" height=\"450\" src=\"https://www.youtube.com/embed/sEGa8F2pMS8\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    \\n    // O(n) time complexity , O(1) =>Space\\n    public String getHint(String secret, String guess) {\\n        int bulls =0;\\n        int cows =0;\\n        int[] secretFreq =new int[10];\\n        \\n        int[] guessFreq =new int[10];\\n        \\n        // O(n)\\n        for(int i=0;i<secret.length();i++){\\n            char secretChar = secret.charAt(i);\\n            \\n            char guessChar = guess.charAt(i);\\n            \\n            if(secretChar == guessChar){\\n                bulls++;\\n            } else{\\n                secretFreq[secretChar -\\'0\\']++;\\n                \\n                guessFreq[guessChar -\\'0\\']++;\\n            }\\n        }\\n        \\n        // O(1)\\n        for(int i=0;i<10;i++){\\n            cows += Math.min(secretFreq[i], guessFreq[i]);\\n        }\\n        \\n        return bulls +\"A\"+ cows +\"B\";\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    // O(n) time complexity , O(1) =>Space\\n    public String getHint(String secret, String guess) {\\n        int bulls =0;\\n        int cows =0;\\n        int[] secretFreq =new int[10];\\n        \\n        int[] guessFreq =new int[10];\\n        \\n        // O(n)\\n        for(int i=0;i<secret.length();i++){\\n            char secretChar = secret.charAt(i);\\n            \\n            char guessChar = guess.charAt(i);\\n            \\n            if(secretChar == guessChar){\\n                bulls++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 513030,
                "title": "java-simple-solution-beats-100-in-time",
                "content": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bull = 0;\\n        int[] countsSecret = new int[10];\\n        int[] countsGuess = new int[10];\\n        for (int i = 0; i < secret.length(); i++) {\\n            char a = secret.charAt(i);\\n            char b = guess.charAt(i);\\n            if (a == b)\\n                bull ++;\\n            else {\\n                countsSecret[a-\\'0\\'] ++;\\n                countsGuess[b-\\'0\\'] ++;\\n            }\\n        }\\n        int count = 0;\\n        for (int i = 0; i < 10; i++)\\n            count += Math.min(countsSecret[i], countsGuess[i]);\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(bull).append(\"A\").append(count).append(\"B\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bull = 0;\\n        int[] countsSecret = new int[10];\\n        int[] countsGuess = new int[10];\\n        for (int i = 0; i < secret.length(); i++) {\\n            char a = secret.charAt(i);\\n            char b = guess.charAt(i);\\n            if (a == b)\\n                bull ++;\\n            else {\\n                countsSecret[a-\\'0\\'] ++;\\n                countsGuess[b-\\'0\\'] ++;\\n            }\\n        }\\n        int count = 0;\\n        for (int i = 0; i < 10; i++)\\n            count += Math.min(countsSecret[i], countsGuess[i]);\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(bull).append(\"A\").append(count).append(\"B\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402832,
                "title": "a-few-solutions",
                "content": "For each `i`<sup>th</sup> digit in `A` and `B`, there are 2 use cases to consider:\\n* **Case 1:** if it\\'s the same digit, then increment `bull` for the digit\\n* **Case 2:** if it\\'s *not* the same digit, then increment the digit count for `A` and `B` via `\\uD83D\\uDDFA` maps `first` and `second` correspondingly\\n\\nThen `cow` is the accumulated minimum count of each digit in `\\uD83D\\uDDFA` maps `first` and `second`.\\n\\n---\\n\\n*Javascript*\\n```\\nlet getHint = (A, B, bull = 0, cow = 0) => {\\n    let first  = Array(10).fill(0), \\n        second = Array(10).fill(0);\\n    for (let i = 0; i < A.length; ++i)\\n        if (A[i] == B[i])\\n            ++bull;               // case 1: same digit, increment bull\\n        else\\n            ++first[A[i]],        // case 2: diff digit, increment corresponding digit count\\n\\t\\t\\t++second[B[i]];\\n    for (let i = 0; i < 10; ++i)\\n        cow += Math.min(first[i], second[i]);\\n    return `${bull}A${cow}B`;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def getHint(self, A: str, B: str, bull = 0, cow = 0) -> str:\\n        A = [int(c) for c in A]\\n        B = [int(c) for c in B]\\n        first, second = [0] * 10, [0] * 10\\n        for i in range(len(A)):\\n            if A[i] == B[i]:\\n                bull += 1             # case 1: same digit, increment bull\\n            else:\\n                first[A[i]] += 1      # case 2: diff digit, increment corresponding digit count\\n                second[B[i]] += 1\\n        for i in range(10):\\n            cow += min(first[i], second[i])\\n        return f\\'{bull}A{cow}B\\'\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    string getHint(string A, string B, int bull = 0, int cow = 0) {\\n        VI first(10), second(10);\\n        for (auto i{ 0 }; i < A.size(); ++i)\\n            if (A[i] == B[i])\\n                ++bull;                  // case 1: same digit, increment bull\\n            else\\n                ++first[A[i] - \\'0\\'],     // case 2: diff digit, increment corresponding digit count\\n\\t\\t\\t\\t++second[B[i] - \\'0\\'];\\n        for (auto i{ 0 }; i < 10; ++i)\\n            cow += min(first[i], second[i]);\\n        ostringstream hint;\\n        hint << bull << \"A\"\\n             << cow  << \"B\";\\n        return hint.str();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet getHint = (A, B, bull = 0, cow = 0) => {\\n    let first  = Array(10).fill(0), \\n        second = Array(10).fill(0);\\n    for (let i = 0; i < A.length; ++i)\\n        if (A[i] == B[i])\\n            ++bull;               // case 1: same digit, increment bull\\n        else\\n            ++first[A[i]],        // case 2: diff digit, increment corresponding digit count\\n\\t\\t\\t++second[B[i]];\\n    for (let i = 0; i < 10; ++i)\\n        cow += Math.min(first[i], second[i]);\\n    return `${bull}A${cow}B`;\\n};\\n```\n```\\nclass Solution:\\n    def getHint(self, A: str, B: str, bull = 0, cow = 0) -> str:\\n        A = [int(c) for c in A]\\n        B = [int(c) for c in B]\\n        first, second = [0] * 10, [0] * 10\\n        for i in range(len(A)):\\n            if A[i] == B[i]:\\n                bull += 1             # case 1: same digit, increment bull\\n            else:\\n                first[A[i]] += 1      # case 2: diff digit, increment corresponding digit count\\n                second[B[i]] += 1\\n        for i in range(10):\\n            cow += min(first[i], second[i])\\n        return f\\'{bull}A{cow}B\\'\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    string getHint(string A, string B, int bull = 0, int cow = 0) {\\n        VI first(10), second(10);\\n        for (auto i{ 0 }; i < A.size(); ++i)\\n            if (A[i] == B[i])\\n                ++bull;                  // case 1: same digit, increment bull\\n            else\\n                ++first[A[i] - \\'0\\'],     // case 2: diff digit, increment corresponding digit count\\n\\t\\t\\t\\t++second[B[i] - \\'0\\'];\\n        for (auto i{ 0 }; i < 10; ++i)\\n            cow += min(first[i], second[i]);\\n        ostringstream hint;\\n        hint << bull << \"A\"\\n             << cow  << \"B\";\\n        return hint.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74697,
                "title": "java-without-hash-3-ms",
                "content": "    public String getHint(String secret, String guess) {\\n        char[] s = secret.toCharArray();\\n        char[] g = guess.toCharArray();\\n        int a = 0, b = 0;\\n        int[] count = new int[10];\\n        for(int i = 0; i < s.length; i++){\\n            if(s[i] == g[i]) a++;\\n            else{\\n                if(count[s[i] - '0']++ < 0) b++;\\n                if(count[g[i] - '0']-- > 0) b++;\\n            }\\n        }\\n        return a+\"A\"+b+\"B\";\\n    }",
                "solutionTags": [],
                "code": "    public String getHint(String secret, String guess) {\\n        char[] s = secret.toCharArray();\\n        char[] g = guess.toCharArray();\\n        int a = 0, b = 0;\\n        int[] count = new int[10];\\n        for(int i = 0; i < s.length; i++){\\n            if(s[i] == g[i]) a++;\\n            else{\\n                if(count[s[i] - '0']++ < 0) b++;\\n                if(count[g[i] - '0']-- > 0) b++;\\n            }\\n        }\\n        return a+\"A\"+b+\"B\";\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 74795,
                "title": "python-solution-using-a-counter",
                "content": "I think the most tricky part is just to understand what cows mean... \\n\\n    class Solution(object):\\n    def getHint(self, secret, guess):\\n        \"\"\"\\n        :type secret: str\\n        :type guess: str\\n        :rtype: str\\n        \"\"\"\\n        from collections import Counter\\n        c = Counter(secret)\\n        bulls, cows = 0,0\\n        for i in xrange(len(secret)):\\n            if secret[i]==guess[i]:\\n                bulls += 1\\n                c[secret[i]] -= 1\\n        for i in xrange(len(secret)):\\n            if secret[i]!=guess[i]:\\n                if guess[i] in c and c[guess[i]]>0:\\n                    c[guess[i]] -= 1\\n                    cows += 1 \\n        return str(bulls)+'A'+str(cows)+'B'",
                "solutionTags": [
                    "Python"
                ],
                "code": "I think the most tricky part is just to understand what cows mean... \\n\\n    class Solution(object):\\n    def getHint(self, secret, guess):\\n        \"\"\"\\n        :type secret: str\\n        :type guess: str\\n        :rtype: str\\n        \"\"\"\\n        from collections import Counter\\n        c = Counter(secret)\\n        bulls, cows = 0,0\\n        for i in xrange(len(secret)):\\n            if secret[i]==guess[i]:\\n                bulls += 1\\n                c[secret[i]] -= 1\\n        for i in xrange(len(secret)):\\n            if secret[i]!=guess[i]:\\n                if guess[i] in c and c[guess[i]]>0:\\n                    c[guess[i]] -= 1\\n                    cows += 1 \\n        return str(bulls)+'A'+str(cows)+'B'",
                "codeTag": "Java"
            },
            {
                "id": 638343,
                "title": "python-very-simple-space-o-1-solution-without-fancy-tricks",
                "content": "It\\'s straightforward to calculate bulls - if the characters at the same index are identical in two strings, we add 1 to bulls.\\nThe core idea to calculate cows is to match the rest characters (the ones unmatched in bulls) as much as possible. We calculate it as (\\'-\\' means minus) :\\n\\n**cows = characters matched at different index = total number of characters in guess - bulls(i.e. number of characters matched at the same index) - number of unmatched characters**\\n\\nIt\\'s straighforward to get total number of characters in guess and bulls, the only trick part is how to calculate number of unmatched characters. Here\\'s how the algorithm works. We maintain a counter on the fly. Whenever the two characters differ (cannot be counted as bulls), we add 1 to secret character\\'s count because it can be used to cancel out a character shown up in guess, and subtract 1 from guess character\\'s count to do the cancel-out. If there are enough characters in secret to cancel out, the counter remains non-negative. As for the negative values, we know there are character cannot be matched, and the amount of the characters is its absolute value. So the sum of all negative value\\'s absolute value is the 3rd term. \\n\\n```python\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        bulls = 0\\n        cnt = Counter()\\n        for c1, c2 in zip(secret, guess):\\n            if c1 == c2:\\n                bulls += 1\\n            else:\\n                cnt[c1] += 1\\n                cnt[c2] -= 1\\n        cows = len(secret) - bulls - sum(-i for i in cnt.values() if i < 0)\\n        return f\"{bulls}A{cows}B\"\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        bulls = 0\\n        cnt = Counter()\\n        for c1, c2 in zip(secret, guess):\\n            if c1 == c2:\\n                bulls += 1\\n            else:\\n                cnt[c1] += 1\\n                cnt[c2] -= 1\\n        cows = len(secret) - bulls - sum(-i for i in cnt.values() if i < 0)\\n        return f\"{bulls}A{cows}B\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74700,
                "title": "easy-c-solution-with-unordered-map",
                "content": "    string getHint(string secret, string guess) {\\n    \\tunordered_map<char, int> mp;\\n    \\tint n = secret.size(), cA = 0, cB = 0;\\n    \\tfor (int i = 0; i < n; i++) {\\n    \\t\\tif (secret[i] == guess[i]) {\\n    \\t\\t\\tcA++;\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\tmp[secret[i]]++;\\n    \\t}\\n    \\tfor (int i = 0; i < n; i++) {\\n    \\t\\tif (secret[i] != guess[i] && mp[guess[i]] > 0) {\\n    \\t\\t\\tmp[guess[i]]--;\\n    \\t\\t\\tcB++;\\n    \\t\\t}\\n    \\t}\\n    \\treturn to_string(cA) + 'A' + to_string(cB) + 'B';\\n    }",
                "solutionTags": [],
                "code": "    string getHint(string secret, string guess) {\\n    \\tunordered_map<char, int> mp;\\n    \\tint n = secret.size(), cA = 0, cB = 0;\\n    \\tfor (int i = 0; i < n; i++) {\\n    \\t\\tif (secret[i] == guess[i]) {\\n    \\t\\t\\tcA++;\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\tmp[secret[i]]++;\\n    \\t}\\n    \\tfor (int i = 0; i < n; i++) {\\n    \\t\\tif (secret[i] != guess[i] && mp[guess[i]] > 0) {\\n    \\t\\t\\tmp[guess[i]]--;\\n    \\t\\t\\tcB++;\\n    \\t\\t}\\n    \\t}\\n    \\treturn to_string(cA) + 'A' + to_string(cB) + 'B';\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 178625,
                "title": "swift-solution-40ms",
                "content": "```\\nclass Solution {\\n    func getHint(_ secret: String, _ guess: String) -> String {\\n        var bull = 0\\n        var cow = 0\\n        \\n        let s = Array(secret)\\n        let g = Array(guess)\\n        var num = [Character : Int]()\\n        \\n        for i in 0 ..< s.count {\\n            if s[i] == g[i] {\\n                bull += 1\\n            } else {\\n                if num[s[i], default:0] < 0 {\\n                    cow += 1\\n                }\\n                if num[g[i], default:0] > 0 {\\n                    cow += 1\\n                }\\n                num[s[i], default:0] += 1\\n                num[g[i], default:0] -= 1\\n            }\\n        }\\n        return \"\\\\(bull)A\\\\(cow)B\"\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func getHint(_ secret: String, _ guess: String) -> String {\\n        var bull = 0\\n        var cow = 0\\n        \\n        let s = Array(secret)\\n        let g = Array(guess)\\n        var num = [Character : Int]()\\n        \\n        for i in 0 ..< s.count {\\n            if s[i] == g[i] {\\n                bull += 1\\n            } else {\\n                if num[s[i], default:0] < 0 {\\n                    cow += 1\\n                }\\n                if num[g[i], default:0] > 0 {\\n                    cow += 1\\n                }\\n                num[s[i], default:0] += 1\\n                num[g[i], default:0] -= 1\\n            }\\n        }\\n        return \"\\\\(bull)A\\\\(cow)B\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74651,
                "title": "very-straightforward-solution",
                "content": "Also viewable [here](https://github.com/fishercoder1534/Leetcode/blob/master/leetcode-algorithms/src/main/java/com/stevesun/solutions/BullsandCows.java).\\n```\\n\\n    public String getHint(String secret, String guess) {\\n        int[] secretCows = new int[10];\\n        int[] guessCows = new int[10];\\n        int bulls = 0;\\n        for(int i = 0; i < secret.length(); i++){\\n            if(guess.charAt(i) == secret.charAt(i)) bulls++;\\n            else{\\n                secretCows[Character.getNumericValue(secret.charAt(i))] ++;\\n                guessCows[Character.getNumericValue(guess.charAt(i))] ++;\\n            }\\n        }\\n        int cows = 0;\\n        for(int i = 0; i < 10; i++){\\n            cows += Math.min(secretCows[i], guessCows[i]);\\n        }\\n        return bulls + \"A\" + cows + \"B\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public String getHint(String secret, String guess) {\\n        int[] secretCows = new int[10];\\n        int[] guessCows = new int[10];\\n        int bulls = 0;\\n        for(int i = 0; i < secret.length(); i++){\\n            if(guess.charAt(i) == secret.charAt(i)) bulls++;\\n            else{\\n                secretCows[Character.getNumericValue(secret.charAt(i))] ++;\\n                guessCows[Character.getNumericValue(guess.charAt(i))] ++;\\n            }\\n        }\\n        int cows = 0;\\n        for(int i = 0; i < 10; i++){\\n            cows += Math.min(secretCows[i], guessCows[i]);\\n        }\\n        return bulls + \"A\" + cows + \"B\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 74627,
                "title": "java-solution-beats-99-no-hashmap-only-one-loop",
                "content": "```\\npublic class Solution {\\n    public String getHint(String secret, String guess) {\\n        int s, g, size = secret.length();\\n        int bulls = 0, cows = 0;\\n        int [] nums = new int [10];\\n        for (int i = 0; i < size; i++) {\\n            s = secret.charAt(i) - '0';\\n            g = guess.charAt(i) - '0';\\n            if (s == g)\\n                bulls ++;\\n            else{\\n                if (nums[s] < 0)\\n                    cows++;\\n                nums[s]++;\\n                if (nums[g] > 0)\\n                    cows++;\\n                nums[g]--;\\n            }\\n        }\\n        return bulls + \"A\" + cows + \"B\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String getHint(String secret, String guess) {\\n        int s, g, size = secret.length();\\n        int bulls = 0, cows = 0;\\n        int [] nums = new int [10];\\n        for (int i = 0; i < size; i++) {\\n            s = secret.charAt(i) - '0';\\n            g = guess.charAt(i) - '0';\\n            if (s == g)\\n                bulls ++;\\n            else{\\n                if (nums[s] < 0)\\n                    cows++;\\n                nums[s]++;\\n                if (nums[g] > 0)\\n                    cows++;\\n                nums[g]--;\\n            }\\n        }\\n        return bulls + \"A\" + cows + \"B\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74709,
                "title": "my-one-pass-solution-in-c",
                "content": "    class Solution {\\n    public:\\n        string getHint(string secret, string guess) {\\n            vector<int>tb_guess(10),tb_secret(10);\\n            int A=0,B=0;\\n            for (int i=0;i<secret.size();++i){\\n                if (secret[i]==guess[i]) A++;\\n                else {\\n                    tb_guess[guess[i]-'0']++;\\n                    tb_secret[secret[i]-'0']++;\\n                }\\n            }\\n            for (int i=0;i<10;++i){\\n                B=B+ min(tb_guess[i],tb_secret[i]);\\n            }\\n            return to_string(A)+'A'+to_string(B)+'B';\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string getHint(string secret, string guess) {\\n            vector<int>tb_guess(10),tb_secret(10);\\n            int A=0,B=0;\\n            for (int i=0;i<secret.size();++i){\\n                if (secret[i]==guess[i]) A++;\\n                else {\\n                    tb_guess[guess[i]-'0']++;\\n                    tb_secret[secret[i]-'0']++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 74757,
                "title": "4ms-concise-c-solution",
                "content": "    class Solution {\\n    public:\\n        string getHint(string secret, string guess) {\\n            vector<int> s(10, 0); // s[i]: number of occurrences of i in secret\\n            vector<int> g(10, 0); // g[i]: number of occurrences of i in guess\\n            int A = 0;\\n            for(int i = 0; i < secret.size(); ++i){\\n                if(secret[i] == guess[i])\\n                    ++A;\\n                s[secret[i] - '0']++;\\n                g[guess[i] - '0']++;\\n            }\\n            int B = -A;\\n            for(int i = 0; i < 10; ++i){\\n                B += min(s[i], g[i]);\\n            }\\n            return to_string(A) + \"A\" + to_string(B) + \"B\";\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string getHint(string secret, string guess) {\\n            vector<int> s(10, 0); // s[i]: number of occurrences of i in secret\\n            vector<int> g(10, 0); // g[i]: number of occurrences of i in guess\\n            int A = 0;\\n            for(int i = 0; i < secret.size(); ++i){\\n                if(secret[i] == guess[i])\\n                    ++A;\\n                s[secret[i] - '0']++;\\n                g[guess[i] - '0']++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3238683,
                "title": "299-time-98-43-and-space-98-71-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define the function getHint that takes two strings secret and guess as input and returns a string.\\n2. Initialize two dictionaries secret_dict and guess_dict to store the frequencies of digits in the secret and guess strings, respectively.\\n3. Initialize two variables bulls and cows to 0, to keep track of the number of bulls and cows.\\n4. Loop through the length of the secret string and compare each digit in the secret string with the corresponding digit in the guess string.\\n5. If the digits are the same, increment the bulls count and decrement the frequency of that digit in both secret_dict and guess_dict.\\n6. If the digits are different, check if the current digit in the guess string exists in secret_dict and its frequency is greater than 0. If so, increment the cows count and decrement the frequency of that digit in secret_dict.\\n7. Finally, return the formatted hint string as \"xAyB\", where x is the number of bulls and y is the number of cows.\\n\\n# Complexity\\n- Time complexity:\\n98.43%\\n\\n- Space complexity:\\n98.71%\\n\\n# Code\\n```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        secret_dict = {}\\n        guess_dict = {}\\n        bulls = 0\\n        cows = 0\\n        \\n        for i in range(len(secret)):\\n            if secret[i] == guess[i]:\\n                bulls += 1\\n            else:\\n                if secret[i] in guess_dict and guess_dict[secret[i]] > 0:\\n                    cows += 1\\n                    guess_dict[secret[i]] -= 1\\n                else:\\n                    secret_dict[secret[i]] = secret_dict.get(secret[i], 0) + 1\\n                if guess[i] in secret_dict and secret_dict[guess[i]] > 0:\\n                    cows += 1\\n                    secret_dict[guess[i]] -= 1\\n                else:\\n                    guess_dict[guess[i]] = guess_dict.get(guess[i], 0) + 1\\n        \\n        return str(bulls) + \"A\" + str(cows) + \"B\"\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        secret_dict = {}\\n        guess_dict = {}\\n        bulls = 0\\n        cows = 0\\n        \\n        for i in range(len(secret)):\\n            if secret[i] == guess[i]:\\n                bulls += 1\\n            else:\\n                if secret[i] in guess_dict and guess_dict[secret[i]] > 0:\\n                    cows += 1\\n                    guess_dict[secret[i]] -= 1\\n                else:\\n                    secret_dict[secret[i]] = secret_dict.get(secret[i], 0) + 1\\n                if guess[i] in secret_dict and secret_dict[guess[i]] > 0:\\n                    cows += 1\\n                    secret_dict[guess[i]] -= 1\\n                else:\\n                    guess_dict[guess[i]] = guess_dict.get(guess[i], 0) + 1\\n        \\n        return str(bulls) + \"A\" + str(cows) + \"B\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218426,
                "title": "java-0ms-beat",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int secdigs[] = new int[10];\\n        int guessdigs[] = new int[10];\\n        int bull = 0, cow = 0;\\n\\n        for(int i = 0; i < secret.length() ; i ++) {\\n            if(secret.charAt(i) == guess.charAt(i)) {\\n                bull ++;\\n            }\\n            else {\\n                secdigs[secret.charAt(i) - \\'0\\'] ++;\\n                guessdigs[guess.charAt(i) - \\'0\\'] ++;\\n            }\\n        }\\n\\n        for(int i = 0; i < 10; i ++) {\\n            int minVal = secdigs[i];\\n            if(minVal > guessdigs[i]) minVal = guessdigs[i];\\n         \\n            cow += minVal;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(bull).append(\"A\").append(cow).append(\"B\");\\n\\n        return sb.toString();\\n    }\\n}\\n```\\n![8873f9b1-dfa4-4d9c-bb67-1b6db9d65e35_1674992431.3815322.jpeg](https://assets.leetcode.com/users/images/69dc97c3-38d1-4b13-b90b-8c0777257008_1677074952.978375.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int secdigs[] = new int[10];\\n        int guessdigs[] = new int[10];\\n        int bull = 0, cow = 0;\\n\\n        for(int i = 0; i < secret.length() ; i ++) {\\n            if(secret.charAt(i) == guess.charAt(i)) {\\n                bull ++;\\n            }\\n            else {\\n                secdigs[secret.charAt(i) - \\'0\\'] ++;\\n                guessdigs[guess.charAt(i) - \\'0\\'] ++;\\n            }\\n        }\\n\\n        for(int i = 0; i < 10; i ++) {\\n            int minVal = secdigs[i];\\n            if(minVal > guessdigs[i]) minVal = guessdigs[i];\\n         \\n            cow += minVal;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(bull).append(\"A\").append(cow).append(\"B\");\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845548,
                "title": "a-simple-and-clear-python-solution",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef getHint(self, secret: str, guess: str) -> str:\\n\\t\\t\\tA = 0\\n\\t\\t\\tB = 0\\n\\t\\t\\tfor index in range(len(secret) - 1, -1, -1):\\n\\t\\t\\t\\tif secret[index] == guess[index]:\\n\\t\\t\\t\\t\\tA += 1\\n\\t\\t\\t\\t\\tsecret = secret[: index] + secret[index + 1 :]\\n\\t\\t\\t\\t\\tguess = guess[: index] + guess[index + 1 :]\\n        \\n\\t\\t\\tfor first in secret:\\n\\t\\t\\t\\tif first in guess:\\n\\t\\t\\t\\t\\tB += 1\\n\\t\\t\\t\\t\\tguess = guess.replace(first, \"\", 1)\\n\\n\\t\\t\\treturn f\"{A}A{B}B\"\\n\\t\\t\\'\\'\\'\\nThe first loop finds identities found in the same index\\nThe second loop finds identities that are not in the same index",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef getHint(self, secret: str, guess: str) -> str:\\n\\t\\t\\tA = 0\\n\\t\\t\\tB = 0\\n\\t\\t\\tfor index in range(len(secret) - 1, -1, -1):\\n\\t\\t\\t\\tif secret[index] == guess[index]:\\n\\t\\t\\t\\t\\tA += 1\\n\\t\\t\\t\\t\\tsecret = secret[: index] + secret[index + 1 :]\\n\\t\\t\\t\\t\\tguess = guess[: index] + guess[index + 1 :]\\n        \\n\\t\\t\\tfor first in secret:\\n\\t\\t\\t\\tif first in guess:\\n\\t\\t\\t\\t\\tB += 1\\n\\t\\t\\t\\t\\tguess = guess.replace(first, \"\", 1)\\n\\n\\t\\t\\treturn f\"{A}",
                "codeTag": "Java"
            },
            {
                "id": 841078,
                "title": "short-and-easy-solution-in-c-o-n-o-1-space",
                "content": "We can calculate count of ```Bulls``` easily by just couting where characters matches in the 2 given strings. Also, in the same iteration when characters don\\'t match we can keep their count in mp1(for ```secret``` ) and mp2(for ```guess```) . Then we can iterate one of these constant size array and find the minimum of count of all the characters in both of these arrays and in that way we can be sure that that this character occurs atleast this much time in both strings and hence this number contributes to the ```Cow``` variable.\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int mp1[10] = {0};\\n        int mp2[10] = {0};\\n        int bull=0,cow=0;\\n        for(int i=0;i<secret.length();i++) {\\n            if(secret[i]==guess[i]) {\\n                bull++;\\n            } else {\\n                mp1[secret[i]-\\'0\\']++;\\n                mp2[guess[i]-\\'0\\']++;\\n            }\\n        }\\n        \\n        for(int i=0;i<10;i++) {\\n            if(mp1[i]!=0 && mp2[i]!=0) {\\n                cow += min(mp1[i], mp2[i]);\\n                \\n            }\\n        }\\n        \\n        return to_string(bull) + \"A\" + to_string(cow) + \"B\";\\n             \\n    }\\n};\\n```\\n\\nRuntime : 8ms\\nMemory Usage: 6.5 MB",
                "solutionTags": [
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```Bulls```\n```secret```\n```guess```\n```Cow```\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int mp1[10] = {0};\\n        int mp2[10] = {0};\\n        int bull=0,cow=0;\\n        for(int i=0;i<secret.length();i++) {\\n            if(secret[i]==guess[i]) {\\n                bull++;\\n            } else {\\n                mp1[secret[i]-\\'0\\']++;\\n                mp2[guess[i]-\\'0\\']++;\\n            }\\n        }\\n        \\n        for(int i=0;i<10;i++) {\\n            if(mp1[i]!=0 && mp2[i]!=0) {\\n                cow += min(mp1[i], mp2[i]);\\n                \\n            }\\n        }\\n        \\n        return to_string(bull) + \"A\" + to_string(cow) + \"B\";\\n             \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840082,
                "title": "python-simple-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=pHm7VOMzJpI)\\nhttps://www.youtube.com/watch?v=pHm7VOMzJpI\\n```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        bulls = 0\\n        bucket = [0] * 10\\n        \\n        for s, g in zip(secret, guess):\\n            if s == g:\\n                bulls += 1\\n            else:\\n                bucket[int(s)] += 1\\n                bucket[int(g)] -= 1\\n        return f\\'{bulls}A{len(secret) - bulls - sum(x for x in bucket if x > 0)}B\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        bulls = 0\\n        bucket = [0] * 10\\n        \\n        for s, g in zip(secret, guess):\\n            if s == g:\\n                bulls += 1\\n            else:\\n                bucket[int(s)] += 1\\n                bucket[int(g)] -= 1\\n        return f\\'{bulls}A{len(secret) - bulls - sum(x for x in bucket if x > 0)}B\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839438,
                "title": "bulls-and-cows-o-n-time-clear-solution",
                "content": "```\\nclass Solution:\\n    \\n    def getHint(self, secret, guess):\\n        \\n        # char freq map for guests\\n\\t\\t\\n        freqMap = {}\\n        \\n        for num in guess:\\n            \\n            if not num in freqMap:\\n                freqMap[num] = 0\\n                \\n            freqMap[num] += 1\\n\\t\\t\\t\\n\\t\\t\\t\\n            \\n        # count bulls\\n\\t\\t\\n        bulls = 0\\n        \\n        for i in range(len(guess)):\\n            \\n            if secret[i] == guess[i]:\\n                bulls += 1\\n               \\n\\t\\t\\t   \\n        \\n        # count total number of matching chars:\\n        \\n        total = 0\\n        \\n        for num in secret:\\n            \\n            if num in freqMap:\\n                total += 1\\n                \\n                if freqMap[num] == 1:\\n                    del freqMap[num]\\n                    \\n                else:\\n                    freqMap[num] -= 1\\n                    \\n                    \\n        # cows = total - bulls\\n        cows = total - bulls\\n        \\n        return str(bulls) + \"A\" + str(cows) + \"B\"\\n        \\n              \\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def getHint(self, secret, guess):\\n        \\n        # char freq map for guests\\n\\t\\t\\n        freqMap = {}\\n        \\n        for num in guess:\\n            \\n            if not num in freqMap:\\n                freqMap[num] = 0\\n                \\n            freqMap[num] += 1\\n\\t\\t\\t\\n\\t\\t\\t\\n            \\n        # count bulls\\n\\t\\t\\n        bulls = 0\\n        \\n        for i in range(len(guess)):\\n            \\n            if secret[i] == guess[i]:\\n                bulls += 1\\n               \\n\\t\\t\\t   \\n        \\n        # count total number of matching chars:\\n        \\n        total = 0\\n        \\n        for num in secret:\\n            \\n            if num in freqMap:\\n                total += 1\\n                \\n                if freqMap[num] == 1:\\n                    del freqMap[num]\\n                    \\n                else:\\n                    freqMap[num] -= 1\\n                    \\n                    \\n        # cows = total - bulls\\n        cows = total - bulls\\n        \\n        return str(bulls) + \"A\" + str(cows) + \"B\"\\n        \\n              \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 350998,
                "title": "solution-in-python-3-beats-98",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n    \\ts, g, i = list(secret), list(guess), 0\\n    \\twhile i < len(s):\\n    \\t\\tif g[i] == s[i]:\\n    \\t\\t\\tdel s[i], g[i]\\n    \\t\\t\\ti -= 1\\n    \\t\\ti += 1\\n    \\treturn str(len(secret)-len(s))+\\'A\\'+str(sum((Counter(s)&Counter(g)).values()))+\\'B\\'\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n    \\ts, g, i = list(secret), list(guess), 0\\n    \\twhile i < len(s):\\n    \\t\\tif g[i] == s[i]:\\n    \\t\\t\\tdel s[i], g[i]\\n    \\t\\t\\ti -= 1\\n    \\t\\ti += 1\\n    \\treturn str(len(secret)-len(s))+\\'A\\'+str(sum((Counter(s)&Counter(g)).values()))+\\'B\\'\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 74705,
                "title": "java-solution-without-hashtable",
                "content": " public String getHint(String secret, String guess) {\\n\\n        int bull=0;\\n        int cow=0;\\n        int[] marks=new int[10];\\n        int[] markg=new int[10];\\n        for(int i =0;i<secret.length();i++){\\n            if(secret.charAt(i)==guess.charAt(i))\\n            bull++;\\n            marks[secret.charAt(i)-'0']++;\\n            markg[guess.charAt(i)-'0']++;\\n        }\\n        for(int i =0;i<10;i++){\\n            cow+=Math.min(marks[i],markg[i]);\\n        }\\n        StringBuffer sb=new StringBuffer();\\n        sb.append(bull);\\n        sb.append(\"A\");\\n        sb.append(cow-bull);\\n        sb.append(\"B\");\\n        String returnStr=new String(sb);\\n        return returnStr;\\n\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": " public String getHint(String secret, String guess) {\\n\\n        int bull=0;\\n        int cow=0;\\n        int[] marks=new int[10];\\n        int[] markg=new int[10];\\n        for(int i =0;i<secret.length();i++){\\n            if(secret.charAt(i)==guess.charAt(i))\\n            bull++;\\n            marks[secret.charAt(i)-'0']++;\\n            markg[guess.charAt(i)-'0']++;\\n        }\\n        for(int i =0;i<10;i++){\\n            cow+=Math.min(marks[i],markg[i]);\\n        }\\n        StringBuffer sb=new StringBuffer();\\n        sb.append(bull);\\n        sb.append(\"A\");\\n        sb.append(cow-bull);\\n        sb.append(\"B\");\\n        String returnStr=new String(sb);\\n        return returnStr;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 74769,
                "title": "c-simple-solution-using-array-with-explaination-4ms",
                "content": "If **secret[i]** and **guess[i]** match that's a bull - that's simple. Trickier part is about cows.\\nWe use array **numbers** to remember if the any of digits (from 0 to 9) is found in either *secret* or *guess*.\\nWhen digit is found in *secret* we decrement value of **numbers[digit]** if digit is found in *guess* we increment it. \\n\\nThis is how we count cows:\\n\\n 1. if we need to decrement **numbers[digit]** and its current value is positive, that means we have seen it before in a different position, hence *cows++*;\\n 2. if we need to increment **numbers[digit]** and its current value is negative, that means we've seen it as well. Again, *cows++*;\\n\\ncode:\\n\\n    string getHint(string secret, string guess) {\\n        int length = secret.length(), bulls=0,cows=0;\\n        int numbers[10];\\n        memset(numbers, 0, sizeof(int)*10);\\n       \\n        for(int i=0;i<length;i++)\\n        {\\n            int a = secret[i]-'0';\\n            int b = guess[i]-'0';\\n            \\n            if(a==b){ bulls++; }\\n            else\\n            {\\n                cows+=(int)(numbers[a]>0) + (int)(numbers[b]<0); \\n                numbers[a]--;\\n                numbers[b]++;\\n            }\\n        }\\n        \\n        return to_string(bulls)+'A'+to_string(cows)+'B';\\n    }",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "If **secret[i]** and **guess[i]** match that's a bull - that's simple. Trickier part is about cows.\\nWe use array **numbers** to remember if the any of digits (from 0 to 9) is found in either *secret* or *guess*.\\nWhen digit is found in *secret* we decrement value of **numbers[digit]** if digit is found in *guess* we increment it. \\n\\nThis is how we count cows:\\n\\n 1. if we need to decrement **numbers[digit]** and its current value is positive, that means we have seen it before in a different position, hence *cows++*;\\n 2. if we need to increment **numbers[digit]** and its current value is negative, that means we've seen it as well. Again, *cows++*;\\n\\ncode:\\n\\n    string getHint(string secret, string guess) {\\n        int length = secret.length(), bulls=0,cows=0;\\n        int numbers[10];\\n        memset(numbers, 0, sizeof(int)*10);\\n       \\n        for(int i=0;i<length;i++)\\n        {\\n            int a = secret[i]-'0';\\n            int b = guess[i]-'0';\\n            \\n            if(a==b){ bulls++; }\\n            else\\n            {\\n                cows+=(int)(numbers[a]>0) + (int)(numbers[b]<0); \\n                numbers[a]--;\\n                numbers[b]++;\\n            }\\n        }\\n        \\n        return to_string(bulls)+'A'+to_string(cows)+'B';\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 74807,
                "title": "two-ac-c-solution-92-ms-and-4-ms",
                "content": "The basic idea of this problem is calculate Bulls number firstly, then calculate Cows number.\\nThis is my first solution code:\\n\\n    string getHint(string s, string g) \\n    {\\n    \\tif (s.empty())\\n    \\t\\treturn \"0A0B\";\\n    \\tint i, j, a, b;\\n    \\tint sz = s.size();\\n    \\ta = b = 0;\\n    \\tvector<int> vs(sz, 1);\\n    \\tvector<int> vg(sz, 1);\\n    \\tfor (i = 0; i < sz; ++i)\\n    \\t{\\n    \\t\\tif (s[i] == g[i])\\n    \\t\\t{\\n    \\t\\t\\t++a;\\n    \\t\\t\\tvs[i] = vg[i] = 0;\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t}\\n    \\tfor (i = 0; i < sz; ++i)\\n    \\t{\\n    \\t\\tif (0 == vs[i])\\n    \\t\\t\\tcontinue;\\n    \\t\\tfor (j = 0; j < sz; ++j)\\n    \\t\\t{\\n    \\t\\t\\tif (0 == vg[j] || i == j)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\tif (s[i] == g[j])\\n    \\t\\t\\t{\\n    \\t\\t\\t\\t++b;\\n    \\t\\t\\t\\tvg[j] = 0;\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn to_string(a) + \"A\" + to_string(b) + \"B\";\\n    }\\n\\nIt costs 92 ms.\\n\\nThe problem also told us character only '0'~'9' be used. Then the code can be improved as follow:\\n\\n    string getHint(string s, string g)\\n    {\\n    \\tif (s.empty())\\n    \\t\\treturn \"0A0B\";\\n    \\tint i, j, a, b;\\n    \\tint sz = s.size();\\n    \\ta = b = 0;\\n    \\tvector<int> vs(10, 0);\\n    \\tvector<int> vg(10, 0);\\n    \\tfor (i = 0; i < sz; ++i)\\n    \\t{\\n    \\t\\tif (s[i] == g[i])\\n    \\t\\t{\\n    \\t\\t\\t++a;\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\t++vs[s[i] - '0'];\\n    \\t\\t++vg[g[i] - '0'];\\n    \\t}\\n    \\tfor (i = 0; i < 10; ++i)\\n    \\t\\tb += min(vs[i], vg[i]);\\n    \\treturn to_string(a) + \"A\" + to_string(b) + \"B\";\\n    }\\n\\nIn the first loop calculate the digits' ('0'~'9') number that didn't paired. In the second loop choose the smaller number means at least these numbers of digits could be paired but at wrong position now.",
                "solutionTags": [
                    "C++"
                ],
                "code": "The basic idea of this problem is calculate Bulls number firstly, then calculate Cows number.\\nThis is my first solution code:\\n\\n    string getHint(string s, string g) \\n    {\\n    \\tif (s.empty())\\n    \\t\\treturn \"0A0B\";\\n    \\tint i, j, a, b;\\n    \\tint sz = s.size();\\n    \\ta = b = 0;\\n    \\tvector<int> vs(sz, 1);\\n    \\tvector<int> vg(sz, 1);\\n    \\tfor (i = 0; i < sz; ++i)\\n    \\t{\\n    \\t\\tif (s[i] == g[i])\\n    \\t\\t{\\n    \\t\\t\\t++a;\\n    \\t\\t\\tvs[i] = vg[i] = 0;\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t}\\n    \\tfor (i = 0; i < sz; ++i)\\n    \\t{\\n    \\t\\tif (0 == vs[i])\\n    \\t\\t\\tcontinue;\\n    \\t\\tfor (j = 0; j < sz; ++j)\\n    \\t\\t{\\n    \\t\\t\\tif (0 == vg[j] || i == j)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\tif (s[i] == g[j])\\n    \\t\\t\\t{\\n    \\t\\t\\t\\t++b;\\n    \\t\\t\\t\\tvg[j] = 0;\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn to_string(a) + \"A\" + to_string(b) + \"B\";\\n    }\\n\\nIt costs 92 ms.\\n\\nThe problem also told us character only '0'~'9' be used. Then the code can be improved as follow:\\n\\n    string getHint(string s, string g)\\n    {\\n    \\tif (s.empty())\\n    \\t\\treturn \"0A0B\";\\n    \\tint i, j, a, b;\\n    \\tint sz = s.size();\\n    \\ta = b = 0;\\n    \\tvector<int> vs(10, 0);\\n    \\tvector<int> vg(10, 0);\\n    \\tfor (i = 0; i < sz; ++i)\\n    \\t{\\n    \\t\\tif (s[i] == g[i])\\n    \\t\\t{\\n    \\t\\t\\t++a;\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\t++vs[s[i] - '0'];\\n    \\t\\t++vg[g[i] - '0'];\\n    \\t}\\n    \\tfor (i = 0; i < 10; ++i)\\n    \\t\\tb += min(vs[i], vg[i]);\\n    \\treturn to_string(a) + \"A\" + to_string(b) + \"B\";\\n    }\\n\\nIn the first loop calculate the digits' ('0'~'9') number that didn't paired. In the second loop choose the smaller number means at least these numbers of digits could be paired but at wrong position now.",
                "codeTag": "Unknown"
            },
            {
                "id": 3128386,
                "title": "easy-python-solution-using-counter",
                "content": "# Code\\n```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        dic=Counter(secret)-Counter(guess)\\n        cnt=0\\n        for i in range(len(secret)):\\n            if secret[i]==guess[i]:\\n                cnt+=1\\n        cnt2=len(secret)-sum(dic.values())-cnt\\n        return str(cnt)+\"A\"+str(cnt2)+\"B\"\\n```",
                "solutionTags": [
                    "Python3",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        dic=Counter(secret)-Counter(guess)\\n        cnt=0\\n        for i in range(len(secret)):\\n            if secret[i]==guess[i]:\\n                cnt+=1\\n        cnt2=len(secret)-sum(dic.values())-cnt\\n        return str(cnt)+\"A\"+str(cnt2)+\"B\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998828,
                "title": "easy-python-solution-using-hashmap",
                "content": "# Intuition\\nFor bulls we have to check for the digits having same position in both the strings i.e. secret and guess, then will count for the rest of the digits which are common in both strings.\\n\\n# Approach\\nWe will take **two dictionary** for **counting the frequency** of each digit occured in the respective string.\\nThen will check for **similar digits** having **same position** in strings and **decrease their frequency** value from each dictionary.\\nNow for cow we will check for **common digits** which have non zero value in both dictionaries and will add the **minimum** of the frequency into cows value.\\n\\n# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        a={}\\n        b={}\\n        for i in secret:            #Frequency of digits in secret\\n            if i in a:\\n                a[i]+=1\\n            else:\\n                a[i]=1\\n        for i in guess:             #Frequency of digits in guess\\n            if i in b:\\n                b[i]+=1\\n            else:\\n                b[i]=1\\n        bulls=0\\n        for i in range(len(secret)):    #Counting bulls\\n            if secret[i]==guess[i]:\\n                bulls+=1\\n                a[secret[i]]-=1\\n                b[secret[i]]-=1\\n        cows=0\\n        for i in a:                     #Counting cows\\n            if i in b:\\n                cows+=min(a[i],b[i])\\n        res=str(bulls)+\"A\"+str(cows)+\"B\"\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        a={}\\n        b={}\\n        for i in secret:            #Frequency of digits in secret\\n            if i in a:\\n                a[i]+=1\\n            else:\\n                a[i]=1\\n        for i in guess:             #Frequency of digits in guess\\n            if i in b:\\n                b[i]+=1\\n            else:\\n                b[i]=1\\n        bulls=0\\n        for i in range(len(secret)):    #Counting bulls\\n            if secret[i]==guess[i]:\\n                bulls+=1\\n                a[secret[i]]-=1\\n                b[secret[i]]-=1\\n        cows=0\\n        for i in a:                     #Counting cows\\n            if i in b:\\n                cows+=min(a[i],b[i])\\n        res=str(bulls)+\"A\"+str(cows)+\"B\"\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990936,
                "title": "easy-java-o-n-solution-by-counting",
                "content": "# Intuition : Counting bulls and cows\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach : Counting bulls by comparing and cows with the help of an array\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        //check same character on both string on same index for bull\\n        int bull =0;\\n        for(int i=0; i< secret.length(); i++){\\n            if(secret.charAt(i) == guess.charAt(i) ) bull++;\\n        }\\n\\n     // for cows count occurance of every number and save it in Array\\n        int count =0;\\n      int[] arr = new int[10];\\n      for(int i=0; i<guess.length(); i++){\\n          int n = guess.charAt(i) -\\'0\\';\\n          arr[n]++;\\n      }\\n    \\n       for(int i=0; i<guess.length(); i++){\\n          int n = secret.charAt(i) -\\'0\\';\\n          if(arr[n] != 0){\\n              arr[n]--;\\n              count++;\\n          }\\n      }\\n      count = count -bull; \\n      String  s= bull+\"A\"+count+\"B\";\\n\\n      return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        //check same character on both string on same index for bull\\n        int bull =0;\\n        for(int i=0; i< secret.length(); i++){\\n            if(secret.charAt(i) == guess.charAt(i) ) bull++;\\n        }\\n\\n     // for cows count occurance of every number and save it in Array\\n        int count =0;\\n      int[] arr = new int[10];\\n      for(int i=0; i<guess.length(); i++){\\n          int n = guess.charAt(i) -\\'0\\';\\n          arr[n]++;\\n      }\\n    \\n       for(int i=0; i<guess.length(); i++){\\n          int n = secret.charAt(i) -\\'0\\';\\n          if(arr[n] != 0){\\n              arr[n]--;\\n              count++;\\n          }\\n      }\\n      count = count -bull; \\n      String  s= bull+\"A\"+count+\"B\";\\n\\n      return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505034,
                "title": "very-easy-implementation-in-dp-with-70-runtime",
                "content": "```\\nclass Solution(object):\\n    def getHint(self, secret, guess):\\n        \"\"\"\\n        :type secret: str\\n        :type guess: str\\n        :rtype: str\\n        \"\"\"\\n        bulls=0\\n        cows=0\\n        d1=collections.Counter(secret)\\n        d2=collections.Counter(guess)\\n        for i in d1:\\n            if i in d2:\\n                cows+=min(d1[i],d2[i])\\n        for i in range(len(secret)):\\n            if secret[i] == guess[i]:\\n                bulls+=1\\n        return str(bulls) + \"A\" + str(cows-bulls) + \\'B\\'\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def getHint(self, secret, guess):\\n        \"\"\"\\n        :type secret: str\\n        :type guess: str\\n        :rtype: str\\n        \"\"\"\\n        bulls=0\\n        cows=0\\n        d1=collections.Counter(secret)\\n        d2=collections.Counter(guess)\\n        for i in d1:\\n            if i in d2:\\n                cows+=min(d1[i],d2[i])\\n        for i in range(len(secret)):\\n            if secret[i] == guess[i]:\\n                bulls+=1\\n        return str(bulls) + \"A\" + str(cows-bulls) + \\'B\\'\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721343,
                "title": "layman-approach-to-understanding-the-problem-statement",
                "content": "Ok, So let me explain you this in very layman terms.\\n\\n-So you know how to count for bulls, which ever character(digit) is at same place, you increase counter. Straight forward.\\n-Coming to count cows. So think it in this way.\\n\\nIf you have bulls that mean \"n\" digits are at same place. So assume you removed the matching char from both the arrays. For Example :\\n    \\n\\tsecret        \"1122\"\\n    guess         \"2212\"\\nWe found 2 at 3rd place, which is same. So we remove it from both arrays and we will be having - :\\n          \\n\\tsecret        \"112\"\\n\\tguess         \"221\"\\nNow to get the answer for num of cows, just calculate how many digits you can shuffle in **guess array** to make it similar as **secret array**. So in above example you can shuffle the guess array in 2 possible ways ( P1 & P2 ) :\\n\\n\\n\\t          P1                 P2    \\n\\tsecret   \"112\"             \"112\"\\n    guess    \"122\"             \"212\"\\nIn both ways you can only have 2 digits at same place. And So your count for cows would be \"2\".",
                "solutionTags": [],
                "code": "Ok, So let me explain you this in very layman terms.\\n\\n-So you know how to count for bulls, which ever character(digit) is at same place, you increase counter. Straight forward.\\n-Coming to count cows. So think it in this way.\\n\\nIf you have bulls that mean \"n\" digits are at same place. So assume you removed the matching char from both the arrays. For Example :\\n    \\n\\tsecret        \"1122\"\\n    guess         \"2212\"\\nWe found 2 at 3rd place, which is same. So we remove it from both arrays and we will be having - :\\n          \\n\\tsecret        \"112\"\\n\\tguess         \"221\"\\nNow to get the answer for num of cows, just calculate how many digits you can shuffle in **guess array** to make it similar as **secret array**. So in above example you can shuffle the guess array in 2 possible ways ( P1 & P2 ) :\\n\\n\\n\\t          P1                 P2    \\n\\tsecret   \"112\"             \"112\"\\n    guess    \"122\"             \"212\"\\nIn both ways you can only have 2 digits at same place. And So your count for cows would be \"2\".",
                "codeTag": "Unknown"
            },
            {
                "id": 1612533,
                "title": "2-pass-1-pass-solution-python",
                "content": "**2-pass solution**\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        secret_non_bull, guess_non_bull = [], []\\n        num_bulls = 0\\n        for char1, char2 in zip(secret, guess):\\n            if char1 == char2:\\n                num_bulls += 1\\n            else:\\n                secret_non_bull.append(char1)\\n                guess_non_bull.append(char2)\\n        \\n        secret_counter, guess_counter = Counter(secret_non_bull), Counter(guess_non_bull)\\n        \\n        num_cows = 0\\n        for word, cnt in guess_counter.items():\\n            num_cows += min(secret_counter[word], cnt)\\n    \\n        \\n        return str(num_bulls) + \\'A\\' + str(num_cows) + \\'B\\'\\n```\\n\\n**1-pass solution**\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        diff_dict = defaultdict(int)\\n        num_bulls, num_cows = 0, 0\\n        \\n        for char1, char2 in zip(secret, guess):\\n            if char1 == char2:\\n                num_bulls += 1\\n            else:\\n                if diff_dict[char2] < 0:\\n                    num_cows += 1\\n                diff_dict[char2] += 1\\n                \\n                if diff_dict[char1] > 0:\\n                    num_cows += 1\\n                diff_dict[char1] -= 1\\n                \\n        return str(num_bulls) + \\'A\\' + str(num_cows) + \\'B\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        secret_non_bull, guess_non_bull = [], []\\n        num_bulls = 0\\n        for char1, char2 in zip(secret, guess):\\n            if char1 == char2:\\n                num_bulls += 1\\n            else:\\n                secret_non_bull.append(char1)\\n                guess_non_bull.append(char2)\\n        \\n        secret_counter, guess_counter = Counter(secret_non_bull), Counter(guess_non_bull)\\n        \\n        num_cows = 0\\n        for word, cnt in guess_counter.items():\\n            num_cows += min(secret_counter[word], cnt)\\n    \\n        \\n        return str(num_bulls) + \\'A\\' + str(num_cows) + \\'B\\'\\n```\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        diff_dict = defaultdict(int)\\n        num_bulls, num_cows = 0, 0\\n        \\n        for char1, char2 in zip(secret, guess):\\n            if char1 == char2:\\n                num_bulls += 1\\n            else:\\n                if diff_dict[char2] < 0:\\n                    num_cows += 1\\n                diff_dict[char2] += 1\\n                \\n                if diff_dict[char1] > 0:\\n                    num_cows += 1\\n                diff_dict[char1] -= 1\\n                \\n        return str(num_bulls) + \\'A\\' + str(num_cows) + \\'B\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842078,
                "title": "javascript-typescript-solution",
                "content": "// JS\\n// Runtime: 84 ms, faster than 88.14% of JavaScript online submissions for Bulls and Cows.\\n// Memory Usage: 39.3 MB, less than 46.05% of JavaScript online submissions for Bulls and Cows.\\n```\\nvar getHint = function (secret, guess) {\\n  let bulls = 0;\\n  let cows = 0;\\n  const hash = {};\\n\\n  for (let i = 0; i < secret.length; i++) {\\n    if (secret[i] === guess[i]) {\\n      bulls++;\\n    } else if (secret[i] in hash) hash[secret[i]]++;\\n    else hash[secret[i]] = 1;\\n  }\\n\\n  for (let i = 0; i < guess.length; i++) {\\n    if (secret[i] !== guess[i] && hash[guess[i]]) {\\n      cows++;\\n      hash[guess[i]]--;\\n    }\\n  }\\n\\n  return `${bulls}A${cows}B`;\\n};\\n```\\n\\n// TS\\n// Runtime: 76 ms, faster than 100.00% of TypeScript online submissions for Bulls and Cows.\\n// Memory Usage: 40.3 MB, less than 40.00% of TypeScript online submissions for Bulls and Cows.\\n```\\nfunction getHint(secret: string, guess: string): string {\\n  let bulls = 0;\\n  let cows = 0;\\n  const hash: { [key: string]: number } = {};\\n\\n  for (let i = 0; i < secret.length; i++) {\\n    if (secret[i] === guess[i]) {\\n      bulls++;\\n    } else if (secret[i] in hash) hash[secret[i]]++;\\n    else hash[secret[i]] = 1;\\n  }\\n\\n  for (let i = 0; i < guess.length; i++) {\\n    if (secret[i] !== guess[i] && hash[guess[i]]) {\\n      cows++;\\n      hash[guess[i]]--;\\n    }\\n  }\\n\\n  return `${bulls}A${cows}B`;\\n}\\n```\\nMore leetcode TypeScript solutions at https://github.com/eddyhdzg/leetcode-typescript-solutions\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nvar getHint = function (secret, guess) {\\n  let bulls = 0;\\n  let cows = 0;\\n  const hash = {};\\n\\n  for (let i = 0; i < secret.length; i++) {\\n    if (secret[i] === guess[i]) {\\n      bulls++;\\n    } else if (secret[i] in hash) hash[secret[i]]++;\\n    else hash[secret[i]] = 1;\\n  }\\n\\n  for (let i = 0; i < guess.length; i++) {\\n    if (secret[i] !== guess[i] && hash[guess[i]]) {\\n      cows++;\\n      hash[guess[i]]--;\\n    }\\n  }\\n\\n  return `${bulls}A${cows}B`;\\n};\\n```\n```\\nfunction getHint(secret: string, guess: string): string {\\n  let bulls = 0;\\n  let cows = 0;\\n  const hash: { [key: string]: number } = {};\\n\\n  for (let i = 0; i < secret.length; i++) {\\n    if (secret[i] === guess[i]) {\\n      bulls++;\\n    } else if (secret[i] in hash) hash[secret[i]]++;\\n    else hash[secret[i]] = 1;\\n  }\\n\\n  for (let i = 0; i < guess.length; i++) {\\n    if (secret[i] !== guess[i] && hash[guess[i]]) {\\n      cows++;\\n      hash[guess[i]]--;\\n    }\\n  }\\n\\n  return `${bulls}A${cows}B`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840038,
                "title": "java-with-some-comments-hashmap-two-pass",
                "content": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        // first pass determine the A\\n        Map<Character, Integer> map1 = new HashMap<>();\\n        Map<Character, Integer> map2 = new HashMap<>();\\n        int A = 0;\\n        for(int i = 0; i < secret.length(); i++) {\\n            map1.put(secret.charAt(i), map1.getOrDefault(secret.charAt(i), 0) + 1);\\n            map2.put(guess.charAt(i), map2.getOrDefault(guess.charAt(i), 0) + 1);\\n            if(secret.charAt(i) == guess.charAt(i)) {\\n                A++;\\n            }\\n        }\\n        // Second Pass find B\\n        int B = 0;\\n        for(char c: map1.keySet()) {\\n            if(map2.containsKey(c)) {\\n                // we always take the smallest value form map1 or map2\\n                B = B + Math.min(map1.get(c), map2.get(c));\\n            }\\n        }\\n        // if some number is definded as \\'A\\', then it must be contain in \\'B\\'. Therefeore, we should minus A.\\n        B = B - A;\\n        return A + \"A\" + B + \"B\";\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        // first pass determine the A\\n        Map<Character, Integer> map1 = new HashMap<>();\\n        Map<Character, Integer> map2 = new HashMap<>();\\n        int A = 0;\\n        for(int i = 0; i < secret.length(); i++) {\\n            map1.put(secret.charAt(i), map1.getOrDefault(secret.charAt(i), 0) + 1);\\n            map2.put(guess.charAt(i), map2.getOrDefault(guess.charAt(i), 0) + 1);\\n            if(secret.charAt(i) == guess.charAt(i)) {\\n                A++;\\n            }\\n        }\\n        // Second Pass find B\\n        int B = 0;\\n        for(char c: map1.keySet()) {\\n            if(map2.containsKey(c)) {\\n                // we always take the smallest value form map1 or map2\\n                B = B + Math.min(map1.get(c), map2.get(c));\\n            }\\n        }\\n        // if some number is definded as \\'A\\', then it must be contain in \\'B\\'. Therefeore, we should minus A.\\n        B = B - A;\\n        return A + \"A\" + B + \"B\";\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839886,
                "title": "javascript-one-pass-with-explanation-and-comments",
                "content": "```\\n/*\\nbulls : exact\\ncows: number match but position does not\\n\\ncreate a hashmap O(1) since it\\'s fixed at most letters in alphabet {num:freq}\\niterate through both strings at once, for every bull, keep a counter\\n\\nif match, don\\'t update map. \\'lock\\' in the position\\nelse \\nif map[secret letter] is negative (from a previous guess) -> cow++\\nif map[guess letter] is positive (from a previous secret) -> cow++\\nfor guess letter, map.set -1\\nfor secret, map.set + 1\\n*/\\n/**\\n * @param {string} secret\\n * @param {string} guess\\n * @return {string}\\n */\\nvar getHint = function(secret, guess) {\\n    let map = new Map(); // {num:count}\\n    let cows = 0;\\n    let bulls = 0;\\n    for (let i = 0; i < secret.length; i++){\\n        let g = guess[i];\\n        let s = secret[i];\\n        if (s === g){\\n            bulls++;\\n        } else {\\n            if (map.has(s) && map.get(s) < 0) cows++;\\n            if (map.has(g) && map.get(g) > 0) cows++;\\n            map.set(s, (map.get(s) || 0) + 1)\\n            map.set(g, (map.get(g) || 0) - 1)\\n        }\\n    }\\n    return `${bulls}A${cows}B`;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nbulls : exact\\ncows: number match but position does not\\n\\ncreate a hashmap O(1) since it\\'s fixed at most letters in alphabet {num:freq}\\niterate through both strings at once, for every bull, keep a counter\\n\\nif match, don\\'t update map. \\'lock\\' in the position\\nelse \\nif map[secret letter] is negative (from a previous guess) -> cow++\\nif map[guess letter] is positive (from a previous secret) -> cow++\\nfor guess letter, map.set -1\\nfor secret, map.set + 1\\n*/\\n/**\\n * @param {string} secret\\n * @param {string} guess\\n * @return {string}\\n */\\nvar getHint = function(secret, guess) {\\n    let map = new Map(); // {num:count}\\n    let cows = 0;\\n    let bulls = 0;\\n    for (let i = 0; i < secret.length; i++){\\n        let g = guess[i];\\n        let s = secret[i];\\n        if (s === g){\\n            bulls++;\\n        } else {\\n            if (map.has(s) && map.get(s) < 0) cows++;\\n            if (map.has(g) && map.get(g) > 0) cows++;\\n            map.set(s, (map.get(s) || 0) + 1)\\n            map.set(g, (map.get(g) || 0) - 1)\\n        }\\n    }\\n    return `${bulls}A${cows}B`;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 839503,
                "title": "python-simple-intuitive-solution",
                "content": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        bull, cow = 0, 0\\n        # keep in dict indexes of each numer:\\n        my_dict = defaultdict(list)\\n        for i, num in enumerate(secret):\\n            my_dict[num].append(i)\\n        temp = \"\"\\n        # find exact matches:\\n        for i, num in enumerate(guess):\\n            if my_dict.get(num):\\n                if i in my_dict.get(num):\\n                    bull+=1\\n                    my_dict[num].remove(i)\\n                    temp+=\\'a\\'\\n                else:\\n                    temp+=num\\n        # find numbers in wrong positions:\\n        for i, num in enumerate(temp):\\n            if my_dict.get(num):\\n                cow+=1\\n                my_dict[num].pop(-1)\\n                \\n        return str(bull)+\\'A\\'+str(cow)+\\'B\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        bull, cow = 0, 0\\n        # keep in dict indexes of each numer:\\n        my_dict = defaultdict(list)\\n        for i, num in enumerate(secret):\\n            my_dict[num].append(i)\\n        temp = \"\"\\n        # find exact matches:\\n        for i, num in enumerate(guess):\\n            if my_dict.get(num):\\n                if i in my_dict.get(num):\\n                    bull+=1\\n                    my_dict[num].remove(i)\\n                    temp+=\\'a\\'\\n                else:\\n                    temp+=num\\n        # find numbers in wrong positions:\\n        for i, num in enumerate(temp):\\n            if my_dict.get(num):\\n                cow+=1\\n                my_dict[num].pop(-1)\\n                \\n        return str(bull)+\\'A\\'+str(cow)+\\'B\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801112,
                "title": "why-is-this-an-easy-question",
                "content": "I think this should be marked as medium, the only easy part of this question is easily messing up edge cases like:\\n```\\n\"1122\"\\n\"1222\"\\n```",
                "solutionTags": [],
                "code": "```\\n\"1122\"\\n\"1222\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371257,
                "title": "c-o-n-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int bull = 0, cow = 0, i, n = secret.length();\\n        int countS[10] = {0};\\n        int countG[10] = {0};\\n        for(i=0; i<n; i++){\\n            if(secret[i] == guess[i]) bull++;\\n            else{\\n                countS[secret[i] - \\'0\\']++;\\n                countG[guess[i] - \\'0\\']++;\\n            }\\n        }\\n        \\n        for(i=0;i<10;i++){\\n            cow += min(countS[i], countG[i]);\\n        }       \\n        return (to_string(bull)+\"A\"+to_string(cow)+\"B\");\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int bull = 0, cow = 0, i, n = secret.length();\\n        int countS[10] = {0};\\n        int countG[10] = {0};\\n        for(i=0; i<n; i++){\\n            if(secret[i] == guess[i]) bull++;\\n            else{\\n                countS[secret[i] - \\'0\\']++;\\n                countG[guess[i] - \\'0\\']++;\\n            }\\n        }\\n        \\n        for(i=0;i<10;i++){\\n            cow += min(countS[i], countG[i]);\\n        }       \\n        return (to_string(bull)+\"A\"+to_string(cow)+\"B\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304319,
                "title": "c-count-a-first-then-b",
                "content": "```\\npublic class Solution {\\n    public string GetHint(string secret, string guess) {\\n        var n = secret.Length;\\n\\n        var countA = 0;\\n        var countB = 0;\\n\\n        var charAndCountSecret = new int[256];\\n        var charAndCountGuess = new int[256];\\n        for (int i = 0; i < n; i++) {\\n            if (secret[i] == guess[i]) {\\n                countA++;\\n            } else {\\n                charAndCountSecret[secret[i]]++;\\n                charAndCountGuess[guess[i]]++;\\n            }\\n        }\\n\\n        for (int i = 0; i < 256; i++) {\\n            countB += Math.Min(charAndCountSecret[i], charAndCountGuess[i]);\\n        }\\n\\n        return $\"{countA}A{countB}B\";\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string GetHint(string secret, string guess) {\\n        var n = secret.Length;\\n\\n        var countA = 0;\\n        var countB = 0;\\n\\n        var charAndCountSecret = new int[256];\\n        var charAndCountGuess = new int[256];\\n        for (int i = 0; i < n; i++) {\\n            if (secret[i] == guess[i]) {\\n                countA++;\\n            } else {\\n                charAndCountSecret[secret[i]]++;\\n                charAndCountGuess[guess[i]]++;\\n            }\\n        }\\n\\n        for (int i = 0; i < 256; i++) {\\n            countB += Math.Min(charAndCountSecret[i], charAndCountGuess[i]);\\n        }\\n\\n        return $\"{countA}A{countB}B\";\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187801,
                "title": "javascript-beats-100-self-explanatory",
                "content": "```\nvar getHint = function(secret, guess) {\n  let guessArr = new Array(10).fill(0);\n  let secretArr = new Array(10).fill(0);\n  let bull = 0; let cow = 0;\n\n  getBulls();\n  getCows();\n  cow = cow - bull;\n\n  return `${bull}A${cow}B`;\n\n  function getBulls() {\n    for (let i = 0; i < secret.length; i++) {\n      secretArr[Number(secret[i])]++; guessArr[Number(guess[i])]++;\n      if (secret[i] === guess[i]) {\n        bull++;\n      }\n    }\n  };\n  \n  function getCows() {\n    for (let i = 0; i < 10; i++) {\n      cow += Math.min(Number(guessArr[i]), Number(secretArr[i]));\n    }\n  };\n};\n```",
                "solutionTags": [],
                "code": "```\nvar getHint = function(secret, guess) {\n  let guessArr = new Array(10).fill(0);\n  let secretArr = new Array(10).fill(0);\n  let bull = 0; let cow = 0;\n\n  getBulls();\n  getCows();\n  cow = cow - bull;\n\n  return `${bull}A${cow}B`;\n\n  function getBulls() {\n    for (let i = 0; i < secret.length; i++) {\n      secretArr[Number(secret[i])]++; guessArr[Number(guess[i])]++;\n      if (secret[i] === guess[i]) {\n        bull++;\n      }\n    }\n  };\n  \n  function getCows() {\n    for (let i = 0; i < 10; i++) {\n      cow += Math.min(Number(guessArr[i]), Number(secretArr[i]));\n    }\n  };\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 74816,
                "title": "o-n-time-o-1-space",
                "content": "public class Solution {\\n    public String getHint(String secret, String guess) {\\n        int bulls=0;\\n        int cows=0;\\n        int[] count=new int[10];\\n        \\n        /*loop once \\n           1231\\n           0230\\n           \\n           0231\\n           1230\\n           \\n           gor guess, count--; for secret, count++\\n        */\\n        for(int i=0;i<secret.length();i++){\\n            int s=secret.charAt(i)-'0';\\n            int g=guess.charAt(i)-'0';\\n            if(s==g){\\n                bulls++;\\n            }else{\\n                if(count[g]>0){\\n                    cows++;\\n                }\\n                if(count[s]<0){\\n                    cows++;\\n                }\\n                count[g]--;\\n                count[s]++;\\n            }\\n        }\\n        return bulls+\"A\"+cows+\"B\";\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String getHint(String secret, String guess) {\\n        int bulls=0;\\n        int cows=0;\\n        int[] count=new int[10];\\n        \\n        /*loop once \\n           1231\\n           0230\\n           \\n           0231\\n           1230\\n           \\n           gor guess, count--; for secret, count++\\n        */\\n        for(int i=0;i<secret.length();i++){\\n            int s=secret.charAt(i)-'0';\\n            int g=guess.charAt(i)-'0';\\n            if(s==g){\\n                bulls++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 74819,
                "title": "clean-and-clear-java-o-n-solution",
                "content": "    public class Solution {\\n        public String getHint(String secret, String guess) {\\n            int A = 0, B = 0;\\n            int[] cnt = new int[10];\\n            for(int i=0; i<secret.length(); ++i){\\n                if(secret.charAt(i) == guess.charAt(i)) ++A;\\n                else{\\n                    if(++cnt[secret.charAt(i)-'0'] <= 0)    ++B;\\n                    if(--cnt[guess.charAt(i)-'0']>=0)   ++B;\\n                }\\n            }\\n            return A + \"A\" + B + \"B\";\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n        public String getHint(String secret, String guess) {\\n            int A = 0, B = 0;\\n            int[] cnt = new int[10];\\n            for(int i=0; i<secret.length(); ++i){\\n                if(secret.charAt(i) == guess.charAt(i)) ++A;\\n                else{\\n                    if(++cnt[secret.charAt(i)-'0'] <= 0)    ++B;\\n                    if(--cnt[guess.charAt(i)-'0']>=0)   ++B;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3478218,
                "title": "c-solution-using-map-o-n",
                "content": "# Intuition\\nShould find the number of *bulls* and *cows*. Can be solved by iterating over $$secret$$ and $$guess$$, and comparing the characters. The comparison to be made for *bull* count and the *cow* count is different.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. we loop through each digit in the $$secret$$ and $$guess$$ strings, comparing the digits at the same position. If they are the same, it means that a *bull* has been found, and the digit is replaced by the character \\'o\\' in both the strings to mark it as a *bull*. The count of *bulls* found so far is incremented.\\n2. we initialise unordered map to store the count of each digit in both the $$secret$$ and $$guess$$ strings. The map stores a pair of integers, where the first integer represents the count of the digit in the secret string, and the second integer represents the count of the digit in the guess string.\\n3. The character \\'o\\' (which represents *bulls*) can be removed from the map as we do not it for *cows* counting.\\n4. we then loop through each character in the map, adding the minimum count of the character in both the $$secret$$ and $$guess$$ strings to the variable *cows*, which represents the number of *cows* (correctly guessed digits in the wrong position).\\n5. Now, we have number of *bulls* and number of *cows*. Format the $$hint$$ as \"<#bulls>A<#cows>B\"\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe overall time complexity of the function is O(n + k), \\nSince, the strings contain only digits, maximum possible value of k is 10, which can considered to be constant.\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe unordered map $$char\\\\_count$$ takes space proportional to k. \\n\\nwhere n is the length of the $$secret$$ string and k is the number of unique digits in the $$secret$$ and $$guess$$ strings.\\nThe number of unique digits is at most 10 (since the digits are from 0 to 9) and k can be considered as constant.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int secret_size = secret.size();\\n        int bulls = 0;\\n        string hint = \"\";\\n        for(int i = 0; i < secret_size; i++)\\n            if(secret[i] == guess[i]) {\\n                secret[i] = guess[i] = \\'o\\';\\n                bulls++;\\n            }\\n        hint += to_string(bulls);\\n        hint.push_back(\\'A\\');\\n\\n        unordered_map<char,pair<int,int>> char_count;\\n        for(int i = 0; i < secret_size; i++) {\\n            char_count[secret[i]].first++;\\n            char_count[guess[i]].second++;\\n        }\\n        char_count.erase(\\'o\\');\\n\\n        int cows = 0;\\n        for(auto [theChar, theCount]: char_count)\\n            cows += min(theCount.first, theCount.second);\\n        hint += to_string(cows);\\n        hint.push_back(\\'B\\');\\n\\n        return hint;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int secret_size = secret.size();\\n        int bulls = 0;\\n        string hint = \"\";\\n        for(int i = 0; i < secret_size; i++)\\n            if(secret[i] == guess[i]) {\\n                secret[i] = guess[i] = \\'o\\';\\n                bulls++;\\n            }\\n        hint += to_string(bulls);\\n        hint.push_back(\\'A\\');\\n\\n        unordered_map<char,pair<int,int>> char_count;\\n        for(int i = 0; i < secret_size; i++) {\\n            char_count[secret[i]].first++;\\n            char_count[guess[i]].second++;\\n        }\\n        char_count.erase(\\'o\\');\\n\\n        int cows = 0;\\n        for(auto [theChar, theCount]: char_count)\\n            cows += min(theCount.first, theCount.second);\\n        hint += to_string(cows);\\n        hint.push_back(\\'B\\');\\n\\n        return hint;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373997,
                "title": "java-bulls-and-cows",
                "content": "\\n```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        StringBuilder first = new StringBuilder(secret);\\n        StringBuilder second = new StringBuilder(guess);\\n        HashMap<Character, Integer> dict = new HashMap<>();\\n        int numA = 0;\\n        int numB = 0;\\n        for (int i = secret.length() - 1; i > -1; i--)\\n        {\\n            if (first.charAt(i) == second.charAt(i)) {\\n                numA++;\\n                first.deleteCharAt(i);\\n                second.deleteCharAt(i);\\n            }\\n            else {\\n                if (!dict.containsKey(secret.charAt(i)))\\n                    dict.put(secret.charAt(i), 0);\\n                dict.put(secret.charAt(i), dict.get(secret.charAt(i)) + 1);\\n            }\\n        }\\n        for (int i = 0; i < second.length(); i++)\\n        {\\n            if(dict.containsKey(second.charAt(i)) && dict.get(second.charAt(i)) > 0)\\n            {\\n                numB++;\\n                dict.put(second.charAt(i), dict.get(second.charAt(i)) - 1);\\n            }\\n        }\\n        return numA + \"A\" + numB + \"B\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        StringBuilder first = new StringBuilder(secret);\\n        StringBuilder second = new StringBuilder(guess);\\n        HashMap<Character, Integer> dict = new HashMap<>();\\n        int numA = 0;\\n        int numB = 0;\\n        for (int i = secret.length() - 1; i > -1; i--)\\n        {\\n            if (first.charAt(i) == second.charAt(i)) {\\n                numA++;\\n                first.deleteCharAt(i);\\n                second.deleteCharAt(i);\\n            }\\n            else {\\n                if (!dict.containsKey(secret.charAt(i)))\\n                    dict.put(secret.charAt(i), 0);\\n                dict.put(secret.charAt(i), dict.get(secret.charAt(i)) + 1);\\n            }\\n        }\\n        for (int i = 0; i < second.length(); i++)\\n        {\\n            if(dict.containsKey(second.charAt(i)) && dict.get(second.charAt(i)) > 0)\\n            {\\n                numB++;\\n                dict.put(second.charAt(i), dict.get(second.charAt(i)) - 1);\\n            }\\n        }\\n        return numA + \"A\" + numB + \"B\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357085,
                "title": "easiest-c-solution-intuition-explained-w-comments",
                "content": "# Intuition\\nWe need to keep track of only two conditions:\\n1. Either the position of a character in both the string is same.(bull++), Or\\n2. The position of a character is different but it is present in both the strings(cow++)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n--> We can simply have a loop to count the characters that are same (and have same index...if that makes sense).\\n\\n--> Then we can take an array of size 10 as there are only digits(0-9) in the string or for simplicity we can take an unordered map to count the total common characters (including cow as well as bull).\\n \\n--> Now we need to realize that for finding cows(same charcters but different index in the string) we can:\\n        no. of cows = total common characters - no. of bulls.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) [as the size of array or map can be maximum 10]\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# **If you liked the solution please UPVOTE!!**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) \\n    {\\n        int n=guess.size();\\n\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)   //frequency map\\n        {\\n            m[secret[i]]++;\\n        }\\n        int b=0;\\n        int c=0;\\n\\n        for(int i=0;i<n;i++)      \\n        {\\n            if(secret[i]==guess[i])    // condition 1: same characters at same index\\n            {\\n                b++;\\n            }\\n        }\\n         \\n        for(int i=0;i<n;i++)   //to find total no. of common characters\\n        {\\n            if(m.find(guess[i])!=m.end())  \\n            {\\n                c++;\\n                m[guess[i]]--;\\n                if(m[guess[i]]==0)    // if frequency of character=0, remove the character\\n                {\\n                    m.erase(guess[i]);\\n                }\\n            }\\n        }\\n       // cout<<c<<b;\\n        c=c-b;      // no. of cows = total common characters - no. of bulls.          \\n        string ans;\\n        ans=to_string(b)+\"A\"+to_string(c)+\"B\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) \\n    {\\n        int n=guess.size();\\n\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)   //frequency map\\n        {\\n            m[secret[i]]++;\\n        }\\n        int b=0;\\n        int c=0;\\n\\n        for(int i=0;i<n;i++)      \\n        {\\n            if(secret[i]==guess[i])    // condition 1: same characters at same index\\n            {\\n                b++;\\n            }\\n        }\\n         \\n        for(int i=0;i<n;i++)   //to find total no. of common characters\\n        {\\n            if(m.find(guess[i])!=m.end())  \\n            {\\n                c++;\\n                m[guess[i]]--;\\n                if(m[guess[i]]==0)    // if frequency of character=0, remove the character\\n                {\\n                    m.erase(guess[i]);\\n                }\\n            }\\n        }\\n       // cout<<c<<b;\\n        c=c-b;      // no. of cows = total common characters - no. of bulls.          \\n        string ans;\\n        ans=to_string(b)+\"A\"+to_string(c)+\"B\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3225167,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int n = secret.length();\\n        map<char,int> mp;\\n        for(int i=0 ; i<n ; ++i) mp[secret[i]]++;\\n        int bulls = 0;\\n        int cows  = 0;\\n        for(int i=0 ; i<n ; ++i){\\n            if(secret[i] == guess[i]){\\n                ++bulls;\\n                if(mp[guess[i]] == 1) mp.erase(guess[i]);\\n                else mp[guess[i]]--;        \\n                guess[i] = \\'*\\';\\n            }\\n        } \\n        for(int i=0 ; i<n ; ++i){\\n            if(guess[i] != \\'*\\'){\\n                if(mp.find(guess[i]) != mp.end()){\\n                    ++cows;\\n                    if(mp[guess[i]] == 1) mp.erase(guess[i]);\\n                    else mp[guess[i]]--;\\n                }\\n            }\\n        }  \\n        string ans = to_string(bulls) + \"A\" + to_string(cows) + \"B\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int n = secret.length();\\n        map<char,int> mp;\\n        for(int i=0 ; i<n ; ++i) mp[secret[i]]++;\\n        int bulls = 0;\\n        int cows  = 0;\\n        for(int i=0 ; i<n ; ++i){\\n            if(secret[i] == guess[i]){\\n                ++bulls;\\n                if(mp[guess[i]] == 1) mp.erase(guess[i]);\\n                else mp[guess[i]]--;        \\n                guess[i] = \\'*\\';\\n            }\\n        } \\n        for(int i=0 ; i<n ; ++i){\\n            if(guess[i] != \\'*\\'){\\n                if(mp.find(guess[i]) != mp.end()){\\n                    ++cows;\\n                    if(mp[guess[i]] == 1) mp.erase(guess[i]);\\n                    else mp[guess[i]]--;\\n                }\\n            }\\n        }  \\n        string ans = to_string(bulls) + \"A\" + to_string(cows) + \"B\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146190,
                "title": "best-js-sol-with-less-runtime-ms-99-memory-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The approach of the function is to compare the characters of the two input strings sec and guess and count the number of matching characters in both the correct position (bulls) and the incorrect position (cows).\\n\\n2. The function uses an array raj of size 10 to keep track of the frequency of characters in the sec string. \\n\\n3. It increments the frequency of each character in the sec string and decrements the frequency of each character in the guess string.\\n\\n4. For each character in the input strings, the function checks if the characters match. \\n\\n5. If they match, it increments the bulls count. \\n\\n6. If they do not match, it checks if the frequency of the sec character in the raj array is less than 0 (meaning it has already been decremented from the guess string) or if the frequency of the guess character in the raj array is greater than 0 (meaning it has already been incremented from the sec string). \\n\\n7. If either of these conditions are true, it increments the cows count.\\n\\n8. Finally, the function returns a string in the format \"bullsAcowB\", where bulls is the number of correct characters in the correct position and cows is the number of correct characters in the incorrect position.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here, n is the length of the input strings sec and guess. \\n\\n2. This is because the function is looping through the length of the input strings, performing constant time operations in each iteration.\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Because as the size of the additional data structures used (i.e. the raj array and the variables bulls and cows) do not depend on the size of the input strings and are limited to a constant size.\\n\\n# Code\\n```\\n/**\\n * @param {string} sec\\n * @param {string} guess\\n * @return {string}\\n */\\nvar getHint = function(sec, guess) {\\n\\n    let bulls = 0;\\n    \\n    let cows = 0;\\n    \\n    let raj = Array(10).fill(0);\\n    \\n    // It creates an array with 10 elements and fills \\n    // each element with the value 0. The result will be \\n    // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0].\\n\\n   // The Array(10) constructor creates an array with \\n   // 10 empty slots (undefined values). The fill method \\n   // then replaces each undefined value with the value 0.\\n   \\n   for (let i=0; i<sec.length; i++) {\\n\\n       let gu = parseInt(guess[i]);\\n       \\n       let secret = parseInt(sec[i]);\\n       \\n       if (secret === gu) {\\n           bulls++;\\n           continue;\\n       }\\n\\n       if (raj[secret] < 0) { \\n           cows++;\\n       }\\n       \\n       if (raj[gu] > 0) {    \\n           cows++;\\n       }\\n       \\n       raj[secret]++;\\n       raj[gu]--;  \\n   }\\n   \\n   return (`${bulls}A${cows}B`);\\n    \\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/2785e1a6-0c0e-4e73-88f8-13a41b277f08_1675599552.5760605.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sec\\n * @param {string} guess\\n * @return {string}\\n */\\nvar getHint = function(sec, guess) {\\n\\n    let bulls = 0;\\n    \\n    let cows = 0;\\n    \\n    let raj = Array(10).fill(0);\\n    \\n    // It creates an array with 10 elements and fills \\n    // each element with the value 0. The result will be \\n    // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0].\\n\\n   // The Array(10) constructor creates an array with \\n   // 10 empty slots (undefined values). The fill method \\n   // then replaces each undefined value with the value 0.\\n   \\n   for (let i=0; i<sec.length; i++) {\\n\\n       let gu = parseInt(guess[i]);\\n       \\n       let secret = parseInt(sec[i]);\\n       \\n       if (secret === gu) {\\n           bulls++;\\n           continue;\\n       }\\n\\n       if (raj[secret] < 0) { \\n           cows++;\\n       }\\n       \\n       if (raj[gu] > 0) {    \\n           cows++;\\n       }\\n       \\n       raj[secret]++;\\n       raj[gu]--;  \\n   }\\n   \\n   return (`${bulls}A${cows}B`);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3030371,
                "title": "python-easy-solution-beats-99-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        lst1 = list(secret)\\n        lst2 = list(guess)\\n        x = 0\\n        for i in range(len(lst2)):\\n            if lst1[i] == lst2[i]:\\n                x += 1\\n        y = len(lst1) - sum((Counter(lst1) - Counter(lst2)).values()) - x\\n        res = \\'\\'.join(str(x)+\\'A\\'+str(y)+\\'B\\')\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        lst1 = list(secret)\\n        lst2 = list(guess)\\n        x = 0\\n        for i in range(len(lst2)):\\n            if lst1[i] == lst2[i]:\\n                x += 1\\n        y = len(lst1) - sum((Counter(lst1) - Counter(lst2)).values()) - x\\n        res = \\'\\'.join(str(x)+\\'A\\'+str(y)+\\'B\\')\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023074,
                "title": "python3-simple-solution-defaultdict-for-cows",
                "content": "https://leetcode.com/submissions/detail/875564006/\\nRuntime: **30 ms**, faster than 99.56% of Python3 online submissions for Bulls and Cows.  \\nMemory Usage: 14 MB, less than 29.43% of Python3 online submissions for Bulls and Cows.  \\n```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        bulls, cows, ds, dg = 0, 0, defaultdict(lambda:0), defaultdict(lambda:0)\\n        for s,g in zip(secret, guess):\\n            if s==g:\\n                bulls += 1\\n                continue\\n            ds[s]+=1; dg[g]+=1\\n        for s in ds:\\n            if s in dg:\\n                cows += min(ds[s], dg[s])\\n        return f\\'{bulls}A{cows}B\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        bulls, cows, ds, dg = 0, 0, defaultdict(lambda:0), defaultdict(lambda:0)\\n        for s,g in zip(secret, guess):\\n            if s==g:\\n                bulls += 1\\n                continue\\n            ds[s]+=1; dg[g]+=1\\n        for s in ds:\\n            if s in dg:\\n                cows += min(ds[s], dg[s])\\n        return f\\'{bulls}A{cows}B\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022988,
                "title": "java-hashmap-solution-easy",
                "content": "**Upvote if you understand !!**\\n# Code\\n```\\nclass Solution {\\n    class Pair{\\n        int val;\\n        List<Integer> list;\\n        Pair(int val,List<Integer> list){\\n            this.val=val;\\n            this.list=list;\\n        }\\n    }\\n    public String getHint(String secret, String guess) {\\n        int A = 0;\\n        int B = 0;\\n        Map<Character,Pair> map = new HashMap<>();\\n        int length = guess.length();\\n        for(int i=0;i<length;i++){\\n            if(map.containsKey(secret.charAt(i))){\\n                Pair p = map.get(secret.charAt(i));\\n                p.val++;\\n                p.list.add(i);\\n            }\\n            else{\\n                map.put(secret.charAt(i),new Pair(1,new ArrayList<Integer>()));\\n                Pair p = map.get(secret.charAt(i));\\n                p.list.add(i);\\n            }\\n        }\\n     \\n        char[] ch = guess.toCharArray();\\n        for(int i=0;i<ch.length;i++){\\n            if(map.containsKey(ch[i]) && map.get(ch[i]).list.contains(new Integer(i))){\\n                map.get(ch[i]).val--;\\n                ch[i]=\\'-\\';\\n                A++;\\n            }\\n        }\\n\\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i] != \\'-\\' && map.containsKey(ch[i]) && map.get(ch[i]).val> 0){\\n                map.get(ch[i]).val--;\\n                B++;\\n            }\\n        }\\n        return A+\"A\"+B+\"B\";\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int val;\\n        List<Integer> list;\\n        Pair(int val,List<Integer> list){\\n            this.val=val;\\n            this.list=list;\\n        }\\n    }\\n    public String getHint(String secret, String guess) {\\n        int A = 0;\\n        int B = 0;\\n        Map<Character,Pair> map = new HashMap<>();\\n        int length = guess.length();\\n        for(int i=0;i<length;i++){\\n            if(map.containsKey(secret.charAt(i))){\\n                Pair p = map.get(secret.charAt(i));\\n                p.val++;\\n                p.list.add(i);\\n            }\\n            else{\\n                map.put(secret.charAt(i),new Pair(1,new ArrayList<Integer>()));\\n                Pair p = map.get(secret.charAt(i));\\n                p.list.add(i);\\n            }\\n        }\\n     \\n        char[] ch = guess.toCharArray();\\n        for(int i=0;i<ch.length;i++){\\n            if(map.containsKey(ch[i]) && map.get(ch[i]).list.contains(new Integer(i))){\\n                map.get(ch[i]).val--;\\n                ch[i]=\\'-\\';\\n                A++;\\n            }\\n        }\\n\\n        for(int i=0;i<ch.length;i++){\\n            if(ch[i] != \\'-\\' && map.containsKey(ch[i]) && map.get(ch[i]).val> 0){\\n                map.get(ch[i]).val--;\\n                B++;\\n            }\\n        }\\n        return A+\"A\"+B+\"B\";\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007895,
                "title": "c-good-code-quality-one-pass-solution-with-great-explanation",
                "content": "**Explanation:**\\nThe statement says that bull is a character which matches exactly to the guess position in secret.\\nand Cows are character which are not in correct position but can be rearranged to form the secret.\\nIf we know the appearance of a character in secret appears before or not we can solve this problem easily\\n\\nExample \\nsecret = \"1807\"\\nguess = \"7810\"\\nOutput = \"1A3B\" (1 bull and 3 Cows)\\n\\nWe can use a freq array to know appearance of a character.\\n\\n**How ?**\\nWe will increment count in secret string character in hope of finding the same character that decrements this count\\nin the guess string.\\nSimilarly we will decrement count in guess string character in hope of finding the same character that increments this count\\nin the secret string.\\nIn the above Example\\n\\'1\\' is the character in secret string that will be decremented by \\'1\\' in guessing string.\\n\\n**Algorithm**\\nCreate a vector to store frequencies of characters.\\nRun a loop until secret length to process all characters.\\nIf we found two same characters at same positions increment bulls.\\nElse check if the secret character is found by guessing character or vice versa, If yes then increment cows.\\nFinally construct the string in the order of given output.\\nReturn output string. \\n\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        vector<int> freq(10,0);\\n        string hint;\\n        int bulls=0,cows=0;\\n\\n        for(int i=0;i<secret.size();++i){\\n            if(guess[i]==secret[i]){\\n                bulls++;\\n            }else {\\n                if(freq[secret[i]-\\'0\\']++ < 0) cows++;\\n                if(freq[guess[i]-\\'0\\']-- > 0) cows++;\\n            }\\n        }\\n        hint=to_string(bulls)+\"A\"+to_string(cows)+\"B\";\\n        return hint;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        vector<int> freq(10,0);\\n        string hint;\\n        int bulls=0,cows=0;\\n\\n        for(int i=0;i<secret.size();++i){\\n            if(guess[i]==secret[i]){\\n                bulls++;\\n            }else {\\n                if(freq[secret[i]-\\'0\\']++ < 0) cows++;\\n                if(freq[guess[i]-\\'0\\']-- > 0) cows++;\\n            }\\n        }\\n        hint=to_string(bulls)+\"A\"+to_string(cows)+\"B\";\\n        return hint;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994433,
                "title": "comprehensible-clean-code",
                "content": "**Please give an upvote if you like the solution**\\n\\n*#6Companies30days #ReviseWithArsh Challenge 2023\\nDay1\\nQ2. Bulls and Cows*\\n\\n![3.bulls-and-cows.jpg](https://assets.leetcode.com/users/images/f5e0aa34-3b54-4db7-b070-cafe7e46978e_1672779956.6196964.jpeg)\\n\\n**cpp:**\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int bulls=0;\\n        int cows=0;\\n        vector<int>s(10,0);\\n        vector<int>g(10,0);\\n\\n        for(int i=0;i<secret.length();i++){\\n            if(secret[i]==guess[i])\\n                bulls++;\\n            else{\\n                s[secret[i]-\\'0\\']++;\\n                g[guess[i]-\\'0\\']++;\\n            }\\n        }\\n        for(int i=0;i<10;i++){\\n            cows+=min(s[i],g[i]);\\n        }\\n        string ans=\"\";\\n        ans+=to_string(bulls);\\n        ans+=\\'A\\';\\n        ans+=to_string(cows);\\n        ans+=\\'B\\';\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int bulls=0;\\n        int cows=0;\\n        vector<int>s(10,0);\\n        vector<int>g(10,0);\\n\\n        for(int i=0;i<secret.length();i++){\\n            if(secret[i]==guess[i])\\n                bulls++;\\n            else{\\n                s[secret[i]-\\'0\\']++;\\n                g[guess[i]-\\'0\\']++;\\n            }\\n        }\\n        for(int i=0;i<10;i++){\\n            cows+=min(s[i],g[i]);\\n        }\\n        string ans=\"\";\\n        ans+=to_string(bulls);\\n        ans+=\\'A\\';\\n        ans+=to_string(cows);\\n        ans+=\\'B\\';\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888667,
                "title": "java-2ms-99-clear-explanations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Traverse the two strings and keep track of the digits count in 2 x int[10]\\n2. While traversing, if current secret digit matches guess digit, only increment the  bulls, but do not mark the digit count. This is because we ignore the bulls.\\n3. Traverse both count arrays and return the sum of their mins. (cows)\\nEG: \\n    - If secret has 7 0s and guess has 3 0s, means only the 3 zeroes can be moved around\\n    - If secret has 3 0s but guess has 7 0s, you can only shuffle and match the 3 0s.\\n    - Thus, only the min between the two is taken in consideration\\n4. Return the formatted string containing bulls and cows.        \\n\\n\\n# Complexity\\n- Time complexity:$$O(n) + O(10)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(20)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int[] secretCount = new int[10];\\n        int[] guessCount = new int[10];\\n        int bulls = 0;\\n        char sChar, gChar;\\n        for (int i = 0; i < secret.length(); i++) {\\n            sChar = secret.charAt(i);\\n            gChar = guess.charAt(i);\\n            if (sChar == gChar) {\\n                bulls++;\\n            } else {\\n                secretCount[sChar - \\'0\\']++;\\n                guessCount[gChar - \\'0\\']++;\\n            }\\n        }\\n        int cows = 0;\\n        for (int i = 0; i < secretCount.length; i++) {\\n            cows += Math.min(secretCount[i], guessCount[i]);\\n        }\\n        return new StringBuilder().append(bulls).append(\\'A\\').append(cows).append(\\'B\\').toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int[] secretCount = new int[10];\\n        int[] guessCount = new int[10];\\n        int bulls = 0;\\n        char sChar, gChar;\\n        for (int i = 0; i < secret.length(); i++) {\\n            sChar = secret.charAt(i);\\n            gChar = guess.charAt(i);\\n            if (sChar == gChar) {\\n                bulls++;\\n            } else {\\n                secretCount[sChar - \\'0\\']++;\\n                guessCount[gChar - \\'0\\']++;\\n            }\\n        }\\n        int cows = 0;\\n        for (int i = 0; i < secretCount.length; i++) {\\n            cows += Math.min(secretCount[i], guessCount[i]);\\n        }\\n        return new StringBuilder().append(bulls).append(\\'A\\').append(cows).append(\\'B\\').toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842809,
                "title": "single-passing-solution",
                "content": "public String getHint(String secret, String guess) {\\n    int bulls = 0;\\n    int cows = 0;\\n    int[] numbers = new int[10];\\n    for (int i = 0; i<secret.length(); i++) {\\n        if (secret.charAt(i) == guess.charAt(i)) bulls++;\\n        else {\\n            if (numbers[secret.charAt(i)-\\'0\\']++ < 0) cows++;\\n            if (numbers[guess.charAt(i)-\\'0\\']-- > 0) cows++;\\n        }\\n    }\\n    return bulls + \"A\" + cows + \"B\";\\n}",
                "solutionTags": [],
                "code": "public String getHint(String secret, String guess) {\\n    int bulls = 0;\\n    int cows = 0;\\n    int[] numbers = new int[10];\\n    for (int i = 0; i<secret.length(); i++) {\\n        if (secret.charAt(i) == guess.charAt(i)) bulls++;\\n        else {\\n            if (numbers[secret.charAt(i)-\\'0\\']++ < 0) cows++;\\n            if (numbers[guess.charAt(i)-\\'0\\']-- > 0) cows++;\\n        }\\n    }\\n    return bulls + \"A\" + cows + \"B\";\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2716129,
                "title": "python-o-n-dictionary-count-ez-solution",
                "content": "class Solution(object):\\n    def getHint(self, secret, guess):\\n        \\n        bulls, cows = 0, 0\\n        lenN = len(secret)\\n        \\n        secDic = { str(i) : [0 , 0] for i in range(10)}\\n        \\n        for i in range(lenN):\\n            \\n            if(secret[i] == guess[i]):\\n                bulls += 1\\n            \\n            secDic[secret[i]][0] += 1\\n            secDic[guess[i]][1] += 1\\n        \\n        for i in range(10):\\n            cows += min(secDic[str(i)])\\n        \\n        return str(bulls) + \\'A\\' + str(cows - bulls) + \\'B\\'\\n            \\n            \\n        \\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def getHint(self, secret, guess):\\n        \\n        bulls, cows = 0, 0\\n        lenN = len(secret)\\n        \\n        secDic = { str(i) : [0 , 0] for i in range(10)}",
                "codeTag": "Java"
            },
            {
                "id": 2691464,
                "title": "c-simple-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHint(string &secret, string &guess) {\\n        int c = 0, b = 0, i = 0, n = secret.length();\\n        unordered_map<char,char> mp;\\n        for(i = 0; i < n; i++){\\n            if(secret[i]==guess[i]){\\n                b++;\\n                guess[i] = \\'#\\';\\n            }else{\\n                mp[secret[i]]++;\\n            }\\n        }\\n        for(auto &i: guess){\\n            if(i != \\'#\\' && mp.count(i) && mp[i]>0){\\n                c++;\\n            }\\n            mp[i]--;\\n        }\\n        return to_string(b)+\\'A\\'+to_string(c)+\\'B\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string &secret, string &guess) {\\n        int c = 0, b = 0, i = 0, n = secret.length();\\n        unordered_map<char,char> mp;\\n        for(i = 0; i < n; i++){\\n            if(secret[i]==guess[i]){\\n                b++;\\n                guess[i] = \\'#\\';\\n            }else{\\n                mp[secret[i]]++;\\n            }\\n        }\\n        for(auto &i: guess){\\n            if(i != \\'#\\' && mp.count(i) && mp[i]>0){\\n                c++;\\n            }\\n            mp[i]--;\\n        }\\n        return to_string(b)+\\'A\\'+to_string(c)+\\'B\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682111,
                "title": "swift-clean-easy-solution",
                "content": "```\\nclass Solution {\\n    func getHint(_ secret: String, _ guess: String) -> String {\\n\\t\\n        guard secret.count == guess.count else {return \"\"}\\n        \\n        var secretA = Array(secret)\\n        var guessA = Array(guess)\\n        \\n        var sDict : [Character : Int] = [:]\\n        var gDict : [Character : Int] = [:]\\n        \\n        var bulls = 0\\n        var cows = 0\\n        \\n        // Finding Bulls\\n        for i in 0..<secretA.count {\\n            if secretA[i] == guessA[i] {\\n                bulls += 1 \\n            }else{\\n                sDict[secretA[i],default:0] += 1\\n                gDict[guessA[i],default:0] += 1\\n            }\\n        }\\n        \\n        // Finding Cows\\n        for (key,val) in sDict{\\n            let minVal = min(gDict[key,default:0],val)\\n            cows += minVal\\n        }\\n        return \"\\\\(bulls)A\\\\(cows)B\"\\n\\t\\t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getHint(_ secret: String, _ guess: String) -> String {\\n\\t\\n        guard secret.count == guess.count else {return \"\"}\\n        \\n        var secretA = Array(secret)\\n        var guessA = Array(guess)\\n        \\n        var sDict : [Character : Int] = [:]\\n        var gDict : [Character : Int] = [:]\\n        \\n        var bulls = 0\\n        var cows = 0\\n        \\n        // Finding Bulls\\n        for i in 0..<secretA.count {\\n            if secretA[i] == guessA[i] {\\n                bulls += 1 \\n            }else{\\n                sDict[secretA[i],default:0] += 1\\n                gDict[guessA[i],default:0] += 1\\n            }\\n        }\\n        \\n        // Finding Cows\\n        for (key,val) in sDict{\\n            let minVal = min(gDict[key,default:0],val)\\n            cows += minVal\\n        }\\n        return \"\\\\(bulls)A\\\\(cows)B\"\\n\\t\\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638549,
                "title": "o-n-time",
                "content": "```\\nclass Solution:\\n    def getHint(self, se: str, gu: str) -> str:\\n        dcse=defaultdict(lambda:0)\\n        dcgu=defaultdict(lambda:0)\\n        a=0\\n        b=0\\n        for i in range(len(se)):\\n            if(se[i]==gu[i]):\\n                a+=1\\n            else:\\n                dcse[se[i]]+=1\\n                dcgu[gu[i]]+=1\\n        for x in dcse:\\n            if(dcgu[x]>=dcse[x]):\\n                b+=dcse[x]\\n            else:\\n                b+=dcgu[x]\\n        return(str(a)+\"A\"+str(b)+\"B\")\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, se: str, gu: str) -> str:\\n        dcse=defaultdict(lambda:0)\\n        dcgu=defaultdict(lambda:0)\\n        a=0\\n        b=0\\n        for i in range(len(se)):\\n            if(se[i]==gu[i]):\\n                a+=1\\n            else:\\n                dcse[se[i]]+=1\\n                dcgu[gu[i]]+=1\\n        for x in dcse:\\n            if(dcgu[x]>=dcse[x]):\\n                b+=dcse[x]\\n            else:\\n                b+=dcgu[x]\\n        return(str(a)+\"A\"+str(b)+\"B\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402184,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Unordered Map***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        int n = secret.size();\\n        \\n        // count the frequency of characters of secret\\n        \\n        unordered_map<char, int> mp;\\n        \\n        int bulls = 0;\\n        \\n        int cows = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bulls++;\\n            }\\n            else\\n            {\\n                mp[secret[i]]++;\\n            }\\n        }\\n        \\n        // count the no. of cows\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(secret[i] != guess[i])\\n            {\\n                if(mp[guess[i]] > 0)\\n                {\\n                    cows++;\\n                    \\n                    mp[guess[i]]--;\\n                }\\n            }\\n        }\\n        \\n        return to_string(bulls) + \"A\" + to_string(cows) + \"B\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        int n = secret.size();\\n        \\n        // count the frequency of characters of secret\\n        \\n        unordered_map<char, int> mp;\\n        \\n        int bulls = 0;\\n        \\n        int cows = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bulls++;\\n            }\\n            else\\n            {\\n                mp[secret[i]]++;\\n            }\\n        }\\n        \\n        // count the no. of cows\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(secret[i] != guess[i])\\n            {\\n                if(mp[guess[i]] > 0)\\n                {\\n                    cows++;\\n                    \\n                    mp[guess[i]]--;\\n                }\\n            }\\n        }\\n        \\n        return to_string(bulls) + \"A\" + to_string(cows) + \"B\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243064,
                "title": "easy-c-code-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        map<char,int> mp;\\n        int n=secret.size();\\n        int b=0,c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(secret[i]==guess[i])\\n                b++;\\n            else\\n                mp[secret[i]]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(secret[i]!=guess[i] && mp.find(guess[i])!=mp.end())\\n            {\\n                c++;\\n                mp[guess[i]]--;\\n                if(mp[guess[i]]==0)\\n                    mp.erase(guess[i]);\\n            }\\n        }\\n        string ans=to_string(b)+\"A\"+to_string(c)+\"B\";\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        map<char,int> mp;\\n        int n=secret.size();\\n        int b=0,c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(secret[i]==guess[i])\\n                b++;\\n            else\\n                mp[secret[i]]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(secret[i]!=guess[i] && mp.find(guess[i])!=mp.end())\\n            {\\n                c++;\\n                mp[guess[i]]--;\\n                if(mp[guess[i]]==0)\\n                    mp.erase(guess[i]);\\n            }\\n        }\\n        string ans=to_string(b)+\"A\"+to_string(c)+\"B\";\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220626,
                "title": "c-hasing-counting-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int n = secret.size(), a[10] = {0},b[10] = {0},bulls = 0,cows = 0;\\n        for(int i = 0;i<n;i++)\\n            if(secret[i] == guess[i]) bulls++;\\n            else{\\n                a[secret[i] - \\'0\\']++;\\n                b[guess[i] - \\'0\\']++;\\n            }\\n        for(int i = 0;i<10;i++) cows += min(a[i],b[i]);\\n        return to_string(bulls) + \\'A\\' + to_string(cows) + \\'B\\';\\n    }\\n    \\n};\\n```\\n![image](https://assets.leetcode.com/users/images/7dca8888-eddb-4cc3-8f4f-b55b794d6478_1656642536.3089802.png)\\n",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int n = secret.size(), a[10] = {0},b[10] = {0},bulls = 0,cows = 0;\\n        for(int i = 0;i<n;i++)\\n            if(secret[i] == guess[i]) bulls++;\\n            else{\\n                a[secret[i] - \\'0\\']++;\\n                b[guess[i] - \\'0\\']++;\\n            }\\n        for(int i = 0;i<10;i++) cows += min(a[i],b[i]);\\n        return to_string(bulls) + \\'A\\' + to_string(cows) + \\'B\\';\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715190,
                "title": "python-beats-100",
                "content": "Python solution using Counter\\n```from collections import Counter\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        a=0\\n        for i,j in zip(secret,guess):\\n            if (i==j):\\n                a+=1\\n        k=Counter(secret)\\n        l=Counter(guess)\\n        return \"%dA%dB\" % (a, sum((k & l).values()) - a)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Python solution using Counter\\n```from collections import Counter\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        a=0\\n        for i,j in zip(secret,guess):\\n            if (i==j):\\n                a+=1\\n        k=Counter(secret)\\n        l=Counter(guess)\\n        return \"%dA%dB\" % (a, sum((k & l).values()) - a)",
                "codeTag": "Java"
            },
            {
                "id": 979920,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        //count bulls first \\n        int bulls = 0, cows = 0;\\n        vector<int> sMap(10, 0);\\n        vector<int> gMap(10, 0);\\n        \\n        for (int i = 0; i < guess.size(); i++) {\\n            if (secret[i] == guess[i]) {\\n                bulls++;  \\n            } else {\\n                sMap[secret[i] - \\'0\\']++;\\n                gMap[guess[i] - \\'0\\']++;\\n            } \\n        }\\n        for (int i = 0; i < 10; i++) {\\n            cows += min(sMap[i], gMap[i]);\\n        }\\n        return to_string(bulls) + \\'A\\' + to_string(cows) + \\'B\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        //count bulls first \\n        int bulls = 0, cows = 0;\\n        vector<int> sMap(10, 0);\\n        vector<int> gMap(10, 0);\\n        \\n        for (int i = 0; i < guess.size(); i++) {\\n            if (secret[i] == guess[i]) {\\n                bulls++;  \\n            } else {\\n                sMap[secret[i] - \\'0\\']++;\\n                gMap[guess[i] - \\'0\\']++;\\n            } \\n        }\\n        for (int i = 0; i < 10; i++) {\\n            cows += min(sMap[i], gMap[i]);\\n        }\\n        return to_string(bulls) + \\'A\\' + to_string(cows) + \\'B\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840712,
                "title": "java-beats-100-runtime-1ms-use-only-array",
                "content": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        char [] s = secret.toCharArray();\\n        char [] g = guess.toCharArray();\\n        \\n        int [] count = new int[10];\\n        int a = 0;\\n        int b = 0;\\n        \\n        StringBuffer sb = new StringBuffer();\\n\\n        for(int i=0; i<s.length; i++){\\n            if(s[i] == g[i]){\\n                g[i] = \\'*\\';\\n                a++;\\n            }else{\\n                count[s[i]-\\'0\\']++;\\n            }\\n        }\\n        \\n        for(int i=0; i<g.length; i++){\\n            if(g[i] != \\'*\\' && count[g[i]-\\'0\\'] > 0){\\n                count[g[i] - \\'0\\']--;\\n                b++;\\n            }\\n        }\\n        \\n        return sb.append(a).append(\"A\").append(b).append(\"B\").toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        char [] s = secret.toCharArray();\\n        char [] g = guess.toCharArray();\\n        \\n        int [] count = new int[10];\\n        int a = 0;\\n        int b = 0;\\n        \\n        StringBuffer sb = new StringBuffer();\\n\\n        for(int i=0; i<s.length; i++){\\n            if(s[i] == g[i]){\\n                g[i] = \\'*\\';\\n                a++;\\n            }else{\\n                count[s[i]-\\'0\\']++;\\n            }\\n        }\\n        \\n        for(int i=0; i<g.length; i++){\\n            if(g[i] != \\'*\\' && count[g[i]-\\'0\\'] > 0){\\n                count[g[i] - \\'0\\']--;\\n                b++;\\n            }\\n        }\\n        \\n        return sb.append(a).append(\"A\").append(b).append(\"B\").toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839867,
                "title": "python-two-pass-20ms",
                "content": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        a=0\\n        b=0\\n        for i,j in zip(secret,guess):\\n            if i==j:\\n                a+=1 \\n                secret=secret.replace(i,\\'*\\',1)\\n                guess=guess.replace(i,\\')\\',1)\\n        for j in guess:    \\n            if j in secret:\\n                b+=1 \\n                secret=secret.replace(j,\\'*\\',1)\\n        return str(a)+\"A\"+str(b)+\"B\"\\n```\\n\\nRuntime: 20 ms, faster than 100.00% of Python3 online submissions for Bulls and Cows.\\nMemory Usage: 13.7 MB, less than 93.70% of Python3 online submissions for Bulls and Cows.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        a=0\\n        b=0\\n        for i,j in zip(secret,guess):\\n            if i==j:\\n                a+=1 \\n                secret=secret.replace(i,\\'*\\',1)\\n                guess=guess.replace(i,\\')\\',1)\\n        for j in guess:    \\n            if j in secret:\\n                b+=1 \\n                secret=secret.replace(j,\\'*\\',1)\\n        return str(a)+\"A\"+str(b)+\"B\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839854,
                "title": "c-99-43-simple-using-vector",
                "content": "The solution goes like\\n* Compare strings to find bulls\\n* Save the numbers that could be found as cows (i.e. all except the bulls)\\n* Compare the guess with the possible cows, to get total cows\\n\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        string ret;\\n        int num=0;\\n        \\n        //for bulls\\n        for(int i=0; i<secret.size()&&i<guess.size(); i++)\\n        {\\n            if(secret[i]==guess[i])\\n                num++;\\n        }\\n        ret.append(to_string(num));\\n        ret.push_back(\\'A\\');\\n        num=0;\\n        \\n        //for cows\\n        vector<int> sec(10, 0);\\n        for(int i=0; i<secret.size(); i++)\\n        {\\n            if(i<guess.size()&&(guess[i]!=secret[i]))\\n                sec[secret[i]-\\'0\\']++;\\n        }\\n        \\n        for(int i=0; i<guess.size(); i++)\\n        {\\n            if(sec[guess[i]-\\'0\\']&&guess[i]!=secret[i])\\n            {\\n                sec[guess[i]-\\'0\\']--;\\n                num++;\\n            }\\n        }\\n        \\n        ret.append(to_string(num));\\n        ret.push_back(\\'B\\');\\n        \\n        return ret;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        string ret;\\n        int num=0;\\n        \\n        //for bulls\\n        for(int i=0; i<secret.size()&&i<guess.size(); i++)\\n        {\\n            if(secret[i]==guess[i])\\n                num++;\\n        }\\n        ret.append(to_string(num));\\n        ret.push_back(\\'A\\');\\n        num=0;\\n        \\n        //for cows\\n        vector<int> sec(10, 0);\\n        for(int i=0; i<secret.size(); i++)\\n        {\\n            if(i<guess.size()&&(guess[i]!=secret[i]))\\n                sec[secret[i]-\\'0\\']++;\\n        }\\n        \\n        for(int i=0; i<guess.size(); i++)\\n        {\\n            if(sec[guess[i]-\\'0\\']&&guess[i]!=secret[i])\\n            {\\n                sec[guess[i]-\\'0\\']--;\\n                num++;\\n            }\\n        }\\n        \\n        ret.append(to_string(num));\\n        ret.push_back(\\'B\\');\\n        \\n        return ret;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839767,
                "title": "efficicient-c-solution-comments-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int pairs(string str1, string str2, int size){\\n        // Counting the frequency of numbers in str1 and str2.\\n        int f1[10] = { 0 };\\n        int f2[10] = { 0 };\\n        int i, c = 0;\\n        \\n        for (i = 0; i < size; i++)\\n          f1[str1[i] - \\'0\\']++;\\n        \\n        for (i = 0; i < size; i++)\\n          f2[str2[i] - \\'0\\']++;\\n        \\n        // Counting common characters in  the strings.\\n        for (i = 0; i < 10; i++)\\n          c += (min(f1[i], f2[i]));\\n        \\n        return c;\\n    }\\n    string getHint(string secret, string guess) {\\n        int a=0,b,n = secret.size();\\n        \\n        b=pairs(secret,guess,n); // Common characters \\n        \\n        for(int i=0;i<n;i++) // Common characters with correct positions.\\n            if(secret[i]==guess[i])\\n                a++;\\n        \\n        // b contains all the common characters, so removing bulls.\\n        string res=to_string(a)+\\'A\\'+to_string(b-a)+\\'B\\'; \\n        return res;\\n    }\\n};\\n```\\n* Upvote if you like this solution.\\n* Open for discussion.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairs(string str1, string str2, int size){\\n        // Counting the frequency of numbers in str1 and str2.\\n        int f1[10] = { 0 };\\n        int f2[10] = { 0 };\\n        int i, c = 0;\\n        \\n        for (i = 0; i < size; i++)\\n          f1[str1[i] - \\'0\\']++;\\n        \\n        for (i = 0; i < size; i++)\\n          f2[str2[i] - \\'0\\']++;\\n        \\n        // Counting common characters in  the strings.\\n        for (i = 0; i < 10; i++)\\n          c += (min(f1[i], f2[i]));\\n        \\n        return c;\\n    }\\n    string getHint(string secret, string guess) {\\n        int a=0,b,n = secret.size();\\n        \\n        b=pairs(secret,guess,n); // Common characters \\n        \\n        for(int i=0;i<n;i++) // Common characters with correct positions.\\n            if(secret[i]==guess[i])\\n                a++;\\n        \\n        // b contains all the common characters, so removing bulls.\\n        string res=to_string(a)+\\'A\\'+to_string(b-a)+\\'B\\'; \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839586,
                "title": "java-simple-solution-faster-than-91",
                "content": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bull = 0;\\n        int cow = 0;\\n        int len = secret.length();\\n        int[] count = new int[10];\\n        // store frequency of each number:\\n        for (int i=0; i<len; i++)\\n            count[secret.charAt(i)-\\'0\\']++;\\n        \\n        for (int i=0; i<len; i++) {\\n            count[guess.charAt(i)-\\'0\\']--;\\n            if (count[guess.charAt(i)-\\'0\\'] >=0)\\n                cow++;\\n        }\\n        \\n        for (int i=0; i<len; i++) {\\n            if (guess.charAt(i) == secret.charAt(i)) {\\n                cow--; bull++;\\n            }\\n        }\\n        \\n        return bull+\"A\"+cow+\"B\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bull = 0;\\n        int cow = 0;\\n        int len = secret.length();\\n        int[] count = new int[10];\\n        // store frequency of each number:\\n        for (int i=0; i<len; i++)\\n            count[secret.charAt(i)-\\'0\\']++;\\n        \\n        for (int i=0; i<len; i++) {\\n            count[guess.charAt(i)-\\'0\\']--;\\n            if (count[guess.charAt(i)-\\'0\\'] >=0)\\n                cow++;\\n        }\\n        \\n        for (int i=0; i<len; i++) {\\n            if (guess.charAt(i) == secret.charAt(i)) {\\n                cow--; bull++;\\n            }\\n        }\\n        \\n        return bull+\"A\"+cow+\"B\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839467,
                "title": "4-pass-java-solution",
                "content": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int[] countS = new int[10];\\n        int[] countG = new int[10];\\n        for(char c : secret.toCharArray()){\\n            countS[c-\\'0\\']++;\\n        }\\n        for(char c : guess.toCharArray()){\\n            countG[c - \\'0\\']++;\\n        }\\n        \\n        int same_count = 0;\\n        for(int i=0;i<10;i++){\\n            same_count+=Math.min(countS[i],countG[i]);\\n        }\\n        \\n        int bulls = 0;\\n        for(int i=0;i<secret.length();i++){\\n            if(secret.charAt(i) == guess.charAt(i)){\\n                bulls++;\\n            }\\n        }\\n        int cows = same_count - bulls;\\n        String res = \"\"+bulls+\"A\"+cows+\"B\";\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int[] countS = new int[10];\\n        int[] countG = new int[10];\\n        for(char c : secret.toCharArray()){\\n            countS[c-\\'0\\']++;\\n        }\\n        for(char c : guess.toCharArray()){\\n            countG[c - \\'0\\']++;\\n        }\\n        \\n        int same_count = 0;\\n        for(int i=0;i<10;i++){\\n            same_count+=Math.min(countS[i],countG[i]);\\n        }\\n        \\n        int bulls = 0;\\n        for(int i=0;i<secret.length();i++){\\n            if(secret.charAt(i) == guess.charAt(i)){\\n                bulls++;\\n            }\\n        }\\n        int cows = same_count - bulls;\\n        String res = \"\"+bulls+\"A\"+cows+\"B\";\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693844,
                "title": "decent-python-code-beats-99-77",
                "content": "```\\n    def getHint(self, secret: str, guess: str) -> str:\\n        c, b = 0, 0\\n        for i in range(len(secret)):\\n            if secret[i] == guess[i]: b += 1\\n        for i in range(len(secret)):\\n            if secret[i] in guess:\\n                c += min(secret.count(secret[i]), guess.count(secret[i]))\\n                guess = guess.replace(secret[i], \"\")\\n        return str(b) + \"A\" + str(c-b) + \"B\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def getHint(self, secret: str, guess: str) -> str:\\n        c, b = 0, 0\\n        for i in range(len(secret)):\\n            if secret[i] == guess[i]: b += 1\\n        for i in range(len(secret)):\\n            if secret[i] in guess:\\n                c += min(secret.count(secret[i]), guess.count(secret[i]))\\n                guess = guess.replace(secret[i], \"\")\\n        return str(b) + \"A\" + str(c-b) + \"B\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 646535,
                "title": "c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int count[10] = {0};\\n        int bull = 0, cow = 0;\\n        \\n        for (int i = 0; secret[i]; i ++) {\\n            if (secret[i] == guess[i]) bull ++;\\n            else {\\n                cow += (count[secret[i] - \\'0\\'] ++ < 0);\\n                cow += (count[guess[i] - \\'0\\'] -- > 0);\\n            }\\n        }\\n        \\n        return to_string(bull) + \"A\" + to_string(cow) + \"B\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int count[10] = {0};\\n        int bull = 0, cow = 0;\\n        \\n        for (int i = 0; secret[i]; i ++) {\\n            if (secret[i] == guess[i]) bull ++;\\n            else {\\n                cow += (count[secret[i] - \\'0\\'] ++ < 0);\\n                cow += (count[guess[i] - \\'0\\'] -- > 0);\\n            }\\n        }\\n        \\n        return to_string(bull) + \"A\" + to_string(cow) + \"B\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592476,
                "title": "python-3-lines-85-using-enumerate-and-counter",
                "content": "Note: The intersection of two Counter() objects return the lowest count found in either hashable iterable for each element.\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        \\n        countA = len(set(enumerate(secret)).intersection(set(enumerate(guess))))\\n        countB = len(list((Counter(secret) & Counter(guess)).elements()))\\n        \\n        return \"{}A{}B\".format(countA, countB-countA)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        \\n        countA = len(set(enumerate(secret)).intersection(set(enumerate(guess))))\\n        countB = len(list((Counter(secret) & Counter(guess)).elements()))\\n        \\n        return \"{}A{}B\".format(countA, countB-countA)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518669,
                "title": "java-2-hashmap",
                "content": "```\\npublic String getHint(String s, String g) {\\n        int l = s.length();\\n        if(g.length() != l) return null;\\n        Map<Character, Integer> sm = new HashMap<>();\\n        Map<Character, Integer> gm = new HashMap<>();\\n        int bl = 0, cw = 0;\\n        for (int i = 0; i < l; i++){\\n            char c = s.charAt(i);\\n            char d = g.charAt(i);\\n            if (c == d) bl++;\\n            else {\\n                sm.put(c, sm.getOrDefault(c, 0) + 1);\\n                gm.put(d, gm.getOrDefault(d, 0) + 1);\\n            }\\n        }\\n        for (char c : gm.keySet()){\\n            cw += Math.min(gm.get(c), sm.getOrDefault(c, 0));\\n        }\\n        return bl + \"A\" + cw + \"B\";\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic String getHint(String s, String g) {\\n        int l = s.length();\\n        if(g.length() != l) return null;\\n        Map<Character, Integer> sm = new HashMap<>();\\n        Map<Character, Integer> gm = new HashMap<>();\\n        int bl = 0, cw = 0;\\n        for (int i = 0; i < l; i++){\\n            char c = s.charAt(i);\\n            char d = g.charAt(i);\\n            if (c == d) bl++;\\n            else {\\n                sm.put(c, sm.getOrDefault(c, 0) + 1);\\n                gm.put(d, gm.getOrDefault(d, 0) + 1);\\n            }\\n        }\\n        for (char c : gm.keySet()){\\n            cw += Math.min(gm.get(c), sm.getOrDefault(c, 0));\\n        }\\n        return bl + \"A\" + cw + \"B\";\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 383596,
                "title": "easy-c-solution-0ms-o-n",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Bulls and Cows.\\nMemory Usage: 8.8 MB, less than 100.00% of C++ online submissions for Bulls and Cows.\\n\\n```\\n\\tstring getHint(string secret, string guess) {\\n        \\n        int bull = 0;\\n        int cow = 0;\\n        int stat[10] = {0};\\n        \\n        for(int i=0; i<secret.size(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n                bull++;\\n            else\\n                stat[secret[i] - \\'0\\']++;\\n        }\\n        \\n        for(int i=0; i<guess.size(); i++)\\n            if(secret[i] != guess[i] && stat[guess[i] - \\'0\\']-- > 0)\\n                cow++;\\n    \\n        return (to_string(bull) + \"A\" + to_string(cow) + \"B\");\\n    }\\n",
                "solutionTags": [],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Bulls and Cows.\\nMemory Usage: 8.8 MB, less than 100.00% of C++ online submissions for Bulls and Cows.\\n\\n```\\n\\tstring getHint(string secret, string guess) {\\n        \\n        int bull = 0;\\n        int cow = 0;\\n        int stat[10] = {0};\\n        \\n        for(int i=0; i<secret.size(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n                bull++;\\n            else\\n                stat[secret[i] - \\'0\\']++;\\n        }\\n        \\n        for(int i=0; i<guess.size(); i++)\\n            if(secret[i] != guess[i] && stat[guess[i] - \\'0\\']-- > 0)\\n                cow++;\\n    \\n        return (to_string(bull) + \"A\" + to_string(cow) + \"B\");\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 351223,
                "title": "fast-and-idea-derivation-full-explanation-java-100-beat",
                "content": "Question asked us two different things\\n1. Find how many digits that are matched and right position (bulls)\\n2. . Find how many digits that are matched and but not at right position (cows).\\n\\nImportant observation here is that, each character in given input is only a single \"digit\" and a digit can be only from \"0-9\".\\nWe\\'ll use array of 10 to track each item presence from secret and guess. \\n\\nNow, if at particular index two case happens \\n1. If they match ; -> increase bulls without any doubt\\n2. If they don\\'t match; Now since they don\\'t match there could be two posibilites \\n\\t\\ta. If the guess character is not present in our secret[till this index]; then we need to ignore it. We reduce its occurrence \\n\\t\\tb. if the guess character is present (means has seen in secret already ) then we need to mark as used so decrease it. \\n\\t\\tc. keep track of secret character all the time. \\n\\t\\t\\nBut how do we count cows? \\nNotice, when we decrease a particular digit occurrence there is possibility that it still there ( means its occurrence is 5 so far, so still we have 4 left ) or not there at all (in the case we are ahead in guess i.e. that particular char has not been occurred as of now in secret ).\\nLets say \\'s\\' represent char in secret and \\'g\\' for guess at this current index. \\n\\nso whenever we see the digit occurrence at \\'s\\' character  as negative (second case) we increase cow\\nand when we see digit occurrence at \\'g\\' character as positive (first case) we increase cow.\\nAlso keep doing the above.\\n\\n```\\n  public String getHint(String secret, String guess) {\\n\\n        if (secret == null || secret.isEmpty() || guess == null || guess.isEmpty())\\n            return \"\";\\n\\n        // System.out.println(\"Secret: \" + secret + \" guess : \" + guess);\\n\\n        int len = secret.length();\\n\\n        int bulls = 0;\\n        int cow = 0;\\n\\n        int digits[] = new int[10]; //0-9\\n\\n        for (int i = 0; i < len; i++) {\\n            char s = secret.charAt(i);\\n            char g = guess.charAt(i);\\n\\n            if (s == g) // if they match and right location\\n                bulls++;\\n            else {\\n                //if they dont match or are not at right position\\n\\n                if (digits[s - \\'0\\'] < 0) //This position/number has not been counted but occurred in guess\\n                    cow++;\\n                digits[s - \\'0\\']++; // mark the presense of this number\\n                \\n\\n                if (digits[g - \\'0\\'] > 0)  //This position/number has not been counted but occurred in secret\\n                    cow++;\\n                digits[g - \\'0\\']--;// remove its presense \\n\\n            }\\n        }\\n\\n\\n        return \"\" + bulls + \"A\" + cow + \"B\";\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public String getHint(String secret, String guess) {\\n\\n        if (secret == null || secret.isEmpty() || guess == null || guess.isEmpty())\\n            return \"\";\\n\\n        // System.out.println(\"Secret: \" + secret + \" guess : \" + guess);\\n\\n        int len = secret.length();\\n\\n        int bulls = 0;\\n        int cow = 0;\\n\\n        int digits[] = new int[10]; //0-9\\n\\n        for (int i = 0; i < len; i++) {\\n            char s = secret.charAt(i);\\n            char g = guess.charAt(i);\\n\\n            if (s == g) // if they match and right location\\n                bulls++;\\n            else {\\n                //if they dont match or are not at right position\\n\\n                if (digits[s - \\'0\\'] < 0) //This position/number has not been counted but occurred in guess\\n                    cow++;\\n                digits[s - \\'0\\']++; // mark the presense of this number\\n                \\n\\n                if (digits[g - \\'0\\'] > 0)  //This position/number has not been counted but occurred in secret\\n                    cow++;\\n                digits[g - \\'0\\']--;// remove its presense \\n\\n            }\\n        }\\n\\n\\n        return \"\" + bulls + \"A\" + cow + \"B\";\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234742,
                "title": "python-beats-100-using-defaultdict",
                "content": "```\\nclass Solution:\\n    def getHint(self, s: \\'str\\', g: \\'str\\') -> \\'str\\':\\n        bulls,cows=0,0\\n        dict1,dict2 = collections.defaultdict(lambda: 0),collections.defaultdict(lambda: 0)\\n        for i in range(len(s)):\\n            if(s[i]==g[i]):\\n                bulls+=1\\n            else:\\n                dict1[s[i]]+=1\\n                dict2[g[i]]+=1\\n        for m in dict2.keys():\\n            cows += min(dict1[m],dict2[m])\\n        return str(bulls)+\"A\"+str(cows)+\"B\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHint(self, s: \\'str\\', g: \\'str\\') -> \\'str\\':\\n        bulls,cows=0,0\\n        dict1,dict2 = collections.defaultdict(lambda: 0),collections.defaultdict(lambda: 0)\\n        for i in range(len(s)):\\n            if(s[i]==g[i]):\\n                bulls+=1\\n            else:\\n                dict1[s[i]]+=1\\n                dict2[g[i]]+=1\\n        for m in dict2.keys():\\n            cows += min(dict1[m],dict2[m])\\n        return str(bulls)+\"A\"+str(cows)+\"B\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74615,
                "title": "short-an-sweet-python-solution",
                "content": "```\\nclass Solution:\\n    def getHint(self, secret, guess):\\n        \"\"\"\\n        :type secret: str\\n        :type guess: str\\n        :rtype: str\\n        \"\"\"\\n        bull, cow = 0, 0\\n        cache = {}\\n        for i, v in enumerate(secret):\\n            if v == guess[i]:\\n                bull += 1\\n            else:\\n                cache[v] = cache[v] + 1 if v in cache else 1\\n\\n        for i, v in enumerate(guess):\\n            if v != secret[i] and v in cache and cache[v] > 0:\\n                cow += 1\\n                cache[v] -= 1\\n        return \"{}A{}B\".format(bull, cow)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret, guess):\\n        \"\"\"\\n        :type secret: str\\n        :type guess: str\\n        :rtype: str\\n        \"\"\"\\n        bull, cow = 0, 0\\n        cache = {}\\n        for i, v in enumerate(secret):\\n            if v == guess[i]:\\n                bull += 1\\n            else:\\n                cache[v] = cache[v] + 1 if v in cache else 1\\n\\n        for i, v in enumerate(guess):\\n            if v != secret[i] and v in cache and cache[v] > 0:\\n                cow += 1\\n                cache[v] -= 1\\n        return \"{}A{}B\".format(bull, cow)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74680,
                "title": "easy-java-solution-using-hash-map",
                "content": "```\\npublic class Solution {\\n    public String getHint(String secret, String guess) {\\n        int i, bulls = 0, cows = 0, size = secret.length();\\n        char s, g;\\n        int[] hMap = new int[256];\\n        for(i = 0; i < size; i++) {\\n            s = secret.charAt(i);\\n            g = guess.charAt(i);\\n            if (s == g) {\\n                bulls++;\\n            } else {\\n                hMap[s-'\\\\0']++;\\n            }\\n        }\\n        for(i = 0; i < size; i++) {\\n            g = guess.charAt(i);\\n            s = secret.charAt(i);\\n            if(hMap[g-'\\\\0'] > 0 && g != s) {\\n                cows++;\\n                hMap[g-'\\\\0']--;\\n            }\\n        }\\n        \\n        return bulls+\"A\"+cows+\"B\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String getHint(String secret, String guess) {\\n        int i, bulls = 0, cows = 0, size = secret.length();\\n        char s, g;\\n        int[] hMap = new int[256];\\n        for(i = 0; i < size; i++) {\\n            s = secret.charAt(i);\\n            g = guess.charAt(i);\\n            if (s == g) {\\n                bulls++;\\n            } else {\\n                hMap[s-'\\\\0']++;\\n            }\\n        }\\n        for(i = 0; i < size; i++) {\\n            g = guess.charAt(i);\\n            s = secret.charAt(i);\\n            if(hMap[g-'\\\\0'] > 0 && g != s) {\\n                cows++;\\n                hMap[g-'\\\\0']--;\\n            }\\n        }\\n        \\n        return bulls+\"A\"+cows+\"B\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 74720,
                "title": "2ms-java-solution-beat-98-4",
                "content": "    public class Solution \\n    {\\n        public String getHint(String secret, String guess) \\n    \\t{\\n            if (secret == null || secret.length() == 0)\\n    \\t\\t{\\n    \\t\\t\\treturn \"0A0B\";\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tint bull = 0;\\n    \\t\\tint total = 0;\\n    \\t\\tchar[] sChar = secret.toCharArray();\\n    \\t\\tchar[] gChar = guess.toCharArray();\\n    \\t\\tint[] flags = new int[10];\\n    \\t\\t\\n    \\t\\tfor (char c : sChar)\\n    \\t\\t{\\n    \\t\\t\\tflags[c - '0']++;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor (int i = 0; i < sChar.length; i++)\\n    \\t\\t{\\n    \\t\\t\\tif (gChar[i] == sChar[i])\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tbull++;\\n    \\t\\t\\t}\\n    \\t\\t\\t\\n    \\t\\t\\tif (flags[gChar[i] - '0']-- > 0)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\ttotal++;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn bull + \"A\" + (total - bull) + \"B\";\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution \\n    {\\n        public String getHint(String secret, String guess) \\n    \\t{\\n            if (secret == null || secret.length() == 0)\\n    \\t\\t{\\n    \\t\\t\\treturn \"0A0B\";\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 74731,
                "title": "very-few-javascript-solutions-here-s-one-pls-leave-feedback-tks",
                "content": "    /**\\n     * @param {string} secret\\n     * @param {string} guess\\n     * @return {string}\\n     */\\n    var getHint = function(secret, guess) {\\n        var secret_digits={},\\n            guess_digits=[],\\n            s = secret.split(''),\\n            g = guess.split(''),\\n            bulls = 0,\\n            cows = 0;\\n        for(var i=0; i<s.length; i++){\\n            if (s[i]===g[i]){\\n                bulls++;\\n            }\\n            else {\\n                secret_digits[s[i]] = (secret_digits[s[i]] === undefined)? 1 : secret_digits[s[i]]+1;\\n                guess_digits.push(g[i]);\\n            }\\n        }\\n    \\n        guess_digits.forEach(function(digit) {\\n            if(secret_digits[digit]){\\n                cows++;\\n                secret_digits[digit]--;\\n            }\\n        });\\n        return bulls + 'A' + cows + 'B';\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    /**\\n     * @param {string} secret\\n     * @param {string} guess\\n     * @return {string}\\n     */\\n    var getHint = function(secret, guess) {\\n        var secret_digits={},\\n            guess_digits=[],\\n            s = secret.split(''),\\n            g = guess.split(''),\\n            bulls = 0,\\n            cows = 0;\\n        for(var i=0; i<s.length; i++){\\n            if (s[i]===g[i]){\\n                bulls++;\\n            }\\n            else {\\n                secret_digits[s[i]] = (secret_digits[s[i]] === undefined)? 1 : secret_digits[s[i]]+1;\\n                guess_digits.push(g[i]);\\n            }\\n        }\\n    \\n        guess_digits.forEach(function(digit) {\\n            if(secret_digits[digit]){\\n                cows++;\\n                secret_digits[digit]--;\\n            }\\n        });\\n        return bulls + 'A' + cows + 'B';\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 74726,
                "title": "simple-easy-understand-cpp",
                "content": "    class Solution {\\n    public:\\n        string getHint(string secret, string guess) {\\n            \\n            int n = secret.size();\\n            int p[10] = {0}; //record how many times chars in Secret guessed by Guess\\n            int A = 0;\\n            for (int i = 0; i < n; i++) {\\n                p[secret[i] - '0'] ++; //Appeared\\n                p[guess[i] - '0'] --; //Guessed\\n                \\n                if (secret[i] == guess[i]) A++; //Matched\\n            }\\n            \\n            int left = 0; //Elements in P that > 0 are those in Secret but not fully guessed by Guess\\n            for (int i = 0; i < 10; i++) {\\n                left += (p[i] > 0) ?p[i] :0;\\n            }\\n            //A is cow, n-left is guessed right, n-left-A is bull\\n            ostringstream oss;\\n            oss << A << \"A\" << n - left - A << \"B\";\\n            return oss.str();\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string getHint(string secret, string guess) {\\n            \\n            int n = secret.size();\\n            int p[10] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 74794,
                "title": "poorly-worded-question",
                "content": "Can the original asker or an admin please modify the problem statement? I am extremely confused by the test cases that are being produced based on the problem description:\\n\\nThe problem clearly states that the guess and the secret are of length 4. But given this, why am I seeing test cases like:\\n\\n1. Secret: \"\"\\n    Guess: \"\"\\n    Expected Output: \"0A0B\"\\n    Complaint Issue: Nothing in the problem says anything of handling strings less than length 4, let alone the empty case of all things - please do not claim the length is 4 when we are supposed to handle this case.\\n\\n2. Secret: \"1\"\\n    Guess: \"0\"\\n    Expected Output: \"0A0B\"\\n    Complaint Issue: In addition to violating the length 4 specification, why does this expect 0 cows? There is clearly 1 digit not in the correct place which, according to the problem, counts as a cow. If we are simply to return 0A0B for all strings not of length 4, then please put that in the specification. But somehow this is not true either since.....\\n\\n3. Secret \"1\"\\n    Guess: \"1\"\\n    Expected Output: \"1A0B\"\\n    Complaint Issue: Directly contradicts what the previous test case revelation suggests. \\n\\nThank you for your time.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 74791,
                "title": "java-python-o-n-solutions",
                "content": "Calculate `bulls` is easy. Just sum all the characters that are equal. To calculate `cows`, first, we use Counter to get digit counts for both secret and guess. For each digit, its contribution is the min of its occurrence in the two strings and Counter provides the \"&\" operator to do the min thing. `cows` is then sum of all these min values subtract `bulls`.\\n\\n**Python solution with Counter**\\n\\n    from collections import Counter\\n    def getHint(self, secret, guess):\\n        bulls = sum(g == s for g, s in zip(secret, guess))\\n        cows = sum((Counter(secret) & Counter(guess)).values()) - bulls\\n        return \"{0}A{1}B\".format(bulls, cows)\\n\\n    # Runtime: 76 ms\\n\\n\\n**Java one pass solution**\\n\\n    public class Solution {\\n        public String getHint(String secret, String guess) {\\n            int bulls = 0, cows = 0;\\n            int[] s = new int[10];\\n            for (int i = 0; i < secret.length(); ++i) {\\n                int sc = Character.getNumericValue(secret.charAt(i));\\n                int gc = Character.getNumericValue(guess.charAt(i));\\n                if (sc == gc) ++bulls;\\n                else {\\n                    if (s[sc] < 0) ++cows;\\n                    if (s[gc] > 0) ++cows;\\n                    ++s[sc];\\n                    --s[gc];\\n                }\\n            }\\n            return String.format(\"%dA%dB\", bulls, cows);\\n        }\\n    }\\n    // Runtime: 18 ms",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "class Solution {\\n        public String getHint(String secret, String guess) {\\n            int bulls = 0, cows = 0;\\n            int[] s = new int[10];\\n            for (int i = 0; i < secret.length(); ++i) {\\n                int sc = Character.getNumericValue(secret.charAt(i));\\n                int gc = Character.getNumericValue(guess.charAt(i));\\n                if (sc == gc) ++bulls;\\n                else {\\n                    if (s[sc] < 0) ++cows;\\n                    if (s[gc] > 0) ++cows;\\n                    ++s[sc];\\n                    --s[gc];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3443416,
                "title": "java-solution-beats-100-o-n",
                "content": "# UPVOTE \\u2B06\\uFE0F\\uD83D\\uDD1D\\u2B06\\uFE0F\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int secdigs[] = new int[10];\\n        int guessdigs[] = new int[10];\\n        int bull = 0, cow = 0;\\n\\n        for(int i = 0; i < secret.length() ; i ++) {\\n            if(secret.charAt(i) == guess.charAt(i)) {\\n                bull ++;\\n            }\\n            else {\\n                secdigs[secret.charAt(i) - \\'0\\'] ++;\\n                guessdigs[guess.charAt(i) - \\'0\\'] ++;\\n            }\\n        }\\n\\n        for(int i = 0; i < 10; i ++) {\\n            int minVal = secdigs[i];\\n            if(minVal > guessdigs[i]) minVal = guessdigs[i];\\n         \\n            cow += minVal;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(bull).append(\"A\").append(cow).append(\"B\");\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int secdigs[] = new int[10];\\n        int guessdigs[] = new int[10];\\n        int bull = 0, cow = 0;\\n\\n        for(int i = 0; i < secret.length() ; i ++) {\\n            if(secret.charAt(i) == guess.charAt(i)) {\\n                bull ++;\\n            }\\n            else {\\n                secdigs[secret.charAt(i) - \\'0\\'] ++;\\n                guessdigs[guess.charAt(i) - \\'0\\'] ++;\\n            }\\n        }\\n\\n        for(int i = 0; i < 10; i ++) {\\n            int minVal = secdigs[i];\\n            if(minVal > guessdigs[i]) minVal = guessdigs[i];\\n         \\n            cow += minVal;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(bull).append(\"A\").append(cow).append(\"B\");\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360116,
                "title": "using-cpp-and-map",
                "content": "![UPvote.jpg](https://assets.leetcode.com/users/images/1c05a01e-d2a8-44d5-a471-c3c241ec68d9_1680199184.034172.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        unordered_map<char,int>m;\\n        unordered_map<char,int>n;\\n        string str;\\n        int c = 0;\\n        for(int i=0;i<secret.size();i++){\\n            if(secret[i]==guess[i]){\\n                c++;\\n            }\\n        }\\n        str += to_string(c);\\n        str += \\'A\\';\\n        for(auto i:secret){\\n            m[i]++;\\n        }\\n        for(auto i:guess){\\n            n[i]++;\\n        }\\n        int cnt = 0;\\n        for(auto i:m){\\n            for(auto j:n){\\n                if(i.first==j.first){\\n                    cnt += min(i.second,j.second);\\n                }\\n            }\\n        }\\n        cnt = cnt - c;\\n        cout << cnt;\\n        str += to_string(cnt);\\n        str += \\'B\\';\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        unordered_map<char,int>m;\\n        unordered_map<char,int>n;\\n        string str;\\n        int c = 0;\\n        for(int i=0;i<secret.size();i++){\\n            if(secret[i]==guess[i]){\\n                c++;\\n            }\\n        }\\n        str += to_string(c);\\n        str += \\'A\\';\\n        for(auto i:secret){\\n            m[i]++;\\n        }\\n        for(auto i:guess){\\n            n[i]++;\\n        }\\n        int cnt = 0;\\n        for(auto i:m){\\n            for(auto j:n){\\n                if(i.first==j.first){\\n                    cnt += min(i.second,j.second);\\n                }\\n            }\\n        }\\n        cnt = cnt - c;\\n        cout << cnt;\\n        str += to_string(cnt);\\n        str += \\'B\\';\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3281816,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nString getHint(String secret, String guess) {\\n  int bulls = 0;\\n  int cows = 0;\\n  Map<String, int> digitCount = {};\\n\\n  for (int i = 0; i < secret.length; i++) {\\n    if (secret[i] == guess[i]) {\\n      bulls++;\\n    } else {\\n      digitCount[secret[i]] = (digitCount[secret[i]] ?? 0) + 1;\\n    }\\n  }\\n\\n  for (int i = 0; i < guess.length; i++) {\\n    if (guess[i] != secret[i] && digitCount.containsKey(guess[i]) && digitCount[guess[i]]! > 0) {\\n      cows++;\\n      digitCount[guess[i]] = digitCount[guess[i]]! - 1;\\n    }\\n  }\\n\\n  return \\'$bulls\\' + \\'A\\' + \\'$cows\\' + \\'B\\';\\n}\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\nString getHint(String secret, String guess) {\\n  int bulls = 0;\\n  int cows = 0;\\n  Map<String, int> digitCount = {};\\n\\n  for (int i = 0; i < secret.length; i++) {\\n    if (secret[i] == guess[i]) {\\n      bulls++;\\n    } else {\\n      digitCount[secret[i]] = (digitCount[secret[i]] ?? 0) + 1;\\n    }\\n  }\\n\\n  for (int i = 0; i < guess.length; i++) {\\n    if (guess[i] != secret[i] && digitCount.containsKey(guess[i]) && digitCount[guess[i]]! > 0) {\\n      cows++;\\n      digitCount[guess[i]] = digitCount[guess[i]]! - 1;\\n    }\\n  }\\n\\n  return \\'$bulls\\' + \\'A\\' + \\'$cows\\' + \\'B\\';\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235693,
                "title": "c-solution-with-comments-for-better-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHint(string s, string g) {\\n        // initialize value of cow and bull\\n        int bull= 0, cow=0, ln= s.size();\\n        \\n        // to store frequency of digits in secret(s) and guess(g)\\n        vector<int> smap(10,0),gmap(10,0);\\n        \\n        \\n        for(int i=0;i<ln;i++){\\n            // bull++ ,if elements is same and index as well\\n            if(s[i]== g[i]) bull++;\\n            \\n            smap[s[i]-\\'0\\']++;\\n            gmap[g[i]-\\'0\\']++;\\n        }\\n        \\n        \\n        // store num of elements common in s and g\\n        for(int i=0;i<10;i++)\\n            cow+= min(gmap[i], smap[i]);\\n        \\n        \\n        // cow = (number of same elements) - (number of elements with equal value and correct index)\\n        cow-= bull;\\n        \\n        string ans= to_string(bull)+\\'A\\'+to_string(cow)+\\'B\\';\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string s, string g) {\\n        // initialize value of cow and bull\\n        int bull= 0, cow=0, ln= s.size();\\n        \\n        // to store frequency of digits in secret(s) and guess(g)\\n        vector<int> smap(10,0),gmap(10,0);\\n        \\n        \\n        for(int i=0;i<ln;i++){\\n            // bull++ ,if elements is same and index as well\\n            if(s[i]== g[i]) bull++;\\n            \\n            smap[s[i]-\\'0\\']++;\\n            gmap[g[i]-\\'0\\']++;\\n        }\\n        \\n        \\n        // store num of elements common in s and g\\n        for(int i=0;i<10;i++)\\n            cow+= min(gmap[i], smap[i]);\\n        \\n        \\n        // cow = (number of same elements) - (number of elements with equal value and correct index)\\n        cow-= bull;\\n        \\n        string ans= to_string(bull)+\\'A\\'+to_string(cow)+\\'B\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189104,
                "title": "c-beats-100-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\nThere will be 3 cases at index i of the string:\\n1. the characters of both string are same, then bull will be incremented by 1\\n2. the characters of both strings are different but character present in guess string at index is occuring elsewhere(let\\'s say index j, but character in secret string at index j should be different from character in guess string at index j)\\n3. the characters of both strings are different and the character in guess string doesn\\'t occur in string secret;\\n\\n# Approach\\n- As every index contains a single digit character, so max number of unique characters are 10 (0-9), so a vector to store frequency is initialized`vector<int> v(12,0);`\\n- First we traverse throught the correct string storing the frequency of the character only if characters in both strings are different\\n`if(secret[i]!=guess[i]) v[stoi(secret[i])]++;`\\n- then we traverse throught the guess function,\\n    1. case1, then increment bull`if(guess[i]==secret[i]) bull++;`\\n    2. case2,\\n    ```\\n    if(v[stoi(guess[i])]>0){\\n        cow++;\\n        v[stoi(guess[i])]--;\\n    }\\n    ```\\n    here we are decreasing the count by 1, as repetition is not allowed\\n    3. case3, no change in value of bull or cow\\n\\nusing `to_string()` function convert from integer to string \\nAlso,\\n```\\nint stoi(char c){\\n        return int(c)-47;\\n    }\\n``` \\nis a function which reduces the value of ASCII charactr by 47\\nASCII OF 0 = 47\\nSo, stoi(\\'5\\') = 52\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int stoi(char c){\\n        return int(c)-47;\\n    }\\n    string getHint(string secret, string guess) {\\n        vector<int> v(12,0);\\n        int bull=0,cow=0;\\n        for(int i=0;i<secret.size();i++){\\n            if(secret[i]!=guess[i]) v[stoi(secret[i])]++;\\n        }\\n        for(int i=0;i<guess.size();i++){\\n            if(guess[i]==secret[i]) bull++;\\n            else{\\n                if(v[stoi(guess[i])]>0){\\n                    cow++;\\n                    v[stoi(guess[i])]--;\\n                }\\n            }\\n        }\\n        string s=\"\";\\n        s+=to_string(bull);\\n        s+=\"A\";\\n        s+=to_string(cow);\\n        s+=\"B\";\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting",
                    "Hash Function"
                ],
                "code": "```\\n    if(v[stoi(guess[i])]>0){\\n        cow++;\\n        v[stoi(guess[i])]--;\\n    }\\n    ```\n```\\nint stoi(char c){\\n        return int(c)-47;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int stoi(char c){\\n        return int(c)-47;\\n    }\\n    string getHint(string secret, string guess) {\\n        vector<int> v(12,0);\\n        int bull=0,cow=0;\\n        for(int i=0;i<secret.size();i++){\\n            if(secret[i]!=guess[i]) v[stoi(secret[i])]++;\\n        }\\n        for(int i=0;i<guess.size();i++){\\n            if(guess[i]==secret[i]) bull++;\\n            else{\\n                if(v[stoi(guess[i])]>0){\\n                    cow++;\\n                    v[stoi(guess[i])]--;\\n                }\\n            }\\n        }\\n        string s=\"\";\\n        s+=to_string(bull);\\n        s+=\"A\";\\n        s+=to_string(cow);\\n        s+=\"B\";\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186173,
                "title": "c-solution-using-map",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        map<char,int> ms;\\n        for(int i=0;i<secret.size();i++)\\n        {\\n            ms[secret[i]]++;\\n        }\\n        int bulls=0;\\n        int cows=0;\\n        for(int j=0;j<secret.size();j++)\\n        {\\n            if(secret[j]==guess[j])\\n            {\\n                bulls++;\\n                ms[secret[j]]-=1;\\n            }\\n            \\n        }\\n        for(int h=0;h<secret.size();h++)\\n        {   \\n            if(secret[h]!=guess[h])\\n            {\\n                if(ms[guess[h]]>=1)\\n                {\\n                    cows++;\\n                    ms[guess[h]]-=1;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        string b=to_string(bulls);\\n        ans=ans+b;\\n        string c=to_string(cows);\\n        ans=ans+\\'A\\';\\n        ans=ans+c;\\n        ans=ans+\\'B\\';\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        map<char,int> ms;\\n        for(int i=0;i<secret.size();i++)\\n        {\\n            ms[secret[i]]++;\\n        }\\n        int bulls=0;\\n        int cows=0;\\n        for(int j=0;j<secret.size();j++)\\n        {\\n            if(secret[j]==guess[j])\\n            {\\n                bulls++;\\n                ms[secret[j]]-=1;\\n            }\\n            \\n        }\\n        for(int h=0;h<secret.size();h++)\\n        {   \\n            if(secret[h]!=guess[h])\\n            {\\n                if(ms[guess[h]]>=1)\\n                {\\n                    cows++;\\n                    ms[guess[h]]-=1;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        string b=to_string(bulls);\\n        ans=ans+b;\\n        string c=to_string(cows);\\n        ans=ans+\\'A\\';\\n        ans=ans+c;\\n        ans=ans+\\'B\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186164,
                "title": "c-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int bull = 0, cow = 0;\\n        string ans = \"\";\\n        int arrS[10] = {0}, arrG[10] = {0};\\n\\n        for(int i = 0; i < secret.length(); i++){\\n            if(secret[i] == guess[i]){\\n                bull++;\\n                continue;\\n            }\\n            arrS[secret[i] - \\'0\\']++;\\n            arrG[guess[i] - \\'0\\']++;\\n        }\\n        for(int i = 0; i < 10; i++){\\n            if((arrG[i] >= arrS[i] || arrS[i] > arrG[i]) && arrS[i] != 0 && arrG[i] != 0){\\n                cow++;\\n                arrS[i]--;\\n                arrG[i]--;\\n                if(arrS[i] != 0)\\n                    i--;\\n            }\\n        }\\n        ans = to_string(bull) + \\'A\\' + to_string(cow) + \\'B\\';\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int bull = 0, cow = 0;\\n        string ans = \"\";\\n        int arrS[10] = {0}, arrG[10] = {0};\\n\\n        for(int i = 0; i < secret.length(); i++){\\n            if(secret[i] == guess[i]){\\n                bull++;\\n                continue;\\n            }\\n            arrS[secret[i] - \\'0\\']++;\\n            arrG[guess[i] - \\'0\\']++;\\n        }\\n        for(int i = 0; i < 10; i++){\\n            if((arrG[i] >= arrS[i] || arrS[i] > arrG[i]) && arrS[i] != 0 && arrG[i] != 0){\\n                cow++;\\n                arrS[i]--;\\n                arrG[i]--;\\n                if(arrS[i] != 0)\\n                    i--;\\n            }\\n        }\\n        ans = to_string(bull) + \\'A\\' + to_string(cow) + \\'B\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125697,
                "title": "5ms-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bulls=0;\\n        int cows=0;\\n        int[] nums=new int[10];\\n        for(int i=0;i<secret.length();i++){\\n            int numsSecret=secret.charAt(i)-\\'0\\';\\n            int numsGuess=guess.charAt(i)-\\'0\\';\\n            if(numsSecret==numsGuess){\\n                bulls++;\\n            }else{\\n                if(nums[numsGuess]<0){\\n                    cows++;\\n                }\\n                if(nums[numsSecret]>0){\\n                    cows++;\\n                }\\n                nums[numsGuess]++;\\n                nums[numsSecret]--;\\n            }\\n            \\n        }\\n        return bulls + \"A\" + cows + \"B\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bulls=0;\\n        int cows=0;\\n        int[] nums=new int[10];\\n        for(int i=0;i<secret.length();i++){\\n            int numsSecret=secret.charAt(i)-\\'0\\';\\n            int numsGuess=guess.charAt(i)-\\'0\\';\\n            if(numsSecret==numsGuess){\\n                bulls++;\\n            }else{\\n                if(nums[numsGuess]<0){\\n                    cows++;\\n                }\\n                if(nums[numsSecret]>0){\\n                    cows++;\\n                }\\n                nums[numsGuess]++;\\n                nums[numsSecret]--;\\n            }\\n            \\n        }\\n        return bulls + \"A\" + cows + \"B\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086664,
                "title": "java-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        HashMap<Character,Integer>map=new HashMap<>();\\n        int bull=0,cow=0;\\n        int i=0;\\n        \\n        while(i<secret.length()){\\n            char s=secret.charAt(i);char g=guess.charAt(i);\\n            if(s==g){\\n                bull++;\\n            }\\n            else{\\n                if(map.containsKey(s)){\\n                    map.put(s,map.get(s)+1);\\n                }\\n                else{\\n                    map.put(s,1);\\n                }\\n            }\\n            i++;\\n        }\\n\\n        i=0;\\n\\n        while(i<guess.length()){\\n            char s=secret.charAt(i);char g=guess.charAt(i);\\n            if(s!=g){\\n                if(map.containsKey(g)){\\n                    cow++;\\n                    if(map.get(g)==1){\\n                        map.remove(g);\\n                    }\\n                    else{\\n                        map.put(g,map.get(g)-1);\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return bull+\"A\"+cow+\"B\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        HashMap<Character,Integer>map=new HashMap<>();\\n        int bull=0,cow=0;\\n        int i=0;\\n        \\n        while(i<secret.length()){\\n            char s=secret.charAt(i);char g=guess.charAt(i);\\n            if(s==g){\\n                bull++;\\n            }\\n            else{\\n                if(map.containsKey(s)){\\n                    map.put(s,map.get(s)+1);\\n                }\\n                else{\\n                    map.put(s,1);\\n                }\\n            }\\n            i++;\\n        }\\n\\n        i=0;\\n\\n        while(i<guess.length()){\\n            char s=secret.charAt(i);char g=guess.charAt(i);\\n            if(s!=g){\\n                if(map.containsKey(g)){\\n                    cow++;\\n                    if(map.get(g)==1){\\n                        map.remove(g);\\n                    }\\n                    else{\\n                        map.put(g,map.get(g)-1);\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return bull+\"A\"+cow+\"B\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082573,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int bull=0,s1,s2,f=0;\\n        unordered_map<int,int> mp;\\n        for(int i =0;i<secret.size();i++){\\n            s1=secret[i]-\\'0\\';\\n            s2=guess[i]-\\'0\\';\\n            if(s1==s2)\\n            bull++;\\n            mp[s2]++;\\n            \\n        }\\n        for(int i =0;i<secret.size();i++)\\n        {\\n        s1=secret[i]-\\'0\\';\\n        if(mp[s1]>0){\\n        f++;\\n        mp[s1]--;}\\n        }      \\n        string s=to_string(bull)+\\'A\\'+to_string(f-bull)+\\'B\\';\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int bull=0,s1,s2,f=0;\\n        unordered_map<int,int> mp;\\n        for(int i =0;i<secret.size();i++){\\n            s1=secret[i]-\\'0\\';\\n            s2=guess[i]-\\'0\\';\\n            if(s1==s2)\\n            bull++;\\n            mp[s2]++;\\n            \\n        }\\n        for(int i =0;i<secret.size();i++)\\n        {\\n        s1=secret[i]-\\'0\\';\\n        if(mp[s1]>0){\\n        f++;\\n        mp[s1]--;}\\n        }      \\n        string s=to_string(bull)+\\'A\\'+to_string(f-bull)+\\'B\\';\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980161,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        map<char, int>m;\\n        int cow=0, bull=0;\\n        for(int i=0; i<secret.size(); i++){\\n            m[secret[i]]++;\\n        }\\n        for(int i=0; i<guess.size(); i++){\\n            if(secret[i]==guess[i]){\\n                bull++;\\n                //cout<<secret[i]<<\" \"<<m1[guess[i]]<<endl;\\n                m[guess[i]]--;\\n                if( m[guess[i]]==0){\\n                    m.erase(guess[i]);\\n                }\\n            }\\n            else{continue;}\\n        }\\n        for(int i=0; i<guess.size(); i++){\\n            if(secret[i]!=guess[i]){\\n                if(m.find(guess[i])!=m.end()){\\n                    //cout<<guess[i]<<\" \"<<secret[i]<<\" \"<<m1[guess[i]]<<endl;\\n                    cow++;\\n                    m[guess[i]]--;\\n                    if( m[guess[i]]==0){\\n                        m.erase(guess[i]);\\n                    }\\n                }\\n            }\\n            else{continue;}\\n        }\\n        string ans=\"\";\\n        ans+=to_string(bull);\\n        ans+=\\'A\\';\\n        ans+=to_string(cow);\\n        ans+=\\'B\\';\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        map<char, int>m;\\n        int cow=0, bull=0;\\n        for(int i=0; i<secret.size(); i++){\\n            m[secret[i]]++;\\n        }\\n        for(int i=0; i<guess.size(); i++){\\n            if(secret[i]==guess[i]){\\n                bull++;\\n                //cout<<secret[i]<<\" \"<<m1[guess[i]]<<endl;\\n                m[guess[i]]--;\\n                if( m[guess[i]]==0){\\n                    m.erase(guess[i]);\\n                }\\n            }\\n            else{continue;}\\n        }\\n        for(int i=0; i<guess.size(); i++){\\n            if(secret[i]!=guess[i]){\\n                if(m.find(guess[i])!=m.end()){\\n                    //cout<<guess[i]<<\" \"<<secret[i]<<\" \"<<m1[guess[i]]<<endl;\\n                    cow++;\\n                    m[guess[i]]--;\\n                    if( m[guess[i]]==0){\\n                        m.erase(guess[i]);\\n                    }\\n                }\\n            }\\n            else{continue;}\\n        }\\n        string ans=\"\";\\n        ans+=to_string(bull);\\n        ans+=\\'A\\';\\n        ans+=to_string(cow);\\n        ans+=\\'B\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2843754,
                "title": "python-onepass-solution",
                "content": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        \\n        counts = Counter(secret)\\n        bulls = 0\\n        cows = 0\\n        \\n        for s,g in zip(secret, guess):\\n            if s == g:\\n                bulls += 1\\n                if counts[s]:\\n                    counts[s] -= 1\\n                else:\\n                    cows -= 1\\n            elif counts[g]:\\n                cows += 1\\n                counts[g] -= 1\\n                \\n        return f\"{bulls}A{cows}B\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        \\n        counts = Counter(secret)\\n        bulls = 0\\n        cows = 0\\n        \\n        for s,g in zip(secret, guess):\\n            if s == g:\\n                bulls += 1\\n                if counts[s]:\\n                    counts[s] -= 1\\n                else:\\n                    cows -= 1\\n            elif counts[g]:\\n                cows += 1\\n                counts[g] -= 1\\n                \\n        return f\"{bulls}A{cows}B\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650910,
                "title": "simple-java-solution-o-n-time",
                "content": "keep frequency map to count characters for both strings.\\nnow loop char by char both strings and just dont count chars if they are same. i.e. bulls.\\nnow for cow, just check which out of two map freq is smaller. in such case those many cows are present.\\n\\n```\\n public String getHint(String secret, String guess) {\\n\\t\\tint[] gu = new int[10];\\n\\t\\tint[] sec = new int[10];\\n\\t\\tint bull = 0;\\n\\t\\tfor (int i = 0; i < secret.length(); i++) {\\n\\t\\t\\tif (secret.charAt(i) == guess.charAt(i)) {\\n\\t\\t\\t\\tbull++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tgu[guess.charAt(i) - \\'0\\']++;\\n\\t\\t\\t\\tsec[secret.charAt(i) - \\'0\\']++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint cow = 0;\\n\\t\\tfor (int i = 0; i < 10; i++) {\\n\\t\\t\\tcow += Math.min(gu[i], sec[i]);\\n\\t\\t}\\n\\t\\treturn bull + \"A\" + cow + \"B\";\\n\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public String getHint(String secret, String guess) {\\n\\t\\tint[] gu = new int[10];\\n\\t\\tint[] sec = new int[10];\\n\\t\\tint bull = 0;\\n\\t\\tfor (int i = 0; i < secret.length(); i++) {\\n\\t\\t\\tif (secret.charAt(i) == guess.charAt(i)) {\\n\\t\\t\\t\\tbull++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tgu[guess.charAt(i) - \\'0\\']++;\\n\\t\\t\\t\\tsec[secret.charAt(i) - \\'0\\']++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint cow = 0;\\n\\t\\tfor (int i = 0; i < 10; i++) {\\n\\t\\t\\tcow += Math.min(gu[i], sec[i]);\\n\\t\\t}\\n\\t\\treturn bull + \"A\" + cow + \"B\";\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2623660,
                "title": "c-1-pass-solution-using-hashmap",
                "content": "class Solution {\\npublic:\\n    string getHint(string st, string gu)\\n    {\\n     map<char,int>s;\\n        map<char,int>g;\\n        int b=0,c=0;\\n        for(int i=0;i<st.length();i++)\\n        {\\n          if(st[i]==gu[i])\\n              b++;\\n            else\\n            {\\n                if(g[st[i]]>0)\\n                {\\n                    g[st[i]]--;\\n                    c++;\\n                }\\n                else\\n                {\\n                    s[st[i]]++;\\n                }\\n                if(s[gu[i]]>0)\\n                {\\n                    s[gu[i]]--;\\n                    c++;\\n                }\\n                else\\n                {\\n                    g[gu[i]]++;\\n                }\\n            }\\n        }\\n        return to_string(b)+\\'A\\'+to_string(c)+\\'B\\';\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string getHint(string st, string gu)\\n    {\\n     map<char,int>s;\\n        map<char,int>g;\\n        int b=0,c=0;\\n        for(int i=0;i<st.length();i++)\\n        {\\n          if(st[i]==gu[i])\\n              b++;\\n            else\\n            {\\n                if(g[st[i]]>0)\\n                {\\n                    g[st[i]]--;\\n                    c++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2622665,
                "title": "c-2-pass-solution-using-hashmap",
                "content": "class Solution {\\npublic:\\n    string getHint(string s, string g)\\n    {\\n        map<char,int>m;\\n        int bulls=0,cows=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==g[i])\\n            {\\n                bulls++;\\n            }\\n            else\\n            {\\n                m[s[i]]++;\\n            }\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=g[i]&&m[g[i]])\\n            {\\n                cows++;\\n                m[g[i]]--;\\n            }\\n        }\\n        return to_string(bulls)+\\'A\\'+to_string(cows)+\\'B\\';\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string getHint(string s, string g)\\n    {\\n        map<char,int>m;\\n        int bulls=0,cows=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==g[i])\\n            {\\n                bulls++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2494618,
                "title": "c-simple-solution-hashmap",
                "content": "Hashmap!!!\\nJust use a hashmap!!\\n```\\nstring getHint(string secret, string guess) {\\n        int bull = 0;\\n        int cow = 0;\\n        unordered_map<char, int> um1, um2;\\n        for (int i = 0; i < secret.size(); i++)\\n        {\\n            if (secret[i] == guess[i]) bull++;\\n            else\\n            {\\n                um1[secret[i]]++;\\n                um2[guess[i]]++;\\n            }\\n        }\\n        \\n        for (char c = \\'0\\'; c <= \\'9\\'; c++)\\n        {\\n            cow += min(um1[c], um2[c]);\\n        }\\n        \\n        return std::to_string(bull) + \\'A\\' + std::to_string(cow) + \\'B\\';\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring getHint(string secret, string guess) {\\n        int bull = 0;\\n        int cow = 0;\\n        unordered_map<char, int> um1, um2;\\n        for (int i = 0; i < secret.size(); i++)\\n        {\\n            if (secret[i] == guess[i]) bull++;\\n            else\\n            {\\n                um1[secret[i]]++;\\n                um2[guess[i]]++;\\n            }\\n        }\\n        \\n        for (char c = \\'0\\'; c <= \\'9\\'; c++)\\n        {\\n            cow += min(um1[c], um2[c]);\\n        }\\n        \\n        return std::to_string(bull) + \\'A\\' + std::to_string(cow) + \\'B\\';\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436122,
                "title": "python-solution-28ms-faster-than-99-92",
                "content": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n            bulls=0\\n            cows=0\\n            d1=collections.Counter(secret)\\n            d2=collections.Counter(guess)\\n            for i in d1:\\n                if i in d2:\\n                    cows+=min(d1[i],d2[i])\\n            for i in range(len(secret)):\\n                if secret[i] == guess[i]:\\n                    bulls+=1\\n            return str(bulls) + \"A\" + str(cows-bulls) + \\'B\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n            bulls=0\\n            cows=0\\n            d1=collections.Counter(secret)\\n            d2=collections.Counter(guess)\\n            for i in d1:\\n                if i in d2:\\n                    cows+=min(d1[i],d2[i])\\n            for i in range(len(secret)):\\n                if secret[i] == guess[i]:\\n                    bulls+=1\\n            return str(bulls) + \"A\" + str(cows-bulls) + \\'B\\'",
                "codeTag": "Java"
            },
            {
                "id": 2389712,
                "title": "easy-java-solution",
                "content": "```\\npublic String getHint(String secret, String guess) {\\n        int cows = 0;\\n        int bulls = 0;\\n        HashMap<Character, Integer> mapS = new HashMap<>();\\n        HashMap<Character, Integer> mapG = new HashMap<>();\\n\\n        \\n        for(int i = 0; i < secret.length(); i++) {\\n            char c1 = secret.charAt(i);\\n            char c2 = guess.charAt(i);\\n            \\n            if(c2 == c1) {\\n                bulls++;\\n                continue;\\n            }\\n            \\n            mapS.put(c1, mapS.getOrDefault(c1, 0) + 1);\\n            mapG.put(c2, mapG.getOrDefault(c2, 0) + 1);\\n        }\\n        \\n        for(Character c : mapG.keySet()) {\\n            if(!mapS.containsKey(c)) continue;\\n            \\n            cows += Math.min(mapS.get(c), mapG.get(c));\\n        }\\n        \\n        return bulls + \"A\" + cows + \"B\";\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String getHint(String secret, String guess) {\\n        int cows = 0;\\n        int bulls = 0;\\n        HashMap<Character, Integer> mapS = new HashMap<>();\\n        HashMap<Character, Integer> mapG = new HashMap<>();\\n\\n        \\n        for(int i = 0; i < secret.length(); i++) {\\n            char c1 = secret.charAt(i);\\n            char c2 = guess.charAt(i);\\n            \\n            if(c2 == c1) {\\n                bulls++;\\n                continue;\\n            }\\n            \\n            mapS.put(c1, mapS.getOrDefault(c1, 0) + 1);\\n            mapG.put(c2, mapG.getOrDefault(c2, 0) + 1);\\n        }\\n        \\n        for(Character c : mapG.keySet()) {\\n            if(!mapS.containsKey(c)) continue;\\n            \\n            cows += Math.min(mapS.get(c), mapG.get(c));\\n        }\\n        \\n        return bulls + \"A\" + cows + \"B\";\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2342124,
                "title": "c-you-just-need-one-array",
                "content": "```\\npublic class Solution {\\n    public string GetHint(string secret, string guess) {\\n        var set = new int[10];\\n        var bulls = 0;\\n        for (var i = 0; i < secret.Length; i++)\\n        {\\n            if (secret[i] == guess[i])\\n                bulls++; // separately calculating bulls\\n            else // we are not accounting bulls in cow calculation\\n            {\\n                set[secret[i] - \\'0\\']++;\\n                set[guess[i] - \\'0\\']--;\\n            }\\n        }\\n        \\n        // everything that was not bull and has negative sum was a miss - thus not a cow\\n        var cows = guess.Length - bulls + set.Where(p => p < 0).Sum();\\n        \\n        return $\"{bulls}A{cows}B\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string GetHint(string secret, string guess) {\\n        var set = new int[10];\\n        var bulls = 0;\\n        for (var i = 0; i < secret.Length; i++)\\n        {\\n            if (secret[i] == guess[i])\\n                bulls++; // separately calculating bulls\\n            else // we are not accounting bulls in cow calculation\\n            {\\n                set[secret[i] - \\'0\\']++;\\n                set[guess[i] - \\'0\\']--;\\n            }\\n        }\\n        \\n        // everything that was not bull and has negative sum was a miss - thus not a cow\\n        var cows = guess.Length - bulls + set.Where(p => p < 0).Sum();\\n        \\n        return $\"{bulls}A{cows}B\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304896,
                "title": "easy-c-solution-map",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int a=0, b=0;\\n        unordered_map<char,int> fS, fG;\\n        for(int i=0; i<secret.size(); ++i){\\n            if(secret[i]==guess[i]) ++a, guess[i]=\\'-\\';\\n            else{\\n                ++fS[secret[i]], ++fG[guess[i]];\\n                if(fS.count(guess[i]) and fS[guess[i]]>0) ++b, --fS[guess[i]], --fG[guess[i]];\\n                if(fG.count(secret[i]) and fG[secret[i]]>0) ++b, --fS[secret[i]], --fG[secret[i]];\\n            }\\n        }\\n        return to_string(a)+\\'A\\'+to_string(b)+\\'B\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int a=0, b=0;\\n        unordered_map<char,int> fS, fG;\\n        for(int i=0; i<secret.size(); ++i){\\n            if(secret[i]==guess[i]) ++a, guess[i]=\\'-\\';\\n            else{\\n                ++fS[secret[i]], ++fG[guess[i]];\\n                if(fS.count(guess[i]) and fS[guess[i]]>0) ++b, --fS[guess[i]], --fG[guess[i]];\\n                if(fG.count(secret[i]) and fG[secret[i]]>0) ++b, --fS[secret[i]], --fG[secret[i]];\\n            }\\n        }\\n        return to_string(a)+\\'A\\'+to_string(b)+\\'B\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283564,
                "title": "java-hashmap-approach-o-n-m-time-and-o-n-space",
                "content": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bulls = 0;\\n        int cows = 0;\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < secret.length(); i++){\\n            if(secret.charAt(i) != guess.charAt(i))\\n            {\\n             map.put(secret.charAt(i), map.getOrDefault(secret.charAt(i), 0) + 1);\\n            }\\n            else bulls +=1;\\n            \\n        }\\n        \\n        for(int j = 0; j < guess.length(); j++){\\n            char g = guess.charAt(j);\\n            char s = secret.charAt(j);\\n            if(g != s){\\n                if(map.containsKey(g)){\\n                    cows += 1;\\n                    map.put(g, map.get(g) - 1);\\n                    if(map.get(g) == 0) map.remove(g);\\n                }\\n            }\\n\\n        }\\n        \\n        //time complexity: O(n + m)\\n        //space complexity: O(n)\\n        return bulls+\"A\"+cows+\"B\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bulls = 0;\\n        int cows = 0;\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < secret.length(); i++){\\n            if(secret.charAt(i) != guess.charAt(i))\\n            {\\n             map.put(secret.charAt(i), map.getOrDefault(secret.charAt(i), 0) + 1);\\n            }\\n            else bulls +=1;\\n            \\n        }\\n        \\n        for(int j = 0; j < guess.length(); j++){\\n            char g = guess.charAt(j);\\n            char s = secret.charAt(j);\\n            if(g != s){\\n                if(map.containsKey(g)){\\n                    cows += 1;\\n                    map.put(g, map.get(g) - 1);\\n                    if(map.get(g) == 0) map.remove(g);\\n                }\\n            }\\n\\n        }\\n        \\n        //time complexity: O(n + m)\\n        //space complexity: O(n)\\n        return bulls+\"A\"+cows+\"B\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270999,
                "title": "python-c-fast-and-easy-solution-without-using-dict-and-map",
                "content": "We just have to use an array to store every possible **B** and traverse them in the end\\n```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        secretTable = [0]*10\\n        guessTable = [0]*10\\n        cntA = 0\\n        cntB = 0\\n        for i in range(len(secret)):\\n            if secret[i]==guess[i]:\\n                cntA += 1\\n            else:\\n                secretTable[secret[i]] += 1\\n                guessTable[guess[i]] += 1\\n        for i in range(10):\\n            cntB += min(secretTable[i], guessTable[i])\\n        return str(cntA)+\\'A\\'+str(cntB)+\\'B\\'\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int cntA = 0;\\n        int cntB = 0;\\n        vector<int> secretTable(10, 0);\\n        vector<int> guessTable(10, 0);\\n        for(int i=0; i<secret.size(); i++){\\n            if(secret[i]==guess[i]) cntA++;\\n            else{\\n                secretTable[secret[i]-\\'0\\']++;\\n                guessTable[guess[i]-\\'0\\']++;\\n            }\\n        }\\n        for(int i=0; i<10; i++){\\n            cntB += min(secretTable[i], guessTable[i]);\\n        }\\n        return to_string(cntA)+\\'A\\'+to_string(cntB)+\\'B\\';\\n    }\\n};\\n```\\n\\nUpvote if you thinl it\\'s helpful !",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        secretTable = [0]*10\\n        guessTable = [0]*10\\n        cntA = 0\\n        cntB = 0\\n        for i in range(len(secret)):\\n            if secret[i]==guess[i]:\\n                cntA += 1\\n            else:\\n                secretTable[secret[i]] += 1\\n                guessTable[guess[i]] += 1\\n        for i in range(10):\\n            cntB += min(secretTable[i], guessTable[i])\\n        return str(cntA)+\\'A\\'+str(cntB)+\\'B\\'\\n```\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int cntA = 0;\\n        int cntB = 0;\\n        vector<int> secretTable(10, 0);\\n        vector<int> guessTable(10, 0);\\n        for(int i=0; i<secret.size(); i++){\\n            if(secret[i]==guess[i]) cntA++;\\n            else{\\n                secretTable[secret[i]-\\'0\\']++;\\n                guessTable[guess[i]-\\'0\\']++;\\n            }\\n        }\\n        for(int i=0; i<10; i++){\\n            cntB += min(secretTable[i], guessTable[i]);\\n        }\\n        return to_string(cntA)+\\'A\\'+to_string(cntB)+\\'B\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116989,
                "title": "simple-python-solution-with-detailed-explanation-easy-to-understand",
                "content": "```\\n\\n```def getHint(self, secret: str, guess: str) -> str:\\n        \\n        news = secret[:]     # make a copy of secret called news\\n        \\n        sumsb = 0       # count the number of bulls by iterating through secret and guess\\n        for i in range(len(secret)):\\n            if secret[i] == guess[i]:\\n                sumsb += 1\\n        \\n        sumsc = 0       # count the number of numbers in guess that\\'s in news and delete every time when the common letter shows up\\n        for i in range(len(secret)):\\n            if guess[i] in news:\\n                sumsc += 1\\n                news = news.replace(guess[i], \\'\\', 1)\\n        \\n        return str(sumsb)+\\'A\\'+str(sumsc-sumsb)+\\'B\\'      # combine the bumber of bulls and number in guess that\\'s in secret - the number of bulls",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848466,
                "title": "c-o-n-onepass",
                "content": "```\\nclass Solution {\\npublic:\\n\\tstring getHint(string secret, string guess) {\\n\\t\\tint n = secret.size();\\n\\t\\tvector<int>freqSecret(10, 0);\\n\\t\\tvector<int>freqGuess(10, 0);\\n\\t\\tint bulls = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (secret[i] == guess[i]) {\\n\\t\\t\\t\\tbulls++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfreqSecret[secret[i] - \\'0\\']++;\\n\\t\\t\\t\\tfreqGuess[guess[i] - \\'0\\']++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint cows = 0;\\n\\t\\tfor (int i = 0; i < 10; i++)\\n\\t\\t\\tcows += min(freqSecret[i], freqGuess[i]);\\n\\t\\treturn to_string(bulls) + \\'A\\' + to_string(cows) + \\'B\\';\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring getHint(string secret, string guess) {\\n\\t\\tint n = secret.size();\\n\\t\\tvector<int>freqSecret(10, 0);\\n\\t\\tvector<int>freqGuess(10, 0);\\n\\t\\tint bulls = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (secret[i] == guess[i]) {\\n\\t\\t\\t\\tbulls++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfreqSecret[secret[i] - \\'0\\']++;\\n\\t\\t\\t\\tfreqGuess[guess[i] - \\'0\\']++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint cows = 0;\\n\\t\\tfor (int i = 0; i < 10; i++)\\n\\t\\t\\tcows += min(freqSecret[i], freqGuess[i]);\\n\\t\\treturn to_string(bulls) + \\'A\\' + to_string(cows) + \\'B\\';\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839270,
                "title": "bulls-and-cows-solution-java",
                "content": "class Solution {\\n  public String getHint(String secret, String guess) {\\n    int A = 0;\\n    int B = 0;\\n    int[] count1 = new int[10];\\n    int[] count2 = new int[10];\\n\\n    for (int i = 0; i < secret.length(); ++i)\\n      if (secret.charAt(i) == guess.charAt(i))\\n        ++A;\\n      else {\\n        ++count1[secret.charAt(i) - \\'0\\'];\\n        ++count2[guess.charAt(i) - \\'0\\'];\\n      }\\n\\n    for (int i = 0; i < 10; ++i)\\n      B += Math.min(count1[i], count2[i]);\\n\\n    return String.valueOf(A) + \"A\" + String.valueOf(B) + \"B\";\\n  }\\n}",
                "solutionTags": [
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "class Solution {\\n  public String getHint(String secret, String guess) {\\n    int A = 0;\\n    int B = 0;\\n    int[] count1 = new int[10];\\n    int[] count2 = new int[10];\\n\\n    for (int i = 0; i < secret.length(); ++i)\\n      if (secret.charAt(i) == guess.charAt(i))\\n        ++A;\\n      else {\\n        ++count1[secret.charAt(i) - \\'0\\'];\\n        ++count2[guess.charAt(i) - \\'0\\'];\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1640161,
                "title": "c-two-pass-easy-to-understand-o-n-4ms-81-25",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int bulls = 0, cows = 0, n = secret.size();\\n        map<int, int> mpp;\\n        \\n        for(int i=0; i<n; i++){\\n            // If index & value match, increment Bull count\\n            if(secret[i] == guess[i]){\\n                bulls++;\\n            } \\n            // Else store the occurences in a Hash table\\n            else {\\n                mpp[secret[i]-\\'0\\']++;\\n            }\\n        }\\n        \\n        // Check the occurences for Cows other than the Bulls\\n        for(int i=0; i<n; i++){\\n            if(secret[i] != guess[i] && mpp[guess[i]-\\'0\\']){\\n                cows++;\\n                mpp[guess[i]-\\'0\\']--;\\n            }\\n        }\\n        return to_string(bulls) + \"A\" + to_string(cows) + \"B\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int bulls = 0, cows = 0, n = secret.size();\\n        map<int, int> mpp;\\n        \\n        for(int i=0; i<n; i++){\\n            // If index & value match, increment Bull count\\n            if(secret[i] == guess[i]){\\n                bulls++;\\n            } \\n            // Else store the occurences in a Hash table\\n            else {\\n                mpp[secret[i]-\\'0\\']++;\\n            }\\n        }\\n        \\n        // Check the occurences for Cows other than the Bulls\\n        for(int i=0; i<n; i++){\\n            if(secret[i] != guess[i] && mpp[guess[i]-\\'0\\']){\\n                cows++;\\n                mpp[guess[i]-\\'0\\']--;\\n            }\\n        }\\n        return to_string(bulls) + \"A\" + to_string(cows) + \"B\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627101,
                "title": "go-faster-than-100",
                "content": "```\\nfunc getHint(secret string, guess string) string {\\n  \\n\\tvar (\\n\\t\\tbull, cow int\\n\\t\\t\\n\\t\\tcount = make([]int, 10)\\n\\t)\\n\\t\\n\\tfor i := 0; i < len(guess); i++ {\\n\\t\\tif secret[i] == guess[i] {\\n\\t\\t\\tbull++\\n\\t\\t} else {\\n\\t\\t\\tcount[guess[i]-\\'0\\']++\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfor i := 0; i < len(secret); i++ {\\n\\t\\tif secret[i] == guess[i] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif count[secret[i]-\\'0\\'] > 0 {\\n\\t\\t\\tcow++\\n\\t\\t\\tcount[secret[i]-\\'0\\']--\\n\\t\\t}\\n\\t}\\n\\treturn fmt.Sprintf(\"%dA%dB\", bull, cow)\\n}",
                "solutionTags": [],
                "code": "```\\nfunc getHint(secret string, guess string) string {\\n  \\n\\tvar (\\n\\t\\tbull, cow int\\n\\t\\t\\n\\t\\tcount = make([]int, 10)\\n\\t)\\n\\t\\n\\tfor i := 0; i < len(guess); i++ {\\n\\t\\tif secret[i] == guess[i] {\\n\\t\\t\\tbull++\\n\\t\\t} else {\\n\\t\\t\\tcount[guess[i]-\\'0\\']++\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfor i := 0; i < len(secret); i++ {\\n\\t\\tif secret[i] == guess[i] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif count[secret[i]-\\'0\\'] > 0 {\\n\\t\\t\\tcow++\\n\\t\\t\\tcount[secret[i]-\\'0\\']--\\n\\t\\t}\\n\\t}\\n\\treturn fmt.Sprintf(\"%dA%dB\", bull, cow)\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1596298,
                "title": "java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int n = secret.length(); \\n        int[] secretdigits = new int[10];\\n        int[] guessdigits = new int[10]; \\n        int bulls = 0, cows = 0; \\n        for (int i = 0; i < n; i++) {\\n            if (secret.charAt(i) == guess.charAt(i)) {\\n                bulls++; \\n            } else {\\n                secretdigits[secret.charAt(i)-\\'0\\']++;\\n                guessdigits[guess.charAt(i)-\\'0\\']++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < 10; i++) {\\n            cows += Math.min(secretdigits[i], guessdigits[i]);\\n        }\\n        \\n        return  bulls + \"A\" + cows + \"B\"; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int n = secret.length(); \\n        int[] secretdigits = new int[10];\\n        int[] guessdigits = new int[10]; \\n        int bulls = 0, cows = 0; \\n        for (int i = 0; i < n; i++) {\\n            if (secret.charAt(i) == guess.charAt(i)) {\\n                bulls++; \\n            } else {\\n                secretdigits[secret.charAt(i)-\\'0\\']++;\\n                guessdigits[guess.charAt(i)-\\'0\\']++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < 10; i++) {\\n            cows += Math.min(secretdigits[i], guessdigits[i]);\\n        }\\n        \\n        return  bulls + \"A\" + cows + \"B\"; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311132,
                "title": "c-0-ms-easy-to-understand",
                "content": "Iterate over the string,\\nif secret char == guess char then bull++\\notherwise, increase freq of respective char\\'s.\\nFor cow -\\nIterate over the freq and count of every digit will be min(secret Freq, guess Freq)\\n\\n```\\nclass Solution {\\npublic:\\nstring getHint(string secret, string guess) {\\nint bull = 0;\\n// Frequency of secret digits\\nvector secFreq(10,0);\\n// Frequency of guess digits\\nvector gueFreq(10,0);\\nfor(int i = 0; i < secret.size();i++){\\nif(secret[i] == guess[i])bull++;\\nelse {\\nsecFreq[secret[i] - \\'0\\']++;\\ngueFreq[guess[i] - \\'0\\']++;\\n}\\n}\\n\\n\\t// For cows\\n    int cow = 0;\\n    for(int i = 0;i < 10;i++){\\n        cow += min(secFreq[i],gueFreq[i]);\\n    }\\n    return to_string(bull) + \\'A\\' + to_string(cow) + \\'B\\';\\n}\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\nstring getHint(string secret, string guess) {\\nint bull = 0;\\n// Frequency of secret digits\\nvector secFreq(10,0);\\n// Frequency of guess digits\\nvector gueFreq(10,0);\\nfor(int i = 0; i < secret.size();i++){\\nif(secret[i] == guess[i])bull++;\\nelse {\\nsecFreq[secret[i] - \\'0\\']++;\\ngueFreq[guess[i] - \\'0\\']++;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1271465,
                "title": "one-pass-simple-python-faster-than-97",
                "content": "Let me explain how we do this:\\n\\nGo through indices one at a time (since we know it\\'s same length for each string).\\n\\nLet\\'s count the digits at each step. Digits only go from 0-9. We don\\'t need dicts, two [0] * 10s will suffice.\\n\\nFor each index, if secret[i] == guess[i] we just want to increment the # of bulls (x).\\nWe don\\'t want to update ct1, ct2 because the digit is already \"mapped\"/matched up so we can\\'t use it again.\\n\\nIf it isn\\'t we just update the ct for each, both the guess digit and the secret digit.\\n\\nAt the end, we can just sum the min of the cts for each digit to get y, that is the cows. This works because all same-index matches are already screened out, so we don\\'t need to subtract those at the end.\\n\\nNote the use of zip/generator functions. Interviewers love to see you\\'re familiar w/ the language you choose and making a complex chunk of code into a simpler/smaller section can be quite helpful. Good luck and please comment if you have questions or suggestions.\\n\\n```\\nclass Solution(object):\\n    def getHint(self, secret, guess):\\n        ct1, ct2 = [0] * 10, [0] * 10\\n        x, y = 0,0\\n        for i in range(len(secret)): \\n            if guess[i] == secret[i]: x += 1\\n            else:\\n                ct1[ord(secret[i])-ord(\\'0\\')] += 1\\n                ct2[ord(guess[i])-ord(\\'0\\')] += 1\\n        y = sum(min(x,y) for x,y in list(zip(ct1,ct2)))\\n        return  str(x) + \"A\" + str(y) + \"B\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getHint(self, secret, guess):\\n        ct1, ct2 = [0] * 10, [0] * 10\\n        x, y = 0,0\\n        for i in range(len(secret)): \\n            if guess[i] == secret[i]: x += 1\\n            else:\\n                ct1[ord(secret[i])-ord(\\'0\\')] += 1\\n                ct2[ord(guess[i])-ord(\\'0\\')] += 1\\n        y = sum(min(x,y) for x,y in list(zip(ct1,ct2)))\\n        return  str(x) + \"A\" + str(y) + \"B\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173111,
                "title": "simple-one-pass-java-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bull = 0;\\n        int cow = 0;\\n        \\n        int[] cowCandidates = new int[10];\\n        for(int i = 0; i < secret.length(); i++) {\\n            char s = secret.charAt(i);\\n            char t = guess.charAt(i);\\n            \\n            if (s == t) {\\n                bull++;\\n            } else {\\n                if (cowCandidates[s - \\'0\\'] < 0) {\\n                    cow++;\\n                }\\n                cowCandidates[s - \\'0\\']++;\\n                \\n                if (cowCandidates[t - \\'0\\'] > 0) {\\n                    cow++;\\n                }\\n                cowCandidates[t - \\'0\\']--;\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(bull); \\n        sb.append(\"A\"); \\n        sb.append(cow); \\n        sb.append(\"B\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int bull = 0;\\n        int cow = 0;\\n        \\n        int[] cowCandidates = new int[10];\\n        for(int i = 0; i < secret.length(); i++) {\\n            char s = secret.charAt(i);\\n            char t = guess.charAt(i);\\n            \\n            if (s == t) {\\n                bull++;\\n            } else {\\n                if (cowCandidates[s - \\'0\\'] < 0) {\\n                    cow++;\\n                }\\n                cowCandidates[s - \\'0\\']++;\\n                \\n                if (cowCandidates[t - \\'0\\'] > 0) {\\n                    cow++;\\n                }\\n                cowCandidates[t - \\'0\\']--;\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(bull); \\n        sb.append(\"A\"); \\n        sb.append(cow); \\n        sb.append(\"B\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088059,
                "title": "c-4ms-soln-easy-and-clear",
                "content": "ss-->secret array\\ngg-->guess array\\n\\nx-->map\\n\\n```\\nclass Solution {\\npublic:\\n    string getHint(string ss, string gg) {\\n        string a=\"\";\\n        unordered_map<int,int>x;\\n        int A=0,B=0;\\n        for(int i=0;i<ss.size();i++){\\n            if(ss[i]==gg[i]) {\\n                A++;\\n                gg[i]=-1;}\\n            else{\\n                x[ss[i]]++;       \\n            }\\n        }\\n        for(int i=0;i<gg.size();i++){\\n            if(gg[i]!=-1)\\n            {\\n                if(x[gg[i]]!=0){\\n                    B++;\\n                    x[gg[i]]--;\\n                }\\n            }\\n        }\\n        \\n        a=to_string(A)+\"A\"+to_string(B)+\"B\";\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string ss, string gg) {\\n        string a=\"\";\\n        unordered_map<int,int>x;\\n        int A=0,B=0;\\n        for(int i=0;i<ss.size();i++){\\n            if(ss[i]==gg[i]) {\\n                A++;\\n                gg[i]=-1;}\\n            else{\\n                x[ss[i]]++;       \\n            }\\n        }\\n        for(int i=0;i<gg.size();i++){\\n            if(gg[i]!=-1)\\n            {\\n                if(x[gg[i]]!=0){\\n                    B++;\\n                    x[gg[i]]--;\\n                }\\n            }\\n        }\\n        \\n        a=to_string(A)+\"A\"+to_string(B)+\"B\";\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842381,
                "title": "javascript-two-pass-time-o-n-space-o-1",
                "content": "```\\nvar getHint = function(secret, guess) {\\n    let seen = {}\\n    for(let i of secret) seen[i] ? seen[i]++ : seen[i] = 1\\n     \\n    let bull = 0\\n    let cow = 0\\n    for(let i = 0; i < secret.length; i++){\\n        if(secret[i] == guess[i]){\\n            bull++\\n            if(seen[secret[i]] == 0) cow--\\n            else seen[secret[i]]--    \\n        } else if(seen[guess[i]]){\\n            cow++\\n            seen[guess[i]]--\\n        }\\n    }\\n   return `${bull}A${cow}B`\\n};\\n```\\ntime:O(n)\\nspace: O(1)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getHint = function(secret, guess) {\\n    let seen = {}\\n    for(let i of secret) seen[i] ? seen[i]++ : seen[i] = 1\\n     \\n    let bull = 0\\n    let cow = 0\\n    for(let i = 0; i < secret.length; i++){\\n        if(secret[i] == guess[i]){\\n            bull++\\n            if(seen[secret[i]] == 0) cow--\\n            else seen[secret[i]]--    \\n        } else if(seen[guess[i]]){\\n            cow++\\n            seen[guess[i]]--\\n        }\\n    }\\n   return `${bull}A${cow}B`\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840215,
                "title": "simple-java-solution-one-array-one-pass",
                "content": "```\\n        int[] arr = new int[10];\\n        int a = 0, b = 0;\\n        for(int i=0; i<secret.length(); i++) {\\n            int s = secret.charAt(i) - \\'0\\';\\n            int g = guess.charAt(i) - \\'0\\';\\n            if(s == g) {\\n                a++;\\n            } else {\\n                arr[s]++;\\n                arr[g]--;\\n                if(arr[g] >= 0) b++;\\n                if(arr[s] <= 0) b++;\\n            }\\n        }\\n        \\n        return a + \"A\" + b + \"B\";\\n```",
                "solutionTags": [],
                "code": "```\\n        int[] arr = new int[10];\\n        int a = 0, b = 0;\\n        for(int i=0; i<secret.length(); i++) {\\n            int s = secret.charAt(i) - \\'0\\';\\n            int g = guess.charAt(i) - \\'0\\';\\n            if(s == g) {\\n                a++;\\n            } else {\\n                arr[s]++;\\n                arr[g]--;\\n                if(arr[g] >= 0) b++;\\n                if(arr[s] <= 0) b++;\\n            }\\n        }\\n        \\n        return a + \"A\" + b + \"B\";\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840206,
                "title": "c-bulls-and-cows-o-n-o-1-one-pass-explained",
                "content": "The idea for a one-pass is to use a producer/consumer approach for determining the Cows. Each time we observe a digit in the secret, we increment the count for that character and each time we observe the digit in the guess we decrement the count. Then we use the following rules to detect a Cow:\\n* Incrementing a digit results in a count <= 0 (e.g. secret digit produced for a past guessed digit)\\n* Decrementing a digit results in a count >= 0 (e.g. guessed digit consumed for a past secret digit)\\n\\n```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        const int n = secret.size();\\n        vector<int> v(10, 0);\\n        int bulls = 0, cows = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (secret[i] == guess[i]) {\\n                bulls++;\\n            }\\n            else {\\n                if (++v[secret[i]-\\'0\\'] <= 0) {\\n                    cows++;\\n                }\\n                if (--v[guess[i]-\\'0\\'] >= 0) {\\n                    cows++;\\n                }\\n            }\\n        }\\n        stringstream ss;\\n        ss << bulls << \"A\" << cows << \"B\";\\n        return ss.str();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        const int n = secret.size();\\n        vector<int> v(10, 0);\\n        int bulls = 0, cows = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (secret[i] == guess[i]) {\\n                bulls++;\\n            }\\n            else {\\n                if (++v[secret[i]-\\'0\\'] <= 0) {\\n                    cows++;\\n                }\\n                if (--v[guess[i]-\\'0\\'] >= 0) {\\n                    cows++;\\n                }\\n            }\\n        }\\n        stringstream ss;\\n        ss << bulls << \"A\" << cows << \"B\";\\n        return ss.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839541,
                "title": "python-o-n-by-dictionary-w-comment",
                "content": "Python O(n) by dictionary\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        \\n        char_occ_dict = defaultdict(int)\\n        \\n        bull, cow = 0, 0\\n        \\n        for i in range(len(secret)):\\n            \\n            if secret[i] == guess[i]:\\n                # full match (Bull) of current character\\n                bull += 1\\n            \\n            else:\\n                # not-full match (Cow) or mismatch\\n                \\n                \\n                if char_occ_dict[ secret[i] ] < 0:\\n                    # current character has showed up in guess somewhere else\\n                    cow += 1\\n                \\n                # secret produces one occurrence\\n                char_occ_dict[ secret[i] ]  += 1\\n                \\n                \\n                if char_occ_dict[ guess[i] ] > 0:\\n                    # current character has showed up in secret somewhere else\\n                    cow += 1\\n                \\n                # guess consumes one occurrence\\n                char_occ_dict[ guess[i] ]  -= 1\\n        \\n        \\n        return str(bull) + \\'A\\' + str(cow) + \\'B\\'\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        \\n        char_occ_dict = defaultdict(int)\\n        \\n        bull, cow = 0, 0\\n        \\n        for i in range(len(secret)):\\n            \\n            if secret[i] == guess[i]:\\n                # full match (Bull) of current character\\n                bull += 1\\n            \\n            else:\\n                # not-full match (Cow) or mismatch\\n                \\n                \\n                if char_occ_dict[ secret[i] ] < 0:\\n                    # current character has showed up in guess somewhere else\\n                    cow += 1\\n                \\n                # secret produces one occurrence\\n                char_occ_dict[ secret[i] ]  += 1\\n                \\n                \\n                if char_occ_dict[ guess[i] ] > 0:\\n                    # current character has showed up in secret somewhere else\\n                    cow += 1\\n                \\n                # guess consumes one occurrence\\n                char_occ_dict[ guess[i] ]  -= 1\\n        \\n        \\n        return str(bull) + \\'A\\' + str(cow) + \\'B\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839468,
                "title": "c-array-based-solution-explained-100-time-95-space",
                "content": "Okay, we have to write the poor man\\'s version of mastermind and in order to do so we need 2 things:\\n* a comparison about the frequencies of each separate digit;\\n* a parsing run through both strings to find each exact matches.\\n\\nNow, in order to achieve the former, we want to first of all store the frequencies of each separate digit and, as my usual when we know we can have a limited amount of options (`10` in this problem), I will do that using an array (`freqs`) initialised with all values set to `0`.\\n\\nI will then increment the cell matching each character in the secret string by one and consequently run into the guess and, each time I find a character so that `freq[c]` is not `0` (after having normalised `c` with `- \\'0\\'`, so that it is always in the `0 - 9` range), I will go to decrease `freq[c]` and to increase `cows` by `1`.\\n\\nNow, `bulls` is just easier to get: create a loop with an index `i`, compare each character at the same position in both strings, increase `bulls` by `1` for each match.\\n\\nSmall tricky part: once you get `bulls`, subtract it from `cows`, since the latter is supposed to count only all the mal-positioned matches (ie: not the `bulls`).\\n\\nOnce you are done, you can compose your string `res` with the result and return it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string getHint(string s, string g) {\\n        // support variables\\n        int bulls = 0, cows = 0, len = s.size();\\n        string res;\\n        // checking the numbers of cows\\n        char freqs[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n        for (char c: s) freqs[c - \\'0\\']++;\\n        for (char c: g) {\\n            c -= \\'0\\';\\n            // every time we find a match, we decrease it in freqs and increase cows\\n            if (freqs[c]) {\\n                freqs[c]--;\\n                cows++;\\n            }\\n        }\\n        // checking for the number of bulls\\n        for (int i = 0; i < len; i++) if (s[i] == g[i]) bulls++;\\n        // adjusting cows\\n        cows -= bulls;\\n\\t\\t// composing the final result\\n        res = to_string(bulls) + \\'A\\' + to_string(cows) + \\'B\\';\\n        return res;\\n    }\\n};\\n```\\n\\nAnd submitting I just noticed I solved it last year (it seemed familiar) and this version of the code with vectors burns much more memory for lesser performances; some parts are still nice to be there for a comparison:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        std::vector<int> sc(10);\\n        int bulls = 0, cows = 0;\\n        for (char c: secret) sc[c - \\'0\\']++;\\n        for (char c: guess) sc[c - \\'0\\']--;\\n        cows = secret.size() - std::accumulate(begin(sc), end(sc), 0, [](int a, int b){return a + std::max(b, 0);});\\n        for (int i = 0; i < secret.size(); i++) bulls += secret[i] == guess[i];\\n        return to_string(bulls) + \\'A\\' + to_string(cows - bulls) + \\'B\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "String",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string getHint(string s, string g) {\\n        // support variables\\n        int bulls = 0, cows = 0, len = s.size();\\n        string res;\\n        // checking the numbers of cows\\n        char freqs[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n        for (char c: s) freqs[c - \\'0\\']++;\\n        for (char c: g) {\\n            c -= \\'0\\';\\n            // every time we find a match, we decrease it in freqs and increase cows\\n            if (freqs[c]) {\\n                freqs[c]--;\\n                cows++;\\n            }\\n        }\\n        // checking for the number of bulls\\n        for (int i = 0; i < len; i++) if (s[i] == g[i]) bulls++;\\n        // adjusting cows\\n        cows -= bulls;\\n\\t\\t// composing the final result\\n        res = to_string(bulls) + \\'A\\' + to_string(cows) + \\'B\\';\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        std::vector<int> sc(10);\\n        int bulls = 0, cows = 0;\\n        for (char c: secret) sc[c - \\'0\\']++;\\n        for (char c: guess) sc[c - \\'0\\']--;\\n        cows = secret.size() - std::accumulate(begin(sc), end(sc), 0, [](int a, int b){return a + std::max(b, 0);});\\n        for (int i = 0; i < secret.size(); i++) bulls += secret[i] == guess[i];\\n        return to_string(bulls) + \\'A\\' + to_string(cows - bulls) + \\'B\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761924,
                "title": "python-simple-solution-using-hash-map",
                "content": "```\\ndef getHint(self, secret: str, guess: str) -> str:\\n        secret_dict, guess_dict = defaultdict(int), defaultdict(int)\\n        bull = cow = 0\\n        \\n        for s, g in zip(secret, guess):\\n            if s == g:\\n                bull += 1\\n            else:\\n                guess_dict[g] += 1\\n                secret_dict[s] += 1\\n        \\n        for guess in guess_dict:\\n            if guess in secret_dict:\\n                cow += min(guess_dict[guess], secret_dict[guess])\\n            \\n        return f\"{bull}A{cow}B\"\\n```",
                "solutionTags": [],
                "code": "```\\ndef getHint(self, secret: str, guess: str) -> str:\\n        secret_dict, guess_dict = defaultdict(int), defaultdict(int)\\n        bull = cow = 0\\n        \\n        for s, g in zip(secret, guess):\\n            if s == g:\\n                bull += 1\\n            else:\\n                guess_dict[g] += 1\\n                secret_dict[s] += 1\\n        \\n        for guess in guess_dict:\\n            if guess in secret_dict:\\n                cow += min(guess_dict[guess], secret_dict[guess])\\n            \\n        return f\"{bull}A{cow}B\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 726790,
                "title": "think-this-in-a-producer-consumer-way-secret-is-the-producer-and-guess-is-the-consumer",
                "content": "```\\nclass Solution:\\n    def getHint(self, secret, guess):\\n        bulls = 0\\n        bucket = [0]*10 # to store \\'products\\', totally 10 positions for 10-types of products\\n        for s, g in zip(secret, guess):\\n            if s == g:\\n                bulls += 1\\n            else:\\n                bucket[int(s)] += 1 # supplier, will supply one product to one position\\n                bucket[int(g)] -= 1 # customer, will take one product to consume\\n            print(bucket, s, g)\\n        return \\'%sA%sB\\' % (bulls, len(secret) - bulls - sum(cnt for cnt in bucket if cnt>0))\\n    # sum(cnt for cnt in bucket if cnt>0) = products that are produced and not consumed yet (guess was not about to consume it)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getHint(self, secret, guess):\\n        bulls = 0\\n        bucket = [0]*10 # to store \\'products\\', totally 10 positions for 10-types of products\\n        for s, g in zip(secret, guess):\\n            if s == g:\\n                bulls += 1\\n            else:\\n                bucket[int(s)] += 1 # supplier, will supply one product to one position\\n                bucket[int(g)] -= 1 # customer, will take one product to consume\\n            print(bucket, s, g)\\n        return \\'%sA%sB\\' % (bulls, len(secret) - bulls - sum(cnt for cnt in bucket if cnt>0))\\n    # sum(cnt for cnt in bucket if cnt>0) = products that are produced and not consumed yet (guess was not about to consume it)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719433,
                "title": "easy-to-understand-python-solution",
                "content": "\\tclass Solution:\\n\\t    def getHint(self, secret: str, guess: str) -> str:\\n\\t        A=B=0\\n\\t        s = dict(Counter(secret))\\n\\t        g = dict(Counter(guess))\\n\\t        for i in range(len(guess)):\\n\\t            if guess[i]==secret[i]: A+=1\\n\\t        for v in g:\\n\\t            if v in s: B+=min(s[v],g[v])\\n\\t        return f\"{A}A{B-A}B\"",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n\\t    def getHint(self, secret: str, guess: str) -> str:\\n\\t        A=B=0\\n\\t        s = dict(Counter(secret))\\n\\t        g = dict(Counter(guess))\\n\\t        for i in range(len(guess)):\\n\\t            if guess[i]==secret[i]: A+=1\\n\\t        for v in g:\\n\\t            if v in s: B+=min(s[v],g[v])\\n\\t        return f\"{A}",
                "codeTag": "Java"
            },
            {
                "id": 714310,
                "title": "java-clean-code-o-n-optimal-solution-1-ms-time-100-faster",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic String getHint (String secret, String guess) {\\n\\t\\t\\n\\t\\tint[] points = new int[10];\\n\\t\\tint bulls = 0, cows = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < secret.length (); i++) {\\n\\t\\t\\tint secretPoint = secret.charAt (i) - \\'0\\';\\n\\t\\t\\tint guessPoint = guess.charAt (i) - \\'0\\';\\n\\t\\t\\tif (secretPoint == guessPoint) {\\n\\t\\t\\t\\t++bulls;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (--points[secretPoint] >= 0) {\\n\\t\\t\\t\\t\\t++cows;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (++points[guessPoint] <= 0) {\\n\\t\\t\\t\\t\\t++cows;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn new StringBuilder ().append (bulls).append (\"A\").append (cows).append (\"B\").toString ();\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic String getHint (String secret, String guess) {\\n\\t\\t\\n\\t\\tint[] points = new int[10];\\n\\t\\tint bulls = 0, cows = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < secret.length (); i++) {\\n\\t\\t\\tint secretPoint = secret.charAt (i) - \\'0\\';\\n\\t\\t\\tint guessPoint = guess.charAt (i) - \\'0\\';\\n\\t\\t\\tif (secretPoint == guessPoint) {\\n\\t\\t\\t\\t++bulls;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (--points[secretPoint] >= 0) {\\n\\t\\t\\t\\t\\t++cows;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (++points[guessPoint] <= 0) {\\n\\t\\t\\t\\t\\t++cows;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn new StringBuilder ().append (bulls).append (\"A\").append (cows).append (\"B\").toString ();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698929,
                "title": "simple-java-easy-to-understand-solution-no-tricks",
                "content": "\\tclass Solution {\\n\\t\\tpublic String getHint(String secret, String guess) {\\n\\t\\t\\tint[] map = new int[10];\\n\\t\\t\\tint n = secret.length();\\n\\t\\t\\tint bulls =0, cows =0;\\n\\t\\t\\tfor(char c : secret.toCharArray()){\\n\\t\\t\\t\\tmap[c-\\'0\\']++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(char c : guess.toCharArray()){\\n\\t\\t\\t\\tif(map[c-\\'0\\']-- >0)\\n\\t\\t\\t\\t\\tcows++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tif(secret.charAt(i) == guess.charAt(i))\\n\\t\\t\\t\\t\\tbulls++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn String.valueOf(bulls)+\"A\"+String.valueOf(cows-bulls)+\"B\";\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic String getHint(String secret, String guess) {\\n\\t\\t\\tint[] map = new int[10];\\n\\t\\t\\tint n = secret.length();\\n\\t\\t\\tint bulls =0, cows =0;\\n\\t\\t\\tfor(char c : secret.toCharArray()){\\n\\t\\t\\t\\tmap[c-\\'0\\']++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 697646,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        \\n        int[] nums = new int[10];\\n        \\n        for (int i = 0; i < secret.length(); i++) {\\n            nums[secret.charAt(i) - \\'0\\']++;\\n        }\\n        int bulls = 0;\\n        int cows = 0;\\n        \\n        Set<Integer> remainingIndexes = new HashSet<>();\\n        \\n        for (int i = 0; i < guess.length(); i++) {\\n            char c = guess.charAt(i);\\n            if (c == secret.charAt(i)) {\\n                bulls++;\\n                nums[c - \\'0\\']--;\\n            } else {\\n                remainingIndexes.add(i);\\n            }\\n        }\\n        \\n        for (Integer i : remainingIndexes) {\\n            char c = guess.charAt(i);\\n            if (nums[c - \\'0\\'] > 0) {\\n                cows++;\\n                nums[c - \\'0\\']--;\\n            }\\n        }\\n        \\n        return String.format(\"%sA%sB\", bulls, cows);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        \\n        int[] nums = new int[10];\\n        \\n        for (int i = 0; i < secret.length(); i++) {\\n            nums[secret.charAt(i) - \\'0\\']++;\\n        }\\n        int bulls = 0;\\n        int cows = 0;\\n        \\n        Set<Integer> remainingIndexes = new HashSet<>();\\n        \\n        for (int i = 0; i < guess.length(); i++) {\\n            char c = guess.charAt(i);\\n            if (c == secret.charAt(i)) {\\n                bulls++;\\n                nums[c - \\'0\\']--;\\n            } else {\\n                remainingIndexes.add(i);\\n            }\\n        }\\n        \\n        for (Integer i : remainingIndexes) {\\n            char c = guess.charAt(i);\\n            if (nums[c - \\'0\\'] > 0) {\\n                cows++;\\n                nums[c - \\'0\\']--;\\n            }\\n        }\\n        \\n        return String.format(\"%sA%sB\", bulls, cows);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694160,
                "title": "one-pass-c-solution-faster-than-98-97",
                "content": "We iterate over `secret` one character at a time. We also maintain a count of each digit seen so far in an array.\\n\\nIf `secret[i] == guess[i]`, we increase `bulls` count.\\nElse, we update counts of both the characters and of cows accordingly.\\n\\nTime: `O(n)` where n is the length of secret\\nSpace: `O(1)`\\nSize of count array is 10 which is not dependent on n. Hence, space complexity is constant.\\n\\n```\\nstring getHint(string secret, string guess) {\\n  vector<int> count(10, 0);\\n  int bulls = 0, cows = 0;\\n  for (int i = 0; i < secret.size(); ++i) {\\n    if (secret[i] == guess[i]) ++bulls;\\n    else {\\n      if (count[secret[i] - \\'0\\']++ < 0) ++cows;\\n      if (count[guess[i] - \\'0\\']-- > 0) ++cows;\\n    }\\n  }\\n  return to_string(bulls) + \\'A\\' + to_string(cows) + \\'B\\';\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring getHint(string secret, string guess) {\\n  vector<int> count(10, 0);\\n  int bulls = 0, cows = 0;\\n  for (int i = 0; i < secret.size(); ++i) {\\n    if (secret[i] == guess[i]) ++bulls;\\n    else {\\n      if (count[secret[i] - \\'0\\']++ < 0) ++cows;\\n      if (count[guess[i] - \\'0\\']-- > 0) ++cows;\\n    }\\n  }\\n  return to_string(bulls) + \\'A\\' + to_string(cows) + \\'B\\';\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 599941,
                "title": "simple-logic-and-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int n=secret.size();\\n        unordered_map<char,int> se,gue;\\n        int ans=0,bulls=0;\\n        for(int i=0;i<n;i++){\\n            if(secret[i]==guess[i]){\\n                bulls++;\\n            }\\n            se[secret[i]]++;\\n            gue[guess[i]]++;\\n        }\\n        for(auto it=gue.begin();it!=gue.end();it++){\\n                char k=it->first;\\n                if(se.find(k)!=se.end()){\\n                    ans+=min(se[k],it->second); //common elements, whether at right position or wrong\\n                }\\n        }\\n        return to_string(bulls)+\"A\"+to_string(ans-bulls)+\"B\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        int n=secret.size();\\n        unordered_map<char,int> se,gue;\\n        int ans=0,bulls=0;\\n        for(int i=0;i<n;i++){\\n            if(secret[i]==guess[i]){\\n                bulls++;\\n            }\\n            se[secret[i]]++;\\n            gue[guess[i]]++;\\n        }\\n        for(auto it=gue.begin();it!=gue.end();it++){\\n                char k=it->first;\\n                if(se.find(k)!=se.end()){\\n                    ans+=min(se[k],it->second); //common elements, whether at right position or wrong\\n                }\\n        }\\n        return to_string(bulls)+\"A\"+to_string(ans-bulls)+\"B\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588289,
                "title": "java-simple-with-only-one-count-array",
                "content": "```\\npublic String getHint(String secret, String guess) {\\n\\tint bulls = 0, cows = 0;\\n\\tint[] count = new int[10];\\n\\tfor(int i=0;i<secret.length();i++) {                    //count bulls\\n\\t\\tif(secret.charAt(i) == guess.charAt(i))\\n\\t\\t\\tbulls++;\\n\\t\\telse \\n\\t\\t\\tcount[secret.charAt(i) - \\'0\\']++;\\n\\t}\\n\\tfor(int i=0;i<guess.length();i++) {                     //count cows\\n\\t\\tif(secret.charAt(i) != guess.charAt(i) && count[guess.charAt(i) - \\'0\\'] > 0) {\\n\\t\\t\\tcows++;\\n\\t\\t\\tcount[guess.charAt(i) - \\'0\\']--;\\n\\t\\t}\\n\\t}\\n\\treturn bulls +\"A\" +cows + \"B\"; \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String getHint(String secret, String guess) {\\n\\tint bulls = 0, cows = 0;\\n\\tint[] count = new int[10];\\n\\tfor(int i=0;i<secret.length();i++) {                    //count bulls\\n\\t\\tif(secret.charAt(i) == guess.charAt(i))\\n\\t\\t\\tbulls++;\\n\\t\\telse \\n\\t\\t\\tcount[secret.charAt(i) - \\'0\\']++;\\n\\t}\\n\\tfor(int i=0;i<guess.length();i++) {                     //count cows\\n\\t\\tif(secret.charAt(i) != guess.charAt(i) && count[guess.charAt(i) - \\'0\\'] > 0) {\\n\\t\\t\\tcows++;\\n\\t\\t\\tcount[guess.charAt(i) - \\'0\\']--;\\n\\t\\t}\\n\\t}\\n\\treturn bulls +\"A\" +cows + \"B\"; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 586306,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int[] arr = new int[10];\\n        int bulls = 0;\\n        int cows = 0;\\n        for(int i = 0; i < secret.length(); i++){\\n            char a = secret.charAt(i);\\n            char b = guess.charAt(i);\\n            if(a == b){\\n                bulls++;\\n            }\\n            else{\\n                arr[a - \\'0\\']++;\\n            }\\n        }\\n        \\n        for(int i = 0; i < guess.length(); i++){\\n            char a = secret.charAt(i);\\n            char b = guess.charAt(i);\\n            if(a != b && arr[b - \\'0\\'] > 0){\\n                cows++;\\n                arr[b - \\'0\\']--;\\n            }\\n            \\n        }\\n        return \"\" + bulls + \"A\" + cows + \"B\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getHint(String secret, String guess) {\\n        int[] arr = new int[10];\\n        int bulls = 0;\\n        int cows = 0;\\n        for(int i = 0; i < secret.length(); i++){\\n            char a = secret.charAt(i);\\n            char b = guess.charAt(i);\\n            if(a == b){\\n                bulls++;\\n            }\\n            else{\\n                arr[a - \\'0\\']++;\\n            }\\n        }\\n        \\n        for(int i = 0; i < guess.length(); i++){\\n            char a = secret.charAt(i);\\n            char b = guess.charAt(i);\\n            if(a != b && arr[b - \\'0\\'] > 0){\\n                cows++;\\n                arr[b - \\'0\\']--;\\n            }\\n            \\n        }\\n        return \"\" + bulls + \"A\" + cows + \"B\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583841,
                "title": "one-pass-python",
                "content": "Here\\'s another possible solution. \\n1. Start off by initialising b (Number of bulls) and c (Number of cows) as 0.\\n2. Create a list **guess_list** which is **guess** in list format. (Could be done with just str too)\\n3. Iterate through **secret** and find the bulls by checking if any of the elements have an exact match in **guess**.\\n4. Then check if that value is in **guess** at any point. If it is, we remove that value from the **guess_list** and increment number of cows\\n5. At the end, we return the # bulls and # cows (which is equal to the number of cows-bulls, since we added bulls as cows during the loop).\\n\\n```\\nb,c = 0,0\\nguess_list = [c for c in guess]\\n# Find bulls\\nfor i in range(len(secret)):\\n\\tif secret[i]==guess[i]:\\n\\t\\tb+=1\\n\\tif secret[i] in guess_list:\\n\\t\\tc+=1\\n\\t\\tguess_list.remove(secret[i])\\n\\nreturn \"{}A{}B\".format(b,c-b)\\n\\t\\t\\n```\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nb,c = 0,0\\nguess_list = [c for c in guess]\\n# Find bulls\\nfor i in range(len(secret)):\\n\\tif secret[i]==guess[i]:\\n\\t\\tb+=1\\n\\tif secret[i] in guess_list:\\n\\t\\tc+=1\\n\\t\\tguess_list.remove(secret[i])\\n\\nreturn \"{}A{}B\".format(b,c-b)\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1788020,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1566498,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1901988,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1569435,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1573124,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1569061,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1573626,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1569060,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1571963,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1571552,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1788020,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1566498,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1901988,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1569435,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1573124,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1569061,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1573626,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1569060,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1571963,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1571552,
                "content": [
                    {
                        "username": "codeywodey",
                        "content": "This is a pretty bad problem. Poorly defined and would take a while for an interviewer to explain correctly. I\\'m pretty sure whoever came up with this never tested with their colleagues and anyone else who used it just snatched it from online without considering it too much. "
                    },
                    {
                        "username": "rock",
                        "content": "Why not **0A1B**? Any one mind elaborating the reason?\\n\\n> Input: \"1\" \"0\"\\n> \\n> Output: \"0A1B\"\\n> \\n> Expected: \"0A0B\"\\n\\nUpdate: Now I got it: the guess digits that in wrong positions should also be among secret digits."
                    },
                    {
                        "username": "Abdul_Mattee",
                        "content": "## What are bulls?\\nThe digits in guess that are correct and are in right positions.\\n## What are cows?\\nThe digits that are correct but on wrong positions.\\n## Example:\\n### Input: \\n**secret = \"1123\", guess = \"0111\"**\\n\\n\\'1\\' on second postion 1**1**23, 0**1**11 is correct and is on right position -> 1 BULL.\\nThe other \\'1\\' is also correct but on wrong position, **1**123, 01**1**1 or 011**1**. *You can consider any of the 2 ones*. -> 1 COWS\\n**Output: 1A1B**\\n"
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "This problem has unnecessary edge cases when there\\'s extra cows in guess but non appearance in secret. It shouldn\\'t be count. But this is not well described neither in the descriptions nor in example cases. \\nIt is a waste of time for resolvers to play with this kind of issue becaue the only difference is to set a counter of this."
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nthe easiest questions are likely to be the hardest one. it cost me over 2 hours to get it fix."
                    },
                    {
                        "username": "ShinozakiAi",
                        "content": "In this case: only one digit 1 is counted, and it is unmatched for all the place, so 0A1B.\\n\\nInput:\\n\"1234\"\\n\"0111\"\\nOutput:\\n\"0A3B\"\\nExpected:\\n\"0A1B\"\\n\\n\\nIn this case: two digits, 1, and 2, both are in wrong place, so I think it should be 0A2B, but the answer is 0A4B, so it double counts the unmatched digits. This really confused me.\\n\\nInput:\\n\"1122\"\\n\"2211\"\\nOutput:\\n\"0A2B\"\\nExpected:\\n\"0A4B\"\\n\\nI think I misunderstood the rule of \"bull and cow\", could someone explain this? Thanks."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Both the expected outputs are correct. In the first case the digits in secret are 1,2,3,4 but only 1 is present in guess and that too at the wrong place so its only 0A1B. \\nNow in the second case, the digits are 1,1,2,2 and all of them are present in the guess but all at wrong places so its 0A4B. Hope it helps!"
                    },
                    {
                        "username": "lidaivet",
                        "content": "In my understanding of the problem, below should return\\n\\n\"1122\"\\n\"2211\"\\n\\n0A2B\\n\\n\"1123\"\\n\"0111\"\\n\\n1A1B\\n\\nBut solution returns the first one as 0A4B and second one as 1A1B. \\nWhat am I missing? if incorrect spots were counted repeatedly, wouldn\\'t the second one be 1A2B instead?"
                    },
                    {
                        "username": "shihua2",
                        "content": "If the 2nd and 3rd \"1\" got ignored in the test case \"1234\"/\"0111\", the 2nd \"2\" and the 2nd \"1\" should be ignored in the test case \"1122\"/\"2211\" too, so its result should be 0A2B.\\n\\nDid I understand the expected behavior wrong?"
                    },
                    {
                        "username": "DDOwzw",
                        "content": "According to the problem description, the test:\\n\"1123\"\\n\"0111\"\\nshould return 1A2B, since the last 2 \\'1\\'s are both \"the correct digits in the wrong locations\"."
                    },
                    {
                        "username": "david120",
                        "content": "> You write a 4-digit secret number and ask your friend to guess it.\\n\\nThis implies both inputs are length 4.  The examples are also both length 4.  It is trivial but unfair to expect support for inputs with length not equal to 4 (especially the length 0 case)."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Read the constraints properly \n```1 <= secret.length, guess.length <= 1000```"
                    }
                ]
            },
            {
                "id": 1761136,
                "content": [
                    {
                        "username": "Nika_Sunchild",
                        "content": "This problem is problematic. And by that I mean SEXIST, holy cow."
                    },
                    {
                        "username": "Nabarun21",
                        "content": "No way this should be a medium problem. Compare this to Jump game II which is also medium."
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case you are not able to understand the problem\\nFor Bulls \\n1. If there is an element in secret and same element is available in guess, and the index of both is same then it\\'s a bull.\\nEx. Secret = 1123     >> 1 at index 1\\n      Guess = 0111     >> 1 at index 1\\n\\nFor Cows\\n2. If there is an element in secret and same element is available in guess but the index is different then it\\'ll be cow.\\nEx. Secret = 1123     >> 1 at index 0\\n      Guess = 0111     >> 1 at index 2\\n\\nNote: If there is 1 element in secret but there are 3 same element in guess, then it will be considered only 1.\\nEx 1: \\nSecret: \"1234\"\\nGuess:  0111\"\\nExpected:\\n\"0A1B\"\\n\\nthere is no element at which has same value and is same index.\\n1 is only one time in secret by three times in guess so we\\'ll only the first 1(at 1 index)\\n\\nEx 2: \\nSecret: \"1122\"\\nGuess:  \"2211\"\\nExpected:\\n\"0A4B\"\\n\\nBecause there is no element at same index so bull is 0.\\nthere are 2 1\\'s  and 2 2\\'s in both secret and guess so cows will be 4\\n\\nLet me know if you didn\\'t understand it."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be marked as an easy one."
                    },
                    {
                        "username": "smit_123",
                        "content": "class Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        int bullsCount = 0, cowsCount = 0;\\n        unordered_map<char,int>mp;\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bullsCount++;\\n                mp[secret[i]] -= 1;\\n            }\\n            mp[secret[i]]++;\\n        }\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] != guess[i])\\n            {\\n                if(mp[guess[i]] > 0)\\n                {\\n                    mp[guess[i]] -= 1;\\n                    cowsCount++;\\n                }\\n            }\\n        }\\n        return to_string(bullsCount) + \"A\" + to_string(cowsCount) + \"B\";\\n    }\\n};"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "It should be hard bcs it\\'s freaking impossible to understand the problem without reading the comments \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I feel stupid because I don\\'t understand what they ask me to do :)"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I can\\'t Understand the Question -> Only!"
                    },
                    {
                        "username": "hackkerguy11",
                        "content": "Has my problem solving skill been improved or this problem does not deserve to be at medium level ?"
                    },
                    {
                        "username": "eduard92",
                        "content": "The problem itself is not that hard to understand once you read the wiki page... The text in the problem makes sense only after you read the wiki page.\nThe testcases are trial and error which is annoying.. but if I solved it on my own, its an easy question, took me 40 min tho."
                    }
                ]
            },
            {
                "id": 1572681,
                "content": [
                    {
                        "username": "Nika_Sunchild",
                        "content": "This problem is problematic. And by that I mean SEXIST, holy cow."
                    },
                    {
                        "username": "Nabarun21",
                        "content": "No way this should be a medium problem. Compare this to Jump game II which is also medium."
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case you are not able to understand the problem\\nFor Bulls \\n1. If there is an element in secret and same element is available in guess, and the index of both is same then it\\'s a bull.\\nEx. Secret = 1123     >> 1 at index 1\\n      Guess = 0111     >> 1 at index 1\\n\\nFor Cows\\n2. If there is an element in secret and same element is available in guess but the index is different then it\\'ll be cow.\\nEx. Secret = 1123     >> 1 at index 0\\n      Guess = 0111     >> 1 at index 2\\n\\nNote: If there is 1 element in secret but there are 3 same element in guess, then it will be considered only 1.\\nEx 1: \\nSecret: \"1234\"\\nGuess:  0111\"\\nExpected:\\n\"0A1B\"\\n\\nthere is no element at which has same value and is same index.\\n1 is only one time in secret by three times in guess so we\\'ll only the first 1(at 1 index)\\n\\nEx 2: \\nSecret: \"1122\"\\nGuess:  \"2211\"\\nExpected:\\n\"0A4B\"\\n\\nBecause there is no element at same index so bull is 0.\\nthere are 2 1\\'s  and 2 2\\'s in both secret and guess so cows will be 4\\n\\nLet me know if you didn\\'t understand it."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be marked as an easy one."
                    },
                    {
                        "username": "smit_123",
                        "content": "class Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        int bullsCount = 0, cowsCount = 0;\\n        unordered_map<char,int>mp;\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bullsCount++;\\n                mp[secret[i]] -= 1;\\n            }\\n            mp[secret[i]]++;\\n        }\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] != guess[i])\\n            {\\n                if(mp[guess[i]] > 0)\\n                {\\n                    mp[guess[i]] -= 1;\\n                    cowsCount++;\\n                }\\n            }\\n        }\\n        return to_string(bullsCount) + \"A\" + to_string(cowsCount) + \"B\";\\n    }\\n};"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "It should be hard bcs it\\'s freaking impossible to understand the problem without reading the comments \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I feel stupid because I don\\'t understand what they ask me to do :)"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I can\\'t Understand the Question -> Only!"
                    },
                    {
                        "username": "hackkerguy11",
                        "content": "Has my problem solving skill been improved or this problem does not deserve to be at medium level ?"
                    },
                    {
                        "username": "eduard92",
                        "content": "The problem itself is not that hard to understand once you read the wiki page... The text in the problem makes sense only after you read the wiki page.\nThe testcases are trial and error which is annoying.. but if I solved it on my own, its an easy question, took me 40 min tho."
                    }
                ]
            },
            {
                "id": 2063578,
                "content": [
                    {
                        "username": "Nika_Sunchild",
                        "content": "This problem is problematic. And by that I mean SEXIST, holy cow."
                    },
                    {
                        "username": "Nabarun21",
                        "content": "No way this should be a medium problem. Compare this to Jump game II which is also medium."
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case you are not able to understand the problem\\nFor Bulls \\n1. If there is an element in secret and same element is available in guess, and the index of both is same then it\\'s a bull.\\nEx. Secret = 1123     >> 1 at index 1\\n      Guess = 0111     >> 1 at index 1\\n\\nFor Cows\\n2. If there is an element in secret and same element is available in guess but the index is different then it\\'ll be cow.\\nEx. Secret = 1123     >> 1 at index 0\\n      Guess = 0111     >> 1 at index 2\\n\\nNote: If there is 1 element in secret but there are 3 same element in guess, then it will be considered only 1.\\nEx 1: \\nSecret: \"1234\"\\nGuess:  0111\"\\nExpected:\\n\"0A1B\"\\n\\nthere is no element at which has same value and is same index.\\n1 is only one time in secret by three times in guess so we\\'ll only the first 1(at 1 index)\\n\\nEx 2: \\nSecret: \"1122\"\\nGuess:  \"2211\"\\nExpected:\\n\"0A4B\"\\n\\nBecause there is no element at same index so bull is 0.\\nthere are 2 1\\'s  and 2 2\\'s in both secret and guess so cows will be 4\\n\\nLet me know if you didn\\'t understand it."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be marked as an easy one."
                    },
                    {
                        "username": "smit_123",
                        "content": "class Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        int bullsCount = 0, cowsCount = 0;\\n        unordered_map<char,int>mp;\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bullsCount++;\\n                mp[secret[i]] -= 1;\\n            }\\n            mp[secret[i]]++;\\n        }\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] != guess[i])\\n            {\\n                if(mp[guess[i]] > 0)\\n                {\\n                    mp[guess[i]] -= 1;\\n                    cowsCount++;\\n                }\\n            }\\n        }\\n        return to_string(bullsCount) + \"A\" + to_string(cowsCount) + \"B\";\\n    }\\n};"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "It should be hard bcs it\\'s freaking impossible to understand the problem without reading the comments \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I feel stupid because I don\\'t understand what they ask me to do :)"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I can\\'t Understand the Question -> Only!"
                    },
                    {
                        "username": "hackkerguy11",
                        "content": "Has my problem solving skill been improved or this problem does not deserve to be at medium level ?"
                    },
                    {
                        "username": "eduard92",
                        "content": "The problem itself is not that hard to understand once you read the wiki page... The text in the problem makes sense only after you read the wiki page.\nThe testcases are trial and error which is annoying.. but if I solved it on my own, its an easy question, took me 40 min tho."
                    }
                ]
            },
            {
                "id": 2049933,
                "content": [
                    {
                        "username": "Nika_Sunchild",
                        "content": "This problem is problematic. And by that I mean SEXIST, holy cow."
                    },
                    {
                        "username": "Nabarun21",
                        "content": "No way this should be a medium problem. Compare this to Jump game II which is also medium."
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case you are not able to understand the problem\\nFor Bulls \\n1. If there is an element in secret and same element is available in guess, and the index of both is same then it\\'s a bull.\\nEx. Secret = 1123     >> 1 at index 1\\n      Guess = 0111     >> 1 at index 1\\n\\nFor Cows\\n2. If there is an element in secret and same element is available in guess but the index is different then it\\'ll be cow.\\nEx. Secret = 1123     >> 1 at index 0\\n      Guess = 0111     >> 1 at index 2\\n\\nNote: If there is 1 element in secret but there are 3 same element in guess, then it will be considered only 1.\\nEx 1: \\nSecret: \"1234\"\\nGuess:  0111\"\\nExpected:\\n\"0A1B\"\\n\\nthere is no element at which has same value and is same index.\\n1 is only one time in secret by three times in guess so we\\'ll only the first 1(at 1 index)\\n\\nEx 2: \\nSecret: \"1122\"\\nGuess:  \"2211\"\\nExpected:\\n\"0A4B\"\\n\\nBecause there is no element at same index so bull is 0.\\nthere are 2 1\\'s  and 2 2\\'s in both secret and guess so cows will be 4\\n\\nLet me know if you didn\\'t understand it."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be marked as an easy one."
                    },
                    {
                        "username": "smit_123",
                        "content": "class Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        int bullsCount = 0, cowsCount = 0;\\n        unordered_map<char,int>mp;\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bullsCount++;\\n                mp[secret[i]] -= 1;\\n            }\\n            mp[secret[i]]++;\\n        }\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] != guess[i])\\n            {\\n                if(mp[guess[i]] > 0)\\n                {\\n                    mp[guess[i]] -= 1;\\n                    cowsCount++;\\n                }\\n            }\\n        }\\n        return to_string(bullsCount) + \"A\" + to_string(cowsCount) + \"B\";\\n    }\\n};"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "It should be hard bcs it\\'s freaking impossible to understand the problem without reading the comments \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I feel stupid because I don\\'t understand what they ask me to do :)"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I can\\'t Understand the Question -> Only!"
                    },
                    {
                        "username": "hackkerguy11",
                        "content": "Has my problem solving skill been improved or this problem does not deserve to be at medium level ?"
                    },
                    {
                        "username": "eduard92",
                        "content": "The problem itself is not that hard to understand once you read the wiki page... The text in the problem makes sense only after you read the wiki page.\nThe testcases are trial and error which is annoying.. but if I solved it on my own, its an easy question, took me 40 min tho."
                    }
                ]
            },
            {
                "id": 1938019,
                "content": [
                    {
                        "username": "Nika_Sunchild",
                        "content": "This problem is problematic. And by that I mean SEXIST, holy cow."
                    },
                    {
                        "username": "Nabarun21",
                        "content": "No way this should be a medium problem. Compare this to Jump game II which is also medium."
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case you are not able to understand the problem\\nFor Bulls \\n1. If there is an element in secret and same element is available in guess, and the index of both is same then it\\'s a bull.\\nEx. Secret = 1123     >> 1 at index 1\\n      Guess = 0111     >> 1 at index 1\\n\\nFor Cows\\n2. If there is an element in secret and same element is available in guess but the index is different then it\\'ll be cow.\\nEx. Secret = 1123     >> 1 at index 0\\n      Guess = 0111     >> 1 at index 2\\n\\nNote: If there is 1 element in secret but there are 3 same element in guess, then it will be considered only 1.\\nEx 1: \\nSecret: \"1234\"\\nGuess:  0111\"\\nExpected:\\n\"0A1B\"\\n\\nthere is no element at which has same value and is same index.\\n1 is only one time in secret by three times in guess so we\\'ll only the first 1(at 1 index)\\n\\nEx 2: \\nSecret: \"1122\"\\nGuess:  \"2211\"\\nExpected:\\n\"0A4B\"\\n\\nBecause there is no element at same index so bull is 0.\\nthere are 2 1\\'s  and 2 2\\'s in both secret and guess so cows will be 4\\n\\nLet me know if you didn\\'t understand it."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be marked as an easy one."
                    },
                    {
                        "username": "smit_123",
                        "content": "class Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        int bullsCount = 0, cowsCount = 0;\\n        unordered_map<char,int>mp;\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bullsCount++;\\n                mp[secret[i]] -= 1;\\n            }\\n            mp[secret[i]]++;\\n        }\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] != guess[i])\\n            {\\n                if(mp[guess[i]] > 0)\\n                {\\n                    mp[guess[i]] -= 1;\\n                    cowsCount++;\\n                }\\n            }\\n        }\\n        return to_string(bullsCount) + \"A\" + to_string(cowsCount) + \"B\";\\n    }\\n};"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "It should be hard bcs it\\'s freaking impossible to understand the problem without reading the comments \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I feel stupid because I don\\'t understand what they ask me to do :)"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I can\\'t Understand the Question -> Only!"
                    },
                    {
                        "username": "hackkerguy11",
                        "content": "Has my problem solving skill been improved or this problem does not deserve to be at medium level ?"
                    },
                    {
                        "username": "eduard92",
                        "content": "The problem itself is not that hard to understand once you read the wiki page... The text in the problem makes sense only after you read the wiki page.\nThe testcases are trial and error which is annoying.. but if I solved it on my own, its an easy question, took me 40 min tho."
                    }
                ]
            },
            {
                "id": 1904339,
                "content": [
                    {
                        "username": "Nika_Sunchild",
                        "content": "This problem is problematic. And by that I mean SEXIST, holy cow."
                    },
                    {
                        "username": "Nabarun21",
                        "content": "No way this should be a medium problem. Compare this to Jump game II which is also medium."
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case you are not able to understand the problem\\nFor Bulls \\n1. If there is an element in secret and same element is available in guess, and the index of both is same then it\\'s a bull.\\nEx. Secret = 1123     >> 1 at index 1\\n      Guess = 0111     >> 1 at index 1\\n\\nFor Cows\\n2. If there is an element in secret and same element is available in guess but the index is different then it\\'ll be cow.\\nEx. Secret = 1123     >> 1 at index 0\\n      Guess = 0111     >> 1 at index 2\\n\\nNote: If there is 1 element in secret but there are 3 same element in guess, then it will be considered only 1.\\nEx 1: \\nSecret: \"1234\"\\nGuess:  0111\"\\nExpected:\\n\"0A1B\"\\n\\nthere is no element at which has same value and is same index.\\n1 is only one time in secret by three times in guess so we\\'ll only the first 1(at 1 index)\\n\\nEx 2: \\nSecret: \"1122\"\\nGuess:  \"2211\"\\nExpected:\\n\"0A4B\"\\n\\nBecause there is no element at same index so bull is 0.\\nthere are 2 1\\'s  and 2 2\\'s in both secret and guess so cows will be 4\\n\\nLet me know if you didn\\'t understand it."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be marked as an easy one."
                    },
                    {
                        "username": "smit_123",
                        "content": "class Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        int bullsCount = 0, cowsCount = 0;\\n        unordered_map<char,int>mp;\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bullsCount++;\\n                mp[secret[i]] -= 1;\\n            }\\n            mp[secret[i]]++;\\n        }\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] != guess[i])\\n            {\\n                if(mp[guess[i]] > 0)\\n                {\\n                    mp[guess[i]] -= 1;\\n                    cowsCount++;\\n                }\\n            }\\n        }\\n        return to_string(bullsCount) + \"A\" + to_string(cowsCount) + \"B\";\\n    }\\n};"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "It should be hard bcs it\\'s freaking impossible to understand the problem without reading the comments \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I feel stupid because I don\\'t understand what they ask me to do :)"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I can\\'t Understand the Question -> Only!"
                    },
                    {
                        "username": "hackkerguy11",
                        "content": "Has my problem solving skill been improved or this problem does not deserve to be at medium level ?"
                    },
                    {
                        "username": "eduard92",
                        "content": "The problem itself is not that hard to understand once you read the wiki page... The text in the problem makes sense only after you read the wiki page.\nThe testcases are trial and error which is annoying.. but if I solved it on my own, its an easy question, took me 40 min tho."
                    }
                ]
            },
            {
                "id": 1878949,
                "content": [
                    {
                        "username": "Nika_Sunchild",
                        "content": "This problem is problematic. And by that I mean SEXIST, holy cow."
                    },
                    {
                        "username": "Nabarun21",
                        "content": "No way this should be a medium problem. Compare this to Jump game II which is also medium."
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case you are not able to understand the problem\\nFor Bulls \\n1. If there is an element in secret and same element is available in guess, and the index of both is same then it\\'s a bull.\\nEx. Secret = 1123     >> 1 at index 1\\n      Guess = 0111     >> 1 at index 1\\n\\nFor Cows\\n2. If there is an element in secret and same element is available in guess but the index is different then it\\'ll be cow.\\nEx. Secret = 1123     >> 1 at index 0\\n      Guess = 0111     >> 1 at index 2\\n\\nNote: If there is 1 element in secret but there are 3 same element in guess, then it will be considered only 1.\\nEx 1: \\nSecret: \"1234\"\\nGuess:  0111\"\\nExpected:\\n\"0A1B\"\\n\\nthere is no element at which has same value and is same index.\\n1 is only one time in secret by three times in guess so we\\'ll only the first 1(at 1 index)\\n\\nEx 2: \\nSecret: \"1122\"\\nGuess:  \"2211\"\\nExpected:\\n\"0A4B\"\\n\\nBecause there is no element at same index so bull is 0.\\nthere are 2 1\\'s  and 2 2\\'s in both secret and guess so cows will be 4\\n\\nLet me know if you didn\\'t understand it."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be marked as an easy one."
                    },
                    {
                        "username": "smit_123",
                        "content": "class Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        int bullsCount = 0, cowsCount = 0;\\n        unordered_map<char,int>mp;\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bullsCount++;\\n                mp[secret[i]] -= 1;\\n            }\\n            mp[secret[i]]++;\\n        }\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] != guess[i])\\n            {\\n                if(mp[guess[i]] > 0)\\n                {\\n                    mp[guess[i]] -= 1;\\n                    cowsCount++;\\n                }\\n            }\\n        }\\n        return to_string(bullsCount) + \"A\" + to_string(cowsCount) + \"B\";\\n    }\\n};"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "It should be hard bcs it\\'s freaking impossible to understand the problem without reading the comments \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I feel stupid because I don\\'t understand what they ask me to do :)"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I can\\'t Understand the Question -> Only!"
                    },
                    {
                        "username": "hackkerguy11",
                        "content": "Has my problem solving skill been improved or this problem does not deserve to be at medium level ?"
                    },
                    {
                        "username": "eduard92",
                        "content": "The problem itself is not that hard to understand once you read the wiki page... The text in the problem makes sense only after you read the wiki page.\nThe testcases are trial and error which is annoying.. but if I solved it on my own, its an easy question, took me 40 min tho."
                    }
                ]
            },
            {
                "id": 1878723,
                "content": [
                    {
                        "username": "Nika_Sunchild",
                        "content": "This problem is problematic. And by that I mean SEXIST, holy cow."
                    },
                    {
                        "username": "Nabarun21",
                        "content": "No way this should be a medium problem. Compare this to Jump game II which is also medium."
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case you are not able to understand the problem\\nFor Bulls \\n1. If there is an element in secret and same element is available in guess, and the index of both is same then it\\'s a bull.\\nEx. Secret = 1123     >> 1 at index 1\\n      Guess = 0111     >> 1 at index 1\\n\\nFor Cows\\n2. If there is an element in secret and same element is available in guess but the index is different then it\\'ll be cow.\\nEx. Secret = 1123     >> 1 at index 0\\n      Guess = 0111     >> 1 at index 2\\n\\nNote: If there is 1 element in secret but there are 3 same element in guess, then it will be considered only 1.\\nEx 1: \\nSecret: \"1234\"\\nGuess:  0111\"\\nExpected:\\n\"0A1B\"\\n\\nthere is no element at which has same value and is same index.\\n1 is only one time in secret by three times in guess so we\\'ll only the first 1(at 1 index)\\n\\nEx 2: \\nSecret: \"1122\"\\nGuess:  \"2211\"\\nExpected:\\n\"0A4B\"\\n\\nBecause there is no element at same index so bull is 0.\\nthere are 2 1\\'s  and 2 2\\'s in both secret and guess so cows will be 4\\n\\nLet me know if you didn\\'t understand it."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be marked as an easy one."
                    },
                    {
                        "username": "smit_123",
                        "content": "class Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        int bullsCount = 0, cowsCount = 0;\\n        unordered_map<char,int>mp;\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bullsCount++;\\n                mp[secret[i]] -= 1;\\n            }\\n            mp[secret[i]]++;\\n        }\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] != guess[i])\\n            {\\n                if(mp[guess[i]] > 0)\\n                {\\n                    mp[guess[i]] -= 1;\\n                    cowsCount++;\\n                }\\n            }\\n        }\\n        return to_string(bullsCount) + \"A\" + to_string(cowsCount) + \"B\";\\n    }\\n};"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "It should be hard bcs it\\'s freaking impossible to understand the problem without reading the comments \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I feel stupid because I don\\'t understand what they ask me to do :)"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I can\\'t Understand the Question -> Only!"
                    },
                    {
                        "username": "hackkerguy11",
                        "content": "Has my problem solving skill been improved or this problem does not deserve to be at medium level ?"
                    },
                    {
                        "username": "eduard92",
                        "content": "The problem itself is not that hard to understand once you read the wiki page... The text in the problem makes sense only after you read the wiki page.\nThe testcases are trial and error which is annoying.. but if I solved it on my own, its an easy question, took me 40 min tho."
                    }
                ]
            },
            {
                "id": 1875039,
                "content": [
                    {
                        "username": "Nika_Sunchild",
                        "content": "This problem is problematic. And by that I mean SEXIST, holy cow."
                    },
                    {
                        "username": "Nabarun21",
                        "content": "No way this should be a medium problem. Compare this to Jump game II which is also medium."
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case you are not able to understand the problem\\nFor Bulls \\n1. If there is an element in secret and same element is available in guess, and the index of both is same then it\\'s a bull.\\nEx. Secret = 1123     >> 1 at index 1\\n      Guess = 0111     >> 1 at index 1\\n\\nFor Cows\\n2. If there is an element in secret and same element is available in guess but the index is different then it\\'ll be cow.\\nEx. Secret = 1123     >> 1 at index 0\\n      Guess = 0111     >> 1 at index 2\\n\\nNote: If there is 1 element in secret but there are 3 same element in guess, then it will be considered only 1.\\nEx 1: \\nSecret: \"1234\"\\nGuess:  0111\"\\nExpected:\\n\"0A1B\"\\n\\nthere is no element at which has same value and is same index.\\n1 is only one time in secret by three times in guess so we\\'ll only the first 1(at 1 index)\\n\\nEx 2: \\nSecret: \"1122\"\\nGuess:  \"2211\"\\nExpected:\\n\"0A4B\"\\n\\nBecause there is no element at same index so bull is 0.\\nthere are 2 1\\'s  and 2 2\\'s in both secret and guess so cows will be 4\\n\\nLet me know if you didn\\'t understand it."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be marked as an easy one."
                    },
                    {
                        "username": "smit_123",
                        "content": "class Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        int bullsCount = 0, cowsCount = 0;\\n        unordered_map<char,int>mp;\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bullsCount++;\\n                mp[secret[i]] -= 1;\\n            }\\n            mp[secret[i]]++;\\n        }\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] != guess[i])\\n            {\\n                if(mp[guess[i]] > 0)\\n                {\\n                    mp[guess[i]] -= 1;\\n                    cowsCount++;\\n                }\\n            }\\n        }\\n        return to_string(bullsCount) + \"A\" + to_string(cowsCount) + \"B\";\\n    }\\n};"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "It should be hard bcs it\\'s freaking impossible to understand the problem without reading the comments \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I feel stupid because I don\\'t understand what they ask me to do :)"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I can\\'t Understand the Question -> Only!"
                    },
                    {
                        "username": "hackkerguy11",
                        "content": "Has my problem solving skill been improved or this problem does not deserve to be at medium level ?"
                    },
                    {
                        "username": "eduard92",
                        "content": "The problem itself is not that hard to understand once you read the wiki page... The text in the problem makes sense only after you read the wiki page.\nThe testcases are trial and error which is annoying.. but if I solved it on my own, its an easy question, took me 40 min tho."
                    }
                ]
            },
            {
                "id": 1874398,
                "content": [
                    {
                        "username": "Nika_Sunchild",
                        "content": "This problem is problematic. And by that I mean SEXIST, holy cow."
                    },
                    {
                        "username": "Nabarun21",
                        "content": "No way this should be a medium problem. Compare this to Jump game II which is also medium."
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case you are not able to understand the problem\\nFor Bulls \\n1. If there is an element in secret and same element is available in guess, and the index of both is same then it\\'s a bull.\\nEx. Secret = 1123     >> 1 at index 1\\n      Guess = 0111     >> 1 at index 1\\n\\nFor Cows\\n2. If there is an element in secret and same element is available in guess but the index is different then it\\'ll be cow.\\nEx. Secret = 1123     >> 1 at index 0\\n      Guess = 0111     >> 1 at index 2\\n\\nNote: If there is 1 element in secret but there are 3 same element in guess, then it will be considered only 1.\\nEx 1: \\nSecret: \"1234\"\\nGuess:  0111\"\\nExpected:\\n\"0A1B\"\\n\\nthere is no element at which has same value and is same index.\\n1 is only one time in secret by three times in guess so we\\'ll only the first 1(at 1 index)\\n\\nEx 2: \\nSecret: \"1122\"\\nGuess:  \"2211\"\\nExpected:\\n\"0A4B\"\\n\\nBecause there is no element at same index so bull is 0.\\nthere are 2 1\\'s  and 2 2\\'s in both secret and guess so cows will be 4\\n\\nLet me know if you didn\\'t understand it."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be marked as an easy one."
                    },
                    {
                        "username": "smit_123",
                        "content": "class Solution {\\npublic:\\n    string getHint(string secret, string guess) {\\n        \\n        int bullsCount = 0, cowsCount = 0;\\n        unordered_map<char,int>mp;\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] == guess[i])\\n            {\\n                bullsCount++;\\n                mp[secret[i]] -= 1;\\n            }\\n            mp[secret[i]]++;\\n        }\\n        for(int i=0; i<secret.length(); i++)\\n        {\\n            if(secret[i] != guess[i])\\n            {\\n                if(mp[guess[i]] > 0)\\n                {\\n                    mp[guess[i]] -= 1;\\n                    cowsCount++;\\n                }\\n            }\\n        }\\n        return to_string(bullsCount) + \"A\" + to_string(cowsCount) + \"B\";\\n    }\\n};"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "It should be hard bcs it\\'s freaking impossible to understand the problem without reading the comments \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I feel stupid because I don\\'t understand what they ask me to do :)"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "I can\\'t Understand the Question -> Only!"
                    },
                    {
                        "username": "hackkerguy11",
                        "content": "Has my problem solving skill been improved or this problem does not deserve to be at medium level ?"
                    },
                    {
                        "username": "eduard92",
                        "content": "The problem itself is not that hard to understand once you read the wiki page... The text in the problem makes sense only after you read the wiki page.\nThe testcases are trial and error which is annoying.. but if I solved it on my own, its an easy question, took me 40 min tho."
                    }
                ]
            }
        ]
    },
    {
        "title": "Evaluate Division",
        "question_content": "<p>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> and <code>values[i]</code> represent the equation <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code>. Each <code>A<sub>i</sub></code> or <code>B<sub>i</sub></code> is a string that represents a single variable.</p>\n\n<p>You are also given some <code>queries</code>, where <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> represents the <code>j<sup>th</sup></code> query where you must find the answer for <code>C<sub>j</sub> / D<sub>j</sub> = ?</code>.</p>\n\n<p>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.</p>\n\n<p><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>\n\n<p><strong>Note:&nbsp;</strong>The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]\n<strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]\n<strong>Explanation:</strong> \nGiven: <em>a / b = 2.0</em>, <em>b / c = 3.0</em>\nqueries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ? </em>\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined =&gt; -1.0</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]\n<strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]\n<strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= equations.length &lt;= 20</code></li>\n\t<li><code>equations[i].length == 2</code></li>\n\t<li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>\n\t<li><code>values.length == equations.length</code></li>\n\t<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 20</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>\n\t<li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> consist of lower case English letters and digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1968813,
                "title": "c-dfs-solution-0-ms-100",
                "content": "```\\nclass Solution {\\npublic:\\nvoid dfs(string start,string end,map<string,double>& mp,map<string,vector<string>>& graph,double& val,map<string,int>& visited,bool& found){\\n        visited[start]=1;\\n    \\n        if(found==true)\\n            return ;\\n        for(auto child:graph[start]){\\n            if(visited[child]!=1){\\n                // cout<<start<<\" \"<<child<<\"\\\\n\";\\n                val*=mp[start+\"->\"+child];\\n                if(end==child){\\n                    // cout<<end<<\" -- \"<<child<<\"\\\\n\";\\n                    found=true;\\n                    return ;\\n                }\\n                dfs(child,end,mp,graph,val,visited,found);\\n                if(found==true){\\n                    return ;\\n                }\\n                else{\\n                    val/=mp[start+\"->\"+child];\\n                }\\n            }\\n        }\\n       \\n        \\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double> ans;\\n        map<string,double> mp;\\n        map<string,vector<string>> graph;\\n        for(int i=0;i<equations.size();i++){\\n            string u=equations[i][0];\\n            string v=equations[i][1];\\n            mp[u+\"->\"+v]=values[i];\\n            mp[v+\"->\"+u]=1/values[i];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            string start=queries[i][0];\\n            string end=queries[i][1];\\n            if(graph.find(start)==graph.end()||graph.find(end)==graph.end()){\\n                ans.push_back(-1);\\n            }\\n            else{\\n                // ans.push_back(1);\\n                double val=1;\\n                map<string,int> visited;\\n                bool found=false;\\n                if(start==end){\\n                    found=true;\\n                }\\n                else\\n                dfs(start,end,mp,graph,val,visited,found);\\n                if(found==true)\\n                ans.push_back(val);\\n                else\\n                    ans.push_back(-1);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(string start,string end,map<string,double>& mp,map<string,vector<string>>& graph,double& val,map<string,int>& visited,bool& found){\\n        visited[start]=1;\\n    \\n        if(found==true)\\n            return ;\\n        for(auto child:graph[start]){\\n            if(visited[child]!=1){\\n                // cout<<start<<\" \"<<child<<\"\\\\n\";\\n                val*=mp[start+\"->\"+child];\\n                if(end==child){\\n                    // cout<<end<<\" -- \"<<child<<\"\\\\n\";\\n                    found=true;\\n                    return ;\\n                }\\n                dfs(child,end,mp,graph,val,visited,found);\\n                if(found==true){\\n                    return ;\\n                }\\n                else{\\n                    val/=mp[start+\"->\"+child];\\n                }\\n            }\\n        }\\n       \\n        \\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double> ans;\\n        map<string,double> mp;\\n        map<string,vector<string>> graph;\\n        for(int i=0;i<equations.size();i++){\\n            string u=equations[i][0];\\n            string v=equations[i][1];\\n            mp[u+\"->\"+v]=values[i];\\n            mp[v+\"->\"+u]=1/values[i];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            string start=queries[i][0];\\n            string end=queries[i][1];\\n            if(graph.find(start)==graph.end()||graph.find(end)==graph.end()){\\n                ans.push_back(-1);\\n            }\\n            else{\\n                // ans.push_back(1);\\n                double val=1;\\n                map<string,int> visited;\\n                bool found=false;\\n                if(start==end){\\n                    found=true;\\n                }\\n                else\\n                dfs(start,end,mp,graph,val,visited,found);\\n                if(found==true)\\n                ans.push_back(val);\\n                else\\n                    ans.push_back(-1);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1992888,
                "title": "python3-dfs",
                "content": "Edit: zayne-siew has kindly provided an explanation for the bone-headed error I made and has provided a BFS implementation of the solution to this problem.\\nIf you have any questions, feel free to ask; I will try to answer in the best manner possible.\\nI hate to say this, but the only reason I took the reciprocal of the answer produced by the DFS (as seen in the second-to-last line before the return statement in `calcEquation`) is because I first tried the *actual* value itself, and I noticed the values coming out were the reciprocal values of the right answer, and it just came out all correct when I took the reciprocal.\\n```\\nclass Solution:\\n    \\n    def answer(self, current, end, scalar):\\n        if current==end: return scalar\\n        self.visited.add(current)\\n        if current in self.graph:\\n            for i in self.graph[current]:\\n                if i[0] not in self.visited:\\n                    a=self.answer(i[0],end,scalar*i[1])\\n                    if a!=-1: return a\\n        return -1\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        self.graph,self.visited={},set()\\n        for i in range(len(equations)):\\n            if equations[i][0] not in self.graph:\\n                self.graph[equations[i][0]]=[]\\n            if equations[i][1] not in self.graph:\\n                self.graph[equations[i][1]]=[]\\n            self.graph[equations[i][0]].append((equations[i][1],1/values[i]))\\n            self.graph[equations[i][1]].append((equations[i][0],values[i]))\\n        v=[]\\n        for i in queries:\\n            self.visited=set()\\n            if i[0] not in self.graph or i[1] not in self.graph:\\n                v.append(-1)\\n                continue\\n            v.append(1/self.answer(i[0],i[1],1) if i[0]!=i[1] else 1)\\n        return v\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def answer(self, current, end, scalar):\\n        if current==end: return scalar\\n        self.visited.add(current)\\n        if current in self.graph:\\n            for i in self.graph[current]:\\n                if i[0] not in self.visited:\\n                    a=self.answer(i[0],end,scalar*i[1])\\n                    if a!=-1: return a\\n        return -1\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        self.graph,self.visited={},set()\\n        for i in range(len(equations)):\\n            if equations[i][0] not in self.graph:\\n                self.graph[equations[i][0]]=[]\\n            if equations[i][1] not in self.graph:\\n                self.graph[equations[i][1]]=[]\\n            self.graph[equations[i][0]].append((equations[i][1],1/values[i]))\\n            self.graph[equations[i][1]].append((equations[i][0],values[i]))\\n        v=[]\\n        for i in queries:\\n            self.visited=set()\\n            if i[0] not in self.graph or i[1] not in self.graph:\\n                v.append(-1)\\n                continue\\n            v.append(1/self.answer(i[0],i[1],1) if i[0]!=i[1] else 1)\\n        return v\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981059,
                "title": "c-sol-100-faster-and-100-space-efficient",
                "content": "This problem is based on graphs , weights and strings:\\n* Map the strings to ids and create a disjoint set\\n* weights should be maintained for each pair of strings\\nI have used disjoint sets approach here.\\n\\n**Creating a disjoint set for strings:**\\nThis problem is designed with the strings. Disjoint sets use a root array and connected elements will point one element. For more info on disjoint sets please go through graphs section in explore area. \\nIn C language if we need to use disjoint set for strings, we should give an id for each string. So using an array of char * pointers *strs*  and *num_strs*  to save strings pointers and map each string to one id (starts from 0).  Basically mapping the strings to ids.\\nWhile going through equations, if it is a new string, we specify the an id else returned mapped id.\\nOnce strings are mapped to ids, disjoint sets can be created using find and union functions.\\n\\n**Weights:**\\n Main issue which we need to understand here is how to maintain weights (values[]) and how to calculate them. I have used 2D array to maintain these weights and initialised to 1s. If (s1, s2, w1) is given, get the mapped s1 and s2 ids and set wt[s1][s2] to w1 and wt[s2][s1] to 1/w1 . \\nWhen we do union of (s1, s2) , we update *root*, *rnk* and *wt* arrays.  While linking x, y through rx and ry , weights should be caluculated for wt[rx][ry] as *wt[rx][ry] = wt[rx][x]  wt[y][ry] wt[x][y]*; \\n\\n**Queries:**\\nThese queries consists of pair of strings. These strings may or may not exist in disjoint set. If not there in map set, just set the result as -1 and go for the next pair.\\nIf both the strings are matching with the map set, check if there is calculated weight value, else get the root values for these string mapped ids and calculate the weight.\\n\\n\\n```\\n#define MAX_ELEMENTS 40\\nint map_str(char* strs[MAX_ELEMENTS], char *s, int num){\\n    int ii;\\n    for (ii=0; ii<num; ii++){\\n        if (!strcmp(strs[ii],s))\\n            return ii+1;\\n    }\\n    return 0;\\n}\\n\\n\\nint findDJ (int *rt, double wt[][MAX_ELEMENTS], int x){\\n    int rx = rt[x];\\n    if (rx == x){\\n        return x;\\n    }\\n    rt[x] = findDJ(rt, wt, rx);\\n    if (rt[x] != rx) {\\n        wt[x][rt[x]] = wt[x][rx] * wt[rx][rt[x]];\\n        wt[rt[x]][x] = 1/(wt[x][rt[x]]);\\n//        printf(\"x %d rx %d, rt[x] %d, wt[x][rt[x]] %f, wt[x][rx] %f  wt[rx][rt[x]] %f \\\\n\", x, rx, rt[x], wt[x][rt[x]], wt[x][rx],  wt[rx][rt[x]]);\\n    }\\n    return (rt[x]);\\n}\\n\\nvoid unionDJ(int *rt, int *rnk, double wt[][MAX_ELEMENTS], double w, int x, int y){\\n    int rx, ry;\\n    rx = findDJ(rt, wt, x);\\n    ry = findDJ(rt, wt, y);\\n    wt[x][y] = w;\\n    wt[y][x] = 1/w;\\n    if (rx == ry) return;\\n\\t/* calculate the weight of wt[rx][ry] */\\n    wt[rx][ry] = wt[rx][x] * wt[y][ry] *wt[x][y];\\n    wt[ry][rx] = 1/(wt[rx][ry]);\\n    if (rnk[rx] > rnk[ry]){\\n        rt[ry] = rx;\\n    }else if (rnk[ry] > rnk[rx]){\\n        rt[rx] = ry;\\n    }else{\\n        rt[ry] = rx;\\n        rnk[rx] += 1;\\n    }\\n//    printf(\"x %d y %d rx %d, ry %d rt[rx] %d rt[ry] %d \", x, y, rx, ry, rt[rx], rt[ry]);\\n//    printf(\"wt[%d][%d] %f wt[%d][%d] %f wt[rx][x] %f , w %f\\\\n\", rx, ry, wt[rx][ry], ry, rx,wt[ry][rx],  wt[rx][x], w);\\n    return;\\n}\\n\\ndouble* calcEquation(char *** equations, int equationsSize, int* equationsColSize, double* values, int valuesSize, char *** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    int num_strs=0;\\n    char *strs[MAX_ELEMENTS];\\n    int rt[MAX_ELEMENTS];\\n    char *s;\\n    int map_id1, map_id2;\\n    double wt[MAX_ELEMENTS][MAX_ELEMENTS];\\n    {\\n        int rnk[MAX_ELEMENTS];\\n        for (int ii=0; ii< MAX_ELEMENTS; ii++){\\n                for (int jj=0; jj< MAX_ELEMENTS; jj++)\\n                    wt[ii][jj] = 1.0;\\n                rt[ii]  =ii;\\n                rnk[ii] = 1;\\n        }\\n        for (int ii=0; ii< equationsSize; ii++){\\n            /* get each string and mapped id of string*/\\n            s =  equations[ii][0];\\n            if (!(map_id1 = map_str(strs, s, num_strs))){\\n                strs[num_strs] = s;\\n                map_id1 = num_strs;\\n                num_strs++;\\n            }else  map_id1--;\\n            s =  equations[ii][1];\\n            if (!(map_id2 = map_str(strs, s, num_strs))){\\n                strs[num_strs] = s;\\n                map_id2 = num_strs;\\n                num_strs++;\\n            }else map_id2--;\\n    //        printf(\" id1 %d, y %s  snum %d id2 %d num_strs %d\\\\n\", map_id1, s, snum,map_id2, num_strs);\\n\\t\\n\\t\\t\\t/* link these vertices and calculate the corresponding weights */\\n            unionDJ(rt, rnk, wt, values[ii], map_id1, map_id2);\\n        }\\n    }\\n\\t\\n\\t/* allocation for output */\\n    double *res = (double *) malloc(sizeof(double) * queriesSize);\\n\\n    for (int ii=0; ii<queriesSize; ii++){\\n\\t    /* get the mapped id strings, if not there set result as -1 */\\n        s = queries[ii][0];\\n        if (!(map_id1 = map_str(strs, s, num_strs))){\\n            res[ii] = -1;\\n            continue;\\n        }else map_id1--;\\n        s = queries[ii][1];\\n        if (!(map_id2 = map_str(strs, s, num_strs))){\\n            res[ii] = -1;\\n            continue;\\n        }else map_id2--;\\n\\t\\t\\n\\t\\t/* if query has same strings as \"a\"/\"a\", set to 1 */\\n        if (map_id1 == map_id2){\\n            res[ii] = 1;\\n        }\\n//    printf(\"qii %d , x %s id1 %d, y %s, id2 %d, wt %f\\\\n\",ii,queries[ii][0], map_id1, queries[ii][1], map_id2,  wt[map_id1][map_id2] );\\n        /* While doing union some weights gets calculated ,\\n\\t\\t   eg, (a, b, w1), (b, c, w2), (c, d, w3) ==>\\n\\t\\t   weigths corresponding to a,b ; b,c; a,c; c,d;a,d gets calculated in unionDJ func */\\n        else if (wt[map_id1][map_id2] != 1.0)\\n            res[ii] = wt[map_id1][map_id2];\\n        else {\\n\\t\\t\\t/* there are cases where some weights will not be calculated \\n\\t\\t   eg, (a, b, w1), (b, c, w2), (c, d, w3) ==>\\n\\t\\t   weigths corresponding to b,d will not get caluculated.\\n\\t\\t    so check if these are linked and update weights*/\\n            int rx =  findDJ(rt, wt, map_id1);\\n            int ry = findDJ (rt, wt, map_id2);\\n            if (rx == ry){\\n                res[ii] = wt[map_id1][rx] * wt[rx][map_id2];\\n            } else\\n                res[ii] = -1.0;\\n        }\\n    }\\n    *returnSize = queriesSize;\\n    return res;\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX_ELEMENTS 40\\nint map_str(char* strs[MAX_ELEMENTS], char *s, int num){\\n    int ii;\\n    for (ii=0; ii<num; ii++){\\n        if (!strcmp(strs[ii],s))\\n            return ii+1;\\n    }\\n    return 0;\\n}\\n\\n\\nint findDJ (int *rt, double wt[][MAX_ELEMENTS], int x){\\n    int rx = rt[x];\\n    if (rx == x){\\n        return x;\\n    }\\n    rt[x] = findDJ(rt, wt, rx);\\n    if (rt[x] != rx) {\\n        wt[x][rt[x]] = wt[x][rx] * wt[rx][rt[x]];\\n        wt[rt[x]][x] = 1/(wt[x][rt[x]]);\\n//        printf(\"x %d rx %d, rt[x] %d, wt[x][rt[x]] %f, wt[x][rx] %f  wt[rx][rt[x]] %f \\\\n\", x, rx, rt[x], wt[x][rt[x]], wt[x][rx],  wt[rx][rt[x]]);\\n    }\\n    return (rt[x]);\\n}\\n\\nvoid unionDJ(int *rt, int *rnk, double wt[][MAX_ELEMENTS], double w, int x, int y){\\n    int rx, ry;\\n    rx = findDJ(rt, wt, x);\\n    ry = findDJ(rt, wt, y);\\n    wt[x][y] = w;\\n    wt[y][x] = 1/w;\\n    if (rx == ry) return;\\n\\t/* calculate the weight of wt[rx][ry] */\\n    wt[rx][ry] = wt[rx][x] * wt[y][ry] *wt[x][y];\\n    wt[ry][rx] = 1/(wt[rx][ry]);\\n    if (rnk[rx] > rnk[ry]){\\n        rt[ry] = rx;\\n    }else if (rnk[ry] > rnk[rx]){\\n        rt[rx] = ry;\\n    }else{\\n        rt[ry] = rx;\\n        rnk[rx] += 1;\\n    }\\n//    printf(\"x %d y %d rx %d, ry %d rt[rx] %d rt[ry] %d \", x, y, rx, ry, rt[rx], rt[ry]);\\n//    printf(\"wt[%d][%d] %f wt[%d][%d] %f wt[rx][x] %f , w %f\\\\n\", rx, ry, wt[rx][ry], ry, rx,wt[ry][rx],  wt[rx][x], w);\\n    return;\\n}\\n\\ndouble* calcEquation(char *** equations, int equationsSize, int* equationsColSize, double* values, int valuesSize, char *** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    int num_strs=0;\\n    char *strs[MAX_ELEMENTS];\\n    int rt[MAX_ELEMENTS];\\n    char *s;\\n    int map_id1, map_id2;\\n    double wt[MAX_ELEMENTS][MAX_ELEMENTS];\\n    {\\n        int rnk[MAX_ELEMENTS];\\n        for (int ii=0; ii< MAX_ELEMENTS; ii++){\\n                for (int jj=0; jj< MAX_ELEMENTS; jj++)\\n                    wt[ii][jj] = 1.0;\\n                rt[ii]  =ii;\\n                rnk[ii] = 1;\\n        }\\n        for (int ii=0; ii< equationsSize; ii++){\\n            /* get each string and mapped id of string*/\\n            s =  equations[ii][0];\\n            if (!(map_id1 = map_str(strs, s, num_strs))){\\n                strs[num_strs] = s;\\n                map_id1 = num_strs;\\n                num_strs++;\\n            }else  map_id1--;\\n            s =  equations[ii][1];\\n            if (!(map_id2 = map_str(strs, s, num_strs))){\\n                strs[num_strs] = s;\\n                map_id2 = num_strs;\\n                num_strs++;\\n            }else map_id2--;\\n    //        printf(\" id1 %d, y %s  snum %d id2 %d num_strs %d\\\\n\", map_id1, s, snum,map_id2, num_strs);\\n\\t\\n\\t\\t\\t/* link these vertices and calculate the corresponding weights */\\n            unionDJ(rt, rnk, wt, values[ii], map_id1, map_id2);\\n        }\\n    }\\n\\t\\n\\t/* allocation for output */\\n    double *res = (double *) malloc(sizeof(double) * queriesSize);\\n\\n    for (int ii=0; ii<queriesSize; ii++){\\n\\t    /* get the mapped id strings, if not there set result as -1 */\\n        s = queries[ii][0];\\n        if (!(map_id1 = map_str(strs, s, num_strs))){\\n            res[ii] = -1;\\n            continue;\\n        }else map_id1--;\\n        s = queries[ii][1];\\n        if (!(map_id2 = map_str(strs, s, num_strs))){\\n            res[ii] = -1;\\n            continue;\\n        }else map_id2--;\\n\\t\\t\\n\\t\\t/* if query has same strings as \"a\"/\"a\", set to 1 */\\n        if (map_id1 == map_id2){\\n            res[ii] = 1;\\n        }\\n//    printf(\"qii %d , x %s id1 %d, y %s, id2 %d, wt %f\\\\n\",ii,queries[ii][0], map_id1, queries[ii][1], map_id2,  wt[map_id1][map_id2] );\\n        /* While doing union some weights gets calculated ,\\n\\t\\t   eg, (a, b, w1), (b, c, w2), (c, d, w3) ==>\\n\\t\\t   weigths corresponding to a,b ; b,c; a,c; c,d;a,d gets calculated in unionDJ func */\\n        else if (wt[map_id1][map_id2] != 1.0)\\n            res[ii] = wt[map_id1][map_id2];\\n        else {\\n\\t\\t\\t/* there are cases where some weights will not be calculated \\n\\t\\t   eg, (a, b, w1), (b, c, w2), (c, d, w3) ==>\\n\\t\\t   weigths corresponding to b,d will not get caluculated.\\n\\t\\t    so check if these are linked and update weights*/\\n            int rx =  findDJ(rt, wt, map_id1);\\n            int ry = findDJ (rt, wt, map_id2);\\n            if (rx == ry){\\n                res[ii] = wt[map_id1][rx] * wt[rx][map_id2];\\n            } else\\n                res[ii] = -1.0;\\n        }\\n    }\\n    *returnSize = queriesSize;\\n    return res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 171649,
                "title": "1ms-dfs-with-explanations",
                "content": "**Binary** relationship is represented as a **graph** usually.\\nDoes the **direction** of an edge matters? -- Yes. Take a / b = 2 for example, it indicates `a --2--> b` as well as `b --1/2--> a`. \\nThus, it is a **directed weighted graph**.\\nIn this graph, how do we evaluate division?\\nTake a / b = 2, b / c = 3, a / c = ? for example,\\n```\\na --2--> b --3--> c\\n```\\nWe simply find a path using DFS from node `a` to node `c` and multiply the weights of edges passed, i.e. `2 * 3 = 6`.\\n\\nPlease note that during **DFS**, \\n* Rejection case should be checked before accepting case.\\n* Accepting case is `(graph.get(u).containsKey(v))` rather than `(u.equals(v))` for it takes O(1)  but `(u.equals(v))` takes O(n) for n is the length of the longer one between u and v.\\n****\\n```\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        \\n        /* Build graph. */\\n        Map<String, Map<String, Double>> graph = buildGraph(equations, values);\\n        double[] result = new double[queries.length];\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            result[i] = getPathWeight(queries[i][0], queries[i][1], new HashSet<>(), graph);\\n        }  \\n        \\n        return result;\\n    }\\n    \\n    private double getPathWeight(String start, String end, Set<String> visited, Map<String, Map<String, Double>> graph) {\\n        \\n        /* Rejection case. */\\n        if (!graph.containsKey(start)) \\n            return -1.0;\\n        \\n        /* Accepting case. */\\n        if (graph.get(start).containsKey(end))\\n            return graph.get(start).get(end);\\n        \\n        visited.add(start);\\n        for (Map.Entry<String, Double> neighbour : graph.get(start).entrySet()) {\\n            if (!visited.contains(neighbour.getKey())) {\\n                double productWeight = getPathWeight(neighbour.getKey(), end, visited, graph);\\n                if (productWeight != -1.0)\\n                    return neighbour.getValue() * productWeight;\\n            }\\n        }\\n        \\n        return -1.0;\\n    }\\n    \\n    private Map<String, Map<String, Double>> buildGraph(String[][] equations, double[] values) {\\n        Map<String, Map<String, Double>> graph = new HashMap<>();\\n        String u, v;\\n        \\n        for (int i = 0; i < equations.length; i++) {\\n            u = equations[i][0];\\n            v = equations[i][1];\\n            graph.putIfAbsent(u, new HashMap<>());\\n            graph.get(u).put(v, values[i]);\\n            graph.putIfAbsent(v, new HashMap<>());\\n            graph.get(v).put(u, 1 / values[i]);\\n        }\\n        \\n        return graph;\\n    }\\n```\\n**(\\uFF89>\\u03C9<)\\uFF89 Vote up, please!**",
                "solutionTags": [],
                "code": "```\\na --2--> b --3--> c\\n```\n```\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        \\n        /* Build graph. */\\n        Map<String, Map<String, Double>> graph = buildGraph(equations, values);\\n        double[] result = new double[queries.length];\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            result[i] = getPathWeight(queries[i][0], queries[i][1], new HashSet<>(), graph);\\n        }  \\n        \\n        return result;\\n    }\\n    \\n    private double getPathWeight(String start, String end, Set<String> visited, Map<String, Map<String, Double>> graph) {\\n        \\n        /* Rejection case. */\\n        if (!graph.containsKey(start)) \\n            return -1.0;\\n        \\n        /* Accepting case. */\\n        if (graph.get(start).containsKey(end))\\n            return graph.get(start).get(end);\\n        \\n        visited.add(start);\\n        for (Map.Entry<String, Double> neighbour : graph.get(start).entrySet()) {\\n            if (!visited.contains(neighbour.getKey())) {\\n                double productWeight = getPathWeight(neighbour.getKey(), end, visited, graph);\\n                if (productWeight != -1.0)\\n                    return neighbour.getValue() * productWeight;\\n            }\\n        }\\n        \\n        return -1.0;\\n    }\\n    \\n    private Map<String, Map<String, Double>> buildGraph(String[][] equations, double[] values) {\\n        Map<String, Map<String, Double>> graph = new HashMap<>();\\n        String u, v;\\n        \\n        for (int i = 0; i < equations.length; i++) {\\n            u = equations[i][0];\\n            v = equations[i][1];\\n            graph.putIfAbsent(u, new HashMap<>());\\n            graph.get(u).put(v, values[i]);\\n            graph.putIfAbsent(v, new HashMap<>());\\n            graph.get(v).put(u, 1 / values[i]);\\n        }\\n        \\n        return graph;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88275,
                "title": "python-fast-bfs-solution-with-detailed-explantion",
                "content": "Although this looks like a math problem, we can easily model it with graph.\\n\\nFor example:\\nGiven:\\na/b = 2.0, b/c = 3.0\\nWe can build a directed graph:\\na -- 2.0 --> b -- 3.0 --> c\\nIf we were asked to find a/c, we have:\\na/c = a/b * b/c = 2.0 * 3.0\\nIn the graph, it is the product of costs of edges.\\n\\nDo notice that, 2 edges need to added into the graph with one given equation,\\nbecause with a/b we also get result of b/a, which is the reciprocal of a/b.\\n\\nso the previous example also gives edges:\\nc -- 0.333 --> b -- 0.5 --> a\\n\\nNow we know how to model this problem, what we need to do is simply build the\\ngraph with given equations, and traverse the graph, either DFS or BFS, to find a path\\nfor a given query, and the result is the product of costs of edges on the path.\\n\\nOne optimization, which is not implemented in the code, is to \"compress\" paths for\\npast queries, which will make future searches faster. This is the same idea used in\\ncompressing paths in union find set. So after a query is conducted and a result is found,\\nwe add two edges for this query if these edges are not already in the graph.\\n\\nGiven the number of variables N, and number of equations E,\\nbuilding the graph takes O(E), each query takes O(N), space for graph takes O(E)\\n\\nI think if we start to compress paths, the graph will grow to O(N^2), and we\\ncan optimize the query to O(1), please correct me if I'm wrong.\\n\\n```\\nclass Solution(object):\\n    def calcEquation(self, equations, values, queries):\\n\\n        graph = {}\\n        \\n        def build_graph(equations, values):\\n            def add_edge(f, t, value):\\n                if f in graph:\\n                    graph[f].append((t, value))\\n                else:\\n                    graph[f] = [(t, value)]\\n            \\n            for vertices, value in zip(equations, values):\\n                f, t = vertices\\n                add_edge(f, t, value)\\n                add_edge(t, f, 1/value)\\n        \\n        def find_path(query):\\n            b, e = query\\n            \\n            if b not in graph or e not in graph:\\n                return -1.0\\n                \\n            q = collections.deque([(b, 1.0)])\\n            visited = set()\\n            \\n            while q:\\n                front, cur_product = q.popleft()\\n                if front == e:\\n                    return cur_product\\n                visited.add(front)\\n                for neighbor, value in graph[front]:\\n                    if neighbor not in visited:\\n                        q.append((neighbor, cur_product*value))\\n            \\n            return -1.0\\n        \\n        build_graph(equations, values)\\n        return [find_path(q) for q in queries]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def calcEquation(self, equations, values, queries):\\n\\n        graph = {}\\n        \\n        def build_graph(equations, values):\\n            def add_edge(f, t, value):\\n                if f in graph:\\n                    graph[f].append((t, value))\\n                else:\\n                    graph[f] = [(t, value)]\\n            \\n            for vertices, value in zip(equations, values):\\n                f, t = vertices\\n                add_edge(f, t, value)\\n                add_edge(t, f, 1/value)\\n        \\n        def find_path(query):\\n            b, e = query\\n            \\n            if b not in graph or e not in graph:\\n                return -1.0\\n                \\n            q = collections.deque([(b, 1.0)])\\n            visited = set()\\n            \\n            while q:\\n                front, cur_product = q.popleft()\\n                if front == e:\\n                    return cur_product\\n                visited.add(front)\\n                for neighbor, value in graph[front]:\\n                    if neighbor not in visited:\\n                        q.append((neighbor, cur_product*value))\\n            \\n            return -1.0\\n        \\n        build_graph(equations, values)\\n        return [find_path(q) for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88175,
                "title": "9-lines-floyd-u2013warshall-in-python",
                "content": "A variation of [**Floyd\\u2013Warshall**](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm), computing quotients instead of shortest paths. An equation `A/B=k` is like a graph edge `A->B`, and `(A/B)*(B/C)*(C/D)` is like the path `A->B->C->D`. Submitted once, accepted in 35 ms.\\n\\n    def calcEquation(self, equations, values, queries):\\n        quot = collections.defaultdict(dict)\\n        for (num, den), val in zip(equations, values):\\n            quot[num][num] = quot[den][den] = 1.0\\n            quot[num][den] = val\\n            quot[den][num] = 1 / val\\n        for k, i, j in itertools.permutations(quot, 3):\\n            if k in quot[i] and j in quot[k]:\\n                quot[i][j] = quot[i][k] * quot[k][j]\\n        return [quot[num].get(den, -1.0) for num, den in queries]\\n\\n<br>\\n\\nVariation without the `if` (submitted twice, accepted in 68 and 39 ms):\\n\\n    def calcEquation(self, equations, values, queries):\\n        quot = collections.defaultdict(dict)\\n        for (num, den), val in zip(equations, values):\\n            quot[num][num] = quot[den][den] = 1.0\\n            quot[num][den] = val\\n            quot[den][num] = 1 / val\\n        for k in quot:\\n            for i in quot[k]:\\n                for j in quot[k]:\\n                    quot[i][j] = quot[i][k] * quot[k][j]\\n        return [quot[num].get(den, -1.0) for num, den in queries]\\n\\nCould save a line with `for i, j in itertools.permutations(quot[k], 2)` but it's longer and I don't like it as much here.",
                "solutionTags": [],
                "code": "A variation of [**Floyd\\u2013Warshall**](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm), computing quotients instead of shortest paths. An equation `A/B=k` is like a graph edge `A->B`, and `(A/B)*(B/C)*(C/D)` is like the path `A->B->C->D`. Submitted once, accepted in 35 ms.\\n\\n    def calcEquation(self, equations, values, queries):\\n        quot = collections.defaultdict(dict)\\n        for (num, den), val in zip(equations, values):\\n            quot[num][num] = quot[den][den] = 1.0\\n            quot[num][den] = val\\n            quot[den][num] = 1 / val\\n        for k, i, j in itertools.permutations(quot, 3):\\n            if k in quot[i] and j in quot[k]:\\n                quot[i][j] = quot[i][k] * quot[k][j]\\n        return [quot[num].get(den, -1.0) for num, den in queries]\\n\\n<br>\\n\\nVariation without the `if` (submitted twice, accepted in 68 and 39 ms):\\n\\n    def calcEquation(self, equations, values, queries):\\n        quot = collections.defaultdict(dict)\\n        for (num, den), val in zip(equations, values):\\n            quot[num][num] = quot[den][den] = 1.0\\n            quot[num][den] = val\\n            quot[den][num] = 1 / val\\n        for k in quot:\\n            for i in quot[k]:\\n                for j in quot[k]:\\n                    quot[i][j] = quot[i][k] * quot[k][j]\\n        return [quot[num].get(den, -1.0) for num, den in queries]\\n\\nCould save a line with `for i, j in itertools.permutations(quot[k], 2)` but it's longer and I don't like it as much here.",
                "codeTag": "Python3"
            },
            {
                "id": 88169,
                "title": "java-ac-solution-using-graph",
                "content": "Image a/b = k as a link between node a and b, the weight from a to b is k, the reverse link  is 1/k. Query is to find a path between two nodes.\\n```\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        HashMap<String, ArrayList<String>> pairs = new HashMap<String, ArrayList<String>>();\\n        HashMap<String, ArrayList<Double>> valuesPair = new HashMap<String, ArrayList<Double>>();\\n        for (int i = 0; i < equations.length; i++) {\\n            String[] equation = equations[i];\\n            if (!pairs.containsKey(equation[0])) {\\n                pairs.put(equation[0], new ArrayList<String>());\\n                valuesPair.put(equation[0], new ArrayList<Double>());\\n            }\\n            if (!pairs.containsKey(equation[1])) {\\n                pairs.put(equation[1], new ArrayList<String>());\\n                valuesPair.put(equation[1], new ArrayList<Double>());\\n            }\\n            pairs.get(equation[0]).add(equation[1]);\\n            pairs.get(equation[1]).add(equation[0]);\\n            valuesPair.get(equation[0]).add(values[i]);\\n            valuesPair.get(equation[1]).add(1/values[i]);\\n        }\\n        \\n        double[] result = new double[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            String[] query = queries[i];\\n            result[i] = dfs(query[0], query[1], pairs, valuesPair, new HashSet<String>(), 1.0);\\n            if (result[i] == 0.0) result[i] = -1.0;\\n        }\\n        return result;\\n    }\\n    \\n    private double dfs(String start, String end, HashMap<String, ArrayList<String>> pairs, HashMap<String, ArrayList<Double>> values, HashSet<String> set, double value) {\\n        if (set.contains(start)) return 0.0;\\n        if (!pairs.containsKey(start)) return 0.0;\\n        if (start.equals(end)) return value;\\n        set.add(start);\\n        \\n        ArrayList<String> strList = pairs.get(start);\\n        ArrayList<Double> valueList = values.get(start);\\n        double tmp = 0.0;\\n        for (int i = 0; i < strList.size(); i++) {\\n            tmp = dfs(strList.get(i), end, pairs, values, set, value*valueList.get(i));\\n            if (tmp != 0.0) {\\n                break;\\n            }\\n        }\\n        set.remove(start);\\n        return tmp;\\n    }",
                "solutionTags": [],
                "code": "Image a/b = k as a link between node a and b, the weight from a to b is k, the reverse link  is 1/k. Query is to find a path between two nodes.\\n```\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        HashMap<String, ArrayList<String>> pairs = new HashMap<String, ArrayList<String>>();\\n        HashMap<String, ArrayList<Double>> valuesPair = new HashMap<String, ArrayList<Double>>();\\n        for (int i = 0; i < equations.length; i++) {\\n            String[] equation = equations[i];\\n            if (!pairs.containsKey(equation[0])) {\\n                pairs.put(equation[0], new ArrayList<String>());\\n                valuesPair.put(equation[0], new ArrayList<Double>());\\n            }\\n            if (!pairs.containsKey(equation[1])) {\\n                pairs.put(equation[1], new ArrayList<String>());\\n                valuesPair.put(equation[1], new ArrayList<Double>());\\n            }\\n            pairs.get(equation[0]).add(equation[1]);\\n            pairs.get(equation[1]).add(equation[0]);\\n            valuesPair.get(equation[0]).add(values[i]);\\n            valuesPair.get(equation[1]).add(1/values[i]);\\n        }\\n        \\n        double[] result = new double[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            String[] query = queries[i];\\n            result[i] = dfs(query[0], query[1], pairs, valuesPair, new HashSet<String>(), 1.0);\\n            if (result[i] == 0.0) result[i] = -1.0;\\n        }\\n        return result;\\n    }\\n    \\n    private double dfs(String start, String end, HashMap<String, ArrayList<String>> pairs, HashMap<String, ArrayList<Double>> values, HashSet<String> set, double value) {\\n        if (set.contains(start)) return 0.0;\\n        if (!pairs.containsKey(start)) return 0.0;\\n        if (start.equals(end)) return value;\\n        set.add(start);\\n        \\n        ArrayList<String> strList = pairs.get(start);\\n        ArrayList<Double> valueList = values.get(start);\\n        double tmp = 0.0;\\n        for (int i = 0; i < strList.size(); i++) {\\n            tmp = dfs(strList.get(i), end, pairs, values, set, value*valueList.get(i));\\n            if (tmp != 0.0) {\\n                break;\\n            }\\n        }\\n        set.remove(start);\\n        return tmp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1993050,
                "title": "c-graph-dfs-easy-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/759de4ba-7588-4bd6-a2c6-918d36239324_1651291331.1632457.jpeg)\\n\\n* Make a directed graph.\\n* If there is a/b = 2, then edge a->b has weight = 2 and edge b->a has weight 0.5.\\n* After forming a weighted directed graph process each query trying to find a path between startNode and endNode.\\n* If path found, running product kept during DFS will be your answer.\\n* ***TC = O(VQ), where V = Vertices on your graph and Q = No. of queries.***\\n\\n```\\nclass Solution {\\n    unordered_map<string, vector<pair<string, double>>> adjList;\\n    unordered_map<string, bool> visited;\\n    double queryAns;\\npublic:\\n    \\n    bool dfs(string startNode, string endNode, double runningProduct){\\n        \\n        if(startNode == endNode and adjList.find(startNode)!=adjList.end()) {\\n            queryAns = runningProduct;\\n            return true;\\n            \\n        }\\n        \\n        bool tempAns = false;\\n        visited[startNode] = true;\\n        \\n        for(int i = 0; i < adjList[startNode].size(); i++){\\n            if(!visited[adjList[startNode][i].first]){\\n                tempAns = dfs(adjList[startNode][i].first, endNode, runningProduct*adjList[startNode][i].second);\\n                if(tempAns){\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        visited[startNode] = false;\\n        \\n        return tempAns;\\n        \\n    }\\n    \\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        \\n        int n = equations.size(), m = queries.size();\\n        vector<double> ans(m);\\n        \\n        for(int i = 0; i < n ; i++){\\n            \\n            adjList[equations[i][0]].push_back({equations[i][1], values[i]});\\n            adjList[equations[i][1]].push_back({equations[i][0], 1/values[i]});\\n            visited[equations[i][0]] = false;\\n            visited[equations[i][1]] = false;\\n\\n        }\\n        \\n        for(int i = 0; i < m ; i++){\\n            \\n            queryAns = 1;\\n            bool pathFound = dfs(queries[i][0], queries[i][1], 1);            \\n            if(pathFound) ans[i] = queryAns;\\n            else ans[i] = -1;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string, vector<pair<string, double>>> adjList;\\n    unordered_map<string, bool> visited;\\n    double queryAns;\\npublic:\\n    \\n    bool dfs(string startNode, string endNode, double runningProduct){\\n        \\n        if(startNode == endNode and adjList.find(startNode)!=adjList.end()) {\\n            queryAns = runningProduct;\\n            return true;\\n            \\n        }\\n        \\n        bool tempAns = false;\\n        visited[startNode] = true;\\n        \\n        for(int i = 0; i < adjList[startNode].size(); i++){\\n            if(!visited[adjList[startNode][i].first]){\\n                tempAns = dfs(adjList[startNode][i].first, endNode, runningProduct*adjList[startNode][i].second);\\n                if(tempAns){\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        visited[startNode] = false;\\n        \\n        return tempAns;\\n        \\n    }\\n    \\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        \\n        int n = equations.size(), m = queries.size();\\n        vector<double> ans(m);\\n        \\n        for(int i = 0; i < n ; i++){\\n            \\n            adjList[equations[i][0]].push_back({equations[i][1], values[i]});\\n            adjList[equations[i][1]].push_back({equations[i][0], 1/values[i]});\\n            visited[equations[i][0]] = false;\\n            visited[equations[i][1]] = false;\\n\\n        }\\n        \\n        for(int i = 0; i < m ; i++){\\n            \\n            queryAns = 1;\\n            bool pathFound = dfs(queries[i][0], queries[i][1], 1);            \\n            if(pathFound) ans[i] = queryAns;\\n            else ans[i] = -1;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147281,
                "title": "java-union-find-solution-faster-than-99",
                "content": "1. a / b = 2.0 \\n==> b is the parent of a and map.put(a, 2.0)\\n==> a = root.get(a) * map.get(a);\\n\"root\" restores the parent of the node; \"map\" restores factor. The formula is \"node = parent * factor\"\\nFor example, \"x / y = 2.0\". Here, y is the parent of x; and the factor is 2.0.\\nIf we also have \"y / z = 3.0\", which means that z is the final parent of x due to path compression; and the factor turns out to be 6.0.\\n\\n2. When we find the parent of the string,  we also accumulately multiply the factors\\n```\\n/**\\n    1. Thoughts\\n        - check if we have enough info to get the result\\n        - if yes, calculate; if not, return -1.0\\n        - Method: union find\\n            - a/b = 2.0 --> b is the root of a; the distance from a to b is 1/2.0\\n            - if two nums have the same root, we can get the result; a/b=2.0, b/c=3.0\\n            index   a   b   c\\n            root    b   c   c \\n            dist    2   3   1\\n            - if we want to know a/c = ?: a = 2 * b = 2 * 3 * c => a/c = 6.0\\n    2. Corner case\\n        - if any input is null, return null\\n        - no enough info, return -1.0\\n    3. Steps\\n        - go through equations to union elements with the same root and update root map and distance map\\n        - go through each query: check if has the same root; find relative dist\\n*/\\nclass Solution {\\n    public double[] calcEquation(String[][] e, double[] values, String[][] q) {\\n        double[] res = new double[q.length];\\n        Map<String, String> root = new HashMap<>();\\n        Map<String, Double> dist = new HashMap<>();\\n        for (int i = 0; i < e.length; i++) {\\n            String r1 = find(root, dist, e[i][0]);\\n            String r2 = find(root, dist, e[i][1]);\\n            root.put(r1, r2);\\n            dist.put(r1, dist.get(e[i][1]) * values[i] / dist.get(e[i][0]));\\n        }\\n        for (int i = 0; i < q.length; i++) {\\n            if (!root.containsKey(q[i][0]) || !root.containsKey(q[i][1])) {\\n                res[i] = -1.0;\\n                continue;\\n            }\\n            String r1 = find(root, dist, q[i][0]);\\n            String r2 = find(root, dist, q[i][1]);\\n            if (!r1.equals(r2)) {\\n                res[i] = -1.0;\\n                continue;\\n            }\\n            res[i] = (double) dist.get(q[i][0]) / dist.get(q[i][1]);\\n        }\\n        return res;\\n    }\\n    \\n    private String find(Map<String, String> root, Map<String, Double> dist, String s) {\\n        if (!root.containsKey(s)) {\\n            root.put(s, s);\\n            dist.put(s, 1.0);\\n            return s;\\n        }\\n        if (root.get(s).equals(s)) return s;\\n        String lastP = root.get(s);\\n        String p = find(root, dist, lastP);\\n        root.put(s, p);\\n        dist.put(s, dist.get(s) * dist.get(lastP));\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n    1. Thoughts\\n        - check if we have enough info to get the result\\n        - if yes, calculate; if not, return -1.0\\n        - Method: union find\\n            - a/b = 2.0 --> b is the root of a; the distance from a to b is 1/2.0\\n            - if two nums have the same root, we can get the result; a/b=2.0, b/c=3.0\\n            index   a   b   c\\n            root    b   c   c \\n            dist    2   3   1\\n            - if we want to know a/c = ?: a = 2 * b = 2 * 3 * c => a/c = 6.0\\n    2. Corner case\\n        - if any input is null, return null\\n        - no enough info, return -1.0\\n    3. Steps\\n        - go through equations to union elements with the same root and update root map and distance map\\n        - go through each query: check if has the same root; find relative dist\\n*/\\nclass Solution {\\n    public double[] calcEquation(String[][] e, double[] values, String[][] q) {\\n        double[] res = new double[q.length];\\n        Map<String, String> root = new HashMap<>();\\n        Map<String, Double> dist = new HashMap<>();\\n        for (int i = 0; i < e.length; i++) {\\n            String r1 = find(root, dist, e[i][0]);\\n            String r2 = find(root, dist, e[i][1]);\\n            root.put(r1, r2);\\n            dist.put(r1, dist.get(e[i][1]) * values[i] / dist.get(e[i][0]));\\n        }\\n        for (int i = 0; i < q.length; i++) {\\n            if (!root.containsKey(q[i][0]) || !root.containsKey(q[i][1])) {\\n                res[i] = -1.0;\\n                continue;\\n            }\\n            String r1 = find(root, dist, q[i][0]);\\n            String r2 = find(root, dist, q[i][1]);\\n            if (!r1.equals(r2)) {\\n                res[i] = -1.0;\\n                continue;\\n            }\\n            res[i] = (double) dist.get(q[i][0]) / dist.get(q[i][1]);\\n        }\\n        return res;\\n    }\\n    \\n    private String find(Map<String, String> root, Map<String, Double> dist, String s) {\\n        if (!root.containsKey(s)) {\\n            root.put(s, s);\\n            dist.put(s, 1.0);\\n            return s;\\n        }\\n        if (root.get(s).equals(s)) return s;\\n        String lastP = root.get(s);\\n        String p = find(root, dist, lastP);\\n        root.put(s, p);\\n        dist.put(s, dist.get(s) * dist.get(lastP));\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270993,
                "title": "python-bfs-uf-detailed-explanation",
                "content": "We can treat each equation as an edge, variables as nodes and value as weight, and build a weighted graph. Then for each queries `(x, y)`, we try to find a path from `x` to `y`. The answer is the product of all edges\\' weights. If either `x` or `y` is not in graph or `x` and `y` are not connected in graph, the answer doesn\\'t exist.\\nWe can use a `defaultdict(dict) G` to build a weighted graph and `G[x][y]` will be the weight of edge `x->y` which is the value of `x / y`\\n\\nSo one solution is BFS (or DFS) for each query.\\n```\\ndef calcEquation(equations, values, queries):\\n\\tG = collections.defaultdict(dict)\\n\\tfor (x, y), v in zip(equations, values):\\n\\t\\tG[x][y] = v\\n\\t\\tG[y][x] = 1/v\\n\\tdef bfs(src, dst):\\n\\t\\tif not (src in G and dst in G): return -1.0\\n\\t\\tq, seen = [(src, 1.0)], set()\\n\\t\\tfor x, v in q:\\n\\t\\t\\tif x == dst: \\n\\t\\t\\t\\treturn v\\n\\t\\t\\tseen.add(x)\\n\\t\\t\\tfor y in G[x]:\\n\\t\\t\\t\\tif y not in seen: \\n\\t\\t\\t\\t\\tq.append((y, v*G[x][y]))\\n\\t\\treturn -1.0\\n\\treturn [bfs(s, d) for s, d in queries]\\n```\\n\\nAnother solution is Union Find. \\n\\nOur root map is `root` and each `root[x]` is in form of `(root(x), ratio)` where `ratio = x/root(x)`. If `x == root(x)`, then `ratio = 1.0`. So just consider root as a denominator here. Then, we process the equations. For each `x/y = v`, we union `x` to `y` or set `root(root(x)) = root(y)` as `y` is the denominator. After union all `x, y` in the equations, for each `a, b` in the queries, if `a` and `b` are not in the same union set, then `a` and `b` are not transmissable to each other so `a/b` should return `-1.0`.\\n\\nNow that we have a `ratio` element in each `root[x]`, we need to update it in `find()` and `union()` as well.\\nIn `find(x)`, we have `root[x] = (p, x/p)` where `p` is the parent node of x and not neccessarily the root node. But we will do path compression and recursively update all the parent nodes in the path to root. And `ratio` should be updated as well. Eventually `find(p)` returns updated `root[p] = (root(p), p/root(p))`. \\nSo `root[x]` should be updated to `(root(x), x/root(x)) = (root(p), x/p * p/root(p))) = (root[p][0], root[x][1] * root[p][1])`\\n\\nFor `union(x, y)` in equations processing, we make `root(root(x)) = root(y)` as mentiond previously. And for `root[root(x)]`\\'s `ratio`, as `root(y)` is `root(x)`\\'s new root, we update it to `root(x)/root(y) = (x/y) * (y/root(y)) / (x/root(x)) = x/y * root[y][1] / root[x][1]`. `x/y` is the provided equation outcome value.\\n\\nFor `union(x, y)` in queries, we can just simply return `x/y = (x/root(x)) / (y/root(y)) = root[x][1]/root[y][1]`.\\n\\n```\\ndef calcEquation(equations, values):\\n\\troot = {}\\n\\t\\n\\t# xr = x/parent(x), pr = parent(x)/root(x), update xr to xr*pr = x/root(x)\\n\\tdef find(x):\\n\\t\\tp, xr = root.setdefault(x, (x, 1.0))\\n\\t\\tif x != p:\\n\\t\\t\\tr, pr = find(p)\\n\\t\\t\\troot[x] = (r, xr*pr)\\n\\t\\treturn root[x]\\n\\n\\t# if root(x) = root(y), equations \"x / y\" doable as (x/root(x)) / (y/root(y)) = xr / yr\\n\\tdef union(x, y, ratio):\\n\\t\\tpx, xr, py, yr = *find(x), *find(y)\\n\\t\\tif not ratio:\\n\\t\\t\\treturn xr / yr if px == py else -1.0\\n\\t\\tif px != py:\\n\\t\\t\\troot[px] = (py, yr/xr*ratio)\\n\\n\\tfor (x, y), v in zip(equations, values):\\n\\t\\tunion(x, y, v)\\n\\treturn [union(x, y, 0) if x in root and y in root else -1.0 for x, y in queries]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\ndef calcEquation(equations, values, queries):\\n\\tG = collections.defaultdict(dict)\\n\\tfor (x, y), v in zip(equations, values):\\n\\t\\tG[x][y] = v\\n\\t\\tG[y][x] = 1/v\\n\\tdef bfs(src, dst):\\n\\t\\tif not (src in G and dst in G): return -1.0\\n\\t\\tq, seen = [(src, 1.0)], set()\\n\\t\\tfor x, v in q:\\n\\t\\t\\tif x == dst: \\n\\t\\t\\t\\treturn v\\n\\t\\t\\tseen.add(x)\\n\\t\\t\\tfor y in G[x]:\\n\\t\\t\\t\\tif y not in seen: \\n\\t\\t\\t\\t\\tq.append((y, v*G[x][y]))\\n\\t\\treturn -1.0\\n\\treturn [bfs(s, d) for s, d in queries]\\n```\n```\\ndef calcEquation(equations, values):\\n\\troot = {}\\n\\t\\n\\t# xr = x/parent(x), pr = parent(x)/root(x), update xr to xr*pr = x/root(x)\\n\\tdef find(x):\\n\\t\\tp, xr = root.setdefault(x, (x, 1.0))\\n\\t\\tif x != p:\\n\\t\\t\\tr, pr = find(p)\\n\\t\\t\\troot[x] = (r, xr*pr)\\n\\t\\treturn root[x]\\n\\n\\t# if root(x) = root(y), equations \"x / y\" doable as (x/root(x)) / (y/root(y)) = xr / yr\\n\\tdef union(x, y, ratio):\\n\\t\\tpx, xr, py, yr = *find(x), *find(y)\\n\\t\\tif not ratio:\\n\\t\\t\\treturn xr / yr if px == py else -1.0\\n\\t\\tif px != py:\\n\\t\\t\\troot[px] = (py, yr/xr*ratio)\\n\\n\\tfor (x, y), v in zip(equations, values):\\n\\t\\tunion(x, y, v)\\n\\treturn [union(x, y, 0) if x in root and y in root else -1.0 for x, y in queries]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 278276,
                "title": "java-union-find-and-dfs-query-o-1",
                "content": "**Java, Union Find:**\\n```\\n    Map<String, String>parents = new HashMap<>();\\n    Map<String, Double>vals = new HashMap<>();\\n\\n    public double[] calcEquation(String[][] equs, double[] values, String[][] queries) {\\n        double[] res = new double[queries.length];\\n        for (int i = 0; i < values.length ; ++i )\\n            union(equs[i][0], equs[i][1], values[i]);\\n        for (int i = 0; i < queries.length; ++i) {\\n            String x = queries[i][0], y = queries[i][1];\\n            res[i] = (parents.containsKey(x) && parents.containsKey(y) && find(x) == find(y)) ? vals.get(x) / vals.get(y) : -1.0;\\n        }\\n        return res;\\n    }\\n\\n    public void add(String x) {\\n        if (parents.containsKey(x)) return;\\n        parents.put(x, x);\\n        vals.put(x, 1.0);\\n    }\\n\\n    public String find(String x) {\\n        String p = parents.getOrDefault(x, x);\\n        if (x != p) {\\n            String pp = find(p);\\n            vals.put(x, vals.get(x) * vals.get(p));\\n            parents.put(x, pp);\\n        }\\n        return parents.getOrDefault(x, x);\\n    }\\n\\n    public void union(String x, String y, double v) {\\n        add(x); add(y);\\n        String px = find(x), py = find(y);\\n        parents.put(px, py);\\n        vals.put(px, v * vals.get(y) / vals.get(x));\\n    }\\n```\\n\\n\\n**Java, DFS**\\n```\\n    HashSet<String> seen = new HashSet<>();\\n    HashMap<String, String> root = new HashMap<>();\\n    HashMap<String, Double> vals = new HashMap<>();\\n    HashMap<String, HashMap<String, Double>> edges = new HashMap<>();\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        int n = equations.length, m = queries.length;\\n        for (int i = 0; i < n; ++i) {\\n            String x = equations[i][0], y = equations[i][1];\\n            if (!edges.containsKey(x))\\n                edges.put(x, new HashMap<String, Double>());\\n            if (!edges.containsKey(y) )\\n                edges.put(y, new HashMap<String, Double>());\\n            edges.get(x).put(y, values[i]);\\n            edges.get(y).put(x, 1 / values[i]);\\n        }\\n        for (String x : edges.keySet()) {\\n            if (!seen.contains(x)) dfs(x, x, 1);\\n        }\\n        double[] res = new double[m];\\n        for (int i = 0; i < m; ++i) {\\n            String x = queries[i][0], y = queries[i][1];\\n            String px = root.getOrDefault(x, x), py = root.getOrDefault(y, y);\\n            if (px != py)\\n                res[i] = -1.0;\\n            else\\n                res[i] = vals.get(x) / vals.get(y);\\n        }\\n        return res;\\n\\n    }\\n    public void dfs(String x, String p, double v) {\\n        vals.put(x, v);\\n        root.put(x, p);\\n        seen.add(x);\\n        for (String y : edges.get(x).keySet()) {\\n            if (!seen.contains(y))\\n                dfs(y, p, v * edges.get(y).get(x));\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Map<String, String>parents = new HashMap<>();\\n    Map<String, Double>vals = new HashMap<>();\\n\\n    public double[] calcEquation(String[][] equs, double[] values, String[][] queries) {\\n        double[] res = new double[queries.length];\\n        for (int i = 0; i < values.length ; ++i )\\n            union(equs[i][0], equs[i][1], values[i]);\\n        for (int i = 0; i < queries.length; ++i) {\\n            String x = queries[i][0], y = queries[i][1];\\n            res[i] = (parents.containsKey(x) && parents.containsKey(y) && find(x) == find(y)) ? vals.get(x) / vals.get(y) : -1.0;\\n        }\\n        return res;\\n    }\\n\\n    public void add(String x) {\\n        if (parents.containsKey(x)) return;\\n        parents.put(x, x);\\n        vals.put(x, 1.0);\\n    }\\n\\n    public String find(String x) {\\n        String p = parents.getOrDefault(x, x);\\n        if (x != p) {\\n            String pp = find(p);\\n            vals.put(x, vals.get(x) * vals.get(p));\\n            parents.put(x, pp);\\n        }\\n        return parents.getOrDefault(x, x);\\n    }\\n\\n    public void union(String x, String y, double v) {\\n        add(x); add(y);\\n        String px = find(x), py = find(y);\\n        parents.put(px, py);\\n        vals.put(px, v * vals.get(y) / vals.get(x));\\n    }\\n```\n```\\n    HashSet<String> seen = new HashSet<>();\\n    HashMap<String, String> root = new HashMap<>();\\n    HashMap<String, Double> vals = new HashMap<>();\\n    HashMap<String, HashMap<String, Double>> edges = new HashMap<>();\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        int n = equations.length, m = queries.length;\\n        for (int i = 0; i < n; ++i) {\\n            String x = equations[i][0], y = equations[i][1];\\n            if (!edges.containsKey(x))\\n                edges.put(x, new HashMap<String, Double>());\\n            if (!edges.containsKey(y) )\\n                edges.put(y, new HashMap<String, Double>());\\n            edges.get(x).put(y, values[i]);\\n            edges.get(y).put(x, 1 / values[i]);\\n        }\\n        for (String x : edges.keySet()) {\\n            if (!seen.contains(x)) dfs(x, x, 1);\\n        }\\n        double[] res = new double[m];\\n        for (int i = 0; i < m; ++i) {\\n            String x = queries[i][0], y = queries[i][1];\\n            String px = root.getOrDefault(x, x), py = root.getOrDefault(y, y);\\n            if (px != py)\\n                res[i] = -1.0;\\n            else\\n                res[i] = vals.get(x) / vals.get(y);\\n        }\\n        return res;\\n\\n    }\\n    public void dfs(String x, String p, double v) {\\n        vals.put(x, v);\\n        root.put(x, p);\\n        seen.add(x);\\n        for (String y : edges.get(x).keySet()) {\\n            if (!seen.contains(y))\\n                dfs(y, p, v * edges.get(y).get(x));\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88170,
                "title": "0ms-c-union-find-solution-easy-to-understand",
                "content": "```c++\\nclass Solution {\\n    // date: 2016-09-12     location: Santa Clara City Library\\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries) {\\n        unordered_map<string, Node*> map;\\n        vector<double> res;\\n        for (int i = 0; i < equations.size(); i ++) {\\n            string s1 = equations[i].first, s2 = equations[i].second;\\n            if (map.count(s1) == 0 && map.count(s2) == 0) {\\n                map[s1] = new Node();\\n                map[s2] = new Node();\\n                map[s1] -> value = values[i];\\n                map[s2] -> value = 1;\\n                map[s1] -> parent = map[s2];\\n            } else if (map.count(s1) == 0) {\\n                map[s1] = new Node();\\n                map[s1] -> value = map[s2] -> value * values[i];\\n                map[s1] -> parent = map[s2];\\n            } else if (map.count(s2) == 0) {\\n                map[s2] = new Node();\\n                map[s2] -> value = map[s1] -> value / values[i];\\n                map[s2] -> parent = map[s1];\\n            } else {\\n                unionNodes(map[s1], map[s2], values[i], map);\\n            }\\n        }\\n\\n        for (auto query : queries) {\\n            if (map.count(query.first) == 0 || map.count(query.second) == 0 || findParent(map[query.first]) != findParent(map[query.second]))\\n                res.push_back(-1);\\n            else\\n                res.push_back(map[query.first] -> value / map[query.second] -> value);\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    struct Node {\\n        Node* parent;\\n        double value = 0.0;\\n        Node()  {parent = this;}\\n    };\\n    \\n    void unionNodes(Node* node1, Node* node2, double num, unordered_map<string, Node*>& map) {\\n        Node* parent1 = findParent(node1), *parent2 = findParent(node2);\\n        double ratio = node2 -> value * num / node1 -> value;\\n        for (auto it = map.begin(); it != map.end(); it ++)\\n            if (findParent(it -> second) == parent1)\\n                it -> second -> value *= ratio;\\n        parent1 -> parent = parent2;\\n    }\\n    \\n    Node* findParent(Node* node) {\\n        if (node -> parent == node)\\n            return node;\\n        node -> parent = findParent(node -> parent);\\n        return node -> parent;\\n    }\\n};\\n```\\n   \\n   \\n**Update:**\\n- Please also check Java solutions below.  \\n- Special thanks to @iambright and @Scarlett_comeup.",
                "solutionTags": [
                    "Java",
                    "C",
                    "Union Find"
                ],
                "code": "```c++\\nclass Solution {\\n    // date: 2016-09-12     location: Santa Clara City Library\\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries) {\\n        unordered_map<string, Node*> map;\\n        vector<double> res;\\n        for (int i = 0; i < equations.size(); i ++) {\\n            string s1 = equations[i].first, s2 = equations[i].second;\\n            if (map.count(s1) == 0 && map.count(s2) == 0) {\\n                map[s1] = new Node();\\n                map[s2] = new Node();\\n                map[s1] -> value = values[i];\\n                map[s2] -> value = 1;\\n                map[s1] -> parent = map[s2];\\n            } else if (map.count(s1) == 0) {\\n                map[s1] = new Node();\\n                map[s1] -> value = map[s2] -> value * values[i];\\n                map[s1] -> parent = map[s2];\\n            } else if (map.count(s2) == 0) {\\n                map[s2] = new Node();\\n                map[s2] -> value = map[s1] -> value / values[i];\\n                map[s2] -> parent = map[s1];\\n            } else {\\n                unionNodes(map[s1], map[s2], values[i], map);\\n            }\\n        }\\n\\n        for (auto query : queries) {\\n            if (map.count(query.first) == 0 || map.count(query.second) == 0 || findParent(map[query.first]) != findParent(map[query.second]))\\n                res.push_back(-1);\\n            else\\n                res.push_back(map[query.first] -> value / map[query.second] -> value);\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    struct Node {\\n        Node* parent;\\n        double value = 0.0;\\n        Node()  {parent = this;}\\n    };\\n    \\n    void unionNodes(Node* node1, Node* node2, double num, unordered_map<string, Node*>& map) {\\n        Node* parent1 = findParent(node1), *parent2 = findParent(node2);\\n        double ratio = node2 -> value * num / node1 -> value;\\n        for (auto it = map.begin(); it != map.end(); it ++)\\n            if (findParent(it -> second) == parent1)\\n                it -> second -> value *= ratio;\\n        parent1 -> parent = parent2;\\n    }\\n    \\n    Node* findParent(Node* node) {\\n        if (node -> parent == node)\\n            return node;\\n        node -> parent = findParent(node -> parent);\\n        return node -> parent;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543256,
                "title": "image-explanation-easiest-concise-complete-intuition-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Evaluate Division` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/ea784e4a-5afe-47b8-b216-05ef635447e2_1684547921.8152688.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/1e21a993-b008-4518-94b7-a34348bf968d_1684547399.092806.png)\\n![image.png](https://assets.leetcode.com/users/images/957bd56c-db2e-44ed-9c68-ba597f223bcf_1684547409.023691.png)\\n![image.png](https://assets.leetcode.com/users/images/3c77b62f-b1b1-4f85-a364-c0eb75560723_1684547419.421671.png)\\n![image.png](https://assets.leetcode.com/users/images/ef723455-6777-414b-8965-d6097ae33857_1684547435.676669.png)\\n![image.png](https://assets.leetcode.com/users/images/6b413a9c-340f-4ecd-8fa6-b734545da24a_1684547443.5713143.png)\\n![image.png](https://assets.leetcode.com/users/images/cfe10701-c382-4222-b4a7-2f30656655b4_1684547451.1970894.png)\\n![image.png](https://assets.leetcode.com/users/images/594b2545-bf3c-476e-a8ae-1aa38ccf7175_1684547468.6778407.png)\\n![image.png](https://assets.leetcode.com/users/images/f1618602-ad90-4089-aed6-f4fd09a3e049_1684547482.2337976.png)\\n![image.png](https://assets.leetcode.com/users/images/e30c97e5-d69c-4b93-ad33-61474812949a_1684547491.0015368.png)\\n![image.png](https://assets.leetcode.com/users/images/1264baff-6ad3-43f3-acd2-eb8c3c06143d_1684547497.6284661.png)\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n\\n    void dfs(string node, string& dest, unordered_map<string, unordered_map<string, double>>& gr, unordered_set<string>& vis, double& ans, double temp) {\\n        if(vis.find(node) != vis.end()) return;\\n\\n        vis.insert(node);\\n        if(node == dest){\\n            ans = temp;\\n            return;\\n        }\\n\\n        for(auto ne : gr[node]){\\n            dfs(ne.first, dest, gr, vis, ans, temp * ne.second);\\n        }\\n    }\\n\\n    unordered_map<string, unordered_map<string, double>> buildGraph(const vector<vector<string>>& equations, const vector<double>& values) {\\n        unordered_map<string, unordered_map<string, double>> gr;\\n\\n        for (int i = 0; i < equations.size(); i++) {\\n            string dividend = equations[i][0];\\n            string divisor = equations[i][1];\\n            double value = values[i];\\n\\n            gr[dividend][divisor] = value;\\n            gr[divisor][dividend] = 1.0 / value;\\n        }\\n\\n        return gr;\\n    }\\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        unordered_map<string, unordered_map<string, double>> gr = buildGraph(equations, values);\\n        vector<double> finalAns;\\n\\n        for (auto query : queries) {\\n            string dividend = query[0];\\n            string divisor = query[1];\\n\\n            if (gr.find(dividend) == gr.end() || gr.find(divisor) == gr.end()) {\\n                finalAns.push_back(-1.0);\\n            } else {\\n                unordered_set<string> vis;\\n                double ans = -1, temp=1.0;\\n                dfs(dividend, divisor, gr, vis, ans, temp);\\n                finalAns.push_back(ans);\\n            }\\n        }\\n\\n        return finalAns;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public void dfs(String node, String dest, HashMap<String, HashMap<String, Double>> gr, HashSet<String> vis, double[] ans, double temp) {\\n        if (vis.contains(node))\\n            return;\\n\\n        vis.add(node);\\n        if (node.equals(dest)) {\\n            ans[0] = temp;\\n            return;\\n        }\\n\\n        for (Map.Entry<String, Double> entry : gr.get(node).entrySet()) {\\n            String ne = entry.getKey();\\n            double val = entry.getValue();\\n            dfs(ne, dest, gr, vis, ans, temp * val);\\n        }\\n    }\\n\\n    public HashMap<String, HashMap<String, Double>> buildGraph(List<List<String>> equations, double[] values) {\\n        HashMap<String, HashMap<String, Double>> gr = new HashMap<>();\\n\\n        for (int i = 0; i < equations.size(); i++) {\\n            String dividend = equations.get(i).get(0);\\n            String divisor = equations.get(i).get(1);\\n            double value = values[i];\\n\\n            gr.putIfAbsent(dividend, new HashMap<>());\\n            gr.putIfAbsent(divisor, new HashMap<>());\\n\\n            gr.get(dividend).put(divisor, value);\\n            gr.get(divisor).put(dividend, 1.0 / value);\\n        }\\n\\n        return gr;\\n    }\\n\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        HashMap<String, HashMap<String, Double>> gr = buildGraph(equations, values);\\n        double[] finalAns = new double[queries.size()];\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            String dividend = queries.get(i).get(0);\\n            String divisor = queries.get(i).get(1);\\n\\n            if (!gr.containsKey(dividend) || !gr.containsKey(divisor)) {\\n                finalAns[i] = -1.0;\\n            } else {\\n                HashSet<String> vis = new HashSet<>();\\n                double[] ans = {-1.0};\\n                double temp = 1.0;\\n                dfs(dividend, divisor, gr, vis, ans, temp);\\n                finalAns[i] = ans[0];\\n            }\\n        }\\n\\n        return finalAns;\\n    }\\n}\\n```\\n```Python []\\nfrom typing import List\\n\\nclass Solution:\\n    def dfs(self, node: str, dest: str, gr: dict, vis: set, ans: List[float], temp: float) -> None:\\n        if node in vis:\\n            return\\n\\n        vis.add(node)\\n        if node == dest:\\n            ans[0] = temp\\n            return\\n\\n        for ne, val in gr[node].items():\\n            self.dfs(ne, dest, gr, vis, ans, temp * val)\\n\\n    def buildGraph(self, equations: List[List[str]], values: List[float]) -> dict:\\n        gr = {}\\n\\n        for i in range(len(equations)):\\n            dividend, divisor = equations[i]\\n            value = values[i]\\n\\n            if dividend not in gr:\\n                gr[dividend] = {}\\n            if divisor not in gr:\\n                gr[divisor] = {}\\n\\n            gr[dividend][divisor] = value\\n            gr[divisor][dividend] = 1.0 / value\\n\\n        return gr\\n\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        gr = self.buildGraph(equations, values)\\n        finalAns = []\\n\\n        for query in queries:\\n            dividend, divisor = query\\n\\n            if dividend not in gr or divisor not in gr:\\n                finalAns.append(-1.0)\\n            else:\\n                vis = set()\\n                ans = [-1.0]\\n                temp = 1.0\\n                self.dfs(dividend, divisor, gr, vis, ans, temp)\\n                finalAns.append(ans[0])\\n\\n        return finalAns\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\n    void dfs(string node, string& dest, unordered_map<string, unordered_map<string, double>>& gr, unordered_set<string>& vis, double& ans, double temp) {\\n        if(vis.find(node) != vis.end()) return;\\n\\n        vis.insert(node);\\n        if(node == dest){\\n            ans = temp;\\n            return;\\n        }\\n\\n        for(auto ne : gr[node]){\\n            dfs(ne.first, dest, gr, vis, ans, temp * ne.second);\\n        }\\n    }\\n\\n    unordered_map<string, unordered_map<string, double>> buildGraph(const vector<vector<string>>& equations, const vector<double>& values) {\\n        unordered_map<string, unordered_map<string, double>> gr;\\n\\n        for (int i = 0; i < equations.size(); i++) {\\n            string dividend = equations[i][0];\\n            string divisor = equations[i][1];\\n            double value = values[i];\\n\\n            gr[dividend][divisor] = value;\\n            gr[divisor][dividend] = 1.0 / value;\\n        }\\n\\n        return gr;\\n    }\\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        unordered_map<string, unordered_map<string, double>> gr = buildGraph(equations, values);\\n        vector<double> finalAns;\\n\\n        for (auto query : queries) {\\n            string dividend = query[0];\\n            string divisor = query[1];\\n\\n            if (gr.find(dividend) == gr.end() || gr.find(divisor) == gr.end()) {\\n                finalAns.push_back(-1.0);\\n            } else {\\n                unordered_set<string> vis;\\n                double ans = -1, temp=1.0;\\n                dfs(dividend, divisor, gr, vis, ans, temp);\\n                finalAns.push_back(ans);\\n            }\\n        }\\n\\n        return finalAns;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public void dfs(String node, String dest, HashMap<String, HashMap<String, Double>> gr, HashSet<String> vis, double[] ans, double temp) {\\n        if (vis.contains(node))\\n            return;\\n\\n        vis.add(node);\\n        if (node.equals(dest)) {\\n            ans[0] = temp;\\n            return;\\n        }\\n\\n        for (Map.Entry<String, Double> entry : gr.get(node).entrySet()) {\\n            String ne = entry.getKey();\\n            double val = entry.getValue();\\n            dfs(ne, dest, gr, vis, ans, temp * val);\\n        }\\n    }\\n\\n    public HashMap<String, HashMap<String, Double>> buildGraph(List<List<String>> equations, double[] values) {\\n        HashMap<String, HashMap<String, Double>> gr = new HashMap<>();\\n\\n        for (int i = 0; i < equations.size(); i++) {\\n            String dividend = equations.get(i).get(0);\\n            String divisor = equations.get(i).get(1);\\n            double value = values[i];\\n\\n            gr.putIfAbsent(dividend, new HashMap<>());\\n            gr.putIfAbsent(divisor, new HashMap<>());\\n\\n            gr.get(dividend).put(divisor, value);\\n            gr.get(divisor).put(dividend, 1.0 / value);\\n        }\\n\\n        return gr;\\n    }\\n\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        HashMap<String, HashMap<String, Double>> gr = buildGraph(equations, values);\\n        double[] finalAns = new double[queries.size()];\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            String dividend = queries.get(i).get(0);\\n            String divisor = queries.get(i).get(1);\\n\\n            if (!gr.containsKey(dividend) || !gr.containsKey(divisor)) {\\n                finalAns[i] = -1.0;\\n            } else {\\n                HashSet<String> vis = new HashSet<>();\\n                double[] ans = {-1.0};\\n                double temp = 1.0;\\n                dfs(dividend, divisor, gr, vis, ans, temp);\\n                finalAns[i] = ans[0];\\n            }\\n        }\\n\\n        return finalAns;\\n    }\\n}\\n```\n```Python []\\nfrom typing import List\\n\\nclass Solution:\\n    def dfs(self, node: str, dest: str, gr: dict, vis: set, ans: List[float], temp: float) -> None:\\n        if node in vis:\\n            return\\n\\n        vis.add(node)\\n        if node == dest:\\n            ans[0] = temp\\n            return\\n\\n        for ne, val in gr[node].items():\\n            self.dfs(ne, dest, gr, vis, ans, temp * val)\\n\\n    def buildGraph(self, equations: List[List[str]], values: List[float]) -> dict:\\n        gr = {}\\n\\n        for i in range(len(equations)):\\n            dividend, divisor = equations[i]\\n            value = values[i]\\n\\n            if dividend not in gr:\\n                gr[dividend] = {}\\n            if divisor not in gr:\\n                gr[divisor] = {}\\n\\n            gr[dividend][divisor] = value\\n            gr[divisor][dividend] = 1.0 / value\\n\\n        return gr\\n\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        gr = self.buildGraph(equations, values)\\n        finalAns = []\\n\\n        for query in queries:\\n            dividend, divisor = query\\n\\n            if dividend not in gr or divisor not in gr:\\n                finalAns.append(-1.0)\\n            else:\\n                vis = set()\\n                ans = [-1.0]\\n                temp = 1.0\\n                self.dfs(dividend, divisor, gr, vis, ans, temp)\\n                finalAns.append(ans[0])\\n\\n        return finalAns\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88168,
                "title": "c-0ms-hash-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, \\n        vector<double>& values, vector<pair<string, string>> query) \\n    {\\n        unordered_map<string,unordered_map<string, double>> m;\\n        vector<double> res;\\n        for (int i = 0; i < values.size(); ++i)\\n        {\\n            m[equations[i].first].insert(make_pair(equations[i].second,values[i]));\\n            if(values[i]!=0)\\n                m[equations[i].second].insert(make_pair(equations[i].first,1/values[i]));\\n        }\\n\\n        for (auto i : query)\\n        {\\n            unordered_set<string> s;\\n            double tmp = check(i.first,i.second,m,s);\\n            if(tmp) res.push_back(tmp);\\n            else res.push_back(-1);\\n        }\\n        return res;\\n    }\\n\\n    double check(string up, string down, \\n            unordered_map<string,unordered_map<string, double>> &m,\\n            unordered_set<string> &s)\\n    {\\n        if(m[up].find(down) != m[up].end()) return m[up][down];\\n        for (auto i : m[up])\\n        {\\n            if(s.find(i.first) == s.end())\\n            {\\n                s.insert(i.first);\\n                double tmp = check(i.first,down,m,s);\\n                if(tmp) return i.second*tmp;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, \\n        vector<double>& values, vector<pair<string, string>> query) \\n    {\\n        unordered_map<string,unordered_map<string, double>> m;\\n        vector<double> res;\\n        for (int i = 0; i < values.size(); ++i)\\n        {\\n            m[equations[i].first].insert(make_pair(equations[i].second,values[i]));\\n            if(values[i]!=0)\\n                m[equations[i].second].insert(make_pair(equations[i].first,1/values[i]));\\n        }\\n\\n        for (auto i : query)\\n        {\\n            unordered_set<string> s;\\n            double tmp = check(i.first,i.second,m,s);\\n            if(tmp) res.push_back(tmp);\\n            else res.push_back(-1);\\n        }\\n        return res;\\n    }\\n\\n    double check(string up, string down, \\n            unordered_map<string,unordered_map<string, double>> &m,\\n            unordered_set<string> &s)\\n    {\\n        if(m[up].find(down) != m[up].end()) return m[up][down];\\n        for (auto i : m[up])\\n        {\\n            if(s.find(i.first) == s.end())\\n            {\\n                s.insert(i.first);\\n                double tmp = check(i.first,down,m,s);\\n                if(tmp) return i.second*tmp;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992891,
                "title": "java-dfs-solution-with-comments-evaluate-division",
                "content": "```\\n# Using DFS\\nprivate  Map<String, Map<String, Double>> makeGraph(List<List<String>> e, double[] values){\\n        // build a graph\\n        // like a -> b = values[i]\\n        // and b -> a  = 1.0 / values[i];\\n        Map<String, Map<String, Double>> graph = new HashMap<>();\\n        String u, v;\\n        \\n        for(int i = 0; i < e.size(); i++){\\n            u = e.get(i).get(0);\\n            v = e.get(i).get(1);\\n            \\n            graph.putIfAbsent(u, new HashMap<>());\\n            graph.get(u).put(v, values[i]);\\n            \\n            graph.putIfAbsent(v, new HashMap<>());\\n            graph.get(v).put(u, 1/values[i]);\\n            \\n        }\\n        return graph;\\n    }\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        Map<String, Map<String, Double>> graph = makeGraph(equations, values);\\n        \\n        double []ans = new double[queries.size()];\\n        \\n        // check for every Querie\\n        // store it in ans array;\\n        for(int i = 0; i < queries.size(); i++){\\n            ans[i] = dfs(queries.get(i).get(0) , queries.get(i).get(1) , new HashSet<>(), graph);\\n        }\\n        return ans;\\n    }\\n    \\n    public double dfs(String src, String dest, Set<String> visited, Map<String, Map<String, Double>> graph){\\n        // check the terminated Case\\n        // if string is not present in graph return -1.0;\\n        // like [a, e] or [x, x] :)\\n        if(graph.containsKey(src ) == false)\\n            return -1.0;\\n        \\n        // simply say check src and dest are equal :) then return dest \\n        // store it in weight varaible;\\n        //case like [a,a] also handle\\n        if(graph.get(src).containsKey(dest)){\\n            return graph.get(src).get(dest);\\n        }\\n        \\n        visited.add(src);\\n        \\n        for(Map.Entry<String, Double> nbr : graph.get(src).entrySet()){\\n            if(visited.contains(nbr.getKey()) == false){\\n                double weight = dfs(nbr.getKey(), dest, visited, graph);\\n                \\n                // if weight is not -1.0(terminate case)\\n                // then mutliply it \\n                // like in querie   a -> c => 2 * 3 = 6\\n                if(weight != -1.0){\\n                    return nbr.getValue() * weight;\\n                }\\n            }\\n        }\\n        return -1.0;\\n    }\\n```\\n\\n**Please Upvote it** :)",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n# Using DFS\\nprivate  Map<String, Map<String, Double>> makeGraph(List<List<String>> e, double[] values){\\n        // build a graph\\n        // like a -> b = values[i]\\n        // and b -> a  = 1.0 / values[i];\\n        Map<String, Map<String, Double>> graph = new HashMap<>();\\n        String u, v;\\n        \\n        for(int i = 0; i < e.size(); i++){\\n            u = e.get(i).get(0);\\n            v = e.get(i).get(1);\\n            \\n            graph.putIfAbsent(u, new HashMap<>());\\n            graph.get(u).put(v, values[i]);\\n            \\n            graph.putIfAbsent(v, new HashMap<>());\\n            graph.get(v).put(u, 1/values[i]);\\n            \\n        }\\n        return graph;\\n    }\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        Map<String, Map<String, Double>> graph = makeGraph(equations, values);\\n        \\n        double []ans = new double[queries.size()];\\n        \\n        // check for every Querie\\n        // store it in ans array;\\n        for(int i = 0; i < queries.size(); i++){\\n            ans[i] = dfs(queries.get(i).get(0) , queries.get(i).get(1) , new HashSet<>(), graph);\\n        }\\n        return ans;\\n    }\\n    \\n    public double dfs(String src, String dest, Set<String> visited, Map<String, Map<String, Double>> graph){\\n        // check the terminated Case\\n        // if string is not present in graph return -1.0;\\n        // like [a, e] or [x, x] :)\\n        if(graph.containsKey(src ) == false)\\n            return -1.0;\\n        \\n        // simply say check src and dest are equal :) then return dest \\n        // store it in weight varaible;\\n        //case like [a,a] also handle\\n        if(graph.get(src).containsKey(dest)){\\n            return graph.get(src).get(dest);\\n        }\\n        \\n        visited.add(src);\\n        \\n        for(Map.Entry<String, Double> nbr : graph.get(src).entrySet()){\\n            if(visited.contains(nbr.getKey()) == false){\\n                double weight = dfs(nbr.getKey(), dest, visited, graph);\\n                \\n                // if weight is not -1.0(terminate case)\\n                // then mutliply it \\n                // like in querie   a -> c => 2 * 3 = 6\\n                if(weight != -1.0){\\n                    return nbr.getValue() * weight;\\n                }\\n            }\\n        }\\n        return -1.0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88287,
                "title": "esay-understand-java-solution-3ms",
                "content": "``` java\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n        double[] result = new double[query.length];\\n        // filter unexpected words\\n        // \\u8fc7\\u6ee4\\u6389\\u6ca1\\u6709\\u9047\\u89c1\\u8fc7\\u7684\\u5b57\\u7b26\\n        Set<String> words = new HashSet<>();\\n        for (String[] strs : equations) {\\n            words.add(strs[0]);\\n            words.add(strs[1]);\\n        }\\n        for (int i = 0; i < query.length; ++i) {\\n            String[] keys = query[i];\\n            if (!words.contains(keys[0]) || !words.contains(keys[1])) result[i] = -1.0d;\\n            else {\\n                Stack<Integer> stack = new Stack<>();\\n                result[i] = helper(equations, values, keys, stack);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public double helper(String[][] equations, double[] values, String[] keys, Stack<Integer> stack) {\\n        // \\u76f4\\u63a5\\u67e5\\u627e\\uff0ckey\\u7684\\u987a\\u5e8f\\u6709\\u6b63\\u53cd\\n        // look up equations directly\\n        for (int i = 0; i < equations.length; ++i) {\\n            if (equations[i][0].equals(keys[0]) && equations[i][1].equals(keys[1])) return values[i];\\n            if (equations[i][0].equals(keys[1]) && equations[i][1].equals(keys[0])) return 1 / values[i];\\n        }\\n        // lookup equations by other equations\\n        // \\u95f4\\u63a5\\u67e5\\u627e\\uff0ckey\\u7684\\u987a\\u5e8f\\u4e5f\\u6709\\u6b63\\u53cd\\n        for (int i = 0; i < equations.length; ++i) {\\n            if (!stack.contains(i) && keys[0].equals(equations[i][0])) {\\n                stack.push(i);\\n                double temp = values[i] * helper(equations, values, new String[]{equations[i][1], keys[1]}, stack);\\n                if (temp > 0) return temp;\\n                else stack.pop();\\n            }\\n            if (!stack.contains(i) && keys[0].equals(equations[i][1])) {\\n                stack.push(i);\\n                double temp = helper(equations, values, new String[]{equations[i][0], keys[1]}, stack) / values[i];\\n                if (temp > 0) return temp;\\n                else stack.pop();\\n            }\\n        }\\n        // \\u67e5\\u4e0d\\u5230\\uff0c\\u8fd4\\u56de-1\\n        return -1.0d;\\n    }\\n```\\n\\nupdate:\\n\\nThanks for @jason88628  remind me. change from stack to set will be better.\\n\\nupdate:\\n\\nAnother way for this problem, but it need more memory and more time to build a whole map of equations.\\n\\nIt's efficient when there is a large set of queries.\\n\\n``` java\\npublic double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n        // use table save string to integer\\n        Map<String, Integer> table = new HashMap<>();\\n        int len = 0;\\n        for (String[] strings : equations)\\n            for (String string : strings)\\n                if (!table.containsKey(string)) table.put(string, len++);\\n\\n        // init map by direct equation\\n        double[][] map = new double[len][len];\\n        for (int i = 0; i < len; ++i)\\n            for (int j = 0; j < len; ++j)\\n                map[i][j] = (i == j ? 1.0d : -1.0d);\\n        for (int i = 0; i < equations.length; ++i) {\\n            String[] keys = equations[i];\\n            int row = table.get(keys[0]);\\n            int col = table.get(keys[1]);\\n            map[row][col] = values[i];\\n            map[col][row] = 1 / values[i];\\n        }\\n\\n        // floyd-warshall like algorithm\\n        for (int i = 0; i < len; ++i) {\\n            for (int j = 0; j < len; ++j) {\\n                for (int k = 0; k < len; ++k) {\\n                    if (map[j][i] >= 0d && map[i][k] >= 0d) map[j][k] = map[j][i] * map[i][k];\\n                }\\n            }\\n        }\\n\\n        // query now\\n        double[] result = new double[query.length];\\n        for (int i = 0; i < query.length; ++i) {\\n            String[] keys = query[i];\\n            Integer row = table.get(keys[0]);\\n            Integer col = table.get(keys[1]);\\n            if (row == null || col == null) result[i] = -1.0d;\\n            else result[i] = map[row][col];\\n        }\\n        return result;\\n    }\\n```\\n\\nupdate:\\nA better way with union-find alogrithm. It takes less memory and time than the above one. But it's hard to understand.\\n\\nYou can replace class `Node` with two arrays. In that way, it will be more efficient.\\n\\n``` java\\npublic double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n\\n        // map string to integer\\n        Map<String, Integer> mIdTable = new HashMap<>();\\n        int len = 0;\\n        for (String[] words : equations)\\n            for (String word : words)\\n                if (!mIdTable.containsKey(word)) mIdTable.put(word, len++);\\n\\n        // init parent index and value\\n        Node[] nodes = new Node[len];\\n        for (int i = 0; i < len; ++i) nodes[i] = new Node(i);\\n\\n        // union, you can take an example as follows\\n        // (a/b=3)->(c/d=6)->(b/d=12)\\n        for (int i = 0; i < equations.length; ++i) {\\n            String[] keys = equations[i];\\n            int k1 = mIdTable.get(keys[0]);\\n            int k2 = mIdTable.get(keys[1]);\\n            int groupHead1 = find(nodes, k1);\\n            int groupHead2 = find(nodes, k2);\\n            nodes[groupHead2].parent = groupHead1;\\n            nodes[groupHead2].value = nodes[k1].value * values[i] / nodes[k2].value;\\n        }\\n\\n        // query now\\n        double[] result = new double[query.length];\\n        for (int i = 0; i < query.length; ++i) {\\n            Integer k1 = mIdTable.get(query[i][0]);\\n            Integer k2 = mIdTable.get(query[i][1]);\\n            if (k1 == null || k2 == null) result[i] = -1d;\\n            else {\\n                int groupHead1 = find(nodes, k1);\\n                int groupHead2 = find(nodes, k2);\\n                if (groupHead1 != groupHead2) result[i] = -1d;\\n                else result[i] = nodes[k2].value / nodes[k1].value;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public int find(Node[] nodes, int k) {\\n        int p = k;\\n        while (nodes[p].parent != p) {\\n            p = nodes[p].parent;\\n            // compress\\n            nodes[k].value *= nodes[p].value;\\n        }\\n        // compress\\n        nodes[k].parent = p;\\n        return p;\\n    }\\n\\n    private static class Node {\\n        int    parent;\\n        double value;\\n\\n        public Node(int index) {\\n            this.parent = index;\\n            this.value = 1d;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "``` java\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n        double[] result = new double[query.length];\\n        // filter unexpected words\\n        // \\u8fc7\\u6ee4\\u6389\\u6ca1\\u6709\\u9047\\u89c1\\u8fc7\\u7684\\u5b57\\u7b26\\n        Set<String> words = new HashSet<>();\\n        for (String[] strs : equations) {\\n            words.add(strs[0]);\\n            words.add(strs[1]);\\n        }\\n        for (int i = 0; i < query.length; ++i) {\\n            String[] keys = query[i];\\n            if (!words.contains(keys[0]) || !words.contains(keys[1])) result[i] = -1.0d;\\n            else {\\n                Stack<Integer> stack = new Stack<>();\\n                result[i] = helper(equations, values, keys, stack);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public double helper(String[][] equations, double[] values, String[] keys, Stack<Integer> stack) {\\n        // \\u76f4\\u63a5\\u67e5\\u627e\\uff0ckey\\u7684\\u987a\\u5e8f\\u6709\\u6b63\\u53cd\\n        // look up equations directly\\n        for (int i = 0; i < equations.length; ++i) {\\n            if (equations[i][0].equals(keys[0]) && equations[i][1].equals(keys[1])) return values[i];\\n            if (equations[i][0].equals(keys[1]) && equations[i][1].equals(keys[0])) return 1 / values[i];\\n        }\\n        // lookup equations by other equations\\n        // \\u95f4\\u63a5\\u67e5\\u627e\\uff0ckey\\u7684\\u987a\\u5e8f\\u4e5f\\u6709\\u6b63\\u53cd\\n        for (int i = 0; i < equations.length; ++i) {\\n            if (!stack.contains(i) && keys[0].equals(equations[i][0])) {\\n                stack.push(i);\\n                double temp = values[i] * helper(equations, values, new String[]{equations[i][1], keys[1]}, stack);\\n                if (temp > 0) return temp;\\n                else stack.pop();\\n            }\\n            if (!stack.contains(i) && keys[0].equals(equations[i][1])) {\\n                stack.push(i);\\n                double temp = helper(equations, values, new String[]{equations[i][0], keys[1]}, stack) / values[i];\\n                if (temp > 0) return temp;\\n                else stack.pop();\\n            }\\n        }\\n        // \\u67e5\\u4e0d\\u5230\\uff0c\\u8fd4\\u56de-1\\n        return -1.0d;\\n    }\\n```\n``` java\\npublic double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n        // use table save string to integer\\n        Map<String, Integer> table = new HashMap<>();\\n        int len = 0;\\n        for (String[] strings : equations)\\n            for (String string : strings)\\n                if (!table.containsKey(string)) table.put(string, len++);\\n\\n        // init map by direct equation\\n        double[][] map = new double[len][len];\\n        for (int i = 0; i < len; ++i)\\n            for (int j = 0; j < len; ++j)\\n                map[i][j] = (i == j ? 1.0d : -1.0d);\\n        for (int i = 0; i < equations.length; ++i) {\\n            String[] keys = equations[i];\\n            int row = table.get(keys[0]);\\n            int col = table.get(keys[1]);\\n            map[row][col] = values[i];\\n            map[col][row] = 1 / values[i];\\n        }\\n\\n        // floyd-warshall like algorithm\\n        for (int i = 0; i < len; ++i) {\\n            for (int j = 0; j < len; ++j) {\\n                for (int k = 0; k < len; ++k) {\\n                    if (map[j][i] >= 0d && map[i][k] >= 0d) map[j][k] = map[j][i] * map[i][k];\\n                }\\n            }\\n        }\\n\\n        // query now\\n        double[] result = new double[query.length];\\n        for (int i = 0; i < query.length; ++i) {\\n            String[] keys = query[i];\\n            Integer row = table.get(keys[0]);\\n            Integer col = table.get(keys[1]);\\n            if (row == null || col == null) result[i] = -1.0d;\\n            else result[i] = map[row][col];\\n        }\\n        return result;\\n    }\\n```\n``` java\\npublic double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n\\n        // map string to integer\\n        Map<String, Integer> mIdTable = new HashMap<>();\\n        int len = 0;\\n        for (String[] words : equations)\\n            for (String word : words)\\n                if (!mIdTable.containsKey(word)) mIdTable.put(word, len++);\\n\\n        // init parent index and value\\n        Node[] nodes = new Node[len];\\n        for (int i = 0; i < len; ++i) nodes[i] = new Node(i);\\n\\n        // union, you can take an example as follows\\n        // (a/b=3)->(c/d=6)->(b/d=12)\\n        for (int i = 0; i < equations.length; ++i) {\\n            String[] keys = equations[i];\\n            int k1 = mIdTable.get(keys[0]);\\n            int k2 = mIdTable.get(keys[1]);\\n            int groupHead1 = find(nodes, k1);\\n            int groupHead2 = find(nodes, k2);\\n            nodes[groupHead2].parent = groupHead1;\\n            nodes[groupHead2].value = nodes[k1].value * values[i] / nodes[k2].value;\\n        }\\n\\n        // query now\\n        double[] result = new double[query.length];\\n        for (int i = 0; i < query.length; ++i) {\\n            Integer k1 = mIdTable.get(query[i][0]);\\n            Integer k2 = mIdTable.get(query[i][1]);\\n            if (k1 == null || k2 == null) result[i] = -1d;\\n            else {\\n                int groupHead1 = find(nodes, k1);\\n                int groupHead2 = find(nodes, k2);\\n                if (groupHead1 != groupHead2) result[i] = -1d;\\n                else result[i] = nodes[k2].value / nodes[k1].value;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public int find(Node[] nodes, int k) {\\n        int p = k;\\n        while (nodes[p].parent != p) {\\n            p = nodes[p].parent;\\n            // compress\\n            nodes[k].value *= nodes[p].value;\\n        }\\n        // compress\\n        nodes[k].parent = p;\\n        return p;\\n    }\\n\\n    private static class Node {\\n        int    parent;\\n        double value;\\n\\n        public Node(int index) {\\n            this.parent = index;\\n            this.value = 1d;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88310,
                "title": "c-0ms-23-lines-dfs-solution-with-comments",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<pair<string, double>>> children;                               // adjacency list\\n    \\n    pair<bool, double> search(string& a, string& b, unordered_set<string>& visited, double val) {\\n        if (visited.count(a) == 0) {\\n            visited.insert(a);                                                                  // mark a as visited\\n            for (auto p : children[a]) {\\n                double temp = val * p.second;                                                   // potential result\\n                if (p.first == b) { return make_pair(true, temp); }                             // found result\\n                \\n                auto result = search(p.first, b, visited, temp);\\n                if (result.first) { return result; }\\n            }\\n        }\\n        return make_pair(false, -1.0);\\n    }\\n    \\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries) {\\n        vector<double> ans;\\n        \\n        for (int i = 0; i < equations.size(); i++) {\\n            children[equations[i].first].push_back(make_pair(equations[i].second, values[i]));      // build graph list a->b\\n            children[equations[i].second].push_back(make_pair(equations[i].first, 1.0 / values[i]));// build graph list b->a\\n        }\\n        \\n        for (auto p : queries) {\\n            unordered_set<string> visited;                                                          // to record visited nodes\\n            // p.first == p.second is special case\\n            ans.push_back(p.first == p.second && children.count(p.first) ? 1.0 : search(p.first, p.second, visited, 1.0).second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<pair<string, double>>> children;                               // adjacency list\\n    \\n    pair<bool, double> search(string& a, string& b, unordered_set<string>& visited, double val) {\\n        if (visited.count(a) == 0) {\\n            visited.insert(a);                                                                  // mark a as visited\\n            for (auto p : children[a]) {\\n                double temp = val * p.second;                                                   // potential result\\n                if (p.first == b) { return make_pair(true, temp); }                             // found result\\n                \\n                auto result = search(p.first, b, visited, temp);\\n                if (result.first) { return result; }\\n            }\\n        }\\n        return make_pair(false, -1.0);\\n    }\\n    \\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries) {\\n        vector<double> ans;\\n        \\n        for (int i = 0; i < equations.size(); i++) {\\n            children[equations[i].first].push_back(make_pair(equations[i].second, values[i]));      // build graph list a->b\\n            children[equations[i].second].push_back(make_pair(equations[i].first, 1.0 / values[i]));// build graph list b->a\\n        }\\n        \\n        for (auto p : queries) {\\n            unordered_set<string> visited;                                                          // to record visited nodes\\n            // p.first == p.second is special case\\n            ans.push_back(p.first == p.second && children.count(p.first) ? 1.0 : search(p.first, p.second, visited, 1.0).second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538681,
                "title": "python-2-solutions-dfs-floy-warshall-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: DFS**\\n```python\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        graph = defaultdict(list)\\n        for (a, b), v in zip(equations, values):\\n            graph[a].append([b, v])\\n            graph[b].append([a, 1/v])\\n            \\n        def dfs(src, dst, res, seen):\\n            if src == dst: return res\\n            if src in seen: return -1\\n            seen.add(src)\\n            for nei, w in graph[src]:\\n                tmp = dfs(nei, dst, res * w, seen)\\n                if tmp != -1:\\n                    return tmp\\n            return -1\\n            \\n        ans = []\\n        for a, b in queries:\\n            if a not in graph or b not in graph:\\n                ans.append(-1)\\n            else:\\n                ans.append(dfs(a, b, 1, set()))\\n        return ans\\n```\\nComplexity:\\n- Time: `O(E + Q * E)`, where `E <= 20` is length of `equations`, `Q <= 20` is number of queries.\\n- Space: `O(E)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Floy Warshall**\\n```python\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        quot = defaultdict(dict)\\n        for (a, b), v in zip(equations, values):\\n            quot[a][a] = quot[b][b] = 1\\n            quot[a][b] = v\\n            quot[b][a] = 1/v\\n            \\n        for k in quot:\\n            for i in quot[k]:\\n                for j in quot[k]:\\n                    quot[i][j] = quot[i][k] * quot[k][j]\\n            \\n        return [quot[a].get(b, -1) for a, b in queries]\\n```\\nComplexity:\\n- Time: `O(E + V^3 + Q)`, where `E <= 20` is length of `equations`, `Q <= 20` is number of queries, `V <= E+1` is number of variables.\\n- Space: `O(E)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        graph = defaultdict(list)\\n        for (a, b), v in zip(equations, values):\\n            graph[a].append([b, v])\\n            graph[b].append([a, 1/v])\\n            \\n        def dfs(src, dst, res, seen):\\n            if src == dst: return res\\n            if src in seen: return -1\\n            seen.add(src)\\n            for nei, w in graph[src]:\\n                tmp = dfs(nei, dst, res * w, seen)\\n                if tmp != -1:\\n                    return tmp\\n            return -1\\n            \\n        ans = []\\n        for a, b in queries:\\n            if a not in graph or b not in graph:\\n                ans.append(-1)\\n            else:\\n                ans.append(dfs(a, b, 1, set()))\\n        return ans\\n```\n```python\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        quot = defaultdict(dict)\\n        for (a, b), v in zip(equations, values):\\n            quot[a][a] = quot[b][b] = 1\\n            quot[a][b] = v\\n            quot[b][a] = 1/v\\n            \\n        for k in quot:\\n            for i in quot[k]:\\n                for j in quot[k]:\\n                    quot[i][j] = quot[i][k] * quot[k][j]\\n            \\n        return [quot[a].get(b, -1) for a, b in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867697,
                "title": "python-dfs-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=EfkvVigVou0)\\nhttps://www.youtube.com/watch?v=EfkvVigVou0\\n```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        # Step 1. Build the Graph\\n        graph = collections.defaultdict(dict)\\n        for (x, y), val in zip(equations,values):\\n            graph[x][y] = val\\n            graph[y][x] = 1.0 / val\\n        print(graph)\\n        \\n        # Step 2. DFS function\\n        def dfs(x, y, visited):\\n            # neither x not y exists\\n            if x not in graph or y not in graph:\\n                return -1.0\\n            \\n            # x points to y\\n            if y in graph[x]:\\n                return graph[x][y]\\n            \\n            # x maybe connected to y through other nodes\\n            # use dfs to see if there is a path from x to y\\n            for i in graph[x]:\\n                if i not in visited:\\n                    visited.add(i)\\n                    temp = dfs(i, y, visited)\\n                    if temp == -1:\\n                        continue\\n                    else:\\n                        return graph[x][i] * temp\\n            return -1\\n            \\n        # go through each of the queries and find the value\\n        res = []\\n        for query in queries:\\n            res.append(dfs(query[0], query[1], set()))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        # Step 1. Build the Graph\\n        graph = collections.defaultdict(dict)\\n        for (x, y), val in zip(equations,values):\\n            graph[x][y] = val\\n            graph[y][x] = 1.0 / val\\n        print(graph)\\n        \\n        # Step 2. DFS function\\n        def dfs(x, y, visited):\\n            # neither x not y exists\\n            if x not in graph or y not in graph:\\n                return -1.0\\n            \\n            # x points to y\\n            if y in graph[x]:\\n                return graph[x][y]\\n            \\n            # x maybe connected to y through other nodes\\n            # use dfs to see if there is a path from x to y\\n            for i in graph[x]:\\n                if i not in visited:\\n                    visited.add(i)\\n                    temp = dfs(i, y, visited)\\n                    if temp == -1:\\n                        continue\\n                    else:\\n                        return graph[x][i] * temp\\n            return -1\\n            \\n        # go through each of the queries and find the value\\n        res = []\\n        for query in queries:\\n            res.append(dfs(query[0], query[1], set()))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867030,
                "title": "python-dfs-o-v-e-explained",
                "content": "First of all, if we look carefully at this problem we can see, that it is graph problem: let our variables be nodes and divistions be connections. It is also given, that there is no contradictions in this graph and divisions by zero, so we do not need to think about it. Let us use `dfs(start, comp, w)` function, with parameters:\\n1. `start` is current node(variable) we visit\\n2. `comp` number of connected component: imagine we have `x/y = 4, y/z = 3` and `a/b = 2`, then first component is `(x,y,z)` and second is `(a,b)`.\\n3. `w` is current weight or value of our node: imagine that we start with node `x`, then we have weight for `x = 1`, weight for `y = 1/4` and weight for `z = 1/12`.\\n\\nSo, what `dfs` function will do? for given `start` value it traverse our graph and check if `self.w[j][0] = -1`. We define `for var in varbs: self.w[var] = [-1,-1]` in the beginning: first value is responsible for number of connected component and second number is responsible for weight. So, if we have neighbour, which is not visited yet, we run `dfs` recursively.\\n\\nMain function: first we grab the names of all variables (nodes), using `varbs = set(chain(*equations))`, then we create defaultdict of edges: for every equation we add two connections: one for direct and one for inversed. Next we iterate over all variables and run `dfs` if this variable(node) is not visited yet.\\nFinally, we traverse `queries` and we found that one of the variables is not in `varbs` or they both are, but they are in two different connected components, we return `-1`. If it is not the case, we return division of weights.\\n\\n**Complexity**: Time complexity is `O(E+V+Q)`, where `V` is number of variables (nodes), `E` is number of equations (edges) and `Q` is number of queries, because complexity of dfs is `O(E+V)` and we also have `Q` queries. Space complexity is also `O(E+V+Q)` to keep all nodes, edges and answers for queries.\\n\\n```\\nclass Solution:\\n    def dfs(self, start, comp, w):\\n        self.w[start] = [comp, w]\\n        for j, weight in self.edges[start]:\\n            if self.w[j][0] == -1:\\n                self.dfs(j, comp, w/weight)\\n      \\n    def calcEquation(self, equations, values, queries):\\n        varbs = set(chain(*equations))\\n        result, it = [], 0\\n        self.edges = defaultdict(list)\\n        for it, [i,j] in enumerate(equations):\\n            self.edges[i].append([j, values[it]])\\n            self.edges[j].append([i, 1/values[it]])\\n            \\n        self.w = defaultdict(list)\\n        for var in varbs: self.w[var] = [-1,-1]\\n            \\n        for key in varbs:\\n            if self.w[key][0] == -1:\\n                self.dfs(key, it, 1)\\n                it += 1\\n                \\n        for a,b in queries:\\n            if a not in varbs or b not in varbs or self.w[a][0] != self.w[b][0]:\\n                result.append(-1.0)\\n            else:\\n                result.append(self.w[a][1]/self.w[b][1])\\n                \\n        return result\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, start, comp, w):\\n        self.w[start] = [comp, w]\\n        for j, weight in self.edges[start]:\\n            if self.w[j][0] == -1:\\n                self.dfs(j, comp, w/weight)\\n      \\n    def calcEquation(self, equations, values, queries):\\n        varbs = set(chain(*equations))\\n        result, it = [], 0\\n        self.edges = defaultdict(list)\\n        for it, [i,j] in enumerate(equations):\\n            self.edges[i].append([j, values[it]])\\n            self.edges[j].append([i, 1/values[it]])\\n            \\n        self.w = defaultdict(list)\\n        for var in varbs: self.w[var] = [-1,-1]\\n            \\n        for key in varbs:\\n            if self.w[key][0] == -1:\\n                self.dfs(key, it, 1)\\n                it += 1\\n                \\n        for a,b in queries:\\n            if a not in varbs or b not in varbs or self.w[a][0] != self.w[b][0]:\\n                result.append(-1.0)\\n            else:\\n                result.append(self.w[a][1]/self.w[b][1])\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88196,
                "title": "simple-n-clean-dfs-solution-in-python",
                "content": "A series of equations `A / B = k` can be seen as a graph in which nodes are the dividend and divisor A and B and weights are the result of the division. So we simply create the graph and traverse it with DFS/BFS to get our result.\\n\\nComplexity is `K * O(N + M)` where N and M are the number of nodes and edges, and `K` is the number of queries. How many nodes can we have? It's `2 * E`, where `E` is the number of equations (2 different nodes per each equation). We can have at most `E` edges in the graph. \\n\\nSo total complexity is `O(K * E)`, with `O(E)` additional space for the graph.\\n\\n```\\nclass Solution(object):\\n    def calcEquation(self, equations, values, queries):\\n        \\n        def dfs(start, end, path, paths):\\n            if start == end and start in G:\\n                paths[0] = path\\n                return\\n            if start in vis: \\n                return\\n            vis.add(start)\\n            for node in G[start]:\\n                dfs(node, end, path * W[start, node], paths)\\n        \\n        \\n        G, W = collections.defaultdict(set), collections.defaultdict(float)\\n        for (A, B), V in zip(equations, values):\\n            G[A], G[B] = G[A] | {B}, G[B] | {A}\\n            W[A, B], W[B, A] = V, 1.0 / V\\n            \\n        res = []\\n        for X, Y in queries:\\n            paths, vis = [-1.0], set()\\n            dfs(X, Y, 1.0, paths)\\n            res += paths[0],\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def calcEquation(self, equations, values, queries):\\n        \\n        def dfs(start, end, path, paths):\\n            if start == end and start in G:\\n                paths[0] = path\\n                return\\n            if start in vis: \\n                return\\n            vis.add(start)\\n            for node in G[start]:\\n                dfs(node, end, path * W[start, node], paths)\\n        \\n        \\n        G, W = collections.defaultdict(set), collections.defaultdict(float)\\n        for (A, B), V in zip(equations, values):\\n            G[A], G[B] = G[A] | {B}, G[B] | {A}\\n            W[A, B], W[B, A] = V, 1.0 / V\\n            \\n        res = []\\n        for X, Y in queries:\\n            paths, vis = [-1.0], set()\\n            dfs(X, Y, 1.0, paths)\\n            res += paths[0],\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88228,
                "title": "java-ac-solution-with-explanation",
                "content": "The logic I have used is to construct a Map of maps, that contains all possible a/b and b/a from the given input and their values.\\n\\nFor the given input\\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ]. values = [2.0, 3.0]\\n\\nThe map that gets constructed is :\\n\\n[a:  [b:2.0]\\nb:  [a:0.5], [c:3.0]\\nc:  [b:0.333]]\\n\\nFor each key in the outer map, the value represents a map, that denotes all possible denominators for the key and the corresponding key/value.\\n\\nWith this map constructed, the logic for evaluating a query is simple in a dfs style:\\n\\nTo find any m/n, if the map of m contains x1, x2, x3\\nthen \\nm/n = m/x1 * x1/n if this gives a valid result or m/x2 * x2/n or m/x3 * x3/n \\n\\n\\n```\\npublic static double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n        Map<String, Map<String, Double>> numMap = new HashMap<>();\\n        int i = 0;\\n        for(String[] str : equations) {\\n            insertPairs(numMap, str[0], str[1], values[i]);\\n            insertPairs(numMap, str[1], str[0], 1.0/values[i]);\\n            i++;\\n        }\\n\\n        double[] res = new double[query.length];\\n        i = 0;\\n        for(String[] q: query) {\\n            Double resObj = handleQuery(q[0], q[1], numMap, new HashSet<>());\\n            res[i++] = (resObj != null) ? resObj : -1.0;\\n        }\\n        return res;\\n    }\\n\\n    public static void insertPairs(Map<String, Map<String, Double>> numMap, String num, String denom, Double value) {\\n        Map<String, Double> denomMap = numMap.get(num);\\n        if(denomMap == null) {\\n            denomMap = new HashMap<>();\\n            numMap.put(num, denomMap);\\n        }\\n        denomMap.put(denom, value);\\n    }\\n\\n    public static Double handleQuery(String num, String denom, Map<String, Map<String, Double>> numMap, Set<String> visitedSet) {\\n        String dupeKey = num+\":\"+denom;\\n        if(visitedSet.contains(dupeKey)) return null;\\n        if(!numMap.containsKey(num) || !numMap.containsKey(denom)) return null;\\n        if(num.equals(denom)) return 1.0;\\n\\n        Map<String, Double> denomMap = numMap.get(num);\\n        visitedSet.add(dupeKey);\\n        for(String key : denomMap.keySet()) {\\n            Double res = handleQuery(key, denom, numMap, visitedSet);\\n            if(res != null) {\\n                return denomMap.get(key) * res;\\n            }\\n        }\\n        visitedSet.remove(dupeKey);\\n        return null;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n        Map<String, Map<String, Double>> numMap = new HashMap<>();\\n        int i = 0;\\n        for(String[] str : equations) {\\n            insertPairs(numMap, str[0], str[1], values[i]);\\n            insertPairs(numMap, str[1], str[0], 1.0/values[i]);\\n            i++;\\n        }\\n\\n        double[] res = new double[query.length];\\n        i = 0;\\n        for(String[] q: query) {\\n            Double resObj = handleQuery(q[0], q[1], numMap, new HashSet<>());\\n            res[i++] = (resObj != null) ? resObj : -1.0;\\n        }\\n        return res;\\n    }\\n\\n    public static void insertPairs(Map<String, Map<String, Double>> numMap, String num, String denom, Double value) {\\n        Map<String, Double> denomMap = numMap.get(num);\\n        if(denomMap == null) {\\n            denomMap = new HashMap<>();\\n            numMap.put(num, denomMap);\\n        }\\n        denomMap.put(denom, value);\\n    }\\n\\n    public static Double handleQuery(String num, String denom, Map<String, Map<String, Double>> numMap, Set<String> visitedSet) {\\n        String dupeKey = num+\":\"+denom;\\n        if(visitedSet.contains(dupeKey)) return null;\\n        if(!numMap.containsKey(num) || !numMap.containsKey(denom)) return null;\\n        if(num.equals(denom)) return 1.0;\\n\\n        Map<String, Double> denomMap = numMap.get(num);\\n        visitedSet.add(dupeKey);\\n        for(String key : denomMap.keySet()) {\\n            Double res = handleQuery(key, denom, numMap, visitedSet);\\n            if(res != null) {\\n                return denomMap.get(key) * res;\\n            }\\n        }\\n        visitedSet.remove(dupeKey);\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 985648,
                "title": "100-faster-c-solution-using-dfs",
                "content": "\\tclass Solution {\\n\\tprivate:\\n\\t\\tdouble find(unordered_map<string, vector<pair<string, double>>> &grf, unordered_set<string> visited, string start, string end){\\n\\t\\t\\tif(grf.find(start) == grf.end() || grf.find(end) == grf.end()) return -1.0; // return -1 if start and end not exist in adj. list\\n\\n\\t\\t\\tif(start == end) return 1.0; //if we are at end\\n\\n\\t\\t\\tvisited.insert(start); // mark as visited \\n\\n\\t\\t\\tfor(auto next : grf[start]){\\n\\t\\t\\t\\tif(visited.count(next.first)==0){\\n\\t\\t\\t\\t\\tdouble res = find(grf, visited, next.first, end);\\n\\n\\t\\t\\t\\t\\tif(res != -1.0){\\n\\t\\t\\t\\t\\t\\treturn res*next.second;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1.0;\\n\\t\\t} \\n\\n\\n\\tpublic:\\n\\t\\tvector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n\\t\\t\\tunordered_map<string, vector<pair<string, double>>> grf;\\n\\n\\t\\t\\tfor(int i = 0; i < equations.size(); i++){ // making adj. list for each edge\\n\\t\\t\\t\\tgrf[equations[i][0]].push_back({equations[i][1], values[i]});\\n\\t\\t\\t\\tgrf[equations[i][1]].push_back({equations[i][0], 1/values[i]});\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<double> ans;\\n\\n\\t\\t\\tfor(auto q: queries){\\n\\t\\t\\t\\tunordered_set<string> visited; // track previous visited nodes  in order to avoid infinite loop\\n\\t\\t\\t\\tdouble res = find(grf, visited, q[0], q[1]);  // go for current query\\n\\t\\t\\t\\tans.push_back(res);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tprivate:\\n\\t\\tdouble find(unordered_map<string, vector<pair<string, double>>> &grf, unordered_set<string> visited, string start, string end){\\n\\t\\t\\tif(grf.find(start) == grf.end() || grf.find(end) == grf.end()) return -1.0; // return -1 if start and end not exist in adj. list\\n\\n\\t\\t\\tif(start == end) return 1.0; //if we are at end\\n\\n\\t\\t\\tvisited.insert(start); // mark as visited \\n\\n\\t\\t\\tfor(auto next : grf[start]){\\n\\t\\t\\t\\tif(visited.count(next.first)==0){\\n\\t\\t\\t\\t\\tdouble res = find(grf, visited, next.first, end);\\n\\n\\t\\t\\t\\t\\tif(res != -1.0){\\n\\t\\t\\t\\t\\t\\treturn res*next.second;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1248963,
                "title": "java-clean-concise-optimal-code-depth-first-search-algorithm-90-faster-solution",
                "content": "```\\nclass Edge {\\n    \\n    String v;\\n    double value;\\n    \\n    public Edge (String v, double value) {\\n        \\n        this.v = v;\\n        this.value = value;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    public void addEdge (Map<String, List<Edge>> map, String u, String v, double value) {\\n        \\n        if (!map.containsKey (u)) {\\n            map.put (u, new ArrayList<> ());\\n        }\\n        \\n        map.get (u).add (new Edge (v, value));\\n    }\\n    \\n    public double dfs (Map<String, List<Edge>> map, Set<String> set, String u, String v) {\\n        \\n        if (!map.containsKey (u) || !map.containsKey (v)) {\\n            return -1;\\n        }\\n        else if (u.equals (v)) {\\n            return 1;\\n        }\\n        \\n        for (Edge edge : map.get (u)) {\\n            if (set.contains (edge.v)) {\\n                continue;\\n            }\\n            else if (edge.v.equals (v)) {\\n                return edge.value;\\n            }\\n            \\n            set.add (u);\\n            double val = dfs (map, set, edge.v, v);\\n            if (val != -1) {\\n                return val * edge.value;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        \\n        double[] answer = new double[queries.size ()];\\n        Map<String, List<Edge>> map = new HashMap<> ();\\n        \\n        for (int i = 0; i < values.length; i++) {\\n            List<String> equation = equations.get (i);\\n            addEdge (map, equation.get (0), equation.get (1), values[i]);\\n            addEdge (map, equation.get (1), equation.get (0), 1 / values[i]);\\n        }\\n        \\n        for (int i = 0; i < answer.length; i++) {\\n            List<String> query = queries.get (i);\\n            answer[i] = dfs (map, new HashSet<> (), query.get (0), query.get (1));\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Edge {\\n    \\n    String v;\\n    double value;\\n    \\n    public Edge (String v, double value) {\\n        \\n        this.v = v;\\n        this.value = value;\\n    }\\n}\\n\\nclass Solution {\\n    \\n    public void addEdge (Map<String, List<Edge>> map, String u, String v, double value) {\\n        \\n        if (!map.containsKey (u)) {\\n            map.put (u, new ArrayList<> ());\\n        }\\n        \\n        map.get (u).add (new Edge (v, value));\\n    }\\n    \\n    public double dfs (Map<String, List<Edge>> map, Set<String> set, String u, String v) {\\n        \\n        if (!map.containsKey (u) || !map.containsKey (v)) {\\n            return -1;\\n        }\\n        else if (u.equals (v)) {\\n            return 1;\\n        }\\n        \\n        for (Edge edge : map.get (u)) {\\n            if (set.contains (edge.v)) {\\n                continue;\\n            }\\n            else if (edge.v.equals (v)) {\\n                return edge.value;\\n            }\\n            \\n            set.add (u);\\n            double val = dfs (map, set, edge.v, v);\\n            if (val != -1) {\\n                return val * edge.value;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        \\n        double[] answer = new double[queries.size ()];\\n        Map<String, List<Edge>> map = new HashMap<> ();\\n        \\n        for (int i = 0; i < values.length; i++) {\\n            List<String> equation = equations.get (i);\\n            addEdge (map, equation.get (0), equation.get (1), values[i]);\\n            addEdge (map, equation.get (1), equation.get (0), 1 / values[i]);\\n        }\\n        \\n        for (int i = 0; i < answer.length; i++) {\\n            List<String> query = queries.get (i);\\n            answer[i] = dfs (map, new HashSet<> (), query.get (0), query.get (1));\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310971,
                "title": "easy-c-0ms-solution-commented-map-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        //we will be using unordered_map to store the data\\n        unordered_map<string,unordered_map<string,double>> adj;\\n        \\n        //create a adj list \\n        createAdjList(adj,equations,values);\\n        \\n        vector<double> res(queries.size());\\n        //calculate result of every query\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            unordered_set<string> visited;\\n            res[i]=dfs(queries[i][0],queries[i][1],visited,adj);\\n        }\\n        return res;\\n        \\n    }\\n    \\n    double dfs(string start,string end,unordered_set<string>& visited,unordered_map<string,unordered_map<string,double>>& adj)\\n    {\\n        //we cant find the  given string\\n        if(adj.find(start)==adj.end())\\n            return -1.0;\\n        //if we have got our string end \\n        if(adj[start].find(end)!=adj[start].end())\\n            return adj[start][end];\\n        visited.insert(start);\\n        //explore all possible paths \\n        //if any one of them doesnot returns -1.0 we got our solution \\n        for(auto i:adj[start])\\n        {\\n            //we dont want to revisit our previously visited strings\\n            if(!visited.count(i.first))\\n            {\\n                double ans=dfs(i.first,end,visited,adj);\\n                if(ans!=-1.0)\\n                    return (double)ans * (i.second);\\n            }       \\n        }\\n        return -1.0;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    void createAdjList(unordered_map<string,unordered_map<string,double>>& adj,vector<vector<string>>&  equations,vector<double>& values)\\n    {\\n        for(int i=0;i<equations.size();i++)\\n        {\\n            string from=equations[i][0];\\n            string to=equations[i][1];\\n            adj[from].insert({to,values[i]});\\n            adj[to].insert({from,(double)1/values[i]});\\n        }\\n            \\n    }\\n};\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Evaluate Division.\\nMemory Usage: 8.2 MB, less than 82.70% of C++ online submissions for Evaluate Division.\\n\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        //we will be using unordered_map to store the data\\n        unordered_map<string,unordered_map<string,double>> adj;\\n        \\n        //create a adj list \\n        createAdjList(adj,equations,values);\\n        \\n        vector<double> res(queries.size());\\n        //calculate result of every query\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            unordered_set<string> visited;\\n            res[i]=dfs(queries[i][0],queries[i][1],visited,adj);\\n        }\\n        return res;\\n        \\n    }\\n    \\n    double dfs(string start,string end,unordered_set<string>& visited,unordered_map<string,unordered_map<string,double>>& adj)\\n    {\\n        //we cant find the  given string\\n        if(adj.find(start)==adj.end())\\n            return -1.0;\\n        //if we have got our string end \\n        if(adj[start].find(end)!=adj[start].end())\\n            return adj[start][end];\\n        visited.insert(start);\\n        //explore all possible paths \\n        //if any one of them doesnot returns -1.0 we got our solution \\n        for(auto i:adj[start])\\n        {\\n            //we dont want to revisit our previously visited strings\\n            if(!visited.count(i.first))\\n            {\\n                double ans=dfs(i.first,end,visited,adj);\\n                if(ans!=-1.0)\\n                    return (double)ans * (i.second);\\n            }       \\n        }\\n        return -1.0;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    void createAdjList(unordered_map<string,unordered_map<string,double>>& adj,vector<vector<string>>&  equations,vector<double>& values)\\n    {\\n        for(int i=0;i<equations.size();i++)\\n        {\\n            string from=equations[i][0];\\n            string to=equations[i][1];\\n            adj[from].insert({to,values[i]});\\n            adj[to].insert({from,(double)1/values[i]});\\n        }\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543150,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for first 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n\\n# or\\n\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\n\\nThe problem can be solved using graph traversal, specifically breadth-first search (BFS). We can represent the given equations as a graph, where each variable is a node, and the values represent the edges between the nodes. The division result between two variables can be found by traversing from the dividend node to the divisor node and multiplying the edge values encountered along the path.\\n\\n- Build the graph: Iterate through the given equations and values, and construct an adjacency map that represents the graph. For each equation (a / b = k), add edges (a, b) and (b, a) to the graph with edge values k and 1/k, respectively.\\n\\n- Evaluate queries: For each query (x, y), perform a BFS starting from node x and searching for node y. During the BFS traversal, keep track of the product of the edge values encountered. If y is reached, return the product as the division result. If y is not reached or either x or y is not present in the graph, return -1.\\n\\n# Intuition:\\n\\nThe problem can be viewed as finding a path in a graph from the dividend node to the divisor node while keeping track of the product of the edge values. Each node represents a variable, and the edge values represent the division results between variables. By performing a BFS, we can explore all possible paths and find the division result if it exists.\\n\\nBy building the graph and using BFS, we can efficiently evaluate the division queries by traversing the graph and multiplying the edge values encountered along the way. If the query variables are not present in the graph or if the destination variable is not reachable from the source variable, we return -1 to indicate that the division result is not possible.\\n\\nOverall, the approach leverages graph traversal and the properties of division to evaluate the division results efficiently.\\n\\n\\n\\n\\n\\n\\n```Python []\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def calcEquation(self, equations, values, queries):\\n        graph = self.buildGraph(equations, values)\\n        results = []\\n        \\n        for dividend, divisor in queries:\\n            if dividend not in graph or divisor not in graph:\\n                results.append(-1.0)\\n            else:\\n                result = self.bfs(dividend, divisor, graph)\\n                results.append(result)\\n        \\n        return results\\n    \\n    def buildGraph(self, equations, values):\\n        graph = defaultdict(dict)\\n        \\n        for (dividend, divisor), value in zip(equations, values):\\n            graph[dividend][divisor] = value\\n            graph[divisor][dividend] = 1.0 / value\\n        \\n        return graph\\n    \\n    def bfs(self, start, end, graph):\\n        queue = deque([(start, 1.0)])\\n        visited = set()\\n        \\n        while queue:\\n            node, value = queue.popleft()\\n            \\n            if node == end:\\n                return value\\n            \\n            visited.add(node)\\n            \\n            for neighbor, weight in graph[node].items():\\n                if neighbor not in visited:\\n                    queue.append((neighbor, value * weight))\\n        \\n        return -1.0\\n\\n```\\n```Java []\\n\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        Map<String, Map<String, Double>> graph = buildGraph(equations, values);\\n        double[] results = new double[queries.size()];\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            List<String> query = queries.get(i);\\n            String dividend = query.get(0);\\n            String divisor = query.get(1);\\n\\n            if (!graph.containsKey(dividend) || !graph.containsKey(divisor)) {\\n                results[i] = -1.0;\\n            } else {\\n                results[i] = bfs(dividend, divisor, graph);\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    private Map<String, Map<String, Double>> buildGraph(List<List<String>> equations, double[] values) {\\n        Map<String, Map<String, Double>> graph = new HashMap<>();\\n\\n        for (int i = 0; i < equations.size(); i++) {\\n            List<String> equation = equations.get(i);\\n            String dividend = equation.get(0);\\n            String divisor = equation.get(1);\\n            double value = values[i];\\n\\n            graph.putIfAbsent(dividend, new HashMap<>());\\n            graph.putIfAbsent(divisor, new HashMap<>());\\n            graph.get(dividend).put(divisor, value);\\n            graph.get(divisor).put(dividend, 1.0 / value);\\n        }\\n\\n        return graph;\\n    }\\n\\n    private double bfs(String start, String end, Map<String, Map<String, Double>> graph) {\\n        Queue<Pair<String, Double>> queue = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        queue.offer(new Pair<>(start, 1.0));\\n\\n        while (!queue.isEmpty()) {\\n            Pair<String, Double> pair = queue.poll();\\n            String node = pair.getKey();\\n            double value = pair.getValue();\\n\\n            if (node.equals(end)) {\\n                return value;\\n            }\\n\\n            visited.add(node);\\n\\n            for (Map.Entry<String, Double> neighbor : graph.get(node).entrySet()) {\\n                String neighborNode = neighbor.getKey();\\n                double neighborValue = neighbor.getValue();\\n\\n                if (!visited.contains(neighborNode)) {\\n                    queue.offer(new Pair<>(neighborNode, value * neighborValue));\\n                }\\n            }\\n        }\\n\\n        return -1.0;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        unordered_map<string, unordered_map<string, double>> graph = buildGraph(equations, values);\\n        vector<double> results;\\n\\n        for (const auto& query : queries) {\\n            const string& dividend = query[0];\\n            const string& divisor = query[1];\\n\\n            if (graph.find(dividend) == graph.end() || graph.find(divisor) == graph.end()) {\\n                results.push_back(-1.0);\\n            } else {\\n                results.push_back(bfs(dividend, divisor, graph));\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\nprivate:\\n    unordered_map<string, unordered_map<string, double>> buildGraph(const vector<vector<string>>& equations, const vector<double>& values) {\\n        unordered_map<string, unordered_map<string, double>> graph;\\n\\n        for (int i = 0; i < equations.size(); i++) {\\n            const string& dividend = equations[i][0];\\n            const string& divisor = equations[i][1];\\n            double value = values[i];\\n\\n            graph[dividend][divisor] = value;\\n            graph[divisor][dividend] = 1.0 / value;\\n        }\\n\\n        return graph;\\n    }\\n\\n    double bfs(const string& start, const string& end, unordered_map<string, unordered_map<string, double>>& graph) {\\n        queue<pair<string, double>> q;\\n        unordered_set<string> visited;\\n        q.push({start, 1.0});\\n\\n        while (!q.empty()) {\\n            string node = q.front().first;\\n            double value = q.front().second;\\n            q.pop();\\n\\n            if (node == end) {\\n                return value;\\n            }\\n\\n            visited.insert(node);\\n\\n            for (const auto& neighbor : graph[node]) {\\n                const string& neighborNode = neighbor.first;\\n                double neighborValue = neighbor.second;\\n\\n                if (visited.find(neighborNode) == visited.end()) {\\n                    q.push({neighborNode, value * neighborValue});\\n                }\\n            }\\n        }\\n\\n        return -1.0;\\n    }\\n};\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Breadth-First Search"
                ],
                "code": "```Python []\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def calcEquation(self, equations, values, queries):\\n        graph = self.buildGraph(equations, values)\\n        results = []\\n        \\n        for dividend, divisor in queries:\\n            if dividend not in graph or divisor not in graph:\\n                results.append(-1.0)\\n            else:\\n                result = self.bfs(dividend, divisor, graph)\\n                results.append(result)\\n        \\n        return results\\n    \\n    def buildGraph(self, equations, values):\\n        graph = defaultdict(dict)\\n        \\n        for (dividend, divisor), value in zip(equations, values):\\n            graph[dividend][divisor] = value\\n            graph[divisor][dividend] = 1.0 / value\\n        \\n        return graph\\n    \\n    def bfs(self, start, end, graph):\\n        queue = deque([(start, 1.0)])\\n        visited = set()\\n        \\n        while queue:\\n            node, value = queue.popleft()\\n            \\n            if node == end:\\n                return value\\n            \\n            visited.add(node)\\n            \\n            for neighbor, weight in graph[node].items():\\n                if neighbor not in visited:\\n                    queue.append((neighbor, value * weight))\\n        \\n        return -1.0\\n\\n```\n```Java []\\n\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        Map<String, Map<String, Double>> graph = buildGraph(equations, values);\\n        double[] results = new double[queries.size()];\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            List<String> query = queries.get(i);\\n            String dividend = query.get(0);\\n            String divisor = query.get(1);\\n\\n            if (!graph.containsKey(dividend) || !graph.containsKey(divisor)) {\\n                results[i] = -1.0;\\n            } else {\\n                results[i] = bfs(dividend, divisor, graph);\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    private Map<String, Map<String, Double>> buildGraph(List<List<String>> equations, double[] values) {\\n        Map<String, Map<String, Double>> graph = new HashMap<>();\\n\\n        for (int i = 0; i < equations.size(); i++) {\\n            List<String> equation = equations.get(i);\\n            String dividend = equation.get(0);\\n            String divisor = equation.get(1);\\n            double value = values[i];\\n\\n            graph.putIfAbsent(dividend, new HashMap<>());\\n            graph.putIfAbsent(divisor, new HashMap<>());\\n            graph.get(dividend).put(divisor, value);\\n            graph.get(divisor).put(dividend, 1.0 / value);\\n        }\\n\\n        return graph;\\n    }\\n\\n    private double bfs(String start, String end, Map<String, Map<String, Double>> graph) {\\n        Queue<Pair<String, Double>> queue = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        queue.offer(new Pair<>(start, 1.0));\\n\\n        while (!queue.isEmpty()) {\\n            Pair<String, Double> pair = queue.poll();\\n            String node = pair.getKey();\\n            double value = pair.getValue();\\n\\n            if (node.equals(end)) {\\n                return value;\\n            }\\n\\n            visited.add(node);\\n\\n            for (Map.Entry<String, Double> neighbor : graph.get(node).entrySet()) {\\n                String neighborNode = neighbor.getKey();\\n                double neighborValue = neighbor.getValue();\\n\\n                if (!visited.contains(neighborNode)) {\\n                    queue.offer(new Pair<>(neighborNode, value * neighborValue));\\n                }\\n            }\\n        }\\n\\n        return -1.0;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        unordered_map<string, unordered_map<string, double>> graph = buildGraph(equations, values);\\n        vector<double> results;\\n\\n        for (const auto& query : queries) {\\n            const string& dividend = query[0];\\n            const string& divisor = query[1];\\n\\n            if (graph.find(dividend) == graph.end() || graph.find(divisor) == graph.end()) {\\n                results.push_back(-1.0);\\n            } else {\\n                results.push_back(bfs(dividend, divisor, graph));\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\nprivate:\\n    unordered_map<string, unordered_map<string, double>> buildGraph(const vector<vector<string>>& equations, const vector<double>& values) {\\n        unordered_map<string, unordered_map<string, double>> graph;\\n\\n        for (int i = 0; i < equations.size(); i++) {\\n            const string& dividend = equations[i][0];\\n            const string& divisor = equations[i][1];\\n            double value = values[i];\\n\\n            graph[dividend][divisor] = value;\\n            graph[divisor][dividend] = 1.0 / value;\\n        }\\n\\n        return graph;\\n    }\\n\\n    double bfs(const string& start, const string& end, unordered_map<string, unordered_map<string, double>>& graph) {\\n        queue<pair<string, double>> q;\\n        unordered_set<string> visited;\\n        q.push({start, 1.0});\\n\\n        while (!q.empty()) {\\n            string node = q.front().first;\\n            double value = q.front().second;\\n            q.pop();\\n\\n            if (node == end) {\\n                return value;\\n            }\\n\\n            visited.insert(node);\\n\\n            for (const auto& neighbor : graph[node]) {\\n                const string& neighborNode = neighbor.first;\\n                double neighborValue = neighbor.second;\\n\\n                if (visited.find(neighborNode) == visited.end()) {\\n                    q.push({neighborNode, value * neighborValue});\\n                }\\n            }\\n        }\\n\\n        return -1.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255407,
                "title": "python-union-find",
                "content": "A union-find without ranking. \\n```\\nclass DJS:\\n    def __init__(self, alphabet):\\n        self.parent = {char: char for char in alphabet}\\n        self.vals = {char: 1.0 for char in alphabet}\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x], val = self.find(self.parent[x])\\n            self.vals[x] *= val\\n        return self.parent[x], self.vals[x]\\n    \\n    def union(self, y, x, val):\\n        x, valx = self.find(x)\\n        y, valy = self.find(y)\\n        if x == y: return\\n        self.parent[y] = self.parent[x]\\n        self.vals[y] = val * valx / valy\\n        \\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        alphabet = set(sum(equations, []))\\n        ufo = DJS(alphabet)\\n        for (y, x), val in zip(equations, values):\\n            ufo.union(y, x, val)\\n            \\n        res = []\\n        for y, x in queries:\\n            if x not in alphabet or y not in alphabet: \\n                res.append(-1.0)\\n                continue\\n            y, valy = ufo.find(y)\\n            x, valx = ufo.find(x)\\n            if x == y: res.append(valy / valx)\\n            else: res.append(-1.0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass DJS:\\n    def __init__(self, alphabet):\\n        self.parent = {char: char for char in alphabet}\\n        self.vals = {char: 1.0 for char in alphabet}\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x], val = self.find(self.parent[x])\\n            self.vals[x] *= val\\n        return self.parent[x], self.vals[x]\\n    \\n    def union(self, y, x, val):\\n        x, valx = self.find(x)\\n        y, valy = self.find(y)\\n        if x == y: return\\n        self.parent[y] = self.parent[x]\\n        self.vals[y] = val * valx / valy\\n        \\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        alphabet = set(sum(equations, []))\\n        ufo = DJS(alphabet)\\n        for (y, x), val in zip(equations, values):\\n            ufo.union(y, x, val)\\n            \\n        res = []\\n        for y, x in queries:\\n            if x not in alphabet or y not in alphabet: \\n                res.append(-1.0)\\n                continue\\n            y, valy = ufo.find(y)\\n            x, valx = ufo.find(x)\\n            if x == y: res.append(valy / valx)\\n            else: res.append(-1.0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309409,
                "title": "javascript-graph-dfs-readable",
                "content": "```\\n/**\\n * @param {string[][]} equations\\n * @param {number[]} values\\n * @param {string[][]} queries\\n * @return {number[]}\\n */\\n\\nvar calcEquation = function(equations, values, queries) {\\n    const adjList = new Map();\\n    \\n    // Initialize the graph\\n    for (let i = 0; i < equations.length; i++) {\\n        adjList.set(equations[i][0], []);\\n        adjList.set(equations[i][1], []);\\n    }\\n\\n    // Build the graph\\n    for (let i = 0; i < equations.length; i++) {\\n        const u = equations[i][0];\\n        const v = equations[i][1];\\n        const weight = values[i];\\n        \\n        // u to v\\n        adjList.get(u).push([v,weight]);\\n        \\n        // v to u\\n        adjList.get(v).push([u, 1/weight]);\\n    }\\n    \\n    // Initialize results array\\n    const res = [];\\n    \\n    for (let i = 0; i < queries.length; i++) {\\n        // divisor\\n        const src = queries[i][0];\\n        \\n        // dividend\\n        const dest = queries[i][1];\\n        const seen = new Set();\\n        const val = dfs(adjList, src, src, dest, 1, seen);\\n        \\n        \\n        if (val === false) {\\n            res.push(-1);\\n        } else {\\n            res.push(val);\\n        }\\n    }\\n    \\n    return res;\\n}\\n// In the case that there are other multiple valid paths from source to destination, ultimately, the quotient is the same\\n// returning the first then works.\\nvar dfs = function(adjList, src, curr, dest, quotient, seen) {\\n    //destination or source is non existent\\n    if (!adjList.has(dest) || !adjList.has(src)) {\\n        return -1;\\n    }\\n    \\n    //source is same as destination i.e. self-loop.\\n    if (src === dest) {\\n        return 1;\\n    }\\n    \\n    // Reached destination\\n    if (curr === dest) {\\n        return quotient;\\n    }\\n    \\n    seen.add(curr);\\n    \\n    const neighbors = adjList.get(curr);\\n    \\n    for (let i = 0; i < neighbors.length; i++) {\\n        if (seen.has(neighbors[i][0])) {\\n            continue;\\n        }\\n        const val = dfs(adjList, src, neighbors[i][0], dest, quotient * neighbors[i][1], seen);\\n        // if any value was found we return because\\n        // the only other cases would be having a cycle, or reaching our destination or path.\\n        if (val !== false) return val;\\n    }\\n    \\n    // We only return false if we\\'ve searched all neighbors and there\\'s no path to destination\\n    // however we know that src and dest are in adjList\\n    // thus it may just be disconnected, but this may return from different levels of recursion.\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\n/**\\n * @param {string[][]} equations\\n * @param {number[]} values\\n * @param {string[][]} queries\\n * @return {number[]}\\n */\\n\\nvar calcEquation = function(equations, values, queries) {\\n    const adjList = new Map();\\n    \\n    // Initialize the graph\\n    for (let i = 0; i < equations.length; i++) {\\n        adjList.set(equations[i][0], []);\\n        adjList.set(equations[i][1], []);\\n    }\\n\\n    // Build the graph\\n    for (let i = 0; i < equations.length; i++) {\\n        const u = equations[i][0];\\n        const v = equations[i][1];\\n        const weight = values[i];\\n        \\n        // u to v\\n        adjList.get(u).push([v,weight]);\\n        \\n        // v to u\\n        adjList.get(v).push([u, 1/weight]);\\n    }\\n    \\n    // Initialize results array\\n    const res = [];\\n    \\n    for (let i = 0; i < queries.length; i++) {\\n        // divisor\\n        const src = queries[i][0];\\n        \\n        // dividend\\n        const dest = queries[i][1];\\n        const seen = new Set();\\n        const val = dfs(adjList, src, src, dest, 1, seen);\\n        \\n        \\n        if (val === false) {\\n            res.push(-1);\\n        } else {\\n            res.push(val);\\n        }\\n    }\\n    \\n    return res;\\n}\\n// In the case that there are other multiple valid paths from source to destination, ultimately, the quotient is the same\\n// returning the first then works.\\nvar dfs = function(adjList, src, curr, dest, quotient, seen) {\\n    //destination or source is non existent\\n    if (!adjList.has(dest) || !adjList.has(src)) {\\n        return -1;\\n    }\\n    \\n    //source is same as destination i.e. self-loop.\\n    if (src === dest) {\\n        return 1;\\n    }\\n    \\n    // Reached destination\\n    if (curr === dest) {\\n        return quotient;\\n    }\\n    \\n    seen.add(curr);\\n    \\n    const neighbors = adjList.get(curr);\\n    \\n    for (let i = 0; i < neighbors.length; i++) {\\n        if (seen.has(neighbors[i][0])) {\\n            continue;\\n        }\\n        const val = dfs(adjList, src, neighbors[i][0], dest, quotient * neighbors[i][1], seen);\\n        // if any value was found we return because\\n        // the only other cases would be having a cycle, or reaching our destination or path.\\n        if (val !== false) return val;\\n    }\\n    \\n    // We only return false if we\\'ve searched all neighbors and there\\'s no path to destination\\n    // however we know that src and dest are in adjList\\n    // thus it may just be disconnected, but this may return from different levels of recursion.\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 439613,
                "title": "c-dfs-100-time-99-memory-with-explanation-comments",
                "content": "The key is to see the graph structure. This is the graph for the example case:\\n\\n```\\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\\nvalues = [2.0, 3.0]\\n```\\n\\n![image](https://assets.leetcode.com/users/birajp/image_1574966193.png)\\nThe nodes are the individual letters while the weights of the edges are the results of the division between the two nodes on that edge. ``` A\\\\B = 2.0 ```, therefore ```2.0``` is the weight between ```A``` and ```B```. It\\'s important when buildiing the graph to put both the original equations into the graph as well as the inverse equations. If the inverses aren\\'t put into the graph, there\\'s no way to calculate ```C/A``` for example.\\n\\nSay we want to evaluate ``` A/C```. To do so, we start at ```A``` and search the graph until ```C``` is found. As we search, we maintain an accumulator value. This accumulator value starts at 1.0 and is multiplied by the weight of an edge that we traverse over. To get from ```A``` to ```C```, we must go through ```B```. Therefore, the accumulator is ```1.0 * 2.0 * 3.0```. This is also the solution to ```A/C```. If we reach a node where all of it\\'s neighbors are visited, then we\\'ve exhausted paths through that node. As a result, that node will never be in our solution path and we can divide the cost of visiting that node out of the accumulator.\\n\\nMy code below uses DFS to search the graph. As this is not a tree, it\\'s important to maintain a visited set so there is no infinite looping.\\n\\nOne way to to optimize this with memoization. This can be done by building new edges in the graph as we search to it for solutions.\\n\\n\\tclass Solution {\\n\\t\\tstruct Node {\\n\\t\\t\\tNode(string v, double r) {\\n\\t\\t\\t\\tthis->variable = v;\\n\\t\\t\\t\\tthis->result = r;\\n\\t\\t\\t}\\n\\t\\t\\tstring variable;\\n\\t\\t\\tdouble result;\\n\\t\\t};\\n\\n\\t\\tmap<string, vector<Node>> graph;\\n\\t\\tvoid buildGraph(vector<vector<string>>& equations, vector<double>& values) {\\n\\t\\t\\tfor(auto& e: equations) {\\n\\t\\t\\t\\tvector<Node> children;\\n\\t\\t\\t\\tgraph[e[0]] = children; /* init each node */\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int e = 0; e < equations.size(); ++e) {\\n\\t\\t\\t\\tNode n(equations[e][1], values[e]);\\n\\t\\t\\t\\tgraph[equations[e][0]].push_back(n);\\n\\n\\t\\t\\t\\t/* add the inverse of the equation to the graph as well */\\n\\t\\t\\t\\tNode n_inverse(equations[e][0], 1/values[e]);\\n\\t\\t\\t\\tgraph[equations[e][1]].push_back(n_inverse);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbool solveEquation(string top, string bottom, double& accum, set<string>& visited) {\\n\\t\\t\\tif(top == bottom && graph.find(top) != graph.end()) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\t/* if either top or bottom aren\\'t in the graph, then the equation is unsolvable */\\n\\t\\t\\tif(graph.find(top) == graph.end() || graph.find(bottom) == graph.end()) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvisited.insert(top);\\n\\t\\t\\tfor(auto& child : graph[top]) {\\n\\t\\t\\t\\t/* only recurse if the child has never been seen before */\\n\\t\\t\\t\\tif(visited.find(child.variable) == visited.end()) {\\n\\t\\t\\t\\t\\taccum *= child.result;  /* temporarily do the multiplication */\\n\\t\\t\\t\\t\\tif(child.variable == bottom) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t/* if somewhere down the tree we encounter the result, then propogate that all the way back up the tree */\\n\\t\\t\\t\\t\\tif(solveEquation(child.variable, bottom, accum, visited)) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\taccum /= child.result;  /* if the current path down the tree yielded a false result, undo the multiplication */\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;  /* can\\'t find a solution */\\n\\t\\t}\\n\\n\\t\\tvector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n\\t\\t\\tbuildGraph(equations, values);\\n\\t\\t\\tvector<double> results;\\n\\t\\t\\tfor(auto& q : queries) {\\n\\t\\t\\t\\tset<string> visited;\\n\\t\\t\\t\\tdouble accum = 1.0;\\n\\n\\t\\t\\t\\tbool res = solveEquation(q[0], q[1], accum, visited);\\n\\t\\t\\t\\tif(res) {\\n\\t\\t\\t\\t\\tresults.push_back(accum);   \\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresults.push_back(-1.0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn results;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\\nvalues = [2.0, 3.0]\\n```\n``` A\\\\B = 2.0 ```\n```2.0```\n```A```\n```B```\n```C/A```\n``` A/C```\n```A```\n```C```\n```A```\n```C```\n```B```\n```1.0 * 2.0 * 3.0```\n```A/C```",
                "codeTag": "Unknown"
            },
            {
                "id": 88343,
                "title": "union-find-algorithm-c-0ms-solution-almost-linear-complexity",
                "content": "The time complexity of this algorithm is amortized O((n+m) * a(n)), where n is the number of equations (or, number of variables),  m is the number of queries, a(n) is the inverse Ackermann function and is less than 5 for all practical values of n. So, it is an almost O(n+m) algorithm.\\n```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> query) {\\n        unordered_map<string, int> varID; // map var name to its ID \\n        vector<int> par;                  // par[v2]==v1 ;  v1 is v2's parent\\n        vector<double> parEq;             // parEq[v2]==t ; v1 is t times of v2 \\n\\n        for (int i=0; i<equations.size(); i++) // process equations\\n        {\\n            string& v1Name = equations[i].first;\\n            string& v2Name = equations[i].second;\\n            double x = values[i]; // v1 is x times of v2\\n            int v1, v2;\\n            if (varID.count(v1Name)==0){ //new variable\\n                v1 = par.size();\\n                par.push_back(v1); //par[v1]==v1, v1 is itself's parent\\n                parEq.push_back(1); \\n                varID[v1Name] = v1;\\n            }\\n            else  v1 = varID[v1Name];\\n            if (varID.count(v2Name)==0) {\\n                v2 = par.size();\\n                par.push_back(v2);  \\n                parEq.push_back(1);\\n                varID[v2Name] = v2; \\n            }\\n            else  v2 = varID[v2Name];\\n            \\n            int r1, r2;\\n            double t1, t2;\\n            r1 = findRoot(par, parEq, v1, t1); //r1 is t1 times of v1\\n            r2 = findRoot(par, parEq, v2, t2); //r2 is t2 times of v2\\n            par[r2] = r1;\\n            parEq[r2] = t1 * x / t2;           //do simple math here\\n        }\\n\\n        vector<double> res;\\n        for (auto& q : query) // process queries\\n        {\\n            int v1, v2;\\n            if (varID.count(q.first)==1 && varID.count(q.second)==1 ) {\\n                v1 = varID[q.first];\\n                v2 = varID[q.second];\\n            }\\n            else {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            int r1, r2;\\n            double t1, t2;\\n            r1 = findRoot(par, parEq, v1, t1); //r1 is t1 times of v1\\n            r2 = findRoot(par, parEq, v2, t2); //r2 is t2 times of v2\\n            if (r1 != r2) res.push_back(-1);\\n            else res.push_back(t2/t1);\\n        }\\n        return res;\\n    }\\n    \\n    int findRoot(vector<int>& par, vector<double>& parEq, int v, double& t) {\\n        t = 1;\\n        while (v != par[v]) {\\n            // path compression\\n            parEq[v] = parEq[v] * parEq[par[v]];\\n            par[v] = par[par[v]];\\n            // climb up\\n            t *= parEq[v];\\n            v = par[v];\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> query) {\\n        unordered_map<string, int> varID; // map var name to its ID \\n        vector<int> par;                  // par[v2]==v1 ;  v1 is v2's parent\\n        vector<double> parEq;             // parEq[v2]==t ; v1 is t times of v2 \\n\\n        for (int i=0; i<equations.size(); i++) // process equations\\n        {\\n            string& v1Name = equations[i].first;\\n            string& v2Name = equations[i].second;\\n            double x = values[i]; // v1 is x times of v2\\n            int v1, v2;\\n            if (varID.count(v1Name)==0){ //new variable\\n                v1 = par.size();\\n                par.push_back(v1); //par[v1]==v1, v1 is itself's parent\\n                parEq.push_back(1); \\n                varID[v1Name] = v1;\\n            }\\n            else  v1 = varID[v1Name];\\n            if (varID.count(v2Name)==0) {\\n                v2 = par.size();\\n                par.push_back(v2);  \\n                parEq.push_back(1);\\n                varID[v2Name] = v2; \\n            }\\n            else  v2 = varID[v2Name];\\n            \\n            int r1, r2;\\n            double t1, t2;\\n            r1 = findRoot(par, parEq, v1, t1); //r1 is t1 times of v1\\n            r2 = findRoot(par, parEq, v2, t2); //r2 is t2 times of v2\\n            par[r2] = r1;\\n            parEq[r2] = t1 * x / t2;           //do simple math here\\n        }\\n\\n        vector<double> res;\\n        for (auto& q : query) // process queries\\n        {\\n            int v1, v2;\\n            if (varID.count(q.first)==1 && varID.count(q.second)==1 ) {\\n                v1 = varID[q.first];\\n                v2 = varID[q.second];\\n            }\\n            else {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            int r1, r2;\\n            double t1, t2;\\n            r1 = findRoot(par, parEq, v1, t1); //r1 is t1 times of v1\\n            r2 = findRoot(par, parEq, v2, t2); //r2 is t2 times of v2\\n            if (r1 != r2) res.push_back(-1);\\n            else res.push_back(t2/t1);\\n        }\\n        return res;\\n    }\\n    \\n    int findRoot(vector<int>& par, vector<double>& parEq, int v, double& t) {\\n        t = 1;\\n        while (v != par[v]) {\\n            // path compression\\n            parEq[v] = parEq[v] * parEq[par[v]];\\n            par[v] = par[par[v]];\\n            // climb up\\n            t *= parEq[v];\\n            v = par[v];\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546365,
                "title": "dfs-graph-js-sol-explained-with-approach",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n \\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n    - This below solution code uses a graph representation to store \\n      the variable pairs and their corresponding values. \\n\\n    - It then uses a Depth-First Search (DFS) algorithm to evaluate \\n      each query by traversing the graph and calculating the result.\\n       \\n    - The evaluateQuery function takes care of the DFS traversal.\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(N * (V + E))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n\\n\\n\\n\\n- Space complexity: $$O(E + V)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {string[][]} equations\\n * @param {number[]} values\\n * @param {string[][]} queries\\n * @return {number[]}\\n */\\nvar calcEquation = function(equations, values, queries) {\\n  \\n  // Step 1: Build the graph\\n  let graph = {};\\n  \\n  for (let i = 0; i < equations.length; i++) {\\n    \\n    let [numerator, denominator] = equations[i];\\n    \\n    let value = values[i];\\n    \\n    if (!graph[numerator]) {\\n      graph[numerator] = {};\\n    }\\n\\n    if (!graph[denominator]) {\\n      graph[denominator] = {};\\n    }\\n\\n    graph[numerator][denominator] = value;\\n    graph[denominator][numerator] = 1 / value;\\n  }\\n\\n  // Step 2: Evaluate queries using DFS\\n  let evaluateQuery = (numerator, denominator, visited) => {\\n    \\n    if (!(numerator in graph) || !(denominator in graph)) {\\n      return -1.0;\\n    }\\n\\n    if (numerator === denominator) {\\n      return 1.0;\\n    }\\n\\n    visited.add(numerator);\\n    let neighbors = graph[numerator];\\n\\n    for (let neighbor in neighbors) {\\n      \\n      if (!visited.has(neighbor)) {\\n        \\n        let result = evaluateQuery(neighbor, denominator, visited);\\n        \\n        if (result !== -1.0) {\\n          return neighbors[neighbor] * result;\\n        }\\n      }\\n    }\\n\\n    return -1.0;\\n  };\\n\\n  // Step 3: Process queries\\n  let results = [];\\n  \\n  for (let query of queries) {\\n    \\n    let [numerator, denominator] = query;\\n    let visited = new Set();\\n    let result = evaluateQuery(numerator, denominator, visited);\\n    \\n    results.push(result);\\n  }\\n\\n  return results;\\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/dc180318-d24d-4ca0-bd2a-b35807d3949f_1684619482.0715039.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n/**\\n * @param {string[][]} equations\\n * @param {number[]} values\\n * @param {string[][]} queries\\n * @return {number[]}\\n */\\nvar calcEquation = function(equations, values, queries) {\\n  \\n  // Step 1: Build the graph\\n  let graph = {};\\n  \\n  for (let i = 0; i < equations.length; i++) {\\n    \\n    let [numerator, denominator] = equations[i];\\n    \\n    let value = values[i];\\n    \\n    if (!graph[numerator]) {\\n      graph[numerator] = {};\\n    }\\n\\n    if (!graph[denominator]) {\\n      graph[denominator] = {};\\n    }\\n\\n    graph[numerator][denominator] = value;\\n    graph[denominator][numerator] = 1 / value;\\n  }\\n\\n  // Step 2: Evaluate queries using DFS\\n  let evaluateQuery = (numerator, denominator, visited) => {\\n    \\n    if (!(numerator in graph) || !(denominator in graph)) {\\n      return -1.0;\\n    }\\n\\n    if (numerator === denominator) {\\n      return 1.0;\\n    }\\n\\n    visited.add(numerator);\\n    let neighbors = graph[numerator];\\n\\n    for (let neighbor in neighbors) {\\n      \\n      if (!visited.has(neighbor)) {\\n        \\n        let result = evaluateQuery(neighbor, denominator, visited);\\n        \\n        if (result !== -1.0) {\\n          return neighbors[neighbor] * result;\\n        }\\n      }\\n    }\\n\\n    return -1.0;\\n  };\\n\\n  // Step 3: Process queries\\n  let results = [];\\n  \\n  for (let query of queries) {\\n    \\n    let [numerator, denominator] = query;\\n    let visited = new Set();\\n    let result = evaluateQuery(numerator, denominator, visited);\\n    \\n    results.push(result);\\n  }\\n\\n  return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3544428,
                "title": "python-elegant-short-floyd-warshall",
                "content": "# Complexity\\n- Time complexity: $$O(n^3)$$\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        graph = defaultdict(dict)\\n\\n        for (u, v), val in zip(equations, values):\\n            graph[u][u] = graph[v][v] = 1\\n            graph[u][v] = val\\n            graph[v][u] = 1 / val\\n\\n        for k in graph:\\n            for i in graph[k]:\\n                for j in graph[k]:\\n                    graph[i][j] = graph[i][k] * graph[k][j]\\n\\n        return [graph[u].get(v, -1) for u, v in queries]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        graph = defaultdict(dict)\\n\\n        for (u, v), val in zip(equations, values):\\n            graph[u][u] = graph[v][v] = 1\\n            graph[u][v] = val\\n            graph[v][u] = 1 / val\\n\\n        for k in graph:\\n            for i in graph[k]:\\n                for j in graph[k]:\\n                    graph[i][j] = graph[i][k] * graph[k][j]\\n\\n        return [graph[u].get(v, -1) for u, v in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544342,
                "title": "c-easy-peasy-dfs-string-as-node-0ms-100-faster",
                "content": "# Code\\n```\\nclass Solution\\n{\\n    unordered_map<string, vector<pair<string, double>>> adj;\\n    unordered_map<string, int> vis;\\n\\npublic:\\n    bool dfs(string node, string dest, double &prod)\\n    {\\n        if (node == dest)\\n            return true;\\n\\n        vis[node] = 1;\\n\\n        for (auto [v, w] : adj[node])\\n        {\\n            if (!vis[v] and dfs(v, dest, prod))\\n            {\\n                prod *= w;\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    vector<double> calcEquation(vector<vector<string>> &e, vector<double> &values, vector<vector<string>> &queries)\\n    {\\n        adj.clear();\\n        for (int i = 0; i < e.size(); i++)\\n        {\\n            adj[e[i][0]].push_back({e[i][1], values[i]});\\n            adj[e[i][1]].push_back({e[i][0], 1.0 / values[i]});\\n        }\\n\\n        vector<double> ans;\\n        for (auto i : queries)\\n        {\\n            vis.clear();\\n\\n            string src = i[0], dest = i[1];\\n            double prod = 1;\\n\\n            if (adj.find(src) == adj.end() or adj.find(dest) == adj.end())\\n                ans.push_back(-1);\\n            else if (dfs(src, dest, prod))\\n                ans.push_back(prod);\\n            else\\n                ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/b14417bd-2560-431d-8bfc-c88dedc4933f_1684574983.4299283.png)\\n\\n\\n### You might want to look at the first attempt of mine (BTW it is also ACCEPTED)\\n```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>> &e, vector<double> &values, vector<vector<string>> &queries)\\n    {\\n        unordered_map<string, int> have;\\n        for (auto i : e)\\n            have[i[0] + \"/\" + i[1]] = 1;\\n\\n        int temp = e.size();\\n        while (temp--)\\n        {\\n            vector<vector<string>> added;\\n            vector<double> vals;\\n\\n            for (int i = 0; i < e.size(); i++)\\n            {\\n                for (int j = 0; j < e.size(); j++)\\n                {\\n                    if (i != j)\\n                    {\\n                        if (e[i][1] == e[j][0] and e[i][0] != e[j][1])\\n                        {\\n                            added.push_back({e[i][0], e[j][1]});\\n                            vals.push_back(values[i] * values[j]);\\n                        }\\n                        else if (e[i][1] == e[j][1] and e[i][0] != e[j][0])\\n                        {\\n                            added.push_back({e[i][0], e[j][0]});\\n                            vals.push_back(values[i] / values[j]);\\n                        }\\n                        else if (e[i][0] == e[j][0] and e[i][1] != e[j][1])\\n                        {\\n                            added.push_back({e[i][1], e[j][1]});\\n                            vals.push_back(values[j] / values[i]);\\n                        }\\n                        else if (e[i][0] == e[j][1] and e[i][1] != e[j][0])\\n                        {\\n                            added.push_back({e[i][1], e[j][0]});\\n                            vals.push_back(1.0 / (values[i] * values[j]));\\n                        }\\n                    }\\n                }\\n            }\\n\\n            for (int j = 0; j < added.size(); j++)\\n            {\\n                if (have.find(added[j][0] + \"/\" + added[j][1]) == have.end())\\n                {\\n                    have[added[j][0] + \"/\" + added[j][1]] = 1;\\n                    e.push_back(added[j]);\\n                    values.push_back(vals[j]);\\n                }\\n            }\\n        }\\n\\n        unordered_map<string, int> mp;\\n        unordered_map<string, double> val;\\n\\n        for (int i = 0; i < e.size(); i++)\\n        {\\n            mp[e[i][0]] = 1, mp[e[i][1]] = 1;\\n            val[e[i][0] + \"/\" + e[i][1]] = values[i];\\n        }\\n\\n        vector<double> ans;\\n        for (auto i : queries)\\n        {\\n            if (mp.find(i[0]) == mp.end() or mp.find(i[1]) == mp.end())\\n                ans.push_back(-1.000000);\\n            else\\n            {\\n                if (i[0] == i[1])\\n                    ans.push_back(1.000000);\\n                else\\n                {\\n                    string t = i[0] + \"/\" + i[1];\\n                    string tReverse = i[1] + \"/\" + i[0];\\n                    if (val.find(t) != val.end())\\n                        ans.push_back(val[t]);\\n                    else if (val.find(tReverse) != val.end())\\n                        ans.push_back(1.0 / val[tReverse]);\\n                    else\\n                        ans.push_back(-1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution\\n{\\n    unordered_map<string, vector<pair<string, double>>> adj;\\n    unordered_map<string, int> vis;\\n\\npublic:\\n    bool dfs(string node, string dest, double &prod)\\n    {\\n        if (node == dest)\\n            return true;\\n\\n        vis[node] = 1;\\n\\n        for (auto [v, w] : adj[node])\\n        {\\n            if (!vis[v] and dfs(v, dest, prod))\\n            {\\n                prod *= w;\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    vector<double> calcEquation(vector<vector<string>> &e, vector<double> &values, vector<vector<string>> &queries)\\n    {\\n        adj.clear();\\n        for (int i = 0; i < e.size(); i++)\\n        {\\n            adj[e[i][0]].push_back({e[i][1], values[i]});\\n            adj[e[i][1]].push_back({e[i][0], 1.0 / values[i]});\\n        }\\n\\n        vector<double> ans;\\n        for (auto i : queries)\\n        {\\n            vis.clear();\\n\\n            string src = i[0], dest = i[1];\\n            double prod = 1;\\n\\n            if (adj.find(src) == adj.end() or adj.find(dest) == adj.end())\\n                ans.push_back(-1);\\n            else if (dfs(src, dest, prod))\\n                ans.push_back(prod);\\n            else\\n                ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>> &e, vector<double> &values, vector<vector<string>> &queries)\\n    {\\n        unordered_map<string, int> have;\\n        for (auto i : e)\\n            have[i[0] + \"/\" + i[1]] = 1;\\n\\n        int temp = e.size();\\n        while (temp--)\\n        {\\n            vector<vector<string>> added;\\n            vector<double> vals;\\n\\n            for (int i = 0; i < e.size(); i++)\\n            {\\n                for (int j = 0; j < e.size(); j++)\\n                {\\n                    if (i != j)\\n                    {\\n                        if (e[i][1] == e[j][0] and e[i][0] != e[j][1])\\n                        {\\n                            added.push_back({e[i][0], e[j][1]});\\n                            vals.push_back(values[i] * values[j]);\\n                        }\\n                        else if (e[i][1] == e[j][1] and e[i][0] != e[j][0])\\n                        {\\n                            added.push_back({e[i][0], e[j][0]});\\n                            vals.push_back(values[i] / values[j]);\\n                        }\\n                        else if (e[i][0] == e[j][0] and e[i][1] != e[j][1])\\n                        {\\n                            added.push_back({e[i][1], e[j][1]});\\n                            vals.push_back(values[j] / values[i]);\\n                        }\\n                        else if (e[i][0] == e[j][1] and e[i][1] != e[j][0])\\n                        {\\n                            added.push_back({e[i][1], e[j][0]});\\n                            vals.push_back(1.0 / (values[i] * values[j]));\\n                        }\\n                    }\\n                }\\n            }\\n\\n            for (int j = 0; j < added.size(); j++)\\n            {\\n                if (have.find(added[j][0] + \"/\" + added[j][1]) == have.end())\\n                {\\n                    have[added[j][0] + \"/\" + added[j][1]] = 1;\\n                    e.push_back(added[j]);\\n                    values.push_back(vals[j]);\\n                }\\n            }\\n        }\\n\\n        unordered_map<string, int> mp;\\n        unordered_map<string, double> val;\\n\\n        for (int i = 0; i < e.size(); i++)\\n        {\\n            mp[e[i][0]] = 1, mp[e[i][1]] = 1;\\n            val[e[i][0] + \"/\" + e[i][1]] = values[i];\\n        }\\n\\n        vector<double> ans;\\n        for (auto i : queries)\\n        {\\n            if (mp.find(i[0]) == mp.end() or mp.find(i[1]) == mp.end())\\n                ans.push_back(-1.000000);\\n            else\\n            {\\n                if (i[0] == i[1])\\n                    ans.push_back(1.000000);\\n                else\\n                {\\n                    string t = i[0] + \"/\" + i[1];\\n                    string tReverse = i[1] + \"/\" + i[0];\\n                    if (val.find(t) != val.end())\\n                        ans.push_back(val[t]);\\n                    else if (val.find(tReverse) != val.end())\\n                        ans.push_back(1.0 / val[tReverse]);\\n                    else\\n                        ans.push_back(-1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543257,
                "title": "0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn general when we have a problem about *some queries* we want to preprocess our data as much as possible so each query can run as fast as possible.\\n\\nFor each equation:\\n$$A / B = v \\\\Rightarrow A = vB$$\\nAnd this can concatenate:\\n$$A / B = v$$ and $$B / C = u \\\\Rightarrow A = uv C$$\\nWe can try to represent all variables using a single *base* variable. This leads us to consider union find.\\n\\n*If you are unfamiliar with Union Find, check out the [wiki](https://en.wikipedia.org/wiki/Disjoint-set_data_structure)*\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a modified version of the `UnionFind` data structure, with an extra `ratio` that represents the ralation between the **variable** and the **base** we find.\\n\\nSome details:\\n  * Union find now returns a pair\\n  * We use a helper class `IdGen` to manage the conversion from string to int so we can easily use them in the union find. We uses string_view so that there is no extra space allocation or string copy.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N + M)$$ where `N` is the number of equations and `M` is the number of queries.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N + M)$$ `UnionFind` uses `N` extra space while the answer itself takes `M` extra space.\\n\\n# Code\\n```\\n// Modified UnionFind data structure.\\nclass Relation {\\n public:\\n  explicit Relation(int size) : base_(size), ranks_(size) {\\n    for (int i = 0; i < size; ++i) {\\n      base_[i] = {i, 1.0};\\n    }\\n  }\\n\\n  // Find(x) returns [x0, ratio] such that $x = ratio * $x0.\\n  pair<int, double> Find(int x) {\\n    pair<int, double>& base = base_[x];\\n    if (base.first != x) {\\n      auto [x0, ratio] = Find(base.first);\\n      base.first = x0;\\n      base.second *= ratio;\\n    }\\n    return base;\\n  }\\n\\n  void Add(int x, double ratio, int y) {\\n    auto [x0, ratio_x] = Find(x);\\n    auto [y0, ratio_y] = Find(y);\\n    if (x0 == y0) {\\n      return;  // We must have ratio_x = ratio_y * ratio in this case.\\n    }\\n    if (ranks_[x0] < ranks_[y0]) {\\n      // Now we have ratio_x * x0 = ratio * ratio_y * y0\\n      // => x0 = ratio * ratio_y / ratio_x y0\\n      base_[x0] = {y0, ratio * ratio_y / ratio_x};\\n    } else if (ranks_[x0] > ranks_[y0]) {\\n      base_[y0] = {x0, ratio_x / ratio_y / ratio};\\n    } else { // same rank\\n      ++ranks_[y0];\\n      base_[x0] = {y0, ratio * ratio_y / ratio_x};\\n    }\\n  }\\n\\n private:\\n  vector<pair<int, double>> base_;\\n  vector<int> ranks_;\\n};\\n\\nclass IdGen {\\n public:\\n  // The argument `string_view` must not point to temporary strings.\\n  int GetId(string_view v) {\\n    int& id = lookup_[v];\\n    if (id == 0) {\\n      id = ++id_counter_;\\n    }\\n    return id;\\n  }\\n\\n  int max() const { return id_counter_; }\\n\\n private:\\n  int id_counter_ = 0;\\n  unordered_map<string_view, int> lookup_;\\n};\\n\\nclass Solution {\\npublic:\\n  vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values,\\n                              vector<vector<string>>& queries) {\\n    IdGen id_gen;\\n    Relation relation(equations.size() * 2 + 1);\\n    for (int i = 0; i < equations.size(); ++i) {\\n      const vector<string>& equation = equations[i];\\n      int a = id_gen.GetId(equation[0]);\\n      int b = id_gen.GetId(equation[1]);\\n      relation.Add(a, values[i], b);  // $a == values[i] * $b\\n    }\\n    const int max_id = id_gen.max();\\n\\n    vector<double> results(queries.size(), -1.0);\\n    for (int i = 0; i < queries.size(); ++i) {\\n      const vector<string>& query = queries[i];\\n      int c = id_gen.GetId(query[0]);\\n      if (c > max_id) {\\n        continue;\\n      }\\n      int d = id_gen.GetId(query[1]);\\n      if (d > max_id) {\\n        continue;\\n      }\\n      // $c = ratio_c * $c0\\n      auto [c0, ratio_c] = relation.Find(c);\\n      // $d = ratio_d * $d0\\n      auto [d0, ratio_d] = relation.Find(d);\\n      if (c0 != d0) {\\n        continue;\\n      }\\n      // Therefore we get $c / $d.\\n      results[i] = ratio_c / ratio_d;\\n    }\\n    return results;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Union Find"
                ],
                "code": "```\\n// Modified UnionFind data structure.\\nclass Relation {\\n public:\\n  explicit Relation(int size) : base_(size), ranks_(size) {\\n    for (int i = 0; i < size; ++i) {\\n      base_[i] = {i, 1.0};\\n    }\\n  }\\n\\n  // Find(x) returns [x0, ratio] such that $x = ratio * $x0.\\n  pair<int, double> Find(int x) {\\n    pair<int, double>& base = base_[x];\\n    if (base.first != x) {\\n      auto [x0, ratio] = Find(base.first);\\n      base.first = x0;\\n      base.second *= ratio;\\n    }\\n    return base;\\n  }\\n\\n  void Add(int x, double ratio, int y) {\\n    auto [x0, ratio_x] = Find(x);\\n    auto [y0, ratio_y] = Find(y);\\n    if (x0 == y0) {\\n      return;  // We must have ratio_x = ratio_y * ratio in this case.\\n    }\\n    if (ranks_[x0] < ranks_[y0]) {\\n      // Now we have ratio_x * x0 = ratio * ratio_y * y0\\n      // => x0 = ratio * ratio_y / ratio_x y0\\n      base_[x0] = {y0, ratio * ratio_y / ratio_x};\\n    } else if (ranks_[x0] > ranks_[y0]) {\\n      base_[y0] = {x0, ratio_x / ratio_y / ratio};\\n    } else { // same rank\\n      ++ranks_[y0];\\n      base_[x0] = {y0, ratio * ratio_y / ratio_x};\\n    }\\n  }\\n\\n private:\\n  vector<pair<int, double>> base_;\\n  vector<int> ranks_;\\n};\\n\\nclass IdGen {\\n public:\\n  // The argument `string_view` must not point to temporary strings.\\n  int GetId(string_view v) {\\n    int& id = lookup_[v];\\n    if (id == 0) {\\n      id = ++id_counter_;\\n    }\\n    return id;\\n  }\\n\\n  int max() const { return id_counter_; }\\n\\n private:\\n  int id_counter_ = 0;\\n  unordered_map<string_view, int> lookup_;\\n};\\n\\nclass Solution {\\npublic:\\n  vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values,\\n                              vector<vector<string>>& queries) {\\n    IdGen id_gen;\\n    Relation relation(equations.size() * 2 + 1);\\n    for (int i = 0; i < equations.size(); ++i) {\\n      const vector<string>& equation = equations[i];\\n      int a = id_gen.GetId(equation[0]);\\n      int b = id_gen.GetId(equation[1]);\\n      relation.Add(a, values[i], b);  // $a == values[i] * $b\\n    }\\n    const int max_id = id_gen.max();\\n\\n    vector<double> results(queries.size(), -1.0);\\n    for (int i = 0; i < queries.size(); ++i) {\\n      const vector<string>& query = queries[i];\\n      int c = id_gen.GetId(query[0]);\\n      if (c > max_id) {\\n        continue;\\n      }\\n      int d = id_gen.GetId(query[1]);\\n      if (d > max_id) {\\n        continue;\\n      }\\n      // $c = ratio_c * $c0\\n      auto [c0, ratio_c] = relation.Find(c);\\n      // $d = ratio_d * $d0\\n      auto [d0, ratio_d] = relation.Find(d);\\n      if (c0 != d0) {\\n        continue;\\n      }\\n      // Therefore we get $c / $d.\\n      results[i] = ratio_c / ratio_d;\\n    }\\n    return results;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371568,
                "title": "java-bfs-solution",
                "content": "Haven\\'t really seen a java BFS solution on here\\n```\\nimport javafx.util.Pair ;\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        Map<String, Map<String, Double>> graph = new HashMap<>();\\n        for (int i = 0; i < equations.size(); i++) {\\n            List<String> equation = equations.get(i);\\n            double value = values[i];\\n            String divider = equation.get(0);\\n            String divisor = equation.get(1);\\n            if (!graph.containsKey(divider)) graph.put(divider, new HashMap<>());\\n            graph.get(divider).put(divisor, value);\\n            if (!graph.containsKey(divisor)) graph.put(divisor, new HashMap<>());\\n            graph.get(divisor).put(divider, 1 / value);\\n        }\\n        \\n        double[] res = new double[queries.size()];\\n        Arrays.fill(res, -1.0);\\n        for (int i = 0; i < queries.size(); i++) {\\n            List<String> query = queries.get(i);\\n            String divider = query.get(0);\\n            String divisor = query.get(1);\\n            if (!graph.containsKey(divider) || !graph.containsKey(divisor)) continue;\\n            if (divider.equals(divisor)) {\\n                res[i] = 1.0;\\n                continue;\\n            }\\n            Queue<Pair<String, Double>> q = new LinkedList<>();\\n            q.add(new Pair(divider, 1.0));\\n            Map<String, Boolean> visited = new HashMap<>();\\n            while (!q.isEmpty()) {\\n                Pair<String, Double> pair = q.poll();\\n                String s = pair.getKey();\\n                double value = pair.getValue();\\n                visited.put(s, true);\\n                for (String key : graph.get(s).keySet()) {\\n                    if (!visited.containsKey(key)) {\\n                        if (key.equals(divisor)) {\\n                            res[i] = graph.get(s).get(key) * value;\\n                            break;\\n                        }\\n                        q.offer(new Pair(key, value * graph.get(s).get(key)));\\n                        visited.put(key, true);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nimport javafx.util.Pair ;\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        Map<String, Map<String, Double>> graph = new HashMap<>();\\n        for (int i = 0; i < equations.size(); i++) {\\n            List<String> equation = equations.get(i);\\n            double value = values[i];\\n            String divider = equation.get(0);\\n            String divisor = equation.get(1);\\n            if (!graph.containsKey(divider)) graph.put(divider, new HashMap<>());\\n            graph.get(divider).put(divisor, value);\\n            if (!graph.containsKey(divisor)) graph.put(divisor, new HashMap<>());\\n            graph.get(divisor).put(divider, 1 / value);\\n        }\\n        \\n        double[] res = new double[queries.size()];\\n        Arrays.fill(res, -1.0);\\n        for (int i = 0; i < queries.size(); i++) {\\n            List<String> query = queries.get(i);\\n            String divider = query.get(0);\\n            String divisor = query.get(1);\\n            if (!graph.containsKey(divider) || !graph.containsKey(divisor)) continue;\\n            if (divider.equals(divisor)) {\\n                res[i] = 1.0;\\n                continue;\\n            }\\n            Queue<Pair<String, Double>> q = new LinkedList<>();\\n            q.add(new Pair(divider, 1.0));\\n            Map<String, Boolean> visited = new HashMap<>();\\n            while (!q.isEmpty()) {\\n                Pair<String, Double> pair = q.poll();\\n                String s = pair.getKey();\\n                double value = pair.getValue();\\n                visited.put(s, true);\\n                for (String key : graph.get(s).keySet()) {\\n                    if (!visited.containsKey(key)) {\\n                        if (key.equals(divisor)) {\\n                            res[i] = graph.get(s).get(key) * value;\\n                            break;\\n                        }\\n                        q.offer(new Pair(key, value * graph.get(s).get(key)));\\n                        visited.put(key, true);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316394,
                "title": "easy-to-understand-python3-dfs-solution-beats-94",
                "content": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        def dfs(graph, start, end, visited):\\n            if start == end and graph[start]:\\n                return 1.0\\n            \\n            visited.add(start)\\n            for neigh, val in graph[start]:\\n                if neigh in visited:\\n                    continue\\n                \\n                tmp = dfs(graph, neigh, end, visited)\\n                if tmp > 0:\\n                    return val * tmp\\n            \\n            return -1.0\\n            \\n        graph = collections.defaultdict(set)\\n        for items, v in zip(equations, values):\\n            x, y = items\\n            graph[x].add((y, v))\\n            graph[y].add((x, 1.0 / v))\\n        \\n        res = []\\n        for q in queries:\\n            res.append(dfs(graph, q[0], q[1], set()))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        def dfs(graph, start, end, visited):\\n            if start == end and graph[start]:\\n                return 1.0\\n            \\n            visited.add(start)\\n            for neigh, val in graph[start]:\\n                if neigh in visited:\\n                    continue\\n                \\n                tmp = dfs(graph, neigh, end, visited)\\n                if tmp > 0:\\n                    return val * tmp\\n            \\n            return -1.0\\n            \\n        graph = collections.defaultdict(set)\\n        for items, v in zip(equations, values):\\n            x, y = items\\n            graph[x].add((y, v))\\n            graph[y].add((x, 1.0 / v))\\n        \\n        res = []\\n        for q in queries:\\n            res.append(dfs(graph, q[0], q[1], set()))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142654,
                "title": "c-speed-0ms-using-bfs",
                "content": "```\\nclass Solution {\\n    \\n    double evaluate(unordered_map<string, vector<pair<string, double>>> &graph, vector<string> &query) {\\n        auto startNode = query[0];\\n        auto endNode = query[1];\\n        \\n        if (graph.find(startNode) == graph.end()) {\\n            return -1;\\n        }\\n        \\n        if (graph.find(endNode) == graph.end()) {\\n            return -1;\\n        }\\n        \\n        queue<pair<string, double>> que;\\n        unordered_set<string> visited;\\n        \\n        que.push({startNode, 1});\\n        visited.insert(startNode);\\n        \\n        while (!que.empty()) {\\n            auto frontItem = que.front();\\n            que.pop();\\n            \\n            auto currNode = frontItem.first;\\n            auto currValue = frontItem.second;\\n            \\n            if (currNode == endNode) {\\n                return currValue;\\n            }\\n            \\n            for (auto nodeObj: graph[currNode]) {\\n                auto node = nodeObj.first;\\n                auto weight = nodeObj.second;\\n                if (visited.insert(node).second) {\\n                    que.push({node, currValue * weight});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        unordered_map<string, vector<pair<string, double>>> graph;\\n        for (int i = 0; i < equations.size(); i++) {\\n            auto fromNode = equations[i][0];\\n            auto toNode = equations[i][1];\\n            double weight = values[i];\\n            \\n            graph[fromNode].push_back({toNode, weight});\\n            graph[toNode].push_back({fromNode, 1 / weight});\\n        }\\n        \\n        vector<double> answers;\\n        \\n        for (auto query: queries) {\\n            answers.push_back(evaluate(graph, query));\\n        }\\n        \\n        return answers;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    double evaluate(unordered_map<string, vector<pair<string, double>>> &graph, vector<string> &query) {\\n        auto startNode = query[0];\\n        auto endNode = query[1];\\n        \\n        if (graph.find(startNode) == graph.end()) {\\n            return -1;\\n        }\\n        \\n        if (graph.find(endNode) == graph.end()) {\\n            return -1;\\n        }\\n        \\n        queue<pair<string, double>> que;\\n        unordered_set<string> visited;\\n        \\n        que.push({startNode, 1});\\n        visited.insert(startNode);\\n        \\n        while (!que.empty()) {\\n            auto frontItem = que.front();\\n            que.pop();\\n            \\n            auto currNode = frontItem.first;\\n            auto currValue = frontItem.second;\\n            \\n            if (currNode == endNode) {\\n                return currValue;\\n            }\\n            \\n            for (auto nodeObj: graph[currNode]) {\\n                auto node = nodeObj.first;\\n                auto weight = nodeObj.second;\\n                if (visited.insert(node).second) {\\n                    que.push({node, currValue * weight});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        unordered_map<string, vector<pair<string, double>>> graph;\\n        for (int i = 0; i < equations.size(); i++) {\\n            auto fromNode = equations[i][0];\\n            auto toNode = equations[i][1];\\n            double weight = values[i];\\n            \\n            graph[fromNode].push_back({toNode, weight});\\n            graph[toNode].push_back({fromNode, 1 / weight});\\n        }\\n        \\n        vector<double> answers;\\n        \\n        for (auto query: queries) {\\n            answers.push_back(evaluate(graph, query));\\n        }\\n        \\n        return answers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 119928,
                "title": "best-and-elegant-union-find-in-python-with-analysis",
                "content": "idea: For those letters which can take division operations, make them refer to a common letter so that any couple of them can take division\\n      indirectly.\\ndata structure: graph. consider letters as a vertices, the mappings as edges, and the values as weights in the graph.\\ntime:\\neach operation of UnionFind costs nearly O(1) (according to wiki) when using both path compression and union-by-rank.\\nbut this problem naturally can\\'t use union-by-rank. The find and union operation can costs up to O(V) if the tree like a linklist in worst case.\\nTherefore, the time should be O(E)*O(V) + O(Q)*O(V), where E stands for equations, Q for queries, and V for vertices number. Since V <= 2E,\\nthe worst time complexity is O(E*E + Q*E).\\nspace: O(E)\\n\\n```\\nclass Solution:\\n    def calcEquation(self, equations, values, queries):\\n        \"\"\"\\n        :type equations: List[List[str]]\\n        :type values: List[float]\\n        :type queries: List[List[str]]\\n        :rtype: List[float]\\n        \"\"\"\\n        res = []\\n        parent = {}    # i.e. [a, b] then parent[a] = b\\n        weight = {}    # i.e. a / b = 2.0, then weight[a] = 2.0\\n        ufind = UnionFind(parent, weight)\\n        for i, edge in enumerate(equations):\\n            x1, x2 = edge[0], edge[1]\\n            val = values[i]\\n            if x1 not in parent and x2 not in parent:\\n                parent[x1] = x2\\n                parent[x2] = x2\\n                weight[x1] = val\\n                weight[x2] = 1\\n            elif x1 not in parent:\\n                parent[x1] = x2\\n                weight[x1] = val\\n            elif x2 not in parent:    # weight[x1] already exists, if make x2 be x1\\'s parent. then weight[x1] will be overwrite.\\n                parent[x2] = x1\\n                weight[x2] = 1 / val\\n            else:\\n                ufind.union(x1, x2, val)\\n                \\n        for x1, x2 in queries:\\n            if x1 not in parent or x2 not in parent or ufind.find(x1) != ufind.find(x2):\\n                res.append(-1.0)\\n            else:\\n                factor1 = weight[x1]\\n                factor2 = weight[x2]\\n                res.append(factor1 / factor2)\\n        return res\\n        \\nclass UnionFind():\\n    def __init__(self, parent, weight):\\n        self.parent = parent\\n        self.weight = weight\\n\\n    def find(self, vertex):\\n        if self.parent[vertex] == vertex:\\n            return vertex\\n        root = self.find(self.parent[vertex])\\n        self.weight[vertex] *= self.weight[self.parent[vertex]]\\n        self.parent[vertex] = root\\n        return root\\n\\n    def union(self, vertex1, vertex2, val):\\n        root1 = self.find(vertex1)\\n        root2 = self.find(vertex2)\\n        self.weight[root1]= self.weight[vertex2] * val / self.weight[vertex1]\\n        self.parent[root1] = root2",
                "solutionTags": [],
                "code": "class Solution:\\n    def calcEquation(self, equations, values, queries):\\n        \"\"\"\\n        :type equations: List[List[str]]\\n        :type values: List[float]\\n        :type queries: List[List[str]]\\n        :rtype: List[float]\\n        \"\"\"\\n        res = []\\n        parent = {}",
                "codeTag": "Java"
            },
            {
                "id": 162493,
                "title": "python-union-find-solution",
                "content": "```\\nclass Solution_UnionFind:\\n    def calcEquation(self, equations, values, queries):\\n        \"\"\"\\n        :type equations: List[List[str]]\\n        :type values: List[float]\\n        :type queries: List[List[str]]\\n        :rtype: List[float]\\n        \\n        Using Union+Find. Faster than DFS.\\n        \\n        Time: O(E+Q) , Union is approx O(1) because it\\'s using path compression during find.\\n        Space:  O(E)\\n        \"\"\"\\n        parents = {} #{Child:Parent}, eg {\\'a\\':\\'b\\'}\\n        weights = {} #{Node: float}, eg{\\'a\\': 1.0}\\n        result = []\\n        \\n        for (eq1,eq2),value in zip(equations,values):\\n            if eq1 not in parents:\\n                parents[eq1] = eq1\\n                weights[eq1] = 1.0\\n            if eq2 not in parents:\\n                parents[eq2] = eq2\\n                weights[eq2] = 1.0            \\n            self.union(eq1,eq2,parents,weights,value)\\n        \\n        for q1,q2 in queries:\\n            if q1 not in parents or q2 not in parents:\\n                result.append(-1.0)\\n            else:\\n                parent1 = self.find(q1,parents,weights)\\n                parent2 = self.find(q2,parents,weights)       \\n                if parent1!=parent2:\\n                    result.append(-1.0)\\n                else:\\n                    result.append(weights[q1]/weights[q2])\\n                \\n        return result\\n            \\n            \\n    def union(self,node1,node2,parents,weights,value):\\n        parent1 = self.find(node1,parents,weights)\\n        parent2 = self.find(node2,parents,weights)\\n        if parent1 != parent2:\\n            parents[parent1] = parent2\\n            weights[parent1] = value * (weights[node2] /weights[node1]) #IMPORTANT: Node1 may already be compressed: its weight could be the product of all weights up to parent1            \\n        \\n    def find(self, node, parents,weights):\\n        #Find parent node of a given node, doing path compression while doing so (set the node\\'s parent to its root and multiply all weights along the way.)     \\n        if parents[node] != node:\\n            p = parents[node]\\n            parents[node] = self.find(parents[node],parents,weights)\\n            weights[node] = weights[node] * weights[p]\\n        return parents[node]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution_UnionFind:\\n    def calcEquation(self, equations, values, queries):\\n        \"\"\"\\n        :type equations: List[List[str]]\\n        :type values: List[float]\\n        :type queries: List[List[str]]\\n        :rtype: List[float]\\n        \\n        Using Union+Find. Faster than DFS.\\n        \\n        Time: O(E+Q) , Union is approx O(1) because it\\'s using path compression during find.\\n        Space:  O(E)\\n        \"\"\"\\n        parents = {} #{Child:Parent}, eg {\\'a\\':\\'b\\'}\\n        weights = {} #{Node: float}, eg{\\'a\\': 1.0}\\n        result = []\\n        \\n        for (eq1,eq2),value in zip(equations,values):\\n            if eq1 not in parents:\\n                parents[eq1] = eq1\\n                weights[eq1] = 1.0\\n            if eq2 not in parents:\\n                parents[eq2] = eq2\\n                weights[eq2] = 1.0            \\n            self.union(eq1,eq2,parents,weights,value)\\n        \\n        for q1,q2 in queries:\\n            if q1 not in parents or q2 not in parents:\\n                result.append(-1.0)\\n            else:\\n                parent1 = self.find(q1,parents,weights)\\n                parent2 = self.find(q2,parents,weights)       \\n                if parent1!=parent2:\\n                    result.append(-1.0)\\n                else:\\n                    result.append(weights[q1]/weights[q2])\\n                \\n        return result\\n            \\n            \\n    def union(self,node1,node2,parents,weights,value):\\n        parent1 = self.find(node1,parents,weights)\\n        parent2 = self.find(node2,parents,weights)\\n        if parent1 != parent2:\\n            parents[parent1] = parent2\\n            weights[parent1] = value * (weights[node2] /weights[node1]) #IMPORTANT: Node1 may already be compressed: its weight could be the product of all weights up to parent1            \\n        \\n    def find(self, node, parents,weights):\\n        #Find parent node of a given node, doing path compression while doing so (set the node\\'s parent to its root and multiply all weights along the way.)     \\n        if parents[node] != node:\\n            p = parents[node]\\n            parents[node] = self.find(parents[node],parents,weights)\\n            weights[node] = weights[node] * weights[p]\\n        return parents[node]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88207,
                "title": "java-solution-using-floyd-u2013warshall-algorithm",
                "content": "Using a variant of [Floyd\\u2013Warshall algorithm](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm), to find the distance between each reachable pair:\\n```\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        HashMap<String, HashMap<String, Double>> graph = new HashMap<>();\\n        Function<String, HashMap<String, Double>> function = s -> new HashMap<>();\\n        for (int i = 0; i < equations.length; i++) {\\n            graph.computeIfAbsent(equations[i][0], function).put(equations[i][0], 1.0);\\n            graph.computeIfAbsent(equations[i][1], function).put(equations[i][1], 1.0);\\n            graph.get(equations[i][0]).put(equations[i][1], values[i]);\\n            graph.get(equations[i][1]).put(equations[i][0], 1 / values[i]);\\n        }\\n        for (String mid : graph.keySet()) {\\n            for (String src : graph.get(mid).keySet()) {\\n                for (String dst : graph.get(mid).keySet()) {\\n                    double val = graph.get(src).get(mid) * graph.get(mid).get(dst);\\n                    graph.get(src).put(dst, val);\\n                }\\n            }\\n        }\\n        double[] result = new double[queries.length];\\n        for (int i = 0; i < result.length; i++) {\\n            if (!graph.containsKey(queries[i][0])) {\\n                result[i] = -1;\\n            } else {\\n                result[i] = graph.get(queries[i][0]).getOrDefault(queries[i][1], -1.0);\\n            }\\n        }\\n        return result;\\n    }\\n```\\nIt is very slow, some optimization applied:\\n```\\n    public double[] calcEquation2(String[][] equations, double[] values, String[][] queries) {\\n        HashMap<String, HashMap<String, Double>> graph = new HashMap<>();\\n        for (int i = 0; i < equations.length; i++) {\\n            String src = equations[i][0], dst = equations[i][1];\\n            if (!graph.containsKey(src)) {\\n                graph.put(src, new HashMap<>());\\n            }\\n            if (!graph.containsKey(dst)) {\\n                graph.put(dst, new HashMap<>());\\n            }\\n            graph.get(src).put(src, 1.0);\\n            graph.get(dst).put(dst, 1.0);\\n            graph.get(src).put(dst, values[i]);\\n            graph.get(dst).put(src, 1 / values[i]);\\n        }\\n        for (String mid : graph.keySet()) {\\n            for (String src : graph.get(mid).keySet()) {\\n                for (String dst : graph.get(mid).keySet()) {\\n                    double val = graph.get(src).get(mid) * graph.get(mid).get(dst);\\n                    graph.get(src).put(dst, val);\\n                }\\n            }\\n        }\\n        double[] result = new double[queries.length];\\n        for (int i = 0; i < result.length; i++) {\\n            if (!graph.containsKey(queries[i][0])) {\\n                result[i] = -1;\\n            } else {\\n                result[i] = graph.get(queries[i][0]).getOrDefault(queries[i][1], -1.0);\\n            }\\n        }\\n        return result;\\n    }\\n```\\nIn practice, we can use guava's `HashBasedTable`, do not have to use `HashMap<String,HashMap<String,Double>>`,:\\n```\\nimport com.google.common.collect.HashBasedTable;\\nimport com.google.common.collect.Table;\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        Table<String, String, Double> table = HashBasedTable.create();\\n        for (int i = 0; i < equations.length; i++) {\\n            String src = equations[i][0], dst = equations[i][1];\\n            table.put(src, src, 1.0);\\n            table.put(dst, dst, 1.0);\\n            table.put(src, dst, values[i]);\\n            table.put(dst, src, 1.0 / values[i]);\\n        }\\n        for (String mid : table.rowKeySet()) {\\n            for (String src : table.row(mid).keySet()) {\\n                for (String dst : table.row(mid).keySet()) {\\n                    double val = table.get(src, mid) * table.get(mid, dst);\\n                    table.put(src, dst, val);\\n                }\\n            }\\n        }\\n        double[] result = new double[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            result[i] = table.contains(queries[i][0], queries[i][1]) ? table.get(queries[i][0], queries[i][1]) : -1.0;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        HashMap<String, HashMap<String, Double>> graph = new HashMap<>();\\n        Function<String, HashMap<String, Double>> function = s -> new HashMap<>();\\n        for (int i = 0; i < equations.length; i++) {\\n            graph.computeIfAbsent(equations[i][0], function).put(equations[i][0], 1.0);\\n            graph.computeIfAbsent(equations[i][1], function).put(equations[i][1], 1.0);\\n            graph.get(equations[i][0]).put(equations[i][1], values[i]);\\n            graph.get(equations[i][1]).put(equations[i][0], 1 / values[i]);\\n        }\\n        for (String mid : graph.keySet()) {\\n            for (String src : graph.get(mid).keySet()) {\\n                for (String dst : graph.get(mid).keySet()) {\\n                    double val = graph.get(src).get(mid) * graph.get(mid).get(dst);\\n                    graph.get(src).put(dst, val);\\n                }\\n            }\\n        }\\n        double[] result = new double[queries.length];\\n        for (int i = 0; i < result.length; i++) {\\n            if (!graph.containsKey(queries[i][0])) {\\n                result[i] = -1;\\n            } else {\\n                result[i] = graph.get(queries[i][0]).getOrDefault(queries[i][1], -1.0);\\n            }\\n        }\\n        return result;\\n    }\\n```\n```\\n    public double[] calcEquation2(String[][] equations, double[] values, String[][] queries) {\\n        HashMap<String, HashMap<String, Double>> graph = new HashMap<>();\\n        for (int i = 0; i < equations.length; i++) {\\n            String src = equations[i][0], dst = equations[i][1];\\n            if (!graph.containsKey(src)) {\\n                graph.put(src, new HashMap<>());\\n            }\\n            if (!graph.containsKey(dst)) {\\n                graph.put(dst, new HashMap<>());\\n            }\\n            graph.get(src).put(src, 1.0);\\n            graph.get(dst).put(dst, 1.0);\\n            graph.get(src).put(dst, values[i]);\\n            graph.get(dst).put(src, 1 / values[i]);\\n        }\\n        for (String mid : graph.keySet()) {\\n            for (String src : graph.get(mid).keySet()) {\\n                for (String dst : graph.get(mid).keySet()) {\\n                    double val = graph.get(src).get(mid) * graph.get(mid).get(dst);\\n                    graph.get(src).put(dst, val);\\n                }\\n            }\\n        }\\n        double[] result = new double[queries.length];\\n        for (int i = 0; i < result.length; i++) {\\n            if (!graph.containsKey(queries[i][0])) {\\n                result[i] = -1;\\n            } else {\\n                result[i] = graph.get(queries[i][0]).getOrDefault(queries[i][1], -1.0);\\n            }\\n        }\\n        return result;\\n    }\\n```\n```\\nimport com.google.common.collect.HashBasedTable;\\nimport com.google.common.collect.Table;\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        Table<String, String, Double> table = HashBasedTable.create();\\n        for (int i = 0; i < equations.length; i++) {\\n            String src = equations[i][0], dst = equations[i][1];\\n            table.put(src, src, 1.0);\\n            table.put(dst, dst, 1.0);\\n            table.put(src, dst, values[i]);\\n            table.put(dst, src, 1.0 / values[i]);\\n        }\\n        for (String mid : table.rowKeySet()) {\\n            for (String src : table.row(mid).keySet()) {\\n                for (String dst : table.row(mid).keySet()) {\\n                    double val = table.get(src, mid) * table.get(mid, dst);\\n                    table.put(src, dst, val);\\n                }\\n            }\\n        }\\n        double[] result = new double[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            result[i] = table.contains(queries[i][0], queries[i][1]) ? table.get(queries[i][0], queries[i][1]) : -1.0;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 178091,
                "title": "javascript-bfs-100-beat-solution-explanation-included",
                "content": "Basically, start we queue up all the \\'children\\' of the expression that we\\'re currently solving, and keep evaluating them until we run out. We do this by first making an adjacency list. For example.\\n\\nKnowns: [a, b] = 2, [b, c] = 3. So we also know then that [b, a] = 0.5, and [c, b] = 0.333. (We initilise the adjacency map as we go with these too, hence 1/values).\\n\\nThe adjacency list then looks like:\\n\\na : [[b, 2]]\\nb : [[a, 0.5], [c, 3]]\\nc : [[b, 0.333]]\\n\\nso when we want to evaluate for example [a, c], all we do is put a\\'s mapping into the queue and keep evaluating until we see c. We multiply the numbers as we go as it\\'s nested division.This looks like:\\n\\nqueue: [[b, 2]]\\nqueue: [[a, 1], [c, 6]] // Here we add the \\'neighbours\\' of b, where we\\'re b maps to a and c. a/a=1, and a/c=6, so it makes sense.\\nqueue: [c, 6]\\n\\nsolved!\\n\\n\\n\\n\\n```\\nvar calcEquation = function(equations, values, queries) {\\n    var neighbours = {};\\n\\n    // Initialise the adjacency list!\\n    for (var e = 0; e < equations.length; e++){\\n        neighbours[equations[e][0]] = [];\\n        neighbours[equations[e][1]] = [];\\n    }\\n    for (var e = 0; e < equations.length; e++){\\n        neighbours[equations[e][0]].push([equations[e][1], values[e]]);\\n        neighbours[equations[e][1]].push([equations[e][0], 1/values[e]]);\\n    }\\n    \\n    res = [];\\n    for (e of queries){\\n        res.push(evaluateExpression(e, neighbours))\\n    }\\n    return res;\\n};\\n\\n\\nfunction evaluateExpression(expression, neighboursList){\\n    if (!(expression[0] in neighboursList) || !(expression[1] in neighboursList)) { return -1; }\\n    if (expression[0] == expression[1]) { return 1; } \\n    \\n    // Initialise with the expression we want to get! We start with the numerator\\'s children in the queue.\\n    var q = neighboursList[expression[0]].slice();\\n    var checked = [];\\n    \\n    while (q.length > 0){\\n        //console.log(q, checked)\\n        var elem = q.shift();\\n        \\n        // If our element is part of the expression, then we\\'re done!\\n        if (elem[0] == expression[1]){ \\n            //console.log(\"DONE\")\\n            return elem[1] \\n        }\\n        checked.push(elem[0]);\\n        \\n        // Otherwise add the neighbours to the queue with updated divisors.\\n        var neighbours = neighboursList[elem[0]];\\n        for (var n = 0; n < neighbours.length; n++){\\n            var nextToCheck = neighbours[n];\\n            if (checked.includes(nextToCheck[0])){ continue ;}\\n            q.push([nextToCheck[0], nextToCheck[1]*elem[1]])\\n        }\\n    }\\n    \\n    \\n    return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar calcEquation = function(equations, values, queries) {\\n    var neighbours = {};\\n\\n    // Initialise the adjacency list!\\n    for (var e = 0; e < equations.length; e++){\\n        neighbours[equations[e][0]] = [];\\n        neighbours[equations[e][1]] = [];\\n    }\\n    for (var e = 0; e < equations.length; e++){\\n        neighbours[equations[e][0]].push([equations[e][1], values[e]]);\\n        neighbours[equations[e][1]].push([equations[e][0], 1/values[e]]);\\n    }\\n    \\n    res = [];\\n    for (e of queries){\\n        res.push(evaluateExpression(e, neighbours))\\n    }\\n    return res;\\n};\\n\\n\\nfunction evaluateExpression(expression, neighboursList){\\n    if (!(expression[0] in neighboursList) || !(expression[1] in neighboursList)) { return -1; }\\n    if (expression[0] == expression[1]) { return 1; } \\n    \\n    // Initialise with the expression we want to get! We start with the numerator\\'s children in the queue.\\n    var q = neighboursList[expression[0]].slice();\\n    var checked = [];\\n    \\n    while (q.length > 0){\\n        //console.log(q, checked)\\n        var elem = q.shift();\\n        \\n        // If our element is part of the expression, then we\\'re done!\\n        if (elem[0] == expression[1]){ \\n            //console.log(\"DONE\")\\n            return elem[1] \\n        }\\n        checked.push(elem[0]);\\n        \\n        // Otherwise add the neighbours to the queue with updated divisors.\\n        var neighbours = neighboursList[elem[0]];\\n        for (var n = 0; n < neighbours.length; n++){\\n            var nextToCheck = neighbours[n];\\n            if (checked.includes(nextToCheck[0])){ continue ;}\\n            q.push([nextToCheck[0], nextToCheck[1]*elem[1]])\\n        }\\n    }\\n    \\n    \\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3543212,
                "title": "java-dfs-beats-90-clean-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConstruct a directed graph where the nodes are the numerators and denominators of the equations. A directed edge starts from the numerator and ends at the denominator and carries a weight equal to the value of `numerator / denominator`. Now we can approach solving each query as a graph traversal problem. We have to start from the `numerator` node of the query and reach the `denominator` node of the query, multiplying the weights of all the edges along the way.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  Map<String, Map<String, Double>> map = new HashMap<>();\\n  Set<String> seen = new HashSet<>();\\n\\n  private double dfs(String s, String target, double num) {\\n    if (!map.containsKey(s)) return -1.0;\\n    if (s.equals(target)) return num;\\n    seen.add(s);\\n\\n    for (var div : map.get(s).entrySet()) {\\n      if (!seen.contains(div.getKey())) {\\n        var ans = dfs(div.getKey(), target, div.getValue());\\n\\n        if (ans != -1) return num * ans;\\n      }\\n    }\\n    return -1.0;\\n  }\\n\\n  public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n    var n = queries.size();\\n    var ans = new double[n];\\n\\n    for (var i=0; i < equations.size(); i++) {\\n      map.putIfAbsent(equations.get(i).get(0), new HashMap<>());\\n      map.putIfAbsent(equations.get(i).get(1), new HashMap<>());\\n\\n      map.get(equations.get(i).get(0)).put(equations.get(i).get(1), values[i]);\\n      map.get(equations.get(i).get(1)).put(equations.get(i).get(0), 1 / values[i]);\\n    }\\n    for (var i=0; i<n; i++) {\\n      seen.clear();\\n      ans[i] = dfs(queries.get(i).get(0), queries.get(i).get(1), 1.0);\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n  Map<String, Map<String, Double>> map = new HashMap<>();\\n  Set<String> seen = new HashSet<>();\\n\\n  private double dfs(String s, String target, double num) {\\n    if (!map.containsKey(s)) return -1.0;\\n    if (s.equals(target)) return num;\\n    seen.add(s);\\n\\n    for (var div : map.get(s).entrySet()) {\\n      if (!seen.contains(div.getKey())) {\\n        var ans = dfs(div.getKey(), target, div.getValue());\\n\\n        if (ans != -1) return num * ans;\\n      }\\n    }\\n    return -1.0;\\n  }\\n\\n  public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n    var n = queries.size();\\n    var ans = new double[n];\\n\\n    for (var i=0; i < equations.size(); i++) {\\n      map.putIfAbsent(equations.get(i).get(0), new HashMap<>());\\n      map.putIfAbsent(equations.get(i).get(1), new HashMap<>());\\n\\n      map.get(equations.get(i).get(0)).put(equations.get(i).get(1), values[i]);\\n      map.get(equations.get(i).get(1)).put(equations.get(i).get(0), 1 / values[i]);\\n    }\\n    for (var i=0; i<n; i++) {\\n      seen.clear();\\n      ans[i] = dfs(queries.get(i).get(0), queries.get(i).get(1), 1.0);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149370,
                "title": "java-clean-union-find-solution-with-detailed-comments",
                "content": "Remeber the path compression in a more traditional Union-Find algorithm; Either we can do it iteratively: \\n```\\npublic int find(int u, int[] parents) {\\n\\twhile (parents[u] != u) {\\n\\t\\tparents[u] = parents[parents[u]];\\n\\t\\tu = parents[u];\\n\\t}\\n\\treturn u;\\n}\\n```\\n\\nOr we can do it recursively: \\n\\n```\\npublic int find(int u, int[] parents) {\\n\\twhile (parenst[u] != u) {\\n\\t\\tparents[u] = find(parents[u], parents);\\n\\t}\\n\\treturn parents[u];\\n}\\n```\\n\\nHere in this question, we need to not only find the parent, but also get the weights between the parent of each String and the String itself. \\n\\nFirst of all, define the parents Map properly as: \\n```\\n/* \\nKey: u  Value: {uParent, uWeight} s.t. u = uParent * uWeight;\\n\\tNamely, denoting uParent as 1 unit & each child u is uWeight units\\n\\nExample: [\"a\", \"b\"] & 2.0   ==>   parent.get(\"b\") = {\"a\", 0.5}\\n*/\\nprivate Map<String, Pair<String, Double>> parents = new HashMap<>();\\n```\\n\\nThen, write the Union & Find function based on our parent Map: \\n**Union Step**\\n\\n```\\n// given a pair {u, v} with u = v * w\\nprivate void union(String u, String v, Double w) {\\n\\tPair<String, Double> uPair = find(u);\\n\\tPair<String, Double> vPair = find(v);\\n\\n\\tString uParent = uPair.getKey();\\n\\tdouble uWeight = uPair.getValue();\\n\\n\\tString vParent = vPair.getKey();\\n\\tdouble vWeight = vPair.getValue();\\n\\n\\n\\t/*\\n\\tThe input is u / v = w  <==>  u = v * w\\n\\n\\tAssuming we have:\\n\\t\\t1. parents.get(u) = {uPar, uWei}  <==> u = uPar * uWei \\n\\t\\t2. parents.get(v) = {vPar, vWei}  <==> v = vPar * vWei\\n\\n\\tThen we have: \\n\\t\\tuPar = (v * w) / uWei\\n\\t\\t\\t = (vWei * vPar * w) / uWei\\n\\t\\t\\t = vPar * (vWei / uWei * w) \\n\\n\\tAssuming no contradiction we should put:\\n\\t\\tparent.put(uParent,  { vPar, vWei / uWei * w } ) \\n\\t*/\\n\\n\\tif (!uParent.equals(vParent)) {\\n\\t\\tparents.put(uParent, new Pair(vParent, vWeight / uWeight * w));\\n\\t}\\n}\\n```\\n\\n**Find Step (Recursive)**\\n\\n```\\nprivate Pair<String, Double> find(String u) {\\n\\tif (!parents.containsKey(u)) {\\n\\t\\tparents.put(u, new Pair(u, 1.0));\\n\\t\\treturn parents.get(u);\\n\\t}\\n\\n\\tif (!parents.get(u).getKey().equals(u)) {\\n\\t\\tPair<String, Double> uParentPair = parents.get(u);\\n\\t\\tPair<String, Double> uGrandParentPair = find(uParentPair.getKey());\\n\\n\\t\\tparents.put(u, new Pair(uGrandParentPair.getKey(), \\n\\t\\t\\t\\t\\t\\t\\t\\tuParentPair.getValue() * uGrandParentPair.getValue()));\\n\\t}\\n\\n\\treturn parents.get(u);\\n\\n}\\n```\\n\\n**Find Step (Iterative)**\\n\\n```\\nprivate Pair<String, Double> find(String u) {\\n\\tif (!parents.containsKey(u)) {\\n\\t\\tparents.put(u, new Pair(u, 1.0));\\n\\t\\treturn parents.get(u);\\n\\t}\\n\\n\\tdouble val = 1.0;\\n\\twhile (!parents.get(u).getKey().equals(u)) {\\n\\t\\tPair<String, Double> uParentPair = parents.get(u);\\n\\t\\tPair<String, Double> uGrandParentPair = parents.get(uParentPair.getKey());\\n\\n\\t\\tval *= uParentPair.getValue() * uGrandParentPair.getValue();\\n\\n\\t\\tparents.put(u, new Pair(uGrandParentPair.getKey(), \\n\\t\\t\\t\\t\\t\\t\\t\\tuParentPair.getValue() * uGrandParentPair.getValue()));\\n\\t\\tu = parents.get(u).getKey();   \\n\\t}\\n\\n\\treturn new Pair(u, val);\\n}\\n```\\n\\nThen we can compose everything into the Final Solution: \\n**Final Solution:**\\n\\n```\\nclass Solution {\\n    private Map<String, Pair<String, Double>> parents = new HashMap<>();\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values,\\n                                 List<List<String>> queries) {\\n        // Step 1: build union groups\\n        for (int i = 0; i < equations.size(); i++) {\\n            List<String> equation = equations.get(i);\\n            \\n            String u = equation.get(0), v = equation.get(1);\\n            double w = values[i];\\n\\n            union(u, v, w);\\n        }\\n\\n        // Step 2. try to make the query\\n        double[] res = new double[queries.size()];\\n        for (int i = 0; i < queries.size(); i++) {\\n            List<String> query = queries.get(i);\\n            String u = query.get(0), v = query.get(1);\\n\\n            // case 1:  u or v never appear before\\n            if (!parents.containsKey(u) || !parents.containsKey(v)) {\\n                res[i] = -1.0;\\n                continue;\\n            }\\n                \\n            \\n            Pair<String, Double> uPair = find(u);\\n            Pair<String, Double> vPair = find(v);\\n\\n            String uParent = uPair.getKey();\\n            double uWeight = uPair.getValue();\\n            \\n            String vParent = vPair.getKey();\\n            double vWeight = vPair.getValue();\\n\\n            if (!uParent.equals(vParent))\\n                // case 2:  u & v NOT belong to the same group\\n                res[i] = -1.0;\\n            else\\n                /* case 3:  u & v belong to the same group  <==>  uPar == vPar\\n                            Then we want to query u / v:\\n                \\n                Assuming we have:\\n                    1. u = uPar * uWei  \\n                    2. v = vPar * vWei = uPar * vWei\\n                \\n                Thus  u / v = uWei / vWei                    */\\n                res[i] = uWeight / vWeight;\\n            \\n        }\\n        return res;\\n    }\\n    \\n    private Pair<String, Double> find(String u) {\\n        if (!parents.containsKey(u)) {\\n            parents.put(u, new Pair(u, 1.0));\\n            return parents.get(u);\\n        }\\n        \\n        if (!parents.get(u).getKey().equals(u)) {\\n            Pair<String, Double> uParentPair = parents.get(u);\\n            Pair<String, Double> uGrandParentPair = find(uParentPair.getKey());\\n            \\n            parents.put(u, new Pair(uGrandParentPair.getKey(), \\n                                    uParentPair.getValue() * uGrandParentPair.getValue()));\\n        }\\n        return parents.get(u);\\n    }\\n    \\n    \\n    private void union(String u, String v, Double w) {\\n        Pair<String, Double> uPair = find(u);\\n        Pair<String, Double> vPair = find(v);\\n\\n        String uParent = uPair.getKey();\\n        double uWeight = uPair.getValue();\\n\\n        String vParent = vPair.getKey();\\n        double vWeight = vPair.getValue();\\n\\n        if (!uParent.equals(vParent)) {\\n            parents.put(uParent, new Pair(vParent, vWeight / uWeight * w));\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\npublic int find(int u, int[] parents) {\\n\\twhile (parents[u] != u) {\\n\\t\\tparents[u] = parents[parents[u]];\\n\\t\\tu = parents[u];\\n\\t}\\n\\treturn u;\\n}\\n```\n```\\npublic int find(int u, int[] parents) {\\n\\twhile (parenst[u] != u) {\\n\\t\\tparents[u] = find(parents[u], parents);\\n\\t}\\n\\treturn parents[u];\\n}\\n```\n```\\n/* \\nKey: u  Value: {uParent, uWeight} s.t. u = uParent * uWeight;\\n\\tNamely, denoting uParent as 1 unit & each child u is uWeight units\\n\\nExample: [\"a\", \"b\"] & 2.0   ==>   parent.get(\"b\") = {\"a\", 0.5}\\n*/\\nprivate Map<String, Pair<String, Double>> parents = new HashMap<>();\\n```\n```\\n// given a pair {u, v} with u = v * w\\nprivate void union(String u, String v, Double w) {\\n\\tPair<String, Double> uPair = find(u);\\n\\tPair<String, Double> vPair = find(v);\\n\\n\\tString uParent = uPair.getKey();\\n\\tdouble uWeight = uPair.getValue();\\n\\n\\tString vParent = vPair.getKey();\\n\\tdouble vWeight = vPair.getValue();\\n\\n\\n\\t/*\\n\\tThe input is u / v = w  <==>  u = v * w\\n\\n\\tAssuming we have:\\n\\t\\t1. parents.get(u) = {uPar, uWei}  <==> u = uPar * uWei \\n\\t\\t2. parents.get(v) = {vPar, vWei}  <==> v = vPar * vWei\\n\\n\\tThen we have: \\n\\t\\tuPar = (v * w) / uWei\\n\\t\\t\\t = (vWei * vPar * w) / uWei\\n\\t\\t\\t = vPar * (vWei / uWei * w) \\n\\n\\tAssuming no contradiction we should put:\\n\\t\\tparent.put(uParent,  { vPar, vWei / uWei * w } ) \\n\\t*/\\n\\n\\tif (!uParent.equals(vParent)) {\\n\\t\\tparents.put(uParent, new Pair(vParent, vWeight / uWeight * w));\\n\\t}\\n}\\n```\n```\\nprivate Pair<String, Double> find(String u) {\\n\\tif (!parents.containsKey(u)) {\\n\\t\\tparents.put(u, new Pair(u, 1.0));\\n\\t\\treturn parents.get(u);\\n\\t}\\n\\n\\tif (!parents.get(u).getKey().equals(u)) {\\n\\t\\tPair<String, Double> uParentPair = parents.get(u);\\n\\t\\tPair<String, Double> uGrandParentPair = find(uParentPair.getKey());\\n\\n\\t\\tparents.put(u, new Pair(uGrandParentPair.getKey(), \\n\\t\\t\\t\\t\\t\\t\\t\\tuParentPair.getValue() * uGrandParentPair.getValue()));\\n\\t}\\n\\n\\treturn parents.get(u);\\n\\n}\\n```\n```\\nprivate Pair<String, Double> find(String u) {\\n\\tif (!parents.containsKey(u)) {\\n\\t\\tparents.put(u, new Pair(u, 1.0));\\n\\t\\treturn parents.get(u);\\n\\t}\\n\\n\\tdouble val = 1.0;\\n\\twhile (!parents.get(u).getKey().equals(u)) {\\n\\t\\tPair<String, Double> uParentPair = parents.get(u);\\n\\t\\tPair<String, Double> uGrandParentPair = parents.get(uParentPair.getKey());\\n\\n\\t\\tval *= uParentPair.getValue() * uGrandParentPair.getValue();\\n\\n\\t\\tparents.put(u, new Pair(uGrandParentPair.getKey(), \\n\\t\\t\\t\\t\\t\\t\\t\\tuParentPair.getValue() * uGrandParentPair.getValue()));\\n\\t\\tu = parents.get(u).getKey();   \\n\\t}\\n\\n\\treturn new Pair(u, val);\\n}\\n```\n```\\nclass Solution {\\n    private Map<String, Pair<String, Double>> parents = new HashMap<>();\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values,\\n                                 List<List<String>> queries) {\\n        // Step 1: build union groups\\n        for (int i = 0; i < equations.size(); i++) {\\n            List<String> equation = equations.get(i);\\n            \\n            String u = equation.get(0), v = equation.get(1);\\n            double w = values[i];\\n\\n            union(u, v, w);\\n        }\\n\\n        // Step 2. try to make the query\\n        double[] res = new double[queries.size()];\\n        for (int i = 0; i < queries.size(); i++) {\\n            List<String> query = queries.get(i);\\n            String u = query.get(0), v = query.get(1);\\n\\n            // case 1:  u or v never appear before\\n            if (!parents.containsKey(u) || !parents.containsKey(v)) {\\n                res[i] = -1.0;\\n                continue;\\n            }\\n                \\n            \\n            Pair<String, Double> uPair = find(u);\\n            Pair<String, Double> vPair = find(v);\\n\\n            String uParent = uPair.getKey();\\n            double uWeight = uPair.getValue();\\n            \\n            String vParent = vPair.getKey();\\n            double vWeight = vPair.getValue();\\n\\n            if (!uParent.equals(vParent))\\n                // case 2:  u & v NOT belong to the same group\\n                res[i] = -1.0;\\n            else\\n                /* case 3:  u & v belong to the same group  <==>  uPar == vPar\\n                            Then we want to query u / v:\\n                \\n                Assuming we have:\\n                    1. u = uPar * uWei  \\n                    2. v = vPar * vWei = uPar * vWei\\n                \\n                Thus  u / v = uWei / vWei                    */\\n                res[i] = uWeight / vWeight;\\n            \\n        }\\n        return res;\\n    }\\n    \\n    private Pair<String, Double> find(String u) {\\n        if (!parents.containsKey(u)) {\\n            parents.put(u, new Pair(u, 1.0));\\n            return parents.get(u);\\n        }\\n        \\n        if (!parents.get(u).getKey().equals(u)) {\\n            Pair<String, Double> uParentPair = parents.get(u);\\n            Pair<String, Double> uGrandParentPair = find(uParentPair.getKey());\\n            \\n            parents.put(u, new Pair(uGrandParentPair.getKey(), \\n                                    uParentPair.getValue() * uGrandParentPair.getValue()));\\n        }\\n        return parents.get(u);\\n    }\\n    \\n    \\n    private void union(String u, String v, Double w) {\\n        Pair<String, Double> uPair = find(u);\\n        Pair<String, Double> vPair = find(v);\\n\\n        String uParent = uPair.getKey();\\n        double uWeight = uPair.getValue();\\n\\n        String vParent = vPair.getKey();\\n        double vWeight = vPair.getValue();\\n\\n        if (!uParent.equals(vParent)) {\\n            parents.put(uParent, new Pair(vParent, vWeight / uWeight * w));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455817,
                "title": "c-dfs-solution",
                "content": "Firstly we construct a graph such that an equation `a / b = x` contributes two edges: `a->b` and `b->a`, corresponding to values `x` and `1/x`, respectively.\\n\\nAfter constructing this graph, for each query `q`, we invoke a depth first search function where the node is `q[0]` and the target node is `q[1]`. If a path is found from `q[0]` to `q[1]`, we multiply values along the path, and get the result. If no path is found, or either node does not exist in the graph, we return `-1.0`.\\n\\n```\\nclass Solution {\\nprivate:\\n    \\n    bool dfs(string cur, string target, unordered_map<string, vector<pair<string, double>>>& adjlist, unordered_set<string>& visited, double& val) {\\n        if (!adjlist.count(target) or !adjlist.count(cur)) {\\n            // not in graph\\n            return false;\\n        }\\n        else if (cur == target) {\\n            // found, val is the result\\n            return true;\\n        }\\n        else {\\n            // keep searching\\n            visited.insert(cur);\\n            for (auto& node : adjlist[cur]) {\\n                if (!visited.count(node.first)) {\\n                    double lastval = val;\\n                    val *= node.second;\\n                    if (dfs(node.first, target, adjlist, visited, val)) {\\n                        return true;\\n                    }\\n                    val = lastval;\\n                }\\n            }\\n\\t\\t\\t// no path found\\n            return false;\\n        }\\n    }\\n        \\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        // construct graph adj list\\n        unordered_map<string, vector<pair<string, double>>> adjlist;\\n        for (int i(0); i < equations.size(); ++i) {\\n            string nume = equations[i][0];\\n            string deno = equations[i][1];\\n            double rst = values[i];\\n            \\n            if (!adjlist.count(nume)) {\\n                adjlist[nume] = vector<pair<string, double>>();\\n            }\\n            adjlist[nume].push_back(make_pair(deno, rst));\\n            if (!adjlist.count(deno)) {\\n                adjlist[deno] = vector<pair<string, double>>();\\n            }\\n            adjlist[deno].push_back(make_pair(nume, 1.0 / rst));\\n        }\\n        // process each query by DFS\\n        vector<double> rst;\\n        for (const auto& x : queries) {\\n            unordered_set<string> visited;\\n            double val = 1.0;\\n            if (dfs(x[0], x[1], adjlist, visited, val)) {\\n                rst.push_back(val);\\n            }\\n            else {\\n                rst.push_back(-1.0);\\n            }\\n        }\\n        return rst;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\n    bool dfs(string cur, string target, unordered_map<string, vector<pair<string, double>>>& adjlist, unordered_set<string>& visited, double& val) {\\n        if (!adjlist.count(target) or !adjlist.count(cur)) {\\n            // not in graph\\n            return false;\\n        }\\n        else if (cur == target) {\\n            // found, val is the result\\n            return true;\\n        }\\n        else {\\n            // keep searching\\n            visited.insert(cur);\\n            for (auto& node : adjlist[cur]) {\\n                if (!visited.count(node.first)) {\\n                    double lastval = val;\\n                    val *= node.second;\\n                    if (dfs(node.first, target, adjlist, visited, val)) {\\n                        return true;\\n                    }\\n                    val = lastval;\\n                }\\n            }\\n\\t\\t\\t// no path found\\n            return false;\\n        }\\n    }\\n        \\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        // construct graph adj list\\n        unordered_map<string, vector<pair<string, double>>> adjlist;\\n        for (int i(0); i < equations.size(); ++i) {\\n            string nume = equations[i][0];\\n            string deno = equations[i][1];\\n            double rst = values[i];\\n            \\n            if (!adjlist.count(nume)) {\\n                adjlist[nume] = vector<pair<string, double>>();\\n            }\\n            adjlist[nume].push_back(make_pair(deno, rst));\\n            if (!adjlist.count(deno)) {\\n                adjlist[deno] = vector<pair<string, double>>();\\n            }\\n            adjlist[deno].push_back(make_pair(nume, 1.0 / rst));\\n        }\\n        // process each query by DFS\\n        vector<double> rst;\\n        for (const auto& x : queries) {\\n            unordered_set<string> visited;\\n            double val = 1.0;\\n            if (dfs(x[0], x[1], adjlist, visited, val)) {\\n                rst.push_back(val);\\n            }\\n            else {\\n                rst.push_back(-1.0);\\n            }\\n        }\\n        return rst;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389027,
                "title": "java-0-ms-faster-than-100-simple-dfs",
                "content": "```\\nclass Solution {\\n    HashMap<String, ArrayList<Pair>> graph = new HashMap<>();\\n    public class Pair{\\n        String v;\\n        double w;\\n        Pair(String v, double w){\\n            this.v = v;\\n            this.w = w;\\n        }\\n        public String toString(){\\n            return v + \" \" + w;\\n        }\\n    }\\n    \\n    public double dfs(String src, String dest, HashSet<String> vis){\\n        vis.add(src);\\n        if(src.equals(dest)) return 1;\\n        double ans = 1;\\n        for(Pair e : graph.get(src)){\\n            if(!vis.contains(e.v)){\\n                double ret = dfs(e.v, dest, vis);\\n                if(ret > 0) return e.w * ret;\\n            }\\n        }\\n        return -1.0;\\n    }\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        double[] qAnswer = new double[queries.size()];\\n        for(int i = 0 ; i < equations.size() ; i++){\\n            String u = equations.get(i).get(0), v = equations.get(i).get(1);\\n            double w = values[i];\\n            graph.putIfAbsent(u, new ArrayList<>());\\n            graph.putIfAbsent(v, new ArrayList<>());\\n            graph.get(u).add(new Pair(v, w));\\n            graph.get(v).add(new Pair(u, 1/w));\\n        }\\n        \\n        for(int i = 0 ; i < queries.size() ; i++){\\n            String u = queries.get(i).get(0), v = queries.get(i).get(1);\\n            double q = graph.containsKey(u) ? dfs(u, v, new HashSet<>()) : -1.0;\\n            qAnswer[i] = q;\\n        }\\n        \\n        return qAnswer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, ArrayList<Pair>> graph = new HashMap<>();\\n    public class Pair{\\n        String v;\\n        double w;\\n        Pair(String v, double w){\\n            this.v = v;\\n            this.w = w;\\n        }\\n        public String toString(){\\n            return v + \" \" + w;\\n        }\\n    }\\n    \\n    public double dfs(String src, String dest, HashSet<String> vis){\\n        vis.add(src);\\n        if(src.equals(dest)) return 1;\\n        double ans = 1;\\n        for(Pair e : graph.get(src)){\\n            if(!vis.contains(e.v)){\\n                double ret = dfs(e.v, dest, vis);\\n                if(ret > 0) return e.w * ret;\\n            }\\n        }\\n        return -1.0;\\n    }\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        double[] qAnswer = new double[queries.size()];\\n        for(int i = 0 ; i < equations.size() ; i++){\\n            String u = equations.get(i).get(0), v = equations.get(i).get(1);\\n            double w = values[i];\\n            graph.putIfAbsent(u, new ArrayList<>());\\n            graph.putIfAbsent(v, new ArrayList<>());\\n            graph.get(u).add(new Pair(v, w));\\n            graph.get(v).add(new Pair(u, 1/w));\\n        }\\n        \\n        for(int i = 0 ; i < queries.size() ; i++){\\n            String u = queries.get(i).get(0), v = queries.get(i).get(1);\\n            double q = graph.containsKey(u) ? dfs(u, v, new HashSet<>()) : -1.0;\\n            qAnswer[i] = q;\\n        }\\n        \\n        return qAnswer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387800,
                "title": "c-0ms-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    double dfs(unordered_map<string, unordered_map<string , double>>&graph, string a , string& b , unordered_set<string>&visited){\\n        if(graph[a].find(b) != graph[a].end()) \\n            return graph[a][b];\\n        \\n        for(auto v : graph[a]){\\n            if(visited.find(v.first) == visited.end()){\\n                visited.insert(v.first);\\n                double dist = dfs(graph,v.first,b,visited );\\n                    if(dist) {\\n                        graph[a][b] = v.second * dist;\\n                        return graph[a][b];\\n                    }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double> result; \\n        unordered_map<string, unordered_map<string , double>> graph; \\n        for(int i=0;i<equations.size();i++){\\n            graph[equations[i][0]][equations[i][1]] = (values[i]); \\n            graph[equations[i][1]][equations[i][0]] = (double) 1/(values[i]); \\n        }\\n        for(int i=0;i<queries.size();i++){           \\n            unordered_set<string> visited;             \\n            double val = dfs(graph , queries[i][0] , queries[i][1] , visited );\\n            if(!val)\\n                result.push_back(double(-1.0));\\n            else \\n                result.push_back(val);\\n        }\\n            \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    double dfs(unordered_map<string, unordered_map<string , double>>&graph, string a , string& b , unordered_set<string>&visited){\\n        if(graph[a].find(b) != graph[a].end()) \\n            return graph[a][b];\\n        \\n        for(auto v : graph[a]){\\n            if(visited.find(v.first) == visited.end()){\\n                visited.insert(v.first);\\n                double dist = dfs(graph,v.first,b,visited );\\n                    if(dist) {\\n                        graph[a][b] = v.second * dist;\\n                        return graph[a][b];\\n                    }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double> result; \\n        unordered_map<string, unordered_map<string , double>> graph; \\n        for(int i=0;i<equations.size();i++){\\n            graph[equations[i][0]][equations[i][1]] = (values[i]); \\n            graph[equations[i][1]][equations[i][0]] = (double) 1/(values[i]); \\n        }\\n        for(int i=0;i<queries.size();i++){           \\n            unordered_set<string> visited;             \\n            double val = dfs(graph , queries[i][0] , queries[i][1] , visited );\\n            if(!val)\\n                result.push_back(double(-1.0));\\n            else \\n                result.push_back(val);\\n        }\\n            \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544099,
                "title": "c-dfs-map-beats-100",
                "content": "![Screenshot (204).png](https://assets.leetcode.com/users/images/720c7799-53ef-401f-8872-653413744c9b_1684569267.2767744.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(string src,string des,unordered_map<string,vector<pair<string,double>>>&mp,map<string,int>m,double &ans,double temp){\\n         m[src]=1;\\n        if(src==des){\\n            ans=temp;\\n            return;\\n        }\\n        for(auto k : mp[src]){\\n            if(m[k.first]==0){\\n              dfs(k.first,des,mp,m,ans,temp*k.second);\\n            }\\n        }\\n        return;\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& e, vector<double>& v, vector<vector<string>>& q){\\n        unordered_map<string,vector<pair<string,double>>>mp;\\n        for(int i=0;i<e.size();i++){\\n            mp[e[i][0]].push_back({e[i][1],v[i]});\\n            mp[e[i][1]].push_back({e[i][0],1.0/v[i]});\\n        }\\n        vector<double>an;\\n        for(int i=0;i<q.size();i++){\\n            string src=q[i][0];\\n            string des=q[i][1];\\n            map<string,int>m;\\n            double ans=-1.0;\\n            double temp=1.0;\\n            if(mp.count(src))\\n            dfs(src,des,mp,m,ans,temp);\\n            an.push_back(ans);\\n            \\n        }\\n        return an;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/ac6542b6-17a8-4368-bccc-823daa945fa5_1684569288.717304.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(string src,string des,unordered_map<string,vector<pair<string,double>>>&mp,map<string,int>m,double &ans,double temp){\\n         m[src]=1;\\n        if(src==des){\\n            ans=temp;\\n            return;\\n        }\\n        for(auto k : mp[src]){\\n            if(m[k.first]==0){\\n              dfs(k.first,des,mp,m,ans,temp*k.second);\\n            }\\n        }\\n        return;\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& e, vector<double>& v, vector<vector<string>>& q){\\n        unordered_map<string,vector<pair<string,double>>>mp;\\n        for(int i=0;i<e.size();i++){\\n            mp[e[i][0]].push_back({e[i][1],v[i]});\\n            mp[e[i][1]].push_back({e[i][0],1.0/v[i]});\\n        }\\n        vector<double>an;\\n        for(int i=0;i<q.size();i++){\\n            string src=q[i][0];\\n            string des=q[i][1];\\n            map<string,int>m;\\n            double ans=-1.0;\\n            double temp=1.0;\\n            if(mp.count(src))\\n            dfs(src,des,mp,m,ans,temp);\\n            an.push_back(ans);\\n            \\n        }\\n        return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994865,
                "title": "python3-simple-bfs-solution",
                "content": "# **This is a GRAPH problem.**\\nThis question is similar to a real world problem called Currency Conversion.\\nIn this we need to derive the value of each query from the initial values and mapping we have.\\n\\nHere we also need to use some basic maths logic.\\nIf a/b = x; then b/a = 1/x\\nAlso if we have a/b and b/c, then to find a/c = a/b * b/c\\nSo we have to use UNDIRECTED GRAPH.\\nSo we form a graph, where graph[u][v] = value i.e u/v = value\\nAlso simultaneously we will fill graph[v][u] = 1 / value\\n\\nSo run a loop over the query,\\nCheck if the variables in the query are present in the graph, \\nif not then add -1.0000 or float(-1) in result array.\\nelse:\\nFor query = [a, b] we run a BFS with source = a and target = b, and we start the BFS with value = 1\\n\\n\\nIn BFS, we have a queue and a visited set to avoid repetitive computation.\\nThe queue will have values in this format \\nqueue = [[node, value]]\\nwhile queue:\\n\\tif node == target: return value\\n\\tif node is visited: continue\\n\\tadd node in visited set\\n\\tfor neighbour in graph[node]:\\n\\t\\tif neighbour is not visited:\\n\\t\\t\\tnew_value = current_value * graph[node][neighbour] (a/b * b/c * ....)\\n\\t\\t\\tqueue.append([neighbour, new_value])\\n\\nIf the loops completes, that means we cannot find the query result with current mapping, we return float(-1)\\n\\nIn the solution, I could have used **defaultdict** instead of normal dictionary, but due to some reason it was causing a problem.\\nSolution:\\n```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        \\n        def bfs(source, target, value):\\n            queue = [[source, value]]\\n            visited = set()\\n            while queue:\\n                \\n                node, val = queue.pop(0)\\n                if node == target:\\n                    return val\\n                if node in visited:\\n                    continue\\n                visited.add(node)\\n                \\n                for baju_wala in graph[node]:\\n                    if baju_wala not in visited:\\n                        new_val = val * graph[node][baju_wala]\\n                        queue.append([baju_wala, new_val])\\n            \\n            return float(-1)\\n                \\n        \\n        graph = {}\\n        for i in range(len(values)):\\n            u, v = equations[i]\\n            value = values[i]\\n            rev_value = 1 / value\\n            if u in graph:\\n                graph[u][v] = value\\n            else:\\n                graph[u] = {v: value}\\n            if v in graph:\\n                graph[v][u] = rev_value\\n            else:\\n                graph[v] = {u: rev_value}\\n        \\n        \\n        result = []\\n        for a, b in queries:\\n            if a not in graph or b not in graph:\\n                result.append(float(-1))\\n            else:\\n                res = bfs(a, b, 1)\\n                result.append(res)\\n                \\n        \\n        return result\\n```\\n\\n***I hope my solution helped you with this problem.***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        \\n        def bfs(source, target, value):\\n            queue = [[source, value]]\\n            visited = set()\\n            while queue:\\n                \\n                node, val = queue.pop(0)\\n                if node == target:\\n                    return val\\n                if node in visited:\\n                    continue\\n                visited.add(node)\\n                \\n                for baju_wala in graph[node]:\\n                    if baju_wala not in visited:\\n                        new_val = val * graph[node][baju_wala]\\n                        queue.append([baju_wala, new_val])\\n            \\n            return float(-1)\\n                \\n        \\n        graph = {}\\n        for i in range(len(values)):\\n            u, v = equations[i]\\n            value = values[i]\\n            rev_value = 1 / value\\n            if u in graph:\\n                graph[u][v] = value\\n            else:\\n                graph[u] = {v: value}\\n            if v in graph:\\n                graph[v][u] = rev_value\\n            else:\\n                graph[v] = {u: rev_value}\\n        \\n        \\n        result = []\\n        for a, b in queries:\\n            if a not in graph or b not in graph:\\n                result.append(float(-1))\\n            else:\\n                res = bfs(a, b, 1)\\n                result.append(res)\\n                \\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867419,
                "title": "python-both-union-find-and-bfs",
                "content": "BFS approach `O(NM)`, where N is the number of equations (edges in a graph) and M is the number of queries:\\n```\\ndef calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n\\tmaps = collections.defaultdict(dict)\\n\\n\\tfor (left, right), value in zip(equations, values):\\n\\t\\tmaps[left][right] = value\\n\\t\\tmaps[right][left] = 1/value\\n\\n\\tresults = []\\n\\tfor left, right in queries:\\n\\t\\tvisited = set()\\n\\t\\tqueue = collections.deque([(left, 1)])  # node and the cost to get here\\n\\t\\tres = -1\\n\\t\\twhile queue:\\n\\t\\t\\tnode, cost = queue.popleft()\\n\\t\\t\\tvisited.add(node)\\n\\t\\t\\tif right in maps[node]:\\n\\t\\t\\t\\tres = cost * maps[node][right]\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tqueue.extend([(neighbor, cost * n_cost) for neighbor, n_cost in maps[node].items() if neighbor not in visited])\\n\\t\\tresults.append(res)\\n\\n\\treturn results\\n```\\n\\nUnion-Find `O((N+M)log\\u2217N)`:\\n```\\ndef calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n\\tparents = {}\\n\\tranks = {}\\n\\tcoefficients = {}\\n\\n\\tdef union(a, b, c):\\n\\t\\tra, ca = findroot(a)\\n\\t\\trb, cb = findroot(b)\\n\\t\\tra_to_rb = c * cb / ca\\n\\t\\tif ra == rb: return\\n\\t\\trbig, rsmall, coef = (ra, rb, 1/ra_to_rb) if ranks[ra] >= ranks[rb] else (rb, ra, ra_to_rb)\\n\\t\\tparents[rsmall] = rbig\\n\\t\\tranks[rbig] += ranks[rbig] == ranks[rsmall]\\n\\t\\tcoefficients[rsmall] = coef\\n\\n\\tdef findroot(a):\\n\\t\\tif parents[a] != a:\\n\\t\\t\\tpar, coef = findroot(parents[a])\\n\\t\\t\\tparents[a] = par \\n\\t\\t\\tcoefficients[a] *= coef\\n\\t\\treturn parents[a], coefficients[a]\\n\\n\\tfor (a, b), v in zip(equations, values):\\n\\t\\tfor el in [a, b]:\\n\\t\\t\\tif el not in parents:\\n\\t\\t\\t\\tparents[el] = el\\n\\t\\t\\t\\tranks[el] = 0\\n\\t\\t\\t\\tcoefficients[el] = 1\\n\\t\\tunion(a, b, v)\\n\\n\\tres = []\\n\\tfor a, b in queries:\\n\\t\\tif a not in parents or b not in parents:\\n\\t\\t\\tres.append(-1)\\n\\t\\t\\tcontinue\\n\\t\\tra, ca = findroot(a)\\n\\t\\trb, cb = findroot(b)\\n\\t\\tres.append(-1 if ra != rb else ca / cb)\\n\\n\\treturn res\\n```\\n\\nBFS, only with inner function defintion:\\n```\\ndef calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n\\trels = defaultdict(dict)\\n\\tfor (a, b), k in zip(equations, values):\\n\\t\\trels[a][b] = k\\n\\t\\trels[b][a] = 1/k\\n\\n\\tdef get_relation(a, b):\\n\\t\\tqueue = deque([(a, 1)])\\n\\t\\tvisited = set([a])\\n\\t\\twhile queue:\\n\\t\\t\\tnxt, div = queue.popleft()\\n\\t\\t\\tif b in rels[nxt]: return div * rels[nxt][b]\\n\\t\\t\\tfor k, v in rels[nxt].items():\\n\\t\\t\\t\\tif k in visited: continue\\n\\t\\t\\t\\tqueue.append((k, div * rels[nxt][k]))\\n\\t\\t\\t\\tvisited.add(k)\\n\\t\\treturn -1\\n\\n\\treturn [get_relation(a, b) for a, b in queries]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\ndef calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n\\tmaps = collections.defaultdict(dict)\\n\\n\\tfor (left, right), value in zip(equations, values):\\n\\t\\tmaps[left][right] = value\\n\\t\\tmaps[right][left] = 1/value\\n\\n\\tresults = []\\n\\tfor left, right in queries:\\n\\t\\tvisited = set()\\n\\t\\tqueue = collections.deque([(left, 1)])  # node and the cost to get here\\n\\t\\tres = -1\\n\\t\\twhile queue:\\n\\t\\t\\tnode, cost = queue.popleft()\\n\\t\\t\\tvisited.add(node)\\n\\t\\t\\tif right in maps[node]:\\n\\t\\t\\t\\tres = cost * maps[node][right]\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tqueue.extend([(neighbor, cost * n_cost) for neighbor, n_cost in maps[node].items() if neighbor not in visited])\\n\\t\\tresults.append(res)\\n\\n\\treturn results\\n```\n```\\ndef calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n\\tparents = {}\\n\\tranks = {}\\n\\tcoefficients = {}\\n\\n\\tdef union(a, b, c):\\n\\t\\tra, ca = findroot(a)\\n\\t\\trb, cb = findroot(b)\\n\\t\\tra_to_rb = c * cb / ca\\n\\t\\tif ra == rb: return\\n\\t\\trbig, rsmall, coef = (ra, rb, 1/ra_to_rb) if ranks[ra] >= ranks[rb] else (rb, ra, ra_to_rb)\\n\\t\\tparents[rsmall] = rbig\\n\\t\\tranks[rbig] += ranks[rbig] == ranks[rsmall]\\n\\t\\tcoefficients[rsmall] = coef\\n\\n\\tdef findroot(a):\\n\\t\\tif parents[a] != a:\\n\\t\\t\\tpar, coef = findroot(parents[a])\\n\\t\\t\\tparents[a] = par \\n\\t\\t\\tcoefficients[a] *= coef\\n\\t\\treturn parents[a], coefficients[a]\\n\\n\\tfor (a, b), v in zip(equations, values):\\n\\t\\tfor el in [a, b]:\\n\\t\\t\\tif el not in parents:\\n\\t\\t\\t\\tparents[el] = el\\n\\t\\t\\t\\tranks[el] = 0\\n\\t\\t\\t\\tcoefficients[el] = 1\\n\\t\\tunion(a, b, v)\\n\\n\\tres = []\\n\\tfor a, b in queries:\\n\\t\\tif a not in parents or b not in parents:\\n\\t\\t\\tres.append(-1)\\n\\t\\t\\tcontinue\\n\\t\\tra, ca = findroot(a)\\n\\t\\trb, cb = findroot(b)\\n\\t\\tres.append(-1 if ra != rb else ca / cb)\\n\\n\\treturn res\\n```\n```\\ndef calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n\\trels = defaultdict(dict)\\n\\tfor (a, b), k in zip(equations, values):\\n\\t\\trels[a][b] = k\\n\\t\\trels[b][a] = 1/k\\n\\n\\tdef get_relation(a, b):\\n\\t\\tqueue = deque([(a, 1)])\\n\\t\\tvisited = set([a])\\n\\t\\twhile queue:\\n\\t\\t\\tnxt, div = queue.popleft()\\n\\t\\t\\tif b in rels[nxt]: return div * rels[nxt][b]\\n\\t\\t\\tfor k, v in rels[nxt].items():\\n\\t\\t\\t\\tif k in visited: continue\\n\\t\\t\\t\\tqueue.append((k, div * rels[nxt][k]))\\n\\t\\t\\t\\tvisited.add(k)\\n\\t\\treturn -1\\n\\n\\treturn [get_relation(a, b) for a, b in queries]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 827506,
                "title": "python3-dfs-union-find",
                "content": "approach 1 - DFS \\n(16ms, 99.93%)\\n```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        graph = {}\\n        for (u, v), w in zip(equations, values): \\n            graph.setdefault(u, []).append((v, 1/w))\\n            graph.setdefault(v, []).append((u, w))\\n\\n        def dfs(n, g, val=1):\\n            \"\"\"Depth-first traverse the graph.\"\"\"\\n            if n in vals: return \\n            vals[n] = val, g\\n            for nn, w in graph.get(n, []): dfs(nn, g, w*val)\\n    \\n        vals = dict()\\n        for i, n in enumerate(graph): dfs(n, i)\\n        \\n        ans = []\\n        for u, v in queries: \\n            if u in vals and v in vals and vals[u][1] == vals[v][1]: ans.append(vals[u][0]/vals[v][0])\\n            else: ans.append(-1)\\n        return ans \\n```\\n\\napproach 2 - Union-Find with ranking (20ms, 99.29%)\\n```\\nclass UnionFind:\\n    def __init__(self, alphabet):\\n        self.parent = {c: c for c in alphabet}\\n        self.value = {c: 1 for c in alphabet}\\n        self.rank = {c: 1 for c in alphabet}\\n    \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u], val = self.find(self.parent[u])\\n            self.value[u] *= val\\n        return self.parent[u], self.value[u]\\n    \\n    def union(self, u, v, w):\\n        pu, vu = self.find(u)\\n        pv, vv = self.find(v)\\n        if pu == pv: return\\n        if self.rank[pu] > self.rank[pv]: self.union(v, u, 1/w)\\n        else: \\n            self.parent[pu] = self.parent[pv]\\n            self.value[pu] = w * vv / vu\\n            self.rank[pv] += self.rank[pu]\\n        \\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        alphabet = set(sum(equations, []))\\n        uf = UnionFind(alphabet)\\n        \\n        for (u, v), w in zip(equations, values): uf.union(u, v, w)\\n            \\n        ans = []\\n        for u, v in queries:\\n            if u in alphabet and v in alphabet: \\n                pu, vu = uf.find(u)\\n                pv, vv = uf.find(v)\\n                if pu == pv: ans.append(vu / vv)\\n                else: ans.append(-1)\\n            else: ans.append(-1)\\n        return ans\\n```\\n\\nEdited on 9/27/2020\\nAdding a more \"direct\" DFS\\nI observe something intersting about Python. If I put `seen` as a function argument, and give it a default value `seen=set()`, i.e. `def dfs(u, v, w=1, seen=set())`. A call `dfs(u, v)` wouldn\\'t set `seen` to its default value `set()` instead it will keep its latest value. Anyone knows what\\'s going on here? \\n```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        # directed graph as adjacency list \\n        digraph = {} \\n        for (u, v), w in zip(equations, values): \\n            digraph.setdefault(u, []).append((v, w))\\n            digraph.setdefault(v, []).append((u, 1/w))\\n            \\n        # query \\n        def dfs(u, v, w=1): \\n            \"\"\"Return division via dfs.\"\"\"\\n            if u not in digraph: return -1 \\n            if u == v: return w\\n            seen.add(u)\\n            for uu, ww in digraph.get(u, []): \\n                if uu not in seen and (ans := dfs(uu, v, w*ww)) != -1: return ans \\n            return -1\\n        \\n        ans = []\\n        for u, v in queries: \\n            seen = set()\\n            ans.append(dfs(u, v))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        graph = {}\\n        for (u, v), w in zip(equations, values): \\n            graph.setdefault(u, []).append((v, 1/w))\\n            graph.setdefault(v, []).append((u, w))\\n\\n        def dfs(n, g, val=1):\\n            \"\"\"Depth-first traverse the graph.\"\"\"\\n            if n in vals: return \\n            vals[n] = val, g\\n            for nn, w in graph.get(n, []): dfs(nn, g, w*val)\\n    \\n        vals = dict()\\n        for i, n in enumerate(graph): dfs(n, i)\\n        \\n        ans = []\\n        for u, v in queries: \\n            if u in vals and v in vals and vals[u][1] == vals[v][1]: ans.append(vals[u][0]/vals[v][0])\\n            else: ans.append(-1)\\n        return ans \\n```\n```\\nclass UnionFind:\\n    def __init__(self, alphabet):\\n        self.parent = {c: c for c in alphabet}\\n        self.value = {c: 1 for c in alphabet}\\n        self.rank = {c: 1 for c in alphabet}\\n    \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u], val = self.find(self.parent[u])\\n            self.value[u] *= val\\n        return self.parent[u], self.value[u]\\n    \\n    def union(self, u, v, w):\\n        pu, vu = self.find(u)\\n        pv, vv = self.find(v)\\n        if pu == pv: return\\n        if self.rank[pu] > self.rank[pv]: self.union(v, u, 1/w)\\n        else: \\n            self.parent[pu] = self.parent[pv]\\n            self.value[pu] = w * vv / vu\\n            self.rank[pv] += self.rank[pu]\\n        \\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        alphabet = set(sum(equations, []))\\n        uf = UnionFind(alphabet)\\n        \\n        for (u, v), w in zip(equations, values): uf.union(u, v, w)\\n            \\n        ans = []\\n        for u, v in queries:\\n            if u in alphabet and v in alphabet: \\n                pu, vu = uf.find(u)\\n                pv, vv = uf.find(v)\\n                if pu == pv: ans.append(vu / vv)\\n                else: ans.append(-1)\\n            else: ans.append(-1)\\n        return ans\\n```\n```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        # directed graph as adjacency list \\n        digraph = {} \\n        for (u, v), w in zip(equations, values): \\n            digraph.setdefault(u, []).append((v, w))\\n            digraph.setdefault(v, []).append((u, 1/w))\\n            \\n        # query \\n        def dfs(u, v, w=1): \\n            \"\"\"Return division via dfs.\"\"\"\\n            if u not in digraph: return -1 \\n            if u == v: return w\\n            seen.add(u)\\n            for uu, ww in digraph.get(u, []): \\n                if uu not in seen and (ans := dfs(uu, v, w*ww)) != -1: return ans \\n            return -1\\n        \\n        ans = []\\n        for u, v in queries: \\n            seen = set()\\n            ans.append(dfs(u, v))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543183,
                "title": "explained-with-images-easy-to-understand-dfs",
                "content": "![image](https://assets.leetcode.com/users/images/0296ec7e-a1f2-4079-81eb-7b3954d278db_1684543548.4413278.jpeg)\\n![image](https://assets.leetcode.com/users/images/483e926f-f8e9-4a8b-a239-2cdc40cb2c2b_1684543457.0519738.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double dfs(unordered_map<string, vector<pair<string, double>>>&adj, unordered_map<string, int>&visited, string& target, string curr)\\n    {\\n        if (!adj.count(curr)) return INT_MAX;\\n        if (curr == target) return 1;\\n        \\n        for (pair<string, double>& adjNode : adj[curr])\\n        {\\n            if (visited[adjNode.first]) continue;\\n            \\n            visited[adjNode.first] = 1;\\n            //========================================================\\n            double currCost = adjNode.second;\\n            double nextCost = dfs(adj, visited, target, adjNode.first);\\n            //==========================================================\\n            visited[adjNode.first] = 0;\\n            \\n            //if path found, return the cost\\n            if (nextCost != INT_MAX) \\n                return (nextCost * currCost); //there will be only \"one\" path if it exists\\n        }\\n        return INT_MAX;\\n    }\\n    vector<double>calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) \\n    {\\n        unordered_map<string, vector<pair<string, double>>>adj;\\n        for (int i = 0; i < equations.size(); i++)\\n        {\\n            adj[equations[i][0]].push_back({equations[i][1], values[i]});\\n            adj[equations[i][1]].push_back({equations[i][0], (1.00 / values[i])});\\n        }\\n        //===================================================================\\n        vector<double>ans;\\n        unordered_map<string, int>visited;\\n        for (vector<string>& query : queries)\\n        {\\n            double cost = cost = dfs(adj, visited, query[1], query[0]);\\n            ans.push_back(cost == INT_MAX? -1 : cost);\\n        }\\n        //=========================================================================\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dfs(unordered_map<string, vector<pair<string, double>>>&adj, unordered_map<string, int>&visited, string& target, string curr)\\n    {\\n        if (!adj.count(curr)) return INT_MAX;\\n        if (curr == target) return 1;\\n        \\n        for (pair<string, double>& adjNode : adj[curr])\\n        {\\n            if (visited[adjNode.first]) continue;\\n            \\n            visited[adjNode.first] = 1;\\n            //========================================================\\n            double currCost = adjNode.second;\\n            double nextCost = dfs(adj, visited, target, adjNode.first);\\n            //==========================================================\\n            visited[adjNode.first] = 0;\\n            \\n            //if path found, return the cost\\n            if (nextCost != INT_MAX) \\n                return (nextCost * currCost); //there will be only \"one\" path if it exists\\n        }\\n        return INT_MAX;\\n    }\\n    vector<double>calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) \\n    {\\n        unordered_map<string, vector<pair<string, double>>>adj;\\n        for (int i = 0; i < equations.size(); i++)\\n        {\\n            adj[equations[i][0]].push_back({equations[i][1], values[i]});\\n            adj[equations[i][1]].push_back({equations[i][0], (1.00 / values[i])});\\n        }\\n        //===================================================================\\n        vector<double>ans;\\n        unordered_map<string, int>visited;\\n        for (vector<string>& query : queries)\\n        {\\n            double cost = cost = dfs(adj, visited, query[1], query[0]);\\n            ans.push_back(cost == INT_MAX? -1 : cost);\\n        }\\n        //=========================================================================\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258506,
                "title": "399-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe solution uses a graph data structure to represent the equations, with each variable as a node and the value of the edge between two nodes representing the ratio of their values. The graph is built by iterating through the given equations and values and adding the appropriate edges to the graph using a defaultdict.\\n\\nThe solution then uses a depth-first search (DFS) algorithm to find the value of the query for each given pair of variables. The DFS function takes as input the starting node, ending node, and a set of visited nodes, and recursively traverses the graph to find the path value between the starting and ending nodes. The visited set is used to avoid visiting nodes that have already been visited in the current path, which prevents infinite loops in cyclic graphs. If the path value is found, the DFS function returns the product of the current edge value and the path value. If the path value is not found, the DFS function returns -1.0 to indicate that the query cannot be evaluated.\\n\\nFinally, the solution iterates through the given queries, performs the DFS algorithm for each query, and appends the resulting value to the output list.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(N*M), where N is the number of equations and M is the length of the longest path in the graph, since the DFS algorithm is called once for each query and may visit each node in the graph at most once.\\n\\n- Space complexity:\\nThe space complexity is O(N), since the graph is represented using a defaultdict that may have at most N keys.\\n\\n# Code\\n```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        # Build the graph\\n        graph = defaultdict(dict)\\n        for i in range(len(equations)):\\n            u, v = equations[i]\\n            graph[u][v] = values[i]\\n            graph[v][u] = 1 / values[i]\\n        \\n        # Helper function to perform DFS and find the path value\\n        def dfs(start, end, visited):\\n            # If we have already visited this node or it doesn\\'t exist in the graph, return -1.0\\n            if start in visited or start not in graph:\\n                return -1.0\\n            # If we have reached the end node, return the path value\\n            if start == end:\\n                return 1.0\\n            # Mark the current node as visited\\n            visited.add(start)\\n            # Traverse the neighbors and find the path value recursively\\n            for neighbor, value in graph[start].items():\\n                path_value = dfs(neighbor, end, visited)\\n                # If we have found a valid path, return the product of the current value and path value\\n                if path_value != -1.0:\\n                    return value * path_value\\n            # If we haven\\'t found a valid path, return -1.0\\n            return -1.0\\n        \\n        # Calculate the answer for each query\\n        result = []\\n        for query in queries:\\n            start, end = query\\n            # Perform DFS to find the path value\\n            result.append(dfs(start, end, set()))\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        # Build the graph\\n        graph = defaultdict(dict)\\n        for i in range(len(equations)):\\n            u, v = equations[i]\\n            graph[u][v] = values[i]\\n            graph[v][u] = 1 / values[i]\\n        \\n        # Helper function to perform DFS and find the path value\\n        def dfs(start, end, visited):\\n            # If we have already visited this node or it doesn\\'t exist in the graph, return -1.0\\n            if start in visited or start not in graph:\\n                return -1.0\\n            # If we have reached the end node, return the path value\\n            if start == end:\\n                return 1.0\\n            # Mark the current node as visited\\n            visited.add(start)\\n            # Traverse the neighbors and find the path value recursively\\n            for neighbor, value in graph[start].items():\\n                path_value = dfs(neighbor, end, visited)\\n                # If we have found a valid path, return the product of the current value and path value\\n                if path_value != -1.0:\\n                    return value * path_value\\n            # If we haven\\'t found a valid path, return -1.0\\n            return -1.0\\n        \\n        # Calculate the answer for each query\\n        result = []\\n        for query in queries:\\n            start, end = query\\n            # Perform DFS to find the path value\\n            result.append(dfs(start, end, set()))\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88311,
                "title": "java-graph-based-solution-no-dfs-is-needed-3ms",
                "content": "I have calculated all the possible distances between graph nodes during the construction of the graph. DFS need not be used as all the possible distances between nodes are already calculated in the adjacency matrix exhaustively.\\n\\n```\\npublic class Solution {\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        \\n        \\n        HashMap<String, Integer> nodes = new HashMap<String, Integer>();\\n        int nodeCount = 0;\\n        for(String[] eq : equations) {\\n            \\n            String src = eq[0];\\n            String dest = eq[1];\\n            \\n            if(!nodes.containsKey(src)) {\\n                nodes.put(src, nodeCount++);\\n            }\\n            if(!nodes.containsKey(dest)) {\\n                nodes.put(dest, nodeCount++);\\n            }\\n        }\\n        \\n        double[][] map = new double[nodeCount][nodeCount];\\n        int len = equations.length;\\n        if(values.length != len) return null;\\n        \\n        for(int i = 0; i < len; i++) {\\n            String[] eq = equations[i];\\n            double val = values[i];\\n            int src = nodes.get(eq[0]);\\n            int dest = nodes.get(eq[1]);\\n            \\n            map[src][dest] = val;\\n            map[src][src] = 1.0;\\n            map[dest][dest] = 1.0;\\n            map[dest][src] = 1.0 / val;\\n        }\\n        \\n        for(int i = 0 ; i < nodeCount; i++) {\\n            for(int j = 0 ; j < nodeCount; j++) {\\n                for(int k = 0 ; k < nodeCount; k++) {\\n                    if(map[i][j] == 0 || map[j][k] == 0) continue;\\n                    map[i][k] = map[i][j] * map[j][k];     \\n                }\\n            }\\n        }\\n        \\n        double res[] = new double[queries.length];\\n        len = queries.length;\\n        for(int i = 0; i < len; i++) {\\n            String[] eq = queries[i];\\n            Integer src = nodes.get(eq[0]);\\n            Integer dest = nodes.get(eq[1]);\\n            if(src == null || dest == null ){\\n                res[i] = -1.0;\\n                continue;\\n            }\\n            double val = map[src][dest];\\n            if(val == 0) res[i] = -1.0;\\n            else res[i] = val;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        \\n        \\n        HashMap<String, Integer> nodes = new HashMap<String, Integer>();\\n        int nodeCount = 0;\\n        for(String[] eq : equations) {\\n            \\n            String src = eq[0];\\n            String dest = eq[1];\\n            \\n            if(!nodes.containsKey(src)) {\\n                nodes.put(src, nodeCount++);\\n            }\\n            if(!nodes.containsKey(dest)) {\\n                nodes.put(dest, nodeCount++);\\n            }\\n        }\\n        \\n        double[][] map = new double[nodeCount][nodeCount];\\n        int len = equations.length;\\n        if(values.length != len) return null;\\n        \\n        for(int i = 0; i < len; i++) {\\n            String[] eq = equations[i];\\n            double val = values[i];\\n            int src = nodes.get(eq[0]);\\n            int dest = nodes.get(eq[1]);\\n            \\n            map[src][dest] = val;\\n            map[src][src] = 1.0;\\n            map[dest][dest] = 1.0;\\n            map[dest][src] = 1.0 / val;\\n        }\\n        \\n        for(int i = 0 ; i < nodeCount; i++) {\\n            for(int j = 0 ; j < nodeCount; j++) {\\n                for(int k = 0 ; k < nodeCount; k++) {\\n                    if(map[i][j] == 0 || map[j][k] == 0) continue;\\n                    map[i][k] = map[i][j] * map[j][k];     \\n                }\\n            }\\n        }\\n        \\n        double res[] = new double[queries.length];\\n        len = queries.length;\\n        for(int i = 0; i < len; i++) {\\n            String[] eq = queries[i];\\n            Integer src = nodes.get(eq[0]);\\n            Integer dest = nodes.get(eq[1]);\\n            if(src == null || dest == null ){\\n                res[i] = -1.0;\\n                continue;\\n            }\\n            double val = map[src][dest];\\n            if(val == 0) res[i] = -1.0;\\n            else res[i] = val;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88346,
                "title": "java-solution-using-hashmap-and-dfs",
                "content": "(1) Build the map, the key is dividend, the value is also a map whose key is divisor and value is its parameter. For example, ```a / b = 2.0```, the map entry is ```<\"a\", <\"b\", 2.0>>```. To make searching and calculation easier, we also put ```b / a = 0.5``` into the map.\\n(2) for each query, use DFS to search divisors recursively\\n```\\npublic class Solution {\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n        // build the map\\n        Map<String, Map<String, Double>> map = new HashMap<>();\\n        for(int i = 0; i < equations.length; i++) {\\n            if(!map.containsKey(equations[i][0])) map.put(equations[i][0], new HashMap<>());\\n            map.get(equations[i][0]).put(equations[i][1], values[i]);\\n\\n            if(!map.containsKey(equations[i][1])) map.put(equations[i][1], new HashMap<>());\\n            map.get(equations[i][1]).put(equations[i][0], 1 / values[i]);\\n        }\\n        \\n        // search dividend and divisor using DFS\\n        double[] res = new double[query.length];\\n        for(int i = 0; i < query.length; i++) {\\n            double[] para = new double[]{1.0};\\n            if(calculate(map, query[i][0], query[i][1], para, new HashSet<>(), 1.0)) res[i] = para[0];\\n            else res[i] = -1.0;\\n        }\\n        return res;\\n    }\\n    \\n    // DFS\\n    private boolean calculate(Map<String, Map<String, Double>> map, String num1, String num2,\\n                              double[] para, Set<String> visited, double res) {\\n        if(!map.containsKey(num1) || !map.containsKey(num2) || visited.contains(num1)) return false;\\n        \\n        if(num1.equals(num2)) {\\n            para[0] = res;\\n            return true;\\n        }\\n        \\n        visited.add(num1);\\n        for(Map.Entry<String, Double> entry: map.get(num1).entrySet()) {\\n            if(calculate(map, entry.getKey(), num2, para, visited, res * entry.getValue())) return true;\\n        }\\n        visited.remove(num1);           // backtracking\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```a / b = 2.0```\n```<\"a\", <\"b\", 2.0>>```\n```b / a = 0.5```\n```\\npublic class Solution {\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] query) {\\n        // build the map\\n        Map<String, Map<String, Double>> map = new HashMap<>();\\n        for(int i = 0; i < equations.length; i++) {\\n            if(!map.containsKey(equations[i][0])) map.put(equations[i][0], new HashMap<>());\\n            map.get(equations[i][0]).put(equations[i][1], values[i]);\\n\\n            if(!map.containsKey(equations[i][1])) map.put(equations[i][1], new HashMap<>());\\n            map.get(equations[i][1]).put(equations[i][0], 1 / values[i]);\\n        }\\n        \\n        // search dividend and divisor using DFS\\n        double[] res = new double[query.length];\\n        for(int i = 0; i < query.length; i++) {\\n            double[] para = new double[]{1.0};\\n            if(calculate(map, query[i][0], query[i][1], para, new HashSet<>(), 1.0)) res[i] = para[0];\\n            else res[i] = -1.0;\\n        }\\n        return res;\\n    }\\n    \\n    // DFS\\n    private boolean calculate(Map<String, Map<String, Double>> map, String num1, String num2,\\n                              double[] para, Set<String> visited, double res) {\\n        if(!map.containsKey(num1) || !map.containsKey(num2) || visited.contains(num1)) return false;\\n        \\n        if(num1.equals(num2)) {\\n            para[0] = res;\\n            return true;\\n        }\\n        \\n        visited.add(num1);\\n        for(Map.Entry<String, Double> entry: map.get(num1).entrySet()) {\\n            if(calculate(map, entry.getKey(), num2, para, visited, res * entry.getValue())) return true;\\n        }\\n        visited.remove(num1);           // backtracking\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544833,
                "title": "covert-to-graph-then-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert the equations to the graph problem, than traversal the graph with the given queries.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd all equations as the edge to the graph.\\n\\nWe have from, to, cost, from every equation and value\\n\\nadd edge[from->to] = cost.\\nadd edge[to->from] = 1 / cost.\\n\\nthan traversal the graph with the given queries.\\n\\n# Complexity\\n- Time complexity: $$O(q * (V+E))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V+E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing PSD = pair<string, double>;\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double> ans;\\n        unordered_map<string, vector<PSD>> graph;\\n        unordered_set<string> nodes;\\n        unordered_set<string> visited;\\n\\n        for (int i = 0 ; i < equations.size() ; ++i ) {\\n            string from = equations[i][0];\\n            string to = equations[i][1];\\n            graph[from].push_back({to, values[i]});\\n            graph[to].push_back({from, 1 / values[i]});\\n            nodes.insert(from);\\n            nodes.insert(to);\\n        }\\n\\n        for (auto node : nodes) {\\n            graph[node].push_back({node, 1});\\n        }\\n\\n        function<void(string, string, double)> dfs = [&](string source, string target, double cur) {\\n            \\n            for (auto [to, cost] : graph[source]) {\\n                if (to == target) {\\n                    ans.back() = cur * cost;\\n                    return;\\n                }\\n                if (visited.count(to) == 0) {\\n                    visited.insert(to);\\n                    dfs(to, target, cur * cost);\\n                }\\n            }\\n        };\\n        \\n        for (auto querie : queries) {\\n            string source = querie[0];\\n            string target = querie[1];\\n            visited.clear();\\n            ans.push_back(-1);\\n            \\n            if (graph.count(source)) {\\n                if (source == target) {\\n                    ans.back() = 1;\\n                }else {\\n                    visited.insert(source);\\n                    dfs(source, target, 1);\\n                }\\n            }    \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nusing PSD = pair<string, double>;\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double> ans;\\n        unordered_map<string, vector<PSD>> graph;\\n        unordered_set<string> nodes;\\n        unordered_set<string> visited;\\n\\n        for (int i = 0 ; i < equations.size() ; ++i ) {\\n            string from = equations[i][0];\\n            string to = equations[i][1];\\n            graph[from].push_back({to, values[i]});\\n            graph[to].push_back({from, 1 / values[i]});\\n            nodes.insert(from);\\n            nodes.insert(to);\\n        }\\n\\n        for (auto node : nodes) {\\n            graph[node].push_back({node, 1});\\n        }\\n\\n        function<void(string, string, double)> dfs = [&](string source, string target, double cur) {\\n            \\n            for (auto [to, cost] : graph[source]) {\\n                if (to == target) {\\n                    ans.back() = cur * cost;\\n                    return;\\n                }\\n                if (visited.count(to) == 0) {\\n                    visited.insert(to);\\n                    dfs(to, target, cur * cost);\\n                }\\n            }\\n        };\\n        \\n        for (auto querie : queries) {\\n            string source = querie[0];\\n            string target = querie[1];\\n            visited.clear();\\n            ans.push_back(-1);\\n            \\n            if (graph.count(source)) {\\n                if (source == target) {\\n                    ans.back() = 1;\\n                }else {\\n                    visited.insert(source);\\n                    dfs(source, target, 1);\\n                }\\n            }    \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993694,
                "title": "base-intuition-multiple-approach-discussion-dfs-based-working-code",
                "content": "Before directly jumping to the code lets understand intution for this problem first. As per the problem statment we have given some division statements and there result and based on these given input we need to deduce output to certain queries.\\n\\nLet take one example first \\n\\nlets say we have following inputs\\n\\na/b = 2 , b/c=2 , e/c = 4, c/d=9, d/p=9\\nfind p/e?\\n\\nIf we consider this as a simple mathematical problem we can find out that\\np/e = p/d * d/c *c/e\\n\\nd will cancel out d and c will cancel out c and we will get p/e.\\n\\nif we create graph from given inputs then we will have following structure for mentioned example\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\td---------p\\n\\t\\t\\t\\t\\t\\t-\\n\\t\\t\\t\\t\\t\\t-\\n\\ta---b---------------c-----e\\n\\nwe need to find p/e what will the path for p/e for in above graph?\\n\\nit will be p---d---c---e. Do you see the pattern yet?\\neach edge is denoting one disvison. so p---d---c---e is denoting p/d*d/c*c*e.\\n\\nNot whole problem can be broken down into finding path. we can you dfs, dijsktra, all pair shortest path depending on level of optimisation you need to do.\\n\\nI have created simple dfs based solution. But it can be optimized for time by using dijsktra or all pair shortest path depening on number of queries you have. you can easy make the decison based on that.\\n\\n\\nPlease have a look the code below, this is simple dfs based implementation.\\n\\n```\\nclass Solution {\\n\\n    public double[] calcEquation(List<List<String>> equations, \\n                                 double[] values, \\n                                 List<List<String>> queries) {\\n        \\n        double output[] = new double[queries.size()];\\n        Map<String,Set<String>> graph = new HashMap<>();\\n        Map<String,Double> costGraph = new HashMap<>();\\n        \\n        \\n        for(int i=0;i<equations.size();i++) {\\n            \\n            List<String> eq = equations.get(i);\\n            costGraph.put(eq.get(0)+\"_\"+eq.get(1),values[i]);\\n            costGraph.put(eq.get(1)+\"_\"+eq.get(0),1/values[i]);\\n            String a = eq.get(0);\\n            String b = eq.get(1);\\n            Set<String> adjSet = graph.getOrDefault(a,new HashSet<>());\\n            adjSet.add(b);\\n            graph.put(a,adjSet);\\n            \\n            adjSet = graph.getOrDefault(b,new HashSet<>());\\n            adjSet.add(a);\\n            graph.put(b,adjSet);\\n            \\n        }\\n\\n        for(int i=0;i<queries.size();i++) {\\n            List<String> q = queries.get(i);\\n            if(graph.get(q.get(0))==null || graph.get(q.get(1))==null) {\\n                output[i] = -1d;\\n            }else if(costGraph.get(q.get(0)+\"_\"+q.get(1))!=null) {\\n                output[i]=costGraph.get(q.get(0)+\"_\"+q.get(1));\\n            }else if(q.get(0).equals(q.get(1))){\\n                output[i]=1d;            \\n            }else {\\n                Double output2 = getCost(q.get(0),q.get(1),graph,costGraph,new HashSet<>(),1d);\\n                output[i]=output2==null?-1:output2;\\n            }\\n            \\n        }\\n        return output;\\n    }\\n    \\n    Double getCost(String a,\\n                   String b,\\n                   Map<String,Set<String>> graph,\\n                   Map<String,Double> costGraph,\\n                   Set<String> set,\\n                   double output) {        \\n        set.add(a);\\n        \\n        Set<String> adjSet = graph.getOrDefault(a,new HashSet<>());\\n        \\n        for(String next:adjSet) {\\n            if(!set.contains(next)) {\\n                output=output*costGraph.get(a+\"_\"+next);\\n                if(next.equals(b)) {\\n                    return output;\\n                }\\n                \\n                Double output2 = getCost(next,b,graph,costGraph,set,output);\\n                if(output2!=null)\\n                    return output2;\\n                else {\\n                    output=output/costGraph.get(a+\"_\"+next);\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n\\nCheers!!!! Hope it helps. Please upvote...",
                "solutionTags": [
                    "Depth-First Search",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n\\n    public double[] calcEquation(List<List<String>> equations, \\n                                 double[] values, \\n                                 List<List<String>> queries) {\\n        \\n        double output[] = new double[queries.size()];\\n        Map<String,Set<String>> graph = new HashMap<>();\\n        Map<String,Double> costGraph = new HashMap<>();\\n        \\n        \\n        for(int i=0;i<equations.size();i++) {\\n            \\n            List<String> eq = equations.get(i);\\n            costGraph.put(eq.get(0)+\"_\"+eq.get(1),values[i]);\\n            costGraph.put(eq.get(1)+\"_\"+eq.get(0),1/values[i]);\\n            String a = eq.get(0);\\n            String b = eq.get(1);\\n            Set<String> adjSet = graph.getOrDefault(a,new HashSet<>());\\n            adjSet.add(b);\\n            graph.put(a,adjSet);\\n            \\n            adjSet = graph.getOrDefault(b,new HashSet<>());\\n            adjSet.add(a);\\n            graph.put(b,adjSet);\\n            \\n        }\\n\\n        for(int i=0;i<queries.size();i++) {\\n            List<String> q = queries.get(i);\\n            if(graph.get(q.get(0))==null || graph.get(q.get(1))==null) {\\n                output[i] = -1d;\\n            }else if(costGraph.get(q.get(0)+\"_\"+q.get(1))!=null) {\\n                output[i]=costGraph.get(q.get(0)+\"_\"+q.get(1));\\n            }else if(q.get(0).equals(q.get(1))){\\n                output[i]=1d;            \\n            }else {\\n                Double output2 = getCost(q.get(0),q.get(1),graph,costGraph,new HashSet<>(),1d);\\n                output[i]=output2==null?-1:output2;\\n            }\\n            \\n        }\\n        return output;\\n    }\\n    \\n    Double getCost(String a,\\n                   String b,\\n                   Map<String,Set<String>> graph,\\n                   Map<String,Double> costGraph,\\n                   Set<String> set,\\n                   double output) {        \\n        set.add(a);\\n        \\n        Set<String> adjSet = graph.getOrDefault(a,new HashSet<>());\\n        \\n        for(String next:adjSet) {\\n            if(!set.contains(next)) {\\n                output=output*costGraph.get(a+\"_\"+next);\\n                if(next.equals(b)) {\\n                    return output;\\n                }\\n                \\n                Double output2 = getCost(next,b,graph,costGraph,set,output);\\n                if(output2!=null)\\n                    return output2;\\n                else {\\n                    output=output/costGraph.get(a+\"_\"+next);\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142350,
                "title": "c-simple-union-find-approach-creates-union-find-class",
                "content": "I looked at other union find approaches in c++ and it is really hard to understand those approaches. I am not sure if you guys can understand this, but if you can, any optimization would be apprectiated!\\nLets learn!!\\n```\\nclass Solution {\\npublic:    \\n    class unionFind{\\n        public:\\n        map<string, pair<string, double>> parent; \\n        pair<string, double> find(string source){\\n            if (parent.count(source)==0){\\n                parent[source]={source, 1};\\n            }\\n            if (source==parent[source].first)return parent[source];\\n            pair<string, double> par= find (parent[source].first);\\n            parent[source].first=par.first;\\n            parent[source].second*=par.second;\\n            return {par.first, parent[source].second};\\n        }\\n        \\n        void Union(string first, string second, double value){\\n            pair<string,double> parentf=find(first);\\n            pair<string, double> parents=find(second);\\n            if (parentf.first==parents.first)return ;\\n            parent[parents.first].first=parentf.first;\\n            parent[parents.first].second=parentf.second*value/parents.second;\\n        }\\n    };\\n    \\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        unionFind uf;\\n        for (int i=0; i<equations.size(); i++){\\n            string first=equations[i][0];\\n            string second=equations[i][1];\\n            uf.Union(first, second, values[i]);\\n        }\\n        vector<double>answer;\\n        for (auto query: queries){\\n            string first=query[0];\\n            string second=query[1];\\n            if (!uf.parent.count(first) || !uf.parent.count(second)){answer.push_back(-1); continue;}\\n            pair<string, double> one=uf.find(first);\\n            pair<string, double> two=uf.find(second);\\n            if (one.first!=two.first)\\n                {answer.push_back(-1); continue;}\\n            answer.push_back(two.second*1.0/one.second);\\n            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    class unionFind{\\n        public:\\n        map<string, pair<string, double>> parent; \\n        pair<string, double> find(string source){\\n            if (parent.count(source)==0){\\n                parent[source]={source, 1};\\n            }\\n            if (source==parent[source].first)return parent[source];\\n            pair<string, double> par= find (parent[source].first);\\n            parent[source].first=par.first;\\n            parent[source].second*=par.second;\\n            return {par.first, parent[source].second};\\n        }\\n        \\n        void Union(string first, string second, double value){\\n            pair<string,double> parentf=find(first);\\n            pair<string, double> parents=find(second);\\n            if (parentf.first==parents.first)return ;\\n            parent[parents.first].first=parentf.first;\\n            parent[parents.first].second=parentf.second*value/parents.second;\\n        }\\n    };\\n    \\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        unionFind uf;\\n        for (int i=0; i<equations.size(); i++){\\n            string first=equations[i][0];\\n            string second=equations[i][1];\\n            uf.Union(first, second, values[i]);\\n        }\\n        vector<double>answer;\\n        for (auto query: queries){\\n            string first=query[0];\\n            string second=query[1];\\n            if (!uf.parent.count(first) || !uf.parent.count(second)){answer.push_back(-1); continue;}\\n            pair<string, double> one=uf.find(first);\\n            pair<string, double> two=uf.find(second);\\n            if (one.first!=two.first)\\n                {answer.push_back(-1); continue;}\\n            answer.push_back(two.second*1.0/one.second);\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757299,
                "title": "union-find-python",
                "content": "For a connected block, if we know nodeX / root = x, nodeY / root = y, then we know nodeX / nodeY = x / y. Then all we need to do is to construct an UnionFind whose value is a tuple<RootNodeTag, RatioToRoot>.\\n\\nFor find, if a / b = A and b / root = B, then we can do a -> root = A * B\\n\\nFor Union, a general case is if the existing relationship is a / b = A, c / d = B, and we want to union 2 non-root note - a and c with a / c = C. We know a\\'s root is b, c\\'s root is d, then we want to set b\\'s root to d. Then we know b / d = B * C / A. A common questions is what if we want to union a root node and a non-root node, for example, b and c. The relationship above still stands because we always have b / b = 1\\n\\nCode below\\n\\n```\\nclass UnionFind:\\n    def __init__(self):\\n        self.content = dict()\\n        \\n    \\n    def find(self, x):\\n        origin = self.content[x]\\n        if origin[0] != x:\\n            node = self.find(origin[0])\\n            self.content[x] = (node[0], node[1] * origin[1])\\n        return self.content[x]\\n    \\n    def union(self, x, y, value):\\n        if x not in self.content:\\n            self.content[x] = (x, 1)\\n        if y not in self.content:\\n            self.content[y] = (y, 1)\\n        bb_x = self.find(x)\\n        bb_y = self.find(y)\\n        self.content[bb_x[0]] = (bb_y[0], bb_y[1] * value / bb_x[1])\\n    \\n    def div(self, x, y):\\n        if x not in self.content or y not in self.content:\\n            return -1\\n        \\n        bb_x = self.find(x)\\n        bb_y = self.find(y)\\n        \\n        if bb_x[0] != bb_y[0]:\\n            return -1\\n        return bb_x[1] / bb_y[1]\\n    \\n    def compact(self):\\n        for key in self.content:\\n            self.find(key)\\n            \\n\\n\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        uf = UnionFind()\\n        for eq, val in zip(equations, values):\\n            uf.union(eq[0], eq[1], val)\\n        \\n        uf.compact()\\n        \\n        return [uf.div(q[0], q[1]) for q in queries]\\n        \\n        \\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self):\\n        self.content = dict()\\n        \\n    \\n    def find(self, x):\\n        origin = self.content[x]\\n        if origin[0] != x:\\n            node = self.find(origin[0])\\n            self.content[x] = (node[0], node[1] * origin[1])\\n        return self.content[x]\\n    \\n    def union(self, x, y, value):\\n        if x not in self.content:\\n            self.content[x] = (x, 1)\\n        if y not in self.content:\\n            self.content[y] = (y, 1)\\n        bb_x = self.find(x)\\n        bb_y = self.find(y)\\n        self.content[bb_x[0]] = (bb_y[0], bb_y[1] * value / bb_x[1])\\n    \\n    def div(self, x, y):\\n        if x not in self.content or y not in self.content:\\n            return -1\\n        \\n        bb_x = self.find(x)\\n        bb_y = self.find(y)\\n        \\n        if bb_x[0] != bb_y[0]:\\n            return -1\\n        return bb_x[1] / bb_y[1]\\n    \\n    def compact(self):\\n        for key in self.content:\\n            self.find(key)\\n            \\n\\n\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        uf = UnionFind()\\n        for eq, val in zip(equations, values):\\n            uf.union(eq[0], eq[1], val)\\n        \\n        uf.compact()\\n        \\n        return [uf.div(q[0], q[1]) for q in queries]\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 214888,
                "title": "readable-javascript-solution",
                "content": "Made minor changes (using much ES6) to https://leetcode.com/problems/evaluate-division/discuss/178091/JavaScript-BFS-100-beat-solution-explanation-included\\n\\nUsing BFS\\n    1. create a neighbor map of nom: [denom, value] and vise versa\\n    2. for each query in queries, evaluate\\n    3. Evaluate function will return -1 for undefined and 1 for if nom and denom are same\\n    4. use neighbor[nom] as first queue and set for visited\\n    5. if not found then add its\\'s neighbor with curvalue * nextValue\\n\\n```\\nvar calcEquation = function(equations, values, queries) {\\n    let neighbors = {};\\n    \\n    equations.forEach(([nom, denom], idx) => {\\n        const curValue = values[idx];\\n        neighbors[nom] = neighbors[nom] || [];\\n        neighbors[nom].push([denom, curValue]);\\n        \\n        neighbors[denom] = neighbors[denom] || [];\\n        neighbors[denom].push([nom, 1 / curValue]);\\n    });\\n    \\n    let result = [];\\n    for (let query of queries) {\\n        result.push(evaluate(query, neighbors));\\n    }\\n    \\n    return result;\\n};\\n\\nfunction evaluate(query, neighbors) {\\n    const [nom, denom] = query;\\n    if (!(nom in neighbors) || !(denom in neighbors)) return -1;\\n    if (nom === denom) return 1;\\n    \\n    let queue = neighbors[nom].slice();\\n    let visited = new Set();\\n    \\n    while (queue.length) {\\n        const [variable, value] = queue.shift();\\n        \\n        if (variable === denom) return value;\\n        visited.add(variable);\\n        \\n        const next = neighbors[variable];\\n        next.forEach(([next, nextValue]) => {\\n            if (visited.has(next)) return;\\n            queue.push([next, nextValue * value]);\\n        });\\n    }\\n    \\n    return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar calcEquation = function(equations, values, queries) {\\n    let neighbors = {};\\n    \\n    equations.forEach(([nom, denom], idx) => {\\n        const curValue = values[idx];\\n        neighbors[nom] = neighbors[nom] || [];\\n        neighbors[nom].push([denom, curValue]);\\n        \\n        neighbors[denom] = neighbors[denom] || [];\\n        neighbors[denom].push([nom, 1 / curValue]);\\n    });\\n    \\n    let result = [];\\n    for (let query of queries) {\\n        result.push(evaluate(query, neighbors));\\n    }\\n    \\n    return result;\\n};\\n\\nfunction evaluate(query, neighbors) {\\n    const [nom, denom] = query;\\n    if (!(nom in neighbors) || !(denom in neighbors)) return -1;\\n    if (nom === denom) return 1;\\n    \\n    let queue = neighbors[nom].slice();\\n    let visited = new Set();\\n    \\n    while (queue.length) {\\n        const [variable, value] = queue.shift();\\n        \\n        if (variable === denom) return value;\\n        visited.add(variable);\\n        \\n        const next = neighbors[variable];\\n        next.forEach(([next, nextValue]) => {\\n            if (visited.has(next)) return;\\n            queue.push([next, nextValue * value]);\\n        });\\n    }\\n    \\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88339,
                "title": "graph-java-solution",
                "content": "For the example:\\n```\\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\\nvalues = [2.0, 3.0],\\nqueries = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \\n```\\n\\nbuild a graph like this:\\n![0_1473673427632_download.png](/uploads/files/1473673430068-download.png) \\n\\nconnecting each the terms of each expression with a directed edge of weight 'value', and an inverted edge with weight 1/'value'.\\n\\nThen you can compute the result of each query just by searching a path in the graph from var1 to var2, and multiplying the weights. E.g: ``` [\"a\",\"c\"] = a -> b -> c = 2.0 * 3.0 = 6.0```\\nRemember to keep track of the visited nodes in the dfs , and stop as soon as you got a valid result. Return -1.0 if you hit a dead end.\\n\\nHere is my code:\\n```\\npublic double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n\\tdouble[] results = new double[queries.length];\\n\\tMap<String,List<String>> graph = buildGraph(equations,values);\\n\\tfor(int i=0;i<queries.length;i++) {\\n\\t\\tString[] query = queries[i];\\n\\t\\tif(query[0].equals(query[1]) && !graph.containsKey(query[0])) {\\n\\t\\t\\tresults[i]=-1.0;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdouble result = computeResultDFS(graph,query);\\n\\t\\t\\tresults[i] = result;\\n\\t\\t}\\n\\t}\\n\\treturn results;\\n}\\n\\t\\npublic double computeResultDFS(Map<String,List<String>> graph, String[] query) {\\n\\tString dividend = query[0];\\n\\tString divisor = query[1];\\n\\tSet<String> visited = new HashSet<>();\\n\\tdouble result = 1.0;\\n\\tresult = dfs(dividend,divisor,graph,visited);\\n\\tif(result<0) result = -1.;\\n\\treturn result;\\n}\\n\\t\\npublic double dfs(String start, String end, Map<String,List<String>> graph, Set<String> visited) {\\n\\tif(start.equals(end)) return 1.0;\\n\\tif(visited.contains(start)) return -1.0;\\n\\tvisited.add(start);\\n\\tList<String> edgesList = graph.get(start);\\n\\tif(edgesList==null || edgesList.isEmpty()) return -1.0;\\n\\tdouble result = 1.0;\\n\\tfor(String edge: edgesList) {\\n\\t\\tString[] tokens = edge.split(\" \");\\n\\t\\tString next = tokens[0];\\n\\t\\tdouble val = Double.parseDouble(tokens[1]);\\n\\t\\tresult = val * dfs(next,end,graph,visited);\\n\\t\\tif(result>0) return result;\\n\\t}\\n\\treturn result;\\n}\\n\\t\\npublic Map<String,List<String>> buildGraph(String[][] equations, double[] values) {\\n\\tMap<String,List<String>> graph = new HashMap<>();\\n\\tfor(int i=0;i<equations.length;i++) {\\n\\t\\tString startNode = equations[i][0];\\n\\t\\tString endNode = equations[i][1];\\n\\t\\tdouble value = values[i];\\n\\t\\tString endEdge = endNode+\" \"+value;\\n\\t\\tString startEdge = startNode+\" \"+(1/value);\\n\\t\\tif(graph.containsKey(startNode)) {\\n\\t\\t\\tgraph.get(startNode).add(endEdge);\\n\\t\\t} else {\\n\\t\\t\\tList<String> edges = new ArrayList<>();\\n\\t\\t\\tedges.add(endEdge);\\n\\t\\t\\tgraph.put(startNode, edges);\\n\\t\\t}\\n\\t\\tif(graph.containsKey(endNode)) {\\n\\t\\t\\tgraph.get(endNode).add(startEdge);\\n\\t\\t} else {\\n\\t\\t\\tList<String> edges = new ArrayList<>();\\n\\t\\t\\tedges.add(startEdge);\\n\\t\\t\\tgraph.put(endNode, edges);\\n\\t\\t}\\n\\t}\\n\\treturn graph;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\\nvalues = [2.0, 3.0],\\nqueries = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \\n```\n``` [\"a\",\"c\"] = a -> b -> c = 2.0 * 3.0 = 6.0```\n```\\npublic double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n\\tdouble[] results = new double[queries.length];\\n\\tMap<String,List<String>> graph = buildGraph(equations,values);\\n\\tfor(int i=0;i<queries.length;i++) {\\n\\t\\tString[] query = queries[i];\\n\\t\\tif(query[0].equals(query[1]) && !graph.containsKey(query[0])) {\\n\\t\\t\\tresults[i]=-1.0;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdouble result = computeResultDFS(graph,query);\\n\\t\\t\\tresults[i] = result;\\n\\t\\t}\\n\\t}\\n\\treturn results;\\n}\\n\\t\\npublic double computeResultDFS(Map<String,List<String>> graph, String[] query) {\\n\\tString dividend = query[0];\\n\\tString divisor = query[1];\\n\\tSet<String> visited = new HashSet<>();\\n\\tdouble result = 1.0;\\n\\tresult = dfs(dividend,divisor,graph,visited);\\n\\tif(result<0) result = -1.;\\n\\treturn result;\\n}\\n\\t\\npublic double dfs(String start, String end, Map<String,List<String>> graph, Set<String> visited) {\\n\\tif(start.equals(end)) return 1.0;\\n\\tif(visited.contains(start)) return -1.0;\\n\\tvisited.add(start);\\n\\tList<String> edgesList = graph.get(start);\\n\\tif(edgesList==null || edgesList.isEmpty()) return -1.0;\\n\\tdouble result = 1.0;\\n\\tfor(String edge: edgesList) {\\n\\t\\tString[] tokens = edge.split(\" \");\\n\\t\\tString next = tokens[0];\\n\\t\\tdouble val = Double.parseDouble(tokens[1]);\\n\\t\\tresult = val * dfs(next,end,graph,visited);\\n\\t\\tif(result>0) return result;\\n\\t}\\n\\treturn result;\\n}\\n\\t\\npublic Map<String,List<String>> buildGraph(String[][] equations, double[] values) {\\n\\tMap<String,List<String>> graph = new HashMap<>();\\n\\tfor(int i=0;i<equations.length;i++) {\\n\\t\\tString startNode = equations[i][0];\\n\\t\\tString endNode = equations[i][1];\\n\\t\\tdouble value = values[i];\\n\\t\\tString endEdge = endNode+\" \"+value;\\n\\t\\tString startEdge = startNode+\" \"+(1/value);\\n\\t\\tif(graph.containsKey(startNode)) {\\n\\t\\t\\tgraph.get(startNode).add(endEdge);\\n\\t\\t} else {\\n\\t\\t\\tList<String> edges = new ArrayList<>();\\n\\t\\t\\tedges.add(endEdge);\\n\\t\\t\\tgraph.put(startNode, edges);\\n\\t\\t}\\n\\t\\tif(graph.containsKey(endNode)) {\\n\\t\\t\\tgraph.get(endNode).add(startEdge);\\n\\t\\t} else {\\n\\t\\t\\tList<String> edges = new ArrayList<>();\\n\\t\\t\\tedges.add(startEdge);\\n\\t\\t\\tgraph.put(endNode, edges);\\n\\t\\t}\\n\\t}\\n\\treturn graph;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2665228,
                "title": "c-disjoint-set-union-marking-variables-with-unique-identifiers",
                "content": "Before you begin reading this article, a small reminder that you must have basic textbook knowledge of DSU if you want to completely understand this article such as Union Find, Path Compression, Union by Size, etc. If you don\\'t know the basics, I highly recommend you to refer to this article:\\n\\nhttps://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide\\n\\nFor all the textbook learners of DSU, it\\'s rather easy to understand Union Find with integers rather than strings. Also, when we use strings and compare them, it performs a linear scan of the characters, increasing the overall TC. So, instead of using strings, we can assign each unique variable (string) with a unique integer (ID of the string). \\n\\nFor each unique variable pairs, perform the union operation. The union function is rather simple. It takes the arguments: **variable 1\\'s ID**, **variable 2\\'s ID** and the **ratio value**. The ratio value is also used to differentiate a query from a non-query. The union function performs two different tasks at the same time:\\n\\n1. If a query (ratio = 0) and ID of the parents of the two variables (u, v) are equal (a.first == b.first), it returns the ratio value (a.second / b.second).  Here, the a.second variable holds the ratio value from node u to its root (a.first) and b.second holds from node v to its root (b.first).  Here by holding the value, I mean it gives the final value of node / root.\\nFinally, dividing the two values (a.second,  b.second) we get:\\n```\\n   (node u / root) / (node v / root) \\n=> (node u / root) * (root / node v) \\n=> (node u / node v)\\n```\\n&emsp; &emsp; If the ID of parents of nodes are not equal, we simply return -1, as the answer cannot be determined.\\n\\n2. If not a query (ratio != 0), if the ID of the parents are equal we need not connect them again as they already belong to the same set, so we simply return the ratio value (unused for not a query). If the ID of the parents are not equal, we used the concept of Union by Size, and attach the node with smaller tree size to the node with larger size. And as for the value, we simply update the value to  ``` (b.second / a.second) * ratio```. \\nHowever, there is a small trick here. For \\'a / b\\', we would want to make \\'a\\' \\'s parent as \\'b\\' and update the value as the value of the ratio (a / b) passed as the argument. But while using Union by Size, we may end up making \\'b\\' \\'s parent as \\'a\\'. So to avoid messing up the ratio value, whenever we would make \\'b\\' \\'s parent as \\'a\\', we would also invert the ratio with ```ratio = 1.0 / ratio```.\\nGiven that we never encounter division by zero, it\\'s safe to assume that the same will hold true for inverting the ratio value.\\n\\nThe below well-commented code may serve as a guide to show you the workflow explained above.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, double> > rep;\\n    vector<int> sz;\\n    \\n    // Union Find with Path Compression\\n    pair<int, double> find(int u){\\n        auto [p, f] = rep[u];\\n        if(p != u){\\n            auto [n, r] = find(p);\\n            // Path Compression - Reattaching each node with their root\\n            rep[u] = {n, r * f};\\n        }\\n        return rep[u];\\n    }\\n    \\n    // Union Operation with Union By Size\\n    double Union(int u, int v, double ratio){\\n        pair<int, double> a = find(u), b = find(v);\\n        \\n        // if same parent, result given by a / b\\n        if(a.first == b.first)\\n            return a.second / b.second;\\n        \\n        // ratio = 0 for query\\n        if(!ratio)\\n            return -1.0;\\n        \\n        // Union by Size - Attaching sub tree (small size) to the root of taller tree (bigger size)\\n        if(sz[a.first] < sz[b.first])\\n            swap(a, b), ratio = 1.0 / ratio;\\n        rep[a.first] = {b.first, b.second / a.second * ratio};\\n        \\n        // if no answer determined, return -1\\n        return -1.0;\\n    }\\n    \\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        // labelling each unique variable with an integer\\n        unordered_map<string, int> mp;\\n        int n = 0;\\n        for(auto &i: equations){\\n            if(mp.find(i[0]) == mp.end() )\\n                mp[i[0]] = n++;\\n            if(mp.find(i[1]) == mp.end() )\\n                mp[i[1]] = n++;\\n        }\\n        \\n        // Initialization of DSU\\n        for(int i = 0; i < n; ++i){\\n            rep.push_back({i, 1.0});\\n            sz.push_back(1);\\n        }\\n        \\n        // Union all the given equation variables with their ratio value included\\n        for(int i = 0; i < (int)equations.size(); ++i)\\n            Union(mp[equations[i][0]], mp[equations[i][1]], values[i]);\\n        \\n        vector<double> res;\\n        for(auto &query: queries){\\n            // for each query if new variable encountered, answer cannot be deteremined\\n            if(mp.find(query[0]) == mp.end() || mp.find(query[1]) == mp.end() )\\n               res.push_back(-1.0);\\n            \\n            // union variables (Ci, Di) for each query to get the value of Ci / Di\\n            else\\n                // ratio = 0 for query\\n                res.push_back(Union(mp[query[0]], mp[query[1]], 0) ); \\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\n   (node u / root) / (node v / root) \\n=> (node u / root) * (root / node v) \\n=> (node u / node v)\\n```\n``` (b.second / a.second) * ratio```\n```ratio = 1.0 / ratio```\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, double> > rep;\\n    vector<int> sz;\\n    \\n    // Union Find with Path Compression\\n    pair<int, double> find(int u){\\n        auto [p, f] = rep[u];\\n        if(p != u){\\n            auto [n, r] = find(p);\\n            // Path Compression - Reattaching each node with their root\\n            rep[u] = {n, r * f};\\n        }\\n        return rep[u];\\n    }\\n    \\n    // Union Operation with Union By Size\\n    double Union(int u, int v, double ratio){\\n        pair<int, double> a = find(u), b = find(v);\\n        \\n        // if same parent, result given by a / b\\n        if(a.first == b.first)\\n            return a.second / b.second;\\n        \\n        // ratio = 0 for query\\n        if(!ratio)\\n            return -1.0;\\n        \\n        // Union by Size - Attaching sub tree (small size) to the root of taller tree (bigger size)\\n        if(sz[a.first] < sz[b.first])\\n            swap(a, b), ratio = 1.0 / ratio;\\n        rep[a.first] = {b.first, b.second / a.second * ratio};\\n        \\n        // if no answer determined, return -1\\n        return -1.0;\\n    }\\n    \\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        // labelling each unique variable with an integer\\n        unordered_map<string, int> mp;\\n        int n = 0;\\n        for(auto &i: equations){\\n            if(mp.find(i[0]) == mp.end() )\\n                mp[i[0]] = n++;\\n            if(mp.find(i[1]) == mp.end() )\\n                mp[i[1]] = n++;\\n        }\\n        \\n        // Initialization of DSU\\n        for(int i = 0; i < n; ++i){\\n            rep.push_back({i, 1.0});\\n            sz.push_back(1);\\n        }\\n        \\n        // Union all the given equation variables with their ratio value included\\n        for(int i = 0; i < (int)equations.size(); ++i)\\n            Union(mp[equations[i][0]], mp[equations[i][1]], values[i]);\\n        \\n        vector<double> res;\\n        for(auto &query: queries){\\n            // for each query if new variable encountered, answer cannot be deteremined\\n            if(mp.find(query[0]) == mp.end() || mp.find(query[1]) == mp.end() )\\n               res.push_back(-1.0);\\n            \\n            // union variables (Ci, Di) for each query to get the value of Ci / Di\\n            else\\n                // ratio = 0 for query\\n                res.push_back(Union(mp[query[0]], mp[query[1]], 0) ); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463656,
                "title": "easy-to-read-python-unionfind",
                "content": "```\\n\\nclass UnionFind():\\n    def __init__(self, variables):\\n        self.root = {v: v for v in variables}\\n        self.rank = {v: 1 for v in variables}\\n        self.val = {v: 1 for v in variables}\\n        \\n    def find(self, x):\\n        if x not in self.root:\\n            return None, 0\\n        if x == self.root[x]:\\n            return x, self.val[x]\\n        self.root[x], m = self.find(self.root[x])\\n        self.val[x] *= m\\n        return self.root[x], self.val[x]\\n    \\n    def union(self, x, y, v):\\n        x, v_x = self.find(x)\\n        y, v_y = self.find(y)\\n        if x != y:\\n            if self.rank[x] < self.rank[y]:\\n                self.root[x] = y\\n                self.val[x] = v_y / v_x * v\\n            elif self.rank[y] < self.rank[x]:\\n                self.root[y] = x\\n                self.val[y] = v_x / v_y / v \\n            else:\\n                self.root[y] = x\\n                self.rank[x] += 1\\n                self.val[y] = v_x / v_y / v\\n        \\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        \\n        # Instantiate a UnionFind object\\n        variables = set()\\n        for e in equations:\\n            variables.add(e[0])\\n            variables.add(e[1])\\n        uf = UnionFind(variables)\\n        \\n        # Add relations\\n        for e, v in zip(equations, values):\\n            uf.union(e[0], e[1], v)\\n        \\n        # Calculate query outputs\\n        out = []\\n        for q in queries:\\n            r0, v0 = uf.find(q[0])\\n            r1, v1 = uf.find(q[1])\\n            if not r0 or not r1 or r0 != r1:\\n                out.append(-1)\\n            else:\\n                out.append(v0 / v1)\\n        return out\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n\\nclass UnionFind():\\n    def __init__(self, variables):\\n        self.root = {v: v for v in variables}\\n        self.rank = {v: 1 for v in variables}\\n        self.val = {v: 1 for v in variables}\\n        \\n    def find(self, x):\\n        if x not in self.root:\\n            return None, 0\\n        if x == self.root[x]:\\n            return x, self.val[x]\\n        self.root[x], m = self.find(self.root[x])\\n        self.val[x] *= m\\n        return self.root[x], self.val[x]\\n    \\n    def union(self, x, y, v):\\n        x, v_x = self.find(x)\\n        y, v_y = self.find(y)\\n        if x != y:\\n            if self.rank[x] < self.rank[y]:\\n                self.root[x] = y\\n                self.val[x] = v_y / v_x * v\\n            elif self.rank[y] < self.rank[x]:\\n                self.root[y] = x\\n                self.val[y] = v_x / v_y / v \\n            else:\\n                self.root[y] = x\\n                self.rank[x] += 1\\n                self.val[y] = v_x / v_y / v\\n        \\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        \\n        # Instantiate a UnionFind object\\n        variables = set()\\n        for e in equations:\\n            variables.add(e[0])\\n            variables.add(e[1])\\n        uf = UnionFind(variables)\\n        \\n        # Add relations\\n        for e, v in zip(equations, values):\\n            uf.union(e[0], e[1], v)\\n        \\n        # Calculate query outputs\\n        out = []\\n        for q in queries:\\n            r0, v0 = uf.find(q[0])\\n            r1, v1 = uf.find(q[1])\\n            if not r0 or not r1 or r0 != r1:\\n                out.append(-1)\\n            else:\\n                out.append(v0 / v1)\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012441,
                "title": "c-very-simplified-approach-and-explanation-with-comments-dsu",
                "content": "The solution is based on the observation that we can calculate the ans for given ci and di if they are related to each other somehow i.e. they belongs to same cohort.\\nFor this purpose, we have used DSU (Disjoint Set Union) for the implementation.\\n\\n```\\nclass Solution {\\n    \\n    // DSU factors declaration\\n    map<string,string> par;\\n    map<string,long long> size;\\n    map<string,double> mp;\\n    \\n    // Adding new node to our DSU graph\\n    void addNode(string s){\\n        if(par.find(s) == par.end()){ par[s] = s; size[s] = 1;}\\n    }\\n    \\n    // To find parent node for a given node\\n    string getPar( string x ){\\n        if( par[x] == x ) return x;\\n        // Path Compression\\n        return par[x] = getPar(par[x]);\\n    }\\n    \\n    // To merge two nodes resulting their parents to be same i.e. now both belongs to the same component\\n    void join( string a, string b ){\\n        string pa = getPar(a);\\n        string pb = getPar(b);\\n        if(pa == pb) return;\\n        // Size optimisation\\n        if(size[pa] < size[pb]) swap(pa,pb);\\n        par[pb] = pa;\\n        size[pa]+=size[pb];\\n    }\\n    \\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        // Making connected components first by adding them in DSU\\n        for(auto eq:equations){\\n            string ai = eq[0], bi = eq[1];\\n            addNode(ai);\\n            addNode(bi);\\n            join(ai,bi);\\n        }\\n        \\n        /* \\n            Now, we assume value of parent to be 1 always\\n            let say a/b = 3    and   b/c = 2\\n            and mapping is like par[a] = a , par[b] = a, par[c] = a\\n            then we can easily take other values of a component\\n            \\n            like here we put a = 1;\\n            the b = 1/3\\n            after it c = 1/6\\n            ..... and so on\\n        */\\n        for(auto p:par){\\n            if(p.first == p.second) mp[p.first] = 1;\\n        }\\n        \\n        // ADDING INDIVIDUAL VALUES TO OUR MAP\\n        while( mp.size() < par.size() ){\\n            \\n             for(int i = 0;i<equations.size();i++){\\n                 string ai = equations[i][0], bi = equations[i][1];\\n                 double v = values[i];\\n                 \\n                if( mp.find(ai) == mp.end() && mp.find(bi) == mp.end() ){\\n                    // will handle it in next iteration\\n                } else if( mp.find(ai) == mp.end() ){\\n                    mp[ai] = mp[bi]*v;\\n                } else if(mp.find(bi) == mp.end()){\\n                    mp[bi] = mp[ai]/v;\\n                }\\n            }\\n            \\n        }\\n        \\n        // FINDING ANSWER\\n         vector<double> ans;\\n        \\n        for(auto q:queries){\\n            string ci = q[0], di = q[1];\\n            \\n            // If its a new variable overall or if parents of variables are different then push -1\\n            if( par.find(ci) == par.end() || par.find(di) == par.end() || getPar(ci) != getPar(di)){\\n                ans.push_back(-1);\\n            } else {\\n                // So, for now we actually stored var / par  as value in our map\\n                // ans as we kept par = 1\\n                // we can directly divide their map values and find the answer\\n                ans.push_back(mp[ci]/mp[di]);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    } \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // DSU factors declaration\\n    map<string,string> par;\\n    map<string,long long> size;\\n    map<string,double> mp;\\n    \\n    // Adding new node to our DSU graph\\n    void addNode(string s){\\n        if(par.find(s) == par.end()){ par[s] = s; size[s] = 1;}\\n    }\\n    \\n    // To find parent node for a given node\\n    string getPar( string x ){\\n        if( par[x] == x ) return x;\\n        // Path Compression\\n        return par[x] = getPar(par[x]);\\n    }\\n    \\n    // To merge two nodes resulting their parents to be same i.e. now both belongs to the same component\\n    void join( string a, string b ){\\n        string pa = getPar(a);\\n        string pb = getPar(b);\\n        if(pa == pb) return;\\n        // Size optimisation\\n        if(size[pa] < size[pb]) swap(pa,pb);\\n        par[pb] = pa;\\n        size[pa]+=size[pb];\\n    }\\n    \\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        // Making connected components first by adding them in DSU\\n        for(auto eq:equations){\\n            string ai = eq[0], bi = eq[1];\\n            addNode(ai);\\n            addNode(bi);\\n            join(ai,bi);\\n        }\\n        \\n        /* \\n            Now, we assume value of parent to be 1 always\\n            let say a/b = 3    and   b/c = 2\\n            and mapping is like par[a] = a , par[b] = a, par[c] = a\\n            then we can easily take other values of a component\\n            \\n            like here we put a = 1;\\n            the b = 1/3\\n            after it c = 1/6\\n            ..... and so on\\n        */\\n        for(auto p:par){\\n            if(p.first == p.second) mp[p.first] = 1;\\n        }\\n        \\n        // ADDING INDIVIDUAL VALUES TO OUR MAP\\n        while( mp.size() < par.size() ){\\n            \\n             for(int i = 0;i<equations.size();i++){\\n                 string ai = equations[i][0], bi = equations[i][1];\\n                 double v = values[i];\\n                 \\n                if( mp.find(ai) == mp.end() && mp.find(bi) == mp.end() ){\\n                    // will handle it in next iteration\\n                } else if( mp.find(ai) == mp.end() ){\\n                    mp[ai] = mp[bi]*v;\\n                } else if(mp.find(bi) == mp.end()){\\n                    mp[bi] = mp[ai]/v;\\n                }\\n            }\\n            \\n        }\\n        \\n        // FINDING ANSWER\\n         vector<double> ans;\\n        \\n        for(auto q:queries){\\n            string ci = q[0], di = q[1];\\n            \\n            // If its a new variable overall or if parents of variables are different then push -1\\n            if( par.find(ci) == par.end() || par.find(di) == par.end() || getPar(ci) != getPar(di)){\\n                ans.push_back(-1);\\n            } else {\\n                // So, for now we actually stored var / par  as value in our map\\n                // ans as we kept par = 1\\n                // we can directly divide their map values and find the answer\\n                ans.push_back(mp[ci]/mp[di]);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993806,
                "title": "time-optimal-solution-with-some-linq",
                "content": "```c#\\npublic class Solution\\n{\\n    public double[] CalcEquation(IList<IList<string>> eq, double[] vals, IList<IList<string>> q)\\n    {\\n        Dictionary<string, Dictionary<string, double>> map = new();\\n        HashSet<string> visited = new();\\n\\n        foreach (var (num, den, val) in eq.Zip(vals, (e, v) => (e[0], e[1], v)))\\n        {\\n            if (!map.ContainsKey(num)) map[num] = new();\\n            if (!map.ContainsKey(den)) map[den] = new();\\n\\n            map[num][den] = 1 / val;\\n            map[den][num] = val;\\n        }\\n\\n        return q.Select(s => FindResult(s[1], s[0])).ToArray();\\n\\n        double FindResult(string s, string t)\\n        {\\n            if (!map.ContainsKey(s)) return -1;\\n            if (s == t) return 1;\\n            \\n            double cur = -1;\\n            visited.Add(s);\\n            \\n            foreach (var k in map[s].Keys)\\n            {\\n                if (visited.Contains(k)) continue;\\n                cur = FindResult(k, t);\\n                if (cur != -1)\\n                {\\n                    cur *= map[s][k];\\n                    break;\\n                }\\n            }\\n\\n            visited.Remove(s);\\n            return cur;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```c#\\npublic class Solution\\n{\\n    public double[] CalcEquation(IList<IList<string>> eq, double[] vals, IList<IList<string>> q)\\n    {\\n        Dictionary<string, Dictionary<string, double>> map = new();\\n        HashSet<string> visited = new();\\n\\n        foreach (var (num, den, val) in eq.Zip(vals, (e, v) => (e[0], e[1], v)))\\n        {\\n            if (!map.ContainsKey(num)) map[num] = new();\\n            if (!map.ContainsKey(den)) map[den] = new();\\n\\n            map[num][den] = 1 / val;\\n            map[den][num] = val;\\n        }\\n\\n        return q.Select(s => FindResult(s[1], s[0])).ToArray();\\n\\n        double FindResult(string s, string t)\\n        {\\n            if (!map.ContainsKey(s)) return -1;\\n            if (s == t) return 1;\\n            \\n            double cur = -1;\\n            visited.Add(s);\\n            \\n            foreach (var k in map[s].Keys)\\n            {\\n                if (visited.Contains(k)) continue;\\n                cur = FindResult(k, t);\\n                if (cur != -1)\\n                {\\n                    cur *= map[s][k];\\n                    break;\\n                }\\n            }\\n\\n            visited.Remove(s);\\n            return cur;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380335,
                "title": "c-simple-clean-algorithm-and-code-explained-step-by-step",
                "content": "At first, it is really tricky to identify that the problem can be solved using graph algorithms.  After knowing this too, one can understand the algorithm, but implementing this might again be a tedious job. \\n\\nIf you have idea about the **Floyd-Warshall algorithm**, it might help. But not knowing this algorithm won\\'t be a trouble here.\\n\\nFor those who know the algorithm, you can relate that, here we are not calculating the shortest distance, but the quotient. Suppose the shorted distance between A and E using Floyd Warshall comes out to be A->B-> C->D->E. Also, we know that we can calculate A/E by calculating (A/x) * (x/E) if (A/x) and (x/E) is known. Hence, using the algorithm, we can get path from A to E {A->B->C->D->E} , and value A/E as (A/B) * (B/C)* (C/D) * (D/E).\\n\\nThe basic algorithm for this problem has 3 steps:\\n1. Make an adjacency List\\n2. Calculate for all the combinations possible\\n3. Add the output for all the queries in vector and return.\\n\\nThe below code describes all steps in detail.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        /* Adjacency list =>\\n            NOTE 1: We understand that the adjacency list should show edge between strings.\\n            NOTE 2: It is a weighted directed graph.\\n                i.e. a/b = 2.0 needs to be represented as (a---2.0--->b) \\n            \\n            Every element should point to its divisor and the value.\\n            So, we use map for creating the list with key as the dividend string\\n            The value associated is a pair of string and double value.\\n            Since one key have multiple associated values, we make the value also as a map object.\\n            \\n            ........\\n            When creating a list, \\n                    suppose a/b = 2.0\\n                    => a/b = 2.0 , b/a = 1/2.0 , a/a = 1.0, b/b = 0\\n                    Hence for each edge, add these three combinations in the map.\\n                    => mp[a][b] = 2.0, mp[b][a] = 1/2.0 , mp[a][a] = 1.0, mp[b][b] = 2.0\\n                    \\n        */\\n        \\n        unordered_map <string, unordered_map <string, double>> mp;\\n        for(int i = 0; i<equations.size(); i++){\\n            double v = values[i];\\n            mp[equations[i][0]][equations[i][1]] = v;\\n            mp[equations[i][1]][equations[i][0]] = 1/v;\\n            mp[equations[i][0]][equations[i][0]] = 1.0;\\n            mp[equations[i][1]][equations[i][1]] = 1.0;\\n        }\\n        \\n        /* To solve the queries, \\n                mp[a][b] = a/b value\\n              & mp[b][c] = b/c value\\n              \\n         => mp[a][c] should equal a/c value\\n                                = (a/b) * (b/c) value\\n         => mp[a][c] = mp[a][b] * mp[b][c] */\\n        \\n        for(auto i: mp){\\n            for(auto j : mp[i.first]){\\n                for(auto k: mp[i.first])\\n                    mp[j.first][k.first] = mp[j.first][i.first] * mp[i.first][k.first];\\n            }\\n        }\\n        \\n        /* Solving Queries one by one */\\n        \\n        vector <double> v;\\n        for(auto i: queries){\\n            string from = i[0];\\n            string to = i[1];\\n            if((mp.find(from)!=mp.end()) && (mp[from].find(to)!=mp[from].end()))\\n                v.push_back(mp[from][to]);\\n            else\\n                v.push_back(-1.0);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        /* Adjacency list =>\\n            NOTE 1: We understand that the adjacency list should show edge between strings.\\n            NOTE 2: It is a weighted directed graph.\\n                i.e. a/b = 2.0 needs to be represented as (a---2.0--->b) \\n            \\n            Every element should point to its divisor and the value.\\n            So, we use map for creating the list with key as the dividend string\\n            The value associated is a pair of string and double value.\\n            Since one key have multiple associated values, we make the value also as a map object.\\n            \\n            ........\\n            When creating a list, \\n                    suppose a/b = 2.0\\n                    => a/b = 2.0 , b/a = 1/2.0 , a/a = 1.0, b/b = 0\\n                    Hence for each edge, add these three combinations in the map.\\n                    => mp[a][b] = 2.0, mp[b][a] = 1/2.0 , mp[a][a] = 1.0, mp[b][b] = 2.0\\n                    \\n        */\\n        \\n        unordered_map <string, unordered_map <string, double>> mp;\\n        for(int i = 0; i<equations.size(); i++){\\n            double v = values[i];\\n            mp[equations[i][0]][equations[i][1]] = v;\\n            mp[equations[i][1]][equations[i][0]] = 1/v;\\n            mp[equations[i][0]][equations[i][0]] = 1.0;\\n            mp[equations[i][1]][equations[i][1]] = 1.0;\\n        }\\n        \\n        /* To solve the queries, \\n                mp[a][b] = a/b value\\n              & mp[b][c] = b/c value\\n              \\n         => mp[a][c] should equal a/c value\\n                                = (a/b) * (b/c) value\\n         => mp[a][c] = mp[a][b] * mp[b][c] */\\n        \\n        for(auto i: mp){\\n            for(auto j : mp[i.first]){\\n                for(auto k: mp[i.first])\\n                    mp[j.first][k.first] = mp[j.first][i.first] * mp[i.first][k.first];\\n            }\\n        }\\n        \\n        /* Solving Queries one by one */\\n        \\n        vector <double> v;\\n        for(auto i: queries){\\n            string from = i[0];\\n            string to = i[1];\\n            if((mp.find(from)!=mp.end()) && (mp[from].find(to)!=mp[from].end()))\\n                v.push_back(mp[from][to]);\\n            else\\n                v.push_back(-1.0);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035346,
                "title": "java-weighted-quick-union-with-path-compression-beats-100",
                "content": "```\\nclass UF {\\n    int[] parent;\\n    int[] sz;\\n    double[] weight;\\n    int count;\\n    public UF(int n) {\\n        parent = new int[n];\\n        sz = new int[n];\\n        weight = new double[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            sz[i] = 1;\\n            weight[i] = 1.0;\\n        }\\n        count = n;\\n    }\\n    public int find(int p) {\\n        if (p != parent[p]) {\\n            int origp = parent[p];\\n            parent[p] = find(parent[p]);\\n            weight[p] *= weight[origp];\\n        }\\n        return parent[p];\\n    }\\n    public boolean connected(int p, int q) {\\n        return find(p) == find(q);\\n    }\\n    public double getQuotient(int p, int q) {\\n        if (connected(p, q))\\n            return weight[p] / weight[q];\\n        else\\n            return -1.0;\\n    }\\n    public void union(int p, int q, double value) {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if (rootP == rootQ) return;\\n        if (sz[rootP] < sz[rootQ]) {\\n            parent[rootP] = rootQ;\\n            sz[rootQ] += sz[rootP];\\n            weight[rootP] = weight[q] * value / weight[p];\\n        }\\n        else {\\n            parent[rootQ] = rootP;\\n            sz[rootP] += sz[rootQ];\\n            weight[rootQ] = weight[p] / value / weight[q];\\n        }\\n        count--;\\n    }\\n}\\nclass Solution {\\n    private Map<String, Integer> varIndex;\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        varIndex = new HashMap<>();\\n        int M = equations.size();\\n        int n = M * 2;\\n        UF uf = new UF(n);\\n        int id = 0;\\n        for (int i = 0; i < M; i++) {\\n            String v1 = equations.get(i).get(0);\\n            String v2  = equations.get(i).get(1);\\n            double q = values[i];\\n            if (!varIndex.containsKey(v1))\\n                varIndex.put(v1, id++);\\n            if (!varIndex.containsKey(v2))\\n                varIndex.put(v2, id++);\\n            uf.union(indexOf(v1), indexOf(v2), q);\\n        }\\n\\n        double[] ans = new double[queries.size()];\\n        for (int i = 0; i < queries.size(); i++) {\\n            String v1 = queries.get(i).get(0);\\n            String v2 = queries.get(i).get(1);\\n            if (!varIndex.containsKey(v1) || !varIndex.containsKey(v2))\\n                ans[i] = -1.0;\\n            else if (v1.equals(v2))\\n                ans[i] = 1.0;\\n            else {\\n                ans[i] = uf.getQuotient(indexOf(v1), indexOf(v2));\\n            }\\n        }\\n        return ans;\\n    }\\n    private Integer indexOf(String name) {\\n        return varIndex.get(name);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass UF {\\n    int[] parent;\\n    int[] sz;\\n    double[] weight;\\n    int count;\\n    public UF(int n) {\\n        parent = new int[n];\\n        sz = new int[n];\\n        weight = new double[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            sz[i] = 1;\\n            weight[i] = 1.0;\\n        }\\n        count = n;\\n    }\\n    public int find(int p) {\\n        if (p != parent[p]) {\\n            int origp = parent[p];\\n            parent[p] = find(parent[p]);\\n            weight[p] *= weight[origp];\\n        }\\n        return parent[p];\\n    }\\n    public boolean connected(int p, int q) {\\n        return find(p) == find(q);\\n    }\\n    public double getQuotient(int p, int q) {\\n        if (connected(p, q))\\n            return weight[p] / weight[q];\\n        else\\n            return -1.0;\\n    }\\n    public void union(int p, int q, double value) {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if (rootP == rootQ) return;\\n        if (sz[rootP] < sz[rootQ]) {\\n            parent[rootP] = rootQ;\\n            sz[rootQ] += sz[rootP];\\n            weight[rootP] = weight[q] * value / weight[p];\\n        }\\n        else {\\n            parent[rootQ] = rootP;\\n            sz[rootP] += sz[rootQ];\\n            weight[rootQ] = weight[p] / value / weight[q];\\n        }\\n        count--;\\n    }\\n}\\nclass Solution {\\n    private Map<String, Integer> varIndex;\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        varIndex = new HashMap<>();\\n        int M = equations.size();\\n        int n = M * 2;\\n        UF uf = new UF(n);\\n        int id = 0;\\n        for (int i = 0; i < M; i++) {\\n            String v1 = equations.get(i).get(0);\\n            String v2  = equations.get(i).get(1);\\n            double q = values[i];\\n            if (!varIndex.containsKey(v1))\\n                varIndex.put(v1, id++);\\n            if (!varIndex.containsKey(v2))\\n                varIndex.put(v2, id++);\\n            uf.union(indexOf(v1), indexOf(v2), q);\\n        }\\n\\n        double[] ans = new double[queries.size()];\\n        for (int i = 0; i < queries.size(); i++) {\\n            String v1 = queries.get(i).get(0);\\n            String v2 = queries.get(i).get(1);\\n            if (!varIndex.containsKey(v1) || !varIndex.containsKey(v2))\\n                ans[i] = -1.0;\\n            else if (v1.equals(v2))\\n                ans[i] = 1.0;\\n            else {\\n                ans[i] = uf.getQuotient(indexOf(v1), indexOf(v2));\\n            }\\n        }\\n        return ans;\\n    }\\n    private Integer indexOf(String name) {\\n        return varIndex.get(name);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867510,
                "title": "shouldn-t-ba-equal-to-ab-as-they-can-be-seen-as-product-of-variables",
                "content": "The example input 2 makes me wonder, if one interprets the variables strings as variable products (i.e. \"ab\" is \"a\" multiplies \"b\"), then this problem will become quite tricky.\\n\\nFor instance, given input:\\n```\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"ed\", \"fg\"]]\\n[2.0,3.0, 5.9]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"de\",\"gf\"]]\\n```\\nThe current expected output is:\\n```\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000,-1.00000]\\n```\\nBut why the answer to the last query can\\'t be `5.9`, as suggested by the last values?\\nI believe such interpretation is correct, but I am not sure how no one has ever raised such questions. Even more, one will need to simplfy the input equations to lowest terms before building the graph. One should also note that other equations\\' value might be needed in another query. So it will get convoluted soon if the input is complicated. \\n\\nAny thoughts are welcomed, thanks.",
                "solutionTags": [],
                "code": "```\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"ed\", \"fg\"]]\\n[2.0,3.0, 5.9]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"de\",\"gf\"]]\\n```\n```\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000,-1.00000]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731504,
                "title": "cpp-solution-with-comments-easy-to-understand-explained",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Evaluate Division.\\nMemory Usage: 7.7 MB, less than 29.60% of C++ online submissions for Evaluate Division.**\\n\\n**You will notice that this is a problem of graph (dfs)\\nlike if we are given a/b=2 and b/c=3\\nthen we can find a/c simply multiplying both the equations\\nSo if we create a graph \\nGiven- [[a,b],[b,c]]=[[2],[3]]\\nWe have to find [[a/c],[c/a]]\\na-->(b,2)\\nb-->(a,1/2)\\nb-->(a,1/2),(c,3)\\nc-->(b,3/2)**\\n\\n**a/c=?\\nthen we will go from a->b res=2 * 1 =2\\nnow we will go from b->c res=2 * 3 =6\\nres will be 6:**\\n\\n**c/a=?\\nthen we will go from c->b res=(1/3) * 1 =1/3\\nnow we will go from b->a res=(1/3) * (1/2) =1/6\\nres will be 1/6:**\\n```\\nclass Solution {\\npublic:\\n    \\n     vector<double> res;   //to store final output\\n     map<string,vector<pair<string,double>>> adj; //Create a map to store adjacency list\\n    \\n    void find(string x,string y,map<string,int> &vis,double rs)\\n    {  \\n        vis[x]=1;\\n        if(x==y){\\n          res.push_back(rs);return;\\n        }\\n        for(int i=0;i<adj[x].size();i++)\\n        {  \\n            string p=adj[x][i].first;\\n           \\n            if( vis.count(p)==0)\\n            {    \\n                find(p,y,vis,rs*adj[x][i].second);\\n            }\\n        }\\n         \\n        return;\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        if(equations.size()==0) return res;\\n        if(equations[0].size()==0) return res;\\n        \\n         \\n        \\n        for(int i=0;i<equations.size();i++)\\n        {   \\n            string x=equations[i][0],y=equations[i][1]; \\n            double val=values[i]; \\n            adj[x].push_back({y,val});   //store weight of path like x/y=2, x->y (2)\\n            adj[y].push_back({x,double(1)/val}); //store reverse path x/y=2 , y->x (1/2)\\n        }\\n       \\n         \\n        for(int i=0;i<queries.size();i++)  //traverse queries\\n        {   \\n             string x=queries[i][0],y=queries[i][1];\\n            if(adj.count(x)==0||adj.count(y)==0) \\n             {\\n                res.push_back(double(-1));continue; \\n                //check if variable is absent in equation then result will be -1.00\\n             }\\n              \\n             map <string,int> vis; //create visites map to check visited variables\\n            //call find function to solve query \\n             find(x,y,vis,double(1)*(1.0));\\n            //if we didn\\'t find val like for x/y=2 , p/q=3\\n            //we have to find x/p which is impossible so we will insert -1.00\\n             if(res.size()!=i+1) res.push_back(double(-1));\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     vector<double> res;   //to store final output\\n     map<string,vector<pair<string,double>>> adj; //Create a map to store adjacency list\\n    \\n    void find(string x,string y,map<string,int> &vis,double rs)\\n    {  \\n        vis[x]=1;\\n        if(x==y){\\n          res.push_back(rs);return;\\n        }\\n        for(int i=0;i<adj[x].size();i++)\\n        {  \\n            string p=adj[x][i].first;\\n           \\n            if( vis.count(p)==0)\\n            {    \\n                find(p,y,vis,rs*adj[x][i].second);\\n            }\\n        }\\n         \\n        return;\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        if(equations.size()==0) return res;\\n        if(equations[0].size()==0) return res;\\n        \\n         \\n        \\n        for(int i=0;i<equations.size();i++)\\n        {   \\n            string x=equations[i][0],y=equations[i][1]; \\n            double val=values[i]; \\n            adj[x].push_back({y,val});   //store weight of path like x/y=2, x->y (2)\\n            adj[y].push_back({x,double(1)/val}); //store reverse path x/y=2 , y->x (1/2)\\n        }\\n       \\n         \\n        for(int i=0;i<queries.size();i++)  //traverse queries\\n        {   \\n             string x=queries[i][0],y=queries[i][1];\\n            if(adj.count(x)==0||adj.count(y)==0) \\n             {\\n                res.push_back(double(-1));continue; \\n                //check if variable is absent in equation then result will be -1.00\\n             }\\n              \\n             map <string,int> vis; //create visites map to check visited variables\\n            //call find function to solve query \\n             find(x,y,vis,double(1)*(1.0));\\n            //if we didn\\'t find val like for x/y=2 , p/q=3\\n            //we have to find x/p which is impossible so we will insert -1.00\\n             if(res.size()!=i+1) res.push_back(double(-1));\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638479,
                "title": "javascript-dfs-solution",
                "content": "```\\n/**\\n * @param {string[][]} equations\\n * @param {number[]} values\\n * @param {string[][]} queries\\n * @return {number[]}\\n */\\nvar calcEquation = function(equations, values, queries) {\\n\\n    let graph = buildGraph(equations, values);\\n    \\n    let result = [];\\n    \\n    const getPathWeight = (start, end, visited)  => {\\n        // exit condition: does the graph have the source vertex?\\n        if (!graph.has(start)) return -1;\\n\\n        // meet condition: target and source are directly connected\\n        if (graph.get(start).has(end)) return graph.get(start).get(end);\\n\\n        // DFS: visit all the neighbors\\n        visited.add(start);\\n\\n        // traverse through the neighbors\\n        for (let [key, val] of graph.get(start)) {\\n            if (!visited.has(key)) {\\n                let weight = getPathWeight(key, end, visited);\\n\\n                if(weight != -1) {\\n                    return val * weight;\\n                }\\n            }\\n        }\\n        // restore state\\n        visited.delete(start);\\n        return -1;\\n    }\\n\\n    for (let i = 0; i < queries.length; i++) {\\n        let visited = new Set();\\n        const [start, end] = queries[i]\\n        result[i] = getPathWeight(start, end, visited, graph);\\n    }\\n    return result;\\n};\\n\\n\\n\\n\\n\\nconst buildGraph = (eq, vals) => {\\n    let map = new Map();\\n    for (let i = 0; i < eq.length; i++) {\\n        let u = eq[i][0];\\n        let v = eq[i][1];\\n        if (!map.has(u)) {\\n            map.set(u, new Map());\\n        }\\n        map.get(u).set(v, vals[i])\\n        if (!map.has(v)) {\\n            map.set(v, new Map());\\n        }\\n        map.get(v).set(u, 1 / vals[i]);\\n    }\\n    return map;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[][]} equations\\n * @param {number[]} values\\n * @param {string[][]} queries\\n * @return {number[]}\\n */\\nvar calcEquation = function(equations, values, queries) {\\n\\n    let graph = buildGraph(equations, values);\\n    \\n    let result = [];\\n    \\n    const getPathWeight = (start, end, visited)  => {\\n        // exit condition: does the graph have the source vertex?\\n        if (!graph.has(start)) return -1;\\n\\n        // meet condition: target and source are directly connected\\n        if (graph.get(start).has(end)) return graph.get(start).get(end);\\n\\n        // DFS: visit all the neighbors\\n        visited.add(start);\\n\\n        // traverse through the neighbors\\n        for (let [key, val] of graph.get(start)) {\\n            if (!visited.has(key)) {\\n                let weight = getPathWeight(key, end, visited);\\n\\n                if(weight != -1) {\\n                    return val * weight;\\n                }\\n            }\\n        }\\n        // restore state\\n        visited.delete(start);\\n        return -1;\\n    }\\n\\n    for (let i = 0; i < queries.length; i++) {\\n        let visited = new Set();\\n        const [start, end] = queries[i]\\n        result[i] = getPathWeight(start, end, visited, graph);\\n    }\\n    return result;\\n};\\n\\n\\n\\n\\n\\nconst buildGraph = (eq, vals) => {\\n    let map = new Map();\\n    for (let i = 0; i < eq.length; i++) {\\n        let u = eq[i][0];\\n        let v = eq[i][1];\\n        if (!map.has(u)) {\\n            map.set(u, new Map());\\n        }\\n        map.get(u).set(v, vals[i])\\n        if (!map.has(v)) {\\n            map.set(v, new Map());\\n        }\\n        map.get(v).set(u, 1 / vals[i]);\\n    }\\n    return map;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 462137,
                "title": "c-4ms-dfs-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tdouble divid(string A, string B, set<string> visited, map<string,map<string,double>> m){\\n\\t\\t\\tif(A==B) return 1.0;\\n\\t\\t\\tvisited.insert(A);\\n\\t\\t\\tfor(auto x:m[A]){\\n\\t\\t\\t\\tstring s=x.first;\\n\\t\\t\\t\\tif(visited.count(s)) continue;\\n\\t\\t\\t\\tdouble d=divid(s,B,visited,m);\\n\\t\\t\\t\\tif(d>0) return d*m[A][s];\\n\\t\\t\\t}\\n\\t\\t\\treturn -1.0;\\n\\t\\t}\\n\\t\\tvector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n\\t\\t\\tmap<string,map<string,double>> m;\\n\\t\\t\\tvector<double> res;\\n\\t\\t\\tset<string> table;\\n\\t\\t\\tfor(int i=0;i<equations.size();i++){\\n\\t\\t\\t\\tm[equations[i][0]][equations[i][1]]=values[i];\\n\\t\\t\\t\\tm[equations[i][1]][equations[i][0]]=1.0/values[i];\\n\\t\\t\\t\\ttable.insert(equations[i][0]);\\n\\t\\t\\t\\ttable.insert(equations[i][1]);\\n\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto x:queries){\\n\\t\\t\\t\\tif(table.count(x[0])==0 || table.count(x[1])==0){\\n\\t\\t\\t\\t\\tres.push_back(-1.0);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstring A=x[0];\\n\\t\\t\\t\\tstring B=x[1];\\n\\t\\t\\t\\tset<string> visited;\\n\\t\\t\\t\\tres.push_back(divid(A,B,visited,m));\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tdouble divid(string A, string B, set<string> visited, map<string,map<string,double>> m){\\n\\t\\t\\tif(A==B) return 1.0;\\n\\t\\t\\tvisited.insert(A);\\n\\t\\t\\tfor(auto x:m[A]){\\n\\t\\t\\t\\tstring s=x.first;\\n\\t\\t\\t\\tif(visited.count(s)) continue;\\n\\t\\t\\t\\tdouble d=divid(s,B,visited,m);\\n\\t\\t\\t\\tif(d>0) return d*m[A][s];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 295332,
                "title": "bfs-solution",
                "content": "BFS  with  caching \\n```\\nclass Solution:\\n    def calcEquation(self, eq: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        graph  =collections.defaultdict(list)\\n        cache = dict()\\n        def build_graph(eq,vals):\\n            for i,edge in enumerate(eq):\\n                s,e = edge\\n                graph[s].append((e,values[i]))\\n                graph[e].append((s,1/values[i]))\\n        \\n        def query(s,e):\\n            q = collections.deque([(s,1.0)])\\n            visited = set()\\n            if s not in graph or e not in graph:\\n                cache[(s,e)] = -1\\n                cache[(e,s)] = -1\\n                return \\n            while q:\\n                node,value = q.popleft()\\n                if node == e:\\n                    cache[(s,node)] = value\\n                    cache[(node,s)] = 1 / value\\n                    return \\n                else:\\n                    for nb,prod in graph[node]:\\n                        if nb not in visited:\\n                            q.append((nb,value*prod))\\n                            visited.add(nb)\\n                            \\n            cache[(s,e)] = -1\\n            return                             \\n        res = []\\n        build_graph(eq,values)        \\n        for s,e in queries:\\n            if (s,e) not in cache:\\n                query(s,e)\\n            res.append(cache[(s,e)])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, eq: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        graph  =collections.defaultdict(list)\\n        cache = dict()\\n        def build_graph(eq,vals):\\n            for i,edge in enumerate(eq):\\n                s,e = edge\\n                graph[s].append((e,values[i]))\\n                graph[e].append((s,1/values[i]))\\n        \\n        def query(s,e):\\n            q = collections.deque([(s,1.0)])\\n            visited = set()\\n            if s not in graph or e not in graph:\\n                cache[(s,e)] = -1\\n                cache[(e,s)] = -1\\n                return \\n            while q:\\n                node,value = q.popleft()\\n                if node == e:\\n                    cache[(s,node)] = value\\n                    cache[(node,s)] = 1 / value\\n                    return \\n                else:\\n                    for nb,prod in graph[node]:\\n                        if nb not in visited:\\n                            q.append((nb,value*prod))\\n                            visited.add(nb)\\n                            \\n            cache[(s,e)] = -1\\n            return                             \\n        res = []\\n        build_graph(eq,values)        \\n        for s,e in queries:\\n            if (s,e) not in cache:\\n                query(s,e)\\n            res.append(cache[(s,e)])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290249,
                "title": "java-union-find",
                "content": "Find + Union:\\nConnect all nodes through the equation relation\\nCompress all relation to a common variable (a = 2b, a = 6c)\\n\\nGet:\\nCompare the relation by replacing the common variable.\\na = 2b, a = 6c\\nreplace a with 2b\\n2b = 6c -> b/c = 6/2\\n\\n```\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        UF uf = new UF();\\n        for(int i = 0; i < values.length; i++) {\\n            uf.union(equations.get(i).get(0), equations.get(i).get(1), values[i]);\\n        }\\n        double[] res = new double[queries.size()];\\n        for(int i = 0; i < queries.size(); i++) {\\n            res[i] = uf.get(queries.get(i).get(0), queries.get(i).get(1));\\n        }\\n        return res;\\n    }\\n}\\n\\nclass UF {\\n    //Stores relation between two variables\\n    HashMap<String, String> p;\\n    //Stores the value of the relation a/b = 2, a/c = 6\\n    HashMap<String, Double> r;\\n    UF() {\\n        p = new HashMap<>();\\n        r = new HashMap<>();\\n    }\\n    //Find and compress path to parent\\n    String find(String a) {\\n        if(!p.containsKey(a)) {\\n            p.put(a,a);\\n            r.put(a,1.0);\\n            return a;\\n        }\\n        double value = r.get(a);\\n        String parent = a;\\n        //Find parent\\n        while(p.get(parent) != parent) {\\n            parent = p.get(parent);\\n            value *= r.get(parent);\\n        }\\n        //Compress path and update relation value\\n        p.put(a,parent);\\n        r.put(a,value);\\n        return parent;\\n    }\\n    void union(String a, String b, double v) {\\n        String p1 = find(a);\\n        String p2 = find(b);\\n        if(p1 == p2) return;\\n        \\n        // a/b = 2 -> a = 2b\\n        // b/c = 3 -> b = 3c -> a/2 = 3c -> a = 6c\\n        double r1 = r.get(a);\\n        double r2 = r.get(b);\\n        p.put(p2,p1);\\n        // a/b = 2\\n        // a/c = 6\\n        r.put(p2, r1/r2*v);\\n    }\\n    double get(String a, String b) {\\n        if(!p.containsKey(a) || !p.containsKey(b)) {\\n            return -1.0;\\n        }\\n        // System.out.println(r.get(b) + \" \" + r.get(a));\\n        String p1 = find(a);\\n        String p2 = find(b);\\n\\t\\t//Not connected\\n        if(p1 != p2) return -1.0;\\n\\t\\t\\n        // p1 = a/a = 1\\n        // p2 = a/c = 6\\n        // p2/p1 = a/c = 6\\n        \\n        // p1 = a/b = 2\\n        // p2 = a/c = 6\\n        // p2/p1 = b/c = 6/2\\n        return r.get(b)/r.get(a);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        UF uf = new UF();\\n        for(int i = 0; i < values.length; i++) {\\n            uf.union(equations.get(i).get(0), equations.get(i).get(1), values[i]);\\n        }\\n        double[] res = new double[queries.size()];\\n        for(int i = 0; i < queries.size(); i++) {\\n            res[i] = uf.get(queries.get(i).get(0), queries.get(i).get(1));\\n        }\\n        return res;\\n    }\\n}\\n\\nclass UF {\\n    //Stores relation between two variables\\n    HashMap<String, String> p;\\n    //Stores the value of the relation a/b = 2, a/c = 6\\n    HashMap<String, Double> r;\\n    UF() {\\n        p = new HashMap<>();\\n        r = new HashMap<>();\\n    }\\n    //Find and compress path to parent\\n    String find(String a) {\\n        if(!p.containsKey(a)) {\\n            p.put(a,a);\\n            r.put(a,1.0);\\n            return a;\\n        }\\n        double value = r.get(a);\\n        String parent = a;\\n        //Find parent\\n        while(p.get(parent) != parent) {\\n            parent = p.get(parent);\\n            value *= r.get(parent);\\n        }\\n        //Compress path and update relation value\\n        p.put(a,parent);\\n        r.put(a,value);\\n        return parent;\\n    }\\n    void union(String a, String b, double v) {\\n        String p1 = find(a);\\n        String p2 = find(b);\\n        if(p1 == p2) return;\\n        \\n        // a/b = 2 -> a = 2b\\n        // b/c = 3 -> b = 3c -> a/2 = 3c -> a = 6c\\n        double r1 = r.get(a);\\n        double r2 = r.get(b);\\n        p.put(p2,p1);\\n        // a/b = 2\\n        // a/c = 6\\n        r.put(p2, r1/r2*v);\\n    }\\n    double get(String a, String b) {\\n        if(!p.containsKey(a) || !p.containsKey(b)) {\\n            return -1.0;\\n        }\\n        // System.out.println(r.get(b) + \" \" + r.get(a));\\n        String p1 = find(a);\\n        String p2 = find(b);\\n\\t\\t//Not connected\\n        if(p1 != p2) return -1.0;\\n\\t\\t\\n        // p1 = a/a = 1\\n        // p2 = a/c = 6\\n        // p2/p1 = a/c = 6\\n        \\n        // p1 = a/b = 2\\n        // p2 = a/c = 6\\n        // p2/p1 = b/c = 6/2\\n        return r.get(b)/r.get(a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 136188,
                "title": "logical-thinking-with-java-code-beats-97-40",
                "content": "**Logical Thinking**\\nThe answer of `query[i]` exists only if `query[i][0]` and `query[i][1]`are **connected** according to `equations[]`.\\nWe utilize the **graph** model to represent **connections**:\\nTake `A/B = k` for example, `A` and `B` are regarded as nodes. Since `k` is provided, there is an edge from `A` to `B` with the weight `k`, at the same time, there is an edge from `B` to `A` with the weight `1.0 / k`.\\nWe apply the **Depth First Search** in `calcEquationFrom()` to see `if query[i][0] and query[i][1] are connected`.\\n\\n**Clean Java Code**\\n```\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n\\n        Map<String, Map<String, Double>> graph = new HashMap<>();\\n        for (int i = 0; i < equations.length; i++) {\\n            String u = equations[i][0], v = equations[i][1];\\n            if (!graph.containsKey(u)) {\\n                graph.put(u, new HashMap<>());\\n            }\\n            if (!graph.containsKey(v)) {\\n                graph.put(v, new HashMap<>());\\n            }\\n            graph.get(u).put(v, values[i]);\\n            graph.get(v).put(u, 1.0 / values[i]);\\n        }\\n\\n        double[] result = new double[queries.length];\\n        int ri = 0;\\n        for (String[] query : queries) {\\n            String start = query[0], end = query[1];\\n            result[ri++] = calcEquationFrom(graph, start, end, new HashSet<>());\\n        }\\n        return result;\\n\\n    }\\n\\n    private double calcEquationFrom(Map<String, Map<String, Double>> graph, String start, String end, Set<String> visited) {\\n\\n        if (!graph.containsKey(start) || visited.contains(start)) {\\n            return -1.0;\\n        }\\n        if (graph.get(start).containsKey(end)) {\\n            return graph.get(start).get(end);\\n        }\\n        visited.add(start);\\n        for (String neighbour : graph.get(start).keySet()) {\\n            double val = calcEquationFrom(graph, neighbour, end, visited);\\n            if (val == -1.0) {\\n                continue;\\n            }\\n            return val * graph.get(start).get(neighbour);\\n        }\\n        return -1.0;\\n\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n\\n        Map<String, Map<String, Double>> graph = new HashMap<>();\\n        for (int i = 0; i < equations.length; i++) {\\n            String u = equations[i][0], v = equations[i][1];\\n            if (!graph.containsKey(u)) {\\n                graph.put(u, new HashMap<>());\\n            }\\n            if (!graph.containsKey(v)) {\\n                graph.put(v, new HashMap<>());\\n            }\\n            graph.get(u).put(v, values[i]);\\n            graph.get(v).put(u, 1.0 / values[i]);\\n        }\\n\\n        double[] result = new double[queries.length];\\n        int ri = 0;\\n        for (String[] query : queries) {\\n            String start = query[0], end = query[1];\\n            result[ri++] = calcEquationFrom(graph, start, end, new HashSet<>());\\n        }\\n        return result;\\n\\n    }\\n\\n    private double calcEquationFrom(Map<String, Map<String, Double>> graph, String start, String end, Set<String> visited) {\\n\\n        if (!graph.containsKey(start) || visited.contains(start)) {\\n            return -1.0;\\n        }\\n        if (graph.get(start).containsKey(end)) {\\n            return graph.get(start).get(end);\\n        }\\n        visited.add(start);\\n        for (String neighbour : graph.get(start).keySet()) {\\n            double val = calcEquationFrom(graph, neighbour, end, visited);\\n            if (val == -1.0) {\\n                continue;\\n            }\\n            return val * graph.get(start).get(neighbour);\\n        }\\n        return -1.0;\\n\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3543381,
                "title": "c-easy-understanding-dfs",
                "content": "### Approach\\n\\nIn this problem we need to find out the value of division of each pair of queries using the data given in equations.\\n\\nLike if we need to find out the value of a/c and we have value 2.0 for a/b and 3.0 b/c then value of a/c will be a/b*b/c=2.03.0 (6.0)\\n\\nFor this problem we first need to make a weighted directed graph using the respective weight (like if a/b=2.0 then add edge from a to b with weight 2.0 and from b to a with weight 3.0)\\n\\nAfter creating the graph we can use DFS to traverse the graph and calculate the value of the given query. We need to traverse the graph starting with the source node and traverse the graph until we reach the destination node. While traversing the graph, we need to multiply the weights of the edges to get the value of the fraction(discussed earlier). Here we need to keep track of the visited node to avoid visited again and again.\\n\\nIf we cannot reach out the destination then we need to store -1.0 as the answer.\\n\\nTime complexity: **O(M*N)** where M = (E+V) ( E= Edges, V= vertex & N = Number of queries)\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(string &source, string &destination, unordered_map<string,vector<pair<string,double>>>&graph, unordered_map<string,int>&vis, double &ans, double temp)\\n    {\\n        if(vis.count(source))return;//if node is present in the visited map then we need to return directly\\n        \\n        vis[source]++;//mark the source as visited \\n        if(source==destination)//// If source and dest node are equal then update the ans and return back\\n        {\\n            ans=temp;\\n            return;\\n        }\\n        \\n        for(auto it:graph[source])\\n        {\\n            dfs(it.first,destination,graph,vis,ans,temp*it.second);////update temp to temp multiply by the edge weight between node to adjNode as if a->b is 2.0 and b->c is 3.0 then a->c will be 2.0*3.0\\n        }\\n    }\\n    \\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        //create a graph first\\n        unordered_map<string,vector<pair<string,double>>>graph; //{source,{destination,edge weight}}\\n        \\n        for(int i=0; i<equations.size(); i++)\\n        {\\n            graph[equations[i][0]].push_back({equations[i][1],values[i]});\\n            graph[equations[i][1]].push_back({equations[i][0],1/values[i]});//here if a->b has weight 2.0 implies that b->a will have weight 1/2.0=0.5\\n        }\\n        \\n        vector<double>res(queries.size());\\n        unordered_map<string,int>vis;//to store the visited string in each dfs call\\n        \\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            string start=queries[i][0],end=queries[i][1];\\n            double ans=-1.0;//initialize ans as -1.0\\n            \\n            vis.clear();//clear the visted map for each dfs call\\n            if(graph.count(start))dfs(start,end,graph,vis,ans,1.0);//if node is present in the graph then only we have to call the dfs\\n            \\n            res[i]=ans;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**cout<<\"Please Upvote !\"<<endl;**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(string &source, string &destination, unordered_map<string,vector<pair<string,double>>>&graph, unordered_map<string,int>&vis, double &ans, double temp)\\n    {\\n        if(vis.count(source))return;//if node is present in the visited map then we need to return directly\\n        \\n        vis[source]++;//mark the source as visited \\n        if(source==destination)//// If source and dest node are equal then update the ans and return back\\n        {\\n            ans=temp;\\n            return;\\n        }\\n        \\n        for(auto it:graph[source])\\n        {\\n            dfs(it.first,destination,graph,vis,ans,temp*it.second);////update temp to temp multiply by the edge weight between node to adjNode as if a->b is 2.0 and b->c is 3.0 then a->c will be 2.0*3.0\\n        }\\n    }\\n    \\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        //create a graph first\\n        unordered_map<string,vector<pair<string,double>>>graph; //{source,{destination,edge weight}}\\n        \\n        for(int i=0; i<equations.size(); i++)\\n        {\\n            graph[equations[i][0]].push_back({equations[i][1],values[i]});\\n            graph[equations[i][1]].push_back({equations[i][0],1/values[i]});//here if a->b has weight 2.0 implies that b->a will have weight 1/2.0=0.5\\n        }\\n        \\n        vector<double>res(queries.size());\\n        unordered_map<string,int>vis;//to store the visited string in each dfs call\\n        \\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            string start=queries[i][0],end=queries[i][1];\\n            double ans=-1.0;//initialize ans as -1.0\\n            \\n            vis.clear();//clear the visted map for each dfs call\\n            if(graph.count(start))dfs(start,end,graph,vis,ans,1.0);//if node is present in the graph then only we have to call the dfs\\n            \\n            res[i]=ans;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992994,
                "title": "c-solution-single-source-shortest-path",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> res;\\n    unordered_map<string,list<pair<string,double>>> h;\\n    \\n    void addedge(string u, string v,double x)\\n    {\\n        h[u].push_back(make_pair(v,x));\\n        h[v].push_back(make_pair(u,1/x));\\n    }\\n    \\n    double sssp(string src,string dest)\\n    {\\n        if(h.find(src)==h.end() || h.find(dest)==h.end())\\n        {\\n            return -1.0;\\n        }\\n        queue<string>q;\\n        q.push(src);\\n        unordered_map<string,bool>visited;\\n        unordered_map<string,double>dist;\\n        visited[src] = true;\\n        dist[src] = 1;\\n        while(!q.empty())\\n        {\\n            string node = q.front();\\n            q.pop();\\n            for(auto children : h[node])\\n            {\\n                if(visited[children.first]==false)\\n                {\\n                    q.push(children.first);\\n                    visited[children.first] = true;\\n                    dist[children.first] = dist[node]*(children.second);\\n                }\\n            }\\n        }\\n        double d = dist[dest];\\n        if(d==0)\\n        {\\n            d = -1;\\n        }\\n        return d;\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n     \\n        for(int i=0;i<values.size();i++)\\n        {\\n            addedge(equations[i][0],equations[i][1],values[i]);\\n        }\\n        int n = queries.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string src = queries[i][0];\\n            string dest = queries[i][1];\\n            double p = sssp(src,dest);\\n            res.push_back(p);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> res;\\n    unordered_map<string,list<pair<string,double>>> h;\\n    \\n    void addedge(string u, string v,double x)\\n    {\\n        h[u].push_back(make_pair(v,x));\\n        h[v].push_back(make_pair(u,1/x));\\n    }\\n    \\n    double sssp(string src,string dest)\\n    {\\n        if(h.find(src)==h.end() || h.find(dest)==h.end())\\n        {\\n            return -1.0;\\n        }\\n        queue<string>q;\\n        q.push(src);\\n        unordered_map<string,bool>visited;\\n        unordered_map<string,double>dist;\\n        visited[src] = true;\\n        dist[src] = 1;\\n        while(!q.empty())\\n        {\\n            string node = q.front();\\n            q.pop();\\n            for(auto children : h[node])\\n            {\\n                if(visited[children.first]==false)\\n                {\\n                    q.push(children.first);\\n                    visited[children.first] = true;\\n                    dist[children.first] = dist[node]*(children.second);\\n                }\\n            }\\n        }\\n        double d = dist[dest];\\n        if(d==0)\\n        {\\n            d = -1;\\n        }\\n        return d;\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n     \\n        for(int i=0;i<values.size();i++)\\n        {\\n            addedge(equations[i][0],equations[i][1],values[i]);\\n        }\\n        int n = queries.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string src = queries[i][0];\\n            string dest = queries[i][1];\\n            double p = sssp(src,dest);\\n            res.push_back(p);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992944,
                "title": "c-100-faster-dfs-short-and-concise",
                "content": "```\\nclass Solution {\\n    unordered_map<string, unordered_map<string, double>> edges; //  {start: {end1: weight, end2. weight } }\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        //equations[i]: (Ai, Bi)\\n        //values[i]: Ai / Bi\\n        //queries[i]: (Ci, Di)\\n        vector<double> ans; ans.reserve(queries.size());\\n        int m = equations.size(); //\\n        for(int i = 0; i < m; i++){ //build up edges and weights\\n            edges[equations[i][0]][equations[i][1]] = values[i]; \\n            edges[equations[i][1]][equations[i][0]] = 1 / values[i]; \\n        }\\n        unordered_set<string> visited;\\n        for(int i = 0; i < queries.size(); i++){\\n            if(edges.count(queries[i][0]) == 0 or edges.count(queries[i][1]) == 0){\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            visited.insert(queries[i][0]); \\n            ans.push_back(dfs(queries[i][0], queries[i][1], visited));\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n    \\n    //assumption: pos not visited\\n\\t//pos is where we are now. \\n    double dfs(const string &pos, const string &target, unordered_set<string> &visited){\\n        if(pos == target)\\n            return 1;\\n        \\n        visited.insert(pos);\\n        \\n        //check all edges\\n        for(const auto &[nxt, w]: edges[pos])\\n        {\\n            if(not visited.count(nxt))\\n            {\\n                double res = dfs(nxt, target, visited);\\n                if(res != -1.0)\\n                    return res * w;\\n            }\\n        }\\n        return -1.0;\\n    }\\n};\\n```\\nUpvote if you like :D",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string, unordered_map<string, double>> edges; //  {start: {end1: weight, end2. weight } }\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        //equations[i]: (Ai, Bi)\\n        //values[i]: Ai / Bi\\n        //queries[i]: (Ci, Di)\\n        vector<double> ans; ans.reserve(queries.size());\\n        int m = equations.size(); //\\n        for(int i = 0; i < m; i++){ //build up edges and weights\\n            edges[equations[i][0]][equations[i][1]] = values[i]; \\n            edges[equations[i][1]][equations[i][0]] = 1 / values[i]; \\n        }\\n        unordered_set<string> visited;\\n        for(int i = 0; i < queries.size(); i++){\\n            if(edges.count(queries[i][0]) == 0 or edges.count(queries[i][1]) == 0){\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            visited.insert(queries[i][0]); \\n            ans.push_back(dfs(queries[i][0], queries[i][1], visited));\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n    \\n    //assumption: pos not visited\\n\\t//pos is where we are now. \\n    double dfs(const string &pos, const string &target, unordered_set<string> &visited){\\n        if(pos == target)\\n            return 1;\\n        \\n        visited.insert(pos);\\n        \\n        //check all edges\\n        for(const auto &[nxt, w]: edges[pos])\\n        {\\n            if(not visited.count(nxt))\\n            {\\n                double res = dfs(nxt, target, visited);\\n                if(res != -1.0)\\n                    return res * w;\\n            }\\n        }\\n        return -1.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253338,
                "title": "0ms-simple-dfs-beats-100-c-fastest",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, vector<pair<string, double>>> mp;\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        for(int i=0;i<equations.size();i++){\\n            mp[equations[i][0]].push_back({equations[i][1], values[i]});\\n            mp[equations[i][1]].push_back({equations[i][0], 1.0 / values[i]});\\n        }\\n        vector<double> ans;\\n        for(auto q: queries){\\n            string p1 = q[0];\\n            string p2 = q[1];\\n            if(mp.find(p1) == mp.end() && mp.find(p2) == mp.end()){\\n                ans.push_back(-1.00);\\n                continue;\\n            }\\n            unordered_map<string, bool> vis;\\n            ans.push_back(dfs(p1, p2, vis));\\n        }\\n        return ans;\\n    }\\n    \\n    double dfs(string x, string y, unordered_map<string, bool> &vis){\\n        vis[x] = true;\\n        if(x == y){\\n            return 1.00;\\n        }\\n        for(int i=0;i<mp[x].size();i++){\\n            if(!vis[mp[x][i].first]){\\n                double ans = mp[x][i].second * dfs(mp[x][i].first, y, vis);\\n                if(ans > 0.0){\\n                    return ans;\\n                }\\n            }\\n        }\\n        return -1.00;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, vector<pair<string, double>>> mp;\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        for(int i=0;i<equations.size();i++){\\n            mp[equations[i][0]].push_back({equations[i][1], values[i]});\\n            mp[equations[i][1]].push_back({equations[i][0], 1.0 / values[i]});\\n        }\\n        vector<double> ans;\\n        for(auto q: queries){\\n            string p1 = q[0];\\n            string p2 = q[1];\\n            if(mp.find(p1) == mp.end() && mp.find(p2) == mp.end()){\\n                ans.push_back(-1.00);\\n                continue;\\n            }\\n            unordered_map<string, bool> vis;\\n            ans.push_back(dfs(p1, p2, vis));\\n        }\\n        return ans;\\n    }\\n    \\n    double dfs(string x, string y, unordered_map<string, bool> &vis){\\n        vis[x] = true;\\n        if(x == y){\\n            return 1.00;\\n        }\\n        for(int i=0;i<mp[x].size();i++){\\n            if(!vis[mp[x][i].first]){\\n                double ans = mp[x][i].second * dfs(mp[x][i].first, y, vis);\\n                if(ans > 0.0){\\n                    return ans;\\n                }\\n            }\\n        }\\n        return -1.00;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867488,
                "title": "ruby-graph-dfs",
                "content": "```\\n# @param {String[][]} equations\\n# @param {Float[]} values\\n# @param {String[][]} queries\\n# @return {Float[]}\\ndef calc_equation(equations, values, queries)\\n  @graph = Hash.new{|h, k| h[k] = {}}\\n  \\n  equations.zip(values).each do |equation, value|\\n    variable_1, variable_2 = equation\\n    \\n    @graph[variable_1][variable_2] = value.to_f\\n    @graph[variable_2][variable_1] = 1.0/value\\n    @graph[variable_1][variable_1] = 1.0\\n    @graph[variable_2][variable_2] = 1.0\\n  end\\n\\n  result = []\\n  \\n  queries.each do |variable_1, variable_2|\\n    if @graph[variable_1].empty? || @graph[variable_2].empty?\\n      result << -1.0\\n    else\\n      result << dfs(variable_1, variable_2, 1.0, Set.new)\\n    end\\n  end\\n  \\n  result\\nend\\n    \\ndef dfs(variable_1, variable_2, result, checked_variables_set)\\n  return result if variable_1 == variable_2\\n  \\n  checked_variables_set << variable_1\\n  \\n  @graph[variable_1].keys.each do |connected_variable|\\n    unless checked_variables_set.include?(connected_variable)\\n      value = dfs(\\n        connected_variable,\\n        variable_2,\\n        result * @graph[variable_1][connected_variable],\\n        checked_variables_set.dup\\n      )\\n      return value if value != -1.0\\n    end\\n  end\\n  \\n  return -1.0\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n# @param {String[][]} equations\\n# @param {Float[]} values\\n# @param {String[][]} queries\\n# @return {Float[]}\\ndef calc_equation(equations, values, queries)\\n  @graph = Hash.new{|h, k| h[k] = {}}\\n  \\n  equations.zip(values).each do |equation, value|\\n    variable_1, variable_2 = equation\\n    \\n    @graph[variable_1][variable_2] = value.to_f\\n    @graph[variable_2][variable_1] = 1.0/value\\n    @graph[variable_1][variable_1] = 1.0\\n    @graph[variable_2][variable_2] = 1.0\\n  end\\n\\n  result = []\\n  \\n  queries.each do |variable_1, variable_2|\\n    if @graph[variable_1].empty? || @graph[variable_2].empty?\\n      result << -1.0\\n    else\\n      result << dfs(variable_1, variable_2, 1.0, Set.new)\\n    end\\n  end\\n  \\n  result\\nend\\n    \\ndef dfs(variable_1, variable_2, result, checked_variables_set)\\n  return result if variable_1 == variable_2\\n  \\n  checked_variables_set << variable_1\\n  \\n  @graph[variable_1].keys.each do |connected_variable|\\n    unless checked_variables_set.include?(connected_variable)\\n      value = dfs(\\n        connected_variable,\\n        variable_2,\\n        result * @graph[variable_1][connected_variable],\\n        checked_variables_set.dup\\n      )\\n      return value if value != -1.0\\n    end\\n  end\\n  \\n  return -1.0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 854032,
                "title": "clean-js-graph-solution",
                "content": "```\\nconst calcEquation = (equations, values, queries) => {\\n    let graph = new Map()\\n\\n    // get direct edges\\n    equations.forEach( ([ t, b ], i ) => {\\n        if ( ! graph.get( t ) ) graph.set( t, new Map() )\\n        if ( ! graph.get( b ) ) graph.set( b, new Map() )\\n\\n        graph.get( b ).set( b, 1 )\\n        graph.get( t ).set( t, 1 )\\n        graph.get( t ).set( b, values[ i ] )\\n        graph.get( b ).set( t, 1 / values[ i ] )\\n    })\\n\\n    // build indirect edges via floyd warshall\\n    graph.forEach( (_,k) => {\\n        graph.get(k).forEach( (_,i) => {\\n            graph.get(k).forEach( (_,j) => {\\n                graph.get(i).set(j, graph.get(i).get(k) * graph.get(k).get(j))\\n            })\\n        })\\n    })\\n\\n    return queries.map( ([ num, denom ]) => graph.get( num ) ? graph.get( num ).get( denom ) || -1 : -1)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\nconst calcEquation = (equations, values, queries) => {\\n    let graph = new Map()\\n\\n    // get direct edges\\n    equations.forEach( ([ t, b ], i ) => {\\n        if ( ! graph.get( t ) ) graph.set( t, new Map() )\\n        if ( ! graph.get( b ) ) graph.set( b, new Map() )\\n\\n        graph.get( b ).set( b, 1 )\\n        graph.get( t ).set( t, 1 )\\n        graph.get( t ).set( b, values[ i ] )\\n        graph.get( b ).set( t, 1 / values[ i ] )\\n    })\\n\\n    // build indirect edges via floyd warshall\\n    graph.forEach( (_,k) => {\\n        graph.get(k).forEach( (_,i) => {\\n            graph.get(k).forEach( (_,j) => {\\n                graph.get(i).set(j, graph.get(i).get(k) * graph.get(k).get(j))\\n            })\\n        })\\n    })\\n\\n    return queries.map( ([ num, denom ]) => graph.get( num ) ? graph.get( num ).get( denom ) || -1 : -1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817809,
                "title": "java-union-find-with-some-explanation",
                "content": "**Union find**\\n\\n```\\n\\nclass Solution {\\n    Map<String, String> root;\\n    Map<String, Double> dist;\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        // key = root, value = parent  root/parent = values\\n        root = new HashMap<>();\\n        // key = root value = dist; \\n        // example:\\n        //    a/c = a/b * b/c = dist.get(a) * dist.get(b); \\n        dist = new HashMap<>();\\n        // construct the hashmap\\n        for(int i=0; i<equations.size(); i++){\\n            List<String> equation = equations.get(i);\\n            // find parent of according factor\\n            // for example: (a, b) -> (2.0)    x,y are the parent of a,b accordingly\\n            //   we know a/x = dist(a)    b/y = dist(b)  a/b =values[i] to get x/y = (b/y) * (a/b) / (a/x) = dist(b)*values[i] / dist(a)\\n            String s = find(equation.get(0));\\n            String p = find(equation.get(1));\\n            root.put(s, p);\\n            dist.put(s, dist.get(equation.get(1)) * values[i]/ dist.get(equation.get(0)));\\n        }\\n        \\n        double[] res = new double[queries.size()];\\n        \\n        //after constructing all root and dist graph\\n        for(int j=0; j<queries.size(); j++){\\n            List<String> query = queries.get(j);\\n            if(!root.containsKey(query.get(0)) || !root.containsKey(query.get(1))){\\n                res[j] = -1.0;\\n            }else{\\n                String qs = find(query.get(0));\\n                String qp = find(query.get(1));\\n                if(!qs.equals(qp)) res[j] = -1;\\n                else{\\n                    // we have same parent p for all characters at this time. so we know qs/p = dist(qs) and qp/p = dist(qp). Hence, qs/qp = (qs/p)/(qp/p) = dist(qs) / dist(qp);\\n                    res[j] = dist.get(query.get(0)) / dist.get(query.get(1));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n    public String find(String s){\\n        if(!root.containsKey(s)){\\n            root.put(s, s);\\n            dist.put(s, 1.0);\\n            return s;\\n        }\\n        if(root.get(s).equals(s)) return s;\\n        String cur_p = root.get(s);\\n        String p = find(cur_p);\\n        root.put(s, p);\\n        dist.put(s, dist.get(s) * dist.get(cur_p));\\n        // p is the final parent;\\n        return p;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\n\\nclass Solution {\\n    Map<String, String> root;\\n    Map<String, Double> dist;\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        // key = root, value = parent  root/parent = values\\n        root = new HashMap<>();\\n        // key = root value = dist; \\n        // example:\\n        //    a/c = a/b * b/c = dist.get(a) * dist.get(b); \\n        dist = new HashMap<>();\\n        // construct the hashmap\\n        for(int i=0; i<equations.size(); i++){\\n            List<String> equation = equations.get(i);\\n            // find parent of according factor\\n            // for example: (a, b) -> (2.0)    x,y are the parent of a,b accordingly\\n            //   we know a/x = dist(a)    b/y = dist(b)  a/b =values[i] to get x/y = (b/y) * (a/b) / (a/x) = dist(b)*values[i] / dist(a)\\n            String s = find(equation.get(0));\\n            String p = find(equation.get(1));\\n            root.put(s, p);\\n            dist.put(s, dist.get(equation.get(1)) * values[i]/ dist.get(equation.get(0)));\\n        }\\n        \\n        double[] res = new double[queries.size()];\\n        \\n        //after constructing all root and dist graph\\n        for(int j=0; j<queries.size(); j++){\\n            List<String> query = queries.get(j);\\n            if(!root.containsKey(query.get(0)) || !root.containsKey(query.get(1))){\\n                res[j] = -1.0;\\n            }else{\\n                String qs = find(query.get(0));\\n                String qp = find(query.get(1));\\n                if(!qs.equals(qp)) res[j] = -1;\\n                else{\\n                    // we have same parent p for all characters at this time. so we know qs/p = dist(qs) and qp/p = dist(qp). Hence, qs/qp = (qs/p)/(qp/p) = dist(qs) / dist(qp);\\n                    res[j] = dist.get(query.get(0)) / dist.get(query.get(1));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n    public String find(String s){\\n        if(!root.containsKey(s)){\\n            root.put(s, s);\\n            dist.put(s, 1.0);\\n            return s;\\n        }\\n        if(root.get(s).equals(s)) return s;\\n        String cur_p = root.get(s);\\n        String p = find(cur_p);\\n        root.put(s, p);\\n        dist.put(s, dist.get(s) * dist.get(cur_p));\\n        // p is the final parent;\\n        return p;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700017,
                "title": "python-very-clean-and-simple-dfs-solution",
                "content": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        ## RC ##\\n        ## APPROACH : GRAPH / DFS ##\\n        ## LOGIC ##\\n        #   1. store all edges (bidirectional) with values.\\n        #   2. start from query[0] and go along edges till you reach query[1] (keep track of ans )\\n        #   3. make sure to prevent cycles using visited\\n        #   4. EDGE CASE : query [x2,x4] ideal path should be x2 -> x3 -> x4, but as we are checking for all items in graph[curr] our path will be x2->x1->x2->x3->x4 but as we keeping track of visited, we can\\'t bactrack, so remve from visited incase solution not found in that path\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        graph = collections.defaultdict(list)\\n        for i, equation in enumerate(equations):\\n            x,y = equation\\n            graph[x].append((y,values[i]))\\n            graph[y].append((x, 1/values[i]))           \\n        \\n        def dfs(curr, end, ans):\\n            if curr in visited: return False\\n            if(curr == end and end in graph):\\n                results.append(ans)\\n                return True\\n            visited.add(curr)\\n            for x, y in graph[curr]:\\n                if(dfs(x, end, ans * y)): return True\\n            visited.remove(curr)\\n            return False\\n            \\n        results = []\\n        for q in queries:\\n            visited = set()\\n            if(not dfs(q[0], q[1], 1)): results.append(-1)    # q[0] start, q[1] end\\n        return results\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        ## RC ##\\n        ## APPROACH : GRAPH / DFS ##\\n        ## LOGIC ##\\n        #   1. store all edges (bidirectional) with values.\\n        #   2. start from query[0] and go along edges till you reach query[1] (keep track of ans )\\n        #   3. make sure to prevent cycles using visited\\n        #   4. EDGE CASE : query [x2,x4] ideal path should be x2 -> x3 -> x4, but as we are checking for all items in graph[curr] our path will be x2->x1->x2->x3->x4 but as we keeping track of visited, we can\\'t bactrack, so remve from visited incase solution not found in that path\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        graph = collections.defaultdict(list)\\n        for i, equation in enumerate(equations):\\n            x,y = equation\\n            graph[x].append((y,values[i]))\\n            graph[y].append((x, 1/values[i]))           \\n        \\n        def dfs(curr, end, ans):\\n            if curr in visited: return False\\n            if(curr == end and end in graph):\\n                results.append(ans)\\n                return True\\n            visited.add(curr)\\n            for x, y in graph[curr]:\\n                if(dfs(x, end, ans * y)): return True\\n            visited.remove(curr)\\n            return False\\n            \\n        results = []\\n        for q in queries:\\n            visited = set()\\n            if(not dfs(q[0], q[1], 1)): results.append(-1)    # q[0] start, q[1] end\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251767,
                "title": "python-bfs-dfs-both-beat-100",
                "content": "```python\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        # DFS\\n        graph = collections.defaultdict(dict)\\n        for ((a, b), v) in zip(equations, values):\\n            graph[a][b], graph[b][a], graph[a][a], graph[b][b] = v, 1 / v, 1, 1\\n        def dfs(a, b, seen):\\n            if a not in graph or b not in graph: return -1\\n            if b in graph[a]: return graph[a][b]\\n            for i in graph[a]:\\n                if i not in seen:\\n                    seen.add(i)\\n                    tep = dfs(i, b, seen)\\n                    if tep == -1: continue\\n                    else: return graph[a][i] * tep\\n            return -1\\n        res = []\\n        for a, b in queries:\\n            res.append(dfs(a, b, set()))\\n        return res\\n        \\n        # BFS\\n        graph = collections.defaultdict(list)\\n        for (a, b), v in zip(equations, values):\\n            graph[a].append((b, v))\\n            graph[b].append((a, 1.0 / v))\\n        def helper(q):\\n            (a, b) = q\\n            seen = set()\\n            if a not in graph or b not in graph: return -1.0\\n            dq = collections.deque([(a, 1)])\\n            while dq:\\n                pre, product = dq.popleft()\\n                if pre == b: return product\\n                seen.add(pre)\\n                for nei, val in graph[pre]:\\n                    if nei not in seen:\\n                        dq.append((nei, product * val))\\n            return -1.0\\n        return list(map(helper, queries))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        # DFS\\n        graph = collections.defaultdict(dict)\\n        for ((a, b), v) in zip(equations, values):\\n            graph[a][b], graph[b][a], graph[a][a], graph[b][b] = v, 1 / v, 1, 1\\n        def dfs(a, b, seen):\\n            if a not in graph or b not in graph: return -1\\n            if b in graph[a]: return graph[a][b]\\n            for i in graph[a]:\\n                if i not in seen:\\n                    seen.add(i)\\n                    tep = dfs(i, b, seen)\\n                    if tep == -1: continue\\n                    else: return graph[a][i] * tep\\n            return -1\\n        res = []\\n        for a, b in queries:\\n            res.append(dfs(a, b, set()))\\n        return res\\n        \\n        # BFS\\n        graph = collections.defaultdict(list)\\n        for (a, b), v in zip(equations, values):\\n            graph[a].append((b, v))\\n            graph[b].append((a, 1.0 / v))\\n        def helper(q):\\n            (a, b) = q\\n            seen = set()\\n            if a not in graph or b not in graph: return -1.0\\n            dq = collections.deque([(a, 1)])\\n            while dq:\\n                pre, product = dq.popleft()\\n                if pre == b: return product\\n                seen.add(pre)\\n                for nei, val in graph[pre]:\\n                    if nei not in seen:\\n                        dq.append((nei, product * val))\\n            return -1.0\\n        return list(map(helper, queries))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180722,
                "title": "100-clean-python",
                "content": "* First, construction a graph, for each euqation pair `<a, b>`,  construct two edges: a -> b and b -> a, associate the value/ratio for each edge so we know how to compute one value given another.\\n\\t* for example, for pair `\\'a\\', \\'b\\', 2`, we build two edges `\\'a\\'->\\'b\\' = 1/2`, `\\'b\\' -> \\'a\\' = 2`\\n* For each component of the graph, select one node as root, set the value of root as 1, and compute the rest values\\n\\t* for example, in the above `\\'a\\', \\'b\\'`, if we set `\\'a\\'` as root and assign `a=1`, then `b = 1/2 * a = 0.5`.\\n* For each query, find if two values are in the same component(same root), if true, return the ratio of their value.\\n\\n```python\\ndef calcEquation(self, equations, values, queries):\\n    # 1, Graph Construction, N = (next, ratio)\\n    N = defaultdict(list)\\n    for (i, j), v in zip(equations, values):\\n        N[i] += (j, 1 / v),; N[j] += (i, v),\\n\\n    # 2, Pick a root for each component, set root value to 1\\n    #    and compute the rest values\\n    P, V = {}, {}\\n    remain = set(N.keys())\\n    while remain:\\n        root = remain.pop()\\n        check = deque([(root, 1)])\\n        while check:\\n            node, val = check.popleft()\\n            P[node], V[node] = root, val\\n            check += [(n, val * r) for n, r in N[node] if n in remain]\\n            remain -= {n for n, _ in N[node]}\\n\\n    # 3, Query\\n    res = []\\n    for q1, q2 in queries:\\n        try:    res += [[-1, V[q1] / V[q2]][P[q1] == P[q2]]]\\n        except: res += [-1]\\n    return res\\n```",
                "solutionTags": [],
                "code": "```python\\ndef calcEquation(self, equations, values, queries):\\n    # 1, Graph Construction, N = (next, ratio)\\n    N = defaultdict(list)\\n    for (i, j), v in zip(equations, values):\\n        N[i] += (j, 1 / v),; N[j] += (i, v),\\n\\n    # 2, Pick a root for each component, set root value to 1\\n    #    and compute the rest values\\n    P, V = {}, {}\\n    remain = set(N.keys())\\n    while remain:\\n        root = remain.pop()\\n        check = deque([(root, 1)])\\n        while check:\\n            node, val = check.popleft()\\n            P[node], V[node] = root, val\\n            check += [(n, val * r) for n, r in N[node] if n in remain]\\n            remain -= {n for n, _ in N[node]}\\n\\n    # 3, Query\\n    res = []\\n    for q1, q2 in queries:\\n        try:    res += [[-1, V[q1] / V[q2]][P[q1] == P[q2]]]\\n        except: res += [-1]\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 163652,
                "title": "java-union-find-solution",
                "content": "\\'\\'\\'\\n\\n    class pair{\\n        String s;\\n        double factor;\\n        public pair(String s, double f){\\n            this.s = s;\\n            factor = f;\\n        }\\n    }\\n    \\n    Map<String, pair> map;\\n    \\n    public pair find(String s){\\n        if (map.get(s).s.equals(s)){\\n            return map.get(s);\\n        }\\n        \\n        pair next = find(map.get(s).s);\\n        \\n        map.put(s, new pair(next.s, map.get(s).factor * next.factor));\\n        return map.get(s);\\n    }\\n    \\n    public void connect(String s1, String s2, double factor){\\n        pair root_a = find(s1);\\n        pair root_b = find(s2);\\n        \\n        if (!root_a.s.equals(root_b.s)){\\n            map.put(root_a.s, new pair(root_b.s, factor * root_b.factor / root_a.factor));\\n        }\\n    }\\n    \\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        map = new HashMap<String, pair>();\\n        for (int i = 0; i < equations.length; i++){\\n            if (!map.containsKey(equations[i][0])){\\n                map.put(equations[i][0], new pair(equations[i][0], 1.0));\\n            }\\n            if (!map.containsKey(equations[i][1])){\\n                map.put(equations[i][1], new pair(equations[i][1], 1.0));\\n            }\\n            connect(equations[i][0], equations[i][1], values[i]);\\n        }\\n        \\n        double[] res = new double[queries.length];\\n        for (int i = 0; i < res.length; i++){\\n            String[] temp = queries[i];\\n            if (!map.containsKey(temp[0]) || !map.containsKey(temp[1])) res[i] = -1.0;\\n            else{\\n                pair root_a = find(temp[0]);\\n                pair root_b = find(temp[1]);\\n                if (!root_a.s.equals(root_b.s)) res[i] = -1.0;\\n                else{\\n                    res[i] = root_a.factor / root_b.factor;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    class pair{\\n        String s;\\n        double factor;\\n        public pair(String s, double f){\\n            this.s = s;\\n            factor = f;\\n        }\\n    }\\n    \\n    Map<String, pair> map;\\n    \\n    public pair find(String s){\\n        if (map.get(s).s.equals(s)){\\n            return map.get(s);\\n        }\\n        \\n        pair next = find(map.get(s).s);\\n        \\n        map.put(s, new pair(next.s, map.get(s).factor * next.factor));\\n        return map.get(s);\\n    }\\n    \\n    public void connect(String s1, String s2, double factor){\\n        pair root_a = find(s1);\\n        pair root_b = find(s2);\\n        \\n        if (!root_a.s.equals(root_b.s)){\\n            map.put(root_a.s, new pair(root_b.s, factor * root_b.factor / root_a.factor));\\n        }\\n    }\\n    \\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        map = new HashMap<String, pair>();\\n        for (int i = 0; i < equations.length; i++){\\n            if (!map.containsKey(equations[i][0])){\\n                map.put(equations[i][0], new pair(equations[i][0], 1.0));\\n            }\\n            if (!map.containsKey(equations[i][1])){\\n                map.put(equations[i][1], new pair(equations[i][1], 1.0));\\n            }\\n            connect(equations[i][0], equations[i][1], values[i]);\\n        }\\n        \\n        double[] res = new double[queries.length];\\n        for (int i = 0; i < res.length; i++){\\n            String[] temp = queries[i];\\n            if (!map.containsKey(temp[0]) || !map.containsKey(temp[1])) res[i] = -1.0;\\n            else{\\n                pair root_a = find(temp[0]);\\n                pair root_b = find(temp[1]);\\n                if (!root_a.s.equals(root_b.s)) res[i] = -1.0;\\n                else{\\n                    res[i] = root_a.factor / root_b.factor;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 122029,
                "title": "c-floyd-warshall-algorithm",
                "content": "This solution is inspired by [StefanPochmann\\'s](https://leetcode.com/stefanpochmann/) [solution](https://leetcode.com/problems/evaluate-division/discuss/88175/9-lines-%22FloydWarshall%22-in-Python) and from [GeeksForGeeks](https://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/) explanation of the Floyd Warshall Algorithm for finding the all pair shortest path.\\n\\nThe idea is to find a path from every node to every other node in the graph.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries)\\n    {\\n        unordered_map<string, unordered_map<string, double>> graph;\\n        \\n        for (int i = 0; i < equations.size(); ++i)\\n        {\\n            graph[equations[i].first].insert({equations[i].first, 1.0});\\n            graph[equations[i].first].insert({equations[i].second, values[i]});\\n            graph[equations[i].second].insert({equations[i].second, 1.0});\\n            graph[equations[i].second].insert({equations[i].first, 1.0/values[i]});\\n        }\\n        \\n        for (auto &k : graph)\\n        {\\n            for (auto &i : graph)\\n            {\\n                for (auto &j : graph)\\n                {\\n                    if (graph[i.first].count(j.first) == 0)\\n                    {\\n                        if (graph[i.first].count(k.first) && graph[k.first].count(j.first))\\n                        {\\n                            graph[i.first].insert({j.first, graph[i.first][k.first]*graph[k.first][j.first]});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<double> calculations;\\n        for (auto &q : queries)\\n        {\\n            if (graph.count(q.first) && graph[q.first].count(q.second))\\n            {\\n                calculations.push_back(graph[q.first][q.second]);\\n            }\\n            else\\n            {\\n                calculations.push_back(-1);\\n            }\\n        }\\n        \\n        return calculations;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries)\\n    {\\n        unordered_map<string, unordered_map<string, double>> graph;\\n        \\n        for (int i = 0; i < equations.size(); ++i)\\n        {\\n            graph[equations[i].first].insert({equations[i].first, 1.0});\\n            graph[equations[i].first].insert({equations[i].second, values[i]});\\n            graph[equations[i].second].insert({equations[i].second, 1.0});\\n            graph[equations[i].second].insert({equations[i].first, 1.0/values[i]});\\n        }\\n        \\n        for (auto &k : graph)\\n        {\\n            for (auto &i : graph)\\n            {\\n                for (auto &j : graph)\\n                {\\n                    if (graph[i.first].count(j.first) == 0)\\n                    {\\n                        if (graph[i.first].count(k.first) && graph[k.first].count(j.first))\\n                        {\\n                            graph[i.first].insert({j.first, graph[i.first][k.first]*graph[k.first][j.first]});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<double> calculations;\\n        for (auto &q : queries)\\n        {\\n            if (graph.count(q.first) && graph[q.first].count(q.second))\\n            {\\n                calculations.push_back(graph[q.first][q.second]);\\n            }\\n            else\\n            {\\n                calculations.push_back(-1);\\n            }\\n        }\\n        \\n        return calculations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88173,
                "title": "share-my-javascript-solution",
                "content": "The solution is long, but that's what I have in mind when I see the question :) Basically the idea is search for a path in the graph and keep track of the product.\\n```\\n/**\\n * @param {string[][]} equations\\n * @param {number[]} values\\n * @param {string[][]} queries\\n * @return {number[]}\\n */\\nconst calcEquation = (equations, values, queries) => {\\n  const result = [];\\n\\n  // Step 1. Build the undirected graph with adjacency list\\n  const adjList = buildGraph(equations, values);\\n\\n  // Step 2. For each query, try to find a path in the graph\\n  // that can link the nodes in the query\\n  for (let i = 0; i < queries.length; i++) {\\n    const [from, to] = queries[i];\\n    const value = dfs(adjList, from, to, 1, new Set());\\n\\n    // If value is null, that means there's no such path\\n    result.push(value ? value : -1.0);\\n\\n    if (value) {\\n      // Update the graph to avoid duplicate computation\\n      adjList.get(from).set(to, value);\\n      adjList.get(to).set(from, 1 / value);\\n    }\\n  }\\n\\n  return result;\\n};\\n\\n/**\\n * @param {Map<string, Map<string, number>>} adjList\\n * @param {string} node\\n * @param {string} to\\n * @param {number} product\\n * @param {Set} visited\\n */\\nconst dfs = (adjList, node, to, product, visited) => {\\n  if (!adjList.has(node)) {\\n      return null; // Dead end\\n  }\\n\\n  visited.add(node); // Mark the current node as visited\\n\\n  const neighbors = [...adjList.get(node).keys()];\\n\\n  for (let i = 0; i < neighbors.length; i++) {\\n    const v = neighbors[i];\\n    const current = product * adjList.get(node).get(v);\\n\\n    if (v === to) {\\n      // Found the path, return the product\\n      return current;\\n    }\\n\\n    if (!visited.has(v)) {\\n      // Continue to search for the path\\n      const value = dfs(adjList, v, to, current, visited);\\n\\n      if (value) {\\n        return value;\\n      }\\n    }\\n  }\\n\\n  return null;\\n};\\n\\nconst buildGraph = (equations, values) => {\\n  const adjList = new Map();\\n\\n  for (let i = 0; i < equations.length; i++) {\\n    const [from, to] = equations[i];\\n    const value = values[i];\\n\\n    if (!adjList.has(from)) {\\n      adjList.set(from, new Map());\\n    }\\n\\n    if (!adjList.has(to)) {\\n      adjList.set(to, new Map());\\n    }\\n\\n    // Build the undirected graph\\n    adjList.get(from).set(to, value);\\n    adjList.get(to).set(from, 1 / value);\\n  }\\n    \\n  return adjList;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[][]} equations\\n * @param {number[]} values\\n * @param {string[][]} queries\\n * @return {number[]}\\n */\\nconst calcEquation = (equations, values, queries) => {\\n  const result = [];\\n\\n  // Step 1. Build the undirected graph with adjacency list\\n  const adjList = buildGraph(equations, values);\\n\\n  // Step 2. For each query, try to find a path in the graph\\n  // that can link the nodes in the query\\n  for (let i = 0; i < queries.length; i++) {\\n    const [from, to] = queries[i];\\n    const value = dfs(adjList, from, to, 1, new Set());\\n\\n    // If value is null, that means there's no such path\\n    result.push(value ? value : -1.0);\\n\\n    if (value) {\\n      // Update the graph to avoid duplicate computation\\n      adjList.get(from).set(to, value);\\n      adjList.get(to).set(from, 1 / value);\\n    }\\n  }\\n\\n  return result;\\n};\\n\\n/**\\n * @param {Map<string, Map<string, number>>} adjList\\n * @param {string} node\\n * @param {string} to\\n * @param {number} product\\n * @param {Set} visited\\n */\\nconst dfs = (adjList, node, to, product, visited) => {\\n  if (!adjList.has(node)) {\\n      return null; // Dead end\\n  }\\n\\n  visited.add(node); // Mark the current node as visited\\n\\n  const neighbors = [...adjList.get(node).keys()];\\n\\n  for (let i = 0; i < neighbors.length; i++) {\\n    const v = neighbors[i];\\n    const current = product * adjList.get(node).get(v);\\n\\n    if (v === to) {\\n      // Found the path, return the product\\n      return current;\\n    }\\n\\n    if (!visited.has(v)) {\\n      // Continue to search for the path\\n      const value = dfs(adjList, v, to, current, visited);\\n\\n      if (value) {\\n        return value;\\n      }\\n    }\\n  }\\n\\n  return null;\\n};\\n\\nconst buildGraph = (equations, values) => {\\n  const adjList = new Map();\\n\\n  for (let i = 0; i < equations.length; i++) {\\n    const [from, to] = equations[i];\\n    const value = values[i];\\n\\n    if (!adjList.has(from)) {\\n      adjList.set(from, new Map());\\n    }\\n\\n    if (!adjList.has(to)) {\\n      adjList.set(to, new Map());\\n    }\\n\\n    // Build the undirected graph\\n    adjList.get(from).set(to, value);\\n    adjList.get(to).set(from, 1 / value);\\n  }\\n    \\n  return adjList;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88278,
                "title": "java-union-find-beats-96",
                "content": "The idea is having an union-find data structure (implemented using hash map) to record all variables, using another hash map to record the relevant value for each variable. Every time we process an equation means equals to make a \"union\" operation, and we need to update relevant value for all the variables in the sets. We can check if two if variables have relationship and calculate value both in O(1) time.\\n\\n```\\npublic class Solution {\\n    private HashMap<String, String> father = new HashMap<>();\\n    private HashMap<String, Double> valMap = new HashMap<>();\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        double[] result = new double[queries.length];\\n        if (values.length == 0 || result.length == 0) {\\n            return result;\\n        }\\n        \\n        for (int i = 0; i < values.length; i++) {\\n            String eq1 = equations[i][0];\\n            String eq2 = equations[i][1];\\n            if (!valMap.containsKey(eq1) && !valMap.containsKey(eq2)) {\\n                father.put(eq1, eq1);\\n                father.put(eq2, eq2);\\n                valMap.put(eq1, values[i]);\\n                valMap.put(eq2, 1.0);\\n            } else if (!valMap.containsKey(eq1)) {\\n                father.put(eq1, eq1);\\n                valMap.put(eq1, valMap.get(eq2) * values[i]);\\n            } else if (!valMap.containsKey(eq2)) {\\n                father.put(eq2, eq2);\\n                valMap.put(eq2, valMap.get(eq1) / values[i]);\\n            } else {\\n                String fa = find(eq1);\\n                for (String key: father.keySet()) {\\n                    if (find(key).equals(fa)) {\\n                        valMap.put(key, valMap.get(key) * values[i] * valMap.get(eq2));\\n                    }\\n                }\\n            }\\n            union(eq1, eq2);\\n        }\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            if (!valMap.containsKey(queries[i][0]) || !valMap.containsKey(queries[i][1]) || !find(queries[i][0]).equals(find(queries[i][1]))) {\\n                result[i] = -1.0;\\n            } else {\\n                result[i] = valMap.get(queries[i][0]) / valMap.get(queries[i][1]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void union(String a, String b) {\\n        String fa = find(a);\\n        String fb = find(b);\\n        if (!fa.equals(fb)) {\\n            father.put(fb, fa);\\n        }\\n    }\\n    \\n    private String find(String a) {\\n        String parent = father.get(a);\\n        while (!parent.equals(father.get(parent))) {\\n            parent = father.get(parent);\\n        }\\n        \\n        String tmp = \"\";\\n        String fa = father.get(a);\\n        while (!fa.equals(father.get(fa))) {\\n            tmp = father.get(fa);\\n            father.put(fa, parent);\\n            fa = tmp;\\n        }\\n        \\n        return parent;\\n    }\\n}  \\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private HashMap<String, String> father = new HashMap<>();\\n    private HashMap<String, Double> valMap = new HashMap<>();\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n        double[] result = new double[queries.length];\\n        if (values.length == 0 || result.length == 0) {\\n            return result;\\n        }\\n        \\n        for (int i = 0; i < values.length; i++) {\\n            String eq1 = equations[i][0];\\n            String eq2 = equations[i][1];\\n            if (!valMap.containsKey(eq1) && !valMap.containsKey(eq2)) {\\n                father.put(eq1, eq1);\\n                father.put(eq2, eq2);\\n                valMap.put(eq1, values[i]);\\n                valMap.put(eq2, 1.0);\\n            } else if (!valMap.containsKey(eq1)) {\\n                father.put(eq1, eq1);\\n                valMap.put(eq1, valMap.get(eq2) * values[i]);\\n            } else if (!valMap.containsKey(eq2)) {\\n                father.put(eq2, eq2);\\n                valMap.put(eq2, valMap.get(eq1) / values[i]);\\n            } else {\\n                String fa = find(eq1);\\n                for (String key: father.keySet()) {\\n                    if (find(key).equals(fa)) {\\n                        valMap.put(key, valMap.get(key) * values[i] * valMap.get(eq2));\\n                    }\\n                }\\n            }\\n            union(eq1, eq2);\\n        }\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            if (!valMap.containsKey(queries[i][0]) || !valMap.containsKey(queries[i][1]) || !find(queries[i][0]).equals(find(queries[i][1]))) {\\n                result[i] = -1.0;\\n            } else {\\n                result[i] = valMap.get(queries[i][0]) / valMap.get(queries[i][1]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void union(String a, String b) {\\n        String fa = find(a);\\n        String fb = find(b);\\n        if (!fa.equals(fb)) {\\n            father.put(fb, fa);\\n        }\\n    }\\n    \\n    private String find(String a) {\\n        String parent = father.get(a);\\n        while (!parent.equals(father.get(parent))) {\\n            parent = father.get(parent);\\n        }\\n        \\n        String tmp = \"\";\\n        String fa = father.get(a);\\n        while (!fa.equals(father.get(fa))) {\\n            tmp = father.get(fa);\\n            father.put(fa, parent);\\n            fa = tmp;\\n        }\\n        \\n        return parent;\\n    }\\n}  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544769,
                "title": "dfs-approach-python-golang-c",
                "content": "# Code\\n``` Go []\\nfunc calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\\n    graph := make(map[string]map[string]float64)\\n\\tseen := make(map[string]bool)\\n\\n\\tfor i := 0; i < len(equations); i++ {\\n\\t\\ta, b := equations[i][0], equations[i][1]\\n\\n\\t\\tif _, ok := graph[a]; !ok {\\n\\t\\t\\tgraph[a] = make(map[string]float64)\\n\\t\\t}\\n\\t\\tgraph[a][b] = values[i]\\n\\n\\t\\tif _, ok := graph[b]; !ok {\\n\\t\\t\\tgraph[b] = make(map[string]float64)\\n\\t\\t}\\n\\t\\tgraph[b][a] = 1 / values[i]\\n\\t}\\n\\n\\tvar divide func(string, string) float64\\n\\tdivide = func(a, b string) float64 {\\n\\t\\tif a == b {\\n\\t\\t\\treturn 1.00000\\n\\t\\t}\\n\\n\\t\\tseen[a] = true\\n\\t\\tfor key, value := range graph[a] {\\n\\t\\t\\tif seen[key] {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tres := divide(key, b)\\n\\t\\t\\tif res > 0 {\\n\\t\\t\\t\\treturn res * value\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1.000\\n\\t}\\n\\n    var isExists func(string, string) bool\\n    isExists = func(a, b string) bool {\\n        if _, ok := graph[a]; !ok {\\n            return false\\n        }\\n\\n        if _, ok := graph[b]; !ok {\\n            return false\\n        }\\n\\n        return true\\n    }\\n\\n\\tans := make([]float64, 0)\\n\\tfor _, q := range queries {\\n\\t\\ta, b := q[0], q[1]\\n\\n\\t\\tif !isExists(a, b) {\\n\\t\\t\\tans = append(ans, -1.000)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tseen = make(map[string]bool)\\n\\t\\tans = append(ans, divide(a, b))\\n\\t}\\n\\n\\treturn ans\\n}\\n```\\n``` Python []\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        graph = defaultdict(dict)\\n        seen = set()\\n\\n        for i in range(len(equations)):\\n            a, b = equations[i][0], equations[i][1]\\n            graph[a][b] = values[i]\\n            graph[b][a] = 1 / values[i]\\n\\n\\n        def divide(a, b):\\n            if a == b:\\n                return 1.00000\\n\\n            seen.add(a)\\n            for key, value in graph[a].items():\\n                if key in seen:\\n                    continue\\n\\n                res = divide(key, b)\\n                if res > 0:\\n                    return float(res * value)\\n            return -1.000\\n\\n        ans = []\\n        for q in queries:\\n            a, b = q[0], q[1]\\n\\n            if a not in graph or b not in graph:\\n                ans.append(-1.000)\\n                continue\\n\\n            seen = set()\\n            ans.append(divide(a, b))\\n\\n        return ans\\n```\\n```C++ []\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    unordered_map<string , unordered_map<string , double>> graph;\\n    unordered_set<string> seen;\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double>ans;\\n        \\n        for(int i=0;i<equations.size();i++){\\n            const string& A = equations[i][0];\\n            const string& B = equations[i][1];\\n            \\n            graph[A][B] = values[i];\\n            graph[B][A] = 1/ values[i];\\n        }\\n        \\n        for(const auto&q : queries){\\n            const string& C = q[0];\\n            const string& D = q[1];\\n            \\n            if(!graph.count(C) || !graph.count(D)) {ans.pb(-1) ; continue;}\\n            ans.pb(divide(C , D ));\\n            seen.clear();\\n        }\\n        \\n        return ans;\\n    }\\n    \\nprivate:\\n    double divide(const string& A ,const string& C){\\n        if(A==C) return 1;\\n        seen.insert(A);\\n        \\n        for(const auto& i:graph[A]){\\n            string B = i.first;\\n            double value = i.second;\\n            if(seen.count(B)) continue;\\n            const double res = divide(B , C);\\n            if(res > 0) return res * value;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Go",
                    "Depth-First Search"
                ],
                "code": "``` Go []\\nfunc calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\\n    graph := make(map[string]map[string]float64)\\n\\tseen := make(map[string]bool)\\n\\n\\tfor i := 0; i < len(equations); i++ {\\n\\t\\ta, b := equations[i][0], equations[i][1]\\n\\n\\t\\tif _, ok := graph[a]; !ok {\\n\\t\\t\\tgraph[a] = make(map[string]float64)\\n\\t\\t}\\n\\t\\tgraph[a][b] = values[i]\\n\\n\\t\\tif _, ok := graph[b]; !ok {\\n\\t\\t\\tgraph[b] = make(map[string]float64)\\n\\t\\t}\\n\\t\\tgraph[b][a] = 1 / values[i]\\n\\t}\\n\\n\\tvar divide func(string, string) float64\\n\\tdivide = func(a, b string) float64 {\\n\\t\\tif a == b {\\n\\t\\t\\treturn 1.00000\\n\\t\\t}\\n\\n\\t\\tseen[a] = true\\n\\t\\tfor key, value := range graph[a] {\\n\\t\\t\\tif seen[key] {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tres := divide(key, b)\\n\\t\\t\\tif res > 0 {\\n\\t\\t\\t\\treturn res * value\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1.000\\n\\t}\\n\\n    var isExists func(string, string) bool\\n    isExists = func(a, b string) bool {\\n        if _, ok := graph[a]; !ok {\\n            return false\\n        }\\n\\n        if _, ok := graph[b]; !ok {\\n            return false\\n        }\\n\\n        return true\\n    }\\n\\n\\tans := make([]float64, 0)\\n\\tfor _, q := range queries {\\n\\t\\ta, b := q[0], q[1]\\n\\n\\t\\tif !isExists(a, b) {\\n\\t\\t\\tans = append(ans, -1.000)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tseen = make(map[string]bool)\\n\\t\\tans = append(ans, divide(a, b))\\n\\t}\\n\\n\\treturn ans\\n}\\n```\n``` Python []\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        graph = defaultdict(dict)\\n        seen = set()\\n\\n        for i in range(len(equations)):\\n            a, b = equations[i][0], equations[i][1]\\n            graph[a][b] = values[i]\\n            graph[b][a] = 1 / values[i]\\n\\n\\n        def divide(a, b):\\n            if a == b:\\n                return 1.00000\\n\\n            seen.add(a)\\n            for key, value in graph[a].items():\\n                if key in seen:\\n                    continue\\n\\n                res = divide(key, b)\\n                if res > 0:\\n                    return float(res * value)\\n            return -1.000\\n\\n        ans = []\\n        for q in queries:\\n            a, b = q[0], q[1]\\n\\n            if a not in graph or b not in graph:\\n                ans.append(-1.000)\\n                continue\\n\\n            seen = set()\\n            ans.append(divide(a, b))\\n\\n        return ans\\n```\n```C++ []\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    unordered_map<string , unordered_map<string , double>> graph;\\n    unordered_set<string> seen;\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double>ans;\\n        \\n        for(int i=0;i<equations.size();i++){\\n            const string& A = equations[i][0];\\n            const string& B = equations[i][1];\\n            \\n            graph[A][B] = values[i];\\n            graph[B][A] = 1/ values[i];\\n        }\\n        \\n        for(const auto&q : queries){\\n            const string& C = q[0];\\n            const string& D = q[1];\\n            \\n            if(!graph.count(C) || !graph.count(D)) {ans.pb(-1) ; continue;}\\n            ans.pb(divide(C , D ));\\n            seen.clear();\\n        }\\n        \\n        return ans;\\n    }\\n    \\nprivate:\\n    double divide(const string& A ,const string& C){\\n        if(A==C) return 1;\\n        seen.insert(A);\\n        \\n        for(const auto& i:graph[A]){\\n            string B = i.first;\\n            double value = i.second;\\n            if(seen.count(B)) continue;\\n            const double res = divide(B , C);\\n            if(res > 0) return res * value;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544322,
                "title": "java-easy-solution-0ms",
                "content": "```\\nclass Solution {\\n    Map<String, String> parents = new HashMap<>();\\n    Map<String, Double> vals = new HashMap<>();\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        double[] res = new double[queries.size()];\\n        for(int i = 0; i < equations.size(); i++){\\n            String x = equations.get(i).get(0), y = equations.get(i).get(1);\\n            union(x, y, values[i]);\\n        }\\n        for(int i = 0; i < queries.size(); i++){\\n            String x = queries.get(i).get(0), y = queries.get(i).get(1);\\n            res[i] = (parents.containsKey(x) && parents.containsKey(y) && find(x) == find(y) ? vals.get(x) / vals.get(y) : -1.0);\\n        }\\n        return res;\\n    }\\n    \\n    public void add(String x){\\n        if(parents.containsKey(x)){\\n            return;\\n        }\\n        parents.put(x,x);\\n        vals.put(x, 1.0);\\n        // System.out.println(vals.get(x));\\n    }\\n    \\n    public String find(String x){\\n        String p = parents.getOrDefault(x, x);\\n        if(x != p){\\n            String pp = find(p);\\n            vals.put(x, vals.get(x) * vals.get(p));\\n            parents.put(x, pp);\\n        }\\n        return parents.getOrDefault(x,x);\\n    }\\n    \\n    public void union(String x, String y, double v){\\n        add(x);\\n        add(y);\\n        String vx = find(x), vy = find(y);\\n        parents.put(vx, vy);\\n        vals.put(vx, v * vals.get(y) / vals.get(x));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, String> parents = new HashMap<>();\\n    Map<String, Double> vals = new HashMap<>();\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        double[] res = new double[queries.size()];\\n        for(int i = 0; i < equations.size(); i++){\\n            String x = equations.get(i).get(0), y = equations.get(i).get(1);\\n            union(x, y, values[i]);\\n        }\\n        for(int i = 0; i < queries.size(); i++){\\n            String x = queries.get(i).get(0), y = queries.get(i).get(1);\\n            res[i] = (parents.containsKey(x) && parents.containsKey(y) && find(x) == find(y) ? vals.get(x) / vals.get(y) : -1.0);\\n        }\\n        return res;\\n    }\\n    \\n    public void add(String x){\\n        if(parents.containsKey(x)){\\n            return;\\n        }\\n        parents.put(x,x);\\n        vals.put(x, 1.0);\\n        // System.out.println(vals.get(x));\\n    }\\n    \\n    public String find(String x){\\n        String p = parents.getOrDefault(x, x);\\n        if(x != p){\\n            String pp = find(p);\\n            vals.put(x, vals.get(x) * vals.get(p));\\n            parents.put(x, pp);\\n        }\\n        return parents.getOrDefault(x,x);\\n    }\\n    \\n    public void union(String x, String y, double v){\\n        add(x);\\n        add(y);\\n        String vx = find(x), vy = find(y);\\n        parents.put(vx, vy);\\n        vals.put(vx, v * vals.get(y) / vals.get(x));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543903,
                "title": "using-maths-hashmaps-and-dfs-video-solution-also-available-c-java-python-code-availabale",
                "content": "Try for at least 25 mins then only your analytical skills will improve, if you are not able to solve the problem then you can see a few hints, then also you could not able to solve then try to understand the solution from the code, still not able to understand then you can watch video Tutorial.\\n\\nVideo Solution is also Availabale\\n\\nhttps://youtu.be/gka4jb3rjFU\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem we should think about Maths, dfs and to optimize we can think about Hashmaps.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ne is a vector of vector of strings, representing the given equations in the form of [a, b], where a and b are variables.\\nv is a vector of doubles, representing the values of the equations.\\nq is a vector of vector of strings, representing the queries to evaluate.\\nThe function starts by creating a map m to map each variable to a unique integer value. It also initializes a counter c to keep track of the unique integer values assigned to variables.\\n\\nNext, the function iterates through each equation in e. For each equation [a, b], it checks if the variables a and b are already present in the map m. If not, it assigns a unique integer value to them and increments c. It then creates edges in the adjacency list adj to represent the equation and its reciprocal between the variables a and b.\\n\\nAfter processing all the equations, the function initializes an empty vector ans to store the results of the queries.\\n\\nThe function then iterates through each query in q. For each query [a, b], it retrieves the corresponding integer values from the map m. If either a or b is not present in the map, it means that the variable is unknown, so it adds -1 to the ans vector.\\n\\nIf both variables a and b are present in the map, the function initializes a variable c to 1.0 and a vector vis to keep track of visited vertices. It then calls the path function to find a path from vertex a to vertex b in the graph represented by adj. The path function uses a depth-first search (DFS) approach to traverse the graph and update the c value based on the edge weights encountered.\\n\\nIf a path is found from a to b, the path function updates the c value accordingly. If no path is found, the c value remains unchanged. After the path function returns, the calcEquation function checks if a path was found and adds the c value to the ans vector if a path exists. Otherwise, it adds -1 to the ans vector.\\n\\n# Complexity\\n\\nThe time complexity of this solution depends on the number of equations and queries. Let\\'s denote the number of equations as E and the number of queries as Q.\\n\\n1. Building the graph: O(E)\\n   - Iterating through the equations: O(E)\\n   - Updating the map `m`: O(1) (amortized)\\n   - Creating adjacency list edges: O(1) (amortized)\\n   \\n2. Evaluating the queries: O(Q)\\n   - Iterating through the queries: O(Q)\\n   - Retrieving values from the map `m`: O(1)\\n   - Calling the `path` function: O(V + E) in the worst case, where V is the number of vertices in the graph and E is the number of edges. This is due to the depth-first search (DFS) traversal in the `path` function.\\n   \\n### ***Therefore, the overall time complexity of this solution is O(E + Q * (V + E)).***\\n\\n***The space complexity of this solution is O(V + E)***, where V is the number of vertices and E is the number of edges in the graph. This is due to the adjacency list representation of the graph and the additional data structures used for mapping variables and visited vertices.\\n\\nNote that the upper bounds of V and E are constant (50) based on the problem constraints, so the space complexity can be considered constant as well.\\n\\n```C++ []\\nclass Solution {\\npublic:\\n\\n    bool path(int a,int b,int prev,vector<pair<int,double>>adj[],double &c,vector<bool>&vis)\\n    {   \\n        //cout<<a<<\" \"<<b<<endl;\\n        if(a==b)\\n            return true;\\n        vis[a]=1;\\n        bool ans=false;\\n        for(auto i:adj[a])\\n        {\\n            if(vis[i.first]==1)\\n                continue;\\n            ans=ans||path(i.first,b,a,adj,c,vis);\\n            if(ans)\\n            {\\n                c=c*i.second;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& e, vector<double>& v, vector<vector<string>>& q) {\\n        map<string,int>m;\\n        int c=1;\\n        vector<pair<int,double>>adj[50];\\n        for(int i=0;i<e.size();i++)\\n        {\\n            string a=e[i][0],b=e[i][1];\\n            if(m.find(a)==m.end())\\n                m[a]=c++;\\n            if(m.find(b)==m.end())\\n                m[b]=c++;\\n            double x=v[i];\\n            double y=1/v[i];\\n            if(a==b)\\n                continue;\\n            adj[m[a]].push_back({m[b],x});\\n            adj[m[b]].push_back({m[a],y});\\n        }\\n        vector<double>ans;\\n        for(int i=0;i<q.size();i++)\\n        {   \\n            //cout<<endl;\\n            int a=m[q[i][0]],b=m[q[i][1]];\\n            if(a==0 || b==0)\\n            {\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            double c=1.0;\\n            vector<bool>vis(c+1,0);\\n            bool x=path(a,b,-1,adj,c,vis);\\n            if(x)\\n                ans.push_back(c);\\n            else\\n                ans.push_back(-1);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n```JAVA []\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\nclass Solution {\\n    private boolean path(int a, int b, int prev, List<Pair<Integer, Double>>[] adj, double[] c, boolean[] vis) {\\n        if (a == b)\\n            return true;\\n        vis[a] = true;\\n        boolean ans = false;\\n        for (Pair<Integer, Double> i : adj[a]) {\\n            if (vis[i.first])\\n                continue;\\n            ans = ans || path(i.first, b, a, adj, c, vis);\\n            if (ans) {\\n                c[0] = c[0] * i.second;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public double[] calcEquation(List<List<String>> e, double[] v, List<List<String>> q) {\\n        Map<String, Integer> m = new HashMap<>();\\n        int c = 1;\\n        List<Pair<Integer, Double>>[] adj = new List[50];\\n        for (int i = 0; i < e.size(); i++) {\\n            String a = e.get(i).get(0);\\n            String b = e.get(i).get(1);\\n            if (!m.containsKey(a))\\n                m.put(a, c++);\\n            if (!m.containsKey(b))\\n                m.put(b, c++);\\n            double x = v[i];\\n            double y = 1 / v[i];\\n            if (a.equals(b))\\n                continue;\\n            if (adj[m.get(a)] == null)\\n                adj[m.get(a)] = new ArrayList<>();\\n            if (adj[m.get(b)] == null)\\n                adj[m.get(b)] = new ArrayList<>();\\n            adj[m.get(a)].add(new Pair<>(m.get(b), x));\\n            adj[m.get(b)].add(new Pair<>(m.get(a), y));\\n        }\\n        double[] ans = new double[q.size()];\\n        for (int i = 0; i < q.size(); i++) {\\n            int a = m.getOrDefault(q.get(i).get(0), 0);\\n            int b = m.getOrDefault(q.get(i).get(1), 0);\\n            if (a == 0 || b == 0) {\\n                ans[i] = -1;\\n                continue;\\n            }\\n            double[] c = new double[] { 1.0 };\\n            boolean[] vis = new boolean[c + 1];\\n            boolean x = path(a, b, -1, adj, c, vis);\\n            if (x)\\n                ans[i] = c[0];\\n            else\\n                ans[i] = -1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n```python []\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def dfs(self, a, b, prev, adj, c, vis):\\n        if a == b:\\n            return True\\n        vis[a] = True\\n        ans = False\\n        for i in adj[a]:\\n            if vis[i[0]]:\\n                continue\\n            ans = ans or self.dfs(i[0], b, a, adj, c, vis)\\n            if ans:\\n                c[0] *= i[1]\\n                return ans\\n        return ans\\n\\n    def calcEquation(self, e, v, q):\\n        m = defaultdict(int)\\n        c = 1\\n        adj = [[] for _ in range(50)]\\n        for i in range(len(e)):\\n            a = e[i][0]\\n            b = e[i][1]\\n            if not m[a]:\\n                m[a] = c\\n                c += 1\\n            if not m[b]:\\n                m[b] = c\\n                c += 1\\n            x = v[i]\\n            y = 1 / v[i]\\n            if a == b:\\n                continue\\n            adj[m[a]].append((m[b], x))\\n            adj[m[b]].append((m[a], y))\\n        ans = []\\n        for i in range(len(q)):\\n            a = m.get(q[i][0], 0)\\n            b = m.get(q[i][1], 0)\\n            if a == 0 or b == 0:\\n                ans.append(-1)\\n                continue\\n            c = [1.0]\\n            vis = [False] * (c + 1)\\n            x = self.dfs(a, b, -1, adj, c, vis)\\n            if x:\\n                ans.append(c[0])\\n            else:\\n                ans.append(-1)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Depth-First Search",
                    "Graph",
                    "Ordered Map"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\n    bool path(int a,int b,int prev,vector<pair<int,double>>adj[],double &c,vector<bool>&vis)\\n    {   \\n        //cout<<a<<\" \"<<b<<endl;\\n        if(a==b)\\n            return true;\\n        vis[a]=1;\\n        bool ans=false;\\n        for(auto i:adj[a])\\n        {\\n            if(vis[i.first]==1)\\n                continue;\\n            ans=ans||path(i.first,b,a,adj,c,vis);\\n            if(ans)\\n            {\\n                c=c*i.second;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& e, vector<double>& v, vector<vector<string>>& q) {\\n        map<string,int>m;\\n        int c=1;\\n        vector<pair<int,double>>adj[50];\\n        for(int i=0;i<e.size();i++)\\n        {\\n            string a=e[i][0],b=e[i][1];\\n            if(m.find(a)==m.end())\\n                m[a]=c++;\\n            if(m.find(b)==m.end())\\n                m[b]=c++;\\n            double x=v[i];\\n            double y=1/v[i];\\n            if(a==b)\\n                continue;\\n            adj[m[a]].push_back({m[b],x});\\n            adj[m[b]].push_back({m[a],y});\\n        }\\n        vector<double>ans;\\n        for(int i=0;i<q.size();i++)\\n        {   \\n            //cout<<endl;\\n            int a=m[q[i][0]],b=m[q[i][1]];\\n            if(a==0 || b==0)\\n            {\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            double c=1.0;\\n            vector<bool>vis(c+1,0);\\n            bool x=path(a,b,-1,adj,c,vis);\\n            if(x)\\n                ans.push_back(c);\\n            else\\n                ans.push_back(-1);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```JAVA []\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\nclass Solution {\\n    private boolean path(int a, int b, int prev, List<Pair<Integer, Double>>[] adj, double[] c, boolean[] vis) {\\n        if (a == b)\\n            return true;\\n        vis[a] = true;\\n        boolean ans = false;\\n        for (Pair<Integer, Double> i : adj[a]) {\\n            if (vis[i.first])\\n                continue;\\n            ans = ans || path(i.first, b, a, adj, c, vis);\\n            if (ans) {\\n                c[0] = c[0] * i.second;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public double[] calcEquation(List<List<String>> e, double[] v, List<List<String>> q) {\\n        Map<String, Integer> m = new HashMap<>();\\n        int c = 1;\\n        List<Pair<Integer, Double>>[] adj = new List[50];\\n        for (int i = 0; i < e.size(); i++) {\\n            String a = e.get(i).get(0);\\n            String b = e.get(i).get(1);\\n            if (!m.containsKey(a))\\n                m.put(a, c++);\\n            if (!m.containsKey(b))\\n                m.put(b, c++);\\n            double x = v[i];\\n            double y = 1 / v[i];\\n            if (a.equals(b))\\n                continue;\\n            if (adj[m.get(a)] == null)\\n                adj[m.get(a)] = new ArrayList<>();\\n            if (adj[m.get(b)] == null)\\n                adj[m.get(b)] = new ArrayList<>();\\n            adj[m.get(a)].add(new Pair<>(m.get(b), x));\\n            adj[m.get(b)].add(new Pair<>(m.get(a), y));\\n        }\\n        double[] ans = new double[q.size()];\\n        for (int i = 0; i < q.size(); i++) {\\n            int a = m.getOrDefault(q.get(i).get(0), 0);\\n            int b = m.getOrDefault(q.get(i).get(1), 0);\\n            if (a == 0 || b == 0) {\\n                ans[i] = -1;\\n                continue;\\n            }\\n            double[] c = new double[] { 1.0 };\\n            boolean[] vis = new boolean[c + 1];\\n            boolean x = path(a, b, -1, adj, c, vis);\\n            if (x)\\n                ans[i] = c[0];\\n            else\\n                ans[i] = -1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```python []\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def dfs(self, a, b, prev, adj, c, vis):\\n        if a == b:\\n            return True\\n        vis[a] = True\\n        ans = False\\n        for i in adj[a]:\\n            if vis[i[0]]:\\n                continue\\n            ans = ans or self.dfs(i[0], b, a, adj, c, vis)\\n            if ans:\\n                c[0] *= i[1]\\n                return ans\\n        return ans\\n\\n    def calcEquation(self, e, v, q):\\n        m = defaultdict(int)\\n        c = 1\\n        adj = [[] for _ in range(50)]\\n        for i in range(len(e)):\\n            a = e[i][0]\\n            b = e[i][1]\\n            if not m[a]:\\n                m[a] = c\\n                c += 1\\n            if not m[b]:\\n                m[b] = c\\n                c += 1\\n            x = v[i]\\n            y = 1 / v[i]\\n            if a == b:\\n                continue\\n            adj[m[a]].append((m[b], x))\\n            adj[m[b]].append((m[a], y))\\n        ans = []\\n        for i in range(len(q)):\\n            a = m.get(q[i][0], 0)\\n            b = m.get(q[i][1], 0)\\n            if a == 0 or b == 0:\\n                ans.append(-1)\\n                continue\\n            c = [1.0]\\n            vis = [False] * (c + 1)\\n            x = self.dfs(a, b, -1, adj, c, vis)\\n            if x:\\n                ans.append(c[0])\\n            else:\\n                ans.append(-1)\\n        return ans\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3543754,
                "title": "java-using-dfs-building-directed-weighted-graph",
                "content": "# Code\\n```\\nclass Solution {\\n    public class Node {\\n        String dest;\\n        double val;\\n        public Node(String d, double v){\\n            dest = d;\\n            val = v;\\n        }\\n    }\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        // Creating graph, Format of graph is Key is String and values is destination and value or weight\\n        Map<String, List<Node>> graph = buildGraph(equations, values);\\n        // To Store answer\\n        double[] ans = new double[queries.size()];\\n        //To compute all the queries \\n        for(int i = 0; i < queries.size(); i++){\\n            ans[i] = dfs(queries.get(i).get(0), queries.get(i).get(1), new HashSet<>(), graph);\\n        }\\n        return ans;\\n    }\\n\\n    private double dfs(String src, String dest, HashSet<String> visited, Map<String, List<Node>> graph){\\n        if(!graph.containsKey(src) || !graph.containsKey(dest)) return -1.0;\\n        if(src.equals(dest)) return 1.0;\\n        visited.add(src);\\n        for(Node node : graph.get(src)){\\n            if(!visited.contains(node.dest)){\\n                double ans = dfs(node.dest, dest, visited, graph);\\n                if(ans != -1.0) return ans * node.val;\\n            }\\n        }\\n        return -1.0;\\n    }\\n\\n    private Map<String, List<Node>> buildGraph(List<List<String>> equations, double[] values){\\n        Map<String, List<Node>> graph = new HashMap<>();\\n        System.out.println(values.length);\\n        for(int i = 0; i < values.length; i++){\\n            // List<String> eq = equations.get(i);\\n            // graph.computeIfAbsent(eq.get(0), value -> new ArrayList<>()).add(new Node(eq.get(i), values[i]));\\n            // graph.computeIfAbsent(eq.get(1), value -> new ArrayList<>()).add(new Node(eq.get(0), 1 / values[i]));\\n            String src = equations.get(i).get(0);\\n            String dest = equations.get(i).get(1);\\n            graph.putIfAbsent(src, new ArrayList());\\n            graph.putIfAbsent(dest, new ArrayList());\\n            graph.get(src).add(new Node(dest, values[i]));\\n            graph.get(dest).add(new Node(src, 1 / values[i]));\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public class Node {\\n        String dest;\\n        double val;\\n        public Node(String d, double v){\\n            dest = d;\\n            val = v;\\n        }\\n    }\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        // Creating graph, Format of graph is Key is String and values is destination and value or weight\\n        Map<String, List<Node>> graph = buildGraph(equations, values);\\n        // To Store answer\\n        double[] ans = new double[queries.size()];\\n        //To compute all the queries \\n        for(int i = 0; i < queries.size(); i++){\\n            ans[i] = dfs(queries.get(i).get(0), queries.get(i).get(1), new HashSet<>(), graph);\\n        }\\n        return ans;\\n    }\\n\\n    private double dfs(String src, String dest, HashSet<String> visited, Map<String, List<Node>> graph){\\n        if(!graph.containsKey(src) || !graph.containsKey(dest)) return -1.0;\\n        if(src.equals(dest)) return 1.0;\\n        visited.add(src);\\n        for(Node node : graph.get(src)){\\n            if(!visited.contains(node.dest)){\\n                double ans = dfs(node.dest, dest, visited, graph);\\n                if(ans != -1.0) return ans * node.val;\\n            }\\n        }\\n        return -1.0;\\n    }\\n\\n    private Map<String, List<Node>> buildGraph(List<List<String>> equations, double[] values){\\n        Map<String, List<Node>> graph = new HashMap<>();\\n        System.out.println(values.length);\\n        for(int i = 0; i < values.length; i++){\\n            // List<String> eq = equations.get(i);\\n            // graph.computeIfAbsent(eq.get(0), value -> new ArrayList<>()).add(new Node(eq.get(i), values[i]));\\n            // graph.computeIfAbsent(eq.get(1), value -> new ArrayList<>()).add(new Node(eq.get(0), 1 / values[i]));\\n            String src = equations.get(i).get(0);\\n            String dest = equations.get(i).get(1);\\n            graph.putIfAbsent(src, new ArrayList());\\n            graph.putIfAbsent(dest, new ArrayList());\\n            graph.get(src).add(new Node(dest, values[i]));\\n            graph.get(dest).add(new Node(src, 1 / values[i]));\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543713,
                "title": "simple-dfs-approach-c-89-efficient",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFiven a pair Ai, Bi, which evaluates to Ai/Bi = Vi, we\\'ll use a dictionary to store (Ai,Bi) = Vi and (Bi,Ai) = 1/Vi.\\n\\nThen, while evaluating each given query, we\\'ll check if both numerator and denominator of the given query is encountered earlier and use DFS approach to find the available num/den combination and evaluate the query.\\n\\n![Screenshot 2023-05-20 110519.png](https://assets.leetcode.com/users/images/13fe7a4c-8ec5-41d7-9772-d2f5078a5c5d_1684560929.298847.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2) - as we apply DFS for each of the query\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) - as we use dictionary to store the given expressions\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public double[] CalcEquation(IList<IList<string>> equations, double[] values, IList<IList<string>> queries) {\\n        \\n        HashSet<string> vis = new HashSet<string>();\\n        Dictionary<string, Dictionary<string, double>> d = new Dictionary<string, Dictionary<string, double>>();\\n\\n        for (int i = 0; i < equations.Count; i++)\\n        {\\n            string numerator = equations[i][0];\\n            string denominator = equations[i][1];\\n            double resultValue = values[i];\\n\\n            if (!d.ContainsKey(numerator))\\n                d[numerator] = new Dictionary<string, double>();\\n            \\n            if (!d.ContainsKey(denominator))\\n                d[denominator] = new Dictionary<string, double>();\\n\\n            d[numerator][denominator] = resultValue;\\n            d[denominator][numerator]  = 1 / resultValue;\\n        }\\n\\n        return queries.Select(q => EvaluateQuery(q[0], q[1], d, vis)).ToArray();\\n    }\\n\\n    private double EvaluateQuery(string num, string den, Dictionary<string, Dictionary<string, double>> d, HashSet<string> vis)\\n    {\\n        if (!d.ContainsKey(num) || !d.ContainsKey(den))\\n            return -1;\\n\\n        if (num == den)\\n            return 1;\\n\\n        if (d.ContainsKey(num) && d[num].ContainsKey(den))\\n            return d[num][den];\\n\\n        vis.Add(num);\\n        double cur = -1;\\n        foreach (var key in d[num].Keys)\\n        {\\n            if (!vis.Contains(key))\\n            {\\n                cur = EvaluateQuery(key, den, d, vis);\\n                if (cur != -1)\\n                {\\n                    cur = cur * d[num][key];\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vis.Remove(num);\\n        return cur;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach\\n![Upvote please - CAT.jpg](https://assets.leetcode.com/users/images/0fb3c936-0ee6-432a-8a4d-70a05f13c753_1684561662.72847.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public double[] CalcEquation(IList<IList<string>> equations, double[] values, IList<IList<string>> queries) {\\n        \\n        HashSet<string> vis = new HashSet<string>();\\n        Dictionary<string, Dictionary<string, double>> d = new Dictionary<string, Dictionary<string, double>>();\\n\\n        for (int i = 0; i < equations.Count; i++)\\n        {\\n            string numerator = equations[i][0];\\n            string denominator = equations[i][1];\\n            double resultValue = values[i];\\n\\n            if (!d.ContainsKey(numerator))\\n                d[numerator] = new Dictionary<string, double>();\\n            \\n            if (!d.ContainsKey(denominator))\\n                d[denominator] = new Dictionary<string, double>();\\n\\n            d[numerator][denominator] = resultValue;\\n            d[denominator][numerator]  = 1 / resultValue;\\n        }\\n\\n        return queries.Select(q => EvaluateQuery(q[0], q[1], d, vis)).ToArray();\\n    }\\n\\n    private double EvaluateQuery(string num, string den, Dictionary<string, Dictionary<string, double>> d, HashSet<string> vis)\\n    {\\n        if (!d.ContainsKey(num) || !d.ContainsKey(den))\\n            return -1;\\n\\n        if (num == den)\\n            return 1;\\n\\n        if (d.ContainsKey(num) && d[num].ContainsKey(den))\\n            return d[num][den];\\n\\n        vis.Add(num);\\n        double cur = -1;\\n        foreach (var key in d[num].Keys)\\n        {\\n            if (!vis.Contains(key))\\n            {\\n                cur = EvaluateQuery(key, den, d, vis);\\n                if (cur != -1)\\n                {\\n                    cur = cur * d[num][key];\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vis.Remove(num);\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106188,
                "title": "c-dfs-solution-picture-for-intuition",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs( map<string, vector<pair<string,double>>> &gr, string start, string end, double &val, map<string,bool> &vis, bool &equal){\\n        if( start == end ) {\\n            equal = true;\\n            return;\\n        }\\n        vis[start] = true;\\n        for( auto nod : gr[ start ] ){\\n            if( !vis[ nod.first ] ){\\n                \\n                val *= nod.second;\\n                \\n                if( end == nod.first ){\\n                    equal = true; \\n                    return ;\\n                }\\n                dfs( gr, nod.first, end, val, vis, equal );\\n                \\n                if( equal) return;\\n                else val /= nod.second;\\n            }\\n        }\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& values, vector<vector<string>>& q) {\\n        map<string, vector<pair<string,double>>>gr;\\n        vector< double > ans;\\n        for( int i = 0; i < eq.size(); i++ ){\\n            gr[ eq[i][0] ].push_back( { eq[i][1], (double)values[i] } );\\n            gr[ eq[i][1] ].push_back( { eq[i][0], (double)1.00/values[i] } );\\n        }\\n        for( int i = 0; i < q.size(); i++) {\\n            \\n            string u = q[ i ][ 0 ];\\n            string v = q[ i ][ 1 ];\\n            //if any of string is not in graph push -1.00 as mentioned\\n            if(gr.find( u ) == gr.end() || gr.find( v ) == gr.end() ) ans.push_back( (double)-1 );\\n            else {\\n                map<string,bool> vis;\\n                double val = 1.00;\\n                bool equal = false;\\n                \\n                dfs ( gr, u, v, val, vis, equal );\\n                \\n                if( equal ) ans.push_back( val );\\n                else ans.push_back( -1.00 );\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2cd564b5-0f20-4d5e-82c9-770f0e6dac10_1654260723.8744035.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs( map<string, vector<pair<string,double>>> &gr, string start, string end, double &val, map<string,bool> &vis, bool &equal){\\n        if( start == end ) {\\n            equal = true;\\n            return;\\n        }\\n        vis[start] = true;\\n        for( auto nod : gr[ start ] ){\\n            if( !vis[ nod.first ] ){\\n                \\n                val *= nod.second;\\n                \\n                if( end == nod.first ){\\n                    equal = true; \\n                    return ;\\n                }\\n                dfs( gr, nod.first, end, val, vis, equal );\\n                \\n                if( equal) return;\\n                else val /= nod.second;\\n            }\\n        }\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& values, vector<vector<string>>& q) {\\n        map<string, vector<pair<string,double>>>gr;\\n        vector< double > ans;\\n        for( int i = 0; i < eq.size(); i++ ){\\n            gr[ eq[i][0] ].push_back( { eq[i][1], (double)values[i] } );\\n            gr[ eq[i][1] ].push_back( { eq[i][0], (double)1.00/values[i] } );\\n        }\\n        for( int i = 0; i < q.size(); i++) {\\n            \\n            string u = q[ i ][ 0 ];\\n            string v = q[ i ][ 1 ];\\n            //if any of string is not in graph push -1.00 as mentioned\\n            if(gr.find( u ) == gr.end() || gr.find( v ) == gr.end() ) ans.push_back( (double)-1 );\\n            else {\\n                map<string,bool> vis;\\n                double val = 1.00;\\n                bool equal = false;\\n                \\n                dfs ( gr, u, v, val, vis, equal );\\n                \\n                if( equal ) ans.push_back( val );\\n                else ans.push_back( -1.00 );\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086218,
                "title": "python-floyd-warshall-o-n-3-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        def buildGraph():\\n            graph = defaultdict(dict)\\n            for (a, b), v in zip(equations, values):    # zip into two tuples\\n                graph[a][b] = v\\n                graph[b][a] = 1/v\\n            return graph\\n    \\n        graph = buildGraph()                            # build given relationship\\n        \\n                                                        # build all other relationship using floyd\\n        for k in graph:                                 # k: intermediate vertext\\n            for i in graph:\\n                for j in graph:                         # i, j : one matrix at a time\\n                    if k in graph[i] and j in graph[k]:\\n                        graph[i][j] = graph[i][k] * graph[k][j]\\n        \\n        return [graph[a][b] if b in graph[a] else -1.00000 for a, b in queries]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        def buildGraph():\\n            graph = defaultdict(dict)\\n            for (a, b), v in zip(equations, values):    # zip into two tuples\\n                graph[a][b] = v\\n                graph[b][a] = 1/v\\n            return graph\\n    \\n        graph = buildGraph()                            # build given relationship\\n        \\n                                                        # build all other relationship using floyd\\n        for k in graph:                                 # k: intermediate vertext\\n            for i in graph:\\n                for j in graph:                         # i, j : one matrix at a time\\n                    if k in graph[i] and j in graph[k]:\\n                        graph[i][j] = graph[i][k] * graph[k][j]\\n        \\n        return [graph[a][b] if b in graph[a] else -1.00000 for a, b in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052388,
                "title": "java-dfs-solution-with-explain",
                "content": "Consider this is a directed graph, [\"a\",\"b\"] means from node a to node b, and values [2.0] means the weight of edge. There also another edge from node b to node a, with weight 1 / 2. \\n\\nAfter we construct the graph, we do dfs start from the query start, and end at query endpoint, calculate the product of edge weight from start to end. If we didn\\'t find the target, return -1. \\n\\n2 special case, if query start node or end node not even appear in graph, return -1 directly. if start node  == end node, return 1. \\n\\n```\\nclass Edge{\\n    public String from;\\n    public String to;\\n    public double value;\\n    public Edge(String f, String t, double v){\\n        this.from = f;\\n        this.to = t;\\n        this.value = v;\\n    }\\n}\\n\\nclass Solution {\\n\\n    boolean isFound = false;\\n\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        HashMap<String, List<Edge>> hashMap = new HashMap<>();\\n\\n        for(int i = 0; i < equations.size(); i++){\\n            List<String> equa = equations.get(i);\\n            double c = values[i];\\n\\n            if(!hashMap.containsKey(equa.get(0))){\\n                hashMap.put(equa.get(0), new ArrayList<>());\\n            }\\n\\n            hashMap.get(equa.get(0)).add(new Edge(equa.get(0), equa.get(1), c));\\n\\n            if(!hashMap.containsKey(equa.get(1))){\\n                hashMap.put(equa.get(1), new ArrayList<>());\\n            }\\n\\n            hashMap.get(equa.get(1)).add(new Edge(equa.get(1), equa.get(0), 1 / c));\\n        }\\n\\n        double[] res = new double[queries.size()];\\n\\n        for(int i = 0; i < queries.size(); i++){\\n            List<String> query = queries.get(i);\\n\\n            String start = query.get(0);\\n            String end = query.get(1);\\n\\n            if(!hashMap.containsKey(start) || !hashMap.containsKey(end)){\\n                res[i] = -1;\\n                continue;\\n            }\\n\\n            if(start == end){\\n                res[i] = 1;\\n                continue;\\n            }\\n            isFound = false;\\n            res[i] = dfs(start, end, hashMap, 1, new HashSet<>());\\n        }\\n\\n        return res;\\n    }\\n\\n    public double dfs(String from, String target, HashMap<String, List<Edge>> hashMap, double current, HashSet<String> visited){\\n        if(from.equals(target)){\\n            isFound = true;\\n            return current;\\n        }\\n        visited.add(from);\\n        List<Edge> thisList = hashMap.get(from);\\n        for(Edge edge : thisList){\\n            if(!visited.contains(edge.to)){\\n                double c = dfs(edge.to, target, hashMap, current * edge.value, visited);\\n                if(isFound){\\n                    return c;\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Edge{\\n    public String from;\\n    public String to;\\n    public double value;\\n    public Edge(String f, String t, double v){\\n        this.from = f;\\n        this.to = t;\\n        this.value = v;\\n    }\\n}\\n\\nclass Solution {\\n\\n    boolean isFound = false;\\n\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        HashMap<String, List<Edge>> hashMap = new HashMap<>();\\n\\n        for(int i = 0; i < equations.size(); i++){\\n            List<String> equa = equations.get(i);\\n            double c = values[i];\\n\\n            if(!hashMap.containsKey(equa.get(0))){\\n                hashMap.put(equa.get(0), new ArrayList<>());\\n            }\\n\\n            hashMap.get(equa.get(0)).add(new Edge(equa.get(0), equa.get(1), c));\\n\\n            if(!hashMap.containsKey(equa.get(1))){\\n                hashMap.put(equa.get(1), new ArrayList<>());\\n            }\\n\\n            hashMap.get(equa.get(1)).add(new Edge(equa.get(1), equa.get(0), 1 / c));\\n        }\\n\\n        double[] res = new double[queries.size()];\\n\\n        for(int i = 0; i < queries.size(); i++){\\n            List<String> query = queries.get(i);\\n\\n            String start = query.get(0);\\n            String end = query.get(1);\\n\\n            if(!hashMap.containsKey(start) || !hashMap.containsKey(end)){\\n                res[i] = -1;\\n                continue;\\n            }\\n\\n            if(start == end){\\n                res[i] = 1;\\n                continue;\\n            }\\n            isFound = false;\\n            res[i] = dfs(start, end, hashMap, 1, new HashSet<>());\\n        }\\n\\n        return res;\\n    }\\n\\n    public double dfs(String from, String target, HashMap<String, List<Edge>> hashMap, double current, HashSet<String> visited){\\n        if(from.equals(target)){\\n            isFound = true;\\n            return current;\\n        }\\n        visited.add(from);\\n        List<Edge> thisList = hashMap.get(from);\\n        for(Edge edge : thisList){\\n            if(!visited.contains(edge.to)){\\n                double c = dfs(edge.to, target, hashMap, current * edge.value, visited);\\n                if(isFound){\\n                    return c;\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995134,
                "title": "c-solution-unionfind",
                "content": "\\tpublic class Solution {\\n\\t\\tDictionary<String,Tuple<String,Double>> equationMap = new Dictionary<String,Tuple<String,Double>>();\\n\\t\\tpublic double[] CalcEquation(IList<IList<string>> equations, double[] values, IList<IList<string>> queries) {\\n\\t\\t\\tint index=0;\\n\\t\\t\\tforeach(List<string> eq in equations){\\n\\t\\t\\t\\tUnion(eq[0],eq[1],values[index]);\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tdouble[] results = new double[queries.Count];\\n\\t\\t\\tfor (int i = 0; i < queries.Count; i++) {\\n\\t\\t\\t\\tstring dividend = queries[i][0];\\n\\t\\t\\t\\tstring divisor = queries[i][1]; \\n\\n\\t\\t\\t\\tif(!equationMap.ContainsKey(dividend) || !equationMap.ContainsKey(divisor))\\n\\t\\t\\t\\t\\tresults[i]=-1.0;\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tTuple<String,Double> key1Value = Find(dividend);\\n\\t\\t\\t\\t\\tTuple<String,Double> key2Value = Find(divisor);\\n\\t\\t\\t\\t\\tif(key1Value.Item1 != key2Value.Item1){\\n\\t\\t\\t\\t\\t\\tresults[i]=-1.0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tresults[i]=key1Value.Item2/key2Value.Item2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn results;\\n\\t\\t}\\n\\n\\t\\tpublic Tuple<String,Double> Find(string key){\\n\\t\\t\\tif(!equationMap.ContainsKey(key))\\n\\t\\t\\t\\tequationMap[key] = new Tuple<String,Double>(key,1.0);\\n\\n\\t\\t\\tTuple<String,Double> keyvalue = equationMap[key];\\n\\t\\t\\tif(key != keyvalue.Item1){\\n\\t\\t\\t\\tTuple<String,Double> newkeyvalue = Find(keyvalue.Item1);\\n\\t\\t\\t\\tequationMap[key] = new Tuple<String,Double>(newkeyvalue.Item1,keyvalue.Item2 * newkeyvalue.Item2);\\n\\t\\t\\t}\\n\\t\\t\\treturn equationMap[key];\\n\\t\\t}\\n\\t\\tpublic void Union(string key1, string key2, double value){\\n\\t\\t\\tTuple<String,Double> key1Value = Find(key1);\\n\\t\\t\\tTuple<String,Double> key2Value = Find(key2);\\n\\n\\t\\t\\tif(key1Value.Item1 != key2Value.Item1){\\n\\t\\t\\t\\tequationMap[key1Value.Item1] = new Tuple<String,Double>(key2Value.Item1,(key2Value.Item2 * value)/key1Value.Item2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tDictionary<String,Tuple<String,Double>> equationMap = new Dictionary<String,Tuple<String,Double>>();\\n\\t\\tpublic double[] CalcEquation(IList<IList<string>> equations, double[] values, IList<IList<string>> queries) {\\n\\t\\t\\tint index=0;\\n\\t\\t\\tforeach(List<string> eq in equations){\\n\\t\\t\\t\\tUnion(eq[0],eq[1],values[index]);\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1968550,
                "title": "bfs-graph",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,double> mp;\\n    unordered_map<string,vector<string>> graph;\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        for(int i=0;i<equations.size();i++){\\n            mp[equations[i][0]+\"$\"+equations[i][1]]=values[i];\\n            mp[equations[i][1]+\"$\"+equations[i][0]]=1.0/values[i];\\n            graph[equations[i][0]].push_back(equations[i][1]);\\n            graph[equations[i][1]].push_back(equations[i][0]);\\n        }\\n        vector<double> ans;\\n        for(auto arr:queries){\\n            queue<pair<string,double>> q;\\n            q.push({arr[0],1.0});\\n            unordered_map<string,bool> visited;\\n            visited[arr[0]]=true;\\n            bool done=false;\\n            if(arr[0]==arr[1]){\\n                if(graph.find(arr[0])!=graph.end())\\n                ans.push_back(1.0);\\n                else\\n                    ans.push_back(-1.0);\\n                continue;\\n            }\\n            while(!q.empty()){\\n                auto curr=q.front();\\n                q.pop();\\n                string s=curr.first;\\n                double val=curr.second;\\n                \\n                for(auto x:graph[s]){\\n                    if(!visited[x]){\\n                        if(x==arr[1]){\\n                            done=true;\\n                            ans.push_back(val*mp[s+\"$\"+x]);\\n                            break;\\n                        }\\n                        q.push({x,val*mp[s+\"$\"+x]});\\n                        visited[x]=true;\\n                        cout<<(s+\"/\"+x)<<endl;\\n                    }\\n                }\\n                if(done) break;\\n            }\\n            if(!done) ans.push_back(-1.0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,double> mp;\\n    unordered_map<string,vector<string>> graph;\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        for(int i=0;i<equations.size();i++){\\n            mp[equations[i][0]+\"$\"+equations[i][1]]=values[i];\\n            mp[equations[i][1]+\"$\"+equations[i][0]]=1.0/values[i];\\n            graph[equations[i][0]].push_back(equations[i][1]);\\n            graph[equations[i][1]].push_back(equations[i][0]);\\n        }\\n        vector<double> ans;\\n        for(auto arr:queries){\\n            queue<pair<string,double>> q;\\n            q.push({arr[0],1.0});\\n            unordered_map<string,bool> visited;\\n            visited[arr[0]]=true;\\n            bool done=false;\\n            if(arr[0]==arr[1]){\\n                if(graph.find(arr[0])!=graph.end())\\n                ans.push_back(1.0);\\n                else\\n                    ans.push_back(-1.0);\\n                continue;\\n            }\\n            while(!q.empty()){\\n                auto curr=q.front();\\n                q.pop();\\n                string s=curr.first;\\n                double val=curr.second;\\n                \\n                for(auto x:graph[s]){\\n                    if(!visited[x]){\\n                        if(x==arr[1]){\\n                            done=true;\\n                            ans.push_back(val*mp[s+\"$\"+x]);\\n                            break;\\n                        }\\n                        q.push({x,val*mp[s+\"$\"+x]});\\n                        visited[x]=true;\\n                        cout<<(s+\"/\"+x)<<endl;\\n                    }\\n                }\\n                if(done) break;\\n            }\\n            if(!done) ans.push_back(-1.0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1956328,
                "title": "easy-to-understand-javascript-solution-dfs",
                "content": "\\tvar calcEquation = function(equations, values, queries) {\\n\\t\\tconst map = equations.reduce((result, [a, b], index) => {\\n\\t\\t\\tconst value = values[index];\\n\\t\\t\\tconst valueA = result.get(a) ?? [];\\n\\t\\t\\tconst valueB = result.get(b) ?? [];\\n\\n\\t\\t\\tvalueA.push([b, value]);\\n\\t\\t\\tvalueB.push([a, 1 / value]);\\n\\t\\t\\tresult.set(a, valueA);\\n\\t\\t\\tresult.set(b, valueB);\\n\\t\\t\\treturn result;\\n\\t\\t}, new Map());\\n\\n\\t\\tconst dfs = ([a, b], visited = new Set(), current = 1) => {\\n\\t\\t\\tif (!map.has(a) || !map.has(b)) return -1;\\n\\t\\t\\tif (a === b) return current;\\n\\t\\t\\tconst values = map.get(a);\\n\\t\\t\\tvisited.add(a);\\n\\n\\t\\t\\tfor (const [key, value] of values) {\\n\\t\\t\\t\\tif (visited.has(key)) continue;\\n\\t\\t\\t\\tconst nextValue = current * value;\\n\\n\\t\\t\\t\\tconst result = dfs([key, b], visited, nextValue);\\n\\t\\t\\t\\tif (result !== null) return result;\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t};\\n\\n\\t\\treturn queries.map(item => dfs(item) ?? -1);\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar calcEquation = function(equations, values, queries) {\\n\\t\\tconst map = equations.reduce((result, [a, b], index) => {\\n\\t\\t\\tconst value = values[index];\\n\\t\\t\\tconst valueA = result.get(a) ?? [];\\n\\t\\t\\tconst valueB = result.get(b) ?? [];\\n\\n\\t\\t\\tvalueA.push([b, value]);\\n\\t\\t\\tvalueB.push([a, 1 / value]);\\n\\t\\t\\tresult.set(a, valueA);\\n\\t\\t\\tresult.set(b, valueB);\\n\\t\\t\\treturn result;\\n\\t\\t}, new Map());\\n\\n\\t\\tconst dfs = ([a, b], visited = new Set(), current = 1) => {\\n\\t\\t\\tif (!map.has(a) || !map.has(b)) return -1;\\n\\t\\t\\tif (a === b) return current;\\n\\t\\t\\tconst values = map.get(a);\\n\\t\\t\\tvisited.add(a);\\n\\n\\t\\t\\tfor (const [key, value] of values) {\\n\\t\\t\\t\\tif (visited.has(key)) continue;\\n\\t\\t\\t\\tconst nextValue = current * value;\\n\\n\\t\\t\\t\\tconst result = dfs([key, b], visited, nextValue);\\n\\t\\t\\t\\tif (result !== null) return result;\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t};\\n\\n\\t\\treturn queries.map(item => dfs(item) ?? -1);\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1557931,
                "title": "c-solution-using-unordered-map-with-explaination",
                "content": "Idea is that there can be chain of these variables being multiplied. First add each of the variables in the equations in our graph. i.e. if equation has vector (\"a\", \"b\") and correspoding value = 2.0 that means there will be an edge in graph from \"a\" to \"b\" of weight 2.0 and there will be an edge in graph from \"b\" to \"a\" with weight 0.5. \\nNow once the graph is created, we need to go through each and every query and find if a path exists from query[i][0] to query[i][1]. If it does, just keep multiplying the weights in the path and return it. \\nSome explaination on not so conventional DFS I have written:\\nFor a minute ignore first if. My first base case is that node1==node2, if so we have both variables equal and hence, whatever val we have got until now is our answer. My second base condition is that visited[node1] = true (note that I check true here, but just checking if node1 was in the unordered_map visited would had been enough). If this is so, we have looped back and couldnt find a path to node2, so return -1.0.\\nNow I go through every neighbour of the current node1 and take the maximum of the answer. Why maximum?\\nRemember that any varaible can be mentioned several times in our original equation vector, i.e. we can have information that (a/b) = 2.0, (a/c) = 4.5, (d/a) = 10.0 and so on....\\nSo if we start finding c as node2, we will get -1.0 as our answer form the edges where we traverse b (0.5) and d (0.1). But when we traverse edge a to c, we find c. \\nAlso note that we assume here that there cant be multiple paths to node2. If there were, just inserting another if condition:\\n```\\noutput = DFS(graph, V.first, node2, val*V.second, visited)\\nif(output!=-1.0 && ret == -1.0)\\n\\tret = output;\\nelse if(output!=-1.0)\\n\\tret  = min(ret, output);\\n```\\nwill do the trick of returning shortest path.\\nNow come back to first if. It is just some trivial check I needed to put for checking if node1 is not present in my graph, if not, return -1.0. Note that my logic already would have returned -1.0 for missing node1 (node2 not reached), except for the cases were node1==node2 (eg \"x\", \"x\").\\nMy code without this particular check returns 1.0 in that one case (which is indeed a correct answer as everybody knows something divided by itself is 1). But I dont know why the question maker wanted to insert a condition that would make our solution more \"unintelligent\".\\n```\\nclass Solution {\\n    double DFS(unordered_map<string, vector<pair<string, double>>> &graph, string node1, string node2, double val, unordered_map<string, bool> &visited)\\n    {\\n        if(graph.find(node1)==graph.end())\\n            return -1.0;\\n        if(node1==node2)\\n            return val;\\n        if(visited[node1])\\n            return -1.0;\\n        visited[node1] = true;\\n        double ret = -1.0;\\n        for(pair<string, double> V : graph[node1])\\n        {\\n            ret = max(ret, DFS(graph, V.first, node2, val*V.second, visited));\\n        }\\n        return ret;\\n    }\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        unordered_map<string, vector<pair<string, double>>> graph;\\n        for(int i = 0; i<equations.size(); i++)\\n        {\\n            vector<string> eq = equations[i];\\n            graph[eq[0]].push_back(make_pair(eq[1], values[i]));\\n            graph[eq[1]].push_back(make_pair(eq[0], 1/values[i]));\\n        }\\n        vector<double> ret;\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            string node1 = queries[i][0];\\n            string node2 = queries[i][1];\\n            unordered_map<string, bool> visited;\\n            ret.push_back(DFS(graph, node1, node2, 1.0, visited));\\n        }\\n        return ret;\\n    }\\n};\\n```\\nTime complexity: O(queries * max no of edges (N^2))\\nSpace complexity: O(max no of edges (N^2))",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\noutput = DFS(graph, V.first, node2, val*V.second, visited)\\nif(output!=-1.0 && ret == -1.0)\\n\\tret = output;\\nelse if(output!=-1.0)\\n\\tret  = min(ret, output);\\n```\n```\\nclass Solution {\\n    double DFS(unordered_map<string, vector<pair<string, double>>> &graph, string node1, string node2, double val, unordered_map<string, bool> &visited)\\n    {\\n        if(graph.find(node1)==graph.end())\\n            return -1.0;\\n        if(node1==node2)\\n            return val;\\n        if(visited[node1])\\n            return -1.0;\\n        visited[node1] = true;\\n        double ret = -1.0;\\n        for(pair<string, double> V : graph[node1])\\n        {\\n            ret = max(ret, DFS(graph, V.first, node2, val*V.second, visited));\\n        }\\n        return ret;\\n    }\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        unordered_map<string, vector<pair<string, double>>> graph;\\n        for(int i = 0; i<equations.size(); i++)\\n        {\\n            vector<string> eq = equations[i];\\n            graph[eq[0]].push_back(make_pair(eq[1], values[i]));\\n            graph[eq[1]].push_back(make_pair(eq[0], 1/values[i]));\\n        }\\n        vector<double> ret;\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            string node1 = queries[i][0];\\n            string node2 = queries[i][1];\\n            unordered_map<string, bool> visited;\\n            ret.push_back(DFS(graph, node1, node2, 1.0, visited));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421363,
                "title": "c-using-dfs-on-directed-graph",
                "content": "The idea is that if a/b is x and b/c is y then a/c is **x*y**, so this can be thought of as a directed graph where a->b has an edge weight x and b->c has edge weight y. To get a/c we need to get the **product of all edges in the path** a->b->c. \\n\\nSince, we know a->b has weight x, therefore b->a would also exist and have a weight **1/x**.\\n\\n```\\nclass Solution\\n{\\nprivate:\\n\\t// adjacency list to store directed edges\\n    unordered_map<string, vector<pair<string, double>>> adj; // src -> dest, wt\\n    unordered_set<string> visited;\\n\\n    // go from source to destination and return product of paths\\n    double dfs(string src, string dest)\\n    {\\n        // if source or destination is not in graph\\n        if (adj.count(src) == 0 || adj.count(dest) == 0)\\n            return -1;\\n\\n        // if source is destination i.e. path exists\\n        if (src == dest)\\n            return 1;\\n\\n        // if already visited, don\\'t revisit\\n        if (visited.find(src) != visited.end())\\n            return -1;\\n        visited.insert(src);\\n\\n        // for every neighbor of source\\n        for (const auto &itr : adj[src])\\n        {\\n            const auto [neighbor, wt] = itr;\\n\\n            double neighbor_answer = dfs(neighbor, dest);\\n\\n            // if a path exists from neighbor to destination\\n            if (neighbor_answer != -1)\\n                return wt * neighbor_answer;\\n        }\\n        // path doesn\\'t exist from src to destination\\n        return -1;\\n    }\\n\\npublic:\\n    vector<double> calcEquation(vector<vector<string>> &equations, vector<double> &values, vector<vector<string>> &queries)\\n    {\\n        // equations: a, b | values = a / b\\n        int edges = equations.size();\\n\\n        // build directed graph\\n        for (int i = 0; i < edges; i++)\\n        {\\n            string a = equations[i][0];\\n            string b = equations[i][1];\\n            double div = values[i];\\n\\n            adj[a].push_back({b, div});     // a -> b = div\\n            adj[b].push_back({a, 1 / div}); // b -> a = 1 / div\\n        }\\n\\n        vector<double> ans;\\n        for (const auto &query : queries)\\n        {\\n            string src = query[0];\\n            string dest = query[1];\\n\\n            // find product of path from src to dest || -1\\n            ans.push_back(dfs(src, dest));\\n\\n            // reset visited\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n\\t// adjacency list to store directed edges\\n    unordered_map<string, vector<pair<string, double>>> adj; // src -> dest, wt\\n    unordered_set<string> visited;\\n\\n    // go from source to destination and return product of paths\\n    double dfs(string src, string dest)\\n    {\\n        // if source or destination is not in graph\\n        if (adj.count(src) == 0 || adj.count(dest) == 0)\\n            return -1;\\n\\n        // if source is destination i.e. path exists\\n        if (src == dest)\\n            return 1;\\n\\n        // if already visited, don\\'t revisit\\n        if (visited.find(src) != visited.end())\\n            return -1;\\n        visited.insert(src);\\n\\n        // for every neighbor of source\\n        for (const auto &itr : adj[src])\\n        {\\n            const auto [neighbor, wt] = itr;\\n\\n            double neighbor_answer = dfs(neighbor, dest);\\n\\n            // if a path exists from neighbor to destination\\n            if (neighbor_answer != -1)\\n                return wt * neighbor_answer;\\n        }\\n        // path doesn\\'t exist from src to destination\\n        return -1;\\n    }\\n\\npublic:\\n    vector<double> calcEquation(vector<vector<string>> &equations, vector<double> &values, vector<vector<string>> &queries)\\n    {\\n        // equations: a, b | values = a / b\\n        int edges = equations.size();\\n\\n        // build directed graph\\n        for (int i = 0; i < edges; i++)\\n        {\\n            string a = equations[i][0];\\n            string b = equations[i][1];\\n            double div = values[i];\\n\\n            adj[a].push_back({b, div});     // a -> b = div\\n            adj[b].push_back({a, 1 / div}); // b -> a = 1 / div\\n        }\\n\\n        vector<double> ans;\\n        for (const auto &query : queries)\\n        {\\n            string src = query[0];\\n            string dest = query[1];\\n\\n            // find product of path from src to dest || -1\\n            ans.push_back(dfs(src, dest));\\n\\n            // reset visited\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145378,
                "title": "java-simple-and-easy-dfs-solution-0-ms-faster-than-100-00-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    \\n    HashMap<String, HashMap<String, Double>> graph; \\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        \\n        //create graph\\n        graph = new HashMap();\\n        for(int i = 0; i < equations.size(); i++){\\n            List<String> equation = equations.get(i);\\n            \\n            String dividend = equation.get(0);\\n            String divisor  = equation.get(1);\\n            double quotient = values[i];\\n            \\n            graph.putIfAbsent(dividend, new HashMap<String, Double>());\\n            graph.putIfAbsent(divisor, new HashMap<String, Double>());\\n            \\n            graph.get(dividend).put(divisor, quotient);\\n            graph.get(divisor).put(dividend, 1 / quotient);\\n        }\\n        \\n        \\n        //get all query result\\n        double[] results = new double[queries.size()];\\n        \\n        for(int i = 0; i < queries.size(); i++){\\n            String dividend = queries.get(i).get(0);\\n            String divisor  = queries.get(i).get(1);\\n            \\n            if(!graph.containsKey(dividend) || !graph.containsKey(divisor)){\\n                results[i] = -1.0;\\n            }else if(dividend == divisor){\\n                results[i] = 1.0;\\n            }else{\\n                results[i] = queryUsingDfs(dividend, divisor, 1, new HashSet());\\n            }\\n        }\\n        \\n        \\n        return results;\\n    }\\n    \\n    private double queryUsingDfs(String currNode, String targetNode, double currProduct, Set<String> visited){\\n        visited.add(currNode);\\n        \\n        double result = -1.0;\\n        \\n        Map<String, Double> neighbors = graph.get(currNode);\\n            \\n        if(neighbors.containsKey(targetNode)){\\n            result = currProduct * neighbors.get(targetNode);\\n        } else {\\n            \\n            for(String nextNode : neighbors.keySet()){\\n                \\n                if(visited.contains(nextNode)) continue;\\n                \\n                double quotient = neighbors.get(nextNode);\\n                \\n                result = queryUsingDfs(nextNode, targetNode, currProduct * quotient, visited);\\n                \\n                //found\\n                if(result != -1.0) break; \\n            }\\n            \\n        }\\n        //visited.remove(currNode);\\n        return result;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    HashMap<String, HashMap<String, Double>> graph; \\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        \\n        //create graph\\n        graph = new HashMap();\\n        for(int i = 0; i < equations.size(); i++){\\n            List<String> equation = equations.get(i);\\n            \\n            String dividend = equation.get(0);\\n            String divisor  = equation.get(1);\\n            double quotient = values[i];\\n            \\n            graph.putIfAbsent(dividend, new HashMap<String, Double>());\\n            graph.putIfAbsent(divisor, new HashMap<String, Double>());\\n            \\n            graph.get(dividend).put(divisor, quotient);\\n            graph.get(divisor).put(dividend, 1 / quotient);\\n        }\\n        \\n        \\n        //get all query result\\n        double[] results = new double[queries.size()];\\n        \\n        for(int i = 0; i < queries.size(); i++){\\n            String dividend = queries.get(i).get(0);\\n            String divisor  = queries.get(i).get(1);\\n            \\n            if(!graph.containsKey(dividend) || !graph.containsKey(divisor)){\\n                results[i] = -1.0;\\n            }else if(dividend == divisor){\\n                results[i] = 1.0;\\n            }else{\\n                results[i] = queryUsingDfs(dividend, divisor, 1, new HashSet());\\n            }\\n        }\\n        \\n        \\n        return results;\\n    }\\n    \\n    private double queryUsingDfs(String currNode, String targetNode, double currProduct, Set<String> visited){\\n        visited.add(currNode);\\n        \\n        double result = -1.0;\\n        \\n        Map<String, Double> neighbors = graph.get(currNode);\\n            \\n        if(neighbors.containsKey(targetNode)){\\n            result = currProduct * neighbors.get(targetNode);\\n        } else {\\n            \\n            for(String nextNode : neighbors.keySet()){\\n                \\n                if(visited.contains(nextNode)) continue;\\n                \\n                double quotient = neighbors.get(nextNode);\\n                \\n                result = queryUsingDfs(nextNode, targetNode, currProduct * quotient, visited);\\n                \\n                //found\\n                if(result != -1.0) break; \\n            }\\n            \\n        }\\n        //visited.remove(currNode);\\n        return result;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867362,
                "title": "rust-dfs-solution-0ms-explained",
                "content": "# A bit of context\\nAs division is essentially a relationship between two numbers, we can model it as a weighted graph with the weight representing the result of the division. \\n\\nHowever as `a / b != b / a`,  we have to model it as a **directed** graph, but one where if we know the weighting for one direction, we can derive the weighting for the opposite direction.\\n\\n# Applying it to the question\\n\\nGiven the format of the question `A / B = k` we can create an edge between `A` and `B` such that  `A` -- `k` --> `B`. Further more we can also derive the inverse `B` -- `1/k` --> `A`. (as `B / A = 1/k`). In addition to this, we can also use the knowledge that `A / A = 1.0` and include that within the solution _(You could either add this directly into the graph when constructing it, or alternatively just check for this condition when you parse your `query`)_.\\n\\nWe can then evaluate divison by traversing through the graph and multiplying the weightings of connected nodes together until we reach our target node. If we are not able to traverse from a start node to a target node, we don\\'t have enough information to answer the question so we return `-1.0` in this case.\\n\\n## Stepping through the example\\n\\n### Known Equations\\n- `a / b = 2.0`\\n- `b / c = 3.0`\\n\\n### Query: [ a / c ]\\nWe can model our known equations in the graph as:\\n- `a -- 2.0 --> b`\\n- `b -- 3.0 --> c`\\n\\nTherefore our path from `a -> c` then becomes: \\n- `a -- 2.0 --> b -- 3.0 --> c`\\n\\nIf we multiply our weightings together `2.0 * 3.0 = 6.0`\\n- so `a / c = 6.0`\\n\\n# Solution\\n_(Omitting all the optional checking and specifics of the collection apis for this explaination, to see what it looks like actually implemented, refer to the solution below)_\\n\\nIn this solution, the graph is modelled as a `let graph: HashMap<String, HashMap<String, f64> = ...`. The first call `let first_node = graph.get(&initial_node_key)` tells us whether the initial node is present in the graph. We can then identify all the nodes this one is connected to by iterating through the (keys, values) in the nested HashMap. To get the weighting between two nodes, we need to fetch the value within the nested HashMap `first_node.get(&second_node_key)`.\\n\\nThanks for reading, more than happy to hear any feedback on how this can be improved if anyone has any suggestions!\\n\\n```rust\\nuse std::collections::{HashMap, HashSet};\\n\\ntype Graph = HashMap<String, HashMap<String, f64>>;\\n\\nimpl Solution {\\n    pub fn calc_equation(equations: Vec<Vec<String>>, values: Vec<f64>, queries: Vec<Vec<String>>) -> Vec<f64> {\\n        let graph = build_graph(equations, values);\\n        queries\\n            .into_iter()\\n            .map(|query| dfs(&graph, query, &mut HashSet::new(), None).map_or(-1.0, |v| v))\\n            .collect()\\n    }\\n}\\n\\nfn build_graph(equations: Vec<Vec<String>>, values: Vec<f64>) -> Graph {\\n    equations\\n        .into_iter()\\n        .zip(values.into_iter())\\n        .fold(HashMap::new(), |mut acc, (eq, val)| {\\n            let entry = acc.entry(eq[0].clone()).or_default();\\n            entry.insert(eq[1].clone(), val);\\n\\n            let entry = acc.entry(eq[1].clone()).or_default();\\n            entry.insert(eq[0].clone(), 1.0 / val);\\n\\n            acc\\n        })\\n}\\n\\nfn dfs(\\n    graph: &Graph,\\n    query: Vec<String>,\\n    visited: &mut HashSet<String>,\\n    current_sum: Option<f64>,\\n) -> Option<f64> {\\n    visited.insert(query[0].clone());\\n\\n    // Check the the node exists in the graph\\n    let entry = graph.get(&query[0])?;\\n\\n    // a / a = 1.0\\n    if query[0] == query[1] {\\n        return Some(1.0);\\n    }\\n\\n    // If our current node has a direct route to our target, return it\\n    if let Some(answer) = entry.get(&query[1]) {\\n        return current_sum.map_or(Some(*answer), |s| Some(s * *answer));\\n    };\\n\\n    // Otherwise perform a DFS of connected nodes (that we haven\\'t already visited)\\n    for path in entry.keys() {\\n        if !visited.contains(path) {\\n            if let Some(val) = entry.get(path) {\\n                let result = dfs(\\n                    graph,\\n                    vec![path.clone(), query[1].clone()],\\n                    visited,\\n                    current_sum.map_or(Some(*val), |s| Some(s * *val)),\\n                );\\n                if result.is_some() {\\n                    return result;\\n                }\\n            }\\n        }\\n    }\\n    None\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```rust\\nuse std::collections::{HashMap, HashSet};\\n\\ntype Graph = HashMap<String, HashMap<String, f64>>;\\n\\nimpl Solution {\\n    pub fn calc_equation(equations: Vec<Vec<String>>, values: Vec<f64>, queries: Vec<Vec<String>>) -> Vec<f64> {\\n        let graph = build_graph(equations, values);\\n        queries\\n            .into_iter()\\n            .map(|query| dfs(&graph, query, &mut HashSet::new(), None).map_or(-1.0, |v| v))\\n            .collect()\\n    }\\n}\\n\\nfn build_graph(equations: Vec<Vec<String>>, values: Vec<f64>) -> Graph {\\n    equations\\n        .into_iter()\\n        .zip(values.into_iter())\\n        .fold(HashMap::new(), |mut acc, (eq, val)| {\\n            let entry = acc.entry(eq[0].clone()).or_default();\\n            entry.insert(eq[1].clone(), val);\\n\\n            let entry = acc.entry(eq[1].clone()).or_default();\\n            entry.insert(eq[0].clone(), 1.0 / val);\\n\\n            acc\\n        })\\n}\\n\\nfn dfs(\\n    graph: &Graph,\\n    query: Vec<String>,\\n    visited: &mut HashSet<String>,\\n    current_sum: Option<f64>,\\n) -> Option<f64> {\\n    visited.insert(query[0].clone());\\n\\n    // Check the the node exists in the graph\\n    let entry = graph.get(&query[0])?;\\n\\n    // a / a = 1.0\\n    if query[0] == query[1] {\\n        return Some(1.0);\\n    }\\n\\n    // If our current node has a direct route to our target, return it\\n    if let Some(answer) = entry.get(&query[1]) {\\n        return current_sum.map_or(Some(*answer), |s| Some(s * *answer));\\n    };\\n\\n    // Otherwise perform a DFS of connected nodes (that we haven\\'t already visited)\\n    for path in entry.keys() {\\n        if !visited.contains(path) {\\n            if let Some(val) = entry.get(path) {\\n                let result = dfs(\\n                    graph,\\n                    vec![path.clone(), query[1].clone()],\\n                    visited,\\n                    current_sum.map_or(Some(*val), |s| Some(s * *val)),\\n                );\\n                if result.is_some() {\\n                    return result;\\n                }\\n            }\\n        }\\n    }\\n    None\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720327,
                "title": "easy-to-read-union-find-solution",
                "content": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        \"\"\"\\n        union find\\n        \"\"\"\\n        # initiate union-find data structure\\n        # e.g. a / b = k\\n        # euqs[a] = b; vals[a] = k\\n        equs = {}\\n        vals = {}\\n        \\n        # find the root and corresponding value for a given variable x\\n        # so that x / root_x = value\\n        def find(x):\\n            if equs[x] != x:\\n                equs[x], v = find(equs[x])\\n                vals[x] *= v\\n            return equs[x], vals[x]\\n        \\n        # union two variables based on a pair of equation and value, update the value simultaneously\\n        def union(a, b, v):\\n            if a not in equs:\\n                equs[a] = a\\n                vals[a] = 1\\n            if b not in equs:\\n                equs[b] = b\\n                vals[b] = 1\\n            root_a, v_a = find(a)\\n            root_b, v_b = find(b)\\n            \"\"\" some math here\\n            a / b = v\\n            a / root_a = v_a\\n            b / root_b = v_b\\n            => root_a / root_b = a * v_b / b / v_a\\n            \"\"\"\\n            equs[root_a] = root_b\\n            vals[root_a] = v * v_b  / v_a\\n            \\n        # calclulate a / b\\n        def calculate(a,b):\\n            if a not in equs or b not in equs:\\n                return -1.0\\n            root_a, v_a = find(a)\\n            root_b, v_b = find(b)\\n            if root_a != root_b:\\n                return -1.0\\n            return v_a / v_b\\n        \\n        # main body\\n        for (a, b), v in zip(equations, values):\\n            union(a, b, v)\\n            \\n        return [calculate(a, b) for a, b in queries]\\n          \\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        \"\"\"\\n        union find\\n        \"\"\"\\n        # initiate union-find data structure\\n        # e.g. a / b = k\\n        # euqs[a] = b; vals[a] = k\\n        equs = {}\\n        vals = {}\\n        \\n        # find the root and corresponding value for a given variable x\\n        # so that x / root_x = value\\n        def find(x):\\n            if equs[x] != x:\\n                equs[x], v = find(equs[x])\\n                vals[x] *= v\\n            return equs[x], vals[x]\\n        \\n        # union two variables based on a pair of equation and value, update the value simultaneously\\n        def union(a, b, v):\\n            if a not in equs:\\n                equs[a] = a\\n                vals[a] = 1\\n            if b not in equs:\\n                equs[b] = b\\n                vals[b] = 1\\n            root_a, v_a = find(a)\\n            root_b, v_b = find(b)\\n            \"\"\" some math here\\n            a / b = v\\n            a / root_a = v_a\\n            b / root_b = v_b\\n            => root_a / root_b = a * v_b / b / v_a\\n            \"\"\"\\n            equs[root_a] = root_b\\n            vals[root_a] = v * v_b  / v_a\\n            \\n        # calclulate a / b\\n        def calculate(a,b):\\n            if a not in equs or b not in equs:\\n                return -1.0\\n            root_a, v_a = find(a)\\n            root_b, v_b = find(b)\\n            if root_a != root_b:\\n                return -1.0\\n            return v_a / v_b\\n        \\n        # main body\\n        for (a, b), v in zip(equations, values):\\n            union(a, b, v)\\n            \\n        return [calculate(a, b) for a, b in queries]\\n          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 441108,
                "title": "java-100-dsu-with-a-twist-explained",
                "content": "***Explanation*** \\nI use a DSU where each node carries a value. This value is the multiplicative weight with respect to the parent. In simpler words, if we have an equation (Y/X = k), we add [Y --> X] in the DSU, with **Y.value = k**. It\\'s easy to see that whenever two equations share a variable, they will be in the same DSU. Then, the query for equation a/b is going to be handled as follows:\\n- -1 if they don\\'t share the same parent (or at least one of them does not belong to any set)\\n-  The chain of products from a\\'s value to the parent _divided_ by the chain of products from b\\'s value to the parent.\\n\\nIn DSUs, we typically write the find() method so that the node points to the parent. I do the same, but we have to make sure the node\\'s value is also updated. To do that, simply multiply all values encountered until we reach the root. \\n\\nAn examples to make it clear: Notice that in the simple case of (a/b = 2), b is root with weight 1, and a is a child of b with weight 2. Then, when we add (b/c = 3), b becomes a child of c with weight updated to 3, and c is root. When we query (a/b), the system calls find(a) which returns [parent=c, value=6], and find(b) which returns [parent=c, value=3]. because parents are the same, we can return find(a).value/find(b).value = 2 (as expected). You can see that more complex scenarios will also hold.\\n\\n***Code***:\\n```\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n\\t\\n\\t\\t// Create a variable <--> Unique Integer ID mapping for DSU.\\n        Map<String, Integer> variables = new HashMap<>();\\n        int k = 0;\\n        for(List<String> pair : equations){\\n            if(!variables.containsKey(pair.get(0))) variables.put(pair.get(0), k++);\\n            if(!variables.containsKey(pair.get(1))) variables.put(pair.get(1), k++);\\n        }\\n\\t\\t\\n\\t\\t// Create and Populate DSU.\\n        int N = variables.size();\\n        DSU dsu = new DSU(N);\\n        for(int i = 0; i < equations.size(); i++){\\n            dsu.union(variables.get(equations.get(i).get(0)), variables.get(equations.get(i).get(1)), values[i]);\\n        }\\n\\t\\t\\n\\t\\t// Answer queries.\\n        double[] ans = new double[queries.size()];\\n        for(int i =0; i < ans.length; i++){\\n            if(!variables.containsKey(queries.get(i).get(0)) || !variables.containsKey(queries.get(i).get(1))){\\n               ans[i] = -1;\\n            }else{\\n                Pair px = dsu.find(variables.get(queries.get(i).get(0)));\\n                Pair py = dsu.find(variables.get(queries.get(i).get(1)));\\n                if( px.parent != py.parent) ans[i] = -1;\\n                else ans[i] = (px.value/py.value);\\n            }    \\n        }\\n        return ans;\\n    }\\n}\\n\\nclass DSU{\\n    int[] parent;\\n    double[] value;\\n    public DSU(int N){\\n        parent = new int[N];\\n        for(int i = 0; i < N; i++) parent[i] = i;\\n        value = new double[N];\\n        for(int i = 0; i < N; i++) value[i] = 1;\\n    }\\n    \\n    public Pair find(int x){\\n        if(parent[x] != x){\\n            Pair p = find(parent[x]);\\n            parent[x] = p.parent;\\n            value[x] = value[x] * p.value;\\n        }\\n        \\n        return new Pair(parent[x], value[x]);\\n    }\\n    \\n    public void union(int x, int y, double val){\\n        Pair px = find(x);\\n        Pair py = find(y);\\n        parent[px.parent] = py.parent;\\n        value[px.parent] = val * py.value / px.value;\\n    }\\n}\\n\\nclass Pair {\\n    int parent;\\n    double value;\\n    public Pair(int parent, double value){\\n        this.parent = parent;\\n        this.value = value;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n\\t\\n\\t\\t// Create a variable <--> Unique Integer ID mapping for DSU.\\n        Map<String, Integer> variables = new HashMap<>();\\n        int k = 0;\\n        for(List<String> pair : equations){\\n            if(!variables.containsKey(pair.get(0))) variables.put(pair.get(0), k++);\\n            if(!variables.containsKey(pair.get(1))) variables.put(pair.get(1), k++);\\n        }\\n\\t\\t\\n\\t\\t// Create and Populate DSU.\\n        int N = variables.size();\\n        DSU dsu = new DSU(N);\\n        for(int i = 0; i < equations.size(); i++){\\n            dsu.union(variables.get(equations.get(i).get(0)), variables.get(equations.get(i).get(1)), values[i]);\\n        }\\n\\t\\t\\n\\t\\t// Answer queries.\\n        double[] ans = new double[queries.size()];\\n        for(int i =0; i < ans.length; i++){\\n            if(!variables.containsKey(queries.get(i).get(0)) || !variables.containsKey(queries.get(i).get(1))){\\n               ans[i] = -1;\\n            }else{\\n                Pair px = dsu.find(variables.get(queries.get(i).get(0)));\\n                Pair py = dsu.find(variables.get(queries.get(i).get(1)));\\n                if( px.parent != py.parent) ans[i] = -1;\\n                else ans[i] = (px.value/py.value);\\n            }    \\n        }\\n        return ans;\\n    }\\n}\\n\\nclass DSU{\\n    int[] parent;\\n    double[] value;\\n    public DSU(int N){\\n        parent = new int[N];\\n        for(int i = 0; i < N; i++) parent[i] = i;\\n        value = new double[N];\\n        for(int i = 0; i < N; i++) value[i] = 1;\\n    }\\n    \\n    public Pair find(int x){\\n        if(parent[x] != x){\\n            Pair p = find(parent[x]);\\n            parent[x] = p.parent;\\n            value[x] = value[x] * p.value;\\n        }\\n        \\n        return new Pair(parent[x], value[x]);\\n    }\\n    \\n    public void union(int x, int y, double val){\\n        Pair px = find(x);\\n        Pair py = find(y);\\n        parent[px.parent] = py.parent;\\n        value[px.parent] = val * py.value / px.value;\\n    }\\n}\\n\\nclass Pair {\\n    int parent;\\n    double value;\\n    public Pair(int parent, double value){\\n        this.parent = parent;\\n        this.value = value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280380,
                "title": "js-solution",
                "content": "So the basic idea is to create a graph first\\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\\nvalues = [2.0, 3.0],\\n\\nFrom `a / b = 2`, we can find out that `2b = a` and `b / a = 1 / 2`\\nso, create a graph table like this\\n\\n|   | a   | b   | c |\\n|---|-----|-----|---|\\n| a |     | 2   |   |\\n| b | 1/2 |     | 3 |\\n| c |     | 1/3 |   |\\n```\\n{\\n  a: { b: 2 },\\n  b: { a: 1/2, c: 3}.\\n  c: { b: 1/3 }\\n}\\n```\\nTo find `a / c`, \\nwe need to go through `a`  --2-->  `b`  --3-->  `c`, \\nand the answer will be 2 * 3 = 6\\n\\nThen we can use BFS\\n```\\n        var visited = {};\\n        var serachList = [num1];\\n        var history = [1];\\n```\\nSearch start from `num1`\\nEvery time we see if the search Target equal to num2, if yes we return acc history\\nIf visited, skip it.\\notherwise, we add all object key from `memory[searchTarget]` to `serachList`, \\nat the same time we push new val by `history * value` \\n\\n\\n\\n```\\nvar calcEquation = function(equations, values, queries) {\\n    var memory = {};\\n    equations.forEach((eq, i) => {\\n        var num1 = eq[0];\\n        var num2 = eq[1];\\n        if (!memory[num1]) {\\n            memory[num1] = { [num2]: values[i] };\\n        } else {\\n            memory[num1][num2] = values[i];\\n        }\\n        if (!memory[num2]) {\\n            memory[num2] = { [num1]: 1 / values[i] };\\n        } else {\\n            memory[num2][num1] = 1 / values[i];\\n        }\\n    });\\n    return queries.map(function(query) {\\n        var num1 = query[0];\\n        var num2 = query[1];\\n        \\n        if (!memory[num1] || !memory[num2]) return -1;\\n        \\n        // BFS\\n        var visited = {};\\n        var serachList = [num1];\\n        var accHistory = [1];\\n        \\n        while(serachList.length > 0) {\\n            const searchItem = serachList.shift();\\n            const acc = accHistory.shift();\\n            \\n            if (searchItem === num2) return acc;\\n            if (visited[searchItem]) continue;\\n            Object.keys(memory[searchItem]).forEach(function(n) {\\n                serachList.push(n);\\n                accHistory.push(acc * memory[searchItem][n]);\\n            });\\n            visited[searchItem] = true;\\n        }\\n        return -1;\\n    });\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n{\\n  a: { b: 2 },\\n  b: { a: 1/2, c: 3}.\\n  c: { b: 1/3 }\\n}\\n```\n```\\n        var visited = {};\\n        var serachList = [num1];\\n        var history = [1];\\n```\n```\\nvar calcEquation = function(equations, values, queries) {\\n    var memory = {};\\n    equations.forEach((eq, i) => {\\n        var num1 = eq[0];\\n        var num2 = eq[1];\\n        if (!memory[num1]) {\\n            memory[num1] = { [num2]: values[i] };\\n        } else {\\n            memory[num1][num2] = values[i];\\n        }\\n        if (!memory[num2]) {\\n            memory[num2] = { [num1]: 1 / values[i] };\\n        } else {\\n            memory[num2][num1] = 1 / values[i];\\n        }\\n    });\\n    return queries.map(function(query) {\\n        var num1 = query[0];\\n        var num2 = query[1];\\n        \\n        if (!memory[num1] || !memory[num2]) return -1;\\n        \\n        // BFS\\n        var visited = {};\\n        var serachList = [num1];\\n        var accHistory = [1];\\n        \\n        while(serachList.length > 0) {\\n            const searchItem = serachList.shift();\\n            const acc = accHistory.shift();\\n            \\n            if (searchItem === num2) return acc;\\n            if (visited[searchItem]) continue;\\n            Object.keys(memory[searchItem]).forEach(function(n) {\\n                serachList.push(n);\\n                accHistory.push(acc * memory[searchItem][n]);\\n            });\\n            visited[searchItem] = true;\\n        }\\n        return -1;\\n    });\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255031,
                "title": "python-clean-solution",
                "content": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        g = collections.defaultdict(list)\\n        for equation, value in zip(equations, values):\\n            num, den = equation\\n            g[num].append((den, value))\\n            g[den].append((num, 1.0/value))\\n            \\n        res = []\\n        \\n        def calc(num, den):\\n            if num not in g or den not in g:\\n                return -1.0\\n            queue = [(num, 1.0)]\\n            seen = set()\\n            while queue:\\n                numerator, value = queue.pop(0)\\n                if numerator == den:\\n                    return value\\n                seen.add(numerator)\\n                for nei, val in g[numerator]:\\n                    if nei not in seen:\\n                        queue.append((nei, value * val))\\n\\n            return -1.0\\n                            \\n        for num, den in queries:\\n            ans = calc(num, den)\\n            res.append(ans)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        g = collections.defaultdict(list)\\n        for equation, value in zip(equations, values):\\n            num, den = equation\\n            g[num].append((den, value))\\n            g[den].append((num, 1.0/value))\\n            \\n        res = []\\n        \\n        def calc(num, den):\\n            if num not in g or den not in g:\\n                return -1.0\\n            queue = [(num, 1.0)]\\n            seen = set()\\n            while queue:\\n                numerator, value = queue.pop(0)\\n                if numerator == den:\\n                    return value\\n                seen.add(numerator)\\n                for nei, val in g[numerator]:\\n                    if nei not in seen:\\n                        queue.append((nei, value * val))\\n\\n            return -1.0\\n                            \\n        for num, den in queries:\\n            ans = calc(num, den)\\n            res.append(ans)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201842,
                "title": "swift-accepted-solution-with-comments",
                "content": "/*\\n     This is a example of how to build a graph with weighted edges\\n     if a/b = 2.0, we build a graph with first edge a-2.0->b and  b-0.5->a etc.\\n     We store all the adjacent list in a dictionary.\\n     When the query comes, c/d , we perform dfs to find if there is connection between c and d, if not, then in each c\\'s neighbor, continue search with the product of the distance\\n     */\\n\\t \\n\\t \\n\\t \\n\\t \\n    func calcEquation(_ equations: [[String]], _ values: [Double], _ queries: [[String]]) -> [Double] {\\n        guard equations.count > 0, values.count > 0, queries.count > 0 else {\\n            return [Double]()\\n        }\\n        typealias Vector = (String, Double)\\n        \\n        //Build graph\\n        var graph = [String: [Vector]]()\\n        for i in 0..<equations.count {\\n            let val = values[i]\\n            let start = equations[i][0]\\n            let end = equations[i][1]\\n            //The graph has to be bidirectional\\n            graph[start] = graph[start, default: [Vector]()] + [Vector(end, val)]\\n            graph[end] = graph[end, default: [Vector]()] + [Vector(start, 1/val)]\\n        }\\n        \\n        \\n        // we need currentVal to track the distance so far.\\n        // We need visited to record the visited nodes so that we do not go in loops\\n        func dfs(query:[String], currentVal: Double, visited:[String: Bool]) -> Double {\\n            let start = query[0]\\n            let end = query[1]\\n            if visited[start] == true {\\n                return -1.0\\n            }\\n            \\n            var visited = visited\\n            visited[start] = true\\n            \\n            guard let vectors = graph[start] else {\\n                return -1.0\\n            }\\n            \\n            for vector in vectors {\\n                if vector.0 == end {\\n                    return vector.1 * currentVal\\n                }\\n            }\\n            var value = -1.0\\n            for vector in vectors {\\n                let temp = dfs(query: [vector.0, end], currentVal: currentVal * vector.1, visited: visited)\\n                if temp != -1.0 {\\n                    value = temp\\n                }\\n            }\\n            \\n            return value\\n        }\\n        \\n        \\n        var result = [Double]()\\n        \\n        for query in queries {\\n            result.append(dfs(query: query, currentVal: 1.0, visited: [String: Bool]()))\\n        }\\n        \\n        return result\\n    }\\n\\t",
                "solutionTags": [],
                "code": "/*\\n     This is a example of how to build a graph with weighted edges\\n     if a/b = 2.0, we build a graph with first edge a-2.0->b and  b-0.5->a etc.\\n     We store all the adjacent list in a dictionary.\\n     When the query comes, c/d , we perform dfs to find if there is connection between c and d, if not, then in each c\\'s neighbor, continue search with the product of the distance\\n     */\\n\\t \\n\\t \\n\\t \\n\\t \\n    func calcEquation(_ equations: [[String]], _ values: [Double], _ queries: [[String]]) -> [Double] {\\n        guard equations.count > 0, values.count > 0, queries.count > 0 else {\\n            return [Double]()\\n        }\\n        typealias Vector = (String, Double)\\n        \\n        //Build graph\\n        var graph = [String: [Vector]]()\\n        for i in 0..<equations.count {\\n            let val = values[i]\\n            let start = equations[i][0]\\n            let end = equations[i][1]\\n            //The graph has to be bidirectional\\n            graph[start] = graph[start, default: [Vector]()] + [Vector(end, val)]\\n            graph[end] = graph[end, default: [Vector]()] + [Vector(start, 1/val)]\\n        }\\n        \\n        \\n        // we need currentVal to track the distance so far.\\n        // We need visited to record the visited nodes so that we do not go in loops\\n        func dfs(query:[String], currentVal: Double, visited:[String: Bool]) -> Double {\\n            let start = query[0]\\n            let end = query[1]\\n            if visited[start] == true {\\n                return -1.0\\n            }\\n            \\n            var visited = visited\\n            visited[start] = true\\n            \\n            guard let vectors = graph[start] else {\\n                return -1.0\\n            }\\n            \\n            for vector in vectors {\\n                if vector.0 == end {\\n                    return vector.1 * currentVal\\n                }\\n            }\\n            var value = -1.0\\n            for vector in vectors {\\n                let temp = dfs(query: [vector.0, end], currentVal: currentVal * vector.1, visited: visited)\\n                if temp != -1.0 {\\n                    value = temp\\n                }\\n            }\\n            \\n            return value\\n        }\\n        \\n        \\n        var result = [Double]()\\n        \\n        for query in queries {\\n            result.append(dfs(query: query, currentVal: 1.0, visited: [String: Bool]()))\\n        }\\n        \\n        return result\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 140948,
                "title": "javascript-unionfind",
                "content": "```js\\nfunction calcEquation(equations, values, queries) {\\n  const parent = {};\\n  const children = {};\\n  const weight = {};\\n\\n  for (let i = 0; i < values.length; i++) {\\n    union(equations[i][0], equations[i][1], values[i]);\\n  }\\n\\n  const res = [];\\n  for (let [c1, c2] of queries) {\\n    if (parent[c1] === undefined || parent[c2] === undefined || parent[c1] !== parent[c2]) {\\n      res.push(-1);\\n    } else {\\n      res.push(weight[c1] / weight[c2]);\\n    }\\n  }\\n  return res;\\n\\n  function union(v1, v2, w) {\\n    let r1 = find(v1);\\n    let r2 = find(v2);\\n\\n    if (r1 === r2) return;\\n    if (children[r1].length > children[r2].length) {\\n      [r1, r2, v1, v2, w] = [r2, r1, v2, v1, 1/w];\\n    }\\n  \\n    w *= weight[v2] / weight[v1];\\n    for (let c of children[r1]) {\\n      children[r2].push(c);\\n      parent[c] = r2;\\n      weight[c] *= w;\\n    }\\n\\n    delete children[r1];\\n  }\\n\\n  function find(v) {\\n    if (parent[v] === undefined) {\\n      parent[v] = v;\\n      children[v] = [v];\\n      weight[v] = 1;\\n    }\\n\\n    while (v !== parent[v]) {\\n      parent[v] = parent[parent[v]];\\n      v = parent[v];\\n    }\\n\\n    return v;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction calcEquation(equations, values, queries) {\\n  const parent = {};\\n  const children = {};\\n  const weight = {};\\n\\n  for (let i = 0; i < values.length; i++) {\\n    union(equations[i][0], equations[i][1], values[i]);\\n  }\\n\\n  const res = [];\\n  for (let [c1, c2] of queries) {\\n    if (parent[c1] === undefined || parent[c2] === undefined || parent[c1] !== parent[c2]) {\\n      res.push(-1);\\n    } else {\\n      res.push(weight[c1] / weight[c2]);\\n    }\\n  }\\n  return res;\\n\\n  function union(v1, v2, w) {\\n    let r1 = find(v1);\\n    let r2 = find(v2);\\n\\n    if (r1 === r2) return;\\n    if (children[r1].length > children[r2].length) {\\n      [r1, r2, v1, v2, w] = [r2, r1, v2, v1, 1/w];\\n    }\\n  \\n    w *= weight[v2] / weight[v1];\\n    for (let c of children[r1]) {\\n      children[r2].push(c);\\n      parent[c] = r2;\\n      weight[c] *= w;\\n    }\\n\\n    delete children[r1];\\n  }\\n\\n  function find(v) {\\n    if (parent[v] === undefined) {\\n      parent[v] = v;\\n      children[v] = [v];\\n      weight[v] = 1;\\n    }\\n\\n    while (v !== parent[v]) {\\n      parent[v] = parent[parent[v]];\\n      v = parent[v];\\n    }\\n\\n    return v;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 131895,
                "title": "java-2ms-union-find-solution",
                "content": "Java union find solution, which takes only 2ms and beats 100%.\\n\\nWe need a map `dict` to indicate index of each number.\\nAlso, need an integer array `parents` to indicate each number\\'s parent.\\nAt last, need a double array `valueArray` to store the ratio between each number and its root number, which means `valueArray[i] = Xi / Xroot`. \\n\\nPre step: you need to know what is Union-Find algorithm.\\nStep 1. Build `dict` and initialze `parents` and `valueArray`, which is trivial.\\nStep 2. Union every number pair in `equations`.\\nStep 3. For a number pair, let\\'s say `(X1, X2)` in `queries`\\n\\t1. if either of them is not in `dict`, then return `-1.0`\\n\\t2. if they are not connected, then return `-1.0`\\n\\t3. if they are connected, find their values. Their values will be `X1 / Xroot` and `X2 / Xroot`. And then do a division. We got `X1 / X2`, which is our answer.\\n\\n```\\nclass Solution {\\n    Map<String, Integer> dict;\\n\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n\\n        dict = new HashMap<>();\\n        int index = 0;\\n        for(int i = 0; i < equations.length; i++) {\\n            if(!dict.containsKey(equations[i][0])) {\\n                dict.put(equations[i][0], index);\\n                index++;\\n            }\\n            if(!dict.containsKey(equations[i][1])) {\\n                dict.put(equations[i][1], index);\\n                index++;\\n            }\\n        }\\n\\n        UnionFind uf = new UnionFind(equations, values);\\n\\n        double[] results = new double[queries.length];\\n        for(int i = 0; i < queries.length; i++) {\\n            if(!dict.containsKey(queries[i][0]) || !dict.containsKey(queries[i][1])) {\\n                results[i] = -1.0;\\n            } else {\\n                if(uf.find(dict.get(queries[i][0])) != uf.find(dict.get(queries[i][1]))) {\\n                    results[i] = -1.0;\\n                } else {\\n                    double dividend = uf.valueArray[dict.get(queries[i][0])];\\n                    double divisor = uf.valueArray[dict.get(queries[i][1])];\\n                    results[i] = dividend / divisor;\\n                }\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    class UnionFind {\\n        int[] parents;\\n        double[] valueArray;\\n\\n        public UnionFind(String[][] equations, double[] values) {\\n            parents = new int[dict.size()];\\n            valueArray = new double[dict.size()];\\n\\n            for(int i = 0; i < parents.length; i++) {\\n                parents[i] = i;\\n                valueArray[i] = 1;\\n            }\\n\\n            for(int i = 0; i < equations.length; i++) {\\n                union(equations[i][0], equations[i][1], values[i]);\\n            }\\n        }\\n\\n        public void union(String num1, String num2, double value) {\\n            int root = find(dict.get(num1));\\n            parents[root] = dict.get(num2);\\n            valueArray[root] = value / valueArray[dict.get(num1)];\\n        }\\n\\n        public int find(int node) {\\n            if(parents[node] == node) {\\n                return node;\\n            }\\n            int root = find(parents[node]);\\n            valueArray[node] = valueArray[node] * valueArray[parents[node]];\\n            parents[node] = root;\\n            return parents[node];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<String, Integer> dict;\\n\\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\\n\\n        dict = new HashMap<>();\\n        int index = 0;\\n        for(int i = 0; i < equations.length; i++) {\\n            if(!dict.containsKey(equations[i][0])) {\\n                dict.put(equations[i][0], index);\\n                index++;\\n            }\\n            if(!dict.containsKey(equations[i][1])) {\\n                dict.put(equations[i][1], index);\\n                index++;\\n            }\\n        }\\n\\n        UnionFind uf = new UnionFind(equations, values);\\n\\n        double[] results = new double[queries.length];\\n        for(int i = 0; i < queries.length; i++) {\\n            if(!dict.containsKey(queries[i][0]) || !dict.containsKey(queries[i][1])) {\\n                results[i] = -1.0;\\n            } else {\\n                if(uf.find(dict.get(queries[i][0])) != uf.find(dict.get(queries[i][1]))) {\\n                    results[i] = -1.0;\\n                } else {\\n                    double dividend = uf.valueArray[dict.get(queries[i][0])];\\n                    double divisor = uf.valueArray[dict.get(queries[i][1])];\\n                    results[i] = dividend / divisor;\\n                }\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    class UnionFind {\\n        int[] parents;\\n        double[] valueArray;\\n\\n        public UnionFind(String[][] equations, double[] values) {\\n            parents = new int[dict.size()];\\n            valueArray = new double[dict.size()];\\n\\n            for(int i = 0; i < parents.length; i++) {\\n                parents[i] = i;\\n                valueArray[i] = 1;\\n            }\\n\\n            for(int i = 0; i < equations.length; i++) {\\n                union(equations[i][0], equations[i][1], values[i]);\\n            }\\n        }\\n\\n        public void union(String num1, String num2, double value) {\\n            int root = find(dict.get(num1));\\n            parents[root] = dict.get(num2);\\n            valueArray[root] = value / valueArray[dict.get(num1)];\\n        }\\n\\n        public int find(int node) {\\n            if(parents[node] == node) {\\n                return node;\\n            }\\n            int root = find(parents[node]);\\n            valueArray[node] = valueArray[node] * valueArray[parents[node]];\\n            parents[node] = root;\\n            return parents[node];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88253,
                "title": "an-issue-with-x-x-where-no-equation-mentions-x",
                "content": "```\\n// input\\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\\nvalues = [2.0, 3.0],\\nqueries = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \\n\\n// standard answer\\n[6.00000,3.00000,-1.00000,1.00000,-1.00000]\\n```\\n\\n\"The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.\" \\u2014 Description\\n\\nIn this example, although \"x\" appears nowhere in the equations, the result of x/x must equal 1, since all queries, including x/x, is guaranteed to be non-division-by-zero.\\n\\nHowever, the standard answer gives x/x = unknown.",
                "solutionTags": [],
                "code": "```\\n// input\\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\\nvalues = [2.0, 3.0],\\nqueries = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \\n\\n// standard answer\\n[6.00000,3.00000,-1.00000,1.00000,-1.00000]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88234,
                "title": "python-simple-ac-solution-using-dict-of-dicts",
                "content": "This code could be more concise.\\n\\n1. Put every number into a **two-layer dictionary** to record it's multiply. \\n2. For each query pair, check whether they're in the dictionary or not.\\nIf both exist => solution must exist.\\n3. Record the multiply and the number we've visited already, keep seeking the dictionary until find out the solution.\\n\\nFor example:\\nequation = [[\"a\",\"e\"],[\"b\",\"e\"]], value = [4,3], query = [[\"a\", \"b\"]]\\n\\n1. Construct a dictionary = **{\"a\":   {\"a\":1, \"e\":4},  \"b\": {\"b\":1, \"e\":3},   \"e\": {\"a\": 1/4,  \"b\": 1/3}  }**\\n2. Follow the path: dct[\"a\"] => dct[\"e\"] => dct[\"b\"], we have query [[\"a\", \"b\"]] = **4 x 1/3** = 4/3\\n\\n```\\nclass Solution(object):\\n    def calcEquation(self, equations, values, query):\\n    \\tdef seeker(a, b, path=[]):\\n    \\t\\t# seek the result of a/b\\n    \\t\\tif a not in dct.keys() or b not in dct.keys():      # No solution\\n    \\t\\t\\treturn 0\\n    \\t\\tif b in dct[a]:                       # This is it!\\n    \\t\\t\\treturn dct[a][b]\\n    \\t\\telse:                                 # Keep looking for solution\\n    \\t\\t\\ttmp = []\\n    \\t\\t\\tfor c in dct[a].keys():\\n    \\t\\t\\t\\tif c not in path and (seeker(c, b, path+[c])):\\n    \\t\\t\\t\\t\\treturn dct[a][c]*(seeker(c, b, path+[c]))\\n\\n        dct = {}                              # Put every number into the dict\\n        for i in xrange(len(equations)):\\n        \\tnums = equations[i]\\n        \\tdiv = float(values[i])\\n        \\tif nums[0] in dct.keys():\\n        \\t\\tdct[nums[0]][nums[1]] = div\\n        \\telse:\\n        \\t\\tdct[nums[0]] = {nums[0]:1, nums[1]:div}\\n        \\tif nums[1] in dct.keys():\\n        \\t\\tdct[nums[1]][nums[0]] = 1.0/div\\n        \\telse:\\n        \\t\\tdct[nums[1]] = {nums[1]:1, nums[0]:1.0/div}\\n\\n        res = []\\n        for pair in query:                    # seek the solution\\n        \\tif seeker(pair[0], pair[1]):\\n        \\t\\tres += seeker(pair[0], pair[1]),\\n        \\telse:\\n        \\t\\tres += -1,\\n\\n        return [float(n) for n in res]\\n```\\n**EDIT:**\\nThanks to @WKVictor 's simplification, it improved from 45ms -> 32ms.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def calcEquation(self, equations, values, query):\\n    \\tdef seeker(a, b, path=[]):\\n    \\t\\t# seek the result of a/b\\n    \\t\\tif a not in dct.keys() or b not in dct.keys():      # No solution\\n    \\t\\t\\treturn 0\\n    \\t\\tif b in dct[a]:                       # This is it!\\n    \\t\\t\\treturn dct[a][b]\\n    \\t\\telse:                                 # Keep looking for solution\\n    \\t\\t\\ttmp = []\\n    \\t\\t\\tfor c in dct[a].keys():\\n    \\t\\t\\t\\tif c not in path and (seeker(c, b, path+[c])):\\n    \\t\\t\\t\\t\\treturn dct[a][c]*(seeker(c, b, path+[c]))\\n\\n        dct = {}                              # Put every number into the dict\\n        for i in xrange(len(equations)):\\n        \\tnums = equations[i]\\n        \\tdiv = float(values[i])\\n        \\tif nums[0] in dct.keys():\\n        \\t\\tdct[nums[0]][nums[1]] = div\\n        \\telse:\\n        \\t\\tdct[nums[0]] = {nums[0]:1, nums[1]:div}\\n        \\tif nums[1] in dct.keys():\\n        \\t\\tdct[nums[1]][nums[0]] = 1.0/div\\n        \\telse:\\n        \\t\\tdct[nums[1]] = {nums[1]:1, nums[0]:1.0/div}\\n\\n        res = []\\n        for pair in query:                    # seek the solution\\n        \\tif seeker(pair[0], pair[1]):\\n        \\t\\tres += seeker(pair[0], pair[1]),\\n        \\telse:\\n        \\t\\tres += -1,\\n\\n        return [float(n) for n in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859698,
                "title": "c-simple-dfs-100-faster",
                "content": "# Intuition\\n<!-- for each pair in each equation  connect these pairs\\n    for eg. a->b =2 then also make a edge b->a with value 1/2  -->\\n\\n# Approach\\n<!-- unordered_map for adjacency matrix \\n     unordered_set for visited array\\nsimply used dfs to reach the denominator from numerator of each queries if there is path then i multiply edge weight dfs -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void dfs(string node,string &dest, unordered_map<string,vector<pair<string,double>>> &mp,double &val,double &res,unordered_set<string> &vis)\\n   {\\n       if(vis.find(node)!=vis.end()) return ;\\n       vis.insert(node);\\n       if(node==dest) \\n       {\\n           res=val;\\n           return ;\\n       }\\n       \\n\\n\\n        for(auto it : mp[node])\\n        {\\n            if(vis.find(it.first)==vis.end())\\n            {\\n                double val1=val;\\n                val=val*it.second;\\n                dfs(it.first,dest,mp,val,res,vis);\\n                val=val1;\\n            }\\n            \\n        }\\n   }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double> ans;\\n        unordered_map<string,vector<pair<string,double>>> mp;\\n        for(int i=0;i<equations.size();i++)\\n        {\\n            string node=equations[i][0];\\n            string dest=equations[i][1];\\n            double val=values[i];\\n            mp[node].push_back({dest,val});\\n            mp[dest].push_back({node,(1.0/(1.0*val))});\\n        }\\n        for(int i=0;i<queries.size();i++)\\n        {\\n           \\n            string node=queries[i][0];\\n            string dest=queries[i][1];\\n            \\n            if(mp.find(node)==mp.end() or mp.find(dest)==mp.end())\\n            {\\n                ans.push_back(-1);\\n            }\\n            else\\n            {\\n                 unordered_set<string> vis;\\n                 double val=1.0,res=-1;\\n                 dfs(node,dest,mp,val,res,vis); \\n                 ans.push_back(res);\\n            }\\n          \\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(string node,string &dest, unordered_map<string,vector<pair<string,double>>> &mp,double &val,double &res,unordered_set<string> &vis)\\n   {\\n       if(vis.find(node)!=vis.end()) return ;\\n       vis.insert(node);\\n       if(node==dest) \\n       {\\n           res=val;\\n           return ;\\n       }\\n       \\n\\n\\n        for(auto it : mp[node])\\n        {\\n            if(vis.find(it.first)==vis.end())\\n            {\\n                double val1=val;\\n                val=val*it.second;\\n                dfs(it.first,dest,mp,val,res,vis);\\n                val=val1;\\n            }\\n            \\n        }\\n   }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double> ans;\\n        unordered_map<string,vector<pair<string,double>>> mp;\\n        for(int i=0;i<equations.size();i++)\\n        {\\n            string node=equations[i][0];\\n            string dest=equations[i][1];\\n            double val=values[i];\\n            mp[node].push_back({dest,val});\\n            mp[dest].push_back({node,(1.0/(1.0*val))});\\n        }\\n        for(int i=0;i<queries.size();i++)\\n        {\\n           \\n            string node=queries[i][0];\\n            string dest=queries[i][1];\\n            \\n            if(mp.find(node)==mp.end() or mp.find(dest)==mp.end())\\n            {\\n                ans.push_back(-1);\\n            }\\n            else\\n            {\\n                 unordered_set<string> vis;\\n                 double val=1.0,res=-1;\\n                 dfs(node,dest,mp,val,res,vis); \\n                 ans.push_back(res);\\n            }\\n          \\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827737,
                "title": "bfs-observation-intuition-approach",
                "content": "# Observation\\n- We do not need to find the actual values of the strings from the equation since we are asked to find the ratios of the string in the queries.\\n- Let say we have `equations = [[\"a\",\"b\"],[\"b\",\"c\"]]`, `values = [1.0,2.0]` and `queries = [\"a\",\"c\"]`. So to find the value of the query we need to from equations[0] to equations[1] and for more general case from equations[i] ... equations[j].\\n\\n# Intuition\\n\\n- How do I know that problem is based on graph ?\\nAns :  From observations we can conclude that to find the value of the query we need to connect the some equation to some other equation which may be further connected to some other equation.\\n- So to find the connections we use graph.\\n# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Let say we have `equations =`[[\"a\",\"b\"],[\"e\",\"f\"],[\"b\",\"e\"],[\\u201Dx\\u201D,\\u201Dy\\u201D]] and `values =` [3.4,1.4,2.3,2.0].\\n- So first I am finding adjacent node of equations[i]. Nodes are adjacent if any of the string in a is present in b. The Idea is : once we find the all the adjacent node to current node and then we assign them in one group. Since we need to find the ratio of strings in queries we will assign any one string in that group as one and then calculate the corresponding values of the string.\\n- Like in the above case [\\u201Da\\u201D,\\u201Db\\u201D,\\u201De\\u201D,\\u201Df\\u201D] and [\\u201Dx\\u201D,\\u201Dy\\u201D] will be two groups. If I assign \\u201Ca\\u201D = 1 & \\u201Cx\\u201D = 1 we can calculate corresponding values in group by given equations.\\n- In BFS part we take a node assign it one find all the adjacent node simultaneously calculating correspoing values of the string and storing it in map. We we visit all the adjacent member in one group we move to another group.\\n- **Note** : If two string are present in unordered map mpp but not in same group we will not be able to find its value. Like we will not be able to find the query of [\\u201Da\\u201D,\\u201Dx\\u201D].\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool adjacent(vector<string>& a,vector<string>& b){\\n        if(a[0]==b[0] || a[0]==b[1]) return true;\\n        if(a[1]==b[0] || a[1]==b[1]) return true;\\n        return false;\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& eqa, vector<double>& values, vector<vector<string>>& queries) {\\n        unordered_map<string,double> mpp;\\n        int n = eqa.size();\\n        vector<int> visited(n,false);\\n        vector<vector<int>> adj(n,vector<int>());\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(i==j) continue;\\n                if(adjacent(eqa[i],eqa[j])){\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        queue<int> que;\\n        vector<unordered_set<string>> vec(n);\\n        int t = 0;\\n        for(int i=0;i<n;i++){\\n            if(visited[i]) continue;\\n            que.push(i);\\n            while(!que.empty()){\\n                int curInd = que.front();que.pop();\\n                if(visited[curInd]) continue;\\n                visited[curInd] = true;\\n                string a = eqa[curInd][0];\\n                string b = eqa[curInd][1];\\n                vec[t].insert(a);\\n                vec[t].insert(b);\\n                if(mpp.find(a)!=mpp.end()){\\n                    mpp[b] = mpp[a]/values[curInd];\\n                }\\n                else if(mpp.find(b)!=mpp.end()){\\n                    mpp[a] = mpp[b]*values[curInd];\\n                }\\n                else{\\n                    mpp[b] = 1.0;\\n                    mpp[a] = values[curInd]*mpp[b];\\n                }\\n                for(int nei:adj[curInd]){\\n                    if(visited[nei]) continue;\\n                    que.push(nei);\\n                }\\n            }\\n            t++;\\n        }\\n        vector<double> res;\\n        for(auto que:queries){\\n            string a = que[0];\\n            string b = que[1];\\n            int z = vec.size();\\n            bool valid = false;\\n            for(int i=0;i<z;i++){\\n                if(vec[i].count(a) && vec[i].count(b)){\\n                    res.push_back(mpp[a]/mpp[b]);\\n                    valid = true;\\n                    break;\\n                }\\n            }\\n            if(!valid){\\n                res.push_back(-1);\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```\\n**Please Upvote** \\uD83E\\uDD79",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool adjacent(vector<string>& a,vector<string>& b){\\n        if(a[0]==b[0] || a[0]==b[1]) return true;\\n        if(a[1]==b[0] || a[1]==b[1]) return true;\\n        return false;\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& eqa, vector<double>& values, vector<vector<string>>& queries) {\\n        unordered_map<string,double> mpp;\\n        int n = eqa.size();\\n        vector<int> visited(n,false);\\n        vector<vector<int>> adj(n,vector<int>());\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(i==j) continue;\\n                if(adjacent(eqa[i],eqa[j])){\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        queue<int> que;\\n        vector<unordered_set<string>> vec(n);\\n        int t = 0;\\n        for(int i=0;i<n;i++){\\n            if(visited[i]) continue;\\n            que.push(i);\\n            while(!que.empty()){\\n                int curInd = que.front();que.pop();\\n                if(visited[curInd]) continue;\\n                visited[curInd] = true;\\n                string a = eqa[curInd][0];\\n                string b = eqa[curInd][1];\\n                vec[t].insert(a);\\n                vec[t].insert(b);\\n                if(mpp.find(a)!=mpp.end()){\\n                    mpp[b] = mpp[a]/values[curInd];\\n                }\\n                else if(mpp.find(b)!=mpp.end()){\\n                    mpp[a] = mpp[b]*values[curInd];\\n                }\\n                else{\\n                    mpp[b] = 1.0;\\n                    mpp[a] = values[curInd]*mpp[b];\\n                }\\n                for(int nei:adj[curInd]){\\n                    if(visited[nei]) continue;\\n                    que.push(nei);\\n                }\\n            }\\n            t++;\\n        }\\n        vector<double> res;\\n        for(auto que:queries){\\n            string a = que[0];\\n            string b = que[1];\\n            int z = vec.size();\\n            bool valid = false;\\n            for(int i=0;i<z;i++){\\n                if(vec[i].count(a) && vec[i].count(b)){\\n                    res.push_back(mpp[a]/mpp[b]);\\n                    valid = true;\\n                    break;\\n                }\\n            }\\n            if(!valid){\\n                res.push_back(-1);\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544946,
                "title": "dfs-c",
                "content": "```\\nclass Solution {\\n    bool dfs(string node, string des, unordered_map<string, vector<pair<string, double>>> &adj, unordered_set<string> &vis, double p, double &ans) {\\n        if(node == des) {\\n            ans = p;\\n            return true;\\n        }\\n        vis.insert(node);\\n\\n        for(auto ad : adj[node]) {\\n            double dis = ad.second;\\n            string adNode = ad.first;\\n\\n            if(vis.find(adNode) == vis.end()) {\\n                if(dfs(adNode, des, adj, vis, p * dis, ans)) return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n = equations.size();\\n        unordered_map<string, vector<pair<string, double>>> adj;\\n        unordered_set<string> seen;\\n\\n        for(int i=0; i<n; i++) {\\n            adj[equations[i][0]].push_back({equations[i][1], values[i]});\\n            adj[equations[i][1]].push_back({equations[i][0], 1 / values[i]});\\n            seen.insert(equations[i][0]);\\n            seen.insert(equations[i][1]);\\n        }\\n\\n        vector<double> ans;\\n        for(auto q : queries) {\\n            string source = q[0], dest = q[1];\\n            if(seen.find(source) == seen.end() || seen.find(dest) == seen.end()) ans.push_back(-1);\\n            else {\\n                double val;\\n                unordered_set<string> vis;\\n                if(dfs(source, dest, adj, vis, 1, val)) ans.push_back(val);\\n                else ans.push_back(-1);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(string node, string des, unordered_map<string, vector<pair<string, double>>> &adj, unordered_set<string> &vis, double p, double &ans) {\\n        if(node == des) {\\n            ans = p;\\n            return true;\\n        }\\n        vis.insert(node);\\n\\n        for(auto ad : adj[node]) {\\n            double dis = ad.second;\\n            string adNode = ad.first;\\n\\n            if(vis.find(adNode) == vis.end()) {\\n                if(dfs(adNode, des, adj, vis, p * dis, ans)) return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n = equations.size();\\n        unordered_map<string, vector<pair<string, double>>> adj;\\n        unordered_set<string> seen;\\n\\n        for(int i=0; i<n; i++) {\\n            adj[equations[i][0]].push_back({equations[i][1], values[i]});\\n            adj[equations[i][1]].push_back({equations[i][0], 1 / values[i]});\\n            seen.insert(equations[i][0]);\\n            seen.insert(equations[i][1]);\\n        }\\n\\n        vector<double> ans;\\n        for(auto q : queries) {\\n            string source = q[0], dest = q[1];\\n            if(seen.find(source) == seen.end() || seen.find(dest) == seen.end()) ans.push_back(-1);\\n            else {\\n                double val;\\n                unordered_set<string> vis;\\n                if(dfs(source, dest, adj, vis, 1, val)) ans.push_back(val);\\n                else ans.push_back(-1);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544770,
                "title": "0-ms-100-c-2-kinds-of-dfs-solution-with-graph-info",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis looks like  a directed graph problem. Every pair (A,B) given in equations denotes a directed edge; the ratio  in values denotes the weight. The pair (C, D) in queries is just a question to ask whether there exists a path from C to D. \\n\\nThis program took me hours to complete. For debugging, I wrote a method print_graph() to print out all the information on the test graph. \\n\\nedges:[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"d\"] with a/b=2, c/b=3,  d/b= 4,w/d=8\\ncan use dfs to construct a path abdw \\nwe got a/w=(a/b) * (b/d)* (d/w)= 2*(1/4)*(1/8)=1/16\\n\\nThe second solution offers an idea to use dfs algorithm find out all of paths within a connected components. The paths will be added to the graph.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nTest graph:\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n```\\n       \\\\       a,       b,       c,       d,       w,       x,       y,       z,\\n       a       1,       2,       0,       0,       0,       0,       0,       0,\\n       b     0.5,       1,0.333333,    0.25,       0,       0,       0,       0,\\n       c       0,       3,       1,       0,       0,       0,       0,       0,\\n       d       0,       4,       0,       1,   0.125,       0,       0,       0,\\n       w       0,       0,       0,       8,       1,       5,       0,       0,\\n       x       0,       0,       0,       0,     0.2,       1,0.166667,0.142857,\\n       y       0,       0,       0,       0,       0,       6,       1,       0,\\n       z       0,       0,       0,       0,       0,       7,       0,       1,\\n===================\\n\\nIf considering adding all paths into the graph\\n\\n       \\\\       a,       b,       c,       d,       w,       x,       y,       z,\\n       a       1,       2,0.666667,     0.5,  0.0625,  0.3125,0.0520833,0.0446429,\\n       b     0.5,       1,0.333333,    0.25, 0.03125, 0.15625,0.0260417,0.0223214,\\n       c     1.5,       3,       1,    0.75, 0.09375, 0.46875,0.078125,0.0669643,\\n       d       2,       4, 1.33333,       1,   0.125,   0.625,0.104167,0.0892857,\\n       w      16,      32, 10.6667,       8,       1,       5,0.833333,0.714286,\\n       x     3.2,     6.4, 2.13333,     1.6,     0.2,       1,0.166667,0.142857,\\n       y    19.2,    38.4,    12.8,     9.6,     1.2,       6,       1,0.857143,\\n       z    22.4,    44.8, 14.9333,    11.2,     1.4,       7, 1.16667,       1,\\n===================\\n\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> v_i;\\n    vector<string> v;\\n    double graph[40][40]={0};\\n    int v_size=0;\\n\\n    void find_graph(vector<vector<string>>& equations, vector<double>& values, int n)\\n    {\\n        int x, y;\\n        for(int i=0; i<n; i++){\\n            vector<string> e=equations[i];\\n            if (v_i.count(e[0])==0){\\n                v.push_back(e[0]);\\n                v_i[e[0]]=v_size++;\\n            }\\n            if (v_i.count(e[1])==0){\\n                v.push_back(e[1]);\\n                v_i[e[1]]=v_size++;\\n            }\\n            x=v_i[e[0]];\\n            y=v_i[e[1]];\\n            graph[x][x]=1;\\n            graph[y][y]=1;\\n            graph[x][y]=values[i];\\n            graph[y][x]=1/values[i];\\n        }\\n    }\\n///The following function print graph for debug\\n    void print_graph(){\\n        cout<<setw(8)<<\"\\\\\\\\\";\\n        for (int i=0; i<v_size; i++)\\n            cout<<setw(8)<<v[i]<<\",\";\\n        cout<<endl;\\n        for(int i=0; i<v_size; i++){\\n            cout<<setw(8)<<v[i];\\n            for(int j=0; j<v_size; j++){\\n                cout<<setw(8)<<graph[i][j]<<\",\";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<\"===================\\\\n\";\\n    }\\n///////////////////////////\\n\\n    void dfs(int x, int z, unordered_set<int>& visited, double w, double& a){\\n        if (x==z){\\n            a=w;\\n            return ;\\n        }            \\n        visited.insert(x);\\n        for(int y=0; y<v_size; y++){\\n            if (graph[x][y]!=0  && visited.count(y)==0)\\n                dfs(y, z, visited, w*graph[x][y], a);        \\n        }      \\n    }\\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=values.size();\\n        find_graph(equations, values, n);\\n//        print_graph();\\n\\n        int m=queries.size();\\n\\n        vector<double> ans(m , -1);\\n        for(int i=0; i<m; i++){\\n            vector<string> q=queries[i];\\n            if (v_i.count(q[0])!=0 && v_i.count(q[1])!=0){\\n                int c=v_i[q[0]], d=v_i[q[1]];\\n                if (graph[c][d]!=0)\\n                    ans[i]=graph[c][d];\\n                else{\\n                    unordered_set<int> visited;\\n                    dfs(c, d, visited, 1, ans[i]);\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```\\nSecond Solution also beats 100%\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> v_i;\\n    vector<string> v;\\n    double graph[29][29]={0};\\n    int v_size=0;\\n\\n    void find_graph(vector<vector<string>>& equations, vector<double>& values, int n)\\n    {\\n        int x, y;\\n        for(int i=0; i<n; i++){\\n            vector<string> e=equations[i];\\n            if (v_i.count(e[0])==0){\\n                v.push_back(e[0]);\\n                v_i[e[0]]=v_size++;\\n            }\\n            if (v_i.count(e[1])==0){\\n                v.push_back(e[1]);\\n                v_i[e[1]]=v_size++;\\n            }\\n            x=v_i[e[0]];\\n            y=v_i[e[1]];\\n            graph[x][x]=1;\\n            graph[y][y]=1;\\n            graph[x][y]=values[i];\\n            graph[y][x]=1/values[i];\\n        }\\n    }\\n///The following function print graph for debug\\n    void print_graph(){\\n        cout<<setw(8)<<\"\\\\\\\\\";\\n        for (int i=0; i<v_size; i++)\\n            cout<<setw(8)<<v[i]<<\",\";\\n        cout<<endl;\\n        for(int i=0; i<v_size; i++){\\n            cout<<setw(8)<<v[i];\\n            for(int j=0; j<v_size; j++){\\n                cout<<setw(8)<<graph[i][j]<<\",\";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<\"===================\\\\n\";\\n    }\\n///////////////////////////\\n\\n    void dfs(int x, unordered_set<int>& visited){\\n        visited.insert(x);\\n        for(int y=0; y<v_size; y++){\\n            if (graph[x][y]!=0  && visited.count(y)==0){\\n                double w=graph[x][y];\\n                visited.insert(y);\\n                for (int z=0; z<v_size; z++){\\n                    if (graph[y][z]!=0  && visited.count(z)==0){\\n                        double w2=graph[y][z];\\n                        graph[x][z]=w*w2;\\n                        graph[z][x]=1.0/graph[x][z];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=values.size();\\n        find_graph(equations, values, n);\\n//      print_graph();\\n\\n        int m=queries.size();\\n        for(int x=0; x<v_size; x++){\\n            unordered_set<int> visited;\\n            dfs(x, visited);\\n        }\\n //       print_graph();\\n\\n        vector<double> ans(m , -1);\\n        for(int i=0; i<m; i++){\\n            vector<string> q=queries[i];\\n            if (v_i.count(q[0])!=0 && v_i.count(q[1])!=0){\\n                int c=v_i[q[0]], d=v_i[q[1]];\\n                if (graph[c][d]!=0)\\n                    ans[i]=graph[c][d];\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n       \\\\       a,       b,       c,       d,       w,       x,       y,       z,\\n       a       1,       2,       0,       0,       0,       0,       0,       0,\\n       b     0.5,       1,0.333333,    0.25,       0,       0,       0,       0,\\n       c       0,       3,       1,       0,       0,       0,       0,       0,\\n       d       0,       4,       0,       1,   0.125,       0,       0,       0,\\n       w       0,       0,       0,       8,       1,       5,       0,       0,\\n       x       0,       0,       0,       0,     0.2,       1,0.166667,0.142857,\\n       y       0,       0,       0,       0,       0,       6,       1,       0,\\n       z       0,       0,       0,       0,       0,       7,       0,       1,\\n===================\\n\\nIf considering adding all paths into the graph\\n\\n       \\\\       a,       b,       c,       d,       w,       x,       y,       z,\\n       a       1,       2,0.666667,     0.5,  0.0625,  0.3125,0.0520833,0.0446429,\\n       b     0.5,       1,0.333333,    0.25, 0.03125, 0.15625,0.0260417,0.0223214,\\n       c     1.5,       3,       1,    0.75, 0.09375, 0.46875,0.078125,0.0669643,\\n       d       2,       4, 1.33333,       1,   0.125,   0.625,0.104167,0.0892857,\\n       w      16,      32, 10.6667,       8,       1,       5,0.833333,0.714286,\\n       x     3.2,     6.4, 2.13333,     1.6,     0.2,       1,0.166667,0.142857,\\n       y    19.2,    38.4,    12.8,     9.6,     1.2,       6,       1,0.857143,\\n       z    22.4,    44.8, 14.9333,    11.2,     1.4,       7, 1.16667,       1,\\n===================\\n\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> v_i;\\n    vector<string> v;\\n    double graph[40][40]={0};\\n    int v_size=0;\\n\\n    void find_graph(vector<vector<string>>& equations, vector<double>& values, int n)\\n    {\\n        int x, y;\\n        for(int i=0; i<n; i++){\\n            vector<string> e=equations[i];\\n            if (v_i.count(e[0])==0){\\n                v.push_back(e[0]);\\n                v_i[e[0]]=v_size++;\\n            }\\n            if (v_i.count(e[1])==0){\\n                v.push_back(e[1]);\\n                v_i[e[1]]=v_size++;\\n            }\\n            x=v_i[e[0]];\\n            y=v_i[e[1]];\\n            graph[x][x]=1;\\n            graph[y][y]=1;\\n            graph[x][y]=values[i];\\n            graph[y][x]=1/values[i];\\n        }\\n    }\\n///The following function print graph for debug\\n    void print_graph(){\\n        cout<<setw(8)<<\"\\\\\\\\\";\\n        for (int i=0; i<v_size; i++)\\n            cout<<setw(8)<<v[i]<<\",\";\\n        cout<<endl;\\n        for(int i=0; i<v_size; i++){\\n            cout<<setw(8)<<v[i];\\n            for(int j=0; j<v_size; j++){\\n                cout<<setw(8)<<graph[i][j]<<\",\";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<\"===================\\\\n\";\\n    }\\n///////////////////////////\\n\\n    void dfs(int x, int z, unordered_set<int>& visited, double w, double& a){\\n        if (x==z){\\n            a=w;\\n            return ;\\n        }            \\n        visited.insert(x);\\n        for(int y=0; y<v_size; y++){\\n            if (graph[x][y]!=0  && visited.count(y)==0)\\n                dfs(y, z, visited, w*graph[x][y], a);        \\n        }      \\n    }\\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=values.size();\\n        find_graph(equations, values, n);\\n//        print_graph();\\n\\n        int m=queries.size();\\n\\n        vector<double> ans(m , -1);\\n        for(int i=0; i<m; i++){\\n            vector<string> q=queries[i];\\n            if (v_i.count(q[0])!=0 && v_i.count(q[1])!=0){\\n                int c=v_i[q[0]], d=v_i[q[1]];\\n                if (graph[c][d]!=0)\\n                    ans[i]=graph[c][d];\\n                else{\\n                    unordered_set<int> visited;\\n                    dfs(c, d, visited, 1, ans[i]);\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> v_i;\\n    vector<string> v;\\n    double graph[29][29]={0};\\n    int v_size=0;\\n\\n    void find_graph(vector<vector<string>>& equations, vector<double>& values, int n)\\n    {\\n        int x, y;\\n        for(int i=0; i<n; i++){\\n            vector<string> e=equations[i];\\n            if (v_i.count(e[0])==0){\\n                v.push_back(e[0]);\\n                v_i[e[0]]=v_size++;\\n            }\\n            if (v_i.count(e[1])==0){\\n                v.push_back(e[1]);\\n                v_i[e[1]]=v_size++;\\n            }\\n            x=v_i[e[0]];\\n            y=v_i[e[1]];\\n            graph[x][x]=1;\\n            graph[y][y]=1;\\n            graph[x][y]=values[i];\\n            graph[y][x]=1/values[i];\\n        }\\n    }\\n///The following function print graph for debug\\n    void print_graph(){\\n        cout<<setw(8)<<\"\\\\\\\\\";\\n        for (int i=0; i<v_size; i++)\\n            cout<<setw(8)<<v[i]<<\",\";\\n        cout<<endl;\\n        for(int i=0; i<v_size; i++){\\n            cout<<setw(8)<<v[i];\\n            for(int j=0; j<v_size; j++){\\n                cout<<setw(8)<<graph[i][j]<<\",\";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<\"===================\\\\n\";\\n    }\\n///////////////////////////\\n\\n    void dfs(int x, unordered_set<int>& visited){\\n        visited.insert(x);\\n        for(int y=0; y<v_size; y++){\\n            if (graph[x][y]!=0  && visited.count(y)==0){\\n                double w=graph[x][y];\\n                visited.insert(y);\\n                for (int z=0; z<v_size; z++){\\n                    if (graph[y][z]!=0  && visited.count(z)==0){\\n                        double w2=graph[y][z];\\n                        graph[x][z]=w*w2;\\n                        graph[z][x]=1.0/graph[x][z];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=values.size();\\n        find_graph(equations, values, n);\\n//      print_graph();\\n\\n        int m=queries.size();\\n        for(int x=0; x<v_size; x++){\\n            unordered_set<int> visited;\\n            dfs(x, visited);\\n        }\\n //       print_graph();\\n\\n        vector<double> ans(m , -1);\\n        for(int i=0; i<m; i++){\\n            vector<string> q=queries[i];\\n            if (v_i.count(q[0])!=0 && v_i.count(q[1])!=0){\\n                int c=v_i[q[0]], d=v_i[q[1]];\\n                if (graph[c][d]!=0)\\n                    ans[i]=graph[c][d];\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3544284,
                "title": "python-short-and-clean-dfs-functional-programming",
                "content": "# Approach\\n1. Convert `equations` into a Directed-Weighted-Graph, such that an equation of form `a / b = v` will have two edges; `a -> b with weight v` and `b -> a with weight (1 / v)`\\n\\n2. For each query `[s, d]`, use DFS to find a path from `s` to `d` in the graph and return the product of it\\'s weights.\\n\\n# Complexity\\n- Time complexity: $$O(n * k)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere,\\n`n is the number of equations`,\\n`k is the number of queries`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def calcEquation(self, equations: list[list[str]], values: list[float], queries: list[list[str]]) -> list[float]:\\n        T = Hashable\\n        W = int | float\\n        WeightedGraph = Mapping[T, Mapping[T, W]]\\n        def solve_div(graph: WeightedGraph, src: T, dest: T, seen: set[T]) -> W:\\n            seen.add(src)\\n            q = next((\\n                graph[src][v] * x\\n                for v in graph[src]\\n                if v not in seen and\\n                (x := solve_div(graph, v, dest, seen)) != -1\\n            ), -1) if src != dest else 1\\n            seen.remove(src)\\n            return q\\n        \\n        g = defaultdict(lambda: defaultdict(int))\\n        for (n, d), v in zip(equations, values): g[n][d] = v; g[d][n] = 1 / v\\n\\n        return [solve_div(g, s, d, set()) if s in g and d in g else -1 for s, d in queries]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```python\\nclass Solution:\\n    def calcEquation(self, equations: list[list[str]], values: list[float], queries: list[list[str]]) -> list[float]:\\n        T = Hashable\\n        W = int | float\\n        WeightedGraph = Mapping[T, Mapping[T, W]]\\n        def solve_div(graph: WeightedGraph, src: T, dest: T, seen: set[T]) -> W:\\n            seen.add(src)\\n            q = next((\\n                graph[src][v] * x\\n                for v in graph[src]\\n                if v not in seen and\\n                (x := solve_div(graph, v, dest, seen)) != -1\\n            ), -1) if src != dest else 1\\n            seen.remove(src)\\n            return q\\n        \\n        g = defaultdict(lambda: defaultdict(int))\\n        for (n, d), v in zip(equations, values): g[n][d] = v; g[d][n] = 1 / v\\n\\n        return [solve_div(g, s, d, set()) if s in g and d in g else -1 for s, d in queries]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544278,
                "title": "easy-dfs-java-solution-beats-100-in-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif a/b then consider it to be an edge from a to b with the value of $$value[i]$$ and b to a with the value of $$1/value[i]$$ and for every numerator and denominator(in the $$equations$$) map it to the number(just to make things easy while indexing).\\nThen create the adjacency matrix for the same traversing the $$equations$$ list.\\nAt last just do dfs traversal for every $$queries$$ .\\nImportant thing to remember is while moving from one node to another the weight of the edges get **multiplied** and not get **added**.\\nFor example .suppose there is an edge from a->b and b->c ,suppose we need the value from a->c, we do a/b*b/c and not a/b +b/c.\\n*****Thank YOu please upvote GUzs..**\\n***\\n# Code\\n```\\nclass Solution {\\n    double ch(double[][] a,int s,int j,int[]v){\\n        v[s]=1;\\n        \\n        for(int i=0;i<a.length;i++){\\n            if(i==j && a[s][i]!=0) return a[s][i];\\n            if(a[s][i]!=0 && v[i]==0){\\n                double x = ch(a,i,j,v);\\n                if(x!=-1)\\n                return x*a[s][i];\\n            }\\n        }\\n        return -1;\\n    }\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        int c=0;\\n        for(int i=0;i<values.length;i++){\\n            if(hm.get(equations.get(i).get(0))==null)\\n            hm.put(equations.get(i).get(0),c++);\\n            if(hm.get(equations.get(i).get(1))==null)\\n            hm.put(equations.get(i).get(1),c++);\\n        }\\n        double[][] ad = new double[c][c];\\n        for(int i=0;i<values.length;i++){\\n            ad[hm.get(equations.get(i).get(0))][hm.get(equations.get(i).get(1))] = values[i];\\n            \\n            ad[hm.get(equations.get(i).get(1))][hm.get(equations.get(i).get(0))] = 1/values[i];\\n            \\n\\n        }\\n        int[] v = new int[c];\\n        double[] ans = new double[queries.size()];\\n        for(int i=0;i<queries.size();i++){\\n            Arrays.fill(v,0);\\n            if(hm.get(queries.get(i).get(0))==null || hm.get(queries.get(i).get(1))==null) ans[i]=-1;\\n            else\\n            ans[i] = ch(ad,hm.get(queries.get(i).get(0)),hm.get(queries.get(i).get(1)),v);\\n    }\\n           \\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    double ch(double[][] a,int s,int j,int[]v){\\n        v[s]=1;\\n        \\n        for(int i=0;i<a.length;i++){\\n            if(i==j && a[s][i]!=0) return a[s][i];\\n            if(a[s][i]!=0 && v[i]==0){\\n                double x = ch(a,i,j,v);\\n                if(x!=-1)\\n                return x*a[s][i];\\n            }\\n        }\\n        return -1;\\n    }\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        int c=0;\\n        for(int i=0;i<values.length;i++){\\n            if(hm.get(equations.get(i).get(0))==null)\\n            hm.put(equations.get(i).get(0),c++);\\n            if(hm.get(equations.get(i).get(1))==null)\\n            hm.put(equations.get(i).get(1),c++);\\n        }\\n        double[][] ad = new double[c][c];\\n        for(int i=0;i<values.length;i++){\\n            ad[hm.get(equations.get(i).get(0))][hm.get(equations.get(i).get(1))] = values[i];\\n            \\n            ad[hm.get(equations.get(i).get(1))][hm.get(equations.get(i).get(0))] = 1/values[i];\\n            \\n\\n        }\\n        int[] v = new int[c];\\n        double[] ans = new double[queries.size()];\\n        for(int i=0;i<queries.size();i++){\\n            Arrays.fill(v,0);\\n            if(hm.get(queries.get(i).get(0))==null || hm.get(queries.get(i).get(1))==null) ans[i]=-1;\\n            else\\n            ans[i] = ch(ad,hm.get(queries.get(i).get(0)),hm.get(queries.get(i).get(1)),v);\\n    }\\n           \\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543304,
                "title": "c-beats-100-depth-first-search",
                "content": "# Code\\n```\\nclass Solution {\\n    unordered_map<string, unordered_map<string, double>> edges; \\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double> ans; ans.reserve(queries.size());\\n        int m = equations.size(); \\n        for(int i = 0; i < m; i++){\\n            edges[equations[i][0]][equations[i][1]] = values[i]; \\n            edges[equations[i][1]][equations[i][0]] = 1 / values[i]; \\n        }\\n        unordered_set<string> visited;\\n        for(int i = 0; i < queries.size(); i++){\\n            if(edges.count(queries[i][0]) == 0 or edges.count(queries[i][1]) == 0){\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            visited.insert(queries[i][0]); \\n            ans.push_back(dfs(queries[i][0], queries[i][1], visited));\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n\\n    double dfs(const string &pos, const string &target, unordered_set<string> &visited){\\n        if(pos == target)\\n            return 1;\\n        visited.insert(pos);\\n        for(const auto &[nxt, w]: edges[pos])\\n        {\\n            if(not visited.count(nxt))\\n            {\\n                double res = dfs(nxt, target, visited);\\n                if(res != -1.0)\\n                    return res * w;\\n            }\\n        }\\n        return -1.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string, unordered_map<string, double>> edges; \\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double> ans; ans.reserve(queries.size());\\n        int m = equations.size(); \\n        for(int i = 0; i < m; i++){\\n            edges[equations[i][0]][equations[i][1]] = values[i]; \\n            edges[equations[i][1]][equations[i][0]] = 1 / values[i]; \\n        }\\n        unordered_set<string> visited;\\n        for(int i = 0; i < queries.size(); i++){\\n            if(edges.count(queries[i][0]) == 0 or edges.count(queries[i][1]) == 0){\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            visited.insert(queries[i][0]); \\n            ans.push_back(dfs(queries[i][0], queries[i][1], visited));\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n\\n    double dfs(const string &pos, const string &target, unordered_set<string> &visited){\\n        if(pos == target)\\n            return 1;\\n        visited.insert(pos);\\n        for(const auto &[nxt, w]: edges[pos])\\n        {\\n            if(not visited.count(nxt))\\n            {\\n                double res = dfs(nxt, target, visited);\\n                if(res != -1.0)\\n                    return res * w;\\n            }\\n        }\\n        return -1.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942676,
                "title": "c-bfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        set<string>s;\\n        vector<double>ans;\\n        for(int i=0; i<equations.size(); i++){\\n            s.insert(equations[i][0]);\\n            s.insert(equations[i][1]);\\n        }\\n        unordered_map<string, vector<pair<string, double>>>m;\\n        for(int i=0; i<equations.size(); i++){\\n            m[equations[i][0]].push_back({equations[i][1], values[i]});\\n            m[equations[i][1]].push_back({equations[i][0], (double)1/values[i]});\\n        }\\n        for(int i=0; i<queries.size(); i++){\\n            queue<pair<string, double>>q;\\n            set<string>v;\\n            double val=-1;\\n            q.push({queries[i][0], 1});\\n            v.insert(queries[i][0]);\\n            if(m.find(queries[i][1])!=m.end()){    \\n                while(!q.empty()){\\n                    string pos=q.front().first;\\n                    double cnt=q.front().second;\\n                    q.pop();\\n                    if(pos==queries[i][1]){\\n                        val=cnt;\\n                        break;\\n                    }\\n                    for(auto it: m[pos]){\\n                        if(v.find(it.first)==v.end()){\\n                            v.insert(it.first);\\n                            q.push({it.first, (double)it.second*cnt});\\n                        }\\n                    }\\n                }\\n            }\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        set<string>s;\\n        vector<double>ans;\\n        for(int i=0; i<equations.size(); i++){\\n            s.insert(equations[i][0]);\\n            s.insert(equations[i][1]);\\n        }\\n        unordered_map<string, vector<pair<string, double>>>m;\\n        for(int i=0; i<equations.size(); i++){\\n            m[equations[i][0]].push_back({equations[i][1], values[i]});\\n            m[equations[i][1]].push_back({equations[i][0], (double)1/values[i]});\\n        }\\n        for(int i=0; i<queries.size(); i++){\\n            queue<pair<string, double>>q;\\n            set<string>v;\\n            double val=-1;\\n            q.push({queries[i][0], 1});\\n            v.insert(queries[i][0]);\\n            if(m.find(queries[i][1])!=m.end()){    \\n                while(!q.empty()){\\n                    string pos=q.front().first;\\n                    double cnt=q.front().second;\\n                    q.pop();\\n                    if(pos==queries[i][1]){\\n                        val=cnt;\\n                        break;\\n                    }\\n                    for(auto it: m[pos]){\\n                        if(v.find(it.first)==v.end()){\\n                            v.insert(it.first);\\n                            q.push({it.first, (double)it.second*cnt});\\n                        }\\n                    }\\n                }\\n            }\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995975,
                "title": "python3-union-find",
                "content": "We create a union find, but unlike the traditional template, the par array becomes a dict, because the input nodes are no longer integers. Also, we do away with the rank array, because we will arbitrarily always pick the parent of the second node in the union operation as the parent. The key is to keep another dict that stores the values of each node. We maintain the property that the value of the parent of any union is 1. Each time a union(x, y, q) is called, we find the ratio that needs to be multiplied to val[x] to make val[x] / val[y] = q. Then we go through the entire union to change all the nodes whose parent is the same as that of x to the parent of y, and update their values by multiplying the ratio.\\n\\nWhen computing the output, we have to check whether the query nodes are in union find, AND if they are in union find, whether they have the same parent. The latter check is crucial because only nodes that share the same parent can have their values divided.\\n\\n```python\\nclass DSU:\\n    def __init__(self):\\n        self.par = {}\\n        self.val = defaultdict(lambda: 1)\\n\\n    def find(self, x: str) -> str:\\n        if x not in self.par:\\n            self.par[x] = x\\n        if x != self.par[x]:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n\\n    def union(self, x: str, y: str, q: float) -> None:\\n        # arbitrarily force all nodes in union find to point to py as\\n        # their new parent. Also, update everyone\\'s value as well\\n        # according to the new ratio\\n        px, py = self.find(x), self.find(y)\\n        ratio = self.val[y] * q / self.val[x]\\n        for node, par in self.par.items():\\n            if par == px:\\n                self.par[node] = py\\n                self.val[node] *= ratio\\n\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        \"\"\"LeetCode 399\\n\\n        32 ms, faster than 87.32%\\n        \"\"\"\\n        uf = DSU()\\n        for (x, y), v in zip(equations, values):\\n            uf.union(x, y, v)\\n        res = []\\n        for x, y in queries:\\n            if x not in uf.val or y not in uf.val or uf.find(x) != uf.find(y):\\n                res.append(-1.0)\\n            else:\\n                res.append(uf.val[x] / uf.val[y])\\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```python\\nclass DSU:\\n    def __init__(self):\\n        self.par = {}\\n        self.val = defaultdict(lambda: 1)\\n\\n    def find(self, x: str) -> str:\\n        if x not in self.par:\\n            self.par[x] = x\\n        if x != self.par[x]:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n\\n    def union(self, x: str, y: str, q: float) -> None:\\n        # arbitrarily force all nodes in union find to point to py as\\n        # their new parent. Also, update everyone\\'s value as well\\n        # according to the new ratio\\n        px, py = self.find(x), self.find(y)\\n        ratio = self.val[y] * q / self.val[x]\\n        for node, par in self.par.items():\\n            if par == px:\\n                self.par[node] = py\\n                self.val[node] *= ratio\\n\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        \"\"\"LeetCode 399\\n\\n        32 ms, faster than 87.32%\\n        \"\"\"\\n        uf = DSU()\\n        for (x, y), v in zip(equations, values):\\n            uf.union(x, y, v)\\n        res = []\\n        for x, y in queries:\\n            if x not in uf.val or y not in uf.val or uf.find(x) != uf.find(y):\\n                res.append(-1.0)\\n            else:\\n                res.append(uf.val[x] / uf.val[y])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994101,
                "title": "c-100-faster",
                "content": "class Solution {\\npublic:\\nvoid dfs(string start,string end,map<string,double>& mp,map<string,vector<string>>& graph,double& val,map<string,int>& visited,bool& found){\\n        visited[start]=1;\\n    \\n        if(found==true)\\n            return ;\\n        for(auto child:graph[start]){\\n            if(visited[child]!=1){\\n                // cout<<start<<\" \"<<child<<\"\\\\n\";\\n                val*=mp[start+\"->\"+child];\\n                if(end==child){\\n                    // cout<<end<<\" -- \"<<child<<\"\\\\n\";\\n                    found=true;\\n                    return ;\\n                }\\n                dfs(child,end,mp,graph,val,visited,found);\\n                if(found==true){\\n                    return ;\\n                }\\n                else{\\n                    val/=mp[start+\"->\"+child];\\n                }\\n            }\\n        }\\n       \\n        \\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        vector<double> ans;\\n        map<string,double> mp;\\n        map<string,vector<string>> graph;\\n        for(int i=0;i<equations.size();i++){\\n            string u=equations[i][0];\\n            string v=equations[i][1];\\n            mp[u+\"->\"+v]=values[i];\\n            mp[v+\"->\"+u]=1/values[i];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            string start=queries[i][0];\\n            string end=queries[i][1];\\n            if(graph.find(start)==graph.end()||graph.find(end)==graph.end()){\\n                ans.push_back(-1);\\n            }\\n            else{\\n                // ans.push_back(1);\\n                double val=1;\\n                map<string,int> visited;\\n                bool found=false;\\n                if(start==end){\\n                    found=true;\\n                }\\n                else\\n                dfs(start,end,mp,graph,val,visited,found);\\n                if(found==true)\\n                ans.push_back(val);\\n                else\\n                    ans.push_back(-1);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nvoid dfs(string start,string end,map<string,double>& mp,map<string,vector<string>>& graph,double& val,map<string,int>& visited,bool& found){\\n        visited[start]=1;\\n    \\n        if(found==true)\\n            return ;\\n        for(auto child:graph[start]){\\n            if(visited[child]!=1){\\n                // cout<<start<<\" \"<<child<<\"\\\\n\";\\n                val*=mp[start+\"->\"+child];\\n                if(end==child){\\n                    // cout<<end<<\" -- \"<<child<<\"\\\\n\";\\n                    found=true;\\n                    return ;\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 1994048,
                "title": "c-graph-dfs-find-path-with-pictures",
                "content": "**1**.Built Graph from Equations. **variables as vertices** .\\n**2**.Add edges to the graph  using **variable pair in equation** with  **values as weight**.(ex: for pair (a,b) add edge a-b and b-a with weights value and 1/(value) );\\n**3**.Now Result of the query we can calculate by getting product of the weights in the path from query\\'s divident  to query\\'s divisor (ex: query(a,c) then products of weights in the path from a to c will be the result).\\n(why because, suppose we have results of a/b , b/c and c/d and want to find a/d then we\\njust multiply them together and get (a/b)x(b/c)x(c/d) = (a/d) )\\n```\\nExample 1: \\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0]\\nquery = [\"a\",\"c\"];\\nAs seen in the picture result of the query is products of weights in the path.\\n2*3 = 6\\n```\\n![image](https://assets.leetcode.com/users/images/7e2ac1e1-c32c-4f6e-b6c8-165646fa2100_1651319273.1511545.png)\\n\\n\\n**My Code**\\n```\\n vector<double> calcEquation(vector<vector<string>>& eqs, vector<double>& vals, vector<vector<string>>& quers) {\\n        \\n        unordered_map<string, int> varVerMap;\\n        int v = 0;\\n        for(auto vars: eqs){\\n            if(varVerMap.count(vars[0]) == 0)\\n                varVerMap[vars[0]] = v++;\\n            if(varVerMap.count(vars[1]) == 0)\\n                varVerMap[vars[1]] = v++;\\n        }\\n        vector<vector<int>> graph(v);\\n        vector<vector<double>> edgeWt(v, vector<double>(v, -1));\\n        \\n        for(int i = 0; i < eqs.size(); ++i){\\n            int u = varVerMap[ eqs[i][0] ];\\n            int v = varVerMap[ eqs[i][1] ];\\n            double wt = vals[i];\\n            graph[u].push_back(v);\\n            edgeWt[u][v] = wt;\\n            graph[v].push_back(u);\\n            edgeWt[v][u] = 1/wt;\\n        }\\n        \\n        vector<double> res;\\n        for(auto qry: quers) {\\n            if(varVerMap.count(qry[0]) == 1 && varVerMap.count(qry[1]) == 1) {\\n                int s = varVerMap[ qry[0] ];\\n                int d = varVerMap[ qry[1] ]; \\n                res.push_back(getProdOfPath(graph, edgeWt, s, d));\\n            }\\n            else {\\n                res.push_back(-1.0);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    double getProdOfPath(vector<vector<int>>& graph, vector<vector<double>>& edgeWt, int s, int d) {\\n        int V =  graph.size();\\n        vector<bool> visit(V, false);\\n        if(s == d) return 1.0;\\n        \\n        visit[s] = true;\\n        for(int u: graph[s]) {\\n            if(visit[u] == false) {\\n                double prod = edgeWt[s][u]*FindPathProdDFS(graph, edgeWt, visit, u, d);\\n                if(prod > 0)\\n                    return prod;\\n            }   \\n        }\\n        return -1.0;\\n    }\\n    double FindPathProdDFS(vector<vector<int>>& graph, vector<vector<double>>& edgeWt, vector<bool>& visit, int u, int d) {\\n        if(u == d)  return 1.0;\\n        visit[u] = true;\\n        for(int v: graph[u]) {\\n            if(visit[v] == false) {\\n                double prod = edgeWt[u][v]*FindPathProdDFS(graph, edgeWt, visit, v, d);\\n                if(prod > 0)\\n                    return prod;\\n            }\\n        }\\n        return -1.0;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nExample 1: \\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0]\\nquery = [\"a\",\"c\"];\\nAs seen in the picture result of the query is products of weights in the path.\\n2*3 = 6\\n```\n```\\n vector<double> calcEquation(vector<vector<string>>& eqs, vector<double>& vals, vector<vector<string>>& quers) {\\n        \\n        unordered_map<string, int> varVerMap;\\n        int v = 0;\\n        for(auto vars: eqs){\\n            if(varVerMap.count(vars[0]) == 0)\\n                varVerMap[vars[0]] = v++;\\n            if(varVerMap.count(vars[1]) == 0)\\n                varVerMap[vars[1]] = v++;\\n        }\\n        vector<vector<int>> graph(v);\\n        vector<vector<double>> edgeWt(v, vector<double>(v, -1));\\n        \\n        for(int i = 0; i < eqs.size(); ++i){\\n            int u = varVerMap[ eqs[i][0] ];\\n            int v = varVerMap[ eqs[i][1] ];\\n            double wt = vals[i];\\n            graph[u].push_back(v);\\n            edgeWt[u][v] = wt;\\n            graph[v].push_back(u);\\n            edgeWt[v][u] = 1/wt;\\n        }\\n        \\n        vector<double> res;\\n        for(auto qry: quers) {\\n            if(varVerMap.count(qry[0]) == 1 && varVerMap.count(qry[1]) == 1) {\\n                int s = varVerMap[ qry[0] ];\\n                int d = varVerMap[ qry[1] ]; \\n                res.push_back(getProdOfPath(graph, edgeWt, s, d));\\n            }\\n            else {\\n                res.push_back(-1.0);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    double getProdOfPath(vector<vector<int>>& graph, vector<vector<double>>& edgeWt, int s, int d) {\\n        int V =  graph.size();\\n        vector<bool> visit(V, false);\\n        if(s == d) return 1.0;\\n        \\n        visit[s] = true;\\n        for(int u: graph[s]) {\\n            if(visit[u] == false) {\\n                double prod = edgeWt[s][u]*FindPathProdDFS(graph, edgeWt, visit, u, d);\\n                if(prod > 0)\\n                    return prod;\\n            }   \\n        }\\n        return -1.0;\\n    }\\n    double FindPathProdDFS(vector<vector<int>>& graph, vector<vector<double>>& edgeWt, vector<bool>& visit, int u, int d) {\\n        if(u == d)  return 1.0;\\n        visit[u] = true;\\n        for(int v: graph[u]) {\\n            if(visit[v] == false) {\\n                double prod = edgeWt[u][v]*FindPathProdDFS(graph, edgeWt, visit, v, d);\\n                if(prod > 0)\\n                    return prod;\\n            }\\n        }\\n        return -1.0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1993248,
                "title": "bfs-solution-shortest-path-o-n-time-and-o-2-n-memory",
                "content": "Do Upvote if you find it useful\\n```\\nclass Solution {\\npublic:\\n   \\n    double solve(map<string,vector<pair<string,double>>> m,vector<string> qi){\\n        queue<pair<string,double>> q;\\n        q.push({qi[0],1});\\n        unordered_set<string> s;\\n        while(!q.empty()){\\n            auto x=q.front();q.pop();\\n            s.insert(x.first);\\n            if(x.first==qi[1] && m.find(x.first)!=m.end()){\\n                return x.second;\\n            }\\n            for(auto y:m[x.first]){\\n                if(s.find(y.first)==s.end()){\\n                    q.push({y.first,(double)y.second*x.second});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        vector<double> r(queries.size());\\n        map<string,vector<pair<string,double>>> m;\\n        for(int i=0;i<values.size();i++){\\n            m[equations[i][0]].push_back({equations[i][1],values[i]});\\n            m[equations[i][1]].push_back({equations[i][0],(double)1/values[i]});\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            r[i]=solve(m,queries[i]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    double solve(map<string,vector<pair<string,double>>> m,vector<string> qi){\\n        queue<pair<string,double>> q;\\n        q.push({qi[0],1});\\n        unordered_set<string> s;\\n        while(!q.empty()){\\n            auto x=q.front();q.pop();\\n            s.insert(x.first);\\n            if(x.first==qi[1] && m.find(x.first)!=m.end()){\\n                return x.second;\\n            }\\n            for(auto y:m[x.first]){\\n                if(s.find(y.first)==s.end()){\\n                    q.push({y.first,(double)y.second*x.second});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        vector<double> r(queries.size());\\n        map<string,vector<pair<string,double>>> m;\\n        for(int i=0;i<values.size();i++){\\n            m[equations[i][0]].push_back({equations[i][1],values[i]});\\n            m[equations[i][1]].push_back({equations[i][0],(double)1/values[i]});\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            r[i]=solve(m,queries[i]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993053,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n  public double[] calcEquation(List<List<String>> equations, double[] values,\\n                               List<List<String>> queries) {\\n    double[] ans = new double[queries.size()];\\n    // graph.get(A).get(B) := A / B\\n    Map<String, Map<String, Double>> graph = new HashMap<>();\\n\\n    // construct the graph\\n    for (int i = 0; i < equations.size(); ++i) {\\n      final String A = equations.get(i).get(0);\\n      final String B = equations.get(i).get(1);\\n      graph.putIfAbsent(A, new HashMap<>());\\n      graph.putIfAbsent(B, new HashMap<>());\\n      graph.get(A).put(B, values[i]);\\n      graph.get(B).put(A, 1.0 / values[i]);\\n    }\\n\\n    for (int i = 0; i < queries.size(); ++i) {\\n      final String A = queries.get(i).get(0);\\n      final String C = queries.get(i).get(1);\\n      if (!graph.containsKey(A) || !graph.containsKey(C))\\n        ans[i] = -1.0;\\n      else\\n        ans[i] = divide(graph, A, C, new HashSet<>());\\n    }\\n\\n    return ans;\\n  }\\n\\n  // return A / C\\n  private double divide(Map<String, Map<String, Double>> graph, final String A, final String C,\\n                        Set<String> seen) {\\n    if (A.equals(C))\\n      return 1.0;\\n\\n    seen.add(A);\\n\\n    for (final String B : graph.get(A).keySet()) {\\n      if (seen.contains(B))\\n        continue;\\n      final double res = divide(graph, B, C, seen); // B / C\\n      if (res > 0)                                  // valid result\\n        return graph.get(A).get(B) * res;           // A / C = (A / B) * (B / C)\\n    }\\n\\n    return -1.0; // invalid result\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public double[] calcEquation(List<List<String>> equations, double[] values,\\n                               List<List<String>> queries) {\\n    double[] ans = new double[queries.size()];\\n    // graph.get(A).get(B) := A / B\\n    Map<String, Map<String, Double>> graph = new HashMap<>();\\n\\n    // construct the graph\\n    for (int i = 0; i < equations.size(); ++i) {\\n      final String A = equations.get(i).get(0);\\n      final String B = equations.get(i).get(1);\\n      graph.putIfAbsent(A, new HashMap<>());\\n      graph.putIfAbsent(B, new HashMap<>());\\n      graph.get(A).put(B, values[i]);\\n      graph.get(B).put(A, 1.0 / values[i]);\\n    }\\n\\n    for (int i = 0; i < queries.size(); ++i) {\\n      final String A = queries.get(i).get(0);\\n      final String C = queries.get(i).get(1);\\n      if (!graph.containsKey(A) || !graph.containsKey(C))\\n        ans[i] = -1.0;\\n      else\\n        ans[i] = divide(graph, A, C, new HashSet<>());\\n    }\\n\\n    return ans;\\n  }\\n\\n  // return A / C\\n  private double divide(Map<String, Map<String, Double>> graph, final String A, final String C,\\n                        Set<String> seen) {\\n    if (A.equals(C))\\n      return 1.0;\\n\\n    seen.add(A);\\n\\n    for (final String B : graph.get(A).keySet()) {\\n      if (seen.contains(B))\\n        continue;\\n      final double res = divide(graph, B, C, seen); // B / C\\n      if (res > 0)                                  // valid result\\n        return graph.get(A).get(B) * res;           // A / C = (A / B) * (B / C)\\n    }\\n\\n    return -1.0; // invalid result\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992985,
                "title": "c-bfs-o-queries-size-equations-size-w-detailed-explanation",
                "content": "**Idea**: We can arbitrarily assign a number to a variable. Then, solve all other variables based off the equations. Lastly, go through queries and solve them using the answers obtained when solving variables. \\n\\n**Example:**  Suppose we have `a / b = 1` and `b / c = 2`. We can simply assign `a = 1` and then solve equations. From the first equation, we get that `1 / b = 1 -> b = 1`. Then, `1 / c = 2 -> c = 0.5`. Now, we can solve any query involving `a, b, c`.\\n\\n**Algorithm:** We can treat each variable as a node, and theres an edge from node `a` to node `b` with weight `w` if `a / b = w`. Now we can take any equation like `a / b = 2` and create two edges: `a->b` with weight `2` and `b->a` with weight `0.5`. Then for each component, we assign the first node some arbitrary value (I chose 100), and then traverse the graph using either BFS or DFS and solve the other variables. At the end, we go through all queries and solve them. \\n\\n**Analysis:** BFS will take `O(n + m)` time where `n` is the number of nodes and `m` is the number of edges. However, since we know that the number of edges will be `2n`, the time for BFS is `O(n)`. We also traverse queries once which takes `O(k)` time, where `k` is the length of queries. In total, the time complexity will be **`O(n + k)`** where `n = equations.size()` and `k = queries.size()`.\\n\\n```\\nclass Solution {\\npublic:\\n    void explore(unordered_map<string, vector<pair<string, double>>> &adj, unordered_set<string> &visited, \\n                 unordered_map<string, pair<double, int>> &ans, string curr, int comp){\\n        \\n        queue<string> q;\\n        q.push(curr); \\n        ans[curr] = {100.0, comp}; // assign arbitrary value\\n        \\n        while(!q.empty()){ // perform BFS (could also use DFS)\\n           \\n            auto curr = q.front(); q.pop();\\n            \\n            if(visited.count(curr)){\\n                continue;\\n            }\\n            visited.insert(curr);\\n            \\n            for(auto &n : adj[curr]){\\n                ans[n.first] = {ans[curr].first / n.second, comp}; // solve the neighbors value\\n                q.push(n.first);\\n            }\\n        }\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        unordered_map<string, vector<pair<string, double>>> adj; // {variable1, {variable2, weight}}\\n        unordered_set<string> visited; // set of visited variables\\n        unordered_map<string, pair<double, int>> ans; // {variable, {answer, component_id}}\\n        for(int i = 0; i < equations.size(); i++){ // create the adjacency list\\n            adj[equations[i][0]].push_back({equations[i][1], values[i]});\\n            adj[equations[i][1]].push_back({equations[i][0], 1 / values[i]});\\n        }\\n        \\n        int comp = 0;\\n        for(auto &[k, v] : adj){\\n            if(!ans[k].first){\\n                explore(adj, visited, ans, k, comp++); // explore the current component\\n            }\\n        }\\n        \\n        vector<double> res;\\n        for(auto &q : queries){ // traverse queries and solve\\n            if(ans[q[0]].first && ans[q[1]].first && ans[q[0]].second == ans[q[1]].second){ // if value exist, and they were from the same component, solve\\n                res.push_back(ans[q[0]].first / ans[q[1]].first);\\n            }\\n            else{\\n                res.push_back(-1.0);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void explore(unordered_map<string, vector<pair<string, double>>> &adj, unordered_set<string> &visited, \\n                 unordered_map<string, pair<double, int>> &ans, string curr, int comp){\\n        \\n        queue<string> q;\\n        q.push(curr); \\n        ans[curr] = {100.0, comp}; // assign arbitrary value\\n        \\n        while(!q.empty()){ // perform BFS (could also use DFS)\\n           \\n            auto curr = q.front(); q.pop();\\n            \\n            if(visited.count(curr)){\\n                continue;\\n            }\\n            visited.insert(curr);\\n            \\n            for(auto &n : adj[curr]){\\n                ans[n.first] = {ans[curr].first / n.second, comp}; // solve the neighbors value\\n                q.push(n.first);\\n            }\\n        }\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        unordered_map<string, vector<pair<string, double>>> adj; // {variable1, {variable2, weight}}\\n        unordered_set<string> visited; // set of visited variables\\n        unordered_map<string, pair<double, int>> ans; // {variable, {answer, component_id}}\\n        for(int i = 0; i < equations.size(); i++){ // create the adjacency list\\n            adj[equations[i][0]].push_back({equations[i][1], values[i]});\\n            adj[equations[i][1]].push_back({equations[i][0], 1 / values[i]});\\n        }\\n        \\n        int comp = 0;\\n        for(auto &[k, v] : adj){\\n            if(!ans[k].first){\\n                explore(adj, visited, ans, k, comp++); // explore the current component\\n            }\\n        }\\n        \\n        vector<double> res;\\n        for(auto &q : queries){ // traverse queries and solve\\n            if(ans[q[0]].first && ans[q[1]].first && ans[q[0]].second == ans[q[1]].second){ // if value exist, and they were from the same component, solve\\n                res.push_back(ans[q[0]].first / ans[q[1]].first);\\n            }\\n            else{\\n                res.push_back(-1.0);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746092,
                "title": "java-faster-than-95-00-with-comments-easy",
                "content": "```\\nclass Solution {\\n    Map<String, Map<String, Double>> graph = new HashMap<>();\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        \\n        generateGraph(equations, values);\\n                \\n        double[] results = new double[queries.size()];\\n        \\n        for(int i=0; i<queries.size(); i++){\\n            String dividend = queries.get(i).get(0);\\n            String divisor = queries.get(i).get(1);\\n            \\n            //check if both nodes exists in our graph\\n            if(!graph.containsKey(dividend) || !graph.containsKey(divisor)){\\n                results[i] = -1.0;\\n            } \\n            \\n            // x/x = 1\\n            else if(dividend == divisor){\\n                results[i] = 1.0;\\n            } \\n            \\n            //perform dfs and calcuate accumulative product\\n            else {\\n              results[i] = DFS(dividend, divisor, new HashSet<>());  \\n            }\\n        }\\n        \\n        \\n        return results;\\n    }\\n    \\n    public void generateGraph(List<List<String>> equations, double[] values){\\n        for(int i=0; i<equations.size(); i++){\\n            String start = equations.get(i).get(0);\\n            String end = equations.get(i).get(1);\\n            Double ratio = values[i];\\n            graph.putIfAbsent(start, new HashMap<>());\\n            graph.get(start).put(end, ratio);\\n            graph.putIfAbsent(end, new HashMap<>());\\n            graph.get(end).put(start, 1.0 / ratio);\\n        }\\n    }\\n\\n    public double DFS(String currNode, String targetNode, HashSet<String> visited){\\n        // return -1; meaning that we have explored this path before\\n        if(visited.contains(currNode)){\\n            return -1;\\n        }\\n\\n        //check if we have the target node in our adjacent nodes\\n        if(graph.get(currNode).containsKey(targetNode)){\\n            return graph.get(currNode).get(targetNode);\\n        }\\n        \\n        visited.add(currNode);\\n                \\n        //explore each adjacent node \\n        for(String adj : graph.get(currNode).keySet()){\\n            double accumlitiveProduct = DFS(adj, targetNode, visited);\\n            \\n            //if result of DFS is not -1, then there was a path, and therefore, we calcuate the accumlitive product\\n            if(accumlitiveProduct != -1){\\n                return accumlitiveProduct * graph.get(currNode).get(adj);\\n            }\\n        }\\n           \\n        // if we reach this point, then there is no path to the target node, so we return -1;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Map<String, Double>> graph = new HashMap<>();\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        \\n        generateGraph(equations, values);\\n                \\n        double[] results = new double[queries.size()];\\n        \\n        for(int i=0; i<queries.size(); i++){\\n            String dividend = queries.get(i).get(0);\\n            String divisor = queries.get(i).get(1);\\n            \\n            //check if both nodes exists in our graph\\n            if(!graph.containsKey(dividend) || !graph.containsKey(divisor)){\\n                results[i] = -1.0;\\n            } \\n            \\n            // x/x = 1\\n            else if(dividend == divisor){\\n                results[i] = 1.0;\\n            } \\n            \\n            //perform dfs and calcuate accumulative product\\n            else {\\n              results[i] = DFS(dividend, divisor, new HashSet<>());  \\n            }\\n        }\\n        \\n        \\n        return results;\\n    }\\n    \\n    public void generateGraph(List<List<String>> equations, double[] values){\\n        for(int i=0; i<equations.size(); i++){\\n            String start = equations.get(i).get(0);\\n            String end = equations.get(i).get(1);\\n            Double ratio = values[i];\\n            graph.putIfAbsent(start, new HashMap<>());\\n            graph.get(start).put(end, ratio);\\n            graph.putIfAbsent(end, new HashMap<>());\\n            graph.get(end).put(start, 1.0 / ratio);\\n        }\\n    }\\n\\n    public double DFS(String currNode, String targetNode, HashSet<String> visited){\\n        // return -1; meaning that we have explored this path before\\n        if(visited.contains(currNode)){\\n            return -1;\\n        }\\n\\n        //check if we have the target node in our adjacent nodes\\n        if(graph.get(currNode).containsKey(targetNode)){\\n            return graph.get(currNode).get(targetNode);\\n        }\\n        \\n        visited.add(currNode);\\n                \\n        //explore each adjacent node \\n        for(String adj : graph.get(currNode).keySet()){\\n            double accumlitiveProduct = DFS(adj, targetNode, visited);\\n            \\n            //if result of DFS is not -1, then there was a path, and therefore, we calcuate the accumlitive product\\n            if(accumlitiveProduct != -1){\\n                return accumlitiveProduct * graph.get(currNode).get(adj);\\n            }\\n        }\\n           \\n        // if we reach this point, then there is no path to the target node, so we return -1;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744360,
                "title": "c-easy-to-understand-dfs-solution",
                "content": "```\\nclass Solution {\\n    \\nprivate:\\n    double dfs(string start, string end, unordered_set<string> &vis, unordered_map<string, vector < pair<string, double>> > adj ){\\n        if((adj.find(start) == adj.end()) or (adj.find(end) == adj.end())) return -1.0;\\n        \\n        if(start == end) return 1.0;\\n        \\n        vis.insert(start);\\n        \\n        for(auto it : adj[start]){\\n            if(vis.find(it.first) == vis.end() ){\\n                auto res = dfs(it.first, end, vis, adj);\\n                if(res != -1.0){\\n                    return it.second *res;\\n                }\\n            }\\n        }\\n        \\n        return -1.0;\\n        \\n    }\\n    \\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        unordered_map<string, vector < pair<string, double>> > adj;\\n        \\n        for(int i = 0; i < equations.size(); i++){\\n            auto eq = equations[i];\\n            adj[eq[0]].push_back({eq[1], values[i] });\\n            adj[eq[1]].push_back({eq[0], 1/values[i]});\\n        }\\n        \\n        vector <double> ans;\\n        \\n        for(int i = 0; i < queries.size(); i++){\\n            auto q = queries[i];\\n            unordered_set<string> vis;\\n            auto res = dfs(q[0], q[1], vis, adj );\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\nprivate:\\n    double dfs(string start, string end, unordered_set<string> &vis, unordered_map<string, vector < pair<string, double>> > adj ){\\n        if((adj.find(start) == adj.end()) or (adj.find(end) == adj.end())) return -1.0;\\n        \\n        if(start == end) return 1.0;\\n        \\n        vis.insert(start);\\n        \\n        for(auto it : adj[start]){\\n            if(vis.find(it.first) == vis.end() ){\\n                auto res = dfs(it.first, end, vis, adj);\\n                if(res != -1.0){\\n                    return it.second *res;\\n                }\\n            }\\n        }\\n        \\n        return -1.0;\\n        \\n    }\\n    \\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        unordered_map<string, vector < pair<string, double>> > adj;\\n        \\n        for(int i = 0; i < equations.size(); i++){\\n            auto eq = equations[i];\\n            adj[eq[0]].push_back({eq[1], values[i] });\\n            adj[eq[1]].push_back({eq[0], 1/values[i]});\\n        }\\n        \\n        vector <double> ans;\\n        \\n        for(int i = 0; i < queries.size(); i++){\\n            auto q = queries[i];\\n            unordered_set<string> vis;\\n            auto res = dfs(q[0], q[1], vis, adj );\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720165,
                "title": "0ms-dfs-graph-o-n-2-c",
                "content": "Using x / y = a and y / z = b => x / z = a * b\\nUp vote if it\\'s helpful!\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    \\n\\t\\tunordered_map<string, unordered_map<string, double>> graph; //graph[x][y] = x / y\\n\\t\\tunordered_map<string, unordered_map<string, bool>> visited; //check x / y have exist \\n\\n\\t\\tvoid dfs(string x, string y) {\\n\\t\\t\\tfor (auto i : graph[y]) {\\n\\t\\t\\t\\tstring z = i.first;\\n\\t\\t\\t\\tif (!visited[x][z]) {\\n\\t\\t\\t\\t\\tgraph[x][z] = graph[x][y] * graph[y][z];\\n\\t\\t\\t\\t\\tvisited[x][z] = true;\\n\\t\\t\\t\\t\\tif (!visited[z][x]) {\\n\\t\\t\\t\\t\\t\\tgraph[z][x] = 1 / graph[x][z];\\n\\t\\t\\t\\t\\t\\tvisited[z][x] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdfs(x, z);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<double> calcEquation(vector<vector<string>> &equations, vector<double>&values,vector<vector<string>> &queries) {\\n\\t\\t\\tfor (int i = 0; i < equations.size(); i++) {\\n\\t\\t\\t\\tstring x = equations[i][0], y = equations[i][1];\\n\\n\\t\\t\\t\\tgraph[x][y] = values[i];\\n\\t\\t\\t\\tgraph[x][x] = 1;\\n\\t\\t\\t\\tgraph[y][y] = 1;\\n\\t\\t\\t\\tgraph[y][x] = 1 / values[i];\\n\\t\\t\\t\\tvisited[x][y] = true;\\n\\t\\t\\t\\tvisited[x][x] = true;\\n\\t\\t\\t\\tvisited[y][y] = true;\\n\\t\\t\\t\\tvisited[y][x] = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<double> ans;\\n\\n\\t\\t\\tfor (auto pair : queries) {\\n\\t\\t\\t\\tstring x = pair[0], y = pair[1];\\n\\t\\t\\t\\tif (!visited[x][y]) {\\n\\t\\t\\t\\t\\tfor (auto i : graph[x])\\n\\t\\t\\t\\t\\t\\tdfs(x, i.first);\\n\\t\\t\\t\\t\\tif (!visited[x][y]) ans.push_back(-1);\\n\\t\\t\\t\\t\\telse ans.push_back(graph[x][y]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tans.push_back(graph[x][y]);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n\\t\\tunordered_map<string, unordered_map<string, double>> graph; //graph[x][y] = x / y\\n\\t\\tunordered_map<string, unordered_map<string, bool>> visited; //check x / y have exist \\n\\n\\t\\tvoid dfs(string x, string y) {\\n\\t\\t\\tfor (auto i : graph[y]) {\\n\\t\\t\\t\\tstring z = i.first;\\n\\t\\t\\t\\tif (!visited[x][z]) {\\n\\t\\t\\t\\t\\tgraph[x][z] = graph[x][y] * graph[y][z];\\n\\t\\t\\t\\t\\tvisited[x][z] = true;\\n\\t\\t\\t\\t\\tif (!visited[z][x]) {\\n\\t\\t\\t\\t\\t\\tgraph[z][x] = 1 / graph[x][z];\\n\\t\\t\\t\\t\\t\\tvisited[z][x] = true;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1657402,
                "title": "java-detailed-explanation-map-of-map",
                "content": "// We can treat each equation as an edge, variables as nodes and value as weight, and build a weighted graph.\\n// Then for each queries (x, y), we try to find a path from x to y. The answer is the product of all edges\\' weights. If either x or y is not in graph or x and y are not connected in graph, the answer doesn\\'t exist.\\n\\n// Related Interview Question : https://leetcode.com/discuss/interview-question/483660/google-phone-currency-conversion\\n// Solution for above interview question : https://leetcode.com/playground/KqirPic8\\n\\n// TC : O(M * N) -> M = queries.size() && N = 2 * equations.size() -> dfs in worst can go on every key of the map\\n// SC : O(N)\\n```\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        // Weighted Directed Graph\\n        Map<String, Map<String, Double>> weightedDirectedGraph = new HashMap<>(); // key -> \\'start\\' in the equations && value -> \\'end\\' in equations mapped with the value\\n        int valueIdx = 0;\\n        \\n        // create the weighted directed graph\\n        for(List<String> equation : equations) {\\n            String start = equation.get(0);\\n            String end = equation.get(1);\\n            double weight = values[valueIdx++];\\n            \\n            weightedDirectedGraph.putIfAbsent(start, new HashMap<>()); // staraight connection\\n            weightedDirectedGraph.get(start).put(end, weight);\\n            \\n            weightedDirectedGraph.putIfAbsent(end, new HashMap<>()); // also do reverse connection\\n            weightedDirectedGraph.get(end).put(start, 1.0/weight);\\n        }\\n        \\n        double[] res = new double[queries.size()]; // to be returned, must of queries size\\n        int resIdx = 0;\\n        for(List<String> query : queries) { // we need to do this for every query\\n            String start = query.get(0);\\n            String end = query.get(1);\\n            \\n            if(!weightedDirectedGraph.containsKey(start) || !weightedDirectedGraph.containsKey(end)) { // if either start or end is not present in map, we cannot reach the answer\\n                res[resIdx++] = -1.0;\\n                continue;\\n            }\\n            \\n            res[resIdx++] = dfs(weightedDirectedGraph, start, end, new HashSet<>());\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private double dfs(Map<String, Map<String, Double>> weightedDirectedGraph, String start, String end, HashSet<String> visited) {\\n        if(weightedDirectedGraph.get(start).containsKey(end)) { // if the start\\'s map of connections has the end we are looking for, we have got the result so return\\n            return weightedDirectedGraph.get(start).get(end);\\n        }\\n        \\n        visited.add(start); // to avoid cyclic dependency\\n        \\n        for(Map.Entry<String, Double> entry : weightedDirectedGraph.get(start).entrySet()) { // read all the entries of the map of \\'start\\'\\n            if(visited.contains(entry.getKey())) continue;\\n            double res = dfs(weightedDirectedGraph, entry.getKey(), end, visited); // dfs on new key using this key as the start (still looking for end)\\n            if(res == -1.0) continue;\\n            \\n            return res * entry.getValue(); // if a/b = 2.0 and b/c = 3.0 then a/c = 2.0 * 3.0 = 6.0\\n        }\\n        \\n        return -1.0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        // Weighted Directed Graph\\n        Map<String, Map<String, Double>> weightedDirectedGraph = new HashMap<>(); // key -> \\'start\\' in the equations && value -> \\'end\\' in equations mapped with the value\\n        int valueIdx = 0;\\n        \\n        // create the weighted directed graph\\n        for(List<String> equation : equations) {\\n            String start = equation.get(0);\\n            String end = equation.get(1);\\n            double weight = values[valueIdx++];\\n            \\n            weightedDirectedGraph.putIfAbsent(start, new HashMap<>()); // staraight connection\\n            weightedDirectedGraph.get(start).put(end, weight);\\n            \\n            weightedDirectedGraph.putIfAbsent(end, new HashMap<>()); // also do reverse connection\\n            weightedDirectedGraph.get(end).put(start, 1.0/weight);\\n        }\\n        \\n        double[] res = new double[queries.size()]; // to be returned, must of queries size\\n        int resIdx = 0;\\n        for(List<String> query : queries) { // we need to do this for every query\\n            String start = query.get(0);\\n            String end = query.get(1);\\n            \\n            if(!weightedDirectedGraph.containsKey(start) || !weightedDirectedGraph.containsKey(end)) { // if either start or end is not present in map, we cannot reach the answer\\n                res[resIdx++] = -1.0;\\n                continue;\\n            }\\n            \\n            res[resIdx++] = dfs(weightedDirectedGraph, start, end, new HashSet<>());\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private double dfs(Map<String, Map<String, Double>> weightedDirectedGraph, String start, String end, HashSet<String> visited) {\\n        if(weightedDirectedGraph.get(start).containsKey(end)) { // if the start\\'s map of connections has the end we are looking for, we have got the result so return\\n            return weightedDirectedGraph.get(start).get(end);\\n        }\\n        \\n        visited.add(start); // to avoid cyclic dependency\\n        \\n        for(Map.Entry<String, Double> entry : weightedDirectedGraph.get(start).entrySet()) { // read all the entries of the map of \\'start\\'\\n            if(visited.contains(entry.getKey())) continue;\\n            double res = dfs(weightedDirectedGraph, entry.getKey(), end, visited); // dfs on new key using this key as the start (still looking for end)\\n            if(res == -1.0) continue;\\n            \\n            return res * entry.getValue(); // if a/b = 2.0 and b/c = 3.0 then a/c = 2.0 * 3.0 = 6.0\\n        }\\n        \\n        return -1.0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890443,
                "title": "java-build-the-graph-via-hashmap-depth-first-search",
                "content": "```\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        if (equations == null || equations.size() == 0) return new double[0];\\n        Map<String, Map<String, Double>> map = new HashMap<>();\\n        int len = values.length, qLen = queries.size();\\n        for (int i=0; i<len; i++) {\\n            String d1 = equations.get(i).get(0), d2 = equations.get(i).get(1);\\n            map.putIfAbsent(d1, new HashMap<>());\\n            map.putIfAbsent(d2, new HashMap<>());\\n            map.get(d1).put(d2, values[i]);\\n            map.get(d2).put(d1, 1/values[i]);\\n        }\\n        double[] res = new double[qLen];\\n        for (int i=0; i<qLen; i++) {\\n            Set<String> seen = new HashSet<>();\\n            String s = queries.get(i).get(0);\\n            String t = queries.get(i).get(1);\\n            res[i] = dfs(s, t, map, 1.0, seen);\\n        }\\n        return res;\\n    }\\n    \\n    public double dfs(String s, String t, Map<String, Map<String, Double>> map, double res, Set<String> seen) {\\n        if (!map.containsKey(s)) return -1.0;\\n        else {\\n            if (s.equals(t)) return res;\\n            else {\\n                if (!seen.contains(s)) {\\n                    seen.add(s);\\n                    Map<String, Double> m = map.get(s);\\n                    for (String temp : m.keySet()) {\\n                        double r = dfs(temp, t, map, res * m.get(temp), seen);\\n                        if (r != -1) {\\n                            return r;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1.0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        if (equations == null || equations.size() == 0) return new double[0];\\n        Map<String, Map<String, Double>> map = new HashMap<>();\\n        int len = values.length, qLen = queries.size();\\n        for (int i=0; i<len; i++) {\\n            String d1 = equations.get(i).get(0), d2 = equations.get(i).get(1);\\n            map.putIfAbsent(d1, new HashMap<>());\\n            map.putIfAbsent(d2, new HashMap<>());\\n            map.get(d1).put(d2, values[i]);\\n            map.get(d2).put(d1, 1/values[i]);\\n        }\\n        double[] res = new double[qLen];\\n        for (int i=0; i<qLen; i++) {\\n            Set<String> seen = new HashSet<>();\\n            String s = queries.get(i).get(0);\\n            String t = queries.get(i).get(1);\\n            res[i] = dfs(s, t, map, 1.0, seen);\\n        }\\n        return res;\\n    }\\n    \\n    public double dfs(String s, String t, Map<String, Map<String, Double>> map, double res, Set<String> seen) {\\n        if (!map.containsKey(s)) return -1.0;\\n        else {\\n            if (s.equals(t)) return res;\\n            else {\\n                if (!seen.contains(s)) {\\n                    seen.add(s);\\n                    Map<String, Double> m = map.get(s);\\n                    for (String temp : m.keySet()) {\\n                        double r = dfs(temp, t, map, res * m.get(temp), seen);\\n                        if (r != -1) {\\n                            return r;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1.0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868319,
                "title": "simple-java-dfs-traversal-with-video-explanation",
                "content": "https://www.youtube.com/watch?v=1NkeOHsHbs0\\n\\n```\\npublic double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        \\n        Map<String,Map<String,Double>> map = new HashMap<>();\\n        buildMap(map,equations,values);\\n        \\n        double[] res = new double[queries.size()];\\n        for(int i=0;i<queries.size();i++) {\\n            List<String> q = queries.get(i);\\n            Set<String> visited = new HashSet<>();\\n            Double d = dfs(map,q.get(0),q.get(1),visited);\\n            res[i] = d == null ? -1.0 : d;\\n        }\\n        return res;\\n    }\\n    \\n    \\n    public Double dfs(Map<String,Map<String,Double>> map, String q1, String q2, Set<String> visited) {\\n        if(visited.contains(q1))\\n            return null;\\n        \\n        if(!map.containsKey(q1) || !map.containsKey(q2))\\n            return null;\\n        \\n        if(map.get(q1)!=null && map.get(q1).get(q2)!=null)\\n            return map.get(q1).get(q2);\\n        \\n        visited.add(q1);\\n        Map<String,Double> q1Val = map.get(q1);\\n        \\n        for(String s:q1Val.keySet()) {\\n            Double d = dfs(map,s,q2,visited);\\n            if(d!=null) {\\n                return d * q1Val.get(s);\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    public void buildMap(Map<String,Map<String,Double>> map, List<List<String>> equations, double[] values) {\\n        for(int i=0;i<equations.size();i++) {\\n            List<String> eq = equations.get(i);\\n            if(!map.containsKey(eq.get(0))) {\\n                map.put(eq.get(0),new HashMap<String,Double>());\\n            }\\n            map.get(eq.get(0)).put(eq.get(1),values[i]);\\n            \\n            if(!map.containsKey(eq.get(1))) {\\n                map.put(eq.get(1),new HashMap<String,Double>());\\n            }\\n            map.get(eq.get(1)).put(eq.get(0),1/values[i]);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        \\n        Map<String,Map<String,Double>> map = new HashMap<>();\\n        buildMap(map,equations,values);\\n        \\n        double[] res = new double[queries.size()];\\n        for(int i=0;i<queries.size();i++) {\\n            List<String> q = queries.get(i);\\n            Set<String> visited = new HashSet<>();\\n            Double d = dfs(map,q.get(0),q.get(1),visited);\\n            res[i] = d == null ? -1.0 : d;\\n        }\\n        return res;\\n    }\\n    \\n    \\n    public Double dfs(Map<String,Map<String,Double>> map, String q1, String q2, Set<String> visited) {\\n        if(visited.contains(q1))\\n            return null;\\n        \\n        if(!map.containsKey(q1) || !map.containsKey(q2))\\n            return null;\\n        \\n        if(map.get(q1)!=null && map.get(q1).get(q2)!=null)\\n            return map.get(q1).get(q2);\\n        \\n        visited.add(q1);\\n        Map<String,Double> q1Val = map.get(q1);\\n        \\n        for(String s:q1Val.keySet()) {\\n            Double d = dfs(map,s,q2,visited);\\n            if(d!=null) {\\n                return d * q1Val.get(s);\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    public void buildMap(Map<String,Map<String,Double>> map, List<List<String>> equations, double[] values) {\\n        for(int i=0;i<equations.size();i++) {\\n            List<String> eq = equations.get(i);\\n            if(!map.containsKey(eq.get(0))) {\\n                map.put(eq.get(0),new HashMap<String,Double>());\\n            }\\n            map.get(eq.get(0)).put(eq.get(1),values[i]);\\n            \\n            if(!map.containsKey(eq.get(1))) {\\n                map.put(eq.get(1),new HashMap<String,Double>());\\n            }\\n            map.get(eq.get(1)).put(eq.get(0),1/values[i]);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 867821,
                "title": "c-simulation-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {        \\n        unordered_map<string, unordered_map<string, double> > m;\\n        for(int i = 0; i < equations.size(); i++){\\n            const string& A = equations[i][0];\\n            const string& B = equations[i][1];\\n            double k = values[i];\\n            m[A][B] = k;\\n            m[B][A] = 1.0 / k;\\n        }\\n        \\n        vector<double> ans;\\n        for(int i = 0; i < queries.size(); i++){\\n            const string A = queries[i][0];\\n            const string B = queries[i][1];   \\n            if(!m.count(A) || !m.count(B)){\\n                ans.push_back(-1.0);\\n                continue;\\n            }\\n            unordered_set<string> visited;\\n            double k = searchDivide(m, A, B, visited);\\n            ans.push_back(k);            \\n        }\\n        return ans;\\n    }\\n    \\n    // dfs: A/B = ?   =  A/C * C/B, where C is one of the neibors of A\\n    double searchDivide(const unordered_map<string, unordered_map<string, double> >& m, const string& A, const string& B, unordered_set<string>& visited){\\n        if(A == B) return 1.0;\\n        visited.insert(A);\\n        for(auto& pair: m.at(A)){\\n            const string C = pair.first;\\n            if(visited.count(C)) continue;\\n            auto d = searchDivide(m, C, B, visited);\\n            if(d > 0) return m.at(A).at(C) * d;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {        \\n        unordered_map<string, unordered_map<string, double> > m;\\n        for(int i = 0; i < equations.size(); i++){\\n            const string& A = equations[i][0];\\n            const string& B = equations[i][1];\\n            double k = values[i];\\n            m[A][B] = k;\\n            m[B][A] = 1.0 / k;\\n        }\\n        \\n        vector<double> ans;\\n        for(int i = 0; i < queries.size(); i++){\\n            const string A = queries[i][0];\\n            const string B = queries[i][1];   \\n            if(!m.count(A) || !m.count(B)){\\n                ans.push_back(-1.0);\\n                continue;\\n            }\\n            unordered_set<string> visited;\\n            double k = searchDivide(m, A, B, visited);\\n            ans.push_back(k);            \\n        }\\n        return ans;\\n    }\\n    \\n    // dfs: A/B = ?   =  A/C * C/B, where C is one of the neibors of A\\n    double searchDivide(const unordered_map<string, unordered_map<string, double> >& m, const string& A, const string& B, unordered_set<string>& visited){\\n        if(A == B) return 1.0;\\n        visited.insert(A);\\n        for(auto& pair: m.at(A)){\\n            const string C = pair.first;\\n            if(visited.count(C)) continue;\\n            auto d = searchDivide(m, C, B, visited);\\n            if(d > 0) return m.at(A).at(C) * d;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867568,
                "title": "evaluate-division-c-bfs-simple-solution",
                "content": "Make use of directed graph,\\n=>For each A/B = K, insert edge A->B with weight K and edge B->A with weight 1/K in graph. \\n=>For each query (S, E), find path from S -> E in the graph using BFS.\\n=>If there is no path return -1 \\n=>If path exists ,e.g. S->N1->N2->E,  return (S/N1) * (N1/N2) * (N2/E) \\n```\\nclass Solution {\\npublic:\\n     unordered_map<string, vector<pair<string, double>>> adj; /*define adjacency list */\\n     /* for path a->b->c result is (a,b) * (b,c) */\\n     double bfs(string s, string e){\\n         queue<pair<string,double>> q;      /* BFS queue */\\n         unordered_set<string> visited;     /* track visited nodes */\\n         q.push({s,1});                     /* push start node with multiplier 1 */\\n         visited.insert(s);                 /* make start node visited */\\n         while(!q.empty()){\\n             auto f = q.front();\\n             q.pop();\\n             for(auto ele : adj[f.first]){\\n                 if(ele.first.compare(e) == 0){         /* if end node is found return product of current */\\n                     return f.second * ele.second;      /* running multiplier with value of current edge */\\n                 }\\n                 if(visited.find(ele.first) == visited.end()){         /* if the node is not yet visited */\\n                     visited.insert(ele.first);                        /* make visited */\\n                     q.push({ele.first, (f.second * ele.second)});     /* push the node and update multiplier*/                    }                 \\n             }\\n         }\\n         return -1;\\n     }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {       \\n        for(int i=0;i<equations.size();i++){            /* for each a/b = x */\\n            auto eq = equations[i];\\n            adj[eq[0]].push_back({eq[1], values[i]});   /* put b in adj list of a with value x   */\\n            adj[eq[1]].push_back({eq[0], 1/values[i]}); /* put a in adj list of b with value 1/x */\\n        }\\n        vector<double> res;\\n        for(auto q : queries){                                  /* for each query (a,b)*/\\n            if(adj.find(q[0]) != adj.end()                      /* if a,b exist in graph */\\n\\t\\t\\t\\t\\t\\t\\t&& adj.find(q[1]) != adj.end()){                    \\n                if(q[0].compare(q[1]) == 0)                     /* if a == b, store 1*/\\n                    res.push_back(1);            \\n                else res.push_back(bfs(q[0], q[1]));            /* else do BFS(a, b) to find path to b */\\n            }\\n            else res.push_back(-1);                             /* if a,b not present in graph, store -1 */ \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     unordered_map<string, vector<pair<string, double>>> adj; /*define adjacency list */\\n     /* for path a->b->c result is (a,b) * (b,c) */\\n     double bfs(string s, string e){\\n         queue<pair<string,double>> q;      /* BFS queue */\\n         unordered_set<string> visited;     /* track visited nodes */\\n         q.push({s,1});                     /* push start node with multiplier 1 */\\n         visited.insert(s);                 /* make start node visited */\\n         while(!q.empty()){\\n             auto f = q.front();\\n             q.pop();\\n             for(auto ele : adj[f.first]){\\n                 if(ele.first.compare(e) == 0){         /* if end node is found return product of current */\\n                     return f.second * ele.second;      /* running multiplier with value of current edge */\\n                 }\\n                 if(visited.find(ele.first) == visited.end()){         /* if the node is not yet visited */\\n                     visited.insert(ele.first);                        /* make visited */\\n                     q.push({ele.first, (f.second * ele.second)});     /* push the node and update multiplier*/                    }                 \\n             }\\n         }\\n         return -1;\\n     }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {       \\n        for(int i=0;i<equations.size();i++){            /* for each a/b = x */\\n            auto eq = equations[i];\\n            adj[eq[0]].push_back({eq[1], values[i]});   /* put b in adj list of a with value x   */\\n            adj[eq[1]].push_back({eq[0], 1/values[i]}); /* put a in adj list of b with value 1/x */\\n        }\\n        vector<double> res;\\n        for(auto q : queries){                                  /* for each query (a,b)*/\\n            if(adj.find(q[0]) != adj.end()                      /* if a,b exist in graph */\\n\\t\\t\\t\\t\\t\\t\\t&& adj.find(q[1]) != adj.end()){                    \\n                if(q[0].compare(q[1]) == 0)                     /* if a == b, store 1*/\\n                    res.push_back(1);            \\n                else res.push_back(bfs(q[0], q[1]));            /* else do BFS(a, b) to find path to b */\\n            }\\n            else res.push_back(-1);                             /* if a,b not present in graph, store -1 */ \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867131,
                "title": "evaluate-division-python-93-dfs",
                "content": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        dic={}\\n        for i,v in zip(equations,values):\\n            if i[0] in dic:\\n                dic[i[0]][i[1]]=v\\n            else:\\n                dic[i[0]]={i[1]:v}\\n            if i[1] in dic:\\n                dic[i[1]][i[0]]=1/v\\n            else:\\n                dic[i[1]]={i[0]:1/v}\\n        \\n        def dfs(a,b,his,cur):\\n            if b in dic[a]:\\n                return cur*dic[a][b]\\n            for i in dic[a]:\\n                if i not in his:\\n                    f=dfs(i,b,his+[i],dic[a][i]*cur)\\n                    if f!=-1:\\n                        return f\\n            return -1\\n        \\n        return [dfs(i[0],i[1],[],1) if i[0] in dic and i[1] in dic else -1 for i in queries ]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\\n        dic={}\\n        for i,v in zip(equations,values):\\n            if i[0] in dic:\\n                dic[i[0]][i[1]]=v\\n            else:\\n                dic[i[0]]={i[1]:v}\\n            if i[1] in dic:\\n                dic[i[1]][i[0]]=1/v\\n            else:\\n                dic[i[1]]={i[0]:1/v}\\n        \\n        def dfs(a,b,his,cur):\\n            if b in dic[a]:\\n                return cur*dic[a][b]\\n            for i in dic[a]:\\n                if i not in his:\\n                    f=dfs(i,b,his+[i],dic[a][i]*cur)\\n                    if f!=-1:\\n                        return f\\n            return -1\\n        \\n        return [dfs(i[0],i[1],[],1) if i[0] in dic and i[1] in dic else -1 for i in queries ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827074,
                "title": "java-dfs-solution-0ms-comments-added",
                "content": "If you liked my solution, **please upvote it**\\n*Time complexity: O(n*e) time where n - amount of queries, e - edges. in worst case\\nSpace compexity: O(e) saving each edge two times. but 2 could be ommited*\\n\\n```\\nclass Solution {\\n    // would be faster to use Char, but we have String\\n    Map<String, Map<String, Double>> connections = new HashMap<>();\\n    // array of results\\n    double[] result;\\n    // mark visited \\n    Map<String, Boolean> visited = new HashMap<>();\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        // all results -1 by default\\n        result = new double[queries.size()];\\n        Arrays.fill(result, -1.0);\\n\\n        int counter = 0;\\n        // fill all dependencies in both directions\\n        for (List<String> pair: equations) {\\n            String first = pair.get(0);\\n            String second = pair.get(1);\\n            double value = values[counter];\\n            if (!connections.containsKey(first)) {\\n                connections.put(first, new HashMap<String, Double>());\\n            }\\n            if (!connections.containsKey(second)) {\\n                connections.put(second, new HashMap<String, Double>());\\n            }\\n            // in given direction\\n            connections.get(first).put(second, value);\\n            // in other direction, value of edge will 1 / given\\n            connections.get(second).put(first, 1.0 / value);\\n            // setting all visites as false;\\n            visited.put(first, false);\\n            visited.put(second, false);\\n            counter++;\\n        }\\n        \\n        counter = 0;\\n        // iterate over all queries\\n        for (List<String> pair: queries) {\\n            String first = pair.get(0);\\n            String second = pair.get(1);\\n            // if vertex is not in list - no solution (-1.0 by default)\\n            if (!connections.containsKey(first) || !connections.containsKey(second)) {\\n                counter++;\\n                continue;\\n            }\\n            // else going dfs with value 1.0 for case when first == second\\n            dfs(first, second, counter, 1.0);\\n            counter++;\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(String first, String second, int counter, double value) {\\n        // not visiting twise\\n        if (visited.get(first)) return;\\n        // if route found = write value and return\\n        if (first == second) {\\n            result[counter] = value;\\n            return;\\n        }\\n\\n        // if adjacent contains final point - calculate route value\\n        Map<String, Double> adjacent = connections.get(first);\\n        if (adjacent.containsKey(second)) {\\n            result[counter] = value * adjacent.get(second);\\n            return;\\n        }\\n        // in other case iterate over all adjacent vetices and mark current as visited\\n        visited.put(first, true);\\n        for (Map.Entry<String, Double> entry: adjacent.entrySet()) {\\n            dfs(entry.getKey(), second, counter, value * entry.getValue());\\n        }\\n        // unmark it after\\n        visited.put(first, false);\\n    }\\n}\\n```\\nIf i did a mistace in Space and Time complexity analysis, please correct me\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // would be faster to use Char, but we have String\\n    Map<String, Map<String, Double>> connections = new HashMap<>();\\n    // array of results\\n    double[] result;\\n    // mark visited \\n    Map<String, Boolean> visited = new HashMap<>();\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        // all results -1 by default\\n        result = new double[queries.size()];\\n        Arrays.fill(result, -1.0);\\n\\n        int counter = 0;\\n        // fill all dependencies in both directions\\n        for (List<String> pair: equations) {\\n            String first = pair.get(0);\\n            String second = pair.get(1);\\n            double value = values[counter];\\n            if (!connections.containsKey(first)) {\\n                connections.put(first, new HashMap<String, Double>());\\n            }\\n            if (!connections.containsKey(second)) {\\n                connections.put(second, new HashMap<String, Double>());\\n            }\\n            // in given direction\\n            connections.get(first).put(second, value);\\n            // in other direction, value of edge will 1 / given\\n            connections.get(second).put(first, 1.0 / value);\\n            // setting all visites as false;\\n            visited.put(first, false);\\n            visited.put(second, false);\\n            counter++;\\n        }\\n        \\n        counter = 0;\\n        // iterate over all queries\\n        for (List<String> pair: queries) {\\n            String first = pair.get(0);\\n            String second = pair.get(1);\\n            // if vertex is not in list - no solution (-1.0 by default)\\n            if (!connections.containsKey(first) || !connections.containsKey(second)) {\\n                counter++;\\n                continue;\\n            }\\n            // else going dfs with value 1.0 for case when first == second\\n            dfs(first, second, counter, 1.0);\\n            counter++;\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(String first, String second, int counter, double value) {\\n        // not visiting twise\\n        if (visited.get(first)) return;\\n        // if route found = write value and return\\n        if (first == second) {\\n            result[counter] = value;\\n            return;\\n        }\\n\\n        // if adjacent contains final point - calculate route value\\n        Map<String, Double> adjacent = connections.get(first);\\n        if (adjacent.containsKey(second)) {\\n            result[counter] = value * adjacent.get(second);\\n            return;\\n        }\\n        // in other case iterate over all adjacent vetices and mark current as visited\\n        visited.put(first, true);\\n        for (Map.Entry<String, Double> entry: adjacent.entrySet()) {\\n            dfs(entry.getKey(), second, counter, value * entry.getValue());\\n        }\\n        // unmark it after\\n        visited.put(first, false);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810560,
                "title": "standard-java-solution",
                "content": "### Theory\\nBasically when I read the hint for this problem, I had a big AHA moment. This problem is not a math one, its a hidden graph problem where we must initiate a BFS.\\n\\n### Solution\\n```\\n    public class Node {\\n        private String str;\\n        private Double cost;\\n        public Node(String str, Double cost) {\\n            this.str = str;\\n            this.cost = cost;\\n        }\\n    }\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        Map<String, List<Node>> map = new HashMap<>();\\n        for (int i = 0; i < equations.size(); i++) {\\n            List<String> curr = equations.get(i);\\n\\n            if (!map.containsKey(curr.get(0)))  map.put(curr.get(0), new ArrayList<>());\\n            if (!map.containsKey(curr.get(1)))  map.put(curr.get(1), new ArrayList<>());\\n\\n            \\n            map.get(curr.get(0)).add(new Node(curr.get(1), values[i]));\\n            map.get(curr.get(1)).add(new Node(curr.get(0), 1 / values[i]));\\n        }\\n        \\n        double[] res = new double[queries.size()];\\n        for (int i = 0; i < res.length; i++) {\\n            List<String> query = queries.get(i);\\n            if (map.containsKey(query.get(0)) && map.containsKey(query.get(1))) {\\n                res[i] = bfs(map, query.get(0), query.get(1));\\n            } else \\n                res[i] = -1;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private double bfs(Map<String, List<Node>> map, String from, String to) {\\n        Queue<Node> queue = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        queue.add(new Node(from, 1.0));\\n        visited.add(from);\\n        while (!queue.isEmpty()) {\\n            Node curr = queue.poll();\\n            if (curr.str.equals(to)) \\n                return curr.cost;\\n            List<Node> next = map.get(curr.str);\\n            for (Node n : next) {\\n                if (visited.contains(n.str)) continue;\\n                queue.add(new Node(n.str, curr.cost * n.cost));\\n                visited.add(n.str);\\n            }\\n        }\\n        return -1.0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Node {\\n        private String str;\\n        private Double cost;\\n        public Node(String str, Double cost) {\\n            this.str = str;\\n            this.cost = cost;\\n        }\\n    }\\n    \\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        Map<String, List<Node>> map = new HashMap<>();\\n        for (int i = 0; i < equations.size(); i++) {\\n            List<String> curr = equations.get(i);\\n\\n            if (!map.containsKey(curr.get(0)))  map.put(curr.get(0), new ArrayList<>());\\n            if (!map.containsKey(curr.get(1)))  map.put(curr.get(1), new ArrayList<>());\\n\\n            \\n            map.get(curr.get(0)).add(new Node(curr.get(1), values[i]));\\n            map.get(curr.get(1)).add(new Node(curr.get(0), 1 / values[i]));\\n        }\\n        \\n        double[] res = new double[queries.size()];\\n        for (int i = 0; i < res.length; i++) {\\n            List<String> query = queries.get(i);\\n            if (map.containsKey(query.get(0)) && map.containsKey(query.get(1))) {\\n                res[i] = bfs(map, query.get(0), query.get(1));\\n            } else \\n                res[i] = -1;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private double bfs(Map<String, List<Node>> map, String from, String to) {\\n        Queue<Node> queue = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        queue.add(new Node(from, 1.0));\\n        visited.add(from);\\n        while (!queue.isEmpty()) {\\n            Node curr = queue.poll();\\n            if (curr.str.equals(to)) \\n                return curr.cost;\\n            List<Node> next = map.get(curr.str);\\n            for (Node n : next) {\\n                if (visited.contains(n.str)) continue;\\n                queue.add(new Node(n.str, curr.cost * n.cost));\\n                visited.add(n.str);\\n            }\\n        }\\n        return -1.0;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805420,
                "title": "clean-python-solution-self-explained-with-other-similar-problems",
                "content": "```python\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def calcEquation(self, equations, values, queries):\\n\\t\\t#using DFS\\n        def find_val(n1, n2):\\n            if n1 not in graph or n2 not in graph: return -1\\n            if n1==n2: return 1\\n            if n2 in graph[n1]: return graph[n1][n2]\\n                \\n            stack = [(n1, 1)]\\n            visited = set()\\n            \\n            while stack:\\n                n, v = stack.pop() #v is the val of n1/n\\n\\t\\t\\t\\t\\n                if n in visited: continue\\n                visited.add(n)\\n                \\n                if n==n2:\\n                    graph[n1][n2] = v\\n                    return v\\n                \\n                stack.extend([(next_n, v*graph[n][next_n]) for next_n in graph[n]])\\n            return -1\\n        \\n        #build graph\\n        graph = defaultdict(dict)\\n        for i, v in enumerate(values):\\n            n1, n2 = equations[i][0], equations[i][1]\\n            graph[n1][n2] = v\\n            graph[n2][n1] = 1/v\\n        \\n        ans = []\\n        for n1, n2 in queries:\\n            ans.append(find_val(n1, n2))\\n            \\n        return ans\\n\\t\\t\\n\"\"\"\\nSimilar Problems: 399, 839, 952, 990, 721\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def calcEquation(self, equations, values, queries):\\n\\t\\t#using DFS\\n        def find_val(n1, n2):\\n            if n1 not in graph or n2 not in graph: return -1\\n            if n1==n2: return 1\\n            if n2 in graph[n1]: return graph[n1][n2]\\n                \\n            stack = [(n1, 1)]\\n            visited = set()\\n            \\n            while stack:\\n                n, v = stack.pop() #v is the val of n1/n\\n\\t\\t\\t\\t\\n                if n in visited: continue\\n                visited.add(n)\\n                \\n                if n==n2:\\n                    graph[n1][n2] = v\\n                    return v\\n                \\n                stack.extend([(next_n, v*graph[n][next_n]) for next_n in graph[n]])\\n            return -1\\n        \\n        #build graph\\n        graph = defaultdict(dict)\\n        for i, v in enumerate(values):\\n            n1, n2 = equations[i][0], equations[i][1]\\n            graph[n1][n2] = v\\n            graph[n2][n1] = 1/v\\n        \\n        ans = []\\n        for n1, n2 in queries:\\n            ans.append(find_val(n1, n2))\\n            \\n        return ans\\n\\t\\t\\n\"\"\"\\nSimilar Problems: 399, 839, 952, 990, 721\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791394,
                "title": "cpp-simple-dfs-and-hash-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& eqn, vector<double>& values, vector<vector<string>>& queries) {\\n        map<string,vector<pair<string,double>>>graph;\\n        for(int i=0;i<eqn.size();i++)\\n        {\\n            graph[eqn[i][0]].push_back({eqn[i][1],values[i]});\\n            graph[eqn[i][1]].push_back({eqn[i][0],1/values[i]});\\n        }\\n        vector<double>res;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            string s=queries[i][0];\\n            string d=queries[i][1];\\n            unordered_set<string>v;\\n            double ans=-1;\\n            if(graph.find(s)!=graph.end())\\n            dfs(s,d,graph,v,ans,1.0);\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n    void dfs(string s,string d,map<string,vector<pair<string,double>>>graph,unordered_set<string>visited,double &ans,double tmp)\\n    {\\n        if(visited.find(s)!=visited.end())\\n            return ;\\n        else\\n        {\\n            visited.insert(s);\\n            if(s==d)\\n            {\\n                ans=tmp;\\n                return;\\n            }\\n            else\\n            {\\n                for(auto it:graph[s])\\n                {\\n                    dfs(it.first,d,graph,visited,ans,tmp*it.second);\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& eqn, vector<double>& values, vector<vector<string>>& queries) {\\n        map<string,vector<pair<string,double>>>graph;\\n        for(int i=0;i<eqn.size();i++)\\n        {\\n            graph[eqn[i][0]].push_back({eqn[i][1],values[i]}",
                "codeTag": "Java"
            },
            {
                "id": 691964,
                "title": "c-solution-with-complete-explanation-explanation-beats-100-and-0-ms-solution",
                "content": "Before coming to the approach we will see why this problem fits into the graph, and whuch type of graph is suitable for this problem.\\na/b = 2, b/c = 3\\nif queries are, a/a = 1, b/b = 1 are simple\\na little complex will be a/c = a/b * b/c (transitive property)\\nmore difficult query can be a/f = a/b * b/c * c/d * d/e ...e/f\\nfrom this we observe that if we make numerator and denominator as seperate node in a graph and a directed edge between num. and deno. having weight corresponding to values(vector). \\nNow our graph should be able to process the query in reverse direction also i.e. if a/b = 2 is given, in our graph implementation along with this edge we should also consider b/a = 0.5 as a edge in graph.\\n***conclusion till here is that we make a directed weighted graph from the variable of equaions***\\nalso we use hashmap to convert first equation variable into 0, second into 1 and so on.(can easily be understood from code).\\n***before performing any query we will check its validity that both num. and denom. strings are present in hashmap or not, if not than it is not a valid query and simply result into -1.0***\\nif it result into a valid query than we will find a path from u to v in the graph (use visited array  to remember node already visited) and keep on multiplying edges weight while moving in the path, if a path does not exist between u and v we simply return -1.0 as seen from the recurrsion code.\\n\\n\\n***Code***\\n```\\ndouble findPath(vector<vector<double>>& graph,int n,int src,int dst,vector<bool>& visited){\\n    \\n    //basically here you have to find out the path starting from the vertex u and ending at vertex v\\n    //and multiply there weight as we progress\\n    visited[src] = true;\\n    if(visited[dst] == true)    return (double)1.0;\\n    \\n    for(int i=0;i<graph[src].size();i++){\\n        int neighbour = i;\\n        double weight = graph[src][i];\\n        if(weight != -1.0){\\n            if(!visited[neighbour]){\\n                double temp = (double)findPath(graph,n,neighbour,dst,visited);\\n                if(temp >=0) return (double)((double)weight * temp);\\n            }\\n        }\\n        \\n    }\\n    \\n    return (double)-1.0;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        //weighted ditrected graph is to be used in this case\\n        //good and brilliant question\\n        //just requires a little of insight\\n        \\n        //make a graph using equations and values, keep queries aside for a while\\n        unordered_map<string,int> mp;\\n        \\n        int count = 0;\\n        \\n        for(int i=0;i<equations.size();i++){\\n            string u = equations[i][0];\\n            string v = equations[i][1];\\n            if(mp.find(u) == mp.end()){\\n                mp[u] = count++;\\n            }\\n            if(mp.find(v) == mp.end()){\\n                mp[v] = count++;\\n            }\\n        }\\n        \\n        int n = count;\\n        //n  corresponds to the no. of the vertices in the graph\\n        vector<vector<double>> graph(n,vector<double>(n,-1.0));\\n        //-1.0 in the graph indicates that no valid path or edge exists between u and v\\n        \\n        //fill the weight in graph using values(vector)\\n        \\n        for(int i=0;i<equations.size();i++){\\n            \\n            int u = mp[equations[i][0]];\\n            int v = mp[equations[i][1]];\\n            \\n            graph[u][v] = values[i];\\n            graph[v][u] = (double)((double)1.0/values[i]);      //this part in the problem is really cool\\n        }\\n        \\n        //now we are set and from this point run all the queries before checking there validity\\n        vector<double> result;\\n        \\n        for(int i=0;i<queries.size();i++){\\n            \\n            string uSrc = queries[i][0];\\n            string vDst = queries[i][1];\\n            \\n            if(mp.find(uSrc) != mp.end() && mp.find(vDst) != mp.end()){\\n                \\n                if(uSrc == vDst){\\n                    result.push_back((double)1.0);\\n                }else{\\n                    int u = mp[uSrc];\\n                    int v = mp[vDst];\\n                    vector<bool> visited(n,false);\\n                    double ans = findPath(graph,n,u,v,visited);\\n                    result.push_back(ans);\\n                }\\n                \\n            }else{\\n                result.push_back((double)-1.0);\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nupvote if it helps!!!\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndouble findPath(vector<vector<double>>& graph,int n,int src,int dst,vector<bool>& visited){\\n    \\n    //basically here you have to find out the path starting from the vertex u and ending at vertex v\\n    //and multiply there weight as we progress\\n    visited[src] = true;\\n    if(visited[dst] == true)    return (double)1.0;\\n    \\n    for(int i=0;i<graph[src].size();i++){\\n        int neighbour = i;\\n        double weight = graph[src][i];\\n        if(weight != -1.0){\\n            if(!visited[neighbour]){\\n                double temp = (double)findPath(graph,n,neighbour,dst,visited);\\n                if(temp >=0) return (double)((double)weight * temp);\\n            }\\n        }\\n        \\n    }\\n    \\n    return (double)-1.0;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        //weighted ditrected graph is to be used in this case\\n        //good and brilliant question\\n        //just requires a little of insight\\n        \\n        //make a graph using equations and values, keep queries aside for a while\\n        unordered_map<string,int> mp;\\n        \\n        int count = 0;\\n        \\n        for(int i=0;i<equations.size();i++){\\n            string u = equations[i][0];\\n            string v = equations[i][1];\\n            if(mp.find(u) == mp.end()){\\n                mp[u] = count++;\\n            }\\n            if(mp.find(v) == mp.end()){\\n                mp[v] = count++;\\n            }\\n        }\\n        \\n        int n = count;\\n        //n  corresponds to the no. of the vertices in the graph\\n        vector<vector<double>> graph(n,vector<double>(n,-1.0));\\n        //-1.0 in the graph indicates that no valid path or edge exists between u and v\\n        \\n        //fill the weight in graph using values(vector)\\n        \\n        for(int i=0;i<equations.size();i++){\\n            \\n            int u = mp[equations[i][0]];\\n            int v = mp[equations[i][1]];\\n            \\n            graph[u][v] = values[i];\\n            graph[v][u] = (double)((double)1.0/values[i]);      //this part in the problem is really cool\\n        }\\n        \\n        //now we are set and from this point run all the queries before checking there validity\\n        vector<double> result;\\n        \\n        for(int i=0;i<queries.size();i++){\\n            \\n            string uSrc = queries[i][0];\\n            string vDst = queries[i][1];\\n            \\n            if(mp.find(uSrc) != mp.end() && mp.find(vDst) != mp.end()){\\n                \\n                if(uSrc == vDst){\\n                    result.push_back((double)1.0);\\n                }else{\\n                    int u = mp[uSrc];\\n                    int v = mp[vDst];\\n                    vector<bool> visited(n,false);\\n                    double ans = findPath(graph,n,u,v,visited);\\n                    result.push_back(ans);\\n                }\\n                \\n            }else{\\n                result.push_back((double)-1.0);\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676055,
                "title": "how-to-explain-to-interviewer-399-evaluate-division",
                "content": "# 399. Evaluate Division\\n[Evaluate Division](https://leetcode.com/problems/evaluate-division/)\\n#### 1. Clarify\\n(1) Is it possible that equations.size() != values.length?\\n(2) What if numerator and denominator in one of the queries are not contained by equations\\n(3) What if query.get(0).equals(query.get(1)) == true but they are not contained by equations?\\n(4) In values array, does 0 exsit? (if 0 exist, for example, a / b = 0, we know a = 0 but b/a is invalid)\\n\\n#### 2. Idea\\nThis question gives some divisions and their values, and wanted us to get the value of some divisions. Apparently, if we know a/b = x, b/c = y, c/d = z, it\\'s easy to get a/d = a/b * b/c * c/d = xyz. So to get a/d, our task is to check whether there exist a/b, b/c and c/d in the divisions given. We build graphs from given divisions and values. From the equation numerator/denominator = value, we can build two edges:\\n\\nnumerator ---(value)---> denominator\\ndenominator ----(value---> numerator\\n\\nIn this way, we build a graph. And whether we can get a/d depends on whether there is path from a to d in this graph. In the example above, we have a path: a --(x)--> b --(y)--> c --(z)--> d so a/d is invalid and the result is xyz\\n\\nApprantly, we should use dfs to search the path.\\n#### 3. Code\\n```java\\nclass Solution {\\n    \\n    private Map<String, Map<String, Double>> graph;\\n    private Set<String> visited;\\n\\n    public double[] calcEquation(List<List<String>> division, double[] values, List<List<String>> queries) {\\n        buildGraph(division, values);\\n        double[] quotients = new double[queries.size()];\\n\\n        for(int i = 0; i < queries.size(); i ++){\\n            List<String> query = queries.get(i);\\n            visited = new HashSet<>();\\n            quotients[i] = getQuotient(query.get(0), query.get(1));\\n        }\\n\\n        return quotients;\\n    }\\n\\n    private void buildGraph(List<List<String>> equations, double[] values){\\n        graph = new HashMap<>();\\n\\n        int sz = equations.size();\\n        for(int i = 0; i < sz; i ++){\\n            List<String> equation = equations.get(i);\\n            double value = values[i];\\n\\n            String numerator = equation.get(0);\\n            String denominator = equation.get(1);\\n\\n            if(!graph.containsKey(numerator)){\\n                graph.put(numerator, new HashMap<>());\\n            }\\n\\n            if(!graph.containsKey(denominator)){\\n                graph.put(denominator, new HashMap<>());\\n            }\\n\\n            graph.get(numerator).put(denominator, value);\\n            graph.get(denominator).put(numerator, 1.0 / value);\\n        }\\n    }\\n\\n    private double getQuotient(String numerator, String denominator){\\n        if(!graph.containsKey(numerator)) return -1.0;\\n        if(graph.get(numerator).containsKey(denominator)) return graph.get(numerator).get(denominator);\\n\\n        visited.add(numerator);\\n        for(String d: graph.get(numerator).keySet()){\\n            if(visited.contains(d)){\\n                continue;\\n            }\\n\\n            double quotient = getQuotient(d, denominator);\\n            if(quotient != -1){\\n                return graph.get(numerator).get(d) * quotient;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n#### 4. Test Cases (Run a test case in the interview)\\n#### 5. Complexity \\n#### **(I\\'m not sure whether this is correct, please let me know your comments)**\\nn = size of division = size of values\\nm = size of queries\\n\\nSpace Complexity: O(m + n)\\n- graph contains 2n vertices and 2n edges, so the cost of graph Map is 2n\\n- visited contains 2n vertices at most, so the cost of visited Set is 2n\\n- size of quotients[] is m\\n\\nTime Complexity: O(m*n + n) = O(mn)\\n- buldGraph() O(n) because it contains a for loop of n\\n- getQuotient() O(n) because Time Compleixty of DFS is O(V + E)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    private Map<String, Map<String, Double>> graph;\\n    private Set<String> visited;\\n\\n    public double[] calcEquation(List<List<String>> division, double[] values, List<List<String>> queries) {\\n        buildGraph(division, values);\\n        double[] quotients = new double[queries.size()];\\n\\n        for(int i = 0; i < queries.size(); i ++){\\n            List<String> query = queries.get(i);\\n            visited = new HashSet<>();\\n            quotients[i] = getQuotient(query.get(0), query.get(1));\\n        }\\n\\n        return quotients;\\n    }\\n\\n    private void buildGraph(List<List<String>> equations, double[] values){\\n        graph = new HashMap<>();\\n\\n        int sz = equations.size();\\n        for(int i = 0; i < sz; i ++){\\n            List<String> equation = equations.get(i);\\n            double value = values[i];\\n\\n            String numerator = equation.get(0);\\n            String denominator = equation.get(1);\\n\\n            if(!graph.containsKey(numerator)){\\n                graph.put(numerator, new HashMap<>());\\n            }\\n\\n            if(!graph.containsKey(denominator)){\\n                graph.put(denominator, new HashMap<>());\\n            }\\n\\n            graph.get(numerator).put(denominator, value);\\n            graph.get(denominator).put(numerator, 1.0 / value);\\n        }\\n    }\\n\\n    private double getQuotient(String numerator, String denominator){\\n        if(!graph.containsKey(numerator)) return -1.0;\\n        if(graph.get(numerator).containsKey(denominator)) return graph.get(numerator).get(denominator);\\n\\n        visited.add(numerator);\\n        for(String d: graph.get(numerator).keySet()){\\n            if(visited.contains(d)){\\n                continue;\\n            }\\n\\n            double quotient = getQuotient(d, denominator);\\n            if(quotient != -1){\\n                return graph.get(numerator).get(d) * quotient;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594120,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int index = 0;\\n        for(int i = 0; i < values.length; i++) {\\n            List<String> pair = equations.get(i);\\n            if(!map.containsKey(pair.get(0))) {\\n                map.put(pair.get(0), index++);\\n            }\\n            \\n            if(!map.containsKey(pair.get(1))) {\\n                map.put(pair.get(1), index++);\\n            }\\n        }\\n        \\n        int n = map.size();\\n        Double[][] graph = new Double[n][n];\\n        for(int i = 0; i < values.length; i++) {\\n            List<String> pair = equations.get(i);\\n            int a = map.get(pair.get(0)), b = map.get(pair.get(1));\\n            graph[a][b] = values[i];\\n            graph[b][a] = values[i] == 0 ? 0 : 1.0 / values[i];\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            boolean[] visited = new boolean[n];\\n            visited[i] = true;\\n            graph[i][i] = 1.0;\\n            dfs(i, i, 1.0, visited, graph);\\n        }\\n        \\n        double[] result = new double[queries.size()];\\n        for(int i = 0; i < result.length; i++) {\\n            List<String> q = queries.get(i);\\n            String from = q.get(0), to = q.get(1);\\n            if(map.containsKey(from) && map.containsKey(to) && graph[map.get(from)][map.get(to)] != null) {\\n                result[i] = graph[map.get(from)][map.get(to)];\\n            } else {\\n                result[i] = -1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void dfs(int start, int cur, double curValue, boolean[] visited, Double[][] graph) {\\n        for(int i = 0; i < visited.length; i++) {\\n            if(visited[i]) continue;\\n            if(graph[cur][i] != null) {\\n                graph[start][i] = curValue * graph[cur][i];\\n                visited[i] = true;\\n                dfs(start, i, curValue * graph[cur][i], visited, graph);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int index = 0;\\n        for(int i = 0; i < values.length; i++) {\\n            List<String> pair = equations.get(i);\\n            if(!map.containsKey(pair.get(0))) {\\n                map.put(pair.get(0), index++);\\n            }\\n            \\n            if(!map.containsKey(pair.get(1))) {\\n                map.put(pair.get(1), index++);\\n            }\\n        }\\n        \\n        int n = map.size();\\n        Double[][] graph = new Double[n][n];\\n        for(int i = 0; i < values.length; i++) {\\n            List<String> pair = equations.get(i);\\n            int a = map.get(pair.get(0)), b = map.get(pair.get(1));\\n            graph[a][b] = values[i];\\n            graph[b][a] = values[i] == 0 ? 0 : 1.0 / values[i];\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            boolean[] visited = new boolean[n];\\n            visited[i] = true;\\n            graph[i][i] = 1.0;\\n            dfs(i, i, 1.0, visited, graph);\\n        }\\n        \\n        double[] result = new double[queries.size()];\\n        for(int i = 0; i < result.length; i++) {\\n            List<String> q = queries.get(i);\\n            String from = q.get(0), to = q.get(1);\\n            if(map.containsKey(from) && map.containsKey(to) && graph[map.get(from)][map.get(to)] != null) {\\n                result[i] = graph[map.get(from)][map.get(to)];\\n            } else {\\n                result[i] = -1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void dfs(int start, int cur, double curValue, boolean[] visited, Double[][] graph) {\\n        for(int i = 0; i < visited.length; i++) {\\n            if(visited[i]) continue;\\n            if(graph[cur][i] != null) {\\n                graph[start][i] = curValue * graph[cur][i];\\n                visited[i] = true;\\n                dfs(start, i, curValue * graph[cur][i], visited, graph);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573748,
                "title": "java-bfs",
                "content": "So many Java DFS solutions, so here you have an example of BFS application. \\nBest!\\n```\\n\\nimport java.util.Map.Entry;\\n\\nclass Solution {\\n    public class Node {\\n        String var;\\n        double path = 1d;\\n        Map<Node, Double> neighbors = new HashMap<>();\\n        public Node(String var) { this.var = var; }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            return var.equals(((Node)o).var);\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            return var.hashCode();\\n        }\\n        \\n        @Override\\n        public String toString() {\\n        \\treturn \"Node:\"+var;\\n        }\\n    }\\n    private Map<String, Node> graph = new HashMap<>();\\n\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        \\n        for (int i = 0; i < values.length; i++) {\\n            List<String> e = equations.get(i);\\n            double value = values[i];\\n            insertIntoGraph(e, value);            \\n        }\\n        \\n        \\n        double[] results = new double[queries.size()];\\n        \\n        // executing bread-first-search BFS for each query \\n        for (int i = 0; i < queries.size(); i++) {\\n            List<String> q = queries.get(i);\\n            \\n        \\tresults[i] = bfs(q);\\n        }\\n        \\n        return results;\\n    }\\n    \\n    public double bfs(List<String> equation) {\\n        Node src = graph.get(equation.get(0));\\n        Node dst = graph.get(equation.get(1));\\n        \\n        if (src == null || dst == null)\\n        \\treturn -1d;\\n        \\n        // e.g. a -> a\\n        if (src.equals(dst))\\n        \\treturn 1d;\\n        \\n        Queue<Node> q = new LinkedList<>();\\n        q.add(src);\\n        Set<Node> visited = new HashSet<>();\\n        visited.add(src);\\n        src.path = 1d; // reseting current path to 1.0\\n        \\n        while (!q.isEmpty()) {\\n            Node node = q.poll();\\n            double currentValuePath = node.path;\\n            \\n            for (Entry<Node, Double> neighbor : node.neighbors.entrySet()) {\\n                Node n = neighbor.getKey();\\n                double value = neighbor.getValue();\\n                \\n                if (visited.contains(n)) {\\n                \\tsrc.path = 1;\\n                    continue;\\n                }\\n                \\n                // calculate the path\\n                n.path = value * currentValuePath;\\n                \\n                if (n.equals(dst))\\n                    return n.path;\\n                \\n                q.add(n);\\n                visited.add(n);\\n\\n            }\\n        }\\n        \\n        return -1d;\\n    }\\n    \\n    public void insertIntoGraph(List<String> e, double value) {\\n        Node src = graph.getOrDefault(e.get(0), new Node(e.get(0)));\\n        Node dst = graph.getOrDefault(e.get(1), new Node(e.get(1))); \\n        src.neighbors.put(dst, value);\\n        dst.neighbors.put(src, 1d/value);\\n        \\n        graph.put(src.var, src);\\n        graph.put(dst.var, dst);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nimport java.util.Map.Entry;\\n\\nclass Solution {\\n    public class Node {\\n        String var;\\n        double path = 1d;\\n        Map<Node, Double> neighbors = new HashMap<>();\\n        public Node(String var) { this.var = var; }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            return var.equals(((Node)o).var);\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            return var.hashCode();\\n        }\\n        \\n        @Override\\n        public String toString() {\\n        \\treturn \"Node:\"+var;\\n        }\\n    }\\n    private Map<String, Node> graph = new HashMap<>();\\n\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n        \\n        for (int i = 0; i < values.length; i++) {\\n            List<String> e = equations.get(i);\\n            double value = values[i];\\n            insertIntoGraph(e, value);            \\n        }\\n        \\n        \\n        double[] results = new double[queries.size()];\\n        \\n        // executing bread-first-search BFS for each query \\n        for (int i = 0; i < queries.size(); i++) {\\n            List<String> q = queries.get(i);\\n            \\n        \\tresults[i] = bfs(q);\\n        }\\n        \\n        return results;\\n    }\\n    \\n    public double bfs(List<String> equation) {\\n        Node src = graph.get(equation.get(0));\\n        Node dst = graph.get(equation.get(1));\\n        \\n        if (src == null || dst == null)\\n        \\treturn -1d;\\n        \\n        // e.g. a -> a\\n        if (src.equals(dst))\\n        \\treturn 1d;\\n        \\n        Queue<Node> q = new LinkedList<>();\\n        q.add(src);\\n        Set<Node> visited = new HashSet<>();\\n        visited.add(src);\\n        src.path = 1d; // reseting current path to 1.0\\n        \\n        while (!q.isEmpty()) {\\n            Node node = q.poll();\\n            double currentValuePath = node.path;\\n            \\n            for (Entry<Node, Double> neighbor : node.neighbors.entrySet()) {\\n                Node n = neighbor.getKey();\\n                double value = neighbor.getValue();\\n                \\n                if (visited.contains(n)) {\\n                \\tsrc.path = 1;\\n                    continue;\\n                }\\n                \\n                // calculate the path\\n                n.path = value * currentValuePath;\\n                \\n                if (n.equals(dst))\\n                    return n.path;\\n                \\n                q.add(n);\\n                visited.add(n);\\n\\n            }\\n        }\\n        \\n        return -1d;\\n    }\\n    \\n    public void insertIntoGraph(List<String> e, double value) {\\n        Node src = graph.getOrDefault(e.get(0), new Node(e.get(0)));\\n        Node dst = graph.getOrDefault(e.get(1), new Node(e.get(1))); \\n        src.neighbors.put(dst, value);\\n        dst.neighbors.put(src, 1d/value);\\n        \\n        graph.put(src.var, src);\\n        graph.put(dst.var, dst);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540975,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        unordered_map<string, vector<pair<string, double>>> m;\\n        for (int i = 0; i < equations.size(); i++)\\n        {\\n            m[equations[i][0]].push_back(pair(equations[i][1], values[i]));\\n            m[equations[i][1]].push_back(pair(equations[i][0], 1.0 / values[i]));\\n        }\\n        vector<double> ret;\\n        for (auto q : queries)\\n        {\\n            if (m.find(q[0]) == m.end() || m.find(q[1]) == m.end())\\n            {\\n                ret.push_back(-1.0);\\n                continue;\\n            }\\n            if (q[0] == q[1])\\n            {\\n                ret.push_back(1.0);\\n                continue;\\n            }\\n            unordered_set<string> visited;\\n            visited.insert(q[0]);\\n            queue<pair<string, double>> que;\\n            que.push(pair(q[0], 1.0));\\n            bool found = false;\\n            while (que.empty() == false)\\n            {\\n                string curr = que.front().first;\\n                double ratio = que.front().second;\\n                if (curr == q[1])\\n                {\\n                    ret.push_back(ratio);\\n                    found = true;\\n                    break;\\n                }\\n                que.pop();\\n                for (auto x : m[curr])\\n                {\\n                    if (visited.find(x.first) != visited.end()) continue;\\n                    que.push(pair(x.first, ratio * x.second));\\n                    visited.insert(x.first);\\n                }\\n            }\\n            if (found == false) ret.push_back(-1.0);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        unordered_map<string, vector<pair<string, double>>> m;\\n        for (int i = 0; i < equations.size(); i++)\\n        {\\n            m[equations[i][0]].push_back(pair(equations[i][1], values[i]));\\n            m[equations[i][1]].push_back(pair(equations[i][0], 1.0 / values[i]));\\n        }\\n        vector<double> ret;\\n        for (auto q : queries)\\n        {\\n            if (m.find(q[0]) == m.end() || m.find(q[1]) == m.end())\\n            {\\n                ret.push_back(-1.0);\\n                continue;\\n            }\\n            if (q[0] == q[1])\\n            {\\n                ret.push_back(1.0);\\n                continue;\\n            }\\n            unordered_set<string> visited;\\n            visited.insert(q[0]);\\n            queue<pair<string, double>> que;\\n            que.push(pair(q[0], 1.0));\\n            bool found = false;\\n            while (que.empty() == false)\\n            {\\n                string curr = que.front().first;\\n                double ratio = que.front().second;\\n                if (curr == q[1])\\n                {\\n                    ret.push_back(ratio);\\n                    found = true;\\n                    break;\\n                }\\n                que.pop();\\n                for (auto x : m[curr])\\n                {\\n                    if (visited.find(x.first) != visited.end()) continue;\\n                    que.push(pair(x.first, ratio * x.second));\\n                    visited.insert(x.first);\\n                }\\n            }\\n            if (found == false) ret.push_back(-1.0);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537564,
                "title": "javascript-dfs",
                "content": "```javascript\\n/**\\n * @param {string[][]} equations\\n * @param {number[]} values\\n * @param {string[][]} queries\\n * @return {number[]}\\n */\\nconst calcEquation = (equations, values, queries) => {\\n    const graph = buildGraph(equations, values);\\n    \\n    const resp = new Array(queries.length);\\n    \\n    queries.forEach((query, i) => {\\n        const [u, v] = query;\\n        \\n        resp[i] = dfs(graph, u, v);\\n    });\\n    \\n    return resp;\\n};\\n\\nconst dfs = (graph, u, v) => {\\n    if(!graph.has(u) || !graph.has(v)) return -1;\\n    \\n    const stack = [{vertex: u, accum: 1}],\\n          visited = new Set();\\n    \\n    visited.add(u);\\n    let result = -1;\\n    while(stack.length) {\\n        const curr = stack.pop();\\n        if(curr.vertex === v) {\\n            result = curr.accum;\\n            break;\\n        }\\n        const adj = graph.get(curr.vertex);\\n        adj.forEach(edge => {\\n            const   dest = edge.v,\\n                    w = edge.w;\\n            if(!visited.has(dest)) {\\n                visited.add(dest);\\n                stack.push({vertex: dest, accum: curr.accum * w});\\n            }\\n        });\\n    }\\n    \\n    return result;\\n};\\n\\nconst buildGraph = (equations, values) => {\\n    const graph = new Map();\\n    \\n    equations.forEach((equation, i) => {\\n        const [u, v] = equation;\\n        const value = values[i];\\n        \\n        if(!graph.has(u)) graph.set(u, new Array());\\n        graph.get(u).push( {v: v, w: value} );\\n        \\n        if(!graph.has(v)) graph.set(v, new Array());\\n        graph.get(v).push({v: u, w: 1/value});\\n    });\\n    \\n    return graph;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript\\n/**\\n * @param {string[][]} equations\\n * @param {number[]} values\\n * @param {string[][]} queries\\n * @return {number[]}\\n */\\nconst calcEquation = (equations, values, queries) => {\\n    const graph = buildGraph(equations, values);\\n    \\n    const resp = new Array(queries.length);\\n    \\n    queries.forEach((query, i) => {\\n        const [u, v] = query;\\n        \\n        resp[i] = dfs(graph, u, v);\\n    });\\n    \\n    return resp;\\n};\\n\\nconst dfs = (graph, u, v) => {\\n    if(!graph.has(u) || !graph.has(v)) return -1;\\n    \\n    const stack = [{vertex: u, accum: 1}],\\n          visited = new Set();\\n    \\n    visited.add(u);\\n    let result = -1;\\n    while(stack.length) {\\n        const curr = stack.pop();\\n        if(curr.vertex === v) {\\n            result = curr.accum;\\n            break;\\n        }\\n        const adj = graph.get(curr.vertex);\\n        adj.forEach(edge => {\\n            const   dest = edge.v,\\n                    w = edge.w;\\n            if(!visited.has(dest)) {\\n                visited.add(dest);\\n                stack.push({vertex: dest, accum: curr.accum * w});\\n            }\\n        });\\n    }\\n    \\n    return result;\\n};\\n\\nconst buildGraph = (equations, values) => {\\n    const graph = new Map();\\n    \\n    equations.forEach((equation, i) => {\\n        const [u, v] = equation;\\n        const value = values[i];\\n        \\n        if(!graph.has(u)) graph.set(u, new Array());\\n        graph.get(u).push( {v: v, w: value} );\\n        \\n        if(!graph.has(v)) graph.set(v, new Array());\\n        graph.get(v).push({v: u, w: 1/value});\\n    });\\n    \\n    return graph;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 460417,
                "title": "java-bfs-100-time-and-space",
                "content": "```\\n\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n     int j = 0;\\n     HashMap<String,Integer> map = new HashMap<>();\\n        \\n     for(int i = 0; i < equations.size(); i++){\\n      List<String> l = equations.get(i);\\n      \\n      for(String s : l){\\n       if(!map.containsKey(s)){\\n        map.put(s,j++);  \\n       }     \\n     }\\n     }   \\n     double[][] graph = new double[j][j];\\n        \\n     for(int i = 0; i < equations.size(); i++){\\n      List<String> l = equations.get(i);\\n      int x = map.get(l.get(0)), y = map.get(l.get(1));\\n      \\n      graph[x][y] = values[i]; \\n      graph[y][x] = 1 / values[i];   \\n     }\\n        \\n     double[] ans = new double[queries.size()];\\n     for(int i = 0; i < queries.size(); i++){\\n      int x = map.getOrDefault(queries.get(i).get(0),-1);\\n      int y = map.getOrDefault(queries.get(i).get(1),-1);\\n      \\n      if(x == -1 || y == -1) ans[i] = -1;\\n      else   \\n      ans[i] = bfs(graph,x,y);   \\n     }\\n     return ans;   \\n    }\\n public double bfs(double[][] graph, int start,int end){\\n  Queue<Integer> q = new LinkedList<>();\\n     double[] valueStart = new double[graph.length];\\n     q.add(start);\\n     valueStart[start] = 1;\\n     boolean[] visited = new boolean[graph.length];\\n     visited[start] = true;   \\n        \\n     while(!q.isEmpty()){\\n      int t = q.poll();\\n      if(t == end) return valueStart[t];\\n         \\n      for(int i = 0; i < graph.length; i++){\\n       if(!visited[i] && graph[t][i] != 0){\\n        valueStart[i] = valueStart[t] * graph[t][i];\\n        q.add(i);\\n        visited[i] = true;   \\n       }   \\n      }   \\n     }\\n     return -1;\\n }   \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n     int j = 0;\\n     HashMap<String,Integer> map = new HashMap<>();\\n        \\n     for(int i = 0; i < equations.size(); i++){\\n      List<String> l = equations.get(i);\\n      \\n      for(String s : l){\\n       if(!map.containsKey(s)){\\n        map.put(s,j++);  \\n       }     \\n     }\\n     }   \\n     double[][] graph = new double[j][j];\\n        \\n     for(int i = 0; i < equations.size(); i++){\\n      List<String> l = equations.get(i);\\n      int x = map.get(l.get(0)), y = map.get(l.get(1));\\n      \\n      graph[x][y] = values[i]; \\n      graph[y][x] = 1 / values[i];   \\n     }\\n        \\n     double[] ans = new double[queries.size()];\\n     for(int i = 0; i < queries.size(); i++){\\n      int x = map.getOrDefault(queries.get(i).get(0),-1);\\n      int y = map.getOrDefault(queries.get(i).get(1),-1);\\n      \\n      if(x == -1 || y == -1) ans[i] = -1;\\n      else   \\n      ans[i] = bfs(graph,x,y);   \\n     }\\n     return ans;   \\n    }\\n public double bfs(double[][] graph, int start,int end){\\n  Queue<Integer> q = new LinkedList<>();\\n     double[] valueStart = new double[graph.length];\\n     q.add(start);\\n     valueStart[start] = 1;\\n     boolean[] visited = new boolean[graph.length];\\n     visited[start] = true;   \\n        \\n     while(!q.isEmpty()){\\n      int t = q.poll();\\n      if(t == end) return valueStart[t];\\n         \\n      for(int i = 0; i < graph.length; i++){\\n       if(!visited[i] && graph[t][i] != 0){\\n        valueStart[i] = valueStart[t] * graph[t][i];\\n        q.add(i);\\n        visited[i] = true;   \\n       }   \\n      }   \\n     }\\n     return -1;\\n }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354643,
                "title": "c-union-find-update-only-one-node-every-union-operation-with-explanation",
                "content": "```c++\\n    struct node\\n    {\\n\\t\\t// a / a.parent = a.value\\n        string parent;\\n        double value;\\n    };\\n```\\na / b = 2.0 ==> a.parent = b,  a.value = 2.0\\nSo a / d = a / b * b / c * c / d = a.value * b.value * c.value\\nWhen union, we find a\\'s root is d, and `a = x * d`; e\\'s root is f, and `e = y * f`\\nsince now `a / e = z`, so ` d / f = z * y / x`\\n\\nand we calculate this when find.\\n```c++\\nclass Solution\\n{\\npublic:\\n    vector<double> calcEquation(vector<vector<string>> &equations, vector<double> &values, vector<vector<string>> &queries)\\n    {\\n        unordered_map<string, node> id;\\n        for (int i = 0; i < equations.size(); i++)\\n        {\\n            string a = equations[i][0], b = equations[i][1];\\n            if (!id.count(a)) {\\n                id[a].parent = a;\\n                id[a].value = 1;\\n            }\\n            if (!id.count(b))\\n            {\\n                id[b].parent = b;\\n                id[b].value = 1.0;\\n            }\\n            Union(a, b, values[i], id);\\n        }\\n        vector<double> ans;\\n        for (auto q : queries)\\n        {\\n            if (!id.count(q[0]) || !id.count(q[1]))\\n                ans.push_back(-1);\\n            else\\n            {\\n                double va = 1, vb = 1;\\n                string aroot = find(q[0], id, va);\\n                string broot = find(q[1], id, vb);\\n                if (aroot != broot)\\n                    ans.push_back(-1);\\n                else\\n                    ans.push_back(va / vb);\\n            }\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    struct node\\n    {\\n        string parent;\\n        double value;\\n    };\\n\\n    string find(string s, unordered_map<string, node> &id, double &v)\\n    {\\n        while (id[s].parent != s)\\n        {\\n            v = v * id[s].value;\\n            s = id[s].parent;\\n        }\\n        return s;\\n    }\\n\\n    void Union(string a, string b, double v, unordered_map<string, node> &id)\\n    {\\n        double va = 1.0, vb = 1.0;\\n        string aroot = find(a, id, va);\\n        string broot = find(b, id, vb);\\n        if (aroot == broot)\\n            return;\\n        id[aroot].parent = broot;\\n        id[aroot].value = v * vb / va;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n    struct node\\n    {\\n\\t\\t// a / a.parent = a.value\\n        string parent;\\n        double value;\\n    };\\n```\n```c++\\nclass Solution\\n{\\npublic:\\n    vector<double> calcEquation(vector<vector<string>> &equations, vector<double> &values, vector<vector<string>> &queries)\\n    {\\n        unordered_map<string, node> id;\\n        for (int i = 0; i < equations.size(); i++)\\n        {\\n            string a = equations[i][0], b = equations[i][1];\\n            if (!id.count(a)) {\\n                id[a].parent = a;\\n                id[a].value = 1;\\n            }\\n            if (!id.count(b))\\n            {\\n                id[b].parent = b;\\n                id[b].value = 1.0;\\n            }\\n            Union(a, b, values[i], id);\\n        }\\n        vector<double> ans;\\n        for (auto q : queries)\\n        {\\n            if (!id.count(q[0]) || !id.count(q[1]))\\n                ans.push_back(-1);\\n            else\\n            {\\n                double va = 1, vb = 1;\\n                string aroot = find(q[0], id, va);\\n                string broot = find(q[1], id, vb);\\n                if (aroot != broot)\\n                    ans.push_back(-1);\\n                else\\n                    ans.push_back(va / vb);\\n            }\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    struct node\\n    {\\n        string parent;\\n        double value;\\n    };\\n\\n    string find(string s, unordered_map<string, node> &id, double &v)\\n    {\\n        while (id[s].parent != s)\\n        {\\n            v = v * id[s].value;\\n            s = id[s].parent;\\n        }\\n        return s;\\n    }\\n\\n    void Union(string a, string b, double v, unordered_map<string, node> &id)\\n    {\\n        double va = 1.0, vb = 1.0;\\n        string aroot = find(a, id, va);\\n        string broot = find(b, id, vb);\\n        if (aroot == broot)\\n            return;\\n        id[aroot].parent = broot;\\n        id[aroot].value = v * vb / va;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308519,
                "title": "golang",
                "content": "```\\nfunc calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\\n\\tgraph := make(map[string]map[string]float64)\\n\\tfor i := 0; i < len(equations); i++ {\\n\\t\\tfirst, second := equations[i][0], equations[i][1]\\n\\t\\tif _, ok := graph[first]; !ok {\\n\\t\\t\\tgraph[first] = make(map[string]float64)\\n\\t\\t}\\n\\t\\tif _, ok := graph[second]; !ok {\\n\\t\\t\\tgraph[second] = make(map[string]float64)\\n\\t\\t}\\n\\n\\t\\tgraph[first][second] = values[i]\\n\\t\\tgraph[second][first] = 1.0 / values[i]\\n\\t}\\n\\n\\tans := make([]float64, len(queries))\\n\\tfor i, query := range queries {\\n\\t\\tans[i] = helper(graph, query)\\n\\t}\\n\\n\\treturn ans\\n}\\n\\nfunc helper(graph map[string]map[string]float64, query []string) float64 {\\n\\tfirst, second := query[0], query[1]\\n\\tif _, ok1 := graph[first]; !ok1 {\\n\\t\\treturn -1.0\\n\\t}\\n\\tif _, ok2 := graph[second]; !ok2 {\\n\\t\\treturn -1.0\\n\\t}\\n\\n\\tif first == second {\\n\\t\\treturn 1.0\\n\\t}\\n\\n\\tvisited := make(map[string]bool)\\n\\treturn dfs(visited, graph, first, second)\\n}\\n\\nfunc dfs(visited map[string]bool, graph map[string]map[string]float64, current string, target string) float64 {\\n\\tif current == target {\\n\\t\\treturn 1.0\\n\\t}\\n\\n\\tif _, ok := visited[current]; ok {\\n\\t\\treturn -1.0\\n\\t}\\n\\n\\tvisited[current] = true\\n\\tneighbors := graph[current]\\n\\tfor neighbor, val := range neighbors {\\n\\t\\tret := dfs(visited, graph, neighbor, target)\\n\\t\\tif ret == -1.0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\treturn ret * val\\n\\t}\\n\\n\\treturn -1.0\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\\n\\tgraph := make(map[string]map[string]float64)\\n\\tfor i := 0; i < len(equations); i++ {\\n\\t\\tfirst, second := equations[i][0], equations[i][1]\\n\\t\\tif _, ok := graph[first]; !ok {\\n\\t\\t\\tgraph[first] = make(map[string]float64)\\n\\t\\t}\\n\\t\\tif _, ok := graph[second]; !ok {\\n\\t\\t\\tgraph[second] = make(map[string]float64)\\n\\t\\t}\\n\\n\\t\\tgraph[first][second] = values[i]\\n\\t\\tgraph[second][first] = 1.0 / values[i]\\n\\t}\\n\\n\\tans := make([]float64, len(queries))\\n\\tfor i, query := range queries {\\n\\t\\tans[i] = helper(graph, query)\\n\\t}\\n\\n\\treturn ans\\n}\\n\\nfunc helper(graph map[string]map[string]float64, query []string) float64 {\\n\\tfirst, second := query[0], query[1]\\n\\tif _, ok1 := graph[first]; !ok1 {\\n\\t\\treturn -1.0\\n\\t}\\n\\tif _, ok2 := graph[second]; !ok2 {\\n\\t\\treturn -1.0\\n\\t}\\n\\n\\tif first == second {\\n\\t\\treturn 1.0\\n\\t}\\n\\n\\tvisited := make(map[string]bool)\\n\\treturn dfs(visited, graph, first, second)\\n}\\n\\nfunc dfs(visited map[string]bool, graph map[string]map[string]float64, current string, target string) float64 {\\n\\tif current == target {\\n\\t\\treturn 1.0\\n\\t}\\n\\n\\tif _, ok := visited[current]; ok {\\n\\t\\treturn -1.0\\n\\t}\\n\\n\\tvisited[current] = true\\n\\tneighbors := graph[current]\\n\\tfor neighbor, val := range neighbors {\\n\\t\\tret := dfs(visited, graph, neighbor, target)\\n\\t\\tif ret == -1.0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\treturn ret * val\\n\\t}\\n\\n\\treturn -1.0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 296437,
                "title": "swift-dfs-solution",
                "content": "```swift\\nclass Solution {\\n    func calcEquation(_ equations: [[String]], _ values: [Double], _ queries: [[String]]) -> [Double] {\\n        var graph = [String : [(String, Double)]]()\\n        \\n        for i in 0..<equations.count {\\n            let equation = equations[i], value = values[i]\\n            let from = equation[0], to = equation[1]\\n            graph[from, default: []].append((to, value))\\n            graph[to, default: []].append((from, 1 / value))\\n        }\\n        \\n        var visited = Set<String>()\\n        return queries.map { calc(&graph, $0[0], $0[1], &visited) }\\n    }\\n    \\n    func calc(_ graph: inout [String : [(String, Double)]], _ from: String, _ to: String, _ visited: inout Set<String>) -> Double {\\n        guard graph[from] != nil && graph[to] != nil else { return -1.0 }\\n        if from == to { return 1.0 }\\n        \\n        visited.insert(from)\\n        var ans: Double = -1.0\\n        for (next, value) in graph[from]! where !visited.contains(next) {\\n            let nextValue = calc(&graph, next, to, &visited)\\n            if nextValue > 0 {\\n                ans = value * nextValue\\n                break\\n            }\\n        }\\n        visited.remove(from)\\n\\n        // update graph for faster searching\\n        if ans > 0 {\\n            graph[from, default: []].append((to, ans))\\n            graph[to, default: []].append((from, 1 / ans))\\n        }        \\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func calcEquation(_ equations: [[String]], _ values: [Double], _ queries: [[String]]) -> [Double] {\\n        var graph = [String : [(String, Double)]]()\\n        \\n        for i in 0..<equations.count {\\n            let equation = equations[i], value = values[i]\\n            let from = equation[0], to = equation[1]\\n            graph[from, default: []].append((to, value))\\n            graph[to, default: []].append((from, 1 / value))\\n        }\\n        \\n        var visited = Set<String>()\\n        return queries.map { calc(&graph, $0[0], $0[1], &visited) }\\n    }\\n    \\n    func calc(_ graph: inout [String : [(String, Double)]], _ from: String, _ to: String, _ visited: inout Set<String>) -> Double {\\n        guard graph[from] != nil && graph[to] != nil else { return -1.0 }\\n        if from == to { return 1.0 }\\n        \\n        visited.insert(from)\\n        var ans: Double = -1.0\\n        for (next, value) in graph[from]! where !visited.contains(next) {\\n            let nextValue = calc(&graph, next, to, &visited)\\n            if nextValue > 0 {\\n                ans = value * nextValue\\n                break\\n            }\\n        }\\n        visited.remove(from)\\n\\n        // update graph for faster searching\\n        if ans > 0 {\\n            graph[from, default: []].append((to, ans))\\n            graph[to, default: []].append((from, 1 / ans))\\n        }        \\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256363,
                "title": "java-dfs",
                "content": "```java\\nclass Solution {\\n\\n    private Map<String, Map<String, Double>> map;\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n\\n        // map<varialbe, map<varialbe, weight>>\\n        map = new HashMap<>();\\n        for (int i = 0; i < equations.size(); i++) {\\n            String a = equations.get(i).get(0);\\n            String b = equations.get(i).get(1);\\n\\n            map.putIfAbsent(a, new HashMap<>());\\n            map.putIfAbsent(b, new HashMap<>());\\n\\n            map.get(a).put(b, values[i]);\\n            map.get(b).put(a, 1.0 / values[i]);\\n        }\\n\\n        double[] ans = new double[queries.size()];\\n        for (int i = 0; i < queries.size(); i++) {\\n            String a = queries.get(i).get(0);\\n            String b = queries.get(i).get(1);\\n\\n            if (!map.containsKey(a) || !map.containsKey(b)) {\\n                ans[i] = -1;\\n            } else if (a.equals(b)) {\\n                ans[i] = 1;\\n            } else {\\n                Set<String> visited = new HashSet<>();\\n                ans[i] = dfs(visited, a, b, 1);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private double dfs(Set<String> visited, String cur, String target, double val) {\\n        visited.add(cur);\\n        if (cur.equals(target)) {\\n            return val;\\n        }\\n\\n        for (String next : map.get(cur).keySet()) {\\n            if (visited.contains(next)) continue;\\n            double ans = dfs(visited, next, target, val * map.get(cur).get(next));\\n            if (ans != -1) return ans;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n\\n    private Map<String, Map<String, Double>> map;\\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\\n\\n        // map<varialbe, map<varialbe, weight>>\\n        map = new HashMap<>();\\n        for (int i = 0; i < equations.size(); i++) {\\n            String a = equations.get(i).get(0);\\n            String b = equations.get(i).get(1);\\n\\n            map.putIfAbsent(a, new HashMap<>());\\n            map.putIfAbsent(b, new HashMap<>());\\n\\n            map.get(a).put(b, values[i]);\\n            map.get(b).put(a, 1.0 / values[i]);\\n        }\\n\\n        double[] ans = new double[queries.size()];\\n        for (int i = 0; i < queries.size(); i++) {\\n            String a = queries.get(i).get(0);\\n            String b = queries.get(i).get(1);\\n\\n            if (!map.containsKey(a) || !map.containsKey(b)) {\\n                ans[i] = -1;\\n            } else if (a.equals(b)) {\\n                ans[i] = 1;\\n            } else {\\n                Set<String> visited = new HashSet<>();\\n                ans[i] = dfs(visited, a, b, 1);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private double dfs(Set<String> visited, String cur, String target, double val) {\\n        visited.add(cur);\\n        if (cur.equals(target)) {\\n            return val;\\n        }\\n\\n        for (String next : map.get(cur).keySet()) {\\n            if (visited.contains(next)) continue;\\n            double ans = dfs(visited, next, target, val * map.get(cur).get(next));\\n            if (ans != -1) return ans;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241978,
                "title": "python-union-find",
                "content": "```\\nclass Solution:\\n    def calcEquation(self, equations: \\'List[List[str]]\\', values: \\'List[float]\\', queries: \\'List[List[str]]\\') -> \\'List[float]\\':\\n        parent = {}\\n\\n        def root(a):\\n            if a in parent:\\n                p, ma = parent[a]\\n                if p != a:\\n                    r, m = root(p)\\n                    parent[a] = (r, m*ma)\\n            else:\\n                parent[a] = (a, 1.0)\\n            return parent[a]\\n        for i, (a,b) in enumerate(equations):\\n            ra, ma = root(a)\\n            rb, mb = root(b)\\n            if ra != rb:\\n                parent[ra] = (rb, mb*values[i]/ma)\\n\\n        res = []\\n        for a, b in queries:\\n            if a not in parent or b not in parent:\\n                res.append(-1.0)\\n            else:\\n                ra, ma = root(a)\\n                rb, mb = root(b)\\n                res.append(ma/mb if ra == rb else -1.0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def calcEquation(self, equations: \\'List[List[str]]\\', values: \\'List[float]\\', queries: \\'List[List[str]]\\') -> \\'List[float]\\':\\n        parent = {}\\n\\n        def root(a):\\n            if a in parent:\\n                p, ma = parent[a]\\n                if p != a:\\n                    r, m = root(p)\\n                    parent[a] = (r, m*ma)\\n            else:\\n                parent[a] = (a, 1.0)\\n            return parent[a]\\n        for i, (a,b) in enumerate(equations):\\n            ra, ma = root(a)\\n            rb, mb = root(b)\\n            if ra != rb:\\n                parent[ra] = (rb, mb*values[i]/ma)\\n\\n        res = []\\n        for a, b in queries:\\n            if a not in parent or b not in parent:\\n                res.append(-1.0)\\n            else:\\n                ra, ma = root(a)\\n                rb, mb = root(b)\\n                res.append(ma/mb if ra == rb else -1.0)\\n        return res\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564604,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1899742,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1565603,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1640627,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1565360,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1565814,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1567327,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1568009,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1871047,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1576772,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1564604,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1899742,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1565603,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1640627,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1565360,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1565814,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1567327,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1568009,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1871047,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1576772,
                "content": [
                    {
                        "username": "elmubark",
                        "content": "This is definitely not a medium problem."
                    },
                    {
                        "username": "sinhaprem636",
                        "content": "Well I know I am dumb cause I suck but I got the logic almost instantly when I saw it is a graph problem."
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) It depends on your familiarity with DFS/BFS vs DSU.\\nDSU is almost always easier in terms of both thinking about it and implementing it.\\n(Remember the DSU is an abstract data structure ready to be used while DFS/BFS is different code for different problems)\\n\\nThat being said, this problem requires a modified version of DSU so I understand some people might not feel it\\'s that easy to use."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) Point taken. That still doesn't make it any easier than a dfs or bfs. The dsu solution is just a layer of abstraction on top of all the rest"
                    },
                    {
                        "username": "hero080",
                        "content": "[@cartesPerforees](/cartesPerforees) No, dfs/bfs is less efficient compared to dsu for this problem. DSU achieves $$\\\\Theta(N + M)$$ while dfs/bfs can only do $$\\\\Theta(N * M)$$."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@cartesPerforees](/cartesPerforees)  I am so dumb I couldnot identify it as graph problem even after seeing the hints, I think I have to jump to editorial . Kudos to u for solving this problem:)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@hero080](/hero080) I know union find and this is not an easy-medium. \n\nThe difficulty lies in analyzing that you can turn this into a graph in the first place. Once you understood that, doing a dfs/bfs is a lot more straight forward and efficient than a dsu anyway."
                    },
                    {
                        "username": "hero080",
                        "content": "It\\'s a hard-medium problem if you use DFS.\\nIt\\'s a hard problem if the input size is $$10^5$$ `equations` and $$10^5$$ `queries`.\\nBut it would become an easy-medium problem if you have learned the union find data structure.\\nThe intuition explanation:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "Few things to be clear before starting:\n1. If `x / y` is asked and either `x` or `y` are not in `equations`, we return -1, even if it is `x / x`.\n2. In Example 2, `\"bc\"` is a single variable, it is **NOT** `b * c`. Treat every string `equations[i][j]` as an atomic variable, not a product of some.\n\n# Hint 1\nOne thing that you might have thought is that if we are given $a/b=n_1$ and $b/c=n_2$, then we can calculate $a/c$ as $(a/b) * (b/c) = n_1 n_2$. We can multiply or divide few given equations to cancel out some variables and generate new equations.\nLet's remove the option to divide by rearranging the equations in the form $a = n_1 b$ and $b = n_2 c$. How can we generate $a$ in terms of $c$ now?\n\n# Hint 2\nTo write $a$ in terms of $c$, let's start with $a = n_1 b$. Put the value of $b$ from $b = n_2 c$. New equation will be $a = n_1 (n_2 c) = n_1 n_2 c = n_3 c$, where $n_3 = n_1 n_2$ is the answer for $a/c$.\nSo, if we want to generate some variable $x$ in terms of some other variable $y$, then we need some set of equations of the form\n$x = n_1 x_1$\n$x_1 = n_2 x_2$\n$x_2 = n_3 x_3$\n$.$\n$.$\n$.$\n$x_k = n_{k+1} y$\nUsing these equations we can start from $x$ and reach $y$ because there exists a **path** of variables $[x_1, x_2,...,x_k]$ between them.\nAnd the final answer would become the product $n_1 n_2 n_3 ... n_{k+1}$.\n\n# Hint 3\nTo get a path from $x$ to $y$, we need to keep track of every equation of the form $x = n_i x_i$ which starts with $x$ and goes to some other variables $x_i$. We need this information for every given variable so that we can check if some variables put together will form a path or not.\nTo do this, we can put them in a graph where each vertex will denote a variable and each edge will denote a relation of variables for equations $a = n b$.\nFor example, if $a = 2b$ then graph will be\n![image.png](https://assets.leetcode.com/users/images/25e9b6d3-a1ad-4d0c-aef1-0a9b31223ad4_1684590881.5234437.png)\nWill this graph be directed or undirected? If $a=2b$ then is $b=2a$?\n\n# Hint 4\nWe need to make a directed graph for equations $a=n b$. But what if we want to calculate $b$ in terms of $a$? If $a = nb$ is an equation, then $b=(1/n)a$ is also another equation by which we can get $b$ in terms of $a$.\nFor example, if $a = 2b$, then graph will have 2 directed edges as\n![image.png](https://assets.leetcode.com/users/images/e1698aa9-a464-4685-b35e-9846e9fdc776_1684590750.7325034.png)\n\n# Hint 5\nLet's make graph for Example 2:\n```\nequations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\nvalues    = [ 1.5,      2.5,      5.0]\n```\nThe equations are $a=1.5b$, $b=2.5c$, $bc = 5.0cd$. ($bc$ is just another different variable it is **NOT** equal to $b * c$)\nThe graph will be:\n![image.png](https://assets.leetcode.com/users/images/e067d848-dba4-47aa-a1da-aa2158fddcf5_1684590679.972568.png)\n\nNow, calculate for given queries\n```\nqueries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n```\n1. Calculate $a$ in terms of $c$ as $a=1.5b=1.5(2.5c)=3.75c$\n2. Calculate $c$ in terms of $b$ as $c=0.4b$\n3. Calculate $bc$ in terms of $cd$ as $bc=5cd$\n4. Calculate $cd$ in terms of $bc$ as $cd=0.2bc$\n\n# Hint 6\nCan we calculate $a$ in terms of $bc$? No, there is no path of variables between them.\nCalculating some variable $x$ in terms of some other variable $y$ is same as finding a valid path between $x$ and $y$, where the final answer of $x/y$ will be the product of weights of edges $n_i$'s that are present in the path.\n\n# Hint 7\nMake the graph. For every equation $a=nb$, add two edges `a --n--> b` and `a <--1/n-- b`.\nFor each query $[c,d]$, check if such nodes even exists in the graph or not. If they don't even exist, there is no path, return `-1` (Like in Example 1, `x` does not exists so return `-1` even if we just wanted `x / x`).\nIf both $c$ and $d$ exists in the graph, traverse the graph to get a path between them, maintaining cost of path as product of weights of edges traversed. If path is found return the product, and if not, then `-1`.\n\nUpvote if helps!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "You are the best my friend. I\\'m traying to do some maths but I didn\\'t  see the graph there. The wors\\'t thing I did was seeing the hint when I had figured out some maths to calculate the querys, when I see it is a graph, my mind blows out. LOL"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@yakode](/yakode) Thank you! Not right now, but hey good idea, I\\'ll give it a try \\uD83D\\uDE04"
                    },
                    {
                        "username": "cJayesh",
                        "content": "For a moment I thought I am in editorial. (y)"
                    },
                    {
                        "username": "yakode",
                        "content": "I love your hint comments!\\nDo you have a blog about leetcode?"
                    },
                    {
                        "username": "pthread",
                        "content": "Considering how many possible ways to approach this problem for a more optimal solution there are and how many smaller sub-algorithms can and should be implemented, this is definitely hard level question."
                    },
                    {
                        "username": "marinho",
                        "content": "Medium??? are you kidding? lol"
                    },
                    {
                        "username": "TatianaVol",
                        "content": "It is really easy problem, maybe a bit unusual))\n\n![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find `A / C` we just need to find the path and multiplay all edges coefficient: `2 * 3 = 6`"
                    },
                    {
                        "username": "omnomnious",
                        "content": "The solution according to the question is -1.0, but x/x should be 1 assuming none of the input is invalid and no division by 0 (which the question says is an assumption)."
                    },
                    {
                        "username": "hero080",
                        "content": "[@Charlemagne5t](/Charlemagne5t) Yes, I think the problem needs to clarify  that point.\\nAlthough it won\\'t really affect the solution. It is quite trivial to add edge case handling in most solutions.\\nFor example, in [this solution](https://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-on-m-most-efficient-solution-modified-unionfind-simple-code/) we can simply add check if `c == d` and if they do we return 1 without trying to find their representative base."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@psionl0](/psionl0) \\n\"If a single answer cannot be determined, return -1.0.\" There is nothing about existing variables. Answer can be determined. Wording in the question is not perfect. We have this case in example though so it\\'s not a biggest issue in this problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@psionl0](/psionl0) This is not what the problem specifies. The problem specifies that the answer should be -1 if you can't determine the result.\nYou can determine the result of $\\\\frac{x}{x}$, even without any information on x (provided $x \\\\neq 0$)"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"x\" is not in the pairs of variables so the answer becomes -1."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/evaluate-division/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Path Search in Graph\n\n  \n**Approach 2:** Union-Find with Weights\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "calvin25",
                        "content": "it says \"the queries will result in no division by zero\", then why x/x is -1.0? x will not be 0 in this case so x/x should be 1.0. Did I miss anything?"
                    },
                    {
                        "username": "pspdragon",
                        "content": "There is no guarantee that \"X\" is a number, it could be a string or NAN."
                    },
                    {
                        "username": "crystal11101",
                        "content": "[@pavan_kumar2000](/pavan_kumar2000) Read the question and comment properly, values are limited to 20"
                    },
                    {
                        "username": "m-d-nabeel",
                        "content": "My submissions went wrong because of this\\n0.0 < values[i] <= 20.0\\nIn this domain \"X\" / \"X\" will always be one I don\\'t know what I missed"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "It\\'s simply because x does not exists in your graph as a node or cannot be reached,"
                    },
                    {
                        "username": "pavan_kumar2000",
                        "content": "it is easy to think that any number divided by itself equals one, which is true. BUT in Mathematics infinity divided by infinity is actually undefined. (source: google - infinty/ infinity)\\n\\nI think based on this property it is marked as -1.0\\n"
                    },
                    {
                        "username": "romanonly2018",
                        "content": "Problem in solutions: \"x\" / \"x\" == 1.0, even when \"x\" not defined :)))"
                    },
                    {
                        "username": "Daone",
                        "content": "[@qiushile](/qiushile)  no division by 0\\n"
                    },
                    {
                        "username": "Numresunw",
                        "content": "[@qiushile](/qiushile) the problem specifies \\n\\'0.0 < values[i] <= 20.0\\' \\nalso it says\\n\\'You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\\'"
                    },
                    {
                        "username": "qiushile",
                        "content": "what if x is 0?"
                    },
                    {
                        "username": "pranjaljo",
                        "content": "Tip: Do not overthink this question.\\n\\nFor eg. bc/ca != b/a,, or x/x != 1. , \\n\\nI followed the wrong rabithole and ended up wasting a lot my time."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "Each Ai or Bi is a string that represents a single variable."
                    },
                    {
                        "username": "mbarse",
                        "content": "yeah this was my problem as well. and then in the constraints i read \"Ai Bi Ci Di consist of lowercase letters AND DIGITS\" i was like how is this medium? parsing alone is medium enough"
                    },
                    {
                        "username": "whiteSkar",
                        "content": "After knowing that this is a graph question with edge values being the value and 1/v, it is trivial to code.\\n\\nHowever, how do I know that this is a graph question in the first place? Like what is the relationship between the division and the edge..?\\n\\nDoes it only work with divisions and multiplications? What if it was plus and minuses? What if it was exponential and logarithmic?\\n\\nKnowing that the graph works, it makes sense that they work, However, I just don\\'t get how to recognize that this is just a directed graph with weighted edge problem in the first place without knowing that this is a graph problem!"
                    },
                    {
                        "username": "vishaleet",
                        "content": "[@joshuamahadevan1](/joshuamahadevan1) wow, You explained very well, thanks Joshua"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "How i figured this was a graph qn was by thinking about the fact that a/b can be found as a/c * c/b, which will give me a product of 2 values. so it is like I am going from a->c using value a/c, and going c->b using value c/b, and multiplying them along the path. It kinda clicked into place that having a graph migh help us to find which c to use, and my approach started from there."
                    },
                    {
                        "username": "hero080",
                        "content": "This is actually a key point of interview: to evaluate your problem solving skills.\\nYou should always think outside the box and try to use any knowledge you might have.\\n\\nIf you know union find, you don\\'t even need to build the graph itself. It becomes super easy:\\nhttps://leetcode.com/problems/evaluate-division/solutions/3543257/0ms-o-n-m-most-efficient-solution-modified-unionfind-simple-code/"
                    },
                    {
                        "username": "z57909160",
                        "content": "I think the reason it is graph is because two variable can only be calculated when they are in same union (a->b->c->d) (e->f->g), you can calculate any two number from the same union. but cannot when the two number are from different unions because there aren't equations that you can come up with."
                    }
                ]
            },
            {
                "id": 1567971,
                "content": [
                    {
                        "username": "yorkshire",
                        "content": "Since \"evaluating the queries will result in no division by zero\" then it doesn't matter if x is not included in the given equations, dividing by itself can only ever be 1 so why is the answer -1 ?"
                    },
                    {
                        "username": "jd2050",
                        "content": "How on Earth the \"Number of Provinces\" problem and this monster have the same \"Medium\" difficulty level?"
                    },
                    {
                        "username": "lummm",
                        "content": "I spent a long time attempting to interpret input like [\\'abc\\', \\'bc\\'] algebraically.\\nIt seems like the problem will always be solvable by considering \\'abc\\' as a distinct variable - not as a * b * c."
                    },
                    {
                        "username": "esrujan",
                        "content": "I don\\'t understand the problem. All the results are placed in the vector<double> and when I print its size, it is 5 in the following example. For some odd reason, the output is seen as \"-1.00000]\". I don\\'t understand what the problem is. It looks like a technical problem with Leetcode. Have anyone seen this? Thank you!\\n\\nInput:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput:\\n**-1.00000]**\\nExpected:\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "The only hint you need is, This is a graph problem. Then traversing and finding answer is trivial. ( I myself couldn\\'t figure out that it\\'s a graph problem, but as soon as I read the hint, I had my eureka moment lol \\uD83D\\uDCA1 "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Never been so proud of a solution to a medium problem! \nI turned it into a graph and solved it with a cached bfs, and I don't wanna hear anything about a \"medium\" difficulty. Let me savor this like I just found a \"hard\" solution\n\nReally cool problem tho!"
                    },
                    {
                        "username": "wds8807",
                        "content": "[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\nThis is the expected output:\\n[360.0,-1.0,-1.0,1.0,-1.0,-1.0]\\n\\nThis is my output:\\n[360.0,0.00833,20.0,1.0,-1.0,-1.0]\\n\\nI wonder why x5 to x2 and x2 to x4 should be invalid, according to the expected output?\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "they might have had a bug in their judge in Feb 2019, but now it works as expected"
                    },
                    {
                        "username": "beignet",
                        "content": "From the given equations, we can multiply two equations to get another equation, i.e. given `[[\"a\",\"b\"],[\"b\",\"c\"]], [2.0, 3.0]` we can calculate `(a/b)*(b/c) = a/c = 6`. Ok let\\'s add another equation, given `[[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"]], [2.0, 3.0, 4.0]`, we can generate `(a/b)*(b/c) = a/c = 6, (b/c)*(c/d) = (b/d) = 12`, but from those two you can addtionally generate `(a/c)*(b/d) = (ab/cd) = 72`, yet this will not be a valid query. "
                    },
                    {
                        "username": "kaik2",
                        "content": "class Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n = equations.size();\\n        unordered_map<string, int> indices;\\n        int index = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n\\n            if (indices.find(x) == indices.end()) {\\n                indices[x] = index;\\n                index++;\\n            }\\n            if (indices.find(y) == indices.end()) {\\n                indices[y] = index;\\n                index++;\\n            }\\n        }\\n\\n        // Create adjacency matrix\\n        int size = indices.size();\\n        vector<vector<double>> adj(size, vector<double>(size, -1.0));\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n            double val = values[i];\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            adj[indexX][indexY] = val;\\n            adj[indexY][indexX] = 1.0 / val;\\n        }\\n\\n       \\n        for (int k = 0; k < size; k++) {\\n            for (int i = 0; i < size; i++) {\\n                for (int j = 0; j < size; j++) {\\n                    if (adj[i][k] != -1.0 && adj[k][j] != -1.0) {\\n                        adj[i][j] = adj[i][k] * adj[k][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        int q = queries.size();\\n        vector<double> results(q, -1.0);\\n        for (int i = 0; i < q; i++) {\\n            string x = queries[i][0];\\n            string y = queries[i][1];\\n\\n            if (indices.find(x) == indices.end() || indices.find(y) == indices.end()) {\\n                results[i] = -1.0; \\n                continue;\\n            }\\n\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            if (adj[indexX][indexY] != -1.0) {\\n                results[i] = adj[indexX][indexY];\\n            }\\n        }\\n\\n        return results;\\n    }\\n};\\ni solved it using flyod warshel and it\\'s giving me wrong answer.......on test case 26/27 please can anybody resolve it?ig it\\'s due to double but if we look at constraints it\\'s b/w 1 to 20 so it should\\'t give\\n.please anybody clarify?\\n"
                    },
                    {
                        "username": "hk_2002",
                        "content": "same issue 26 test case ran if you found the solution than please share it.\\n"
                    },
                    {
                        "username": "user2282Lf",
                        "content": "This problem is broken, because the constraints does allow something like [[\"a\",\"b\"],[\"b\",\"c\"],[\"ab\",\"cd\"]] equations but the original solution and almost 90% of users solutions returns -1 on [\"ab\",\"cd\"] when is completely solvable. Definitely this problem is broken and need to be revised, it is not that easy to solve as the author thought. This problem is higher than difficult and not appropriate for a learn page like this, it\\'s basically an entire project. I tried a fully functional solution but it takes hundreds of lines because basically you need to construct an class object that can handle and operate equations, almost like built-in datatypes.\\n\\nConclusion: The problem is poorly defined and the proposed solution does not solve the original problem. The original problem involves much more field than the proposed solution.\\n\\nThis was just and example, but I could push the constraints to the limit and there would be thousands of examples that are wrong."
                    }
                ]
            },
            {
                "id": 1782439,
                "content": [
                    {
                        "username": "yorkshire",
                        "content": "Since \"evaluating the queries will result in no division by zero\" then it doesn't matter if x is not included in the given equations, dividing by itself can only ever be 1 so why is the answer -1 ?"
                    },
                    {
                        "username": "jd2050",
                        "content": "How on Earth the \"Number of Provinces\" problem and this monster have the same \"Medium\" difficulty level?"
                    },
                    {
                        "username": "lummm",
                        "content": "I spent a long time attempting to interpret input like [\\'abc\\', \\'bc\\'] algebraically.\\nIt seems like the problem will always be solvable by considering \\'abc\\' as a distinct variable - not as a * b * c."
                    },
                    {
                        "username": "esrujan",
                        "content": "I don\\'t understand the problem. All the results are placed in the vector<double> and when I print its size, it is 5 in the following example. For some odd reason, the output is seen as \"-1.00000]\". I don\\'t understand what the problem is. It looks like a technical problem with Leetcode. Have anyone seen this? Thank you!\\n\\nInput:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput:\\n**-1.00000]**\\nExpected:\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "The only hint you need is, This is a graph problem. Then traversing and finding answer is trivial. ( I myself couldn\\'t figure out that it\\'s a graph problem, but as soon as I read the hint, I had my eureka moment lol \\uD83D\\uDCA1 "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Never been so proud of a solution to a medium problem! \nI turned it into a graph and solved it with a cached bfs, and I don't wanna hear anything about a \"medium\" difficulty. Let me savor this like I just found a \"hard\" solution\n\nReally cool problem tho!"
                    },
                    {
                        "username": "wds8807",
                        "content": "[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\nThis is the expected output:\\n[360.0,-1.0,-1.0,1.0,-1.0,-1.0]\\n\\nThis is my output:\\n[360.0,0.00833,20.0,1.0,-1.0,-1.0]\\n\\nI wonder why x5 to x2 and x2 to x4 should be invalid, according to the expected output?\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "they might have had a bug in their judge in Feb 2019, but now it works as expected"
                    },
                    {
                        "username": "beignet",
                        "content": "From the given equations, we can multiply two equations to get another equation, i.e. given `[[\"a\",\"b\"],[\"b\",\"c\"]], [2.0, 3.0]` we can calculate `(a/b)*(b/c) = a/c = 6`. Ok let\\'s add another equation, given `[[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"]], [2.0, 3.0, 4.0]`, we can generate `(a/b)*(b/c) = a/c = 6, (b/c)*(c/d) = (b/d) = 12`, but from those two you can addtionally generate `(a/c)*(b/d) = (ab/cd) = 72`, yet this will not be a valid query. "
                    },
                    {
                        "username": "kaik2",
                        "content": "class Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n = equations.size();\\n        unordered_map<string, int> indices;\\n        int index = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n\\n            if (indices.find(x) == indices.end()) {\\n                indices[x] = index;\\n                index++;\\n            }\\n            if (indices.find(y) == indices.end()) {\\n                indices[y] = index;\\n                index++;\\n            }\\n        }\\n\\n        // Create adjacency matrix\\n        int size = indices.size();\\n        vector<vector<double>> adj(size, vector<double>(size, -1.0));\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n            double val = values[i];\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            adj[indexX][indexY] = val;\\n            adj[indexY][indexX] = 1.0 / val;\\n        }\\n\\n       \\n        for (int k = 0; k < size; k++) {\\n            for (int i = 0; i < size; i++) {\\n                for (int j = 0; j < size; j++) {\\n                    if (adj[i][k] != -1.0 && adj[k][j] != -1.0) {\\n                        adj[i][j] = adj[i][k] * adj[k][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        int q = queries.size();\\n        vector<double> results(q, -1.0);\\n        for (int i = 0; i < q; i++) {\\n            string x = queries[i][0];\\n            string y = queries[i][1];\\n\\n            if (indices.find(x) == indices.end() || indices.find(y) == indices.end()) {\\n                results[i] = -1.0; \\n                continue;\\n            }\\n\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            if (adj[indexX][indexY] != -1.0) {\\n                results[i] = adj[indexX][indexY];\\n            }\\n        }\\n\\n        return results;\\n    }\\n};\\ni solved it using flyod warshel and it\\'s giving me wrong answer.......on test case 26/27 please can anybody resolve it?ig it\\'s due to double but if we look at constraints it\\'s b/w 1 to 20 so it should\\'t give\\n.please anybody clarify?\\n"
                    },
                    {
                        "username": "hk_2002",
                        "content": "same issue 26 test case ran if you found the solution than please share it.\\n"
                    },
                    {
                        "username": "user2282Lf",
                        "content": "This problem is broken, because the constraints does allow something like [[\"a\",\"b\"],[\"b\",\"c\"],[\"ab\",\"cd\"]] equations but the original solution and almost 90% of users solutions returns -1 on [\"ab\",\"cd\"] when is completely solvable. Definitely this problem is broken and need to be revised, it is not that easy to solve as the author thought. This problem is higher than difficult and not appropriate for a learn page like this, it\\'s basically an entire project. I tried a fully functional solution but it takes hundreds of lines because basically you need to construct an class object that can handle and operate equations, almost like built-in datatypes.\\n\\nConclusion: The problem is poorly defined and the proposed solution does not solve the original problem. The original problem involves much more field than the proposed solution.\\n\\nThis was just and example, but I could push the constraints to the limit and there would be thousands of examples that are wrong."
                    }
                ]
            },
            {
                "id": 1575971,
                "content": [
                    {
                        "username": "yorkshire",
                        "content": "Since \"evaluating the queries will result in no division by zero\" then it doesn't matter if x is not included in the given equations, dividing by itself can only ever be 1 so why is the answer -1 ?"
                    },
                    {
                        "username": "jd2050",
                        "content": "How on Earth the \"Number of Provinces\" problem and this monster have the same \"Medium\" difficulty level?"
                    },
                    {
                        "username": "lummm",
                        "content": "I spent a long time attempting to interpret input like [\\'abc\\', \\'bc\\'] algebraically.\\nIt seems like the problem will always be solvable by considering \\'abc\\' as a distinct variable - not as a * b * c."
                    },
                    {
                        "username": "esrujan",
                        "content": "I don\\'t understand the problem. All the results are placed in the vector<double> and when I print its size, it is 5 in the following example. For some odd reason, the output is seen as \"-1.00000]\". I don\\'t understand what the problem is. It looks like a technical problem with Leetcode. Have anyone seen this? Thank you!\\n\\nInput:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput:\\n**-1.00000]**\\nExpected:\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "The only hint you need is, This is a graph problem. Then traversing and finding answer is trivial. ( I myself couldn\\'t figure out that it\\'s a graph problem, but as soon as I read the hint, I had my eureka moment lol \\uD83D\\uDCA1 "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Never been so proud of a solution to a medium problem! \nI turned it into a graph and solved it with a cached bfs, and I don't wanna hear anything about a \"medium\" difficulty. Let me savor this like I just found a \"hard\" solution\n\nReally cool problem tho!"
                    },
                    {
                        "username": "wds8807",
                        "content": "[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\nThis is the expected output:\\n[360.0,-1.0,-1.0,1.0,-1.0,-1.0]\\n\\nThis is my output:\\n[360.0,0.00833,20.0,1.0,-1.0,-1.0]\\n\\nI wonder why x5 to x2 and x2 to x4 should be invalid, according to the expected output?\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "they might have had a bug in their judge in Feb 2019, but now it works as expected"
                    },
                    {
                        "username": "beignet",
                        "content": "From the given equations, we can multiply two equations to get another equation, i.e. given `[[\"a\",\"b\"],[\"b\",\"c\"]], [2.0, 3.0]` we can calculate `(a/b)*(b/c) = a/c = 6`. Ok let\\'s add another equation, given `[[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"]], [2.0, 3.0, 4.0]`, we can generate `(a/b)*(b/c) = a/c = 6, (b/c)*(c/d) = (b/d) = 12`, but from those two you can addtionally generate `(a/c)*(b/d) = (ab/cd) = 72`, yet this will not be a valid query. "
                    },
                    {
                        "username": "kaik2",
                        "content": "class Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n = equations.size();\\n        unordered_map<string, int> indices;\\n        int index = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n\\n            if (indices.find(x) == indices.end()) {\\n                indices[x] = index;\\n                index++;\\n            }\\n            if (indices.find(y) == indices.end()) {\\n                indices[y] = index;\\n                index++;\\n            }\\n        }\\n\\n        // Create adjacency matrix\\n        int size = indices.size();\\n        vector<vector<double>> adj(size, vector<double>(size, -1.0));\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n            double val = values[i];\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            adj[indexX][indexY] = val;\\n            adj[indexY][indexX] = 1.0 / val;\\n        }\\n\\n       \\n        for (int k = 0; k < size; k++) {\\n            for (int i = 0; i < size; i++) {\\n                for (int j = 0; j < size; j++) {\\n                    if (adj[i][k] != -1.0 && adj[k][j] != -1.0) {\\n                        adj[i][j] = adj[i][k] * adj[k][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        int q = queries.size();\\n        vector<double> results(q, -1.0);\\n        for (int i = 0; i < q; i++) {\\n            string x = queries[i][0];\\n            string y = queries[i][1];\\n\\n            if (indices.find(x) == indices.end() || indices.find(y) == indices.end()) {\\n                results[i] = -1.0; \\n                continue;\\n            }\\n\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            if (adj[indexX][indexY] != -1.0) {\\n                results[i] = adj[indexX][indexY];\\n            }\\n        }\\n\\n        return results;\\n    }\\n};\\ni solved it using flyod warshel and it\\'s giving me wrong answer.......on test case 26/27 please can anybody resolve it?ig it\\'s due to double but if we look at constraints it\\'s b/w 1 to 20 so it should\\'t give\\n.please anybody clarify?\\n"
                    },
                    {
                        "username": "hk_2002",
                        "content": "same issue 26 test case ran if you found the solution than please share it.\\n"
                    },
                    {
                        "username": "user2282Lf",
                        "content": "This problem is broken, because the constraints does allow something like [[\"a\",\"b\"],[\"b\",\"c\"],[\"ab\",\"cd\"]] equations but the original solution and almost 90% of users solutions returns -1 on [\"ab\",\"cd\"] when is completely solvable. Definitely this problem is broken and need to be revised, it is not that easy to solve as the author thought. This problem is higher than difficult and not appropriate for a learn page like this, it\\'s basically an entire project. I tried a fully functional solution but it takes hundreds of lines because basically you need to construct an class object that can handle and operate equations, almost like built-in datatypes.\\n\\nConclusion: The problem is poorly defined and the proposed solution does not solve the original problem. The original problem involves much more field than the proposed solution.\\n\\nThis was just and example, but I could push the constraints to the limit and there would be thousands of examples that are wrong."
                    }
                ]
            },
            {
                "id": 1567481,
                "content": [
                    {
                        "username": "yorkshire",
                        "content": "Since \"evaluating the queries will result in no division by zero\" then it doesn't matter if x is not included in the given equations, dividing by itself can only ever be 1 so why is the answer -1 ?"
                    },
                    {
                        "username": "jd2050",
                        "content": "How on Earth the \"Number of Provinces\" problem and this monster have the same \"Medium\" difficulty level?"
                    },
                    {
                        "username": "lummm",
                        "content": "I spent a long time attempting to interpret input like [\\'abc\\', \\'bc\\'] algebraically.\\nIt seems like the problem will always be solvable by considering \\'abc\\' as a distinct variable - not as a * b * c."
                    },
                    {
                        "username": "esrujan",
                        "content": "I don\\'t understand the problem. All the results are placed in the vector<double> and when I print its size, it is 5 in the following example. For some odd reason, the output is seen as \"-1.00000]\". I don\\'t understand what the problem is. It looks like a technical problem with Leetcode. Have anyone seen this? Thank you!\\n\\nInput:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput:\\n**-1.00000]**\\nExpected:\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "The only hint you need is, This is a graph problem. Then traversing and finding answer is trivial. ( I myself couldn\\'t figure out that it\\'s a graph problem, but as soon as I read the hint, I had my eureka moment lol \\uD83D\\uDCA1 "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Never been so proud of a solution to a medium problem! \nI turned it into a graph and solved it with a cached bfs, and I don't wanna hear anything about a \"medium\" difficulty. Let me savor this like I just found a \"hard\" solution\n\nReally cool problem tho!"
                    },
                    {
                        "username": "wds8807",
                        "content": "[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\nThis is the expected output:\\n[360.0,-1.0,-1.0,1.0,-1.0,-1.0]\\n\\nThis is my output:\\n[360.0,0.00833,20.0,1.0,-1.0,-1.0]\\n\\nI wonder why x5 to x2 and x2 to x4 should be invalid, according to the expected output?\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "they might have had a bug in their judge in Feb 2019, but now it works as expected"
                    },
                    {
                        "username": "beignet",
                        "content": "From the given equations, we can multiply two equations to get another equation, i.e. given `[[\"a\",\"b\"],[\"b\",\"c\"]], [2.0, 3.0]` we can calculate `(a/b)*(b/c) = a/c = 6`. Ok let\\'s add another equation, given `[[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"]], [2.0, 3.0, 4.0]`, we can generate `(a/b)*(b/c) = a/c = 6, (b/c)*(c/d) = (b/d) = 12`, but from those two you can addtionally generate `(a/c)*(b/d) = (ab/cd) = 72`, yet this will not be a valid query. "
                    },
                    {
                        "username": "kaik2",
                        "content": "class Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n = equations.size();\\n        unordered_map<string, int> indices;\\n        int index = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n\\n            if (indices.find(x) == indices.end()) {\\n                indices[x] = index;\\n                index++;\\n            }\\n            if (indices.find(y) == indices.end()) {\\n                indices[y] = index;\\n                index++;\\n            }\\n        }\\n\\n        // Create adjacency matrix\\n        int size = indices.size();\\n        vector<vector<double>> adj(size, vector<double>(size, -1.0));\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n            double val = values[i];\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            adj[indexX][indexY] = val;\\n            adj[indexY][indexX] = 1.0 / val;\\n        }\\n\\n       \\n        for (int k = 0; k < size; k++) {\\n            for (int i = 0; i < size; i++) {\\n                for (int j = 0; j < size; j++) {\\n                    if (adj[i][k] != -1.0 && adj[k][j] != -1.0) {\\n                        adj[i][j] = adj[i][k] * adj[k][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        int q = queries.size();\\n        vector<double> results(q, -1.0);\\n        for (int i = 0; i < q; i++) {\\n            string x = queries[i][0];\\n            string y = queries[i][1];\\n\\n            if (indices.find(x) == indices.end() || indices.find(y) == indices.end()) {\\n                results[i] = -1.0; \\n                continue;\\n            }\\n\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            if (adj[indexX][indexY] != -1.0) {\\n                results[i] = adj[indexX][indexY];\\n            }\\n        }\\n\\n        return results;\\n    }\\n};\\ni solved it using flyod warshel and it\\'s giving me wrong answer.......on test case 26/27 please can anybody resolve it?ig it\\'s due to double but if we look at constraints it\\'s b/w 1 to 20 so it should\\'t give\\n.please anybody clarify?\\n"
                    },
                    {
                        "username": "hk_2002",
                        "content": "same issue 26 test case ran if you found the solution than please share it.\\n"
                    },
                    {
                        "username": "user2282Lf",
                        "content": "This problem is broken, because the constraints does allow something like [[\"a\",\"b\"],[\"b\",\"c\"],[\"ab\",\"cd\"]] equations but the original solution and almost 90% of users solutions returns -1 on [\"ab\",\"cd\"] when is completely solvable. Definitely this problem is broken and need to be revised, it is not that easy to solve as the author thought. This problem is higher than difficult and not appropriate for a learn page like this, it\\'s basically an entire project. I tried a fully functional solution but it takes hundreds of lines because basically you need to construct an class object that can handle and operate equations, almost like built-in datatypes.\\n\\nConclusion: The problem is poorly defined and the proposed solution does not solve the original problem. The original problem involves much more field than the proposed solution.\\n\\nThis was just and example, but I could push the constraints to the limit and there would be thousands of examples that are wrong."
                    }
                ]
            },
            {
                "id": 1899716,
                "content": [
                    {
                        "username": "yorkshire",
                        "content": "Since \"evaluating the queries will result in no division by zero\" then it doesn't matter if x is not included in the given equations, dividing by itself can only ever be 1 so why is the answer -1 ?"
                    },
                    {
                        "username": "jd2050",
                        "content": "How on Earth the \"Number of Provinces\" problem and this monster have the same \"Medium\" difficulty level?"
                    },
                    {
                        "username": "lummm",
                        "content": "I spent a long time attempting to interpret input like [\\'abc\\', \\'bc\\'] algebraically.\\nIt seems like the problem will always be solvable by considering \\'abc\\' as a distinct variable - not as a * b * c."
                    },
                    {
                        "username": "esrujan",
                        "content": "I don\\'t understand the problem. All the results are placed in the vector<double> and when I print its size, it is 5 in the following example. For some odd reason, the output is seen as \"-1.00000]\". I don\\'t understand what the problem is. It looks like a technical problem with Leetcode. Have anyone seen this? Thank you!\\n\\nInput:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput:\\n**-1.00000]**\\nExpected:\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "The only hint you need is, This is a graph problem. Then traversing and finding answer is trivial. ( I myself couldn\\'t figure out that it\\'s a graph problem, but as soon as I read the hint, I had my eureka moment lol \\uD83D\\uDCA1 "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Never been so proud of a solution to a medium problem! \nI turned it into a graph and solved it with a cached bfs, and I don't wanna hear anything about a \"medium\" difficulty. Let me savor this like I just found a \"hard\" solution\n\nReally cool problem tho!"
                    },
                    {
                        "username": "wds8807",
                        "content": "[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\nThis is the expected output:\\n[360.0,-1.0,-1.0,1.0,-1.0,-1.0]\\n\\nThis is my output:\\n[360.0,0.00833,20.0,1.0,-1.0,-1.0]\\n\\nI wonder why x5 to x2 and x2 to x4 should be invalid, according to the expected output?\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "they might have had a bug in their judge in Feb 2019, but now it works as expected"
                    },
                    {
                        "username": "beignet",
                        "content": "From the given equations, we can multiply two equations to get another equation, i.e. given `[[\"a\",\"b\"],[\"b\",\"c\"]], [2.0, 3.0]` we can calculate `(a/b)*(b/c) = a/c = 6`. Ok let\\'s add another equation, given `[[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"]], [2.0, 3.0, 4.0]`, we can generate `(a/b)*(b/c) = a/c = 6, (b/c)*(c/d) = (b/d) = 12`, but from those two you can addtionally generate `(a/c)*(b/d) = (ab/cd) = 72`, yet this will not be a valid query. "
                    },
                    {
                        "username": "kaik2",
                        "content": "class Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n = equations.size();\\n        unordered_map<string, int> indices;\\n        int index = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n\\n            if (indices.find(x) == indices.end()) {\\n                indices[x] = index;\\n                index++;\\n            }\\n            if (indices.find(y) == indices.end()) {\\n                indices[y] = index;\\n                index++;\\n            }\\n        }\\n\\n        // Create adjacency matrix\\n        int size = indices.size();\\n        vector<vector<double>> adj(size, vector<double>(size, -1.0));\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n            double val = values[i];\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            adj[indexX][indexY] = val;\\n            adj[indexY][indexX] = 1.0 / val;\\n        }\\n\\n       \\n        for (int k = 0; k < size; k++) {\\n            for (int i = 0; i < size; i++) {\\n                for (int j = 0; j < size; j++) {\\n                    if (adj[i][k] != -1.0 && adj[k][j] != -1.0) {\\n                        adj[i][j] = adj[i][k] * adj[k][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        int q = queries.size();\\n        vector<double> results(q, -1.0);\\n        for (int i = 0; i < q; i++) {\\n            string x = queries[i][0];\\n            string y = queries[i][1];\\n\\n            if (indices.find(x) == indices.end() || indices.find(y) == indices.end()) {\\n                results[i] = -1.0; \\n                continue;\\n            }\\n\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            if (adj[indexX][indexY] != -1.0) {\\n                results[i] = adj[indexX][indexY];\\n            }\\n        }\\n\\n        return results;\\n    }\\n};\\ni solved it using flyod warshel and it\\'s giving me wrong answer.......on test case 26/27 please can anybody resolve it?ig it\\'s due to double but if we look at constraints it\\'s b/w 1 to 20 so it should\\'t give\\n.please anybody clarify?\\n"
                    },
                    {
                        "username": "hk_2002",
                        "content": "same issue 26 test case ran if you found the solution than please share it.\\n"
                    },
                    {
                        "username": "user2282Lf",
                        "content": "This problem is broken, because the constraints does allow something like [[\"a\",\"b\"],[\"b\",\"c\"],[\"ab\",\"cd\"]] equations but the original solution and almost 90% of users solutions returns -1 on [\"ab\",\"cd\"] when is completely solvable. Definitely this problem is broken and need to be revised, it is not that easy to solve as the author thought. This problem is higher than difficult and not appropriate for a learn page like this, it\\'s basically an entire project. I tried a fully functional solution but it takes hundreds of lines because basically you need to construct an class object that can handle and operate equations, almost like built-in datatypes.\\n\\nConclusion: The problem is poorly defined and the proposed solution does not solve the original problem. The original problem involves much more field than the proposed solution.\\n\\nThis was just and example, but I could push the constraints to the limit and there would be thousands of examples that are wrong."
                    }
                ]
            },
            {
                "id": 1899618,
                "content": [
                    {
                        "username": "yorkshire",
                        "content": "Since \"evaluating the queries will result in no division by zero\" then it doesn't matter if x is not included in the given equations, dividing by itself can only ever be 1 so why is the answer -1 ?"
                    },
                    {
                        "username": "jd2050",
                        "content": "How on Earth the \"Number of Provinces\" problem and this monster have the same \"Medium\" difficulty level?"
                    },
                    {
                        "username": "lummm",
                        "content": "I spent a long time attempting to interpret input like [\\'abc\\', \\'bc\\'] algebraically.\\nIt seems like the problem will always be solvable by considering \\'abc\\' as a distinct variable - not as a * b * c."
                    },
                    {
                        "username": "esrujan",
                        "content": "I don\\'t understand the problem. All the results are placed in the vector<double> and when I print its size, it is 5 in the following example. For some odd reason, the output is seen as \"-1.00000]\". I don\\'t understand what the problem is. It looks like a technical problem with Leetcode. Have anyone seen this? Thank you!\\n\\nInput:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput:\\n**-1.00000]**\\nExpected:\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "The only hint you need is, This is a graph problem. Then traversing and finding answer is trivial. ( I myself couldn\\'t figure out that it\\'s a graph problem, but as soon as I read the hint, I had my eureka moment lol \\uD83D\\uDCA1 "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Never been so proud of a solution to a medium problem! \nI turned it into a graph and solved it with a cached bfs, and I don't wanna hear anything about a \"medium\" difficulty. Let me savor this like I just found a \"hard\" solution\n\nReally cool problem tho!"
                    },
                    {
                        "username": "wds8807",
                        "content": "[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\nThis is the expected output:\\n[360.0,-1.0,-1.0,1.0,-1.0,-1.0]\\n\\nThis is my output:\\n[360.0,0.00833,20.0,1.0,-1.0,-1.0]\\n\\nI wonder why x5 to x2 and x2 to x4 should be invalid, according to the expected output?\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "they might have had a bug in their judge in Feb 2019, but now it works as expected"
                    },
                    {
                        "username": "beignet",
                        "content": "From the given equations, we can multiply two equations to get another equation, i.e. given `[[\"a\",\"b\"],[\"b\",\"c\"]], [2.0, 3.0]` we can calculate `(a/b)*(b/c) = a/c = 6`. Ok let\\'s add another equation, given `[[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"]], [2.0, 3.0, 4.0]`, we can generate `(a/b)*(b/c) = a/c = 6, (b/c)*(c/d) = (b/d) = 12`, but from those two you can addtionally generate `(a/c)*(b/d) = (ab/cd) = 72`, yet this will not be a valid query. "
                    },
                    {
                        "username": "kaik2",
                        "content": "class Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n = equations.size();\\n        unordered_map<string, int> indices;\\n        int index = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n\\n            if (indices.find(x) == indices.end()) {\\n                indices[x] = index;\\n                index++;\\n            }\\n            if (indices.find(y) == indices.end()) {\\n                indices[y] = index;\\n                index++;\\n            }\\n        }\\n\\n        // Create adjacency matrix\\n        int size = indices.size();\\n        vector<vector<double>> adj(size, vector<double>(size, -1.0));\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n            double val = values[i];\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            adj[indexX][indexY] = val;\\n            adj[indexY][indexX] = 1.0 / val;\\n        }\\n\\n       \\n        for (int k = 0; k < size; k++) {\\n            for (int i = 0; i < size; i++) {\\n                for (int j = 0; j < size; j++) {\\n                    if (adj[i][k] != -1.0 && adj[k][j] != -1.0) {\\n                        adj[i][j] = adj[i][k] * adj[k][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        int q = queries.size();\\n        vector<double> results(q, -1.0);\\n        for (int i = 0; i < q; i++) {\\n            string x = queries[i][0];\\n            string y = queries[i][1];\\n\\n            if (indices.find(x) == indices.end() || indices.find(y) == indices.end()) {\\n                results[i] = -1.0; \\n                continue;\\n            }\\n\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            if (adj[indexX][indexY] != -1.0) {\\n                results[i] = adj[indexX][indexY];\\n            }\\n        }\\n\\n        return results;\\n    }\\n};\\ni solved it using flyod warshel and it\\'s giving me wrong answer.......on test case 26/27 please can anybody resolve it?ig it\\'s due to double but if we look at constraints it\\'s b/w 1 to 20 so it should\\'t give\\n.please anybody clarify?\\n"
                    },
                    {
                        "username": "hk_2002",
                        "content": "same issue 26 test case ran if you found the solution than please share it.\\n"
                    },
                    {
                        "username": "user2282Lf",
                        "content": "This problem is broken, because the constraints does allow something like [[\"a\",\"b\"],[\"b\",\"c\"],[\"ab\",\"cd\"]] equations but the original solution and almost 90% of users solutions returns -1 on [\"ab\",\"cd\"] when is completely solvable. Definitely this problem is broken and need to be revised, it is not that easy to solve as the author thought. This problem is higher than difficult and not appropriate for a learn page like this, it\\'s basically an entire project. I tried a fully functional solution but it takes hundreds of lines because basically you need to construct an class object that can handle and operate equations, almost like built-in datatypes.\\n\\nConclusion: The problem is poorly defined and the proposed solution does not solve the original problem. The original problem involves much more field than the proposed solution.\\n\\nThis was just and example, but I could push the constraints to the limit and there would be thousands of examples that are wrong."
                    }
                ]
            },
            {
                "id": 1572479,
                "content": [
                    {
                        "username": "yorkshire",
                        "content": "Since \"evaluating the queries will result in no division by zero\" then it doesn't matter if x is not included in the given equations, dividing by itself can only ever be 1 so why is the answer -1 ?"
                    },
                    {
                        "username": "jd2050",
                        "content": "How on Earth the \"Number of Provinces\" problem and this monster have the same \"Medium\" difficulty level?"
                    },
                    {
                        "username": "lummm",
                        "content": "I spent a long time attempting to interpret input like [\\'abc\\', \\'bc\\'] algebraically.\\nIt seems like the problem will always be solvable by considering \\'abc\\' as a distinct variable - not as a * b * c."
                    },
                    {
                        "username": "esrujan",
                        "content": "I don\\'t understand the problem. All the results are placed in the vector<double> and when I print its size, it is 5 in the following example. For some odd reason, the output is seen as \"-1.00000]\". I don\\'t understand what the problem is. It looks like a technical problem with Leetcode. Have anyone seen this? Thank you!\\n\\nInput:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput:\\n**-1.00000]**\\nExpected:\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "The only hint you need is, This is a graph problem. Then traversing and finding answer is trivial. ( I myself couldn\\'t figure out that it\\'s a graph problem, but as soon as I read the hint, I had my eureka moment lol \\uD83D\\uDCA1 "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Never been so proud of a solution to a medium problem! \nI turned it into a graph and solved it with a cached bfs, and I don't wanna hear anything about a \"medium\" difficulty. Let me savor this like I just found a \"hard\" solution\n\nReally cool problem tho!"
                    },
                    {
                        "username": "wds8807",
                        "content": "[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\nThis is the expected output:\\n[360.0,-1.0,-1.0,1.0,-1.0,-1.0]\\n\\nThis is my output:\\n[360.0,0.00833,20.0,1.0,-1.0,-1.0]\\n\\nI wonder why x5 to x2 and x2 to x4 should be invalid, according to the expected output?\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "they might have had a bug in their judge in Feb 2019, but now it works as expected"
                    },
                    {
                        "username": "beignet",
                        "content": "From the given equations, we can multiply two equations to get another equation, i.e. given `[[\"a\",\"b\"],[\"b\",\"c\"]], [2.0, 3.0]` we can calculate `(a/b)*(b/c) = a/c = 6`. Ok let\\'s add another equation, given `[[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"]], [2.0, 3.0, 4.0]`, we can generate `(a/b)*(b/c) = a/c = 6, (b/c)*(c/d) = (b/d) = 12`, but from those two you can addtionally generate `(a/c)*(b/d) = (ab/cd) = 72`, yet this will not be a valid query. "
                    },
                    {
                        "username": "kaik2",
                        "content": "class Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n = equations.size();\\n        unordered_map<string, int> indices;\\n        int index = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n\\n            if (indices.find(x) == indices.end()) {\\n                indices[x] = index;\\n                index++;\\n            }\\n            if (indices.find(y) == indices.end()) {\\n                indices[y] = index;\\n                index++;\\n            }\\n        }\\n\\n        // Create adjacency matrix\\n        int size = indices.size();\\n        vector<vector<double>> adj(size, vector<double>(size, -1.0));\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n            double val = values[i];\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            adj[indexX][indexY] = val;\\n            adj[indexY][indexX] = 1.0 / val;\\n        }\\n\\n       \\n        for (int k = 0; k < size; k++) {\\n            for (int i = 0; i < size; i++) {\\n                for (int j = 0; j < size; j++) {\\n                    if (adj[i][k] != -1.0 && adj[k][j] != -1.0) {\\n                        adj[i][j] = adj[i][k] * adj[k][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        int q = queries.size();\\n        vector<double> results(q, -1.0);\\n        for (int i = 0; i < q; i++) {\\n            string x = queries[i][0];\\n            string y = queries[i][1];\\n\\n            if (indices.find(x) == indices.end() || indices.find(y) == indices.end()) {\\n                results[i] = -1.0; \\n                continue;\\n            }\\n\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            if (adj[indexX][indexY] != -1.0) {\\n                results[i] = adj[indexX][indexY];\\n            }\\n        }\\n\\n        return results;\\n    }\\n};\\ni solved it using flyod warshel and it\\'s giving me wrong answer.......on test case 26/27 please can anybody resolve it?ig it\\'s due to double but if we look at constraints it\\'s b/w 1 to 20 so it should\\'t give\\n.please anybody clarify?\\n"
                    },
                    {
                        "username": "hk_2002",
                        "content": "same issue 26 test case ran if you found the solution than please share it.\\n"
                    },
                    {
                        "username": "user2282Lf",
                        "content": "This problem is broken, because the constraints does allow something like [[\"a\",\"b\"],[\"b\",\"c\"],[\"ab\",\"cd\"]] equations but the original solution and almost 90% of users solutions returns -1 on [\"ab\",\"cd\"] when is completely solvable. Definitely this problem is broken and need to be revised, it is not that easy to solve as the author thought. This problem is higher than difficult and not appropriate for a learn page like this, it\\'s basically an entire project. I tried a fully functional solution but it takes hundreds of lines because basically you need to construct an class object that can handle and operate equations, almost like built-in datatypes.\\n\\nConclusion: The problem is poorly defined and the proposed solution does not solve the original problem. The original problem involves much more field than the proposed solution.\\n\\nThis was just and example, but I could push the constraints to the limit and there would be thousands of examples that are wrong."
                    }
                ]
            },
            {
                "id": 1572188,
                "content": [
                    {
                        "username": "yorkshire",
                        "content": "Since \"evaluating the queries will result in no division by zero\" then it doesn't matter if x is not included in the given equations, dividing by itself can only ever be 1 so why is the answer -1 ?"
                    },
                    {
                        "username": "jd2050",
                        "content": "How on Earth the \"Number of Provinces\" problem and this monster have the same \"Medium\" difficulty level?"
                    },
                    {
                        "username": "lummm",
                        "content": "I spent a long time attempting to interpret input like [\\'abc\\', \\'bc\\'] algebraically.\\nIt seems like the problem will always be solvable by considering \\'abc\\' as a distinct variable - not as a * b * c."
                    },
                    {
                        "username": "esrujan",
                        "content": "I don\\'t understand the problem. All the results are placed in the vector<double> and when I print its size, it is 5 in the following example. For some odd reason, the output is seen as \"-1.00000]\". I don\\'t understand what the problem is. It looks like a technical problem with Leetcode. Have anyone seen this? Thank you!\\n\\nInput:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput:\\n**-1.00000]**\\nExpected:\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "The only hint you need is, This is a graph problem. Then traversing and finding answer is trivial. ( I myself couldn\\'t figure out that it\\'s a graph problem, but as soon as I read the hint, I had my eureka moment lol \\uD83D\\uDCA1 "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Never been so proud of a solution to a medium problem! \nI turned it into a graph and solved it with a cached bfs, and I don't wanna hear anything about a \"medium\" difficulty. Let me savor this like I just found a \"hard\" solution\n\nReally cool problem tho!"
                    },
                    {
                        "username": "wds8807",
                        "content": "[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\nThis is the expected output:\\n[360.0,-1.0,-1.0,1.0,-1.0,-1.0]\\n\\nThis is my output:\\n[360.0,0.00833,20.0,1.0,-1.0,-1.0]\\n\\nI wonder why x5 to x2 and x2 to x4 should be invalid, according to the expected output?\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "they might have had a bug in their judge in Feb 2019, but now it works as expected"
                    },
                    {
                        "username": "beignet",
                        "content": "From the given equations, we can multiply two equations to get another equation, i.e. given `[[\"a\",\"b\"],[\"b\",\"c\"]], [2.0, 3.0]` we can calculate `(a/b)*(b/c) = a/c = 6`. Ok let\\'s add another equation, given `[[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"]], [2.0, 3.0, 4.0]`, we can generate `(a/b)*(b/c) = a/c = 6, (b/c)*(c/d) = (b/d) = 12`, but from those two you can addtionally generate `(a/c)*(b/d) = (ab/cd) = 72`, yet this will not be a valid query. "
                    },
                    {
                        "username": "kaik2",
                        "content": "class Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n = equations.size();\\n        unordered_map<string, int> indices;\\n        int index = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n\\n            if (indices.find(x) == indices.end()) {\\n                indices[x] = index;\\n                index++;\\n            }\\n            if (indices.find(y) == indices.end()) {\\n                indices[y] = index;\\n                index++;\\n            }\\n        }\\n\\n        // Create adjacency matrix\\n        int size = indices.size();\\n        vector<vector<double>> adj(size, vector<double>(size, -1.0));\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n            double val = values[i];\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            adj[indexX][indexY] = val;\\n            adj[indexY][indexX] = 1.0 / val;\\n        }\\n\\n       \\n        for (int k = 0; k < size; k++) {\\n            for (int i = 0; i < size; i++) {\\n                for (int j = 0; j < size; j++) {\\n                    if (adj[i][k] != -1.0 && adj[k][j] != -1.0) {\\n                        adj[i][j] = adj[i][k] * adj[k][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        int q = queries.size();\\n        vector<double> results(q, -1.0);\\n        for (int i = 0; i < q; i++) {\\n            string x = queries[i][0];\\n            string y = queries[i][1];\\n\\n            if (indices.find(x) == indices.end() || indices.find(y) == indices.end()) {\\n                results[i] = -1.0; \\n                continue;\\n            }\\n\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            if (adj[indexX][indexY] != -1.0) {\\n                results[i] = adj[indexX][indexY];\\n            }\\n        }\\n\\n        return results;\\n    }\\n};\\ni solved it using flyod warshel and it\\'s giving me wrong answer.......on test case 26/27 please can anybody resolve it?ig it\\'s due to double but if we look at constraints it\\'s b/w 1 to 20 so it should\\'t give\\n.please anybody clarify?\\n"
                    },
                    {
                        "username": "hk_2002",
                        "content": "same issue 26 test case ran if you found the solution than please share it.\\n"
                    },
                    {
                        "username": "user2282Lf",
                        "content": "This problem is broken, because the constraints does allow something like [[\"a\",\"b\"],[\"b\",\"c\"],[\"ab\",\"cd\"]] equations but the original solution and almost 90% of users solutions returns -1 on [\"ab\",\"cd\"] when is completely solvable. Definitely this problem is broken and need to be revised, it is not that easy to solve as the author thought. This problem is higher than difficult and not appropriate for a learn page like this, it\\'s basically an entire project. I tried a fully functional solution but it takes hundreds of lines because basically you need to construct an class object that can handle and operate equations, almost like built-in datatypes.\\n\\nConclusion: The problem is poorly defined and the proposed solution does not solve the original problem. The original problem involves much more field than the proposed solution.\\n\\nThis was just and example, but I could push the constraints to the limit and there would be thousands of examples that are wrong."
                    }
                ]
            },
            {
                "id": 1932867,
                "content": [
                    {
                        "username": "yorkshire",
                        "content": "Since \"evaluating the queries will result in no division by zero\" then it doesn't matter if x is not included in the given equations, dividing by itself can only ever be 1 so why is the answer -1 ?"
                    },
                    {
                        "username": "jd2050",
                        "content": "How on Earth the \"Number of Provinces\" problem and this monster have the same \"Medium\" difficulty level?"
                    },
                    {
                        "username": "lummm",
                        "content": "I spent a long time attempting to interpret input like [\\'abc\\', \\'bc\\'] algebraically.\\nIt seems like the problem will always be solvable by considering \\'abc\\' as a distinct variable - not as a * b * c."
                    },
                    {
                        "username": "esrujan",
                        "content": "I don\\'t understand the problem. All the results are placed in the vector<double> and when I print its size, it is 5 in the following example. For some odd reason, the output is seen as \"-1.00000]\". I don\\'t understand what the problem is. It looks like a technical problem with Leetcode. Have anyone seen this? Thank you!\\n\\nInput:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput:\\n**-1.00000]**\\nExpected:\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "The only hint you need is, This is a graph problem. Then traversing and finding answer is trivial. ( I myself couldn\\'t figure out that it\\'s a graph problem, but as soon as I read the hint, I had my eureka moment lol \\uD83D\\uDCA1 "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Never been so proud of a solution to a medium problem! \nI turned it into a graph and solved it with a cached bfs, and I don't wanna hear anything about a \"medium\" difficulty. Let me savor this like I just found a \"hard\" solution\n\nReally cool problem tho!"
                    },
                    {
                        "username": "wds8807",
                        "content": "[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\nThis is the expected output:\\n[360.0,-1.0,-1.0,1.0,-1.0,-1.0]\\n\\nThis is my output:\\n[360.0,0.00833,20.0,1.0,-1.0,-1.0]\\n\\nI wonder why x5 to x2 and x2 to x4 should be invalid, according to the expected output?\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "they might have had a bug in their judge in Feb 2019, but now it works as expected"
                    },
                    {
                        "username": "beignet",
                        "content": "From the given equations, we can multiply two equations to get another equation, i.e. given `[[\"a\",\"b\"],[\"b\",\"c\"]], [2.0, 3.0]` we can calculate `(a/b)*(b/c) = a/c = 6`. Ok let\\'s add another equation, given `[[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"]], [2.0, 3.0, 4.0]`, we can generate `(a/b)*(b/c) = a/c = 6, (b/c)*(c/d) = (b/d) = 12`, but from those two you can addtionally generate `(a/c)*(b/d) = (ab/cd) = 72`, yet this will not be a valid query. "
                    },
                    {
                        "username": "kaik2",
                        "content": "class Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n = equations.size();\\n        unordered_map<string, int> indices;\\n        int index = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n\\n            if (indices.find(x) == indices.end()) {\\n                indices[x] = index;\\n                index++;\\n            }\\n            if (indices.find(y) == indices.end()) {\\n                indices[y] = index;\\n                index++;\\n            }\\n        }\\n\\n        // Create adjacency matrix\\n        int size = indices.size();\\n        vector<vector<double>> adj(size, vector<double>(size, -1.0));\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n            double val = values[i];\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            adj[indexX][indexY] = val;\\n            adj[indexY][indexX] = 1.0 / val;\\n        }\\n\\n       \\n        for (int k = 0; k < size; k++) {\\n            for (int i = 0; i < size; i++) {\\n                for (int j = 0; j < size; j++) {\\n                    if (adj[i][k] != -1.0 && adj[k][j] != -1.0) {\\n                        adj[i][j] = adj[i][k] * adj[k][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        int q = queries.size();\\n        vector<double> results(q, -1.0);\\n        for (int i = 0; i < q; i++) {\\n            string x = queries[i][0];\\n            string y = queries[i][1];\\n\\n            if (indices.find(x) == indices.end() || indices.find(y) == indices.end()) {\\n                results[i] = -1.0; \\n                continue;\\n            }\\n\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            if (adj[indexX][indexY] != -1.0) {\\n                results[i] = adj[indexX][indexY];\\n            }\\n        }\\n\\n        return results;\\n    }\\n};\\ni solved it using flyod warshel and it\\'s giving me wrong answer.......on test case 26/27 please can anybody resolve it?ig it\\'s due to double but if we look at constraints it\\'s b/w 1 to 20 so it should\\'t give\\n.please anybody clarify?\\n"
                    },
                    {
                        "username": "hk_2002",
                        "content": "same issue 26 test case ran if you found the solution than please share it.\\n"
                    },
                    {
                        "username": "user2282Lf",
                        "content": "This problem is broken, because the constraints does allow something like [[\"a\",\"b\"],[\"b\",\"c\"],[\"ab\",\"cd\"]] equations but the original solution and almost 90% of users solutions returns -1 on [\"ab\",\"cd\"] when is completely solvable. Definitely this problem is broken and need to be revised, it is not that easy to solve as the author thought. This problem is higher than difficult and not appropriate for a learn page like this, it\\'s basically an entire project. I tried a fully functional solution but it takes hundreds of lines because basically you need to construct an class object that can handle and operate equations, almost like built-in datatypes.\\n\\nConclusion: The problem is poorly defined and the proposed solution does not solve the original problem. The original problem involves much more field than the proposed solution.\\n\\nThis was just and example, but I could push the constraints to the limit and there would be thousands of examples that are wrong."
                    }
                ]
            },
            {
                "id": 1900003,
                "content": [
                    {
                        "username": "yorkshire",
                        "content": "Since \"evaluating the queries will result in no division by zero\" then it doesn't matter if x is not included in the given equations, dividing by itself can only ever be 1 so why is the answer -1 ?"
                    },
                    {
                        "username": "jd2050",
                        "content": "How on Earth the \"Number of Provinces\" problem and this monster have the same \"Medium\" difficulty level?"
                    },
                    {
                        "username": "lummm",
                        "content": "I spent a long time attempting to interpret input like [\\'abc\\', \\'bc\\'] algebraically.\\nIt seems like the problem will always be solvable by considering \\'abc\\' as a distinct variable - not as a * b * c."
                    },
                    {
                        "username": "esrujan",
                        "content": "I don\\'t understand the problem. All the results are placed in the vector<double> and when I print its size, it is 5 in the following example. For some odd reason, the output is seen as \"-1.00000]\". I don\\'t understand what the problem is. It looks like a technical problem with Leetcode. Have anyone seen this? Thank you!\\n\\nInput:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput:\\n**-1.00000]**\\nExpected:\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "The only hint you need is, This is a graph problem. Then traversing and finding answer is trivial. ( I myself couldn\\'t figure out that it\\'s a graph problem, but as soon as I read the hint, I had my eureka moment lol \\uD83D\\uDCA1 "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Never been so proud of a solution to a medium problem! \nI turned it into a graph and solved it with a cached bfs, and I don't wanna hear anything about a \"medium\" difficulty. Let me savor this like I just found a \"hard\" solution\n\nReally cool problem tho!"
                    },
                    {
                        "username": "wds8807",
                        "content": "[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\nThis is the expected output:\\n[360.0,-1.0,-1.0,1.0,-1.0,-1.0]\\n\\nThis is my output:\\n[360.0,0.00833,20.0,1.0,-1.0,-1.0]\\n\\nI wonder why x5 to x2 and x2 to x4 should be invalid, according to the expected output?\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "they might have had a bug in their judge in Feb 2019, but now it works as expected"
                    },
                    {
                        "username": "beignet",
                        "content": "From the given equations, we can multiply two equations to get another equation, i.e. given `[[\"a\",\"b\"],[\"b\",\"c\"]], [2.0, 3.0]` we can calculate `(a/b)*(b/c) = a/c = 6`. Ok let\\'s add another equation, given `[[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"]], [2.0, 3.0, 4.0]`, we can generate `(a/b)*(b/c) = a/c = 6, (b/c)*(c/d) = (b/d) = 12`, but from those two you can addtionally generate `(a/c)*(b/d) = (ab/cd) = 72`, yet this will not be a valid query. "
                    },
                    {
                        "username": "kaik2",
                        "content": "class Solution {\\npublic:\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n = equations.size();\\n        unordered_map<string, int> indices;\\n        int index = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n\\n            if (indices.find(x) == indices.end()) {\\n                indices[x] = index;\\n                index++;\\n            }\\n            if (indices.find(y) == indices.end()) {\\n                indices[y] = index;\\n                index++;\\n            }\\n        }\\n\\n        // Create adjacency matrix\\n        int size = indices.size();\\n        vector<vector<double>> adj(size, vector<double>(size, -1.0));\\n        for (int i = 0; i < n; i++) {\\n            string x = equations[i][0];\\n            string y = equations[i][1];\\n            double val = values[i];\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            adj[indexX][indexY] = val;\\n            adj[indexY][indexX] = 1.0 / val;\\n        }\\n\\n       \\n        for (int k = 0; k < size; k++) {\\n            for (int i = 0; i < size; i++) {\\n                for (int j = 0; j < size; j++) {\\n                    if (adj[i][k] != -1.0 && adj[k][j] != -1.0) {\\n                        adj[i][j] = adj[i][k] * adj[k][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        int q = queries.size();\\n        vector<double> results(q, -1.0);\\n        for (int i = 0; i < q; i++) {\\n            string x = queries[i][0];\\n            string y = queries[i][1];\\n\\n            if (indices.find(x) == indices.end() || indices.find(y) == indices.end()) {\\n                results[i] = -1.0; \\n                continue;\\n            }\\n\\n            int indexX = indices[x];\\n            int indexY = indices[y];\\n\\n            if (adj[indexX][indexY] != -1.0) {\\n                results[i] = adj[indexX][indexY];\\n            }\\n        }\\n\\n        return results;\\n    }\\n};\\ni solved it using flyod warshel and it\\'s giving me wrong answer.......on test case 26/27 please can anybody resolve it?ig it\\'s due to double but if we look at constraints it\\'s b/w 1 to 20 so it should\\'t give\\n.please anybody clarify?\\n"
                    },
                    {
                        "username": "hk_2002",
                        "content": "same issue 26 test case ran if you found the solution than please share it.\\n"
                    },
                    {
                        "username": "user2282Lf",
                        "content": "This problem is broken, because the constraints does allow something like [[\"a\",\"b\"],[\"b\",\"c\"],[\"ab\",\"cd\"]] equations but the original solution and almost 90% of users solutions returns -1 on [\"ab\",\"cd\"] when is completely solvable. Definitely this problem is broken and need to be revised, it is not that easy to solve as the author thought. This problem is higher than difficult and not appropriate for a learn page like this, it\\'s basically an entire project. I tried a fully functional solution but it takes hundreds of lines because basically you need to construct an class object that can handle and operate equations, almost like built-in datatypes.\\n\\nConclusion: The problem is poorly defined and the proposed solution does not solve the original problem. The original problem involves much more field than the proposed solution.\\n\\nThis was just and example, but I could push the constraints to the limit and there would be thousands of examples that are wrong."
                    }
                ]
            },
            {
                "id": 1899904,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Although this problem is doable , over 100 lines. but it took me for hours to debug, a helper function for print out the graph info is useful for every test case. In fact, I can solve all of possible paths\nFor test case :\n====================\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\n```\n       \\       a,       b,       c,       d,       w,       x,       y,       z,\n       a       1,       2,       0,       0,       0,       0,       0,       0,\n       b     0.5,       1,0.333333,    0.25,       0,       0,       0,       0,\n       c       0,       3,       1,       0,       0,       0,       0,       0,\n       d       0,       4,       0,       1,   0.125,       0,       0,       0,\n       w       0,       0,       0,       8,       1,       5,       0,       0,\n       x       0,       0,       0,       0,     0.2,       1,0.166667,0.142857,\n       y       0,       0,       0,       0,       0,       6,       1,       0,\n       z       0,       0,       0,       0,       0,       7,       0,       1,\n===================\n```\n```\n///The following function print graph for debug\n    void print_graph(){\n        cout<<setw(8)<<\"\";\n        for (int i=0; i<v_size; i++)\n            cout<<setw(8)<<v[i]<<\",\";\n        cout<<endl;\n        for(int i=0; i<v_size; i++){\n            cout<<setw(8)<<v[i];\n            for(int j=0; j<v_size; j++){\n                cout<<setw(8)<<graph[i][j]<<\",\";\n            }\n            cout<<endl;\n        }\n        cout<<\"===================\n\";\n    }\n///////////////////////////\n```\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/evaluate-division/solutions/3544770/0-ms-beats-100c-solution-using-lots-of-tables-with-debugging-info/"
                    },
                    {
                        "username": "can-keklik",
                        "content": "I would expect the description to be clearer. Even though the term \"variable\" is used to describe a part of a query, multiple letter variables like \"bc\" can be FALSELY understood as a composition of b and c (while bc is just a separate variable), and that would change the whole question, obviously would make it much more difficult. It was a good exercise though, thanks."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find A / C we just nees find the path and multiplay all edges coefficient: 2 * 3 = 6"
                    },
                    {
                        "username": "prakarshparashar",
                        "content": "For this input:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"ac\",\"bb\"]]\\n\\nThe expected result is :\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]\\n\\nHowever, \"ac\"/\"bb\" can be obtained from values[0] x (1/values[1]) . Question must be framed properly to exclude certain inputs in the queries."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Read the question carefully. \"ac\" != \"a\" * \"c\", each string corresponds to a single variable only, not a composition of many."
                    },
                    {
                        "username": "ahcox",
                        "content": "[**\\uD83E\\uDD14**](https://en.wikipedia.org/wiki/Division_(mathematics))"
                    },
                    {
                        "username": "Blatogh",
                        "content": "This question may be hard instead of medium..."
                    },
                    {
                        "username": "natitati",
                        "content": "No, no I do not recognize this as a graph problem, leetcode."
                    },
                    {
                        "username": "Kaushh",
                        "content": "The question is unclear. It assumes `bc/dc` to be different than `b/d`. Even if we can cancel out `c` from both numerator and denominator, it requires us to report -1 for that."
                    },
                    {
                        "username": "luzede",
                        "content": "I would say x/x should be 1 and not -1, especially since values are greater than 0, hence, no query taking a/b where a is 0 exists."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "It\\'s a **Hard one, but definitely cool**"
                    }
                ]
            },
            {
                "id": 1899826,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Although this problem is doable , over 100 lines. but it took me for hours to debug, a helper function for print out the graph info is useful for every test case. In fact, I can solve all of possible paths\nFor test case :\n====================\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\n```\n       \\       a,       b,       c,       d,       w,       x,       y,       z,\n       a       1,       2,       0,       0,       0,       0,       0,       0,\n       b     0.5,       1,0.333333,    0.25,       0,       0,       0,       0,\n       c       0,       3,       1,       0,       0,       0,       0,       0,\n       d       0,       4,       0,       1,   0.125,       0,       0,       0,\n       w       0,       0,       0,       8,       1,       5,       0,       0,\n       x       0,       0,       0,       0,     0.2,       1,0.166667,0.142857,\n       y       0,       0,       0,       0,       0,       6,       1,       0,\n       z       0,       0,       0,       0,       0,       7,       0,       1,\n===================\n```\n```\n///The following function print graph for debug\n    void print_graph(){\n        cout<<setw(8)<<\"\";\n        for (int i=0; i<v_size; i++)\n            cout<<setw(8)<<v[i]<<\",\";\n        cout<<endl;\n        for(int i=0; i<v_size; i++){\n            cout<<setw(8)<<v[i];\n            for(int j=0; j<v_size; j++){\n                cout<<setw(8)<<graph[i][j]<<\",\";\n            }\n            cout<<endl;\n        }\n        cout<<\"===================\n\";\n    }\n///////////////////////////\n```\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/evaluate-division/solutions/3544770/0-ms-beats-100c-solution-using-lots-of-tables-with-debugging-info/"
                    },
                    {
                        "username": "can-keklik",
                        "content": "I would expect the description to be clearer. Even though the term \"variable\" is used to describe a part of a query, multiple letter variables like \"bc\" can be FALSELY understood as a composition of b and c (while bc is just a separate variable), and that would change the whole question, obviously would make it much more difficult. It was a good exercise though, thanks."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find A / C we just nees find the path and multiplay all edges coefficient: 2 * 3 = 6"
                    },
                    {
                        "username": "prakarshparashar",
                        "content": "For this input:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"ac\",\"bb\"]]\\n\\nThe expected result is :\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]\\n\\nHowever, \"ac\"/\"bb\" can be obtained from values[0] x (1/values[1]) . Question must be framed properly to exclude certain inputs in the queries."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Read the question carefully. \"ac\" != \"a\" * \"c\", each string corresponds to a single variable only, not a composition of many."
                    },
                    {
                        "username": "ahcox",
                        "content": "[**\\uD83E\\uDD14**](https://en.wikipedia.org/wiki/Division_(mathematics))"
                    },
                    {
                        "username": "Blatogh",
                        "content": "This question may be hard instead of medium..."
                    },
                    {
                        "username": "natitati",
                        "content": "No, no I do not recognize this as a graph problem, leetcode."
                    },
                    {
                        "username": "Kaushh",
                        "content": "The question is unclear. It assumes `bc/dc` to be different than `b/d`. Even if we can cancel out `c` from both numerator and denominator, it requires us to report -1 for that."
                    },
                    {
                        "username": "luzede",
                        "content": "I would say x/x should be 1 and not -1, especially since values are greater than 0, hence, no query taking a/b where a is 0 exists."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "It\\'s a **Hard one, but definitely cool**"
                    }
                ]
            },
            {
                "id": 1899719,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Although this problem is doable , over 100 lines. but it took me for hours to debug, a helper function for print out the graph info is useful for every test case. In fact, I can solve all of possible paths\nFor test case :\n====================\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\n```\n       \\       a,       b,       c,       d,       w,       x,       y,       z,\n       a       1,       2,       0,       0,       0,       0,       0,       0,\n       b     0.5,       1,0.333333,    0.25,       0,       0,       0,       0,\n       c       0,       3,       1,       0,       0,       0,       0,       0,\n       d       0,       4,       0,       1,   0.125,       0,       0,       0,\n       w       0,       0,       0,       8,       1,       5,       0,       0,\n       x       0,       0,       0,       0,     0.2,       1,0.166667,0.142857,\n       y       0,       0,       0,       0,       0,       6,       1,       0,\n       z       0,       0,       0,       0,       0,       7,       0,       1,\n===================\n```\n```\n///The following function print graph for debug\n    void print_graph(){\n        cout<<setw(8)<<\"\";\n        for (int i=0; i<v_size; i++)\n            cout<<setw(8)<<v[i]<<\",\";\n        cout<<endl;\n        for(int i=0; i<v_size; i++){\n            cout<<setw(8)<<v[i];\n            for(int j=0; j<v_size; j++){\n                cout<<setw(8)<<graph[i][j]<<\",\";\n            }\n            cout<<endl;\n        }\n        cout<<\"===================\n\";\n    }\n///////////////////////////\n```\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/evaluate-division/solutions/3544770/0-ms-beats-100c-solution-using-lots-of-tables-with-debugging-info/"
                    },
                    {
                        "username": "can-keklik",
                        "content": "I would expect the description to be clearer. Even though the term \"variable\" is used to describe a part of a query, multiple letter variables like \"bc\" can be FALSELY understood as a composition of b and c (while bc is just a separate variable), and that would change the whole question, obviously would make it much more difficult. It was a good exercise though, thanks."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find A / C we just nees find the path and multiplay all edges coefficient: 2 * 3 = 6"
                    },
                    {
                        "username": "prakarshparashar",
                        "content": "For this input:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"ac\",\"bb\"]]\\n\\nThe expected result is :\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]\\n\\nHowever, \"ac\"/\"bb\" can be obtained from values[0] x (1/values[1]) . Question must be framed properly to exclude certain inputs in the queries."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Read the question carefully. \"ac\" != \"a\" * \"c\", each string corresponds to a single variable only, not a composition of many."
                    },
                    {
                        "username": "ahcox",
                        "content": "[**\\uD83E\\uDD14**](https://en.wikipedia.org/wiki/Division_(mathematics))"
                    },
                    {
                        "username": "Blatogh",
                        "content": "This question may be hard instead of medium..."
                    },
                    {
                        "username": "natitati",
                        "content": "No, no I do not recognize this as a graph problem, leetcode."
                    },
                    {
                        "username": "Kaushh",
                        "content": "The question is unclear. It assumes `bc/dc` to be different than `b/d`. Even if we can cancel out `c` from both numerator and denominator, it requires us to report -1 for that."
                    },
                    {
                        "username": "luzede",
                        "content": "I would say x/x should be 1 and not -1, especially since values are greater than 0, hence, no query taking a/b where a is 0 exists."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "It\\'s a **Hard one, but definitely cool**"
                    }
                ]
            },
            {
                "id": 1570799,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Although this problem is doable , over 100 lines. but it took me for hours to debug, a helper function for print out the graph info is useful for every test case. In fact, I can solve all of possible paths\nFor test case :\n====================\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\n```\n       \\       a,       b,       c,       d,       w,       x,       y,       z,\n       a       1,       2,       0,       0,       0,       0,       0,       0,\n       b     0.5,       1,0.333333,    0.25,       0,       0,       0,       0,\n       c       0,       3,       1,       0,       0,       0,       0,       0,\n       d       0,       4,       0,       1,   0.125,       0,       0,       0,\n       w       0,       0,       0,       8,       1,       5,       0,       0,\n       x       0,       0,       0,       0,     0.2,       1,0.166667,0.142857,\n       y       0,       0,       0,       0,       0,       6,       1,       0,\n       z       0,       0,       0,       0,       0,       7,       0,       1,\n===================\n```\n```\n///The following function print graph for debug\n    void print_graph(){\n        cout<<setw(8)<<\"\";\n        for (int i=0; i<v_size; i++)\n            cout<<setw(8)<<v[i]<<\",\";\n        cout<<endl;\n        for(int i=0; i<v_size; i++){\n            cout<<setw(8)<<v[i];\n            for(int j=0; j<v_size; j++){\n                cout<<setw(8)<<graph[i][j]<<\",\";\n            }\n            cout<<endl;\n        }\n        cout<<\"===================\n\";\n    }\n///////////////////////////\n```\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/evaluate-division/solutions/3544770/0-ms-beats-100c-solution-using-lots-of-tables-with-debugging-info/"
                    },
                    {
                        "username": "can-keklik",
                        "content": "I would expect the description to be clearer. Even though the term \"variable\" is used to describe a part of a query, multiple letter variables like \"bc\" can be FALSELY understood as a composition of b and c (while bc is just a separate variable), and that would change the whole question, obviously would make it much more difficult. It was a good exercise though, thanks."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find A / C we just nees find the path and multiplay all edges coefficient: 2 * 3 = 6"
                    },
                    {
                        "username": "prakarshparashar",
                        "content": "For this input:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"ac\",\"bb\"]]\\n\\nThe expected result is :\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]\\n\\nHowever, \"ac\"/\"bb\" can be obtained from values[0] x (1/values[1]) . Question must be framed properly to exclude certain inputs in the queries."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Read the question carefully. \"ac\" != \"a\" * \"c\", each string corresponds to a single variable only, not a composition of many."
                    },
                    {
                        "username": "ahcox",
                        "content": "[**\\uD83E\\uDD14**](https://en.wikipedia.org/wiki/Division_(mathematics))"
                    },
                    {
                        "username": "Blatogh",
                        "content": "This question may be hard instead of medium..."
                    },
                    {
                        "username": "natitati",
                        "content": "No, no I do not recognize this as a graph problem, leetcode."
                    },
                    {
                        "username": "Kaushh",
                        "content": "The question is unclear. It assumes `bc/dc` to be different than `b/d`. Even if we can cancel out `c` from both numerator and denominator, it requires us to report -1 for that."
                    },
                    {
                        "username": "luzede",
                        "content": "I would say x/x should be 1 and not -1, especially since values are greater than 0, hence, no query taking a/b where a is 0 exists."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "It\\'s a **Hard one, but definitely cool**"
                    }
                ]
            },
            {
                "id": 1569689,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Although this problem is doable , over 100 lines. but it took me for hours to debug, a helper function for print out the graph info is useful for every test case. In fact, I can solve all of possible paths\nFor test case :\n====================\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\n```\n       \\       a,       b,       c,       d,       w,       x,       y,       z,\n       a       1,       2,       0,       0,       0,       0,       0,       0,\n       b     0.5,       1,0.333333,    0.25,       0,       0,       0,       0,\n       c       0,       3,       1,       0,       0,       0,       0,       0,\n       d       0,       4,       0,       1,   0.125,       0,       0,       0,\n       w       0,       0,       0,       8,       1,       5,       0,       0,\n       x       0,       0,       0,       0,     0.2,       1,0.166667,0.142857,\n       y       0,       0,       0,       0,       0,       6,       1,       0,\n       z       0,       0,       0,       0,       0,       7,       0,       1,\n===================\n```\n```\n///The following function print graph for debug\n    void print_graph(){\n        cout<<setw(8)<<\"\";\n        for (int i=0; i<v_size; i++)\n            cout<<setw(8)<<v[i]<<\",\";\n        cout<<endl;\n        for(int i=0; i<v_size; i++){\n            cout<<setw(8)<<v[i];\n            for(int j=0; j<v_size; j++){\n                cout<<setw(8)<<graph[i][j]<<\",\";\n            }\n            cout<<endl;\n        }\n        cout<<\"===================\n\";\n    }\n///////////////////////////\n```\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/evaluate-division/solutions/3544770/0-ms-beats-100c-solution-using-lots-of-tables-with-debugging-info/"
                    },
                    {
                        "username": "can-keklik",
                        "content": "I would expect the description to be clearer. Even though the term \"variable\" is used to describe a part of a query, multiple letter variables like \"bc\" can be FALSELY understood as a composition of b and c (while bc is just a separate variable), and that would change the whole question, obviously would make it much more difficult. It was a good exercise though, thanks."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find A / C we just nees find the path and multiplay all edges coefficient: 2 * 3 = 6"
                    },
                    {
                        "username": "prakarshparashar",
                        "content": "For this input:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"ac\",\"bb\"]]\\n\\nThe expected result is :\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]\\n\\nHowever, \"ac\"/\"bb\" can be obtained from values[0] x (1/values[1]) . Question must be framed properly to exclude certain inputs in the queries."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Read the question carefully. \"ac\" != \"a\" * \"c\", each string corresponds to a single variable only, not a composition of many."
                    },
                    {
                        "username": "ahcox",
                        "content": "[**\\uD83E\\uDD14**](https://en.wikipedia.org/wiki/Division_(mathematics))"
                    },
                    {
                        "username": "Blatogh",
                        "content": "This question may be hard instead of medium..."
                    },
                    {
                        "username": "natitati",
                        "content": "No, no I do not recognize this as a graph problem, leetcode."
                    },
                    {
                        "username": "Kaushh",
                        "content": "The question is unclear. It assumes `bc/dc` to be different than `b/d`. Even if we can cancel out `c` from both numerator and denominator, it requires us to report -1 for that."
                    },
                    {
                        "username": "luzede",
                        "content": "I would say x/x should be 1 and not -1, especially since values are greater than 0, hence, no query taking a/b where a is 0 exists."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "It\\'s a **Hard one, but definitely cool**"
                    }
                ]
            },
            {
                "id": 1900815,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Although this problem is doable , over 100 lines. but it took me for hours to debug, a helper function for print out the graph info is useful for every test case. In fact, I can solve all of possible paths\nFor test case :\n====================\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\n```\n       \\       a,       b,       c,       d,       w,       x,       y,       z,\n       a       1,       2,       0,       0,       0,       0,       0,       0,\n       b     0.5,       1,0.333333,    0.25,       0,       0,       0,       0,\n       c       0,       3,       1,       0,       0,       0,       0,       0,\n       d       0,       4,       0,       1,   0.125,       0,       0,       0,\n       w       0,       0,       0,       8,       1,       5,       0,       0,\n       x       0,       0,       0,       0,     0.2,       1,0.166667,0.142857,\n       y       0,       0,       0,       0,       0,       6,       1,       0,\n       z       0,       0,       0,       0,       0,       7,       0,       1,\n===================\n```\n```\n///The following function print graph for debug\n    void print_graph(){\n        cout<<setw(8)<<\"\";\n        for (int i=0; i<v_size; i++)\n            cout<<setw(8)<<v[i]<<\",\";\n        cout<<endl;\n        for(int i=0; i<v_size; i++){\n            cout<<setw(8)<<v[i];\n            for(int j=0; j<v_size; j++){\n                cout<<setw(8)<<graph[i][j]<<\",\";\n            }\n            cout<<endl;\n        }\n        cout<<\"===================\n\";\n    }\n///////////////////////////\n```\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/evaluate-division/solutions/3544770/0-ms-beats-100c-solution-using-lots-of-tables-with-debugging-info/"
                    },
                    {
                        "username": "can-keklik",
                        "content": "I would expect the description to be clearer. Even though the term \"variable\" is used to describe a part of a query, multiple letter variables like \"bc\" can be FALSELY understood as a composition of b and c (while bc is just a separate variable), and that would change the whole question, obviously would make it much more difficult. It was a good exercise though, thanks."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find A / C we just nees find the path and multiplay all edges coefficient: 2 * 3 = 6"
                    },
                    {
                        "username": "prakarshparashar",
                        "content": "For this input:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"ac\",\"bb\"]]\\n\\nThe expected result is :\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]\\n\\nHowever, \"ac\"/\"bb\" can be obtained from values[0] x (1/values[1]) . Question must be framed properly to exclude certain inputs in the queries."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Read the question carefully. \"ac\" != \"a\" * \"c\", each string corresponds to a single variable only, not a composition of many."
                    },
                    {
                        "username": "ahcox",
                        "content": "[**\\uD83E\\uDD14**](https://en.wikipedia.org/wiki/Division_(mathematics))"
                    },
                    {
                        "username": "Blatogh",
                        "content": "This question may be hard instead of medium..."
                    },
                    {
                        "username": "natitati",
                        "content": "No, no I do not recognize this as a graph problem, leetcode."
                    },
                    {
                        "username": "Kaushh",
                        "content": "The question is unclear. It assumes `bc/dc` to be different than `b/d`. Even if we can cancel out `c` from both numerator and denominator, it requires us to report -1 for that."
                    },
                    {
                        "username": "luzede",
                        "content": "I would say x/x should be 1 and not -1, especially since values are greater than 0, hence, no query taking a/b where a is 0 exists."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "It\\'s a **Hard one, but definitely cool**"
                    }
                ]
            },
            {
                "id": 1900314,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Although this problem is doable , over 100 lines. but it took me for hours to debug, a helper function for print out the graph info is useful for every test case. In fact, I can solve all of possible paths\nFor test case :\n====================\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\n```\n       \\       a,       b,       c,       d,       w,       x,       y,       z,\n       a       1,       2,       0,       0,       0,       0,       0,       0,\n       b     0.5,       1,0.333333,    0.25,       0,       0,       0,       0,\n       c       0,       3,       1,       0,       0,       0,       0,       0,\n       d       0,       4,       0,       1,   0.125,       0,       0,       0,\n       w       0,       0,       0,       8,       1,       5,       0,       0,\n       x       0,       0,       0,       0,     0.2,       1,0.166667,0.142857,\n       y       0,       0,       0,       0,       0,       6,       1,       0,\n       z       0,       0,       0,       0,       0,       7,       0,       1,\n===================\n```\n```\n///The following function print graph for debug\n    void print_graph(){\n        cout<<setw(8)<<\"\";\n        for (int i=0; i<v_size; i++)\n            cout<<setw(8)<<v[i]<<\",\";\n        cout<<endl;\n        for(int i=0; i<v_size; i++){\n            cout<<setw(8)<<v[i];\n            for(int j=0; j<v_size; j++){\n                cout<<setw(8)<<graph[i][j]<<\",\";\n            }\n            cout<<endl;\n        }\n        cout<<\"===================\n\";\n    }\n///////////////////////////\n```\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/evaluate-division/solutions/3544770/0-ms-beats-100c-solution-using-lots-of-tables-with-debugging-info/"
                    },
                    {
                        "username": "can-keklik",
                        "content": "I would expect the description to be clearer. Even though the term \"variable\" is used to describe a part of a query, multiple letter variables like \"bc\" can be FALSELY understood as a composition of b and c (while bc is just a separate variable), and that would change the whole question, obviously would make it much more difficult. It was a good exercise though, thanks."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find A / C we just nees find the path and multiplay all edges coefficient: 2 * 3 = 6"
                    },
                    {
                        "username": "prakarshparashar",
                        "content": "For this input:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"ac\",\"bb\"]]\\n\\nThe expected result is :\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]\\n\\nHowever, \"ac\"/\"bb\" can be obtained from values[0] x (1/values[1]) . Question must be framed properly to exclude certain inputs in the queries."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Read the question carefully. \"ac\" != \"a\" * \"c\", each string corresponds to a single variable only, not a composition of many."
                    },
                    {
                        "username": "ahcox",
                        "content": "[**\\uD83E\\uDD14**](https://en.wikipedia.org/wiki/Division_(mathematics))"
                    },
                    {
                        "username": "Blatogh",
                        "content": "This question may be hard instead of medium..."
                    },
                    {
                        "username": "natitati",
                        "content": "No, no I do not recognize this as a graph problem, leetcode."
                    },
                    {
                        "username": "Kaushh",
                        "content": "The question is unclear. It assumes `bc/dc` to be different than `b/d`. Even if we can cancel out `c` from both numerator and denominator, it requires us to report -1 for that."
                    },
                    {
                        "username": "luzede",
                        "content": "I would say x/x should be 1 and not -1, especially since values are greater than 0, hence, no query taking a/b where a is 0 exists."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "It\\'s a **Hard one, but definitely cool**"
                    }
                ]
            },
            {
                "id": 1899881,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Although this problem is doable , over 100 lines. but it took me for hours to debug, a helper function for print out the graph info is useful for every test case. In fact, I can solve all of possible paths\nFor test case :\n====================\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\n```\n       \\       a,       b,       c,       d,       w,       x,       y,       z,\n       a       1,       2,       0,       0,       0,       0,       0,       0,\n       b     0.5,       1,0.333333,    0.25,       0,       0,       0,       0,\n       c       0,       3,       1,       0,       0,       0,       0,       0,\n       d       0,       4,       0,       1,   0.125,       0,       0,       0,\n       w       0,       0,       0,       8,       1,       5,       0,       0,\n       x       0,       0,       0,       0,     0.2,       1,0.166667,0.142857,\n       y       0,       0,       0,       0,       0,       6,       1,       0,\n       z       0,       0,       0,       0,       0,       7,       0,       1,\n===================\n```\n```\n///The following function print graph for debug\n    void print_graph(){\n        cout<<setw(8)<<\"\";\n        for (int i=0; i<v_size; i++)\n            cout<<setw(8)<<v[i]<<\",\";\n        cout<<endl;\n        for(int i=0; i<v_size; i++){\n            cout<<setw(8)<<v[i];\n            for(int j=0; j<v_size; j++){\n                cout<<setw(8)<<graph[i][j]<<\",\";\n            }\n            cout<<endl;\n        }\n        cout<<\"===================\n\";\n    }\n///////////////////////////\n```\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/evaluate-division/solutions/3544770/0-ms-beats-100c-solution-using-lots-of-tables-with-debugging-info/"
                    },
                    {
                        "username": "can-keklik",
                        "content": "I would expect the description to be clearer. Even though the term \"variable\" is used to describe a part of a query, multiple letter variables like \"bc\" can be FALSELY understood as a composition of b and c (while bc is just a separate variable), and that would change the whole question, obviously would make it much more difficult. It was a good exercise though, thanks."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find A / C we just nees find the path and multiplay all edges coefficient: 2 * 3 = 6"
                    },
                    {
                        "username": "prakarshparashar",
                        "content": "For this input:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"ac\",\"bb\"]]\\n\\nThe expected result is :\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]\\n\\nHowever, \"ac\"/\"bb\" can be obtained from values[0] x (1/values[1]) . Question must be framed properly to exclude certain inputs in the queries."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Read the question carefully. \"ac\" != \"a\" * \"c\", each string corresponds to a single variable only, not a composition of many."
                    },
                    {
                        "username": "ahcox",
                        "content": "[**\\uD83E\\uDD14**](https://en.wikipedia.org/wiki/Division_(mathematics))"
                    },
                    {
                        "username": "Blatogh",
                        "content": "This question may be hard instead of medium..."
                    },
                    {
                        "username": "natitati",
                        "content": "No, no I do not recognize this as a graph problem, leetcode."
                    },
                    {
                        "username": "Kaushh",
                        "content": "The question is unclear. It assumes `bc/dc` to be different than `b/d`. Even if we can cancel out `c` from both numerator and denominator, it requires us to report -1 for that."
                    },
                    {
                        "username": "luzede",
                        "content": "I would say x/x should be 1 and not -1, especially since values are greater than 0, hence, no query taking a/b where a is 0 exists."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "It\\'s a **Hard one, but definitely cool**"
                    }
                ]
            },
            {
                "id": 1899799,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Although this problem is doable , over 100 lines. but it took me for hours to debug, a helper function for print out the graph info is useful for every test case. In fact, I can solve all of possible paths\nFor test case :\n====================\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\n```\n       \\       a,       b,       c,       d,       w,       x,       y,       z,\n       a       1,       2,       0,       0,       0,       0,       0,       0,\n       b     0.5,       1,0.333333,    0.25,       0,       0,       0,       0,\n       c       0,       3,       1,       0,       0,       0,       0,       0,\n       d       0,       4,       0,       1,   0.125,       0,       0,       0,\n       w       0,       0,       0,       8,       1,       5,       0,       0,\n       x       0,       0,       0,       0,     0.2,       1,0.166667,0.142857,\n       y       0,       0,       0,       0,       0,       6,       1,       0,\n       z       0,       0,       0,       0,       0,       7,       0,       1,\n===================\n```\n```\n///The following function print graph for debug\n    void print_graph(){\n        cout<<setw(8)<<\"\";\n        for (int i=0; i<v_size; i++)\n            cout<<setw(8)<<v[i]<<\",\";\n        cout<<endl;\n        for(int i=0; i<v_size; i++){\n            cout<<setw(8)<<v[i];\n            for(int j=0; j<v_size; j++){\n                cout<<setw(8)<<graph[i][j]<<\",\";\n            }\n            cout<<endl;\n        }\n        cout<<\"===================\n\";\n    }\n///////////////////////////\n```\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/evaluate-division/solutions/3544770/0-ms-beats-100c-solution-using-lots-of-tables-with-debugging-info/"
                    },
                    {
                        "username": "can-keklik",
                        "content": "I would expect the description to be clearer. Even though the term \"variable\" is used to describe a part of a query, multiple letter variables like \"bc\" can be FALSELY understood as a composition of b and c (while bc is just a separate variable), and that would change the whole question, obviously would make it much more difficult. It was a good exercise though, thanks."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find A / C we just nees find the path and multiplay all edges coefficient: 2 * 3 = 6"
                    },
                    {
                        "username": "prakarshparashar",
                        "content": "For this input:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"ac\",\"bb\"]]\\n\\nThe expected result is :\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]\\n\\nHowever, \"ac\"/\"bb\" can be obtained from values[0] x (1/values[1]) . Question must be framed properly to exclude certain inputs in the queries."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Read the question carefully. \"ac\" != \"a\" * \"c\", each string corresponds to a single variable only, not a composition of many."
                    },
                    {
                        "username": "ahcox",
                        "content": "[**\\uD83E\\uDD14**](https://en.wikipedia.org/wiki/Division_(mathematics))"
                    },
                    {
                        "username": "Blatogh",
                        "content": "This question may be hard instead of medium..."
                    },
                    {
                        "username": "natitati",
                        "content": "No, no I do not recognize this as a graph problem, leetcode."
                    },
                    {
                        "username": "Kaushh",
                        "content": "The question is unclear. It assumes `bc/dc` to be different than `b/d`. Even if we can cancel out `c` from both numerator and denominator, it requires us to report -1 for that."
                    },
                    {
                        "username": "luzede",
                        "content": "I would say x/x should be 1 and not -1, especially since values are greater than 0, hence, no query taking a/b where a is 0 exists."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "It\\'s a **Hard one, but definitely cool**"
                    }
                ]
            },
            {
                "id": 1899791,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Although this problem is doable , over 100 lines. but it took me for hours to debug, a helper function for print out the graph info is useful for every test case. In fact, I can solve all of possible paths\nFor test case :\n====================\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\n```\n       \\       a,       b,       c,       d,       w,       x,       y,       z,\n       a       1,       2,       0,       0,       0,       0,       0,       0,\n       b     0.5,       1,0.333333,    0.25,       0,       0,       0,       0,\n       c       0,       3,       1,       0,       0,       0,       0,       0,\n       d       0,       4,       0,       1,   0.125,       0,       0,       0,\n       w       0,       0,       0,       8,       1,       5,       0,       0,\n       x       0,       0,       0,       0,     0.2,       1,0.166667,0.142857,\n       y       0,       0,       0,       0,       0,       6,       1,       0,\n       z       0,       0,       0,       0,       0,       7,       0,       1,\n===================\n```\n```\n///The following function print graph for debug\n    void print_graph(){\n        cout<<setw(8)<<\"\";\n        for (int i=0; i<v_size; i++)\n            cout<<setw(8)<<v[i]<<\",\";\n        cout<<endl;\n        for(int i=0; i<v_size; i++){\n            cout<<setw(8)<<v[i];\n            for(int j=0; j<v_size; j++){\n                cout<<setw(8)<<graph[i][j]<<\",\";\n            }\n            cout<<endl;\n        }\n        cout<<\"===================\n\";\n    }\n///////////////////////////\n```\n\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/evaluate-division/solutions/3544770/0-ms-beats-100c-solution-using-lots-of-tables-with-debugging-info/"
                    },
                    {
                        "username": "can-keklik",
                        "content": "I would expect the description to be clearer. Even though the term \"variable\" is used to describe a part of a query, multiple letter variables like \"bc\" can be FALSELY understood as a composition of b and c (while bc is just a separate variable), and that would change the whole question, obviously would make it much more difficult. It was a good exercise though, thanks."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "![image.png](https://assets.leetcode.com/users/images/c2fc3b69-939b-444d-9c1f-4ab4ded28f58_1684568298.0892184.png)\n\nTo find A / C we just nees find the path and multiplay all edges coefficient: 2 * 3 = 6"
                    },
                    {
                        "username": "prakarshparashar",
                        "content": "For this input:\\n[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"ac\",\"bb\"]]\\n\\nThe expected result is :\\n[6.00000,0.50000,-1.00000,1.00000,-1.00000]\\n\\nHowever, \"ac\"/\"bb\" can be obtained from values[0] x (1/values[1]) . Question must be framed properly to exclude certain inputs in the queries."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Read the question carefully. \"ac\" != \"a\" * \"c\", each string corresponds to a single variable only, not a composition of many."
                    },
                    {
                        "username": "ahcox",
                        "content": "[**\\uD83E\\uDD14**](https://en.wikipedia.org/wiki/Division_(mathematics))"
                    },
                    {
                        "username": "Blatogh",
                        "content": "This question may be hard instead of medium..."
                    },
                    {
                        "username": "natitati",
                        "content": "No, no I do not recognize this as a graph problem, leetcode."
                    },
                    {
                        "username": "Kaushh",
                        "content": "The question is unclear. It assumes `bc/dc` to be different than `b/d`. Even if we can cancel out `c` from both numerator and denominator, it requires us to report -1 for that."
                    },
                    {
                        "username": "luzede",
                        "content": "I would say x/x should be 1 and not -1, especially since values are greater than 0, hence, no query taking a/b where a is 0 exists."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "It\\'s a **Hard one, but definitely cool**"
                    }
                ]
            },
            {
                "id": 1899710,
                "content": [
                    {
                        "username": "02Gaurav",
                        "content": "I dont believe myself how i solved it just by knowing its a graph problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Why are people saying it should be hard? You just have to \"flatten\" the multipliers, and you can do it in `O(n^2)` since there\\'s only 20 equations"
                    },
                    {
                        "username": "user3475tK",
                        "content": "The description have mentioned to return -1.0 in case If a single answer cannot be determined, but didn\\'t find any test case where multiple ans are possible for a given query. Spent a lot of time because of this statement and it turns out of no use\\uD83E\\uDD72"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Well yeah the question is worded poorly, but later down it does say there\\'s no equations that will contradict any other equation. If both a and b are real numbers, a / b can never give two answers anyways so you should have also thought that."
                    },
                    {
                        "username": "alexmalyushytsky",
                        "content": "[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\ntest should return  1. for [\"x\",\"x\"]]\\n\\naccording to description validness is assumed.\\nSince you do not need to know number a to evaluate a/a \\nat least the Java if order  is wrong.\\nCheck for  dividend == divisor should be the first check:\\nif (dividend == divisor)\\n                results[i] = 1.0;\\nelse if (!graph.containsKey(dividend) || !graph.containsKey(divisor))\\n                results[i] = -1.0;\\n\\nDid I miss anything?\\n"
                    },
                    {
                        "username": "coder101boy",
                        "content": "The description does not state what happens when a shorter path is available. Although, mathematically it is not possible but the test console does accept the test cases.\\n\\nFor eg\\n`equation: [[\"a\",\"b\"],[\"b\",\"c\"],[\"a\", \"e\"],[\"e\", \"c\"]`\\n`value: [2.0,3.0,0.5,0.5]`\\n`query: [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]`\\n\\nAnswer for `a  -> c` as per leetcode is 6.0  (a -> b -> c) but it could also be 0.25 (a -> e -> c). \\n\\nA simple dfs/bfs gives 6.0 but dijsktra gives 0.25. Question and test case validation needs to be more clear."
                    },
                    {
                        "username": "S_h_arp",
                        "content": "This test case is no longer accepted"
                    },
                    {
                        "username": "Zergio",
                        "content": "If query is a pair of same strings it supposed to be \"1\"? e.g. x/x = 1 (assuming that it is non zero), or it is -1 because we are not sure is it non-zero?\\n\\nQuestion is based on example test case from the question:\\n\\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\\nExplanation: \\nGiven: a / b = 2.0, b / c = 3.0\\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]"
                    },
                    {
                        "username": "ajak6",
                        "content": "in example \\n[a,b] = 2\\n[b,c] =3\\n\\nif query is a/a why should the answer be 1 \\nand if query is x/x then answer will be -1\\n\\nThis is very confusing although very easy to fix but wondering how to explain this to interviewer?"
                    },
                    {
                        "username": "yllipolly",
                        "content": "You should ask in the interview whether or not they want -1 or 1 for that case. x, x is minus 1 since x is not defined in the equation list. Although I doubt they will care if you solve this and it outputs 1."
                    },
                    {
                        "username": "QinglongZeng",
                        "content": "After I submitted my code, I got a wrong answer with input as follows:\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\nIt claimed my output is [-1.00000,0.40000,5.00000,0.20000]. However, when I tested my code with the given input, the output is [3.75000,0.40000,5.00000,0.20000], which is correct. That's wierd."
                    },
                    {
                        "username": "charonme",
                        "content": "not weird at all: if you know a/b=1.5 and b/c=2.5 then you also can know a/c=(a/b)\\*(b/c)=(1.5)\\*(2.5)=3.75"
                    },
                    {
                        "username": "tqjustc_",
                        "content": "\\u8fd9\\u4e2a\\u662f\\u6211\\u5f97\\u5230\\u7684\\u62a5\\u9519\\u4fe1\\u606f\\u3002\\n\\nInput:\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\nOutput:\\n[6.00000,3.00000,-1.00000,1.00000,1.00000]\\nExpected:\\n[6.00000,3.00000,-1.00000,1.00000,-1.00000]\\n\\n\\u867d\\u7136\\u201cx\\u201d\\u4e0d\\u5728\\u4e4b\\u524d\\u7684given equation\\u91cc\\u9762\\uff0c\\u4f46\\u662f\\uff0c[\"x\", \"x\"]\\u7684\\u7ed3\\u679c\\u662f \\u4e00\\u5b9a\\u662f1\\uff0c\\u800c\\u4e0d\\u662f -1."
                    },
                    {
                        "username": "leetcancode",
                        "content": "`Few more test cases:`\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\n\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\n[[\"ab\",\"cd\"],[\"a\",\"c\"]]\\n[4.0,2.0]\\n[[\"b\",\"d\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"a\",\"c\"]]\\n[2.0,3.0,6.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]"
                    }
                ]
            },
            {
                "id": 1899433,
                "content": [
                    {
                        "username": "02Gaurav",
                        "content": "I dont believe myself how i solved it just by knowing its a graph problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Why are people saying it should be hard? You just have to \"flatten\" the multipliers, and you can do it in `O(n^2)` since there\\'s only 20 equations"
                    },
                    {
                        "username": "user3475tK",
                        "content": "The description have mentioned to return -1.0 in case If a single answer cannot be determined, but didn\\'t find any test case where multiple ans are possible for a given query. Spent a lot of time because of this statement and it turns out of no use\\uD83E\\uDD72"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Well yeah the question is worded poorly, but later down it does say there\\'s no equations that will contradict any other equation. If both a and b are real numbers, a / b can never give two answers anyways so you should have also thought that."
                    },
                    {
                        "username": "alexmalyushytsky",
                        "content": "[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\ntest should return  1. for [\"x\",\"x\"]]\\n\\naccording to description validness is assumed.\\nSince you do not need to know number a to evaluate a/a \\nat least the Java if order  is wrong.\\nCheck for  dividend == divisor should be the first check:\\nif (dividend == divisor)\\n                results[i] = 1.0;\\nelse if (!graph.containsKey(dividend) || !graph.containsKey(divisor))\\n                results[i] = -1.0;\\n\\nDid I miss anything?\\n"
                    },
                    {
                        "username": "coder101boy",
                        "content": "The description does not state what happens when a shorter path is available. Although, mathematically it is not possible but the test console does accept the test cases.\\n\\nFor eg\\n`equation: [[\"a\",\"b\"],[\"b\",\"c\"],[\"a\", \"e\"],[\"e\", \"c\"]`\\n`value: [2.0,3.0,0.5,0.5]`\\n`query: [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]`\\n\\nAnswer for `a  -> c` as per leetcode is 6.0  (a -> b -> c) but it could also be 0.25 (a -> e -> c). \\n\\nA simple dfs/bfs gives 6.0 but dijsktra gives 0.25. Question and test case validation needs to be more clear."
                    },
                    {
                        "username": "S_h_arp",
                        "content": "This test case is no longer accepted"
                    },
                    {
                        "username": "Zergio",
                        "content": "If query is a pair of same strings it supposed to be \"1\"? e.g. x/x = 1 (assuming that it is non zero), or it is -1 because we are not sure is it non-zero?\\n\\nQuestion is based on example test case from the question:\\n\\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\\nExplanation: \\nGiven: a / b = 2.0, b / c = 3.0\\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]"
                    },
                    {
                        "username": "ajak6",
                        "content": "in example \\n[a,b] = 2\\n[b,c] =3\\n\\nif query is a/a why should the answer be 1 \\nand if query is x/x then answer will be -1\\n\\nThis is very confusing although very easy to fix but wondering how to explain this to interviewer?"
                    },
                    {
                        "username": "yllipolly",
                        "content": "You should ask in the interview whether or not they want -1 or 1 for that case. x, x is minus 1 since x is not defined in the equation list. Although I doubt they will care if you solve this and it outputs 1."
                    },
                    {
                        "username": "QinglongZeng",
                        "content": "After I submitted my code, I got a wrong answer with input as follows:\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\nIt claimed my output is [-1.00000,0.40000,5.00000,0.20000]. However, when I tested my code with the given input, the output is [3.75000,0.40000,5.00000,0.20000], which is correct. That's wierd."
                    },
                    {
                        "username": "charonme",
                        "content": "not weird at all: if you know a/b=1.5 and b/c=2.5 then you also can know a/c=(a/b)\\*(b/c)=(1.5)\\*(2.5)=3.75"
                    },
                    {
                        "username": "tqjustc_",
                        "content": "\\u8fd9\\u4e2a\\u662f\\u6211\\u5f97\\u5230\\u7684\\u62a5\\u9519\\u4fe1\\u606f\\u3002\\n\\nInput:\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\nOutput:\\n[6.00000,3.00000,-1.00000,1.00000,1.00000]\\nExpected:\\n[6.00000,3.00000,-1.00000,1.00000,-1.00000]\\n\\n\\u867d\\u7136\\u201cx\\u201d\\u4e0d\\u5728\\u4e4b\\u524d\\u7684given equation\\u91cc\\u9762\\uff0c\\u4f46\\u662f\\uff0c[\"x\", \"x\"]\\u7684\\u7ed3\\u679c\\u662f \\u4e00\\u5b9a\\u662f1\\uff0c\\u800c\\u4e0d\\u662f -1."
                    },
                    {
                        "username": "leetcancode",
                        "content": "`Few more test cases:`\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\n\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\n[[\"ab\",\"cd\"],[\"a\",\"c\"]]\\n[4.0,2.0]\\n[[\"b\",\"d\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"a\",\"c\"]]\\n[2.0,3.0,6.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]"
                    }
                ]
            },
            {
                "id": 1758857,
                "content": [
                    {
                        "username": "02Gaurav",
                        "content": "I dont believe myself how i solved it just by knowing its a graph problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Why are people saying it should be hard? You just have to \"flatten\" the multipliers, and you can do it in `O(n^2)` since there\\'s only 20 equations"
                    },
                    {
                        "username": "user3475tK",
                        "content": "The description have mentioned to return -1.0 in case If a single answer cannot be determined, but didn\\'t find any test case where multiple ans are possible for a given query. Spent a lot of time because of this statement and it turns out of no use\\uD83E\\uDD72"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Well yeah the question is worded poorly, but later down it does say there\\'s no equations that will contradict any other equation. If both a and b are real numbers, a / b can never give two answers anyways so you should have also thought that."
                    },
                    {
                        "username": "alexmalyushytsky",
                        "content": "[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\ntest should return  1. for [\"x\",\"x\"]]\\n\\naccording to description validness is assumed.\\nSince you do not need to know number a to evaluate a/a \\nat least the Java if order  is wrong.\\nCheck for  dividend == divisor should be the first check:\\nif (dividend == divisor)\\n                results[i] = 1.0;\\nelse if (!graph.containsKey(dividend) || !graph.containsKey(divisor))\\n                results[i] = -1.0;\\n\\nDid I miss anything?\\n"
                    },
                    {
                        "username": "coder101boy",
                        "content": "The description does not state what happens when a shorter path is available. Although, mathematically it is not possible but the test console does accept the test cases.\\n\\nFor eg\\n`equation: [[\"a\",\"b\"],[\"b\",\"c\"],[\"a\", \"e\"],[\"e\", \"c\"]`\\n`value: [2.0,3.0,0.5,0.5]`\\n`query: [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]`\\n\\nAnswer for `a  -> c` as per leetcode is 6.0  (a -> b -> c) but it could also be 0.25 (a -> e -> c). \\n\\nA simple dfs/bfs gives 6.0 but dijsktra gives 0.25. Question and test case validation needs to be more clear."
                    },
                    {
                        "username": "S_h_arp",
                        "content": "This test case is no longer accepted"
                    },
                    {
                        "username": "Zergio",
                        "content": "If query is a pair of same strings it supposed to be \"1\"? e.g. x/x = 1 (assuming that it is non zero), or it is -1 because we are not sure is it non-zero?\\n\\nQuestion is based on example test case from the question:\\n\\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\\nExplanation: \\nGiven: a / b = 2.0, b / c = 3.0\\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]"
                    },
                    {
                        "username": "ajak6",
                        "content": "in example \\n[a,b] = 2\\n[b,c] =3\\n\\nif query is a/a why should the answer be 1 \\nand if query is x/x then answer will be -1\\n\\nThis is very confusing although very easy to fix but wondering how to explain this to interviewer?"
                    },
                    {
                        "username": "yllipolly",
                        "content": "You should ask in the interview whether or not they want -1 or 1 for that case. x, x is minus 1 since x is not defined in the equation list. Although I doubt they will care if you solve this and it outputs 1."
                    },
                    {
                        "username": "QinglongZeng",
                        "content": "After I submitted my code, I got a wrong answer with input as follows:\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\nIt claimed my output is [-1.00000,0.40000,5.00000,0.20000]. However, when I tested my code with the given input, the output is [3.75000,0.40000,5.00000,0.20000], which is correct. That's wierd."
                    },
                    {
                        "username": "charonme",
                        "content": "not weird at all: if you know a/b=1.5 and b/c=2.5 then you also can know a/c=(a/b)\\*(b/c)=(1.5)\\*(2.5)=3.75"
                    },
                    {
                        "username": "tqjustc_",
                        "content": "\\u8fd9\\u4e2a\\u662f\\u6211\\u5f97\\u5230\\u7684\\u62a5\\u9519\\u4fe1\\u606f\\u3002\\n\\nInput:\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\nOutput:\\n[6.00000,3.00000,-1.00000,1.00000,1.00000]\\nExpected:\\n[6.00000,3.00000,-1.00000,1.00000,-1.00000]\\n\\n\\u867d\\u7136\\u201cx\\u201d\\u4e0d\\u5728\\u4e4b\\u524d\\u7684given equation\\u91cc\\u9762\\uff0c\\u4f46\\u662f\\uff0c[\"x\", \"x\"]\\u7684\\u7ed3\\u679c\\u662f \\u4e00\\u5b9a\\u662f1\\uff0c\\u800c\\u4e0d\\u662f -1."
                    },
                    {
                        "username": "leetcancode",
                        "content": "`Few more test cases:`\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\n\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\n[[\"ab\",\"cd\"],[\"a\",\"c\"]]\\n[4.0,2.0]\\n[[\"b\",\"d\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"a\",\"c\"]]\\n[2.0,3.0,6.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]"
                    }
                ]
            },
            {
                "id": 1576343,
                "content": [
                    {
                        "username": "02Gaurav",
                        "content": "I dont believe myself how i solved it just by knowing its a graph problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Why are people saying it should be hard? You just have to \"flatten\" the multipliers, and you can do it in `O(n^2)` since there\\'s only 20 equations"
                    },
                    {
                        "username": "user3475tK",
                        "content": "The description have mentioned to return -1.0 in case If a single answer cannot be determined, but didn\\'t find any test case where multiple ans are possible for a given query. Spent a lot of time because of this statement and it turns out of no use\\uD83E\\uDD72"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Well yeah the question is worded poorly, but later down it does say there\\'s no equations that will contradict any other equation. If both a and b are real numbers, a / b can never give two answers anyways so you should have also thought that."
                    },
                    {
                        "username": "alexmalyushytsky",
                        "content": "[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\ntest should return  1. for [\"x\",\"x\"]]\\n\\naccording to description validness is assumed.\\nSince you do not need to know number a to evaluate a/a \\nat least the Java if order  is wrong.\\nCheck for  dividend == divisor should be the first check:\\nif (dividend == divisor)\\n                results[i] = 1.0;\\nelse if (!graph.containsKey(dividend) || !graph.containsKey(divisor))\\n                results[i] = -1.0;\\n\\nDid I miss anything?\\n"
                    },
                    {
                        "username": "coder101boy",
                        "content": "The description does not state what happens when a shorter path is available. Although, mathematically it is not possible but the test console does accept the test cases.\\n\\nFor eg\\n`equation: [[\"a\",\"b\"],[\"b\",\"c\"],[\"a\", \"e\"],[\"e\", \"c\"]`\\n`value: [2.0,3.0,0.5,0.5]`\\n`query: [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]`\\n\\nAnswer for `a  -> c` as per leetcode is 6.0  (a -> b -> c) but it could also be 0.25 (a -> e -> c). \\n\\nA simple dfs/bfs gives 6.0 but dijsktra gives 0.25. Question and test case validation needs to be more clear."
                    },
                    {
                        "username": "S_h_arp",
                        "content": "This test case is no longer accepted"
                    },
                    {
                        "username": "Zergio",
                        "content": "If query is a pair of same strings it supposed to be \"1\"? e.g. x/x = 1 (assuming that it is non zero), or it is -1 because we are not sure is it non-zero?\\n\\nQuestion is based on example test case from the question:\\n\\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\\nExplanation: \\nGiven: a / b = 2.0, b / c = 3.0\\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]"
                    },
                    {
                        "username": "ajak6",
                        "content": "in example \\n[a,b] = 2\\n[b,c] =3\\n\\nif query is a/a why should the answer be 1 \\nand if query is x/x then answer will be -1\\n\\nThis is very confusing although very easy to fix but wondering how to explain this to interviewer?"
                    },
                    {
                        "username": "yllipolly",
                        "content": "You should ask in the interview whether or not they want -1 or 1 for that case. x, x is minus 1 since x is not defined in the equation list. Although I doubt they will care if you solve this and it outputs 1."
                    },
                    {
                        "username": "QinglongZeng",
                        "content": "After I submitted my code, I got a wrong answer with input as follows:\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\nIt claimed my output is [-1.00000,0.40000,5.00000,0.20000]. However, when I tested my code with the given input, the output is [3.75000,0.40000,5.00000,0.20000], which is correct. That's wierd."
                    },
                    {
                        "username": "charonme",
                        "content": "not weird at all: if you know a/b=1.5 and b/c=2.5 then you also can know a/c=(a/b)\\*(b/c)=(1.5)\\*(2.5)=3.75"
                    },
                    {
                        "username": "tqjustc_",
                        "content": "\\u8fd9\\u4e2a\\u662f\\u6211\\u5f97\\u5230\\u7684\\u62a5\\u9519\\u4fe1\\u606f\\u3002\\n\\nInput:\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\nOutput:\\n[6.00000,3.00000,-1.00000,1.00000,1.00000]\\nExpected:\\n[6.00000,3.00000,-1.00000,1.00000,-1.00000]\\n\\n\\u867d\\u7136\\u201cx\\u201d\\u4e0d\\u5728\\u4e4b\\u524d\\u7684given equation\\u91cc\\u9762\\uff0c\\u4f46\\u662f\\uff0c[\"x\", \"x\"]\\u7684\\u7ed3\\u679c\\u662f \\u4e00\\u5b9a\\u662f1\\uff0c\\u800c\\u4e0d\\u662f -1."
                    },
                    {
                        "username": "leetcancode",
                        "content": "`Few more test cases:`\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\n\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\n[[\"ab\",\"cd\"],[\"a\",\"c\"]]\\n[4.0,2.0]\\n[[\"b\",\"d\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"a\",\"c\"]]\\n[2.0,3.0,6.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]"
                    }
                ]
            },
            {
                "id": 1576326,
                "content": [
                    {
                        "username": "02Gaurav",
                        "content": "I dont believe myself how i solved it just by knowing its a graph problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Why are people saying it should be hard? You just have to \"flatten\" the multipliers, and you can do it in `O(n^2)` since there\\'s only 20 equations"
                    },
                    {
                        "username": "user3475tK",
                        "content": "The description have mentioned to return -1.0 in case If a single answer cannot be determined, but didn\\'t find any test case where multiple ans are possible for a given query. Spent a lot of time because of this statement and it turns out of no use\\uD83E\\uDD72"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Well yeah the question is worded poorly, but later down it does say there\\'s no equations that will contradict any other equation. If both a and b are real numbers, a / b can never give two answers anyways so you should have also thought that."
                    },
                    {
                        "username": "alexmalyushytsky",
                        "content": "[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\ntest should return  1. for [\"x\",\"x\"]]\\n\\naccording to description validness is assumed.\\nSince you do not need to know number a to evaluate a/a \\nat least the Java if order  is wrong.\\nCheck for  dividend == divisor should be the first check:\\nif (dividend == divisor)\\n                results[i] = 1.0;\\nelse if (!graph.containsKey(dividend) || !graph.containsKey(divisor))\\n                results[i] = -1.0;\\n\\nDid I miss anything?\\n"
                    },
                    {
                        "username": "coder101boy",
                        "content": "The description does not state what happens when a shorter path is available. Although, mathematically it is not possible but the test console does accept the test cases.\\n\\nFor eg\\n`equation: [[\"a\",\"b\"],[\"b\",\"c\"],[\"a\", \"e\"],[\"e\", \"c\"]`\\n`value: [2.0,3.0,0.5,0.5]`\\n`query: [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]`\\n\\nAnswer for `a  -> c` as per leetcode is 6.0  (a -> b -> c) but it could also be 0.25 (a -> e -> c). \\n\\nA simple dfs/bfs gives 6.0 but dijsktra gives 0.25. Question and test case validation needs to be more clear."
                    },
                    {
                        "username": "S_h_arp",
                        "content": "This test case is no longer accepted"
                    },
                    {
                        "username": "Zergio",
                        "content": "If query is a pair of same strings it supposed to be \"1\"? e.g. x/x = 1 (assuming that it is non zero), or it is -1 because we are not sure is it non-zero?\\n\\nQuestion is based on example test case from the question:\\n\\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\\nExplanation: \\nGiven: a / b = 2.0, b / c = 3.0\\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]"
                    },
                    {
                        "username": "ajak6",
                        "content": "in example \\n[a,b] = 2\\n[b,c] =3\\n\\nif query is a/a why should the answer be 1 \\nand if query is x/x then answer will be -1\\n\\nThis is very confusing although very easy to fix but wondering how to explain this to interviewer?"
                    },
                    {
                        "username": "yllipolly",
                        "content": "You should ask in the interview whether or not they want -1 or 1 for that case. x, x is minus 1 since x is not defined in the equation list. Although I doubt they will care if you solve this and it outputs 1."
                    },
                    {
                        "username": "QinglongZeng",
                        "content": "After I submitted my code, I got a wrong answer with input as follows:\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\nIt claimed my output is [-1.00000,0.40000,5.00000,0.20000]. However, when I tested my code with the given input, the output is [3.75000,0.40000,5.00000,0.20000], which is correct. That's wierd."
                    },
                    {
                        "username": "charonme",
                        "content": "not weird at all: if you know a/b=1.5 and b/c=2.5 then you also can know a/c=(a/b)\\*(b/c)=(1.5)\\*(2.5)=3.75"
                    },
                    {
                        "username": "tqjustc_",
                        "content": "\\u8fd9\\u4e2a\\u662f\\u6211\\u5f97\\u5230\\u7684\\u62a5\\u9519\\u4fe1\\u606f\\u3002\\n\\nInput:\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\nOutput:\\n[6.00000,3.00000,-1.00000,1.00000,1.00000]\\nExpected:\\n[6.00000,3.00000,-1.00000,1.00000,-1.00000]\\n\\n\\u867d\\u7136\\u201cx\\u201d\\u4e0d\\u5728\\u4e4b\\u524d\\u7684given equation\\u91cc\\u9762\\uff0c\\u4f46\\u662f\\uff0c[\"x\", \"x\"]\\u7684\\u7ed3\\u679c\\u662f \\u4e00\\u5b9a\\u662f1\\uff0c\\u800c\\u4e0d\\u662f -1."
                    },
                    {
                        "username": "leetcancode",
                        "content": "`Few more test cases:`\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\n\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\n[[\"ab\",\"cd\"],[\"a\",\"c\"]]\\n[4.0,2.0]\\n[[\"b\",\"d\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"a\",\"c\"]]\\n[2.0,3.0,6.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]"
                    }
                ]
            },
            {
                "id": 1576219,
                "content": [
                    {
                        "username": "02Gaurav",
                        "content": "I dont believe myself how i solved it just by knowing its a graph problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Why are people saying it should be hard? You just have to \"flatten\" the multipliers, and you can do it in `O(n^2)` since there\\'s only 20 equations"
                    },
                    {
                        "username": "user3475tK",
                        "content": "The description have mentioned to return -1.0 in case If a single answer cannot be determined, but didn\\'t find any test case where multiple ans are possible for a given query. Spent a lot of time because of this statement and it turns out of no use\\uD83E\\uDD72"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Well yeah the question is worded poorly, but later down it does say there\\'s no equations that will contradict any other equation. If both a and b are real numbers, a / b can never give two answers anyways so you should have also thought that."
                    },
                    {
                        "username": "alexmalyushytsky",
                        "content": "[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\ntest should return  1. for [\"x\",\"x\"]]\\n\\naccording to description validness is assumed.\\nSince you do not need to know number a to evaluate a/a \\nat least the Java if order  is wrong.\\nCheck for  dividend == divisor should be the first check:\\nif (dividend == divisor)\\n                results[i] = 1.0;\\nelse if (!graph.containsKey(dividend) || !graph.containsKey(divisor))\\n                results[i] = -1.0;\\n\\nDid I miss anything?\\n"
                    },
                    {
                        "username": "coder101boy",
                        "content": "The description does not state what happens when a shorter path is available. Although, mathematically it is not possible but the test console does accept the test cases.\\n\\nFor eg\\n`equation: [[\"a\",\"b\"],[\"b\",\"c\"],[\"a\", \"e\"],[\"e\", \"c\"]`\\n`value: [2.0,3.0,0.5,0.5]`\\n`query: [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]`\\n\\nAnswer for `a  -> c` as per leetcode is 6.0  (a -> b -> c) but it could also be 0.25 (a -> e -> c). \\n\\nA simple dfs/bfs gives 6.0 but dijsktra gives 0.25. Question and test case validation needs to be more clear."
                    },
                    {
                        "username": "S_h_arp",
                        "content": "This test case is no longer accepted"
                    },
                    {
                        "username": "Zergio",
                        "content": "If query is a pair of same strings it supposed to be \"1\"? e.g. x/x = 1 (assuming that it is non zero), or it is -1 because we are not sure is it non-zero?\\n\\nQuestion is based on example test case from the question:\\n\\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\\nExplanation: \\nGiven: a / b = 2.0, b / c = 3.0\\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]"
                    },
                    {
                        "username": "ajak6",
                        "content": "in example \\n[a,b] = 2\\n[b,c] =3\\n\\nif query is a/a why should the answer be 1 \\nand if query is x/x then answer will be -1\\n\\nThis is very confusing although very easy to fix but wondering how to explain this to interviewer?"
                    },
                    {
                        "username": "yllipolly",
                        "content": "You should ask in the interview whether or not they want -1 or 1 for that case. x, x is minus 1 since x is not defined in the equation list. Although I doubt they will care if you solve this and it outputs 1."
                    },
                    {
                        "username": "QinglongZeng",
                        "content": "After I submitted my code, I got a wrong answer with input as follows:\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\nIt claimed my output is [-1.00000,0.40000,5.00000,0.20000]. However, when I tested my code with the given input, the output is [3.75000,0.40000,5.00000,0.20000], which is correct. That's wierd."
                    },
                    {
                        "username": "charonme",
                        "content": "not weird at all: if you know a/b=1.5 and b/c=2.5 then you also can know a/c=(a/b)\\*(b/c)=(1.5)\\*(2.5)=3.75"
                    },
                    {
                        "username": "tqjustc_",
                        "content": "\\u8fd9\\u4e2a\\u662f\\u6211\\u5f97\\u5230\\u7684\\u62a5\\u9519\\u4fe1\\u606f\\u3002\\n\\nInput:\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\nOutput:\\n[6.00000,3.00000,-1.00000,1.00000,1.00000]\\nExpected:\\n[6.00000,3.00000,-1.00000,1.00000,-1.00000]\\n\\n\\u867d\\u7136\\u201cx\\u201d\\u4e0d\\u5728\\u4e4b\\u524d\\u7684given equation\\u91cc\\u9762\\uff0c\\u4f46\\u662f\\uff0c[\"x\", \"x\"]\\u7684\\u7ed3\\u679c\\u662f \\u4e00\\u5b9a\\u662f1\\uff0c\\u800c\\u4e0d\\u662f -1."
                    },
                    {
                        "username": "leetcancode",
                        "content": "`Few more test cases:`\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\n\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\n[[\"ab\",\"cd\"],[\"a\",\"c\"]]\\n[4.0,2.0]\\n[[\"b\",\"d\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"a\",\"c\"]]\\n[2.0,3.0,6.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]"
                    }
                ]
            },
            {
                "id": 1573600,
                "content": [
                    {
                        "username": "02Gaurav",
                        "content": "I dont believe myself how i solved it just by knowing its a graph problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Why are people saying it should be hard? You just have to \"flatten\" the multipliers, and you can do it in `O(n^2)` since there\\'s only 20 equations"
                    },
                    {
                        "username": "user3475tK",
                        "content": "The description have mentioned to return -1.0 in case If a single answer cannot be determined, but didn\\'t find any test case where multiple ans are possible for a given query. Spent a lot of time because of this statement and it turns out of no use\\uD83E\\uDD72"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Well yeah the question is worded poorly, but later down it does say there\\'s no equations that will contradict any other equation. If both a and b are real numbers, a / b can never give two answers anyways so you should have also thought that."
                    },
                    {
                        "username": "alexmalyushytsky",
                        "content": "[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\ntest should return  1. for [\"x\",\"x\"]]\\n\\naccording to description validness is assumed.\\nSince you do not need to know number a to evaluate a/a \\nat least the Java if order  is wrong.\\nCheck for  dividend == divisor should be the first check:\\nif (dividend == divisor)\\n                results[i] = 1.0;\\nelse if (!graph.containsKey(dividend) || !graph.containsKey(divisor))\\n                results[i] = -1.0;\\n\\nDid I miss anything?\\n"
                    },
                    {
                        "username": "coder101boy",
                        "content": "The description does not state what happens when a shorter path is available. Although, mathematically it is not possible but the test console does accept the test cases.\\n\\nFor eg\\n`equation: [[\"a\",\"b\"],[\"b\",\"c\"],[\"a\", \"e\"],[\"e\", \"c\"]`\\n`value: [2.0,3.0,0.5,0.5]`\\n`query: [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]`\\n\\nAnswer for `a  -> c` as per leetcode is 6.0  (a -> b -> c) but it could also be 0.25 (a -> e -> c). \\n\\nA simple dfs/bfs gives 6.0 but dijsktra gives 0.25. Question and test case validation needs to be more clear."
                    },
                    {
                        "username": "S_h_arp",
                        "content": "This test case is no longer accepted"
                    },
                    {
                        "username": "Zergio",
                        "content": "If query is a pair of same strings it supposed to be \"1\"? e.g. x/x = 1 (assuming that it is non zero), or it is -1 because we are not sure is it non-zero?\\n\\nQuestion is based on example test case from the question:\\n\\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\\nExplanation: \\nGiven: a / b = 2.0, b / c = 3.0\\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]"
                    },
                    {
                        "username": "ajak6",
                        "content": "in example \\n[a,b] = 2\\n[b,c] =3\\n\\nif query is a/a why should the answer be 1 \\nand if query is x/x then answer will be -1\\n\\nThis is very confusing although very easy to fix but wondering how to explain this to interviewer?"
                    },
                    {
                        "username": "yllipolly",
                        "content": "You should ask in the interview whether or not they want -1 or 1 for that case. x, x is minus 1 since x is not defined in the equation list. Although I doubt they will care if you solve this and it outputs 1."
                    },
                    {
                        "username": "QinglongZeng",
                        "content": "After I submitted my code, I got a wrong answer with input as follows:\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\nIt claimed my output is [-1.00000,0.40000,5.00000,0.20000]. However, when I tested my code with the given input, the output is [3.75000,0.40000,5.00000,0.20000], which is correct. That's wierd."
                    },
                    {
                        "username": "charonme",
                        "content": "not weird at all: if you know a/b=1.5 and b/c=2.5 then you also can know a/c=(a/b)\\*(b/c)=(1.5)\\*(2.5)=3.75"
                    },
                    {
                        "username": "tqjustc_",
                        "content": "\\u8fd9\\u4e2a\\u662f\\u6211\\u5f97\\u5230\\u7684\\u62a5\\u9519\\u4fe1\\u606f\\u3002\\n\\nInput:\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\nOutput:\\n[6.00000,3.00000,-1.00000,1.00000,1.00000]\\nExpected:\\n[6.00000,3.00000,-1.00000,1.00000,-1.00000]\\n\\n\\u867d\\u7136\\u201cx\\u201d\\u4e0d\\u5728\\u4e4b\\u524d\\u7684given equation\\u91cc\\u9762\\uff0c\\u4f46\\u662f\\uff0c[\"x\", \"x\"]\\u7684\\u7ed3\\u679c\\u662f \\u4e00\\u5b9a\\u662f1\\uff0c\\u800c\\u4e0d\\u662f -1."
                    },
                    {
                        "username": "leetcancode",
                        "content": "`Few more test cases:`\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\n\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\n[[\"ab\",\"cd\"],[\"a\",\"c\"]]\\n[4.0,2.0]\\n[[\"b\",\"d\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"a\",\"c\"]]\\n[2.0,3.0,6.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]"
                    }
                ]
            },
            {
                "id": 1571671,
                "content": [
                    {
                        "username": "02Gaurav",
                        "content": "I dont believe myself how i solved it just by knowing its a graph problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Why are people saying it should be hard? You just have to \"flatten\" the multipliers, and you can do it in `O(n^2)` since there\\'s only 20 equations"
                    },
                    {
                        "username": "user3475tK",
                        "content": "The description have mentioned to return -1.0 in case If a single answer cannot be determined, but didn\\'t find any test case where multiple ans are possible for a given query. Spent a lot of time because of this statement and it turns out of no use\\uD83E\\uDD72"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Well yeah the question is worded poorly, but later down it does say there\\'s no equations that will contradict any other equation. If both a and b are real numbers, a / b can never give two answers anyways so you should have also thought that."
                    },
                    {
                        "username": "alexmalyushytsky",
                        "content": "[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\ntest should return  1. for [\"x\",\"x\"]]\\n\\naccording to description validness is assumed.\\nSince you do not need to know number a to evaluate a/a \\nat least the Java if order  is wrong.\\nCheck for  dividend == divisor should be the first check:\\nif (dividend == divisor)\\n                results[i] = 1.0;\\nelse if (!graph.containsKey(dividend) || !graph.containsKey(divisor))\\n                results[i] = -1.0;\\n\\nDid I miss anything?\\n"
                    },
                    {
                        "username": "coder101boy",
                        "content": "The description does not state what happens when a shorter path is available. Although, mathematically it is not possible but the test console does accept the test cases.\\n\\nFor eg\\n`equation: [[\"a\",\"b\"],[\"b\",\"c\"],[\"a\", \"e\"],[\"e\", \"c\"]`\\n`value: [2.0,3.0,0.5,0.5]`\\n`query: [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]`\\n\\nAnswer for `a  -> c` as per leetcode is 6.0  (a -> b -> c) but it could also be 0.25 (a -> e -> c). \\n\\nA simple dfs/bfs gives 6.0 but dijsktra gives 0.25. Question and test case validation needs to be more clear."
                    },
                    {
                        "username": "S_h_arp",
                        "content": "This test case is no longer accepted"
                    },
                    {
                        "username": "Zergio",
                        "content": "If query is a pair of same strings it supposed to be \"1\"? e.g. x/x = 1 (assuming that it is non zero), or it is -1 because we are not sure is it non-zero?\\n\\nQuestion is based on example test case from the question:\\n\\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\\nExplanation: \\nGiven: a / b = 2.0, b / c = 3.0\\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]"
                    },
                    {
                        "username": "ajak6",
                        "content": "in example \\n[a,b] = 2\\n[b,c] =3\\n\\nif query is a/a why should the answer be 1 \\nand if query is x/x then answer will be -1\\n\\nThis is very confusing although very easy to fix but wondering how to explain this to interviewer?"
                    },
                    {
                        "username": "yllipolly",
                        "content": "You should ask in the interview whether or not they want -1 or 1 for that case. x, x is minus 1 since x is not defined in the equation list. Although I doubt they will care if you solve this and it outputs 1."
                    },
                    {
                        "username": "QinglongZeng",
                        "content": "After I submitted my code, I got a wrong answer with input as follows:\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\nIt claimed my output is [-1.00000,0.40000,5.00000,0.20000]. However, when I tested my code with the given input, the output is [3.75000,0.40000,5.00000,0.20000], which is correct. That's wierd."
                    },
                    {
                        "username": "charonme",
                        "content": "not weird at all: if you know a/b=1.5 and b/c=2.5 then you also can know a/c=(a/b)\\*(b/c)=(1.5)\\*(2.5)=3.75"
                    },
                    {
                        "username": "tqjustc_",
                        "content": "\\u8fd9\\u4e2a\\u662f\\u6211\\u5f97\\u5230\\u7684\\u62a5\\u9519\\u4fe1\\u606f\\u3002\\n\\nInput:\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\nOutput:\\n[6.00000,3.00000,-1.00000,1.00000,1.00000]\\nExpected:\\n[6.00000,3.00000,-1.00000,1.00000,-1.00000]\\n\\n\\u867d\\u7136\\u201cx\\u201d\\u4e0d\\u5728\\u4e4b\\u524d\\u7684given equation\\u91cc\\u9762\\uff0c\\u4f46\\u662f\\uff0c[\"x\", \"x\"]\\u7684\\u7ed3\\u679c\\u662f \\u4e00\\u5b9a\\u662f1\\uff0c\\u800c\\u4e0d\\u662f -1."
                    },
                    {
                        "username": "leetcancode",
                        "content": "`Few more test cases:`\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\n\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\n[[\"ab\",\"cd\"],[\"a\",\"c\"]]\\n[4.0,2.0]\\n[[\"b\",\"d\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"a\",\"c\"]]\\n[2.0,3.0,6.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]"
                    }
                ]
            },
            {
                "id": 1569111,
                "content": [
                    {
                        "username": "02Gaurav",
                        "content": "I dont believe myself how i solved it just by knowing its a graph problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Why are people saying it should be hard? You just have to \"flatten\" the multipliers, and you can do it in `O(n^2)` since there\\'s only 20 equations"
                    },
                    {
                        "username": "user3475tK",
                        "content": "The description have mentioned to return -1.0 in case If a single answer cannot be determined, but didn\\'t find any test case where multiple ans are possible for a given query. Spent a lot of time because of this statement and it turns out of no use\\uD83E\\uDD72"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Well yeah the question is worded poorly, but later down it does say there\\'s no equations that will contradict any other equation. If both a and b are real numbers, a / b can never give two answers anyways so you should have also thought that."
                    },
                    {
                        "username": "alexmalyushytsky",
                        "content": "[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\ntest should return  1. for [\"x\",\"x\"]]\\n\\naccording to description validness is assumed.\\nSince you do not need to know number a to evaluate a/a \\nat least the Java if order  is wrong.\\nCheck for  dividend == divisor should be the first check:\\nif (dividend == divisor)\\n                results[i] = 1.0;\\nelse if (!graph.containsKey(dividend) || !graph.containsKey(divisor))\\n                results[i] = -1.0;\\n\\nDid I miss anything?\\n"
                    },
                    {
                        "username": "coder101boy",
                        "content": "The description does not state what happens when a shorter path is available. Although, mathematically it is not possible but the test console does accept the test cases.\\n\\nFor eg\\n`equation: [[\"a\",\"b\"],[\"b\",\"c\"],[\"a\", \"e\"],[\"e\", \"c\"]`\\n`value: [2.0,3.0,0.5,0.5]`\\n`query: [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]`\\n\\nAnswer for `a  -> c` as per leetcode is 6.0  (a -> b -> c) but it could also be 0.25 (a -> e -> c). \\n\\nA simple dfs/bfs gives 6.0 but dijsktra gives 0.25. Question and test case validation needs to be more clear."
                    },
                    {
                        "username": "S_h_arp",
                        "content": "This test case is no longer accepted"
                    },
                    {
                        "username": "Zergio",
                        "content": "If query is a pair of same strings it supposed to be \"1\"? e.g. x/x = 1 (assuming that it is non zero), or it is -1 because we are not sure is it non-zero?\\n\\nQuestion is based on example test case from the question:\\n\\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\\nExplanation: \\nGiven: a / b = 2.0, b / c = 3.0\\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]"
                    },
                    {
                        "username": "ajak6",
                        "content": "in example \\n[a,b] = 2\\n[b,c] =3\\n\\nif query is a/a why should the answer be 1 \\nand if query is x/x then answer will be -1\\n\\nThis is very confusing although very easy to fix but wondering how to explain this to interviewer?"
                    },
                    {
                        "username": "yllipolly",
                        "content": "You should ask in the interview whether or not they want -1 or 1 for that case. x, x is minus 1 since x is not defined in the equation list. Although I doubt they will care if you solve this and it outputs 1."
                    },
                    {
                        "username": "QinglongZeng",
                        "content": "After I submitted my code, I got a wrong answer with input as follows:\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\nIt claimed my output is [-1.00000,0.40000,5.00000,0.20000]. However, when I tested my code with the given input, the output is [3.75000,0.40000,5.00000,0.20000], which is correct. That's wierd."
                    },
                    {
                        "username": "charonme",
                        "content": "not weird at all: if you know a/b=1.5 and b/c=2.5 then you also can know a/c=(a/b)\\*(b/c)=(1.5)\\*(2.5)=3.75"
                    },
                    {
                        "username": "tqjustc_",
                        "content": "\\u8fd9\\u4e2a\\u662f\\u6211\\u5f97\\u5230\\u7684\\u62a5\\u9519\\u4fe1\\u606f\\u3002\\n\\nInput:\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\nOutput:\\n[6.00000,3.00000,-1.00000,1.00000,1.00000]\\nExpected:\\n[6.00000,3.00000,-1.00000,1.00000,-1.00000]\\n\\n\\u867d\\u7136\\u201cx\\u201d\\u4e0d\\u5728\\u4e4b\\u524d\\u7684given equation\\u91cc\\u9762\\uff0c\\u4f46\\u662f\\uff0c[\"x\", \"x\"]\\u7684\\u7ed3\\u679c\\u662f \\u4e00\\u5b9a\\u662f1\\uff0c\\u800c\\u4e0d\\u662f -1."
                    },
                    {
                        "username": "leetcancode",
                        "content": "`Few more test cases:`\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\n\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\n[[\"ab\",\"cd\"],[\"a\",\"c\"]]\\n[4.0,2.0]\\n[[\"b\",\"d\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"a\",\"c\"]]\\n[2.0,3.0,6.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]"
                    }
                ]
            },
            {
                "id": 2052084,
                "content": [
                    {
                        "username": "02Gaurav",
                        "content": "I dont believe myself how i solved it just by knowing its a graph problem."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Why are people saying it should be hard? You just have to \"flatten\" the multipliers, and you can do it in `O(n^2)` since there\\'s only 20 equations"
                    },
                    {
                        "username": "user3475tK",
                        "content": "The description have mentioned to return -1.0 in case If a single answer cannot be determined, but didn\\'t find any test case where multiple ans are possible for a given query. Spent a lot of time because of this statement and it turns out of no use\\uD83E\\uDD72"
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Well yeah the question is worded poorly, but later down it does say there\\'s no equations that will contradict any other equation. If both a and b are real numbers, a / b can never give two answers anyways so you should have also thought that."
                    },
                    {
                        "username": "alexmalyushytsky",
                        "content": "[[\"a\",\"b\"],[\"b\",\"c\"]]\\n[2.0,3.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\ntest should return  1. for [\"x\",\"x\"]]\\n\\naccording to description validness is assumed.\\nSince you do not need to know number a to evaluate a/a \\nat least the Java if order  is wrong.\\nCheck for  dividend == divisor should be the first check:\\nif (dividend == divisor)\\n                results[i] = 1.0;\\nelse if (!graph.containsKey(dividend) || !graph.containsKey(divisor))\\n                results[i] = -1.0;\\n\\nDid I miss anything?\\n"
                    },
                    {
                        "username": "coder101boy",
                        "content": "The description does not state what happens when a shorter path is available. Although, mathematically it is not possible but the test console does accept the test cases.\\n\\nFor eg\\n`equation: [[\"a\",\"b\"],[\"b\",\"c\"],[\"a\", \"e\"],[\"e\", \"c\"]`\\n`value: [2.0,3.0,0.5,0.5]`\\n`query: [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]`\\n\\nAnswer for `a  -> c` as per leetcode is 6.0  (a -> b -> c) but it could also be 0.25 (a -> e -> c). \\n\\nA simple dfs/bfs gives 6.0 but dijsktra gives 0.25. Question and test case validation needs to be more clear."
                    },
                    {
                        "username": "S_h_arp",
                        "content": "This test case is no longer accepted"
                    },
                    {
                        "username": "Zergio",
                        "content": "If query is a pair of same strings it supposed to be \"1\"? e.g. x/x = 1 (assuming that it is non zero), or it is -1 because we are not sure is it non-zero?\\n\\nQuestion is based on example test case from the question:\\n\\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\\nExplanation: \\nGiven: a / b = 2.0, b / c = 3.0\\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]"
                    },
                    {
                        "username": "ajak6",
                        "content": "in example \\n[a,b] = 2\\n[b,c] =3\\n\\nif query is a/a why should the answer be 1 \\nand if query is x/x then answer will be -1\\n\\nThis is very confusing although very easy to fix but wondering how to explain this to interviewer?"
                    },
                    {
                        "username": "yllipolly",
                        "content": "You should ask in the interview whether or not they want -1 or 1 for that case. x, x is minus 1 since x is not defined in the equation list. Although I doubt they will care if you solve this and it outputs 1."
                    },
                    {
                        "username": "QinglongZeng",
                        "content": "After I submitted my code, I got a wrong answer with input as follows:\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\nIt claimed my output is [-1.00000,0.40000,5.00000,0.20000]. However, when I tested my code with the given input, the output is [3.75000,0.40000,5.00000,0.20000], which is correct. That's wierd."
                    },
                    {
                        "username": "charonme",
                        "content": "not weird at all: if you know a/b=1.5 and b/c=2.5 then you also can know a/c=(a/b)\\*(b/c)=(1.5)\\*(2.5)=3.75"
                    },
                    {
                        "username": "tqjustc_",
                        "content": "\\u8fd9\\u4e2a\\u662f\\u6211\\u5f97\\u5230\\u7684\\u62a5\\u9519\\u4fe1\\u606f\\u3002\\n\\nInput:\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\nOutput:\\n[6.00000,3.00000,-1.00000,1.00000,1.00000]\\nExpected:\\n[6.00000,3.00000,-1.00000,1.00000,-1.00000]\\n\\n\\u867d\\u7136\\u201cx\\u201d\\u4e0d\\u5728\\u4e4b\\u524d\\u7684given equation\\u91cc\\u9762\\uff0c\\u4f46\\u662f\\uff0c[\"x\", \"x\"]\\u7684\\u7ed3\\u679c\\u662f \\u4e00\\u5b9a\\u662f1\\uff0c\\u800c\\u4e0d\\u662f -1."
                    },
                    {
                        "username": "leetcancode",
                        "content": "`Few more test cases:`\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\n[3.0,4.0,5.0,6.0]\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\\n\\n[ [\"a\",\"b\"],[\"b\",\"c\"] ]\\n[2.0,3.0]\\n[ [\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"] ]\\n\\n[[\"a\",\"b\"]]\\n[0.5]\\n[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\n[[\"ab\",\"cd\"],[\"a\",\"c\"]]\\n[4.0,2.0]\\n[[\"b\",\"d\"]]\\n\\n[[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"b\"],[\"w\",\"x\"],[\"y\",\"x\"],[\"z\",\"x\"],[\"w\",\"d\"]]\\n[2.0,3.0,4.0,5.0,6.0,7.0,8.0]\\n[[\"a\",\"c\"],[\"b\",\"c\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"],[\"a\",\"z\"]]\\n\\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"a\",\"c\"]]\\n[2.0,3.0,6.0]\\n[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]"
                    }
                ]
            },
            {
                "id": 2052082,
                "content": [
                    {
                        "username": "leetcancode",
                        "content": "Not a medium one! :)"
                    },
                    {
                        "username": "SeineAle",
                        "content": "just a basic bfs/dfs question.\\ndo not overthink.\\n"
                    },
                    {
                        "username": "wolfhound115",
                        "content": "I was so confused in the first example why \"a / a = ?\" gives the correct value of 1 but \"x / x = ?\" gives a correct value of -1. \\nHow was it getting the edge of \"a\" to \"a\" in my solution if I know I didn\\'t actually add the \"dividing by itself\" case to the dict?\\n\\nTurns out it\\'s going a -> b and then b -> a by the inverse so the case was handled, just slightly less efficiently haha"
                    },
                    {
                        "username": "psionl0",
                        "content": "For the variables given, we are guaranteed that there will be no division by zero error but we don\\'t know that this is the case for the unknown variables. That is why x / x must return -1. I implemented my solution using graph traversal. But that means that the first variable will be marked as \"visited\" so we can\\'t return to it. So I had to treat a / a as an edge case."
                    },
                    {
                        "username": "bruh50",
                        "content": "terribly written"
                    },
                    {
                        "username": "hhik1996",
                        "content": "overthink the problem as I suppose \"ab\" == \"ba\", what a waste of time :("
                    },
                    {
                        "username": "psionl0",
                        "content": "It doesn\\'t."
                    },
                    {
                        "username": "krobzh",
                        "content": "Not difficult for thinking since it is a common graph problem, but a bit tedious when implementing."
                    },
                    {
                        "username": "darianco",
                        "content": "Skip"
                    },
                    {
                        "username": "Prashant3010",
                        "content": "class Solution {\\npublic:\\ntypedef pair<int,double>ipair;\\ntypedef double ll;\\nbool dfs(int node,int target,vector<vector<ipair>>adj,ll ans,vector<int>&vis){\\n    if(node==target)return 1;\\n    vis[node]=1;\\n    for(auto it:adj[node]){\\n        \\n        ll child=it.first;\\n        ll wt=it.second;\\n        if(vis[child])continue;\\n        ans*=wt;\\n        if(dfs(child,target,adj,ans,vis))return 1;\\n    }\\n    return 0;\\n}\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        int m=equations.size();\\n        vector<vector<ipair>>adj(m);\\n        map<string,int>mp;\\n        int node=0;\\n       \\n        for(int i=0;i<m;i++){\\n            string s1=\"\";\\n            string s2=\"\";\\n            int n=equations[i].size();\\n            for(int j=0;j<n;j++){\\n                if(j==0)s1=equations[i][j];\\n                else s2=equations[i][j];\\n                \\n            \\n                \\n                    if(mp.find(equations[i][j])==mp.end()){\\n                    \\n                    mp[equations[i][j]]=node;\\n                    node++;\\n                    cout<<node<<endl;\\n                    }\\n                \\n            }\\n            if(values[i]!=0.0){\\n            adj[mp[s1]].push_back({mp[s2],values[i]});\\n            adj[mp[s2]].push_back({mp[s1],1.0/(values[i])});\\n            }\\n        }\\n        vector<ll>val;\\n\\n        for(auto it:queries){\\n            ll start=mp[it[0]];\\n            ll target=mp[it[1]];\\n            ll ans=1.00000;\\n            vector<int>vis(2*node,0);\\n          \\n            if(dfs(start,target,adj,ans,vis)) val.push_back(ans);\\n           \\n           else val.push_back(-1.00000);\\n    \\n        }\\n        return val;\\n    }\\n};      This code gives runtime error if I comment the line node++ runtime error is gone why"
                    },
                    {
                        "username": "who_rules",
                        "content": "solution is not very difficult, but a lot of code and corner cases... I think it\\'s a medium, but closer to a hard"
                    },
                    {
                        "username": "yudonglin",
                        "content": "This is a medium problem for sure, but I would recommend you to work on \"1466. Reorder Routes to Make All Paths Lead to the City Zero\" first and then come back. The fundamental idea is very similar. This question is extremely hard to figure out without knowing the fundamental."
                    }
                ]
            },
            {
                "id": 2042853,
                "content": [
                    {
                        "username": "leetcancode",
                        "content": "Not a medium one! :)"
                    },
                    {
                        "username": "SeineAle",
                        "content": "just a basic bfs/dfs question.\\ndo not overthink.\\n"
                    },
                    {
                        "username": "wolfhound115",
                        "content": "I was so confused in the first example why \"a / a = ?\" gives the correct value of 1 but \"x / x = ?\" gives a correct value of -1. \\nHow was it getting the edge of \"a\" to \"a\" in my solution if I know I didn\\'t actually add the \"dividing by itself\" case to the dict?\\n\\nTurns out it\\'s going a -> b and then b -> a by the inverse so the case was handled, just slightly less efficiently haha"
                    },
                    {
                        "username": "psionl0",
                        "content": "For the variables given, we are guaranteed that there will be no division by zero error but we don\\'t know that this is the case for the unknown variables. That is why x / x must return -1. I implemented my solution using graph traversal. But that means that the first variable will be marked as \"visited\" so we can\\'t return to it. So I had to treat a / a as an edge case."
                    },
                    {
                        "username": "bruh50",
                        "content": "terribly written"
                    },
                    {
                        "username": "hhik1996",
                        "content": "overthink the problem as I suppose \"ab\" == \"ba\", what a waste of time :("
                    },
                    {
                        "username": "psionl0",
                        "content": "It doesn\\'t."
                    },
                    {
                        "username": "krobzh",
                        "content": "Not difficult for thinking since it is a common graph problem, but a bit tedious when implementing."
                    },
                    {
                        "username": "darianco",
                        "content": "Skip"
                    },
                    {
                        "username": "Prashant3010",
                        "content": "class Solution {\\npublic:\\ntypedef pair<int,double>ipair;\\ntypedef double ll;\\nbool dfs(int node,int target,vector<vector<ipair>>adj,ll ans,vector<int>&vis){\\n    if(node==target)return 1;\\n    vis[node]=1;\\n    for(auto it:adj[node]){\\n        \\n        ll child=it.first;\\n        ll wt=it.second;\\n        if(vis[child])continue;\\n        ans*=wt;\\n        if(dfs(child,target,adj,ans,vis))return 1;\\n    }\\n    return 0;\\n}\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        int m=equations.size();\\n        vector<vector<ipair>>adj(m);\\n        map<string,int>mp;\\n        int node=0;\\n       \\n        for(int i=0;i<m;i++){\\n            string s1=\"\";\\n            string s2=\"\";\\n            int n=equations[i].size();\\n            for(int j=0;j<n;j++){\\n                if(j==0)s1=equations[i][j];\\n                else s2=equations[i][j];\\n                \\n            \\n                \\n                    if(mp.find(equations[i][j])==mp.end()){\\n                    \\n                    mp[equations[i][j]]=node;\\n                    node++;\\n                    cout<<node<<endl;\\n                    }\\n                \\n            }\\n            if(values[i]!=0.0){\\n            adj[mp[s1]].push_back({mp[s2],values[i]});\\n            adj[mp[s2]].push_back({mp[s1],1.0/(values[i])});\\n            }\\n        }\\n        vector<ll>val;\\n\\n        for(auto it:queries){\\n            ll start=mp[it[0]];\\n            ll target=mp[it[1]];\\n            ll ans=1.00000;\\n            vector<int>vis(2*node,0);\\n          \\n            if(dfs(start,target,adj,ans,vis)) val.push_back(ans);\\n           \\n           else val.push_back(-1.00000);\\n    \\n        }\\n        return val;\\n    }\\n};      This code gives runtime error if I comment the line node++ runtime error is gone why"
                    },
                    {
                        "username": "who_rules",
                        "content": "solution is not very difficult, but a lot of code and corner cases... I think it\\'s a medium, but closer to a hard"
                    },
                    {
                        "username": "yudonglin",
                        "content": "This is a medium problem for sure, but I would recommend you to work on \"1466. Reorder Routes to Make All Paths Lead to the City Zero\" first and then come back. The fundamental idea is very similar. This question is extremely hard to figure out without knowing the fundamental."
                    }
                ]
            },
            {
                "id": 2033768,
                "content": [
                    {
                        "username": "leetcancode",
                        "content": "Not a medium one! :)"
                    },
                    {
                        "username": "SeineAle",
                        "content": "just a basic bfs/dfs question.\\ndo not overthink.\\n"
                    },
                    {
                        "username": "wolfhound115",
                        "content": "I was so confused in the first example why \"a / a = ?\" gives the correct value of 1 but \"x / x = ?\" gives a correct value of -1. \\nHow was it getting the edge of \"a\" to \"a\" in my solution if I know I didn\\'t actually add the \"dividing by itself\" case to the dict?\\n\\nTurns out it\\'s going a -> b and then b -> a by the inverse so the case was handled, just slightly less efficiently haha"
                    },
                    {
                        "username": "psionl0",
                        "content": "For the variables given, we are guaranteed that there will be no division by zero error but we don\\'t know that this is the case for the unknown variables. That is why x / x must return -1. I implemented my solution using graph traversal. But that means that the first variable will be marked as \"visited\" so we can\\'t return to it. So I had to treat a / a as an edge case."
                    },
                    {
                        "username": "bruh50",
                        "content": "terribly written"
                    },
                    {
                        "username": "hhik1996",
                        "content": "overthink the problem as I suppose \"ab\" == \"ba\", what a waste of time :("
                    },
                    {
                        "username": "psionl0",
                        "content": "It doesn\\'t."
                    },
                    {
                        "username": "krobzh",
                        "content": "Not difficult for thinking since it is a common graph problem, but a bit tedious when implementing."
                    },
                    {
                        "username": "darianco",
                        "content": "Skip"
                    },
                    {
                        "username": "Prashant3010",
                        "content": "class Solution {\\npublic:\\ntypedef pair<int,double>ipair;\\ntypedef double ll;\\nbool dfs(int node,int target,vector<vector<ipair>>adj,ll ans,vector<int>&vis){\\n    if(node==target)return 1;\\n    vis[node]=1;\\n    for(auto it:adj[node]){\\n        \\n        ll child=it.first;\\n        ll wt=it.second;\\n        if(vis[child])continue;\\n        ans*=wt;\\n        if(dfs(child,target,adj,ans,vis))return 1;\\n    }\\n    return 0;\\n}\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        int m=equations.size();\\n        vector<vector<ipair>>adj(m);\\n        map<string,int>mp;\\n        int node=0;\\n       \\n        for(int i=0;i<m;i++){\\n            string s1=\"\";\\n            string s2=\"\";\\n            int n=equations[i].size();\\n            for(int j=0;j<n;j++){\\n                if(j==0)s1=equations[i][j];\\n                else s2=equations[i][j];\\n                \\n            \\n                \\n                    if(mp.find(equations[i][j])==mp.end()){\\n                    \\n                    mp[equations[i][j]]=node;\\n                    node++;\\n                    cout<<node<<endl;\\n                    }\\n                \\n            }\\n            if(values[i]!=0.0){\\n            adj[mp[s1]].push_back({mp[s2],values[i]});\\n            adj[mp[s2]].push_back({mp[s1],1.0/(values[i])});\\n            }\\n        }\\n        vector<ll>val;\\n\\n        for(auto it:queries){\\n            ll start=mp[it[0]];\\n            ll target=mp[it[1]];\\n            ll ans=1.00000;\\n            vector<int>vis(2*node,0);\\n          \\n            if(dfs(start,target,adj,ans,vis)) val.push_back(ans);\\n           \\n           else val.push_back(-1.00000);\\n    \\n        }\\n        return val;\\n    }\\n};      This code gives runtime error if I comment the line node++ runtime error is gone why"
                    },
                    {
                        "username": "who_rules",
                        "content": "solution is not very difficult, but a lot of code and corner cases... I think it\\'s a medium, but closer to a hard"
                    },
                    {
                        "username": "yudonglin",
                        "content": "This is a medium problem for sure, but I would recommend you to work on \"1466. Reorder Routes to Make All Paths Lead to the City Zero\" first and then come back. The fundamental idea is very similar. This question is extremely hard to figure out without knowing the fundamental."
                    }
                ]
            },
            {
                "id": 2023295,
                "content": [
                    {
                        "username": "leetcancode",
                        "content": "Not a medium one! :)"
                    },
                    {
                        "username": "SeineAle",
                        "content": "just a basic bfs/dfs question.\\ndo not overthink.\\n"
                    },
                    {
                        "username": "wolfhound115",
                        "content": "I was so confused in the first example why \"a / a = ?\" gives the correct value of 1 but \"x / x = ?\" gives a correct value of -1. \\nHow was it getting the edge of \"a\" to \"a\" in my solution if I know I didn\\'t actually add the \"dividing by itself\" case to the dict?\\n\\nTurns out it\\'s going a -> b and then b -> a by the inverse so the case was handled, just slightly less efficiently haha"
                    },
                    {
                        "username": "psionl0",
                        "content": "For the variables given, we are guaranteed that there will be no division by zero error but we don\\'t know that this is the case for the unknown variables. That is why x / x must return -1. I implemented my solution using graph traversal. But that means that the first variable will be marked as \"visited\" so we can\\'t return to it. So I had to treat a / a as an edge case."
                    },
                    {
                        "username": "bruh50",
                        "content": "terribly written"
                    },
                    {
                        "username": "hhik1996",
                        "content": "overthink the problem as I suppose \"ab\" == \"ba\", what a waste of time :("
                    },
                    {
                        "username": "psionl0",
                        "content": "It doesn\\'t."
                    },
                    {
                        "username": "krobzh",
                        "content": "Not difficult for thinking since it is a common graph problem, but a bit tedious when implementing."
                    },
                    {
                        "username": "darianco",
                        "content": "Skip"
                    },
                    {
                        "username": "Prashant3010",
                        "content": "class Solution {\\npublic:\\ntypedef pair<int,double>ipair;\\ntypedef double ll;\\nbool dfs(int node,int target,vector<vector<ipair>>adj,ll ans,vector<int>&vis){\\n    if(node==target)return 1;\\n    vis[node]=1;\\n    for(auto it:adj[node]){\\n        \\n        ll child=it.first;\\n        ll wt=it.second;\\n        if(vis[child])continue;\\n        ans*=wt;\\n        if(dfs(child,target,adj,ans,vis))return 1;\\n    }\\n    return 0;\\n}\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        int m=equations.size();\\n        vector<vector<ipair>>adj(m);\\n        map<string,int>mp;\\n        int node=0;\\n       \\n        for(int i=0;i<m;i++){\\n            string s1=\"\";\\n            string s2=\"\";\\n            int n=equations[i].size();\\n            for(int j=0;j<n;j++){\\n                if(j==0)s1=equations[i][j];\\n                else s2=equations[i][j];\\n                \\n            \\n                \\n                    if(mp.find(equations[i][j])==mp.end()){\\n                    \\n                    mp[equations[i][j]]=node;\\n                    node++;\\n                    cout<<node<<endl;\\n                    }\\n                \\n            }\\n            if(values[i]!=0.0){\\n            adj[mp[s1]].push_back({mp[s2],values[i]});\\n            adj[mp[s2]].push_back({mp[s1],1.0/(values[i])});\\n            }\\n        }\\n        vector<ll>val;\\n\\n        for(auto it:queries){\\n            ll start=mp[it[0]];\\n            ll target=mp[it[1]];\\n            ll ans=1.00000;\\n            vector<int>vis(2*node,0);\\n          \\n            if(dfs(start,target,adj,ans,vis)) val.push_back(ans);\\n           \\n           else val.push_back(-1.00000);\\n    \\n        }\\n        return val;\\n    }\\n};      This code gives runtime error if I comment the line node++ runtime error is gone why"
                    },
                    {
                        "username": "who_rules",
                        "content": "solution is not very difficult, but a lot of code and corner cases... I think it\\'s a medium, but closer to a hard"
                    },
                    {
                        "username": "yudonglin",
                        "content": "This is a medium problem for sure, but I would recommend you to work on \"1466. Reorder Routes to Make All Paths Lead to the City Zero\" first and then come back. The fundamental idea is very similar. This question is extremely hard to figure out without knowing the fundamental."
                    }
                ]
            },
            {
                "id": 2016158,
                "content": [
                    {
                        "username": "leetcancode",
                        "content": "Not a medium one! :)"
                    },
                    {
                        "username": "SeineAle",
                        "content": "just a basic bfs/dfs question.\\ndo not overthink.\\n"
                    },
                    {
                        "username": "wolfhound115",
                        "content": "I was so confused in the first example why \"a / a = ?\" gives the correct value of 1 but \"x / x = ?\" gives a correct value of -1. \\nHow was it getting the edge of \"a\" to \"a\" in my solution if I know I didn\\'t actually add the \"dividing by itself\" case to the dict?\\n\\nTurns out it\\'s going a -> b and then b -> a by the inverse so the case was handled, just slightly less efficiently haha"
                    },
                    {
                        "username": "psionl0",
                        "content": "For the variables given, we are guaranteed that there will be no division by zero error but we don\\'t know that this is the case for the unknown variables. That is why x / x must return -1. I implemented my solution using graph traversal. But that means that the first variable will be marked as \"visited\" so we can\\'t return to it. So I had to treat a / a as an edge case."
                    },
                    {
                        "username": "bruh50",
                        "content": "terribly written"
                    },
                    {
                        "username": "hhik1996",
                        "content": "overthink the problem as I suppose \"ab\" == \"ba\", what a waste of time :("
                    },
                    {
                        "username": "psionl0",
                        "content": "It doesn\\'t."
                    },
                    {
                        "username": "krobzh",
                        "content": "Not difficult for thinking since it is a common graph problem, but a bit tedious when implementing."
                    },
                    {
                        "username": "darianco",
                        "content": "Skip"
                    },
                    {
                        "username": "Prashant3010",
                        "content": "class Solution {\\npublic:\\ntypedef pair<int,double>ipair;\\ntypedef double ll;\\nbool dfs(int node,int target,vector<vector<ipair>>adj,ll ans,vector<int>&vis){\\n    if(node==target)return 1;\\n    vis[node]=1;\\n    for(auto it:adj[node]){\\n        \\n        ll child=it.first;\\n        ll wt=it.second;\\n        if(vis[child])continue;\\n        ans*=wt;\\n        if(dfs(child,target,adj,ans,vis))return 1;\\n    }\\n    return 0;\\n}\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        int m=equations.size();\\n        vector<vector<ipair>>adj(m);\\n        map<string,int>mp;\\n        int node=0;\\n       \\n        for(int i=0;i<m;i++){\\n            string s1=\"\";\\n            string s2=\"\";\\n            int n=equations[i].size();\\n            for(int j=0;j<n;j++){\\n                if(j==0)s1=equations[i][j];\\n                else s2=equations[i][j];\\n                \\n            \\n                \\n                    if(mp.find(equations[i][j])==mp.end()){\\n                    \\n                    mp[equations[i][j]]=node;\\n                    node++;\\n                    cout<<node<<endl;\\n                    }\\n                \\n            }\\n            if(values[i]!=0.0){\\n            adj[mp[s1]].push_back({mp[s2],values[i]});\\n            adj[mp[s2]].push_back({mp[s1],1.0/(values[i])});\\n            }\\n        }\\n        vector<ll>val;\\n\\n        for(auto it:queries){\\n            ll start=mp[it[0]];\\n            ll target=mp[it[1]];\\n            ll ans=1.00000;\\n            vector<int>vis(2*node,0);\\n          \\n            if(dfs(start,target,adj,ans,vis)) val.push_back(ans);\\n           \\n           else val.push_back(-1.00000);\\n    \\n        }\\n        return val;\\n    }\\n};      This code gives runtime error if I comment the line node++ runtime error is gone why"
                    },
                    {
                        "username": "who_rules",
                        "content": "solution is not very difficult, but a lot of code and corner cases... I think it\\'s a medium, but closer to a hard"
                    },
                    {
                        "username": "yudonglin",
                        "content": "This is a medium problem for sure, but I would recommend you to work on \"1466. Reorder Routes to Make All Paths Lead to the City Zero\" first and then come back. The fundamental idea is very similar. This question is extremely hard to figure out without knowing the fundamental."
                    }
                ]
            },
            {
                "id": 2013920,
                "content": [
                    {
                        "username": "leetcancode",
                        "content": "Not a medium one! :)"
                    },
                    {
                        "username": "SeineAle",
                        "content": "just a basic bfs/dfs question.\\ndo not overthink.\\n"
                    },
                    {
                        "username": "wolfhound115",
                        "content": "I was so confused in the first example why \"a / a = ?\" gives the correct value of 1 but \"x / x = ?\" gives a correct value of -1. \\nHow was it getting the edge of \"a\" to \"a\" in my solution if I know I didn\\'t actually add the \"dividing by itself\" case to the dict?\\n\\nTurns out it\\'s going a -> b and then b -> a by the inverse so the case was handled, just slightly less efficiently haha"
                    },
                    {
                        "username": "psionl0",
                        "content": "For the variables given, we are guaranteed that there will be no division by zero error but we don\\'t know that this is the case for the unknown variables. That is why x / x must return -1. I implemented my solution using graph traversal. But that means that the first variable will be marked as \"visited\" so we can\\'t return to it. So I had to treat a / a as an edge case."
                    },
                    {
                        "username": "bruh50",
                        "content": "terribly written"
                    },
                    {
                        "username": "hhik1996",
                        "content": "overthink the problem as I suppose \"ab\" == \"ba\", what a waste of time :("
                    },
                    {
                        "username": "psionl0",
                        "content": "It doesn\\'t."
                    },
                    {
                        "username": "krobzh",
                        "content": "Not difficult for thinking since it is a common graph problem, but a bit tedious when implementing."
                    },
                    {
                        "username": "darianco",
                        "content": "Skip"
                    },
                    {
                        "username": "Prashant3010",
                        "content": "class Solution {\\npublic:\\ntypedef pair<int,double>ipair;\\ntypedef double ll;\\nbool dfs(int node,int target,vector<vector<ipair>>adj,ll ans,vector<int>&vis){\\n    if(node==target)return 1;\\n    vis[node]=1;\\n    for(auto it:adj[node]){\\n        \\n        ll child=it.first;\\n        ll wt=it.second;\\n        if(vis[child])continue;\\n        ans*=wt;\\n        if(dfs(child,target,adj,ans,vis))return 1;\\n    }\\n    return 0;\\n}\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        int m=equations.size();\\n        vector<vector<ipair>>adj(m);\\n        map<string,int>mp;\\n        int node=0;\\n       \\n        for(int i=0;i<m;i++){\\n            string s1=\"\";\\n            string s2=\"\";\\n            int n=equations[i].size();\\n            for(int j=0;j<n;j++){\\n                if(j==0)s1=equations[i][j];\\n                else s2=equations[i][j];\\n                \\n            \\n                \\n                    if(mp.find(equations[i][j])==mp.end()){\\n                    \\n                    mp[equations[i][j]]=node;\\n                    node++;\\n                    cout<<node<<endl;\\n                    }\\n                \\n            }\\n            if(values[i]!=0.0){\\n            adj[mp[s1]].push_back({mp[s2],values[i]});\\n            adj[mp[s2]].push_back({mp[s1],1.0/(values[i])});\\n            }\\n        }\\n        vector<ll>val;\\n\\n        for(auto it:queries){\\n            ll start=mp[it[0]];\\n            ll target=mp[it[1]];\\n            ll ans=1.00000;\\n            vector<int>vis(2*node,0);\\n          \\n            if(dfs(start,target,adj,ans,vis)) val.push_back(ans);\\n           \\n           else val.push_back(-1.00000);\\n    \\n        }\\n        return val;\\n    }\\n};      This code gives runtime error if I comment the line node++ runtime error is gone why"
                    },
                    {
                        "username": "who_rules",
                        "content": "solution is not very difficult, but a lot of code and corner cases... I think it\\'s a medium, but closer to a hard"
                    },
                    {
                        "username": "yudonglin",
                        "content": "This is a medium problem for sure, but I would recommend you to work on \"1466. Reorder Routes to Make All Paths Lead to the City Zero\" first and then come back. The fundamental idea is very similar. This question is extremely hard to figure out without knowing the fundamental."
                    }
                ]
            },
            {
                "id": 2010652,
                "content": [
                    {
                        "username": "leetcancode",
                        "content": "Not a medium one! :)"
                    },
                    {
                        "username": "SeineAle",
                        "content": "just a basic bfs/dfs question.\\ndo not overthink.\\n"
                    },
                    {
                        "username": "wolfhound115",
                        "content": "I was so confused in the first example why \"a / a = ?\" gives the correct value of 1 but \"x / x = ?\" gives a correct value of -1. \\nHow was it getting the edge of \"a\" to \"a\" in my solution if I know I didn\\'t actually add the \"dividing by itself\" case to the dict?\\n\\nTurns out it\\'s going a -> b and then b -> a by the inverse so the case was handled, just slightly less efficiently haha"
                    },
                    {
                        "username": "psionl0",
                        "content": "For the variables given, we are guaranteed that there will be no division by zero error but we don\\'t know that this is the case for the unknown variables. That is why x / x must return -1. I implemented my solution using graph traversal. But that means that the first variable will be marked as \"visited\" so we can\\'t return to it. So I had to treat a / a as an edge case."
                    },
                    {
                        "username": "bruh50",
                        "content": "terribly written"
                    },
                    {
                        "username": "hhik1996",
                        "content": "overthink the problem as I suppose \"ab\" == \"ba\", what a waste of time :("
                    },
                    {
                        "username": "psionl0",
                        "content": "It doesn\\'t."
                    },
                    {
                        "username": "krobzh",
                        "content": "Not difficult for thinking since it is a common graph problem, but a bit tedious when implementing."
                    },
                    {
                        "username": "darianco",
                        "content": "Skip"
                    },
                    {
                        "username": "Prashant3010",
                        "content": "class Solution {\\npublic:\\ntypedef pair<int,double>ipair;\\ntypedef double ll;\\nbool dfs(int node,int target,vector<vector<ipair>>adj,ll ans,vector<int>&vis){\\n    if(node==target)return 1;\\n    vis[node]=1;\\n    for(auto it:adj[node]){\\n        \\n        ll child=it.first;\\n        ll wt=it.second;\\n        if(vis[child])continue;\\n        ans*=wt;\\n        if(dfs(child,target,adj,ans,vis))return 1;\\n    }\\n    return 0;\\n}\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        int m=equations.size();\\n        vector<vector<ipair>>adj(m);\\n        map<string,int>mp;\\n        int node=0;\\n       \\n        for(int i=0;i<m;i++){\\n            string s1=\"\";\\n            string s2=\"\";\\n            int n=equations[i].size();\\n            for(int j=0;j<n;j++){\\n                if(j==0)s1=equations[i][j];\\n                else s2=equations[i][j];\\n                \\n            \\n                \\n                    if(mp.find(equations[i][j])==mp.end()){\\n                    \\n                    mp[equations[i][j]]=node;\\n                    node++;\\n                    cout<<node<<endl;\\n                    }\\n                \\n            }\\n            if(values[i]!=0.0){\\n            adj[mp[s1]].push_back({mp[s2],values[i]});\\n            adj[mp[s2]].push_back({mp[s1],1.0/(values[i])});\\n            }\\n        }\\n        vector<ll>val;\\n\\n        for(auto it:queries){\\n            ll start=mp[it[0]];\\n            ll target=mp[it[1]];\\n            ll ans=1.00000;\\n            vector<int>vis(2*node,0);\\n          \\n            if(dfs(start,target,adj,ans,vis)) val.push_back(ans);\\n           \\n           else val.push_back(-1.00000);\\n    \\n        }\\n        return val;\\n    }\\n};      This code gives runtime error if I comment the line node++ runtime error is gone why"
                    },
                    {
                        "username": "who_rules",
                        "content": "solution is not very difficult, but a lot of code and corner cases... I think it\\'s a medium, but closer to a hard"
                    },
                    {
                        "username": "yudonglin",
                        "content": "This is a medium problem for sure, but I would recommend you to work on \"1466. Reorder Routes to Make All Paths Lead to the City Zero\" first and then come back. The fundamental idea is very similar. This question is extremely hard to figure out without knowing the fundamental."
                    }
                ]
            },
            {
                "id": 1991473,
                "content": [
                    {
                        "username": "leetcancode",
                        "content": "Not a medium one! :)"
                    },
                    {
                        "username": "SeineAle",
                        "content": "just a basic bfs/dfs question.\\ndo not overthink.\\n"
                    },
                    {
                        "username": "wolfhound115",
                        "content": "I was so confused in the first example why \"a / a = ?\" gives the correct value of 1 but \"x / x = ?\" gives a correct value of -1. \\nHow was it getting the edge of \"a\" to \"a\" in my solution if I know I didn\\'t actually add the \"dividing by itself\" case to the dict?\\n\\nTurns out it\\'s going a -> b and then b -> a by the inverse so the case was handled, just slightly less efficiently haha"
                    },
                    {
                        "username": "psionl0",
                        "content": "For the variables given, we are guaranteed that there will be no division by zero error but we don\\'t know that this is the case for the unknown variables. That is why x / x must return -1. I implemented my solution using graph traversal. But that means that the first variable will be marked as \"visited\" so we can\\'t return to it. So I had to treat a / a as an edge case."
                    },
                    {
                        "username": "bruh50",
                        "content": "terribly written"
                    },
                    {
                        "username": "hhik1996",
                        "content": "overthink the problem as I suppose \"ab\" == \"ba\", what a waste of time :("
                    },
                    {
                        "username": "psionl0",
                        "content": "It doesn\\'t."
                    },
                    {
                        "username": "krobzh",
                        "content": "Not difficult for thinking since it is a common graph problem, but a bit tedious when implementing."
                    },
                    {
                        "username": "darianco",
                        "content": "Skip"
                    },
                    {
                        "username": "Prashant3010",
                        "content": "class Solution {\\npublic:\\ntypedef pair<int,double>ipair;\\ntypedef double ll;\\nbool dfs(int node,int target,vector<vector<ipair>>adj,ll ans,vector<int>&vis){\\n    if(node==target)return 1;\\n    vis[node]=1;\\n    for(auto it:adj[node]){\\n        \\n        ll child=it.first;\\n        ll wt=it.second;\\n        if(vis[child])continue;\\n        ans*=wt;\\n        if(dfs(child,target,adj,ans,vis))return 1;\\n    }\\n    return 0;\\n}\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        int m=equations.size();\\n        vector<vector<ipair>>adj(m);\\n        map<string,int>mp;\\n        int node=0;\\n       \\n        for(int i=0;i<m;i++){\\n            string s1=\"\";\\n            string s2=\"\";\\n            int n=equations[i].size();\\n            for(int j=0;j<n;j++){\\n                if(j==0)s1=equations[i][j];\\n                else s2=equations[i][j];\\n                \\n            \\n                \\n                    if(mp.find(equations[i][j])==mp.end()){\\n                    \\n                    mp[equations[i][j]]=node;\\n                    node++;\\n                    cout<<node<<endl;\\n                    }\\n                \\n            }\\n            if(values[i]!=0.0){\\n            adj[mp[s1]].push_back({mp[s2],values[i]});\\n            adj[mp[s2]].push_back({mp[s1],1.0/(values[i])});\\n            }\\n        }\\n        vector<ll>val;\\n\\n        for(auto it:queries){\\n            ll start=mp[it[0]];\\n            ll target=mp[it[1]];\\n            ll ans=1.00000;\\n            vector<int>vis(2*node,0);\\n          \\n            if(dfs(start,target,adj,ans,vis)) val.push_back(ans);\\n           \\n           else val.push_back(-1.00000);\\n    \\n        }\\n        return val;\\n    }\\n};      This code gives runtime error if I comment the line node++ runtime error is gone why"
                    },
                    {
                        "username": "who_rules",
                        "content": "solution is not very difficult, but a lot of code and corner cases... I think it\\'s a medium, but closer to a hard"
                    },
                    {
                        "username": "yudonglin",
                        "content": "This is a medium problem for sure, but I would recommend you to work on \"1466. Reorder Routes to Make All Paths Lead to the City Zero\" first and then come back. The fundamental idea is very similar. This question is extremely hard to figure out without knowing the fundamental."
                    }
                ]
            },
            {
                "id": 1970430,
                "content": [
                    {
                        "username": "leetcancode",
                        "content": "Not a medium one! :)"
                    },
                    {
                        "username": "SeineAle",
                        "content": "just a basic bfs/dfs question.\\ndo not overthink.\\n"
                    },
                    {
                        "username": "wolfhound115",
                        "content": "I was so confused in the first example why \"a / a = ?\" gives the correct value of 1 but \"x / x = ?\" gives a correct value of -1. \\nHow was it getting the edge of \"a\" to \"a\" in my solution if I know I didn\\'t actually add the \"dividing by itself\" case to the dict?\\n\\nTurns out it\\'s going a -> b and then b -> a by the inverse so the case was handled, just slightly less efficiently haha"
                    },
                    {
                        "username": "psionl0",
                        "content": "For the variables given, we are guaranteed that there will be no division by zero error but we don\\'t know that this is the case for the unknown variables. That is why x / x must return -1. I implemented my solution using graph traversal. But that means that the first variable will be marked as \"visited\" so we can\\'t return to it. So I had to treat a / a as an edge case."
                    },
                    {
                        "username": "bruh50",
                        "content": "terribly written"
                    },
                    {
                        "username": "hhik1996",
                        "content": "overthink the problem as I suppose \"ab\" == \"ba\", what a waste of time :("
                    },
                    {
                        "username": "psionl0",
                        "content": "It doesn\\'t."
                    },
                    {
                        "username": "krobzh",
                        "content": "Not difficult for thinking since it is a common graph problem, but a bit tedious when implementing."
                    },
                    {
                        "username": "darianco",
                        "content": "Skip"
                    },
                    {
                        "username": "Prashant3010",
                        "content": "class Solution {\\npublic:\\ntypedef pair<int,double>ipair;\\ntypedef double ll;\\nbool dfs(int node,int target,vector<vector<ipair>>adj,ll ans,vector<int>&vis){\\n    if(node==target)return 1;\\n    vis[node]=1;\\n    for(auto it:adj[node]){\\n        \\n        ll child=it.first;\\n        ll wt=it.second;\\n        if(vis[child])continue;\\n        ans*=wt;\\n        if(dfs(child,target,adj,ans,vis))return 1;\\n    }\\n    return 0;\\n}\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        int m=equations.size();\\n        vector<vector<ipair>>adj(m);\\n        map<string,int>mp;\\n        int node=0;\\n       \\n        for(int i=0;i<m;i++){\\n            string s1=\"\";\\n            string s2=\"\";\\n            int n=equations[i].size();\\n            for(int j=0;j<n;j++){\\n                if(j==0)s1=equations[i][j];\\n                else s2=equations[i][j];\\n                \\n            \\n                \\n                    if(mp.find(equations[i][j])==mp.end()){\\n                    \\n                    mp[equations[i][j]]=node;\\n                    node++;\\n                    cout<<node<<endl;\\n                    }\\n                \\n            }\\n            if(values[i]!=0.0){\\n            adj[mp[s1]].push_back({mp[s2],values[i]});\\n            adj[mp[s2]].push_back({mp[s1],1.0/(values[i])});\\n            }\\n        }\\n        vector<ll>val;\\n\\n        for(auto it:queries){\\n            ll start=mp[it[0]];\\n            ll target=mp[it[1]];\\n            ll ans=1.00000;\\n            vector<int>vis(2*node,0);\\n          \\n            if(dfs(start,target,adj,ans,vis)) val.push_back(ans);\\n           \\n           else val.push_back(-1.00000);\\n    \\n        }\\n        return val;\\n    }\\n};      This code gives runtime error if I comment the line node++ runtime error is gone why"
                    },
                    {
                        "username": "who_rules",
                        "content": "solution is not very difficult, but a lot of code and corner cases... I think it\\'s a medium, but closer to a hard"
                    },
                    {
                        "username": "yudonglin",
                        "content": "This is a medium problem for sure, but I would recommend you to work on \"1466. Reorder Routes to Make All Paths Lead to the City Zero\" first and then come back. The fundamental idea is very similar. This question is extremely hard to figure out without knowing the fundamental."
                    }
                ]
            },
            {
                "id": 1953880,
                "content": [
                    {
                        "username": "leetcancode",
                        "content": "Not a medium one! :)"
                    },
                    {
                        "username": "SeineAle",
                        "content": "just a basic bfs/dfs question.\\ndo not overthink.\\n"
                    },
                    {
                        "username": "wolfhound115",
                        "content": "I was so confused in the first example why \"a / a = ?\" gives the correct value of 1 but \"x / x = ?\" gives a correct value of -1. \\nHow was it getting the edge of \"a\" to \"a\" in my solution if I know I didn\\'t actually add the \"dividing by itself\" case to the dict?\\n\\nTurns out it\\'s going a -> b and then b -> a by the inverse so the case was handled, just slightly less efficiently haha"
                    },
                    {
                        "username": "psionl0",
                        "content": "For the variables given, we are guaranteed that there will be no division by zero error but we don\\'t know that this is the case for the unknown variables. That is why x / x must return -1. I implemented my solution using graph traversal. But that means that the first variable will be marked as \"visited\" so we can\\'t return to it. So I had to treat a / a as an edge case."
                    },
                    {
                        "username": "bruh50",
                        "content": "terribly written"
                    },
                    {
                        "username": "hhik1996",
                        "content": "overthink the problem as I suppose \"ab\" == \"ba\", what a waste of time :("
                    },
                    {
                        "username": "psionl0",
                        "content": "It doesn\\'t."
                    },
                    {
                        "username": "krobzh",
                        "content": "Not difficult for thinking since it is a common graph problem, but a bit tedious when implementing."
                    },
                    {
                        "username": "darianco",
                        "content": "Skip"
                    },
                    {
                        "username": "Prashant3010",
                        "content": "class Solution {\\npublic:\\ntypedef pair<int,double>ipair;\\ntypedef double ll;\\nbool dfs(int node,int target,vector<vector<ipair>>adj,ll ans,vector<int>&vis){\\n    if(node==target)return 1;\\n    vis[node]=1;\\n    for(auto it:adj[node]){\\n        \\n        ll child=it.first;\\n        ll wt=it.second;\\n        if(vis[child])continue;\\n        ans*=wt;\\n        if(dfs(child,target,adj,ans,vis))return 1;\\n    }\\n    return 0;\\n}\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        int m=equations.size();\\n        vector<vector<ipair>>adj(m);\\n        map<string,int>mp;\\n        int node=0;\\n       \\n        for(int i=0;i<m;i++){\\n            string s1=\"\";\\n            string s2=\"\";\\n            int n=equations[i].size();\\n            for(int j=0;j<n;j++){\\n                if(j==0)s1=equations[i][j];\\n                else s2=equations[i][j];\\n                \\n            \\n                \\n                    if(mp.find(equations[i][j])==mp.end()){\\n                    \\n                    mp[equations[i][j]]=node;\\n                    node++;\\n                    cout<<node<<endl;\\n                    }\\n                \\n            }\\n            if(values[i]!=0.0){\\n            adj[mp[s1]].push_back({mp[s2],values[i]});\\n            adj[mp[s2]].push_back({mp[s1],1.0/(values[i])});\\n            }\\n        }\\n        vector<ll>val;\\n\\n        for(auto it:queries){\\n            ll start=mp[it[0]];\\n            ll target=mp[it[1]];\\n            ll ans=1.00000;\\n            vector<int>vis(2*node,0);\\n          \\n            if(dfs(start,target,adj,ans,vis)) val.push_back(ans);\\n           \\n           else val.push_back(-1.00000);\\n    \\n        }\\n        return val;\\n    }\\n};      This code gives runtime error if I comment the line node++ runtime error is gone why"
                    },
                    {
                        "username": "who_rules",
                        "content": "solution is not very difficult, but a lot of code and corner cases... I think it\\'s a medium, but closer to a hard"
                    },
                    {
                        "username": "yudonglin",
                        "content": "This is a medium problem for sure, but I would recommend you to work on \"1466. Reorder Routes to Make All Paths Lead to the City Zero\" first and then come back. The fundamental idea is very similar. This question is extremely hard to figure out without knowing the fundamental."
                    }
                ]
            },
            {
                "id": 1951677,
                "content": [
                    {
                        "username": "rahul_singaria",
                        "content": "why BFS gives TLE?"
                    },
                    {
                        "username": "Willthedrill",
                        "content": "I think that the problem should add a statement staing that \"bc\" is a single variable and it is NOT  `b*c` otherwise the problem becomes much harder..."
                    },
                    {
                        "username": "alexvaiman",
                        "content": "but it is... \"Each Ai or Bi is a string that represents a single variable.\""
                    },
                    {
                        "username": "alexvaiman",
                        "content": "Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\\nfor every x, if x!=0 x\\xA0/ x =1 in my opinion you algorithm and test cases are wrong"
                    },
                    {
                        "username": "gm-too-nice",
                        "content": "this is one of those leetcode problems where its helpful that they tell you the idea of how to solve (ex: here create a graph using the given information) but then its better to try to come up with own solutions as opposed to trying to understand leetcode\\'s solution"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nSIMPLE AND SUPER CLEAN CODE || EASY || COMMENTS\\nankush920\\n1\\n0\\na minute ago\\nC++\\nIntuition\\nusing DFS by converting string of equation in bidirected graph\\n\\nApproach\\nfor each query using DFS for each query\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\nm = length of query vector\\nn =string in expression\\n\\nSpace complexity:\\n0(n) // for making graph\\n// for visited node in dfs\\n\\nCode\\n\\n//-------------------------------Are you ready for this---------------------------------------------//\\nclass Solution {\\npublic:\\n\\n\\n//-------------------------------dfs------------------------------------------------//\\nvoid dfs( string start  ,string end , unordered_map<string , int >&visited , unordered_map<string, unordered_map<string,double> >&graph , double &ans , double temp ){\\n     if(end ==start){\\n          ans = temp ;\\n          return;\\n     }\\n\\n     if(visited.count(start)){\\n           return; \\n     }\\n    \\n    visited[start]++; \\n\\n\\n    for(auto neighbour : graph[start]){\\n            dfs( neighbour.first,end, visited , graph , ans ,temp* neighbour.second);\\n    }\\n      return ;\\n}\\n//-------------------------------main function----------------------------------------//\\n    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& val, vector<vector<string>>& que) {\\n       int len = eq.size();\\n       int n = que.size();\\n        vector<double>answer; \\n  //------------------------------------make graph--------------------------------------------------//\\n  unordered_map< string , unordered_map<string , double> > graph;\\n\\n  for(int i =0 ; i<len ;i++){\\n        string first = eq[i][0];\\n        string second = eq[i][1];\\n         graph[first][second] = val[i];  //-->N/D\\n       graph[second][first] = (1.0/val[i]); //--> D/N\\n  }\\n\\n//-----------------------------------------next step-------------------------------------------------//\\n    for( int i = 0; i<n; i++){\\n   unordered_map<string , int>visited;\\n   double ans  =-1 ;   // que[i] --> final answer store\\n\\n   if(!graph.count(que[i][0]) || !graph.count(que[i][1])){    //if variable not exist in graph \\n          answer.push_back(-1);  \\n          continue;\\n   }\\n  dfs(que[i][0] ,que[i][1], visited , graph , ans ,1);   /// function call   \\n answer.push_back(ans);  \\n    }\\n\\n  return answer;           \\n    }\\n};"
                    },
                    {
                        "username": "an5dy90",
                        "content": "what is the purpose of providing [\"bc\",\"cd\"] and then query [\"bc\",\"cd\"] instead of [\"b\",\"d\"]? I was stuck in thinking how to remove the common factor but realized the solution treats \"bc\" or \"cd\" as new vertice.  "
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we handle query variables of multiple length? for e.g. bc / cd? I have some approaches in my head (using set and collections.retainAll etc) but that seems too complicated for a medium problem. Any ideas?"
                    },
                    {
                        "username": "judgementdey",
                        "content": "In such cases you treat `bc` as a single variable name, and not think of it as `b` and `c` separately. Store variable names as `string`, not `char`."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "how the fuck is this is a medium question it took me 2hrs to guess graph approach and then solve it completely!!!\\nHere\\'s how I solved it:\\npair<bool,double>Look(string a,string b,map<string,bool>&M,map<string,vector<pair<string,double> > >&m)\\n    {\\n        M[a]=true;\\n        for(auto p:m[a])\\n        {\\n            if(M[p.first] == true)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                M[p.first]=true;\\n            }\\n            //cout<<\"| \";\\n            if(p.first == b)\\n            {\\n                //cout<<\"1 \";\\n                return {true,p.second};\\n            }\\n            else\\n            {\\n                //cout<<\"2 \";\\n                pair<bool,double>k=Look(p.first,b,M,m);\\n                if(k.first == true)\\n                {\\n                    return {true,(k.second)*(p.second)};\\n                }\\n            }\\n        }\\n        return {false,-1};\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=equations.size();\\n        map<string,bool>N;\\n        for(int i=0;i<n;i++)\\n        {\\n            N[equations[i][0]]=true;\\n            N[equations[i][1]]=true;\\n        }\\n        map<string,vector<pair<string,double> > >m;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            string a=equations[i][0];\\n            string b=equations[i][1];\\n\\n            double value=values[i];\\n\\n            m[a].push_back({b,value});\\n            m[b].push_back({a,1/value});\\n        }\\n        vector<double>res;\\n        for(auto p:queries)\\n        {\\n            string a=p[0];\\n            string b=p[1];\\n            if(N.find(a) == N.end() and N.find(b) == N.end())\\n            {\\n                res.push_back(-1);continue;\\n            }\\n            if(a == b)\\n            {\\n                res.push_back(1);\\n                continue;\\n            }\\n            map<string,bool>M;\\n            for(auto p:N)\\n            {\\n                M[p.first]=false;\\n            }\\n            pair<bool,double>k=Look(a,b,M,m);\\n            //cout<<k.second<<\" \";\\n            if(k.first == false)\\n            {\\n                res.push_back(-1);\\n            }\\n            else\\n            {\\n                res.push_back(k.second);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "BimanDas",
                        "content": "It is an easy problem but became harder when I thought in more difficult way :\na/b = 2,    c/d = 3.      ac/bd = ?\nThough in this case result is -1.0 but I thought it will give the answer 6."
                    },
                    {
                        "username": "jaehee",
                        "content": "If we have `equations = [[\"a\", \"b\"], [\"c\", \"d\"]], values = [2.0, 3.0], queries = [[\"ac\", \"bd\"]]`, shouldn\\'t the output be `[6.0]` not `[-1.0]`? Did I miss any constraints?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "\"ac\" does not means a * c. Its an independent variable. Same for \"bd\".\\nThese variables are unknown as they are not mentioned in equations.\\n\\nHence we get -1 for that.\\n\\nHope that helps."
                    }
                ]
            },
            {
                "id": 1932911,
                "content": [
                    {
                        "username": "rahul_singaria",
                        "content": "why BFS gives TLE?"
                    },
                    {
                        "username": "Willthedrill",
                        "content": "I think that the problem should add a statement staing that \"bc\" is a single variable and it is NOT  `b*c` otherwise the problem becomes much harder..."
                    },
                    {
                        "username": "alexvaiman",
                        "content": "but it is... \"Each Ai or Bi is a string that represents a single variable.\""
                    },
                    {
                        "username": "alexvaiman",
                        "content": "Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\\nfor every x, if x!=0 x\\xA0/ x =1 in my opinion you algorithm and test cases are wrong"
                    },
                    {
                        "username": "gm-too-nice",
                        "content": "this is one of those leetcode problems where its helpful that they tell you the idea of how to solve (ex: here create a graph using the given information) but then its better to try to come up with own solutions as opposed to trying to understand leetcode\\'s solution"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nSIMPLE AND SUPER CLEAN CODE || EASY || COMMENTS\\nankush920\\n1\\n0\\na minute ago\\nC++\\nIntuition\\nusing DFS by converting string of equation in bidirected graph\\n\\nApproach\\nfor each query using DFS for each query\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\nm = length of query vector\\nn =string in expression\\n\\nSpace complexity:\\n0(n) // for making graph\\n// for visited node in dfs\\n\\nCode\\n\\n//-------------------------------Are you ready for this---------------------------------------------//\\nclass Solution {\\npublic:\\n\\n\\n//-------------------------------dfs------------------------------------------------//\\nvoid dfs( string start  ,string end , unordered_map<string , int >&visited , unordered_map<string, unordered_map<string,double> >&graph , double &ans , double temp ){\\n     if(end ==start){\\n          ans = temp ;\\n          return;\\n     }\\n\\n     if(visited.count(start)){\\n           return; \\n     }\\n    \\n    visited[start]++; \\n\\n\\n    for(auto neighbour : graph[start]){\\n            dfs( neighbour.first,end, visited , graph , ans ,temp* neighbour.second);\\n    }\\n      return ;\\n}\\n//-------------------------------main function----------------------------------------//\\n    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& val, vector<vector<string>>& que) {\\n       int len = eq.size();\\n       int n = que.size();\\n        vector<double>answer; \\n  //------------------------------------make graph--------------------------------------------------//\\n  unordered_map< string , unordered_map<string , double> > graph;\\n\\n  for(int i =0 ; i<len ;i++){\\n        string first = eq[i][0];\\n        string second = eq[i][1];\\n         graph[first][second] = val[i];  //-->N/D\\n       graph[second][first] = (1.0/val[i]); //--> D/N\\n  }\\n\\n//-----------------------------------------next step-------------------------------------------------//\\n    for( int i = 0; i<n; i++){\\n   unordered_map<string , int>visited;\\n   double ans  =-1 ;   // que[i] --> final answer store\\n\\n   if(!graph.count(que[i][0]) || !graph.count(que[i][1])){    //if variable not exist in graph \\n          answer.push_back(-1);  \\n          continue;\\n   }\\n  dfs(que[i][0] ,que[i][1], visited , graph , ans ,1);   /// function call   \\n answer.push_back(ans);  \\n    }\\n\\n  return answer;           \\n    }\\n};"
                    },
                    {
                        "username": "an5dy90",
                        "content": "what is the purpose of providing [\"bc\",\"cd\"] and then query [\"bc\",\"cd\"] instead of [\"b\",\"d\"]? I was stuck in thinking how to remove the common factor but realized the solution treats \"bc\" or \"cd\" as new vertice.  "
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we handle query variables of multiple length? for e.g. bc / cd? I have some approaches in my head (using set and collections.retainAll etc) but that seems too complicated for a medium problem. Any ideas?"
                    },
                    {
                        "username": "judgementdey",
                        "content": "In such cases you treat `bc` as a single variable name, and not think of it as `b` and `c` separately. Store variable names as `string`, not `char`."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "how the fuck is this is a medium question it took me 2hrs to guess graph approach and then solve it completely!!!\\nHere\\'s how I solved it:\\npair<bool,double>Look(string a,string b,map<string,bool>&M,map<string,vector<pair<string,double> > >&m)\\n    {\\n        M[a]=true;\\n        for(auto p:m[a])\\n        {\\n            if(M[p.first] == true)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                M[p.first]=true;\\n            }\\n            //cout<<\"| \";\\n            if(p.first == b)\\n            {\\n                //cout<<\"1 \";\\n                return {true,p.second};\\n            }\\n            else\\n            {\\n                //cout<<\"2 \";\\n                pair<bool,double>k=Look(p.first,b,M,m);\\n                if(k.first == true)\\n                {\\n                    return {true,(k.second)*(p.second)};\\n                }\\n            }\\n        }\\n        return {false,-1};\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=equations.size();\\n        map<string,bool>N;\\n        for(int i=0;i<n;i++)\\n        {\\n            N[equations[i][0]]=true;\\n            N[equations[i][1]]=true;\\n        }\\n        map<string,vector<pair<string,double> > >m;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            string a=equations[i][0];\\n            string b=equations[i][1];\\n\\n            double value=values[i];\\n\\n            m[a].push_back({b,value});\\n            m[b].push_back({a,1/value});\\n        }\\n        vector<double>res;\\n        for(auto p:queries)\\n        {\\n            string a=p[0];\\n            string b=p[1];\\n            if(N.find(a) == N.end() and N.find(b) == N.end())\\n            {\\n                res.push_back(-1);continue;\\n            }\\n            if(a == b)\\n            {\\n                res.push_back(1);\\n                continue;\\n            }\\n            map<string,bool>M;\\n            for(auto p:N)\\n            {\\n                M[p.first]=false;\\n            }\\n            pair<bool,double>k=Look(a,b,M,m);\\n            //cout<<k.second<<\" \";\\n            if(k.first == false)\\n            {\\n                res.push_back(-1);\\n            }\\n            else\\n            {\\n                res.push_back(k.second);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "BimanDas",
                        "content": "It is an easy problem but became harder when I thought in more difficult way :\na/b = 2,    c/d = 3.      ac/bd = ?\nThough in this case result is -1.0 but I thought it will give the answer 6."
                    },
                    {
                        "username": "jaehee",
                        "content": "If we have `equations = [[\"a\", \"b\"], [\"c\", \"d\"]], values = [2.0, 3.0], queries = [[\"ac\", \"bd\"]]`, shouldn\\'t the output be `[6.0]` not `[-1.0]`? Did I miss any constraints?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "\"ac\" does not means a * c. Its an independent variable. Same for \"bd\".\\nThese variables are unknown as they are not mentioned in equations.\\n\\nHence we get -1 for that.\\n\\nHope that helps."
                    }
                ]
            },
            {
                "id": 1932534,
                "content": [
                    {
                        "username": "rahul_singaria",
                        "content": "why BFS gives TLE?"
                    },
                    {
                        "username": "Willthedrill",
                        "content": "I think that the problem should add a statement staing that \"bc\" is a single variable and it is NOT  `b*c` otherwise the problem becomes much harder..."
                    },
                    {
                        "username": "alexvaiman",
                        "content": "but it is... \"Each Ai or Bi is a string that represents a single variable.\""
                    },
                    {
                        "username": "alexvaiman",
                        "content": "Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\\nfor every x, if x!=0 x\\xA0/ x =1 in my opinion you algorithm and test cases are wrong"
                    },
                    {
                        "username": "gm-too-nice",
                        "content": "this is one of those leetcode problems where its helpful that they tell you the idea of how to solve (ex: here create a graph using the given information) but then its better to try to come up with own solutions as opposed to trying to understand leetcode\\'s solution"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nSIMPLE AND SUPER CLEAN CODE || EASY || COMMENTS\\nankush920\\n1\\n0\\na minute ago\\nC++\\nIntuition\\nusing DFS by converting string of equation in bidirected graph\\n\\nApproach\\nfor each query using DFS for each query\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\nm = length of query vector\\nn =string in expression\\n\\nSpace complexity:\\n0(n) // for making graph\\n// for visited node in dfs\\n\\nCode\\n\\n//-------------------------------Are you ready for this---------------------------------------------//\\nclass Solution {\\npublic:\\n\\n\\n//-------------------------------dfs------------------------------------------------//\\nvoid dfs( string start  ,string end , unordered_map<string , int >&visited , unordered_map<string, unordered_map<string,double> >&graph , double &ans , double temp ){\\n     if(end ==start){\\n          ans = temp ;\\n          return;\\n     }\\n\\n     if(visited.count(start)){\\n           return; \\n     }\\n    \\n    visited[start]++; \\n\\n\\n    for(auto neighbour : graph[start]){\\n            dfs( neighbour.first,end, visited , graph , ans ,temp* neighbour.second);\\n    }\\n      return ;\\n}\\n//-------------------------------main function----------------------------------------//\\n    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& val, vector<vector<string>>& que) {\\n       int len = eq.size();\\n       int n = que.size();\\n        vector<double>answer; \\n  //------------------------------------make graph--------------------------------------------------//\\n  unordered_map< string , unordered_map<string , double> > graph;\\n\\n  for(int i =0 ; i<len ;i++){\\n        string first = eq[i][0];\\n        string second = eq[i][1];\\n         graph[first][second] = val[i];  //-->N/D\\n       graph[second][first] = (1.0/val[i]); //--> D/N\\n  }\\n\\n//-----------------------------------------next step-------------------------------------------------//\\n    for( int i = 0; i<n; i++){\\n   unordered_map<string , int>visited;\\n   double ans  =-1 ;   // que[i] --> final answer store\\n\\n   if(!graph.count(que[i][0]) || !graph.count(que[i][1])){    //if variable not exist in graph \\n          answer.push_back(-1);  \\n          continue;\\n   }\\n  dfs(que[i][0] ,que[i][1], visited , graph , ans ,1);   /// function call   \\n answer.push_back(ans);  \\n    }\\n\\n  return answer;           \\n    }\\n};"
                    },
                    {
                        "username": "an5dy90",
                        "content": "what is the purpose of providing [\"bc\",\"cd\"] and then query [\"bc\",\"cd\"] instead of [\"b\",\"d\"]? I was stuck in thinking how to remove the common factor but realized the solution treats \"bc\" or \"cd\" as new vertice.  "
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we handle query variables of multiple length? for e.g. bc / cd? I have some approaches in my head (using set and collections.retainAll etc) but that seems too complicated for a medium problem. Any ideas?"
                    },
                    {
                        "username": "judgementdey",
                        "content": "In such cases you treat `bc` as a single variable name, and not think of it as `b` and `c` separately. Store variable names as `string`, not `char`."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "how the fuck is this is a medium question it took me 2hrs to guess graph approach and then solve it completely!!!\\nHere\\'s how I solved it:\\npair<bool,double>Look(string a,string b,map<string,bool>&M,map<string,vector<pair<string,double> > >&m)\\n    {\\n        M[a]=true;\\n        for(auto p:m[a])\\n        {\\n            if(M[p.first] == true)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                M[p.first]=true;\\n            }\\n            //cout<<\"| \";\\n            if(p.first == b)\\n            {\\n                //cout<<\"1 \";\\n                return {true,p.second};\\n            }\\n            else\\n            {\\n                //cout<<\"2 \";\\n                pair<bool,double>k=Look(p.first,b,M,m);\\n                if(k.first == true)\\n                {\\n                    return {true,(k.second)*(p.second)};\\n                }\\n            }\\n        }\\n        return {false,-1};\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=equations.size();\\n        map<string,bool>N;\\n        for(int i=0;i<n;i++)\\n        {\\n            N[equations[i][0]]=true;\\n            N[equations[i][1]]=true;\\n        }\\n        map<string,vector<pair<string,double> > >m;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            string a=equations[i][0];\\n            string b=equations[i][1];\\n\\n            double value=values[i];\\n\\n            m[a].push_back({b,value});\\n            m[b].push_back({a,1/value});\\n        }\\n        vector<double>res;\\n        for(auto p:queries)\\n        {\\n            string a=p[0];\\n            string b=p[1];\\n            if(N.find(a) == N.end() and N.find(b) == N.end())\\n            {\\n                res.push_back(-1);continue;\\n            }\\n            if(a == b)\\n            {\\n                res.push_back(1);\\n                continue;\\n            }\\n            map<string,bool>M;\\n            for(auto p:N)\\n            {\\n                M[p.first]=false;\\n            }\\n            pair<bool,double>k=Look(a,b,M,m);\\n            //cout<<k.second<<\" \";\\n            if(k.first == false)\\n            {\\n                res.push_back(-1);\\n            }\\n            else\\n            {\\n                res.push_back(k.second);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "BimanDas",
                        "content": "It is an easy problem but became harder when I thought in more difficult way :\na/b = 2,    c/d = 3.      ac/bd = ?\nThough in this case result is -1.0 but I thought it will give the answer 6."
                    },
                    {
                        "username": "jaehee",
                        "content": "If we have `equations = [[\"a\", \"b\"], [\"c\", \"d\"]], values = [2.0, 3.0], queries = [[\"ac\", \"bd\"]]`, shouldn\\'t the output be `[6.0]` not `[-1.0]`? Did I miss any constraints?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "\"ac\" does not means a * c. Its an independent variable. Same for \"bd\".\\nThese variables are unknown as they are not mentioned in equations.\\n\\nHence we get -1 for that.\\n\\nHope that helps."
                    }
                ]
            },
            {
                "id": 1932086,
                "content": [
                    {
                        "username": "rahul_singaria",
                        "content": "why BFS gives TLE?"
                    },
                    {
                        "username": "Willthedrill",
                        "content": "I think that the problem should add a statement staing that \"bc\" is a single variable and it is NOT  `b*c` otherwise the problem becomes much harder..."
                    },
                    {
                        "username": "alexvaiman",
                        "content": "but it is... \"Each Ai or Bi is a string that represents a single variable.\""
                    },
                    {
                        "username": "alexvaiman",
                        "content": "Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\\nfor every x, if x!=0 x\\xA0/ x =1 in my opinion you algorithm and test cases are wrong"
                    },
                    {
                        "username": "gm-too-nice",
                        "content": "this is one of those leetcode problems where its helpful that they tell you the idea of how to solve (ex: here create a graph using the given information) but then its better to try to come up with own solutions as opposed to trying to understand leetcode\\'s solution"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nSIMPLE AND SUPER CLEAN CODE || EASY || COMMENTS\\nankush920\\n1\\n0\\na minute ago\\nC++\\nIntuition\\nusing DFS by converting string of equation in bidirected graph\\n\\nApproach\\nfor each query using DFS for each query\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\nm = length of query vector\\nn =string in expression\\n\\nSpace complexity:\\n0(n) // for making graph\\n// for visited node in dfs\\n\\nCode\\n\\n//-------------------------------Are you ready for this---------------------------------------------//\\nclass Solution {\\npublic:\\n\\n\\n//-------------------------------dfs------------------------------------------------//\\nvoid dfs( string start  ,string end , unordered_map<string , int >&visited , unordered_map<string, unordered_map<string,double> >&graph , double &ans , double temp ){\\n     if(end ==start){\\n          ans = temp ;\\n          return;\\n     }\\n\\n     if(visited.count(start)){\\n           return; \\n     }\\n    \\n    visited[start]++; \\n\\n\\n    for(auto neighbour : graph[start]){\\n            dfs( neighbour.first,end, visited , graph , ans ,temp* neighbour.second);\\n    }\\n      return ;\\n}\\n//-------------------------------main function----------------------------------------//\\n    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& val, vector<vector<string>>& que) {\\n       int len = eq.size();\\n       int n = que.size();\\n        vector<double>answer; \\n  //------------------------------------make graph--------------------------------------------------//\\n  unordered_map< string , unordered_map<string , double> > graph;\\n\\n  for(int i =0 ; i<len ;i++){\\n        string first = eq[i][0];\\n        string second = eq[i][1];\\n         graph[first][second] = val[i];  //-->N/D\\n       graph[second][first] = (1.0/val[i]); //--> D/N\\n  }\\n\\n//-----------------------------------------next step-------------------------------------------------//\\n    for( int i = 0; i<n; i++){\\n   unordered_map<string , int>visited;\\n   double ans  =-1 ;   // que[i] --> final answer store\\n\\n   if(!graph.count(que[i][0]) || !graph.count(que[i][1])){    //if variable not exist in graph \\n          answer.push_back(-1);  \\n          continue;\\n   }\\n  dfs(que[i][0] ,que[i][1], visited , graph , ans ,1);   /// function call   \\n answer.push_back(ans);  \\n    }\\n\\n  return answer;           \\n    }\\n};"
                    },
                    {
                        "username": "an5dy90",
                        "content": "what is the purpose of providing [\"bc\",\"cd\"] and then query [\"bc\",\"cd\"] instead of [\"b\",\"d\"]? I was stuck in thinking how to remove the common factor but realized the solution treats \"bc\" or \"cd\" as new vertice.  "
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we handle query variables of multiple length? for e.g. bc / cd? I have some approaches in my head (using set and collections.retainAll etc) but that seems too complicated for a medium problem. Any ideas?"
                    },
                    {
                        "username": "judgementdey",
                        "content": "In such cases you treat `bc` as a single variable name, and not think of it as `b` and `c` separately. Store variable names as `string`, not `char`."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "how the fuck is this is a medium question it took me 2hrs to guess graph approach and then solve it completely!!!\\nHere\\'s how I solved it:\\npair<bool,double>Look(string a,string b,map<string,bool>&M,map<string,vector<pair<string,double> > >&m)\\n    {\\n        M[a]=true;\\n        for(auto p:m[a])\\n        {\\n            if(M[p.first] == true)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                M[p.first]=true;\\n            }\\n            //cout<<\"| \";\\n            if(p.first == b)\\n            {\\n                //cout<<\"1 \";\\n                return {true,p.second};\\n            }\\n            else\\n            {\\n                //cout<<\"2 \";\\n                pair<bool,double>k=Look(p.first,b,M,m);\\n                if(k.first == true)\\n                {\\n                    return {true,(k.second)*(p.second)};\\n                }\\n            }\\n        }\\n        return {false,-1};\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=equations.size();\\n        map<string,bool>N;\\n        for(int i=0;i<n;i++)\\n        {\\n            N[equations[i][0]]=true;\\n            N[equations[i][1]]=true;\\n        }\\n        map<string,vector<pair<string,double> > >m;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            string a=equations[i][0];\\n            string b=equations[i][1];\\n\\n            double value=values[i];\\n\\n            m[a].push_back({b,value});\\n            m[b].push_back({a,1/value});\\n        }\\n        vector<double>res;\\n        for(auto p:queries)\\n        {\\n            string a=p[0];\\n            string b=p[1];\\n            if(N.find(a) == N.end() and N.find(b) == N.end())\\n            {\\n                res.push_back(-1);continue;\\n            }\\n            if(a == b)\\n            {\\n                res.push_back(1);\\n                continue;\\n            }\\n            map<string,bool>M;\\n            for(auto p:N)\\n            {\\n                M[p.first]=false;\\n            }\\n            pair<bool,double>k=Look(a,b,M,m);\\n            //cout<<k.second<<\" \";\\n            if(k.first == false)\\n            {\\n                res.push_back(-1);\\n            }\\n            else\\n            {\\n                res.push_back(k.second);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "BimanDas",
                        "content": "It is an easy problem but became harder when I thought in more difficult way :\na/b = 2,    c/d = 3.      ac/bd = ?\nThough in this case result is -1.0 but I thought it will give the answer 6."
                    },
                    {
                        "username": "jaehee",
                        "content": "If we have `equations = [[\"a\", \"b\"], [\"c\", \"d\"]], values = [2.0, 3.0], queries = [[\"ac\", \"bd\"]]`, shouldn\\'t the output be `[6.0]` not `[-1.0]`? Did I miss any constraints?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "\"ac\" does not means a * c. Its an independent variable. Same for \"bd\".\\nThese variables are unknown as they are not mentioned in equations.\\n\\nHence we get -1 for that.\\n\\nHope that helps."
                    }
                ]
            },
            {
                "id": 1931780,
                "content": [
                    {
                        "username": "rahul_singaria",
                        "content": "why BFS gives TLE?"
                    },
                    {
                        "username": "Willthedrill",
                        "content": "I think that the problem should add a statement staing that \"bc\" is a single variable and it is NOT  `b*c` otherwise the problem becomes much harder..."
                    },
                    {
                        "username": "alexvaiman",
                        "content": "but it is... \"Each Ai or Bi is a string that represents a single variable.\""
                    },
                    {
                        "username": "alexvaiman",
                        "content": "Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\\nfor every x, if x!=0 x\\xA0/ x =1 in my opinion you algorithm and test cases are wrong"
                    },
                    {
                        "username": "gm-too-nice",
                        "content": "this is one of those leetcode problems where its helpful that they tell you the idea of how to solve (ex: here create a graph using the given information) but then its better to try to come up with own solutions as opposed to trying to understand leetcode\\'s solution"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nSIMPLE AND SUPER CLEAN CODE || EASY || COMMENTS\\nankush920\\n1\\n0\\na minute ago\\nC++\\nIntuition\\nusing DFS by converting string of equation in bidirected graph\\n\\nApproach\\nfor each query using DFS for each query\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\nm = length of query vector\\nn =string in expression\\n\\nSpace complexity:\\n0(n) // for making graph\\n// for visited node in dfs\\n\\nCode\\n\\n//-------------------------------Are you ready for this---------------------------------------------//\\nclass Solution {\\npublic:\\n\\n\\n//-------------------------------dfs------------------------------------------------//\\nvoid dfs( string start  ,string end , unordered_map<string , int >&visited , unordered_map<string, unordered_map<string,double> >&graph , double &ans , double temp ){\\n     if(end ==start){\\n          ans = temp ;\\n          return;\\n     }\\n\\n     if(visited.count(start)){\\n           return; \\n     }\\n    \\n    visited[start]++; \\n\\n\\n    for(auto neighbour : graph[start]){\\n            dfs( neighbour.first,end, visited , graph , ans ,temp* neighbour.second);\\n    }\\n      return ;\\n}\\n//-------------------------------main function----------------------------------------//\\n    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& val, vector<vector<string>>& que) {\\n       int len = eq.size();\\n       int n = que.size();\\n        vector<double>answer; \\n  //------------------------------------make graph--------------------------------------------------//\\n  unordered_map< string , unordered_map<string , double> > graph;\\n\\n  for(int i =0 ; i<len ;i++){\\n        string first = eq[i][0];\\n        string second = eq[i][1];\\n         graph[first][second] = val[i];  //-->N/D\\n       graph[second][first] = (1.0/val[i]); //--> D/N\\n  }\\n\\n//-----------------------------------------next step-------------------------------------------------//\\n    for( int i = 0; i<n; i++){\\n   unordered_map<string , int>visited;\\n   double ans  =-1 ;   // que[i] --> final answer store\\n\\n   if(!graph.count(que[i][0]) || !graph.count(que[i][1])){    //if variable not exist in graph \\n          answer.push_back(-1);  \\n          continue;\\n   }\\n  dfs(que[i][0] ,que[i][1], visited , graph , ans ,1);   /// function call   \\n answer.push_back(ans);  \\n    }\\n\\n  return answer;           \\n    }\\n};"
                    },
                    {
                        "username": "an5dy90",
                        "content": "what is the purpose of providing [\"bc\",\"cd\"] and then query [\"bc\",\"cd\"] instead of [\"b\",\"d\"]? I was stuck in thinking how to remove the common factor but realized the solution treats \"bc\" or \"cd\" as new vertice.  "
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we handle query variables of multiple length? for e.g. bc / cd? I have some approaches in my head (using set and collections.retainAll etc) but that seems too complicated for a medium problem. Any ideas?"
                    },
                    {
                        "username": "judgementdey",
                        "content": "In such cases you treat `bc` as a single variable name, and not think of it as `b` and `c` separately. Store variable names as `string`, not `char`."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "how the fuck is this is a medium question it took me 2hrs to guess graph approach and then solve it completely!!!\\nHere\\'s how I solved it:\\npair<bool,double>Look(string a,string b,map<string,bool>&M,map<string,vector<pair<string,double> > >&m)\\n    {\\n        M[a]=true;\\n        for(auto p:m[a])\\n        {\\n            if(M[p.first] == true)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                M[p.first]=true;\\n            }\\n            //cout<<\"| \";\\n            if(p.first == b)\\n            {\\n                //cout<<\"1 \";\\n                return {true,p.second};\\n            }\\n            else\\n            {\\n                //cout<<\"2 \";\\n                pair<bool,double>k=Look(p.first,b,M,m);\\n                if(k.first == true)\\n                {\\n                    return {true,(k.second)*(p.second)};\\n                }\\n            }\\n        }\\n        return {false,-1};\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=equations.size();\\n        map<string,bool>N;\\n        for(int i=0;i<n;i++)\\n        {\\n            N[equations[i][0]]=true;\\n            N[equations[i][1]]=true;\\n        }\\n        map<string,vector<pair<string,double> > >m;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            string a=equations[i][0];\\n            string b=equations[i][1];\\n\\n            double value=values[i];\\n\\n            m[a].push_back({b,value});\\n            m[b].push_back({a,1/value});\\n        }\\n        vector<double>res;\\n        for(auto p:queries)\\n        {\\n            string a=p[0];\\n            string b=p[1];\\n            if(N.find(a) == N.end() and N.find(b) == N.end())\\n            {\\n                res.push_back(-1);continue;\\n            }\\n            if(a == b)\\n            {\\n                res.push_back(1);\\n                continue;\\n            }\\n            map<string,bool>M;\\n            for(auto p:N)\\n            {\\n                M[p.first]=false;\\n            }\\n            pair<bool,double>k=Look(a,b,M,m);\\n            //cout<<k.second<<\" \";\\n            if(k.first == false)\\n            {\\n                res.push_back(-1);\\n            }\\n            else\\n            {\\n                res.push_back(k.second);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "BimanDas",
                        "content": "It is an easy problem but became harder when I thought in more difficult way :\na/b = 2,    c/d = 3.      ac/bd = ?\nThough in this case result is -1.0 but I thought it will give the answer 6."
                    },
                    {
                        "username": "jaehee",
                        "content": "If we have `equations = [[\"a\", \"b\"], [\"c\", \"d\"]], values = [2.0, 3.0], queries = [[\"ac\", \"bd\"]]`, shouldn\\'t the output be `[6.0]` not `[-1.0]`? Did I miss any constraints?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "\"ac\" does not means a * c. Its an independent variable. Same for \"bd\".\\nThese variables are unknown as they are not mentioned in equations.\\n\\nHence we get -1 for that.\\n\\nHope that helps."
                    }
                ]
            },
            {
                "id": 1907963,
                "content": [
                    {
                        "username": "rahul_singaria",
                        "content": "why BFS gives TLE?"
                    },
                    {
                        "username": "Willthedrill",
                        "content": "I think that the problem should add a statement staing that \"bc\" is a single variable and it is NOT  `b*c` otherwise the problem becomes much harder..."
                    },
                    {
                        "username": "alexvaiman",
                        "content": "but it is... \"Each Ai or Bi is a string that represents a single variable.\""
                    },
                    {
                        "username": "alexvaiman",
                        "content": "Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\\nfor every x, if x!=0 x\\xA0/ x =1 in my opinion you algorithm and test cases are wrong"
                    },
                    {
                        "username": "gm-too-nice",
                        "content": "this is one of those leetcode problems where its helpful that they tell you the idea of how to solve (ex: here create a graph using the given information) but then its better to try to come up with own solutions as opposed to trying to understand leetcode\\'s solution"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nSIMPLE AND SUPER CLEAN CODE || EASY || COMMENTS\\nankush920\\n1\\n0\\na minute ago\\nC++\\nIntuition\\nusing DFS by converting string of equation in bidirected graph\\n\\nApproach\\nfor each query using DFS for each query\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\nm = length of query vector\\nn =string in expression\\n\\nSpace complexity:\\n0(n) // for making graph\\n// for visited node in dfs\\n\\nCode\\n\\n//-------------------------------Are you ready for this---------------------------------------------//\\nclass Solution {\\npublic:\\n\\n\\n//-------------------------------dfs------------------------------------------------//\\nvoid dfs( string start  ,string end , unordered_map<string , int >&visited , unordered_map<string, unordered_map<string,double> >&graph , double &ans , double temp ){\\n     if(end ==start){\\n          ans = temp ;\\n          return;\\n     }\\n\\n     if(visited.count(start)){\\n           return; \\n     }\\n    \\n    visited[start]++; \\n\\n\\n    for(auto neighbour : graph[start]){\\n            dfs( neighbour.first,end, visited , graph , ans ,temp* neighbour.second);\\n    }\\n      return ;\\n}\\n//-------------------------------main function----------------------------------------//\\n    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& val, vector<vector<string>>& que) {\\n       int len = eq.size();\\n       int n = que.size();\\n        vector<double>answer; \\n  //------------------------------------make graph--------------------------------------------------//\\n  unordered_map< string , unordered_map<string , double> > graph;\\n\\n  for(int i =0 ; i<len ;i++){\\n        string first = eq[i][0];\\n        string second = eq[i][1];\\n         graph[first][second] = val[i];  //-->N/D\\n       graph[second][first] = (1.0/val[i]); //--> D/N\\n  }\\n\\n//-----------------------------------------next step-------------------------------------------------//\\n    for( int i = 0; i<n; i++){\\n   unordered_map<string , int>visited;\\n   double ans  =-1 ;   // que[i] --> final answer store\\n\\n   if(!graph.count(que[i][0]) || !graph.count(que[i][1])){    //if variable not exist in graph \\n          answer.push_back(-1);  \\n          continue;\\n   }\\n  dfs(que[i][0] ,que[i][1], visited , graph , ans ,1);   /// function call   \\n answer.push_back(ans);  \\n    }\\n\\n  return answer;           \\n    }\\n};"
                    },
                    {
                        "username": "an5dy90",
                        "content": "what is the purpose of providing [\"bc\",\"cd\"] and then query [\"bc\",\"cd\"] instead of [\"b\",\"d\"]? I was stuck in thinking how to remove the common factor but realized the solution treats \"bc\" or \"cd\" as new vertice.  "
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we handle query variables of multiple length? for e.g. bc / cd? I have some approaches in my head (using set and collections.retainAll etc) but that seems too complicated for a medium problem. Any ideas?"
                    },
                    {
                        "username": "judgementdey",
                        "content": "In such cases you treat `bc` as a single variable name, and not think of it as `b` and `c` separately. Store variable names as `string`, not `char`."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "how the fuck is this is a medium question it took me 2hrs to guess graph approach and then solve it completely!!!\\nHere\\'s how I solved it:\\npair<bool,double>Look(string a,string b,map<string,bool>&M,map<string,vector<pair<string,double> > >&m)\\n    {\\n        M[a]=true;\\n        for(auto p:m[a])\\n        {\\n            if(M[p.first] == true)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                M[p.first]=true;\\n            }\\n            //cout<<\"| \";\\n            if(p.first == b)\\n            {\\n                //cout<<\"1 \";\\n                return {true,p.second};\\n            }\\n            else\\n            {\\n                //cout<<\"2 \";\\n                pair<bool,double>k=Look(p.first,b,M,m);\\n                if(k.first == true)\\n                {\\n                    return {true,(k.second)*(p.second)};\\n                }\\n            }\\n        }\\n        return {false,-1};\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=equations.size();\\n        map<string,bool>N;\\n        for(int i=0;i<n;i++)\\n        {\\n            N[equations[i][0]]=true;\\n            N[equations[i][1]]=true;\\n        }\\n        map<string,vector<pair<string,double> > >m;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            string a=equations[i][0];\\n            string b=equations[i][1];\\n\\n            double value=values[i];\\n\\n            m[a].push_back({b,value});\\n            m[b].push_back({a,1/value});\\n        }\\n        vector<double>res;\\n        for(auto p:queries)\\n        {\\n            string a=p[0];\\n            string b=p[1];\\n            if(N.find(a) == N.end() and N.find(b) == N.end())\\n            {\\n                res.push_back(-1);continue;\\n            }\\n            if(a == b)\\n            {\\n                res.push_back(1);\\n                continue;\\n            }\\n            map<string,bool>M;\\n            for(auto p:N)\\n            {\\n                M[p.first]=false;\\n            }\\n            pair<bool,double>k=Look(a,b,M,m);\\n            //cout<<k.second<<\" \";\\n            if(k.first == false)\\n            {\\n                res.push_back(-1);\\n            }\\n            else\\n            {\\n                res.push_back(k.second);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "BimanDas",
                        "content": "It is an easy problem but became harder when I thought in more difficult way :\na/b = 2,    c/d = 3.      ac/bd = ?\nThough in this case result is -1.0 but I thought it will give the answer 6."
                    },
                    {
                        "username": "jaehee",
                        "content": "If we have `equations = [[\"a\", \"b\"], [\"c\", \"d\"]], values = [2.0, 3.0], queries = [[\"ac\", \"bd\"]]`, shouldn\\'t the output be `[6.0]` not `[-1.0]`? Did I miss any constraints?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "\"ac\" does not means a * c. Its an independent variable. Same for \"bd\".\\nThese variables are unknown as they are not mentioned in equations.\\n\\nHence we get -1 for that.\\n\\nHope that helps."
                    }
                ]
            },
            {
                "id": 1903232,
                "content": [
                    {
                        "username": "rahul_singaria",
                        "content": "why BFS gives TLE?"
                    },
                    {
                        "username": "Willthedrill",
                        "content": "I think that the problem should add a statement staing that \"bc\" is a single variable and it is NOT  `b*c` otherwise the problem becomes much harder..."
                    },
                    {
                        "username": "alexvaiman",
                        "content": "but it is... \"Each Ai or Bi is a string that represents a single variable.\""
                    },
                    {
                        "username": "alexvaiman",
                        "content": "Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\\nfor every x, if x!=0 x\\xA0/ x =1 in my opinion you algorithm and test cases are wrong"
                    },
                    {
                        "username": "gm-too-nice",
                        "content": "this is one of those leetcode problems where its helpful that they tell you the idea of how to solve (ex: here create a graph using the given information) but then its better to try to come up with own solutions as opposed to trying to understand leetcode\\'s solution"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nSIMPLE AND SUPER CLEAN CODE || EASY || COMMENTS\\nankush920\\n1\\n0\\na minute ago\\nC++\\nIntuition\\nusing DFS by converting string of equation in bidirected graph\\n\\nApproach\\nfor each query using DFS for each query\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\nm = length of query vector\\nn =string in expression\\n\\nSpace complexity:\\n0(n) // for making graph\\n// for visited node in dfs\\n\\nCode\\n\\n//-------------------------------Are you ready for this---------------------------------------------//\\nclass Solution {\\npublic:\\n\\n\\n//-------------------------------dfs------------------------------------------------//\\nvoid dfs( string start  ,string end , unordered_map<string , int >&visited , unordered_map<string, unordered_map<string,double> >&graph , double &ans , double temp ){\\n     if(end ==start){\\n          ans = temp ;\\n          return;\\n     }\\n\\n     if(visited.count(start)){\\n           return; \\n     }\\n    \\n    visited[start]++; \\n\\n\\n    for(auto neighbour : graph[start]){\\n            dfs( neighbour.first,end, visited , graph , ans ,temp* neighbour.second);\\n    }\\n      return ;\\n}\\n//-------------------------------main function----------------------------------------//\\n    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& val, vector<vector<string>>& que) {\\n       int len = eq.size();\\n       int n = que.size();\\n        vector<double>answer; \\n  //------------------------------------make graph--------------------------------------------------//\\n  unordered_map< string , unordered_map<string , double> > graph;\\n\\n  for(int i =0 ; i<len ;i++){\\n        string first = eq[i][0];\\n        string second = eq[i][1];\\n         graph[first][second] = val[i];  //-->N/D\\n       graph[second][first] = (1.0/val[i]); //--> D/N\\n  }\\n\\n//-----------------------------------------next step-------------------------------------------------//\\n    for( int i = 0; i<n; i++){\\n   unordered_map<string , int>visited;\\n   double ans  =-1 ;   // que[i] --> final answer store\\n\\n   if(!graph.count(que[i][0]) || !graph.count(que[i][1])){    //if variable not exist in graph \\n          answer.push_back(-1);  \\n          continue;\\n   }\\n  dfs(que[i][0] ,que[i][1], visited , graph , ans ,1);   /// function call   \\n answer.push_back(ans);  \\n    }\\n\\n  return answer;           \\n    }\\n};"
                    },
                    {
                        "username": "an5dy90",
                        "content": "what is the purpose of providing [\"bc\",\"cd\"] and then query [\"bc\",\"cd\"] instead of [\"b\",\"d\"]? I was stuck in thinking how to remove the common factor but realized the solution treats \"bc\" or \"cd\" as new vertice.  "
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we handle query variables of multiple length? for e.g. bc / cd? I have some approaches in my head (using set and collections.retainAll etc) but that seems too complicated for a medium problem. Any ideas?"
                    },
                    {
                        "username": "judgementdey",
                        "content": "In such cases you treat `bc` as a single variable name, and not think of it as `b` and `c` separately. Store variable names as `string`, not `char`."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "how the fuck is this is a medium question it took me 2hrs to guess graph approach and then solve it completely!!!\\nHere\\'s how I solved it:\\npair<bool,double>Look(string a,string b,map<string,bool>&M,map<string,vector<pair<string,double> > >&m)\\n    {\\n        M[a]=true;\\n        for(auto p:m[a])\\n        {\\n            if(M[p.first] == true)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                M[p.first]=true;\\n            }\\n            //cout<<\"| \";\\n            if(p.first == b)\\n            {\\n                //cout<<\"1 \";\\n                return {true,p.second};\\n            }\\n            else\\n            {\\n                //cout<<\"2 \";\\n                pair<bool,double>k=Look(p.first,b,M,m);\\n                if(k.first == true)\\n                {\\n                    return {true,(k.second)*(p.second)};\\n                }\\n            }\\n        }\\n        return {false,-1};\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=equations.size();\\n        map<string,bool>N;\\n        for(int i=0;i<n;i++)\\n        {\\n            N[equations[i][0]]=true;\\n            N[equations[i][1]]=true;\\n        }\\n        map<string,vector<pair<string,double> > >m;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            string a=equations[i][0];\\n            string b=equations[i][1];\\n\\n            double value=values[i];\\n\\n            m[a].push_back({b,value});\\n            m[b].push_back({a,1/value});\\n        }\\n        vector<double>res;\\n        for(auto p:queries)\\n        {\\n            string a=p[0];\\n            string b=p[1];\\n            if(N.find(a) == N.end() and N.find(b) == N.end())\\n            {\\n                res.push_back(-1);continue;\\n            }\\n            if(a == b)\\n            {\\n                res.push_back(1);\\n                continue;\\n            }\\n            map<string,bool>M;\\n            for(auto p:N)\\n            {\\n                M[p.first]=false;\\n            }\\n            pair<bool,double>k=Look(a,b,M,m);\\n            //cout<<k.second<<\" \";\\n            if(k.first == false)\\n            {\\n                res.push_back(-1);\\n            }\\n            else\\n            {\\n                res.push_back(k.second);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "BimanDas",
                        "content": "It is an easy problem but became harder when I thought in more difficult way :\na/b = 2,    c/d = 3.      ac/bd = ?\nThough in this case result is -1.0 but I thought it will give the answer 6."
                    },
                    {
                        "username": "jaehee",
                        "content": "If we have `equations = [[\"a\", \"b\"], [\"c\", \"d\"]], values = [2.0, 3.0], queries = [[\"ac\", \"bd\"]]`, shouldn\\'t the output be `[6.0]` not `[-1.0]`? Did I miss any constraints?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "\"ac\" does not means a * c. Its an independent variable. Same for \"bd\".\\nThese variables are unknown as they are not mentioned in equations.\\n\\nHence we get -1 for that.\\n\\nHope that helps."
                    }
                ]
            },
            {
                "id": 1900312,
                "content": [
                    {
                        "username": "rahul_singaria",
                        "content": "why BFS gives TLE?"
                    },
                    {
                        "username": "Willthedrill",
                        "content": "I think that the problem should add a statement staing that \"bc\" is a single variable and it is NOT  `b*c` otherwise the problem becomes much harder..."
                    },
                    {
                        "username": "alexvaiman",
                        "content": "but it is... \"Each Ai or Bi is a string that represents a single variable.\""
                    },
                    {
                        "username": "alexvaiman",
                        "content": "Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\\nfor every x, if x!=0 x\\xA0/ x =1 in my opinion you algorithm and test cases are wrong"
                    },
                    {
                        "username": "gm-too-nice",
                        "content": "this is one of those leetcode problems where its helpful that they tell you the idea of how to solve (ex: here create a graph using the given information) but then its better to try to come up with own solutions as opposed to trying to understand leetcode\\'s solution"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nSIMPLE AND SUPER CLEAN CODE || EASY || COMMENTS\\nankush920\\n1\\n0\\na minute ago\\nC++\\nIntuition\\nusing DFS by converting string of equation in bidirected graph\\n\\nApproach\\nfor each query using DFS for each query\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\nm = length of query vector\\nn =string in expression\\n\\nSpace complexity:\\n0(n) // for making graph\\n// for visited node in dfs\\n\\nCode\\n\\n//-------------------------------Are you ready for this---------------------------------------------//\\nclass Solution {\\npublic:\\n\\n\\n//-------------------------------dfs------------------------------------------------//\\nvoid dfs( string start  ,string end , unordered_map<string , int >&visited , unordered_map<string, unordered_map<string,double> >&graph , double &ans , double temp ){\\n     if(end ==start){\\n          ans = temp ;\\n          return;\\n     }\\n\\n     if(visited.count(start)){\\n           return; \\n     }\\n    \\n    visited[start]++; \\n\\n\\n    for(auto neighbour : graph[start]){\\n            dfs( neighbour.first,end, visited , graph , ans ,temp* neighbour.second);\\n    }\\n      return ;\\n}\\n//-------------------------------main function----------------------------------------//\\n    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& val, vector<vector<string>>& que) {\\n       int len = eq.size();\\n       int n = que.size();\\n        vector<double>answer; \\n  //------------------------------------make graph--------------------------------------------------//\\n  unordered_map< string , unordered_map<string , double> > graph;\\n\\n  for(int i =0 ; i<len ;i++){\\n        string first = eq[i][0];\\n        string second = eq[i][1];\\n         graph[first][second] = val[i];  //-->N/D\\n       graph[second][first] = (1.0/val[i]); //--> D/N\\n  }\\n\\n//-----------------------------------------next step-------------------------------------------------//\\n    for( int i = 0; i<n; i++){\\n   unordered_map<string , int>visited;\\n   double ans  =-1 ;   // que[i] --> final answer store\\n\\n   if(!graph.count(que[i][0]) || !graph.count(que[i][1])){    //if variable not exist in graph \\n          answer.push_back(-1);  \\n          continue;\\n   }\\n  dfs(que[i][0] ,que[i][1], visited , graph , ans ,1);   /// function call   \\n answer.push_back(ans);  \\n    }\\n\\n  return answer;           \\n    }\\n};"
                    },
                    {
                        "username": "an5dy90",
                        "content": "what is the purpose of providing [\"bc\",\"cd\"] and then query [\"bc\",\"cd\"] instead of [\"b\",\"d\"]? I was stuck in thinking how to remove the common factor but realized the solution treats \"bc\" or \"cd\" as new vertice.  "
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we handle query variables of multiple length? for e.g. bc / cd? I have some approaches in my head (using set and collections.retainAll etc) but that seems too complicated for a medium problem. Any ideas?"
                    },
                    {
                        "username": "judgementdey",
                        "content": "In such cases you treat `bc` as a single variable name, and not think of it as `b` and `c` separately. Store variable names as `string`, not `char`."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "how the fuck is this is a medium question it took me 2hrs to guess graph approach and then solve it completely!!!\\nHere\\'s how I solved it:\\npair<bool,double>Look(string a,string b,map<string,bool>&M,map<string,vector<pair<string,double> > >&m)\\n    {\\n        M[a]=true;\\n        for(auto p:m[a])\\n        {\\n            if(M[p.first] == true)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                M[p.first]=true;\\n            }\\n            //cout<<\"| \";\\n            if(p.first == b)\\n            {\\n                //cout<<\"1 \";\\n                return {true,p.second};\\n            }\\n            else\\n            {\\n                //cout<<\"2 \";\\n                pair<bool,double>k=Look(p.first,b,M,m);\\n                if(k.first == true)\\n                {\\n                    return {true,(k.second)*(p.second)};\\n                }\\n            }\\n        }\\n        return {false,-1};\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=equations.size();\\n        map<string,bool>N;\\n        for(int i=0;i<n;i++)\\n        {\\n            N[equations[i][0]]=true;\\n            N[equations[i][1]]=true;\\n        }\\n        map<string,vector<pair<string,double> > >m;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            string a=equations[i][0];\\n            string b=equations[i][1];\\n\\n            double value=values[i];\\n\\n            m[a].push_back({b,value});\\n            m[b].push_back({a,1/value});\\n        }\\n        vector<double>res;\\n        for(auto p:queries)\\n        {\\n            string a=p[0];\\n            string b=p[1];\\n            if(N.find(a) == N.end() and N.find(b) == N.end())\\n            {\\n                res.push_back(-1);continue;\\n            }\\n            if(a == b)\\n            {\\n                res.push_back(1);\\n                continue;\\n            }\\n            map<string,bool>M;\\n            for(auto p:N)\\n            {\\n                M[p.first]=false;\\n            }\\n            pair<bool,double>k=Look(a,b,M,m);\\n            //cout<<k.second<<\" \";\\n            if(k.first == false)\\n            {\\n                res.push_back(-1);\\n            }\\n            else\\n            {\\n                res.push_back(k.second);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "BimanDas",
                        "content": "It is an easy problem but became harder when I thought in more difficult way :\na/b = 2,    c/d = 3.      ac/bd = ?\nThough in this case result is -1.0 but I thought it will give the answer 6."
                    },
                    {
                        "username": "jaehee",
                        "content": "If we have `equations = [[\"a\", \"b\"], [\"c\", \"d\"]], values = [2.0, 3.0], queries = [[\"ac\", \"bd\"]]`, shouldn\\'t the output be `[6.0]` not `[-1.0]`? Did I miss any constraints?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "\"ac\" does not means a * c. Its an independent variable. Same for \"bd\".\\nThese variables are unknown as they are not mentioned in equations.\\n\\nHence we get -1 for that.\\n\\nHope that helps."
                    }
                ]
            },
            {
                "id": 1900284,
                "content": [
                    {
                        "username": "rahul_singaria",
                        "content": "why BFS gives TLE?"
                    },
                    {
                        "username": "Willthedrill",
                        "content": "I think that the problem should add a statement staing that \"bc\" is a single variable and it is NOT  `b*c` otherwise the problem becomes much harder..."
                    },
                    {
                        "username": "alexvaiman",
                        "content": "but it is... \"Each Ai or Bi is a string that represents a single variable.\""
                    },
                    {
                        "username": "alexvaiman",
                        "content": "Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\\nfor every x, if x!=0 x\\xA0/ x =1 in my opinion you algorithm and test cases are wrong"
                    },
                    {
                        "username": "gm-too-nice",
                        "content": "this is one of those leetcode problems where its helpful that they tell you the idea of how to solve (ex: here create a graph using the given information) but then its better to try to come up with own solutions as opposed to trying to understand leetcode\\'s solution"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nSIMPLE AND SUPER CLEAN CODE || EASY || COMMENTS\\nankush920\\n1\\n0\\na minute ago\\nC++\\nIntuition\\nusing DFS by converting string of equation in bidirected graph\\n\\nApproach\\nfor each query using DFS for each query\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\nm = length of query vector\\nn =string in expression\\n\\nSpace complexity:\\n0(n) // for making graph\\n// for visited node in dfs\\n\\nCode\\n\\n//-------------------------------Are you ready for this---------------------------------------------//\\nclass Solution {\\npublic:\\n\\n\\n//-------------------------------dfs------------------------------------------------//\\nvoid dfs( string start  ,string end , unordered_map<string , int >&visited , unordered_map<string, unordered_map<string,double> >&graph , double &ans , double temp ){\\n     if(end ==start){\\n          ans = temp ;\\n          return;\\n     }\\n\\n     if(visited.count(start)){\\n           return; \\n     }\\n    \\n    visited[start]++; \\n\\n\\n    for(auto neighbour : graph[start]){\\n            dfs( neighbour.first,end, visited , graph , ans ,temp* neighbour.second);\\n    }\\n      return ;\\n}\\n//-------------------------------main function----------------------------------------//\\n    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& val, vector<vector<string>>& que) {\\n       int len = eq.size();\\n       int n = que.size();\\n        vector<double>answer; \\n  //------------------------------------make graph--------------------------------------------------//\\n  unordered_map< string , unordered_map<string , double> > graph;\\n\\n  for(int i =0 ; i<len ;i++){\\n        string first = eq[i][0];\\n        string second = eq[i][1];\\n         graph[first][second] = val[i];  //-->N/D\\n       graph[second][first] = (1.0/val[i]); //--> D/N\\n  }\\n\\n//-----------------------------------------next step-------------------------------------------------//\\n    for( int i = 0; i<n; i++){\\n   unordered_map<string , int>visited;\\n   double ans  =-1 ;   // que[i] --> final answer store\\n\\n   if(!graph.count(que[i][0]) || !graph.count(que[i][1])){    //if variable not exist in graph \\n          answer.push_back(-1);  \\n          continue;\\n   }\\n  dfs(que[i][0] ,que[i][1], visited , graph , ans ,1);   /// function call   \\n answer.push_back(ans);  \\n    }\\n\\n  return answer;           \\n    }\\n};"
                    },
                    {
                        "username": "an5dy90",
                        "content": "what is the purpose of providing [\"bc\",\"cd\"] and then query [\"bc\",\"cd\"] instead of [\"b\",\"d\"]? I was stuck in thinking how to remove the common factor but realized the solution treats \"bc\" or \"cd\" as new vertice.  "
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we handle query variables of multiple length? for e.g. bc / cd? I have some approaches in my head (using set and collections.retainAll etc) but that seems too complicated for a medium problem. Any ideas?"
                    },
                    {
                        "username": "judgementdey",
                        "content": "In such cases you treat `bc` as a single variable name, and not think of it as `b` and `c` separately. Store variable names as `string`, not `char`."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "how the fuck is this is a medium question it took me 2hrs to guess graph approach and then solve it completely!!!\\nHere\\'s how I solved it:\\npair<bool,double>Look(string a,string b,map<string,bool>&M,map<string,vector<pair<string,double> > >&m)\\n    {\\n        M[a]=true;\\n        for(auto p:m[a])\\n        {\\n            if(M[p.first] == true)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                M[p.first]=true;\\n            }\\n            //cout<<\"| \";\\n            if(p.first == b)\\n            {\\n                //cout<<\"1 \";\\n                return {true,p.second};\\n            }\\n            else\\n            {\\n                //cout<<\"2 \";\\n                pair<bool,double>k=Look(p.first,b,M,m);\\n                if(k.first == true)\\n                {\\n                    return {true,(k.second)*(p.second)};\\n                }\\n            }\\n        }\\n        return {false,-1};\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=equations.size();\\n        map<string,bool>N;\\n        for(int i=0;i<n;i++)\\n        {\\n            N[equations[i][0]]=true;\\n            N[equations[i][1]]=true;\\n        }\\n        map<string,vector<pair<string,double> > >m;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            string a=equations[i][0];\\n            string b=equations[i][1];\\n\\n            double value=values[i];\\n\\n            m[a].push_back({b,value});\\n            m[b].push_back({a,1/value});\\n        }\\n        vector<double>res;\\n        for(auto p:queries)\\n        {\\n            string a=p[0];\\n            string b=p[1];\\n            if(N.find(a) == N.end() and N.find(b) == N.end())\\n            {\\n                res.push_back(-1);continue;\\n            }\\n            if(a == b)\\n            {\\n                res.push_back(1);\\n                continue;\\n            }\\n            map<string,bool>M;\\n            for(auto p:N)\\n            {\\n                M[p.first]=false;\\n            }\\n            pair<bool,double>k=Look(a,b,M,m);\\n            //cout<<k.second<<\" \";\\n            if(k.first == false)\\n            {\\n                res.push_back(-1);\\n            }\\n            else\\n            {\\n                res.push_back(k.second);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "BimanDas",
                        "content": "It is an easy problem but became harder when I thought in more difficult way :\na/b = 2,    c/d = 3.      ac/bd = ?\nThough in this case result is -1.0 but I thought it will give the answer 6."
                    },
                    {
                        "username": "jaehee",
                        "content": "If we have `equations = [[\"a\", \"b\"], [\"c\", \"d\"]], values = [2.0, 3.0], queries = [[\"ac\", \"bd\"]]`, shouldn\\'t the output be `[6.0]` not `[-1.0]`? Did I miss any constraints?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "\"ac\" does not means a * c. Its an independent variable. Same for \"bd\".\\nThese variables are unknown as they are not mentioned in equations.\\n\\nHence we get -1 for that.\\n\\nHope that helps."
                    }
                ]
            },
            {
                "id": 1900179,
                "content": [
                    {
                        "username": "rahul_singaria",
                        "content": "why BFS gives TLE?"
                    },
                    {
                        "username": "Willthedrill",
                        "content": "I think that the problem should add a statement staing that \"bc\" is a single variable and it is NOT  `b*c` otherwise the problem becomes much harder..."
                    },
                    {
                        "username": "alexvaiman",
                        "content": "but it is... \"Each Ai or Bi is a string that represents a single variable.\""
                    },
                    {
                        "username": "alexvaiman",
                        "content": "Input: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\\nOutput: [0.50000,2.00000,-1.00000,-1.00000]\\nfor every x, if x!=0 x\\xA0/ x =1 in my opinion you algorithm and test cases are wrong"
                    },
                    {
                        "username": "gm-too-nice",
                        "content": "this is one of those leetcode problems where its helpful that they tell you the idea of how to solve (ex: here create a graph using the given information) but then its better to try to come up with own solutions as opposed to trying to understand leetcode\\'s solution"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nSIMPLE AND SUPER CLEAN CODE || EASY || COMMENTS\\nankush920\\n1\\n0\\na minute ago\\nC++\\nIntuition\\nusing DFS by converting string of equation in bidirected graph\\n\\nApproach\\nfor each query using DFS for each query\\n\\nComplexity\\nTime complexity:\\n0(m*n)\\nm = length of query vector\\nn =string in expression\\n\\nSpace complexity:\\n0(n) // for making graph\\n// for visited node in dfs\\n\\nCode\\n\\n//-------------------------------Are you ready for this---------------------------------------------//\\nclass Solution {\\npublic:\\n\\n\\n//-------------------------------dfs------------------------------------------------//\\nvoid dfs( string start  ,string end , unordered_map<string , int >&visited , unordered_map<string, unordered_map<string,double> >&graph , double &ans , double temp ){\\n     if(end ==start){\\n          ans = temp ;\\n          return;\\n     }\\n\\n     if(visited.count(start)){\\n           return; \\n     }\\n    \\n    visited[start]++; \\n\\n\\n    for(auto neighbour : graph[start]){\\n            dfs( neighbour.first,end, visited , graph , ans ,temp* neighbour.second);\\n    }\\n      return ;\\n}\\n//-------------------------------main function----------------------------------------//\\n    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& val, vector<vector<string>>& que) {\\n       int len = eq.size();\\n       int n = que.size();\\n        vector<double>answer; \\n  //------------------------------------make graph--------------------------------------------------//\\n  unordered_map< string , unordered_map<string , double> > graph;\\n\\n  for(int i =0 ; i<len ;i++){\\n        string first = eq[i][0];\\n        string second = eq[i][1];\\n         graph[first][second] = val[i];  //-->N/D\\n       graph[second][first] = (1.0/val[i]); //--> D/N\\n  }\\n\\n//-----------------------------------------next step-------------------------------------------------//\\n    for( int i = 0; i<n; i++){\\n   unordered_map<string , int>visited;\\n   double ans  =-1 ;   // que[i] --> final answer store\\n\\n   if(!graph.count(que[i][0]) || !graph.count(que[i][1])){    //if variable not exist in graph \\n          answer.push_back(-1);  \\n          continue;\\n   }\\n  dfs(que[i][0] ,que[i][1], visited , graph , ans ,1);   /// function call   \\n answer.push_back(ans);  \\n    }\\n\\n  return answer;           \\n    }\\n};"
                    },
                    {
                        "username": "an5dy90",
                        "content": "what is the purpose of providing [\"bc\",\"cd\"] and then query [\"bc\",\"cd\"] instead of [\"b\",\"d\"]? I was stuck in thinking how to remove the common factor but realized the solution treats \"bc\" or \"cd\" as new vertice.  "
                    },
                    {
                        "username": "zephyr8",
                        "content": "How do we handle query variables of multiple length? for e.g. bc / cd? I have some approaches in my head (using set and collections.retainAll etc) but that seems too complicated for a medium problem. Any ideas?"
                    },
                    {
                        "username": "judgementdey",
                        "content": "In such cases you treat `bc` as a single variable name, and not think of it as `b` and `c` separately. Store variable names as `string`, not `char`."
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "how the fuck is this is a medium question it took me 2hrs to guess graph approach and then solve it completely!!!\\nHere\\'s how I solved it:\\npair<bool,double>Look(string a,string b,map<string,bool>&M,map<string,vector<pair<string,double> > >&m)\\n    {\\n        M[a]=true;\\n        for(auto p:m[a])\\n        {\\n            if(M[p.first] == true)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                M[p.first]=true;\\n            }\\n            //cout<<\"| \";\\n            if(p.first == b)\\n            {\\n                //cout<<\"1 \";\\n                return {true,p.second};\\n            }\\n            else\\n            {\\n                //cout<<\"2 \";\\n                pair<bool,double>k=Look(p.first,b,M,m);\\n                if(k.first == true)\\n                {\\n                    return {true,(k.second)*(p.second)};\\n                }\\n            }\\n        }\\n        return {false,-1};\\n    }\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        int n=equations.size();\\n        map<string,bool>N;\\n        for(int i=0;i<n;i++)\\n        {\\n            N[equations[i][0]]=true;\\n            N[equations[i][1]]=true;\\n        }\\n        map<string,vector<pair<string,double> > >m;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            string a=equations[i][0];\\n            string b=equations[i][1];\\n\\n            double value=values[i];\\n\\n            m[a].push_back({b,value});\\n            m[b].push_back({a,1/value});\\n        }\\n        vector<double>res;\\n        for(auto p:queries)\\n        {\\n            string a=p[0];\\n            string b=p[1];\\n            if(N.find(a) == N.end() and N.find(b) == N.end())\\n            {\\n                res.push_back(-1);continue;\\n            }\\n            if(a == b)\\n            {\\n                res.push_back(1);\\n                continue;\\n            }\\n            map<string,bool>M;\\n            for(auto p:N)\\n            {\\n                M[p.first]=false;\\n            }\\n            pair<bool,double>k=Look(a,b,M,m);\\n            //cout<<k.second<<\" \";\\n            if(k.first == false)\\n            {\\n                res.push_back(-1);\\n            }\\n            else\\n            {\\n                res.push_back(k.second);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "BimanDas",
                        "content": "It is an easy problem but became harder when I thought in more difficult way :\na/b = 2,    c/d = 3.      ac/bd = ?\nThough in this case result is -1.0 but I thought it will give the answer 6."
                    },
                    {
                        "username": "jaehee",
                        "content": "If we have `equations = [[\"a\", \"b\"], [\"c\", \"d\"]], values = [2.0, 3.0], queries = [[\"ac\", \"bd\"]]`, shouldn\\'t the output be `[6.0]` not `[-1.0]`? Did I miss any constraints?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "\"ac\" does not means a * c. Its an independent variable. Same for \"bd\".\\nThese variables are unknown as they are not mentioned in equations.\\n\\nHence we get -1 for that.\\n\\nHope that helps."
                    }
                ]
            },
            {
                "id": 1900169,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone please tell whether the time complexity my code is right or wrong ?\\n\\n\\nclass Solution {\\npublic:\\n\\n    double ans = -1.0;\\n\\n    void dfs(map<string , vector<pair<string , double>>> &adj , string curr_node , string end_node , double product , set<string> &visited){\\n\\n        if(curr_node==end_node){\\n            ans = product;\\n            return;\\n        }\\n        \\n        // O(logV)\\n        visited.insert(curr_node);\\n\\n        for(auto it : adj[curr_node]){\\n            if(visited.find(it.first)==visited.end()){\\n                dfs(adj , it.first , end_node , product*it.second , visited);\\n            }\\n        }\\n        \\n    }\\n \\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        vector<double>anss;\\n        map<string,vector<pair<string , double>>>adj;\\n\\n\\n        for(int i=0 ; i<equations.size() ; i++){\\n            \\n            string a = equations[i][0];\\n            string b = equations[i][1];\\n            double val = values[i];\\n            double inverse_val = 1.0/(val*1.0) ;\\n\\n            adj[a].push_back({b , val});\\n            adj[b].push_back({a , inverse_val});\\n\\n        }\\n \\n\\n        //O(queries.length)\\n\\n        for(int i=0 ; i<queries.size() ; i++){\\n            string curr_node = queries[i][0];\\n            string end_node = queries[i][1];\\n             \\n            //O(log V)\\n\\n            if(adj.find(curr_node)==adj.end() || adj.find(end_node)==adj.end()){\\n                anss.push_back(-1.0);\\n            }else{\\n            set<string>visited;\\n            double product = 1.0;\\n            ans = -1.0;\\n            \\n            // O(V + E*logV)\\n\\n            dfs(adj , curr_node , end_node , product , visited);\\n            anss.push_back(ans);\\n            }\\n        }\\n\\n        // overall Time Complexity is O(queries.length * (log V + (V + E*logV)))\\n\\n\\n\\n        return anss;\\n    }\\n}; @TushaarDTU  "
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "Use unordered_map instead of map.\\n\\nIt will remove the log V part in your complexity.\\n\\nNew TC: O(queries.size() * (V+E))"
                    },
                    {
                        "username": "lordvidex",
                        "content": "what a problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "What an Enlightening Hint!"
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone else here solved it for a-s and b-s only to realize there are also cases like ab/bc? "
                    },
                    {
                        "username": "z3eg",
                        "content": "i mean, x/x should always be 1, even if we don\\'t know what x is. your first testcase is kinda lame ngl"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "considering the constraint that \\n0.0 < values[i] <= 20.0, you are right. from 1 to 20, x/x must be  1.\\n\\nhowever, if these constraints aren\\'t there\\nthen 0/0 is undefined, as well as infinity / infinity is undefined.\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "This is a graph problem."
                    },
                    {
                        "username": "prajjwaljogdand20bcs39",
                        "content": "equations =\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\nvalues =\\n[3.0,4.0,5.0,6.0]\\nqueries =\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\nUse Testcase\\nOutput\\n[360.00000,0.00833,6.66667,1.00000,-1.00000,-1.00000]\\nExpected\\n[360.00000,0.00833,20.00000,1.00000,-1.00000,-1.00000]\\n\\nfor third query x2 and x4 ans should be 20 right  ?\\nx2 / x3 = 4.0 \\nx3 / x4 = 5.0 \\n( x2 / x3 ) * ( x3 / x4 ) = x2 / x4 =  4.0 * 5.0  = 20.00"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "yes you are right.\\nit is 20.00.\\n\\nwhy you are getting 6.6667 though?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "I got confused with the [[\"bc\", \"cd\" ]]  test. I thought it is b*c / c*d.\\n\\nThe problem should be marked Hard though"
                    },
                    {
                        "username": "grapefroot",
                        "content": "You can precompute answers for all queries using a Floyd-Warshall like algorithm"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "where is the God Damn Editorial when we need it !"
                    }
                ]
            },
            {
                "id": 1900140,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone please tell whether the time complexity my code is right or wrong ?\\n\\n\\nclass Solution {\\npublic:\\n\\n    double ans = -1.0;\\n\\n    void dfs(map<string , vector<pair<string , double>>> &adj , string curr_node , string end_node , double product , set<string> &visited){\\n\\n        if(curr_node==end_node){\\n            ans = product;\\n            return;\\n        }\\n        \\n        // O(logV)\\n        visited.insert(curr_node);\\n\\n        for(auto it : adj[curr_node]){\\n            if(visited.find(it.first)==visited.end()){\\n                dfs(adj , it.first , end_node , product*it.second , visited);\\n            }\\n        }\\n        \\n    }\\n \\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        vector<double>anss;\\n        map<string,vector<pair<string , double>>>adj;\\n\\n\\n        for(int i=0 ; i<equations.size() ; i++){\\n            \\n            string a = equations[i][0];\\n            string b = equations[i][1];\\n            double val = values[i];\\n            double inverse_val = 1.0/(val*1.0) ;\\n\\n            adj[a].push_back({b , val});\\n            adj[b].push_back({a , inverse_val});\\n\\n        }\\n \\n\\n        //O(queries.length)\\n\\n        for(int i=0 ; i<queries.size() ; i++){\\n            string curr_node = queries[i][0];\\n            string end_node = queries[i][1];\\n             \\n            //O(log V)\\n\\n            if(adj.find(curr_node)==adj.end() || adj.find(end_node)==adj.end()){\\n                anss.push_back(-1.0);\\n            }else{\\n            set<string>visited;\\n            double product = 1.0;\\n            ans = -1.0;\\n            \\n            // O(V + E*logV)\\n\\n            dfs(adj , curr_node , end_node , product , visited);\\n            anss.push_back(ans);\\n            }\\n        }\\n\\n        // overall Time Complexity is O(queries.length * (log V + (V + E*logV)))\\n\\n\\n\\n        return anss;\\n    }\\n}; @TushaarDTU  "
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "Use unordered_map instead of map.\\n\\nIt will remove the log V part in your complexity.\\n\\nNew TC: O(queries.size() * (V+E))"
                    },
                    {
                        "username": "lordvidex",
                        "content": "what a problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "What an Enlightening Hint!"
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone else here solved it for a-s and b-s only to realize there are also cases like ab/bc? "
                    },
                    {
                        "username": "z3eg",
                        "content": "i mean, x/x should always be 1, even if we don\\'t know what x is. your first testcase is kinda lame ngl"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "considering the constraint that \\n0.0 < values[i] <= 20.0, you are right. from 1 to 20, x/x must be  1.\\n\\nhowever, if these constraints aren\\'t there\\nthen 0/0 is undefined, as well as infinity / infinity is undefined.\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "This is a graph problem."
                    },
                    {
                        "username": "prajjwaljogdand20bcs39",
                        "content": "equations =\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\nvalues =\\n[3.0,4.0,5.0,6.0]\\nqueries =\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\nUse Testcase\\nOutput\\n[360.00000,0.00833,6.66667,1.00000,-1.00000,-1.00000]\\nExpected\\n[360.00000,0.00833,20.00000,1.00000,-1.00000,-1.00000]\\n\\nfor third query x2 and x4 ans should be 20 right  ?\\nx2 / x3 = 4.0 \\nx3 / x4 = 5.0 \\n( x2 / x3 ) * ( x3 / x4 ) = x2 / x4 =  4.0 * 5.0  = 20.00"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "yes you are right.\\nit is 20.00.\\n\\nwhy you are getting 6.6667 though?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "I got confused with the [[\"bc\", \"cd\" ]]  test. I thought it is b*c / c*d.\\n\\nThe problem should be marked Hard though"
                    },
                    {
                        "username": "grapefroot",
                        "content": "You can precompute answers for all queries using a Floyd-Warshall like algorithm"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "where is the God Damn Editorial when we need it !"
                    }
                ]
            },
            {
                "id": 1900125,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone please tell whether the time complexity my code is right or wrong ?\\n\\n\\nclass Solution {\\npublic:\\n\\n    double ans = -1.0;\\n\\n    void dfs(map<string , vector<pair<string , double>>> &adj , string curr_node , string end_node , double product , set<string> &visited){\\n\\n        if(curr_node==end_node){\\n            ans = product;\\n            return;\\n        }\\n        \\n        // O(logV)\\n        visited.insert(curr_node);\\n\\n        for(auto it : adj[curr_node]){\\n            if(visited.find(it.first)==visited.end()){\\n                dfs(adj , it.first , end_node , product*it.second , visited);\\n            }\\n        }\\n        \\n    }\\n \\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        vector<double>anss;\\n        map<string,vector<pair<string , double>>>adj;\\n\\n\\n        for(int i=0 ; i<equations.size() ; i++){\\n            \\n            string a = equations[i][0];\\n            string b = equations[i][1];\\n            double val = values[i];\\n            double inverse_val = 1.0/(val*1.0) ;\\n\\n            adj[a].push_back({b , val});\\n            adj[b].push_back({a , inverse_val});\\n\\n        }\\n \\n\\n        //O(queries.length)\\n\\n        for(int i=0 ; i<queries.size() ; i++){\\n            string curr_node = queries[i][0];\\n            string end_node = queries[i][1];\\n             \\n            //O(log V)\\n\\n            if(adj.find(curr_node)==adj.end() || adj.find(end_node)==adj.end()){\\n                anss.push_back(-1.0);\\n            }else{\\n            set<string>visited;\\n            double product = 1.0;\\n            ans = -1.0;\\n            \\n            // O(V + E*logV)\\n\\n            dfs(adj , curr_node , end_node , product , visited);\\n            anss.push_back(ans);\\n            }\\n        }\\n\\n        // overall Time Complexity is O(queries.length * (log V + (V + E*logV)))\\n\\n\\n\\n        return anss;\\n    }\\n}; @TushaarDTU  "
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "Use unordered_map instead of map.\\n\\nIt will remove the log V part in your complexity.\\n\\nNew TC: O(queries.size() * (V+E))"
                    },
                    {
                        "username": "lordvidex",
                        "content": "what a problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "What an Enlightening Hint!"
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone else here solved it for a-s and b-s only to realize there are also cases like ab/bc? "
                    },
                    {
                        "username": "z3eg",
                        "content": "i mean, x/x should always be 1, even if we don\\'t know what x is. your first testcase is kinda lame ngl"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "considering the constraint that \\n0.0 < values[i] <= 20.0, you are right. from 1 to 20, x/x must be  1.\\n\\nhowever, if these constraints aren\\'t there\\nthen 0/0 is undefined, as well as infinity / infinity is undefined.\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "This is a graph problem."
                    },
                    {
                        "username": "prajjwaljogdand20bcs39",
                        "content": "equations =\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\nvalues =\\n[3.0,4.0,5.0,6.0]\\nqueries =\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\nUse Testcase\\nOutput\\n[360.00000,0.00833,6.66667,1.00000,-1.00000,-1.00000]\\nExpected\\n[360.00000,0.00833,20.00000,1.00000,-1.00000,-1.00000]\\n\\nfor third query x2 and x4 ans should be 20 right  ?\\nx2 / x3 = 4.0 \\nx3 / x4 = 5.0 \\n( x2 / x3 ) * ( x3 / x4 ) = x2 / x4 =  4.0 * 5.0  = 20.00"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "yes you are right.\\nit is 20.00.\\n\\nwhy you are getting 6.6667 though?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "I got confused with the [[\"bc\", \"cd\" ]]  test. I thought it is b*c / c*d.\\n\\nThe problem should be marked Hard though"
                    },
                    {
                        "username": "grapefroot",
                        "content": "You can precompute answers for all queries using a Floyd-Warshall like algorithm"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "where is the God Damn Editorial when we need it !"
                    }
                ]
            },
            {
                "id": 1900119,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone please tell whether the time complexity my code is right or wrong ?\\n\\n\\nclass Solution {\\npublic:\\n\\n    double ans = -1.0;\\n\\n    void dfs(map<string , vector<pair<string , double>>> &adj , string curr_node , string end_node , double product , set<string> &visited){\\n\\n        if(curr_node==end_node){\\n            ans = product;\\n            return;\\n        }\\n        \\n        // O(logV)\\n        visited.insert(curr_node);\\n\\n        for(auto it : adj[curr_node]){\\n            if(visited.find(it.first)==visited.end()){\\n                dfs(adj , it.first , end_node , product*it.second , visited);\\n            }\\n        }\\n        \\n    }\\n \\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        vector<double>anss;\\n        map<string,vector<pair<string , double>>>adj;\\n\\n\\n        for(int i=0 ; i<equations.size() ; i++){\\n            \\n            string a = equations[i][0];\\n            string b = equations[i][1];\\n            double val = values[i];\\n            double inverse_val = 1.0/(val*1.0) ;\\n\\n            adj[a].push_back({b , val});\\n            adj[b].push_back({a , inverse_val});\\n\\n        }\\n \\n\\n        //O(queries.length)\\n\\n        for(int i=0 ; i<queries.size() ; i++){\\n            string curr_node = queries[i][0];\\n            string end_node = queries[i][1];\\n             \\n            //O(log V)\\n\\n            if(adj.find(curr_node)==adj.end() || adj.find(end_node)==adj.end()){\\n                anss.push_back(-1.0);\\n            }else{\\n            set<string>visited;\\n            double product = 1.0;\\n            ans = -1.0;\\n            \\n            // O(V + E*logV)\\n\\n            dfs(adj , curr_node , end_node , product , visited);\\n            anss.push_back(ans);\\n            }\\n        }\\n\\n        // overall Time Complexity is O(queries.length * (log V + (V + E*logV)))\\n\\n\\n\\n        return anss;\\n    }\\n}; @TushaarDTU  "
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "Use unordered_map instead of map.\\n\\nIt will remove the log V part in your complexity.\\n\\nNew TC: O(queries.size() * (V+E))"
                    },
                    {
                        "username": "lordvidex",
                        "content": "what a problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "What an Enlightening Hint!"
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone else here solved it for a-s and b-s only to realize there are also cases like ab/bc? "
                    },
                    {
                        "username": "z3eg",
                        "content": "i mean, x/x should always be 1, even if we don\\'t know what x is. your first testcase is kinda lame ngl"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "considering the constraint that \\n0.0 < values[i] <= 20.0, you are right. from 1 to 20, x/x must be  1.\\n\\nhowever, if these constraints aren\\'t there\\nthen 0/0 is undefined, as well as infinity / infinity is undefined.\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "This is a graph problem."
                    },
                    {
                        "username": "prajjwaljogdand20bcs39",
                        "content": "equations =\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\nvalues =\\n[3.0,4.0,5.0,6.0]\\nqueries =\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\nUse Testcase\\nOutput\\n[360.00000,0.00833,6.66667,1.00000,-1.00000,-1.00000]\\nExpected\\n[360.00000,0.00833,20.00000,1.00000,-1.00000,-1.00000]\\n\\nfor third query x2 and x4 ans should be 20 right  ?\\nx2 / x3 = 4.0 \\nx3 / x4 = 5.0 \\n( x2 / x3 ) * ( x3 / x4 ) = x2 / x4 =  4.0 * 5.0  = 20.00"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "yes you are right.\\nit is 20.00.\\n\\nwhy you are getting 6.6667 though?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "I got confused with the [[\"bc\", \"cd\" ]]  test. I thought it is b*c / c*d.\\n\\nThe problem should be marked Hard though"
                    },
                    {
                        "username": "grapefroot",
                        "content": "You can precompute answers for all queries using a Floyd-Warshall like algorithm"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "where is the God Damn Editorial when we need it !"
                    }
                ]
            },
            {
                "id": 1900108,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone please tell whether the time complexity my code is right or wrong ?\\n\\n\\nclass Solution {\\npublic:\\n\\n    double ans = -1.0;\\n\\n    void dfs(map<string , vector<pair<string , double>>> &adj , string curr_node , string end_node , double product , set<string> &visited){\\n\\n        if(curr_node==end_node){\\n            ans = product;\\n            return;\\n        }\\n        \\n        // O(logV)\\n        visited.insert(curr_node);\\n\\n        for(auto it : adj[curr_node]){\\n            if(visited.find(it.first)==visited.end()){\\n                dfs(adj , it.first , end_node , product*it.second , visited);\\n            }\\n        }\\n        \\n    }\\n \\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        vector<double>anss;\\n        map<string,vector<pair<string , double>>>adj;\\n\\n\\n        for(int i=0 ; i<equations.size() ; i++){\\n            \\n            string a = equations[i][0];\\n            string b = equations[i][1];\\n            double val = values[i];\\n            double inverse_val = 1.0/(val*1.0) ;\\n\\n            adj[a].push_back({b , val});\\n            adj[b].push_back({a , inverse_val});\\n\\n        }\\n \\n\\n        //O(queries.length)\\n\\n        for(int i=0 ; i<queries.size() ; i++){\\n            string curr_node = queries[i][0];\\n            string end_node = queries[i][1];\\n             \\n            //O(log V)\\n\\n            if(adj.find(curr_node)==adj.end() || adj.find(end_node)==adj.end()){\\n                anss.push_back(-1.0);\\n            }else{\\n            set<string>visited;\\n            double product = 1.0;\\n            ans = -1.0;\\n            \\n            // O(V + E*logV)\\n\\n            dfs(adj , curr_node , end_node , product , visited);\\n            anss.push_back(ans);\\n            }\\n        }\\n\\n        // overall Time Complexity is O(queries.length * (log V + (V + E*logV)))\\n\\n\\n\\n        return anss;\\n    }\\n}; @TushaarDTU  "
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "Use unordered_map instead of map.\\n\\nIt will remove the log V part in your complexity.\\n\\nNew TC: O(queries.size() * (V+E))"
                    },
                    {
                        "username": "lordvidex",
                        "content": "what a problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "What an Enlightening Hint!"
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone else here solved it for a-s and b-s only to realize there are also cases like ab/bc? "
                    },
                    {
                        "username": "z3eg",
                        "content": "i mean, x/x should always be 1, even if we don\\'t know what x is. your first testcase is kinda lame ngl"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "considering the constraint that \\n0.0 < values[i] <= 20.0, you are right. from 1 to 20, x/x must be  1.\\n\\nhowever, if these constraints aren\\'t there\\nthen 0/0 is undefined, as well as infinity / infinity is undefined.\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "This is a graph problem."
                    },
                    {
                        "username": "prajjwaljogdand20bcs39",
                        "content": "equations =\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\nvalues =\\n[3.0,4.0,5.0,6.0]\\nqueries =\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\nUse Testcase\\nOutput\\n[360.00000,0.00833,6.66667,1.00000,-1.00000,-1.00000]\\nExpected\\n[360.00000,0.00833,20.00000,1.00000,-1.00000,-1.00000]\\n\\nfor third query x2 and x4 ans should be 20 right  ?\\nx2 / x3 = 4.0 \\nx3 / x4 = 5.0 \\n( x2 / x3 ) * ( x3 / x4 ) = x2 / x4 =  4.0 * 5.0  = 20.00"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "yes you are right.\\nit is 20.00.\\n\\nwhy you are getting 6.6667 though?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "I got confused with the [[\"bc\", \"cd\" ]]  test. I thought it is b*c / c*d.\\n\\nThe problem should be marked Hard though"
                    },
                    {
                        "username": "grapefroot",
                        "content": "You can precompute answers for all queries using a Floyd-Warshall like algorithm"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "where is the God Damn Editorial when we need it !"
                    }
                ]
            },
            {
                "id": 1900097,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone please tell whether the time complexity my code is right or wrong ?\\n\\n\\nclass Solution {\\npublic:\\n\\n    double ans = -1.0;\\n\\n    void dfs(map<string , vector<pair<string , double>>> &adj , string curr_node , string end_node , double product , set<string> &visited){\\n\\n        if(curr_node==end_node){\\n            ans = product;\\n            return;\\n        }\\n        \\n        // O(logV)\\n        visited.insert(curr_node);\\n\\n        for(auto it : adj[curr_node]){\\n            if(visited.find(it.first)==visited.end()){\\n                dfs(adj , it.first , end_node , product*it.second , visited);\\n            }\\n        }\\n        \\n    }\\n \\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        vector<double>anss;\\n        map<string,vector<pair<string , double>>>adj;\\n\\n\\n        for(int i=0 ; i<equations.size() ; i++){\\n            \\n            string a = equations[i][0];\\n            string b = equations[i][1];\\n            double val = values[i];\\n            double inverse_val = 1.0/(val*1.0) ;\\n\\n            adj[a].push_back({b , val});\\n            adj[b].push_back({a , inverse_val});\\n\\n        }\\n \\n\\n        //O(queries.length)\\n\\n        for(int i=0 ; i<queries.size() ; i++){\\n            string curr_node = queries[i][0];\\n            string end_node = queries[i][1];\\n             \\n            //O(log V)\\n\\n            if(adj.find(curr_node)==adj.end() || adj.find(end_node)==adj.end()){\\n                anss.push_back(-1.0);\\n            }else{\\n            set<string>visited;\\n            double product = 1.0;\\n            ans = -1.0;\\n            \\n            // O(V + E*logV)\\n\\n            dfs(adj , curr_node , end_node , product , visited);\\n            anss.push_back(ans);\\n            }\\n        }\\n\\n        // overall Time Complexity is O(queries.length * (log V + (V + E*logV)))\\n\\n\\n\\n        return anss;\\n    }\\n}; @TushaarDTU  "
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "Use unordered_map instead of map.\\n\\nIt will remove the log V part in your complexity.\\n\\nNew TC: O(queries.size() * (V+E))"
                    },
                    {
                        "username": "lordvidex",
                        "content": "what a problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "What an Enlightening Hint!"
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone else here solved it for a-s and b-s only to realize there are also cases like ab/bc? "
                    },
                    {
                        "username": "z3eg",
                        "content": "i mean, x/x should always be 1, even if we don\\'t know what x is. your first testcase is kinda lame ngl"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "considering the constraint that \\n0.0 < values[i] <= 20.0, you are right. from 1 to 20, x/x must be  1.\\n\\nhowever, if these constraints aren\\'t there\\nthen 0/0 is undefined, as well as infinity / infinity is undefined.\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "This is a graph problem."
                    },
                    {
                        "username": "prajjwaljogdand20bcs39",
                        "content": "equations =\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\nvalues =\\n[3.0,4.0,5.0,6.0]\\nqueries =\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\nUse Testcase\\nOutput\\n[360.00000,0.00833,6.66667,1.00000,-1.00000,-1.00000]\\nExpected\\n[360.00000,0.00833,20.00000,1.00000,-1.00000,-1.00000]\\n\\nfor third query x2 and x4 ans should be 20 right  ?\\nx2 / x3 = 4.0 \\nx3 / x4 = 5.0 \\n( x2 / x3 ) * ( x3 / x4 ) = x2 / x4 =  4.0 * 5.0  = 20.00"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "yes you are right.\\nit is 20.00.\\n\\nwhy you are getting 6.6667 though?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "I got confused with the [[\"bc\", \"cd\" ]]  test. I thought it is b*c / c*d.\\n\\nThe problem should be marked Hard though"
                    },
                    {
                        "username": "grapefroot",
                        "content": "You can precompute answers for all queries using a Floyd-Warshall like algorithm"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "where is the God Damn Editorial when we need it !"
                    }
                ]
            },
            {
                "id": 1900079,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone please tell whether the time complexity my code is right or wrong ?\\n\\n\\nclass Solution {\\npublic:\\n\\n    double ans = -1.0;\\n\\n    void dfs(map<string , vector<pair<string , double>>> &adj , string curr_node , string end_node , double product , set<string> &visited){\\n\\n        if(curr_node==end_node){\\n            ans = product;\\n            return;\\n        }\\n        \\n        // O(logV)\\n        visited.insert(curr_node);\\n\\n        for(auto it : adj[curr_node]){\\n            if(visited.find(it.first)==visited.end()){\\n                dfs(adj , it.first , end_node , product*it.second , visited);\\n            }\\n        }\\n        \\n    }\\n \\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        vector<double>anss;\\n        map<string,vector<pair<string , double>>>adj;\\n\\n\\n        for(int i=0 ; i<equations.size() ; i++){\\n            \\n            string a = equations[i][0];\\n            string b = equations[i][1];\\n            double val = values[i];\\n            double inverse_val = 1.0/(val*1.0) ;\\n\\n            adj[a].push_back({b , val});\\n            adj[b].push_back({a , inverse_val});\\n\\n        }\\n \\n\\n        //O(queries.length)\\n\\n        for(int i=0 ; i<queries.size() ; i++){\\n            string curr_node = queries[i][0];\\n            string end_node = queries[i][1];\\n             \\n            //O(log V)\\n\\n            if(adj.find(curr_node)==adj.end() || adj.find(end_node)==adj.end()){\\n                anss.push_back(-1.0);\\n            }else{\\n            set<string>visited;\\n            double product = 1.0;\\n            ans = -1.0;\\n            \\n            // O(V + E*logV)\\n\\n            dfs(adj , curr_node , end_node , product , visited);\\n            anss.push_back(ans);\\n            }\\n        }\\n\\n        // overall Time Complexity is O(queries.length * (log V + (V + E*logV)))\\n\\n\\n\\n        return anss;\\n    }\\n}; @TushaarDTU  "
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "Use unordered_map instead of map.\\n\\nIt will remove the log V part in your complexity.\\n\\nNew TC: O(queries.size() * (V+E))"
                    },
                    {
                        "username": "lordvidex",
                        "content": "what a problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "What an Enlightening Hint!"
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone else here solved it for a-s and b-s only to realize there are also cases like ab/bc? "
                    },
                    {
                        "username": "z3eg",
                        "content": "i mean, x/x should always be 1, even if we don\\'t know what x is. your first testcase is kinda lame ngl"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "considering the constraint that \\n0.0 < values[i] <= 20.0, you are right. from 1 to 20, x/x must be  1.\\n\\nhowever, if these constraints aren\\'t there\\nthen 0/0 is undefined, as well as infinity / infinity is undefined.\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "This is a graph problem."
                    },
                    {
                        "username": "prajjwaljogdand20bcs39",
                        "content": "equations =\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\nvalues =\\n[3.0,4.0,5.0,6.0]\\nqueries =\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\nUse Testcase\\nOutput\\n[360.00000,0.00833,6.66667,1.00000,-1.00000,-1.00000]\\nExpected\\n[360.00000,0.00833,20.00000,1.00000,-1.00000,-1.00000]\\n\\nfor third query x2 and x4 ans should be 20 right  ?\\nx2 / x3 = 4.0 \\nx3 / x4 = 5.0 \\n( x2 / x3 ) * ( x3 / x4 ) = x2 / x4 =  4.0 * 5.0  = 20.00"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "yes you are right.\\nit is 20.00.\\n\\nwhy you are getting 6.6667 though?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "I got confused with the [[\"bc\", \"cd\" ]]  test. I thought it is b*c / c*d.\\n\\nThe problem should be marked Hard though"
                    },
                    {
                        "username": "grapefroot",
                        "content": "You can precompute answers for all queries using a Floyd-Warshall like algorithm"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "where is the God Damn Editorial when we need it !"
                    }
                ]
            },
            {
                "id": 1900024,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone please tell whether the time complexity my code is right or wrong ?\\n\\n\\nclass Solution {\\npublic:\\n\\n    double ans = -1.0;\\n\\n    void dfs(map<string , vector<pair<string , double>>> &adj , string curr_node , string end_node , double product , set<string> &visited){\\n\\n        if(curr_node==end_node){\\n            ans = product;\\n            return;\\n        }\\n        \\n        // O(logV)\\n        visited.insert(curr_node);\\n\\n        for(auto it : adj[curr_node]){\\n            if(visited.find(it.first)==visited.end()){\\n                dfs(adj , it.first , end_node , product*it.second , visited);\\n            }\\n        }\\n        \\n    }\\n \\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        vector<double>anss;\\n        map<string,vector<pair<string , double>>>adj;\\n\\n\\n        for(int i=0 ; i<equations.size() ; i++){\\n            \\n            string a = equations[i][0];\\n            string b = equations[i][1];\\n            double val = values[i];\\n            double inverse_val = 1.0/(val*1.0) ;\\n\\n            adj[a].push_back({b , val});\\n            adj[b].push_back({a , inverse_val});\\n\\n        }\\n \\n\\n        //O(queries.length)\\n\\n        for(int i=0 ; i<queries.size() ; i++){\\n            string curr_node = queries[i][0];\\n            string end_node = queries[i][1];\\n             \\n            //O(log V)\\n\\n            if(adj.find(curr_node)==adj.end() || adj.find(end_node)==adj.end()){\\n                anss.push_back(-1.0);\\n            }else{\\n            set<string>visited;\\n            double product = 1.0;\\n            ans = -1.0;\\n            \\n            // O(V + E*logV)\\n\\n            dfs(adj , curr_node , end_node , product , visited);\\n            anss.push_back(ans);\\n            }\\n        }\\n\\n        // overall Time Complexity is O(queries.length * (log V + (V + E*logV)))\\n\\n\\n\\n        return anss;\\n    }\\n}; @TushaarDTU  "
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "Use unordered_map instead of map.\\n\\nIt will remove the log V part in your complexity.\\n\\nNew TC: O(queries.size() * (V+E))"
                    },
                    {
                        "username": "lordvidex",
                        "content": "what a problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "What an Enlightening Hint!"
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone else here solved it for a-s and b-s only to realize there are also cases like ab/bc? "
                    },
                    {
                        "username": "z3eg",
                        "content": "i mean, x/x should always be 1, even if we don\\'t know what x is. your first testcase is kinda lame ngl"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "considering the constraint that \\n0.0 < values[i] <= 20.0, you are right. from 1 to 20, x/x must be  1.\\n\\nhowever, if these constraints aren\\'t there\\nthen 0/0 is undefined, as well as infinity / infinity is undefined.\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "This is a graph problem."
                    },
                    {
                        "username": "prajjwaljogdand20bcs39",
                        "content": "equations =\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\nvalues =\\n[3.0,4.0,5.0,6.0]\\nqueries =\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\nUse Testcase\\nOutput\\n[360.00000,0.00833,6.66667,1.00000,-1.00000,-1.00000]\\nExpected\\n[360.00000,0.00833,20.00000,1.00000,-1.00000,-1.00000]\\n\\nfor third query x2 and x4 ans should be 20 right  ?\\nx2 / x3 = 4.0 \\nx3 / x4 = 5.0 \\n( x2 / x3 ) * ( x3 / x4 ) = x2 / x4 =  4.0 * 5.0  = 20.00"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "yes you are right.\\nit is 20.00.\\n\\nwhy you are getting 6.6667 though?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "I got confused with the [[\"bc\", \"cd\" ]]  test. I thought it is b*c / c*d.\\n\\nThe problem should be marked Hard though"
                    },
                    {
                        "username": "grapefroot",
                        "content": "You can precompute answers for all queries using a Floyd-Warshall like algorithm"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "where is the God Damn Editorial when we need it !"
                    }
                ]
            },
            {
                "id": 1899996,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone please tell whether the time complexity my code is right or wrong ?\\n\\n\\nclass Solution {\\npublic:\\n\\n    double ans = -1.0;\\n\\n    void dfs(map<string , vector<pair<string , double>>> &adj , string curr_node , string end_node , double product , set<string> &visited){\\n\\n        if(curr_node==end_node){\\n            ans = product;\\n            return;\\n        }\\n        \\n        // O(logV)\\n        visited.insert(curr_node);\\n\\n        for(auto it : adj[curr_node]){\\n            if(visited.find(it.first)==visited.end()){\\n                dfs(adj , it.first , end_node , product*it.second , visited);\\n            }\\n        }\\n        \\n    }\\n \\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        vector<double>anss;\\n        map<string,vector<pair<string , double>>>adj;\\n\\n\\n        for(int i=0 ; i<equations.size() ; i++){\\n            \\n            string a = equations[i][0];\\n            string b = equations[i][1];\\n            double val = values[i];\\n            double inverse_val = 1.0/(val*1.0) ;\\n\\n            adj[a].push_back({b , val});\\n            adj[b].push_back({a , inverse_val});\\n\\n        }\\n \\n\\n        //O(queries.length)\\n\\n        for(int i=0 ; i<queries.size() ; i++){\\n            string curr_node = queries[i][0];\\n            string end_node = queries[i][1];\\n             \\n            //O(log V)\\n\\n            if(adj.find(curr_node)==adj.end() || adj.find(end_node)==adj.end()){\\n                anss.push_back(-1.0);\\n            }else{\\n            set<string>visited;\\n            double product = 1.0;\\n            ans = -1.0;\\n            \\n            // O(V + E*logV)\\n\\n            dfs(adj , curr_node , end_node , product , visited);\\n            anss.push_back(ans);\\n            }\\n        }\\n\\n        // overall Time Complexity is O(queries.length * (log V + (V + E*logV)))\\n\\n\\n\\n        return anss;\\n    }\\n}; @TushaarDTU  "
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "Use unordered_map instead of map.\\n\\nIt will remove the log V part in your complexity.\\n\\nNew TC: O(queries.size() * (V+E))"
                    },
                    {
                        "username": "lordvidex",
                        "content": "what a problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "What an Enlightening Hint!"
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone else here solved it for a-s and b-s only to realize there are also cases like ab/bc? "
                    },
                    {
                        "username": "z3eg",
                        "content": "i mean, x/x should always be 1, even if we don\\'t know what x is. your first testcase is kinda lame ngl"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "considering the constraint that \\n0.0 < values[i] <= 20.0, you are right. from 1 to 20, x/x must be  1.\\n\\nhowever, if these constraints aren\\'t there\\nthen 0/0 is undefined, as well as infinity / infinity is undefined.\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "This is a graph problem."
                    },
                    {
                        "username": "prajjwaljogdand20bcs39",
                        "content": "equations =\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\nvalues =\\n[3.0,4.0,5.0,6.0]\\nqueries =\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\nUse Testcase\\nOutput\\n[360.00000,0.00833,6.66667,1.00000,-1.00000,-1.00000]\\nExpected\\n[360.00000,0.00833,20.00000,1.00000,-1.00000,-1.00000]\\n\\nfor third query x2 and x4 ans should be 20 right  ?\\nx2 / x3 = 4.0 \\nx3 / x4 = 5.0 \\n( x2 / x3 ) * ( x3 / x4 ) = x2 / x4 =  4.0 * 5.0  = 20.00"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "yes you are right.\\nit is 20.00.\\n\\nwhy you are getting 6.6667 though?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "I got confused with the [[\"bc\", \"cd\" ]]  test. I thought it is b*c / c*d.\\n\\nThe problem should be marked Hard though"
                    },
                    {
                        "username": "grapefroot",
                        "content": "You can precompute answers for all queries using a Floyd-Warshall like algorithm"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "where is the God Damn Editorial when we need it !"
                    }
                ]
            },
            {
                "id": 1899962,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone please tell whether the time complexity my code is right or wrong ?\\n\\n\\nclass Solution {\\npublic:\\n\\n    double ans = -1.0;\\n\\n    void dfs(map<string , vector<pair<string , double>>> &adj , string curr_node , string end_node , double product , set<string> &visited){\\n\\n        if(curr_node==end_node){\\n            ans = product;\\n            return;\\n        }\\n        \\n        // O(logV)\\n        visited.insert(curr_node);\\n\\n        for(auto it : adj[curr_node]){\\n            if(visited.find(it.first)==visited.end()){\\n                dfs(adj , it.first , end_node , product*it.second , visited);\\n            }\\n        }\\n        \\n    }\\n \\n\\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\\n        \\n        vector<double>anss;\\n        map<string,vector<pair<string , double>>>adj;\\n\\n\\n        for(int i=0 ; i<equations.size() ; i++){\\n            \\n            string a = equations[i][0];\\n            string b = equations[i][1];\\n            double val = values[i];\\n            double inverse_val = 1.0/(val*1.0) ;\\n\\n            adj[a].push_back({b , val});\\n            adj[b].push_back({a , inverse_val});\\n\\n        }\\n \\n\\n        //O(queries.length)\\n\\n        for(int i=0 ; i<queries.size() ; i++){\\n            string curr_node = queries[i][0];\\n            string end_node = queries[i][1];\\n             \\n            //O(log V)\\n\\n            if(adj.find(curr_node)==adj.end() || adj.find(end_node)==adj.end()){\\n                anss.push_back(-1.0);\\n            }else{\\n            set<string>visited;\\n            double product = 1.0;\\n            ans = -1.0;\\n            \\n            // O(V + E*logV)\\n\\n            dfs(adj , curr_node , end_node , product , visited);\\n            anss.push_back(ans);\\n            }\\n        }\\n\\n        // overall Time Complexity is O(queries.length * (log V + (V + E*logV)))\\n\\n\\n\\n        return anss;\\n    }\\n}; @TushaarDTU  "
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "Use unordered_map instead of map.\\n\\nIt will remove the log V part in your complexity.\\n\\nNew TC: O(queries.size() * (V+E))"
                    },
                    {
                        "username": "lordvidex",
                        "content": "what a problem"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "What an Enlightening Hint!"
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone else here solved it for a-s and b-s only to realize there are also cases like ab/bc? "
                    },
                    {
                        "username": "z3eg",
                        "content": "i mean, x/x should always be 1, even if we don\\'t know what x is. your first testcase is kinda lame ngl"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "considering the constraint that \\n0.0 < values[i] <= 20.0, you are right. from 1 to 20, x/x must be  1.\\n\\nhowever, if these constraints aren\\'t there\\nthen 0/0 is undefined, as well as infinity / infinity is undefined.\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "This is a graph problem."
                    },
                    {
                        "username": "prajjwaljogdand20bcs39",
                        "content": "equations =\\n[[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]]\\nvalues =\\n[3.0,4.0,5.0,6.0]\\nqueries =\\n[[\"x1\",\"x5\"],[\"x5\",\"x2\"],[\"x2\",\"x4\"],[\"x2\",\"x2\"],[\"x2\",\"x9\"],[\"x9\",\"x9\"]]\\nUse Testcase\\nOutput\\n[360.00000,0.00833,6.66667,1.00000,-1.00000,-1.00000]\\nExpected\\n[360.00000,0.00833,20.00000,1.00000,-1.00000,-1.00000]\\n\\nfor third query x2 and x4 ans should be 20 right  ?\\nx2 / x3 = 4.0 \\nx3 / x4 = 5.0 \\n( x2 / x3 ) * ( x3 / x4 ) = x2 / x4 =  4.0 * 5.0  = 20.00"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "yes you are right.\\nit is 20.00.\\n\\nwhy you are getting 6.6667 though?"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "I got confused with the [[\"bc\", \"cd\" ]]  test. I thought it is b*c / c*d.\\n\\nThe problem should be marked Hard though"
                    },
                    {
                        "username": "grapefroot",
                        "content": "You can precompute answers for all queries using a Floyd-Warshall like algorithm"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "where is the God Damn Editorial when we need it !"
                    }
                ]
            },
            {
                "id": 1899949,
                "content": [
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "I have some issue, see if we take  equations as [ [\"a\", \"b\"],[ \"b\", \"c\"] ] and values to be [2.0,3.0] and then if i have a query as [ [\"ab\" , \"bc\"] ],\\nthe system giving it as -1.0 means the answer cannot be concluded. \\nBut we can say it as 6.0 right,\\n$$\\\\frac{a}{b} \\\\frac{b}{c} = \\\\frac{ab}{bc} = 6.0 $$ \\n$b$ can\\'t be zero with the values we have gave so the answer should be 6.0 not -1 . Please someone comment if iam getting something wrong\\n"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "[\"ab\", \"bc\" ] is -1. because the problem says that each string is a single variable.( and not the multiplication of two variables).\\n\\nso consider \"ab\" , \"bc\"  to be new variables, not the multiplications of a*b and b*c.\\n\\nEach Ai or Bi is a string that represents a single variable. = 4th line in problem statement.\\n\\nEven I got confused there but after looking closely I figured out."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) sure :+1:"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@can-keklik](/can-keklik)  Thank you for clarification"
                    },
                    {
                        "username": "can-keklik",
                        "content": "So \"ab\" is not equal \"a * b\", but rather, it is a separate variable. So you shouldn't decompose it into characters. This was not explained well in the description, I thought the same in the beginning."
                    },
                    {
                        "username": "jeshupatelg3774",
                        "content": "Definitely a hard question(on the lower spectrum of hards..). Too proud of myself when i saw the hint screaming graph after successful submission.... kudos to leetcode daily challenge."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Easy Question But Problem Description is Very bad"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why equation aa/bb=2 and query a/b returns -1? And the same for the reverse: input a/b=2, query aa/bb=-1."
                    },
                    {
                        "username": "EricRaw",
                        "content": "The variable \"aa\" is not the same as \"a\" multiplied by \"a\". Similarly, \"bb\" is not the same as \"b\" multiplied by \"b\". Therefore, the expression a/b returns -1 because the variables a and b do not exist in the equation.\n\nThe reverse is also true. If the variables in the equation are \"a\" and \"b\", you cannot multiply \"a\" and \"a\" to get \"aa\" or \"b\" and \"b\" to get \"bb\".\n\nThis is because the variables in the equation are defined as \"a\" and \"b\", and there is no variable called \"aa\" or \"bb\"."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Tough one today, but we got there in the end. Absolutely went over my time limit, but I think the problem difficulty might need some changing too T_T"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Nice try, but I still don\\'t have time to learn graph."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "In lieu of solving this problem, I would like to waste my time watching IPL match today."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Wrote 115 lines of code, never seemed a medium level problem throughout the coding process :/"
                    },
                    {
                        "username": "octothorpe27",
                        "content": "idk how, but i got the intuition that it is a graph problem after thinking for only 3-4 minutes...simple dfs but implementing it was not easy. but solved it at the end..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use DFS....yes u read correct this is a graph problem .Initially I also didn\\'t though."
                    }
                ]
            },
            {
                "id": 1899908,
                "content": [
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "I have some issue, see if we take  equations as [ [\"a\", \"b\"],[ \"b\", \"c\"] ] and values to be [2.0,3.0] and then if i have a query as [ [\"ab\" , \"bc\"] ],\\nthe system giving it as -1.0 means the answer cannot be concluded. \\nBut we can say it as 6.0 right,\\n$$\\\\frac{a}{b} \\\\frac{b}{c} = \\\\frac{ab}{bc} = 6.0 $$ \\n$b$ can\\'t be zero with the values we have gave so the answer should be 6.0 not -1 . Please someone comment if iam getting something wrong\\n"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "[\"ab\", \"bc\" ] is -1. because the problem says that each string is a single variable.( and not the multiplication of two variables).\\n\\nso consider \"ab\" , \"bc\"  to be new variables, not the multiplications of a*b and b*c.\\n\\nEach Ai or Bi is a string that represents a single variable. = 4th line in problem statement.\\n\\nEven I got confused there but after looking closely I figured out."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) sure :+1:"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@can-keklik](/can-keklik)  Thank you for clarification"
                    },
                    {
                        "username": "can-keklik",
                        "content": "So \"ab\" is not equal \"a * b\", but rather, it is a separate variable. So you shouldn't decompose it into characters. This was not explained well in the description, I thought the same in the beginning."
                    },
                    {
                        "username": "jeshupatelg3774",
                        "content": "Definitely a hard question(on the lower spectrum of hards..). Too proud of myself when i saw the hint screaming graph after successful submission.... kudos to leetcode daily challenge."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Easy Question But Problem Description is Very bad"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why equation aa/bb=2 and query a/b returns -1? And the same for the reverse: input a/b=2, query aa/bb=-1."
                    },
                    {
                        "username": "EricRaw",
                        "content": "The variable \"aa\" is not the same as \"a\" multiplied by \"a\". Similarly, \"bb\" is not the same as \"b\" multiplied by \"b\". Therefore, the expression a/b returns -1 because the variables a and b do not exist in the equation.\n\nThe reverse is also true. If the variables in the equation are \"a\" and \"b\", you cannot multiply \"a\" and \"a\" to get \"aa\" or \"b\" and \"b\" to get \"bb\".\n\nThis is because the variables in the equation are defined as \"a\" and \"b\", and there is no variable called \"aa\" or \"bb\"."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Tough one today, but we got there in the end. Absolutely went over my time limit, but I think the problem difficulty might need some changing too T_T"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Nice try, but I still don\\'t have time to learn graph."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "In lieu of solving this problem, I would like to waste my time watching IPL match today."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Wrote 115 lines of code, never seemed a medium level problem throughout the coding process :/"
                    },
                    {
                        "username": "octothorpe27",
                        "content": "idk how, but i got the intuition that it is a graph problem after thinking for only 3-4 minutes...simple dfs but implementing it was not easy. but solved it at the end..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use DFS....yes u read correct this is a graph problem .Initially I also didn\\'t though."
                    }
                ]
            },
            {
                "id": 1899898,
                "content": [
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "I have some issue, see if we take  equations as [ [\"a\", \"b\"],[ \"b\", \"c\"] ] and values to be [2.0,3.0] and then if i have a query as [ [\"ab\" , \"bc\"] ],\\nthe system giving it as -1.0 means the answer cannot be concluded. \\nBut we can say it as 6.0 right,\\n$$\\\\frac{a}{b} \\\\frac{b}{c} = \\\\frac{ab}{bc} = 6.0 $$ \\n$b$ can\\'t be zero with the values we have gave so the answer should be 6.0 not -1 . Please someone comment if iam getting something wrong\\n"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "[\"ab\", \"bc\" ] is -1. because the problem says that each string is a single variable.( and not the multiplication of two variables).\\n\\nso consider \"ab\" , \"bc\"  to be new variables, not the multiplications of a*b and b*c.\\n\\nEach Ai or Bi is a string that represents a single variable. = 4th line in problem statement.\\n\\nEven I got confused there but after looking closely I figured out."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) sure :+1:"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@can-keklik](/can-keklik)  Thank you for clarification"
                    },
                    {
                        "username": "can-keklik",
                        "content": "So \"ab\" is not equal \"a * b\", but rather, it is a separate variable. So you shouldn't decompose it into characters. This was not explained well in the description, I thought the same in the beginning."
                    },
                    {
                        "username": "jeshupatelg3774",
                        "content": "Definitely a hard question(on the lower spectrum of hards..). Too proud of myself when i saw the hint screaming graph after successful submission.... kudos to leetcode daily challenge."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Easy Question But Problem Description is Very bad"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why equation aa/bb=2 and query a/b returns -1? And the same for the reverse: input a/b=2, query aa/bb=-1."
                    },
                    {
                        "username": "EricRaw",
                        "content": "The variable \"aa\" is not the same as \"a\" multiplied by \"a\". Similarly, \"bb\" is not the same as \"b\" multiplied by \"b\". Therefore, the expression a/b returns -1 because the variables a and b do not exist in the equation.\n\nThe reverse is also true. If the variables in the equation are \"a\" and \"b\", you cannot multiply \"a\" and \"a\" to get \"aa\" or \"b\" and \"b\" to get \"bb\".\n\nThis is because the variables in the equation are defined as \"a\" and \"b\", and there is no variable called \"aa\" or \"bb\"."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Tough one today, but we got there in the end. Absolutely went over my time limit, but I think the problem difficulty might need some changing too T_T"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Nice try, but I still don\\'t have time to learn graph."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "In lieu of solving this problem, I would like to waste my time watching IPL match today."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Wrote 115 lines of code, never seemed a medium level problem throughout the coding process :/"
                    },
                    {
                        "username": "octothorpe27",
                        "content": "idk how, but i got the intuition that it is a graph problem after thinking for only 3-4 minutes...simple dfs but implementing it was not easy. but solved it at the end..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use DFS....yes u read correct this is a graph problem .Initially I also didn\\'t though."
                    }
                ]
            },
            {
                "id": 1899789,
                "content": [
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "I have some issue, see if we take  equations as [ [\"a\", \"b\"],[ \"b\", \"c\"] ] and values to be [2.0,3.0] and then if i have a query as [ [\"ab\" , \"bc\"] ],\\nthe system giving it as -1.0 means the answer cannot be concluded. \\nBut we can say it as 6.0 right,\\n$$\\\\frac{a}{b} \\\\frac{b}{c} = \\\\frac{ab}{bc} = 6.0 $$ \\n$b$ can\\'t be zero with the values we have gave so the answer should be 6.0 not -1 . Please someone comment if iam getting something wrong\\n"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "[\"ab\", \"bc\" ] is -1. because the problem says that each string is a single variable.( and not the multiplication of two variables).\\n\\nso consider \"ab\" , \"bc\"  to be new variables, not the multiplications of a*b and b*c.\\n\\nEach Ai or Bi is a string that represents a single variable. = 4th line in problem statement.\\n\\nEven I got confused there but after looking closely I figured out."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) sure :+1:"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@can-keklik](/can-keklik)  Thank you for clarification"
                    },
                    {
                        "username": "can-keklik",
                        "content": "So \"ab\" is not equal \"a * b\", but rather, it is a separate variable. So you shouldn't decompose it into characters. This was not explained well in the description, I thought the same in the beginning."
                    },
                    {
                        "username": "jeshupatelg3774",
                        "content": "Definitely a hard question(on the lower spectrum of hards..). Too proud of myself when i saw the hint screaming graph after successful submission.... kudos to leetcode daily challenge."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Easy Question But Problem Description is Very bad"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why equation aa/bb=2 and query a/b returns -1? And the same for the reverse: input a/b=2, query aa/bb=-1."
                    },
                    {
                        "username": "EricRaw",
                        "content": "The variable \"aa\" is not the same as \"a\" multiplied by \"a\". Similarly, \"bb\" is not the same as \"b\" multiplied by \"b\". Therefore, the expression a/b returns -1 because the variables a and b do not exist in the equation.\n\nThe reverse is also true. If the variables in the equation are \"a\" and \"b\", you cannot multiply \"a\" and \"a\" to get \"aa\" or \"b\" and \"b\" to get \"bb\".\n\nThis is because the variables in the equation are defined as \"a\" and \"b\", and there is no variable called \"aa\" or \"bb\"."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Tough one today, but we got there in the end. Absolutely went over my time limit, but I think the problem difficulty might need some changing too T_T"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Nice try, but I still don\\'t have time to learn graph."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "In lieu of solving this problem, I would like to waste my time watching IPL match today."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Wrote 115 lines of code, never seemed a medium level problem throughout the coding process :/"
                    },
                    {
                        "username": "octothorpe27",
                        "content": "idk how, but i got the intuition that it is a graph problem after thinking for only 3-4 minutes...simple dfs but implementing it was not easy. but solved it at the end..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use DFS....yes u read correct this is a graph problem .Initially I also didn\\'t though."
                    }
                ]
            },
            {
                "id": 1899747,
                "content": [
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "I have some issue, see if we take  equations as [ [\"a\", \"b\"],[ \"b\", \"c\"] ] and values to be [2.0,3.0] and then if i have a query as [ [\"ab\" , \"bc\"] ],\\nthe system giving it as -1.0 means the answer cannot be concluded. \\nBut we can say it as 6.0 right,\\n$$\\\\frac{a}{b} \\\\frac{b}{c} = \\\\frac{ab}{bc} = 6.0 $$ \\n$b$ can\\'t be zero with the values we have gave so the answer should be 6.0 not -1 . Please someone comment if iam getting something wrong\\n"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "[\"ab\", \"bc\" ] is -1. because the problem says that each string is a single variable.( and not the multiplication of two variables).\\n\\nso consider \"ab\" , \"bc\"  to be new variables, not the multiplications of a*b and b*c.\\n\\nEach Ai or Bi is a string that represents a single variable. = 4th line in problem statement.\\n\\nEven I got confused there but after looking closely I figured out."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) sure :+1:"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@can-keklik](/can-keklik)  Thank you for clarification"
                    },
                    {
                        "username": "can-keklik",
                        "content": "So \"ab\" is not equal \"a * b\", but rather, it is a separate variable. So you shouldn't decompose it into characters. This was not explained well in the description, I thought the same in the beginning."
                    },
                    {
                        "username": "jeshupatelg3774",
                        "content": "Definitely a hard question(on the lower spectrum of hards..). Too proud of myself when i saw the hint screaming graph after successful submission.... kudos to leetcode daily challenge."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Easy Question But Problem Description is Very bad"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why equation aa/bb=2 and query a/b returns -1? And the same for the reverse: input a/b=2, query aa/bb=-1."
                    },
                    {
                        "username": "EricRaw",
                        "content": "The variable \"aa\" is not the same as \"a\" multiplied by \"a\". Similarly, \"bb\" is not the same as \"b\" multiplied by \"b\". Therefore, the expression a/b returns -1 because the variables a and b do not exist in the equation.\n\nThe reverse is also true. If the variables in the equation are \"a\" and \"b\", you cannot multiply \"a\" and \"a\" to get \"aa\" or \"b\" and \"b\" to get \"bb\".\n\nThis is because the variables in the equation are defined as \"a\" and \"b\", and there is no variable called \"aa\" or \"bb\"."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Tough one today, but we got there in the end. Absolutely went over my time limit, but I think the problem difficulty might need some changing too T_T"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Nice try, but I still don\\'t have time to learn graph."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "In lieu of solving this problem, I would like to waste my time watching IPL match today."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Wrote 115 lines of code, never seemed a medium level problem throughout the coding process :/"
                    },
                    {
                        "username": "octothorpe27",
                        "content": "idk how, but i got the intuition that it is a graph problem after thinking for only 3-4 minutes...simple dfs but implementing it was not easy. but solved it at the end..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use DFS....yes u read correct this is a graph problem .Initially I also didn\\'t though."
                    }
                ]
            },
            {
                "id": 1899724,
                "content": [
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "I have some issue, see if we take  equations as [ [\"a\", \"b\"],[ \"b\", \"c\"] ] and values to be [2.0,3.0] and then if i have a query as [ [\"ab\" , \"bc\"] ],\\nthe system giving it as -1.0 means the answer cannot be concluded. \\nBut we can say it as 6.0 right,\\n$$\\\\frac{a}{b} \\\\frac{b}{c} = \\\\frac{ab}{bc} = 6.0 $$ \\n$b$ can\\'t be zero with the values we have gave so the answer should be 6.0 not -1 . Please someone comment if iam getting something wrong\\n"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "[\"ab\", \"bc\" ] is -1. because the problem says that each string is a single variable.( and not the multiplication of two variables).\\n\\nso consider \"ab\" , \"bc\"  to be new variables, not the multiplications of a*b and b*c.\\n\\nEach Ai or Bi is a string that represents a single variable. = 4th line in problem statement.\\n\\nEven I got confused there but after looking closely I figured out."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) sure :+1:"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@can-keklik](/can-keklik)  Thank you for clarification"
                    },
                    {
                        "username": "can-keklik",
                        "content": "So \"ab\" is not equal \"a * b\", but rather, it is a separate variable. So you shouldn't decompose it into characters. This was not explained well in the description, I thought the same in the beginning."
                    },
                    {
                        "username": "jeshupatelg3774",
                        "content": "Definitely a hard question(on the lower spectrum of hards..). Too proud of myself when i saw the hint screaming graph after successful submission.... kudos to leetcode daily challenge."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Easy Question But Problem Description is Very bad"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why equation aa/bb=2 and query a/b returns -1? And the same for the reverse: input a/b=2, query aa/bb=-1."
                    },
                    {
                        "username": "EricRaw",
                        "content": "The variable \"aa\" is not the same as \"a\" multiplied by \"a\". Similarly, \"bb\" is not the same as \"b\" multiplied by \"b\". Therefore, the expression a/b returns -1 because the variables a and b do not exist in the equation.\n\nThe reverse is also true. If the variables in the equation are \"a\" and \"b\", you cannot multiply \"a\" and \"a\" to get \"aa\" or \"b\" and \"b\" to get \"bb\".\n\nThis is because the variables in the equation are defined as \"a\" and \"b\", and there is no variable called \"aa\" or \"bb\"."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Tough one today, but we got there in the end. Absolutely went over my time limit, but I think the problem difficulty might need some changing too T_T"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Nice try, but I still don\\'t have time to learn graph."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "In lieu of solving this problem, I would like to waste my time watching IPL match today."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Wrote 115 lines of code, never seemed a medium level problem throughout the coding process :/"
                    },
                    {
                        "username": "octothorpe27",
                        "content": "idk how, but i got the intuition that it is a graph problem after thinking for only 3-4 minutes...simple dfs but implementing it was not easy. but solved it at the end..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use DFS....yes u read correct this is a graph problem .Initially I also didn\\'t though."
                    }
                ]
            },
            {
                "id": 1899676,
                "content": [
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "I have some issue, see if we take  equations as [ [\"a\", \"b\"],[ \"b\", \"c\"] ] and values to be [2.0,3.0] and then if i have a query as [ [\"ab\" , \"bc\"] ],\\nthe system giving it as -1.0 means the answer cannot be concluded. \\nBut we can say it as 6.0 right,\\n$$\\\\frac{a}{b} \\\\frac{b}{c} = \\\\frac{ab}{bc} = 6.0 $$ \\n$b$ can\\'t be zero with the values we have gave so the answer should be 6.0 not -1 . Please someone comment if iam getting something wrong\\n"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "[\"ab\", \"bc\" ] is -1. because the problem says that each string is a single variable.( and not the multiplication of two variables).\\n\\nso consider \"ab\" , \"bc\"  to be new variables, not the multiplications of a*b and b*c.\\n\\nEach Ai or Bi is a string that represents a single variable. = 4th line in problem statement.\\n\\nEven I got confused there but after looking closely I figured out."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) sure :+1:"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@can-keklik](/can-keklik)  Thank you for clarification"
                    },
                    {
                        "username": "can-keklik",
                        "content": "So \"ab\" is not equal \"a * b\", but rather, it is a separate variable. So you shouldn't decompose it into characters. This was not explained well in the description, I thought the same in the beginning."
                    },
                    {
                        "username": "jeshupatelg3774",
                        "content": "Definitely a hard question(on the lower spectrum of hards..). Too proud of myself when i saw the hint screaming graph after successful submission.... kudos to leetcode daily challenge."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Easy Question But Problem Description is Very bad"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why equation aa/bb=2 and query a/b returns -1? And the same for the reverse: input a/b=2, query aa/bb=-1."
                    },
                    {
                        "username": "EricRaw",
                        "content": "The variable \"aa\" is not the same as \"a\" multiplied by \"a\". Similarly, \"bb\" is not the same as \"b\" multiplied by \"b\". Therefore, the expression a/b returns -1 because the variables a and b do not exist in the equation.\n\nThe reverse is also true. If the variables in the equation are \"a\" and \"b\", you cannot multiply \"a\" and \"a\" to get \"aa\" or \"b\" and \"b\" to get \"bb\".\n\nThis is because the variables in the equation are defined as \"a\" and \"b\", and there is no variable called \"aa\" or \"bb\"."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Tough one today, but we got there in the end. Absolutely went over my time limit, but I think the problem difficulty might need some changing too T_T"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Nice try, but I still don\\'t have time to learn graph."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "In lieu of solving this problem, I would like to waste my time watching IPL match today."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Wrote 115 lines of code, never seemed a medium level problem throughout the coding process :/"
                    },
                    {
                        "username": "octothorpe27",
                        "content": "idk how, but i got the intuition that it is a graph problem after thinking for only 3-4 minutes...simple dfs but implementing it was not easy. but solved it at the end..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use DFS....yes u read correct this is a graph problem .Initially I also didn\\'t though."
                    }
                ]
            },
            {
                "id": 1899670,
                "content": [
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "I have some issue, see if we take  equations as [ [\"a\", \"b\"],[ \"b\", \"c\"] ] and values to be [2.0,3.0] and then if i have a query as [ [\"ab\" , \"bc\"] ],\\nthe system giving it as -1.0 means the answer cannot be concluded. \\nBut we can say it as 6.0 right,\\n$$\\\\frac{a}{b} \\\\frac{b}{c} = \\\\frac{ab}{bc} = 6.0 $$ \\n$b$ can\\'t be zero with the values we have gave so the answer should be 6.0 not -1 . Please someone comment if iam getting something wrong\\n"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "[\"ab\", \"bc\" ] is -1. because the problem says that each string is a single variable.( and not the multiplication of two variables).\\n\\nso consider \"ab\" , \"bc\"  to be new variables, not the multiplications of a*b and b*c.\\n\\nEach Ai or Bi is a string that represents a single variable. = 4th line in problem statement.\\n\\nEven I got confused there but after looking closely I figured out."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) sure :+1:"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@can-keklik](/can-keklik)  Thank you for clarification"
                    },
                    {
                        "username": "can-keklik",
                        "content": "So \"ab\" is not equal \"a * b\", but rather, it is a separate variable. So you shouldn't decompose it into characters. This was not explained well in the description, I thought the same in the beginning."
                    },
                    {
                        "username": "jeshupatelg3774",
                        "content": "Definitely a hard question(on the lower spectrum of hards..). Too proud of myself when i saw the hint screaming graph after successful submission.... kudos to leetcode daily challenge."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Easy Question But Problem Description is Very bad"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why equation aa/bb=2 and query a/b returns -1? And the same for the reverse: input a/b=2, query aa/bb=-1."
                    },
                    {
                        "username": "EricRaw",
                        "content": "The variable \"aa\" is not the same as \"a\" multiplied by \"a\". Similarly, \"bb\" is not the same as \"b\" multiplied by \"b\". Therefore, the expression a/b returns -1 because the variables a and b do not exist in the equation.\n\nThe reverse is also true. If the variables in the equation are \"a\" and \"b\", you cannot multiply \"a\" and \"a\" to get \"aa\" or \"b\" and \"b\" to get \"bb\".\n\nThis is because the variables in the equation are defined as \"a\" and \"b\", and there is no variable called \"aa\" or \"bb\"."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Tough one today, but we got there in the end. Absolutely went over my time limit, but I think the problem difficulty might need some changing too T_T"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Nice try, but I still don\\'t have time to learn graph."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "In lieu of solving this problem, I would like to waste my time watching IPL match today."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Wrote 115 lines of code, never seemed a medium level problem throughout the coding process :/"
                    },
                    {
                        "username": "octothorpe27",
                        "content": "idk how, but i got the intuition that it is a graph problem after thinking for only 3-4 minutes...simple dfs but implementing it was not easy. but solved it at the end..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use DFS....yes u read correct this is a graph problem .Initially I also didn\\'t though."
                    }
                ]
            },
            {
                "id": 1899662,
                "content": [
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "I have some issue, see if we take  equations as [ [\"a\", \"b\"],[ \"b\", \"c\"] ] and values to be [2.0,3.0] and then if i have a query as [ [\"ab\" , \"bc\"] ],\\nthe system giving it as -1.0 means the answer cannot be concluded. \\nBut we can say it as 6.0 right,\\n$$\\\\frac{a}{b} \\\\frac{b}{c} = \\\\frac{ab}{bc} = 6.0 $$ \\n$b$ can\\'t be zero with the values we have gave so the answer should be 6.0 not -1 . Please someone comment if iam getting something wrong\\n"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "[\"ab\", \"bc\" ] is -1. because the problem says that each string is a single variable.( and not the multiplication of two variables).\\n\\nso consider \"ab\" , \"bc\"  to be new variables, not the multiplications of a*b and b*c.\\n\\nEach Ai or Bi is a string that represents a single variable. = 4th line in problem statement.\\n\\nEven I got confused there but after looking closely I figured out."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) sure :+1:"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@can-keklik](/can-keklik)  Thank you for clarification"
                    },
                    {
                        "username": "can-keklik",
                        "content": "So \"ab\" is not equal \"a * b\", but rather, it is a separate variable. So you shouldn't decompose it into characters. This was not explained well in the description, I thought the same in the beginning."
                    },
                    {
                        "username": "jeshupatelg3774",
                        "content": "Definitely a hard question(on the lower spectrum of hards..). Too proud of myself when i saw the hint screaming graph after successful submission.... kudos to leetcode daily challenge."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Easy Question But Problem Description is Very bad"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why equation aa/bb=2 and query a/b returns -1? And the same for the reverse: input a/b=2, query aa/bb=-1."
                    },
                    {
                        "username": "EricRaw",
                        "content": "The variable \"aa\" is not the same as \"a\" multiplied by \"a\". Similarly, \"bb\" is not the same as \"b\" multiplied by \"b\". Therefore, the expression a/b returns -1 because the variables a and b do not exist in the equation.\n\nThe reverse is also true. If the variables in the equation are \"a\" and \"b\", you cannot multiply \"a\" and \"a\" to get \"aa\" or \"b\" and \"b\" to get \"bb\".\n\nThis is because the variables in the equation are defined as \"a\" and \"b\", and there is no variable called \"aa\" or \"bb\"."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Tough one today, but we got there in the end. Absolutely went over my time limit, but I think the problem difficulty might need some changing too T_T"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Nice try, but I still don\\'t have time to learn graph."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "In lieu of solving this problem, I would like to waste my time watching IPL match today."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Wrote 115 lines of code, never seemed a medium level problem throughout the coding process :/"
                    },
                    {
                        "username": "octothorpe27",
                        "content": "idk how, but i got the intuition that it is a graph problem after thinking for only 3-4 minutes...simple dfs but implementing it was not easy. but solved it at the end..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use DFS....yes u read correct this is a graph problem .Initially I also didn\\'t though."
                    }
                ]
            },
            {
                "id": 1899612,
                "content": [
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "I have some issue, see if we take  equations as [ [\"a\", \"b\"],[ \"b\", \"c\"] ] and values to be [2.0,3.0] and then if i have a query as [ [\"ab\" , \"bc\"] ],\\nthe system giving it as -1.0 means the answer cannot be concluded. \\nBut we can say it as 6.0 right,\\n$$\\\\frac{a}{b} \\\\frac{b}{c} = \\\\frac{ab}{bc} = 6.0 $$ \\n$b$ can\\'t be zero with the values we have gave so the answer should be 6.0 not -1 . Please someone comment if iam getting something wrong\\n"
                    },
                    {
                        "username": "LEGENDVISHAL",
                        "content": "[\"ab\", \"bc\" ] is -1. because the problem says that each string is a single variable.( and not the multiplication of two variables).\\n\\nso consider \"ab\" , \"bc\"  to be new variables, not the multiplications of a*b and b*c.\\n\\nEach Ai or Bi is a string that represents a single variable. = 4th line in problem statement.\\n\\nEven I got confused there but after looking closely I figured out."
                    },
                    {
                        "username": "can-keklik",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) sure :+1:"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "[@can-keklik](/can-keklik)  Thank you for clarification"
                    },
                    {
                        "username": "can-keklik",
                        "content": "So \"ab\" is not equal \"a * b\", but rather, it is a separate variable. So you shouldn't decompose it into characters. This was not explained well in the description, I thought the same in the beginning."
                    },
                    {
                        "username": "jeshupatelg3774",
                        "content": "Definitely a hard question(on the lower spectrum of hards..). Too proud of myself when i saw the hint screaming graph after successful submission.... kudos to leetcode daily challenge."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Easy Question But Problem Description is Very bad"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why equation aa/bb=2 and query a/b returns -1? And the same for the reverse: input a/b=2, query aa/bb=-1."
                    },
                    {
                        "username": "EricRaw",
                        "content": "The variable \"aa\" is not the same as \"a\" multiplied by \"a\". Similarly, \"bb\" is not the same as \"b\" multiplied by \"b\". Therefore, the expression a/b returns -1 because the variables a and b do not exist in the equation.\n\nThe reverse is also true. If the variables in the equation are \"a\" and \"b\", you cannot multiply \"a\" and \"a\" to get \"aa\" or \"b\" and \"b\" to get \"bb\".\n\nThis is because the variables in the equation are defined as \"a\" and \"b\", and there is no variable called \"aa\" or \"bb\"."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Tough one today, but we got there in the end. Absolutely went over my time limit, but I think the problem difficulty might need some changing too T_T"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Nice try, but I still don\\'t have time to learn graph."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "In lieu of solving this problem, I would like to waste my time watching IPL match today."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Wrote 115 lines of code, never seemed a medium level problem throughout the coding process :/"
                    },
                    {
                        "username": "octothorpe27",
                        "content": "idk how, but i got the intuition that it is a graph problem after thinking for only 3-4 minutes...simple dfs but implementing it was not easy. but solved it at the end..\\uD83D\\uDE0A"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use DFS....yes u read correct this is a graph problem .Initially I also didn\\'t though."
                    }
                ]
            },
            {
                "id": 1899611,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "If it is garanteed that there is no division by 0 (as the problem states), then we know the result of x/x, even if x is not in the list of equations.\\nI don;t think the result should be -1 in that case (we know it is 1, regardless of the value of x)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "This is a pretty simple graph problem only.. but implementing it with strings is a pain in the ass to say the least. This could be categorised as a medium problem if you consider just the algorithm, but is a whole another beast to implemen the same."
                    },
                    {
                        "username": "theRadFad",
                        "content": "It\\'s just a bit more laborious work, shouldn\\'t push it to hard"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it wasnt very intuitive for me to think of this as a graph problem. but after seeing the hint, i solved it in about 10 minutes"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "equations[i] = [Ai, Bi]\\nIn equation, the variable will not be equal right? Only 2 different variables exist in a pair right?\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "\"Each Ai or Bi is a string that represents a single variable.\"\\n\\nit implies that Ai and Bi will not be the same variable."
                    },
                    {
                        "username": "nshntsharma86",
                        "content": "This is one of the most brain puzzling question. It is definately hard"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "ooh ,I forgot  this was a graph week"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "applying bfs is giving its answer , but how can we ensure that ,by using it , it will give the shortest path between two nodes"
                    },
                    {
                        "username": "judgementdey",
                        "content": "It is not necessary to compute the shortest path per se. Any path from the numerator to the denominator will help you find the answer. That\\'s why DFS also works, not just BFS.\\n\\nThe maximum number of edges is 20, so it isn\\'t necessary to optimize for the shortest path."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "what if test cases given are \\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\nlogically we can solve this but according to leetcode answer is -1 :).\\ncan anyone explain "
                    },
                    {
                        "username": "c4tdog",
                        "content": "ac != a * c"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hm, I didn't even think about graphs and just solved it head-on as a system of simple mathematical equations.\nhttps://leetcode.com/problems/evaluate-division/solutions/3543258/simple-brute-force-solution/"
                    },
                    {
                        "username": "theRadFad",
                        "content": "If it works, it works"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode has a way of misleading us, not only in undistinguishing between hard and medium questions but also between Saturday and Sunday. BTW, I didn\\'t give it a shot, but the description says it all."
                    }
                ]
            },
            {
                "id": 1899596,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "If it is garanteed that there is no division by 0 (as the problem states), then we know the result of x/x, even if x is not in the list of equations.\\nI don;t think the result should be -1 in that case (we know it is 1, regardless of the value of x)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "This is a pretty simple graph problem only.. but implementing it with strings is a pain in the ass to say the least. This could be categorised as a medium problem if you consider just the algorithm, but is a whole another beast to implemen the same."
                    },
                    {
                        "username": "theRadFad",
                        "content": "It\\'s just a bit more laborious work, shouldn\\'t push it to hard"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it wasnt very intuitive for me to think of this as a graph problem. but after seeing the hint, i solved it in about 10 minutes"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "equations[i] = [Ai, Bi]\\nIn equation, the variable will not be equal right? Only 2 different variables exist in a pair right?\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "\"Each Ai or Bi is a string that represents a single variable.\"\\n\\nit implies that Ai and Bi will not be the same variable."
                    },
                    {
                        "username": "nshntsharma86",
                        "content": "This is one of the most brain puzzling question. It is definately hard"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "ooh ,I forgot  this was a graph week"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "applying bfs is giving its answer , but how can we ensure that ,by using it , it will give the shortest path between two nodes"
                    },
                    {
                        "username": "judgementdey",
                        "content": "It is not necessary to compute the shortest path per se. Any path from the numerator to the denominator will help you find the answer. That\\'s why DFS also works, not just BFS.\\n\\nThe maximum number of edges is 20, so it isn\\'t necessary to optimize for the shortest path."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "what if test cases given are \\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\nlogically we can solve this but according to leetcode answer is -1 :).\\ncan anyone explain "
                    },
                    {
                        "username": "c4tdog",
                        "content": "ac != a * c"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hm, I didn't even think about graphs and just solved it head-on as a system of simple mathematical equations.\nhttps://leetcode.com/problems/evaluate-division/solutions/3543258/simple-brute-force-solution/"
                    },
                    {
                        "username": "theRadFad",
                        "content": "If it works, it works"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode has a way of misleading us, not only in undistinguishing between hard and medium questions but also between Saturday and Sunday. BTW, I didn\\'t give it a shot, but the description says it all."
                    }
                ]
            },
            {
                "id": 1899544,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "If it is garanteed that there is no division by 0 (as the problem states), then we know the result of x/x, even if x is not in the list of equations.\\nI don;t think the result should be -1 in that case (we know it is 1, regardless of the value of x)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "This is a pretty simple graph problem only.. but implementing it with strings is a pain in the ass to say the least. This could be categorised as a medium problem if you consider just the algorithm, but is a whole another beast to implemen the same."
                    },
                    {
                        "username": "theRadFad",
                        "content": "It\\'s just a bit more laborious work, shouldn\\'t push it to hard"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it wasnt very intuitive for me to think of this as a graph problem. but after seeing the hint, i solved it in about 10 minutes"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "equations[i] = [Ai, Bi]\\nIn equation, the variable will not be equal right? Only 2 different variables exist in a pair right?\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "\"Each Ai or Bi is a string that represents a single variable.\"\\n\\nit implies that Ai and Bi will not be the same variable."
                    },
                    {
                        "username": "nshntsharma86",
                        "content": "This is one of the most brain puzzling question. It is definately hard"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "ooh ,I forgot  this was a graph week"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "applying bfs is giving its answer , but how can we ensure that ,by using it , it will give the shortest path between two nodes"
                    },
                    {
                        "username": "judgementdey",
                        "content": "It is not necessary to compute the shortest path per se. Any path from the numerator to the denominator will help you find the answer. That\\'s why DFS also works, not just BFS.\\n\\nThe maximum number of edges is 20, so it isn\\'t necessary to optimize for the shortest path."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "what if test cases given are \\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\nlogically we can solve this but according to leetcode answer is -1 :).\\ncan anyone explain "
                    },
                    {
                        "username": "c4tdog",
                        "content": "ac != a * c"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hm, I didn't even think about graphs and just solved it head-on as a system of simple mathematical equations.\nhttps://leetcode.com/problems/evaluate-division/solutions/3543258/simple-brute-force-solution/"
                    },
                    {
                        "username": "theRadFad",
                        "content": "If it works, it works"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode has a way of misleading us, not only in undistinguishing between hard and medium questions but also between Saturday and Sunday. BTW, I didn\\'t give it a shot, but the description says it all."
                    }
                ]
            },
            {
                "id": 1899542,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "If it is garanteed that there is no division by 0 (as the problem states), then we know the result of x/x, even if x is not in the list of equations.\\nI don;t think the result should be -1 in that case (we know it is 1, regardless of the value of x)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "This is a pretty simple graph problem only.. but implementing it with strings is a pain in the ass to say the least. This could be categorised as a medium problem if you consider just the algorithm, but is a whole another beast to implemen the same."
                    },
                    {
                        "username": "theRadFad",
                        "content": "It\\'s just a bit more laborious work, shouldn\\'t push it to hard"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it wasnt very intuitive for me to think of this as a graph problem. but after seeing the hint, i solved it in about 10 minutes"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "equations[i] = [Ai, Bi]\\nIn equation, the variable will not be equal right? Only 2 different variables exist in a pair right?\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "\"Each Ai or Bi is a string that represents a single variable.\"\\n\\nit implies that Ai and Bi will not be the same variable."
                    },
                    {
                        "username": "nshntsharma86",
                        "content": "This is one of the most brain puzzling question. It is definately hard"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "ooh ,I forgot  this was a graph week"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "applying bfs is giving its answer , but how can we ensure that ,by using it , it will give the shortest path between two nodes"
                    },
                    {
                        "username": "judgementdey",
                        "content": "It is not necessary to compute the shortest path per se. Any path from the numerator to the denominator will help you find the answer. That\\'s why DFS also works, not just BFS.\\n\\nThe maximum number of edges is 20, so it isn\\'t necessary to optimize for the shortest path."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "what if test cases given are \\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\nlogically we can solve this but according to leetcode answer is -1 :).\\ncan anyone explain "
                    },
                    {
                        "username": "c4tdog",
                        "content": "ac != a * c"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hm, I didn't even think about graphs and just solved it head-on as a system of simple mathematical equations.\nhttps://leetcode.com/problems/evaluate-division/solutions/3543258/simple-brute-force-solution/"
                    },
                    {
                        "username": "theRadFad",
                        "content": "If it works, it works"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode has a way of misleading us, not only in undistinguishing between hard and medium questions but also between Saturday and Sunday. BTW, I didn\\'t give it a shot, but the description says it all."
                    }
                ]
            },
            {
                "id": 1899534,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "If it is garanteed that there is no division by 0 (as the problem states), then we know the result of x/x, even if x is not in the list of equations.\\nI don;t think the result should be -1 in that case (we know it is 1, regardless of the value of x)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "This is a pretty simple graph problem only.. but implementing it with strings is a pain in the ass to say the least. This could be categorised as a medium problem if you consider just the algorithm, but is a whole another beast to implemen the same."
                    },
                    {
                        "username": "theRadFad",
                        "content": "It\\'s just a bit more laborious work, shouldn\\'t push it to hard"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it wasnt very intuitive for me to think of this as a graph problem. but after seeing the hint, i solved it in about 10 minutes"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "equations[i] = [Ai, Bi]\\nIn equation, the variable will not be equal right? Only 2 different variables exist in a pair right?\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "\"Each Ai or Bi is a string that represents a single variable.\"\\n\\nit implies that Ai and Bi will not be the same variable."
                    },
                    {
                        "username": "nshntsharma86",
                        "content": "This is one of the most brain puzzling question. It is definately hard"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "ooh ,I forgot  this was a graph week"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "applying bfs is giving its answer , but how can we ensure that ,by using it , it will give the shortest path between two nodes"
                    },
                    {
                        "username": "judgementdey",
                        "content": "It is not necessary to compute the shortest path per se. Any path from the numerator to the denominator will help you find the answer. That\\'s why DFS also works, not just BFS.\\n\\nThe maximum number of edges is 20, so it isn\\'t necessary to optimize for the shortest path."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "what if test cases given are \\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\nlogically we can solve this but according to leetcode answer is -1 :).\\ncan anyone explain "
                    },
                    {
                        "username": "c4tdog",
                        "content": "ac != a * c"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hm, I didn't even think about graphs and just solved it head-on as a system of simple mathematical equations.\nhttps://leetcode.com/problems/evaluate-division/solutions/3543258/simple-brute-force-solution/"
                    },
                    {
                        "username": "theRadFad",
                        "content": "If it works, it works"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode has a way of misleading us, not only in undistinguishing between hard and medium questions but also between Saturday and Sunday. BTW, I didn\\'t give it a shot, but the description says it all."
                    }
                ]
            },
            {
                "id": 1899528,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "If it is garanteed that there is no division by 0 (as the problem states), then we know the result of x/x, even if x is not in the list of equations.\\nI don;t think the result should be -1 in that case (we know it is 1, regardless of the value of x)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "This is a pretty simple graph problem only.. but implementing it with strings is a pain in the ass to say the least. This could be categorised as a medium problem if you consider just the algorithm, but is a whole another beast to implemen the same."
                    },
                    {
                        "username": "theRadFad",
                        "content": "It\\'s just a bit more laborious work, shouldn\\'t push it to hard"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it wasnt very intuitive for me to think of this as a graph problem. but after seeing the hint, i solved it in about 10 minutes"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "equations[i] = [Ai, Bi]\\nIn equation, the variable will not be equal right? Only 2 different variables exist in a pair right?\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "\"Each Ai or Bi is a string that represents a single variable.\"\\n\\nit implies that Ai and Bi will not be the same variable."
                    },
                    {
                        "username": "nshntsharma86",
                        "content": "This is one of the most brain puzzling question. It is definately hard"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "ooh ,I forgot  this was a graph week"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "applying bfs is giving its answer , but how can we ensure that ,by using it , it will give the shortest path between two nodes"
                    },
                    {
                        "username": "judgementdey",
                        "content": "It is not necessary to compute the shortest path per se. Any path from the numerator to the denominator will help you find the answer. That\\'s why DFS also works, not just BFS.\\n\\nThe maximum number of edges is 20, so it isn\\'t necessary to optimize for the shortest path."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "what if test cases given are \\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\nlogically we can solve this but according to leetcode answer is -1 :).\\ncan anyone explain "
                    },
                    {
                        "username": "c4tdog",
                        "content": "ac != a * c"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hm, I didn't even think about graphs and just solved it head-on as a system of simple mathematical equations.\nhttps://leetcode.com/problems/evaluate-division/solutions/3543258/simple-brute-force-solution/"
                    },
                    {
                        "username": "theRadFad",
                        "content": "If it works, it works"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode has a way of misleading us, not only in undistinguishing between hard and medium questions but also between Saturday and Sunday. BTW, I didn\\'t give it a shot, but the description says it all."
                    }
                ]
            },
            {
                "id": 1899486,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "If it is garanteed that there is no division by 0 (as the problem states), then we know the result of x/x, even if x is not in the list of equations.\\nI don;t think the result should be -1 in that case (we know it is 1, regardless of the value of x)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "This is a pretty simple graph problem only.. but implementing it with strings is a pain in the ass to say the least. This could be categorised as a medium problem if you consider just the algorithm, but is a whole another beast to implemen the same."
                    },
                    {
                        "username": "theRadFad",
                        "content": "It\\'s just a bit more laborious work, shouldn\\'t push it to hard"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it wasnt very intuitive for me to think of this as a graph problem. but after seeing the hint, i solved it in about 10 minutes"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "equations[i] = [Ai, Bi]\\nIn equation, the variable will not be equal right? Only 2 different variables exist in a pair right?\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "\"Each Ai or Bi is a string that represents a single variable.\"\\n\\nit implies that Ai and Bi will not be the same variable."
                    },
                    {
                        "username": "nshntsharma86",
                        "content": "This is one of the most brain puzzling question. It is definately hard"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "ooh ,I forgot  this was a graph week"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "applying bfs is giving its answer , but how can we ensure that ,by using it , it will give the shortest path between two nodes"
                    },
                    {
                        "username": "judgementdey",
                        "content": "It is not necessary to compute the shortest path per se. Any path from the numerator to the denominator will help you find the answer. That\\'s why DFS also works, not just BFS.\\n\\nThe maximum number of edges is 20, so it isn\\'t necessary to optimize for the shortest path."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "what if test cases given are \\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\nlogically we can solve this but according to leetcode answer is -1 :).\\ncan anyone explain "
                    },
                    {
                        "username": "c4tdog",
                        "content": "ac != a * c"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hm, I didn't even think about graphs and just solved it head-on as a system of simple mathematical equations.\nhttps://leetcode.com/problems/evaluate-division/solutions/3543258/simple-brute-force-solution/"
                    },
                    {
                        "username": "theRadFad",
                        "content": "If it works, it works"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode has a way of misleading us, not only in undistinguishing between hard and medium questions but also between Saturday and Sunday. BTW, I didn\\'t give it a shot, but the description says it all."
                    }
                ]
            },
            {
                "id": 1899483,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "If it is garanteed that there is no division by 0 (as the problem states), then we know the result of x/x, even if x is not in the list of equations.\\nI don;t think the result should be -1 in that case (we know it is 1, regardless of the value of x)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "This is a pretty simple graph problem only.. but implementing it with strings is a pain in the ass to say the least. This could be categorised as a medium problem if you consider just the algorithm, but is a whole another beast to implemen the same."
                    },
                    {
                        "username": "theRadFad",
                        "content": "It\\'s just a bit more laborious work, shouldn\\'t push it to hard"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it wasnt very intuitive for me to think of this as a graph problem. but after seeing the hint, i solved it in about 10 minutes"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "equations[i] = [Ai, Bi]\\nIn equation, the variable will not be equal right? Only 2 different variables exist in a pair right?\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "\"Each Ai or Bi is a string that represents a single variable.\"\\n\\nit implies that Ai and Bi will not be the same variable."
                    },
                    {
                        "username": "nshntsharma86",
                        "content": "This is one of the most brain puzzling question. It is definately hard"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "ooh ,I forgot  this was a graph week"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "applying bfs is giving its answer , but how can we ensure that ,by using it , it will give the shortest path between two nodes"
                    },
                    {
                        "username": "judgementdey",
                        "content": "It is not necessary to compute the shortest path per se. Any path from the numerator to the denominator will help you find the answer. That\\'s why DFS also works, not just BFS.\\n\\nThe maximum number of edges is 20, so it isn\\'t necessary to optimize for the shortest path."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "what if test cases given are \\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\nlogically we can solve this but according to leetcode answer is -1 :).\\ncan anyone explain "
                    },
                    {
                        "username": "c4tdog",
                        "content": "ac != a * c"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hm, I didn't even think about graphs and just solved it head-on as a system of simple mathematical equations.\nhttps://leetcode.com/problems/evaluate-division/solutions/3543258/simple-brute-force-solution/"
                    },
                    {
                        "username": "theRadFad",
                        "content": "If it works, it works"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode has a way of misleading us, not only in undistinguishing between hard and medium questions but also between Saturday and Sunday. BTW, I didn\\'t give it a shot, but the description says it all."
                    }
                ]
            },
            {
                "id": 1899456,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "If it is garanteed that there is no division by 0 (as the problem states), then we know the result of x/x, even if x is not in the list of equations.\\nI don;t think the result should be -1 in that case (we know it is 1, regardless of the value of x)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "This is a pretty simple graph problem only.. but implementing it with strings is a pain in the ass to say the least. This could be categorised as a medium problem if you consider just the algorithm, but is a whole another beast to implemen the same."
                    },
                    {
                        "username": "theRadFad",
                        "content": "It\\'s just a bit more laborious work, shouldn\\'t push it to hard"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it wasnt very intuitive for me to think of this as a graph problem. but after seeing the hint, i solved it in about 10 minutes"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "equations[i] = [Ai, Bi]\\nIn equation, the variable will not be equal right? Only 2 different variables exist in a pair right?\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "\"Each Ai or Bi is a string that represents a single variable.\"\\n\\nit implies that Ai and Bi will not be the same variable."
                    },
                    {
                        "username": "nshntsharma86",
                        "content": "This is one of the most brain puzzling question. It is definately hard"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "ooh ,I forgot  this was a graph week"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "applying bfs is giving its answer , but how can we ensure that ,by using it , it will give the shortest path between two nodes"
                    },
                    {
                        "username": "judgementdey",
                        "content": "It is not necessary to compute the shortest path per se. Any path from the numerator to the denominator will help you find the answer. That\\'s why DFS also works, not just BFS.\\n\\nThe maximum number of edges is 20, so it isn\\'t necessary to optimize for the shortest path."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "what if test cases given are \\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\nlogically we can solve this but according to leetcode answer is -1 :).\\ncan anyone explain "
                    },
                    {
                        "username": "c4tdog",
                        "content": "ac != a * c"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hm, I didn't even think about graphs and just solved it head-on as a system of simple mathematical equations.\nhttps://leetcode.com/problems/evaluate-division/solutions/3543258/simple-brute-force-solution/"
                    },
                    {
                        "username": "theRadFad",
                        "content": "If it works, it works"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode has a way of misleading us, not only in undistinguishing between hard and medium questions but also between Saturday and Sunday. BTW, I didn\\'t give it a shot, but the description says it all."
                    }
                ]
            },
            {
                "id": 1899391,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "If it is garanteed that there is no division by 0 (as the problem states), then we know the result of x/x, even if x is not in the list of equations.\\nI don;t think the result should be -1 in that case (we know it is 1, regardless of the value of x)"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "This is a pretty simple graph problem only.. but implementing it with strings is a pain in the ass to say the least. This could be categorised as a medium problem if you consider just the algorithm, but is a whole another beast to implemen the same."
                    },
                    {
                        "username": "theRadFad",
                        "content": "It\\'s just a bit more laborious work, shouldn\\'t push it to hard"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "it wasnt very intuitive for me to think of this as a graph problem. but after seeing the hint, i solved it in about 10 minutes"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "equations[i] = [Ai, Bi]\\nIn equation, the variable will not be equal right? Only 2 different variables exist in a pair right?\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": "\"Each Ai or Bi is a string that represents a single variable.\"\\n\\nit implies that Ai and Bi will not be the same variable."
                    },
                    {
                        "username": "nshntsharma86",
                        "content": "This is one of the most brain puzzling question. It is definately hard"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "ooh ,I forgot  this was a graph week"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "applying bfs is giving its answer , but how can we ensure that ,by using it , it will give the shortest path between two nodes"
                    },
                    {
                        "username": "judgementdey",
                        "content": "It is not necessary to compute the shortest path per se. Any path from the numerator to the denominator will help you find the answer. That\\'s why DFS also works, not just BFS.\\n\\nThe maximum number of edges is 20, so it isn\\'t necessary to optimize for the shortest path."
                    },
                    {
                        "username": "kevinrawal",
                        "content": "what if test cases given are \\n[[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]]\\n[1.5,2.5,5.0]\\n[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"ac\",\"cd\"]]\\n\\nlogically we can solve this but according to leetcode answer is -1 :).\\ncan anyone explain "
                    },
                    {
                        "username": "c4tdog",
                        "content": "ac != a * c"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hm, I didn't even think about graphs and just solved it head-on as a system of simple mathematical equations.\nhttps://leetcode.com/problems/evaluate-division/solutions/3543258/simple-brute-force-solution/"
                    },
                    {
                        "username": "theRadFad",
                        "content": "If it works, it works"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode has a way of misleading us, not only in undistinguishing between hard and medium questions but also between Saturday and Sunday. BTW, I didn\\'t give it a shot, but the description says it all."
                    }
                ]
            }
        ]
    },
    {
        "title": "The Maze III",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1752951,
                "content": [
                    {
                        "username": "chrihop",
                        "content": "The question is ill-formed. Say, if the instruction is \"u\", and the ball is at the bottom edge of the map. \"du\" has the same distance as \"u\" (bounce back from the wall below) and lexicographically smaller, and \"ddu\" is also valid and even smaller. So the question has no answer."
                    },
                    {
                        "username": "ZXCr",
                        "content": "`\\nSo the output is \"lul\"\\n`\\nMade me laugh, lul"
                    }
                ]
            },
            {
                "id": 1568443,
                "content": [
                    {
                        "username": "chrihop",
                        "content": "The question is ill-formed. Say, if the instruction is \"u\", and the ball is at the bottom edge of the map. \"du\" has the same distance as \"u\" (bounce back from the wall below) and lexicographically smaller, and \"ddu\" is also valid and even smaller. So the question has no answer."
                    },
                    {
                        "username": "ZXCr",
                        "content": "`\\nSo the output is \"lul\"\\n`\\nMade me laugh, lul"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Index Sum of Two Lists",
        "question_content": "<p>Given two arrays of strings <code>list1</code> and <code>list2</code>, find the <strong>common strings with the least index sum</strong>.</p>\n\n<p>A <strong>common string</strong> is a string that appeared in both <code>list1</code> and <code>list2</code>.</p>\n\n<p>A <strong>common string with the least index sum</strong> is a common string such that if it appeared at <code>list1[i]</code> and <code>list2[j]</code> then <code>i + j</code> should be the minimum value among all the other <strong>common strings</strong>.</p>\n\n<p>Return <em>all the <strong>common strings with the least index sum</strong></em>. Return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [&quot;Shogun&quot;,&quot;Tapioca Express&quot;,&quot;Burger King&quot;,&quot;KFC&quot;], list2 = [&quot;Piatti&quot;,&quot;The Grill at Torrey Pines&quot;,&quot;Hungry Hunter Steakhouse&quot;,&quot;Shogun&quot;]\n<strong>Output:</strong> [&quot;Shogun&quot;]\n<strong>Explanation:</strong> The only common string is &quot;Shogun&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [&quot;Shogun&quot;,&quot;Tapioca Express&quot;,&quot;Burger King&quot;,&quot;KFC&quot;], list2 = [&quot;KFC&quot;,&quot;Shogun&quot;,&quot;Burger King&quot;]\n<strong>Output:</strong> [&quot;Shogun&quot;]\n<strong>Explanation:</strong> The common string with the least index sum is &quot;Shogun&quot; with index sum = (0 + 1) = 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [&quot;happy&quot;,&quot;sad&quot;,&quot;good&quot;], list2 = [&quot;sad&quot;,&quot;happy&quot;,&quot;good&quot;]\n<strong>Output:</strong> [&quot;sad&quot;,&quot;happy&quot;]\n<strong>Explanation:</strong> There are three common strings:\n&quot;happy&quot; with index sum = (0 + 1) = 1.\n&quot;sad&quot; with index sum = (1 + 0) = 1.\n&quot;good&quot; with index sum = (2 + 2) = 4.\nThe strings with the least index sum are &quot;sad&quot; and &quot;happy&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= list1.length, list2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= list1[i].length, list2[i].length &lt;= 30</code></li>\n\t<li><code>list1[i]</code> and <code>list2[i]</code> consist of spaces <code>&#39; &#39;</code> and English letters.</li>\n\t<li>All the strings of <code>list1</code> are <strong>unique</strong>.</li>\n\t<li>All the strings of <code>list2</code> are <strong>unique</strong>.</li>\n\t<li>There is at least a common string between <code>list1</code> and <code>list2</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 103654,
                "title": "java-o-n-m-time-o-n-space",
                "content": "```\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\n    Map<String, Integer> map = new HashMap<>();\\n    List<String> res = new LinkedList<>();\\n    int minSum = Integer.MAX_VALUE;\\n    for (int i=0;i<list1.length;i++) map.put(list1[i], i);\\n    for (int i=0;i<list2.length;i++) {\\n        Integer j = map.get(list2[i]);\\n        if (j != null && i + j <= minSum) {\\n            if (i + j < minSum) { res.clear(); minSum = i+j; }\\n            res.add(list2[i]);\\n        }\\n    }\\n    return res.toArray(new String[res.size()]);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\n    Map<String, Integer> map = new HashMap<>();\\n    List<String> res = new LinkedList<>();\\n    int minSum = Integer.MAX_VALUE;\\n    for (int i=0;i<list1.length;i++) map.put(list1[i], i);\\n    for (int i=0;i<list2.length;i++) {\\n        Integer j = map.get(list2[i]);\\n        if (j != null && i + j <= minSum) {\\n            if (i + j < minSum) { res.clear(); minSum = i+j; }\\n            res.add(list2[i]);\\n        }\\n    }\\n    return res.toArray(new String[res.size()]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103745,
                "title": "python-straightforward-with-explanation",
                "content": "Say the lists are ```A``` and ```B```.  Let ```Aindex[element]``` be the index of that element in A.  For every index, value pair (j, v) in B, we have some candidate sum-of-indexes i + j, where i = Aindex[v] if it exists.  If the candidate sum is better, it becomes our new answer; if the candidate sums are the same, then we append to our answer.\\n\\n```\\ndef findRestaurant(self, A, B):\\n    Aindex = {u: i for i, u in enumerate(A)}\\n    best, ans = 1e9, []\\n\\n    for j, v in enumerate(B):\\n        i = Aindex.get(v, 1e9)\\n        if i + j < best:\\n            best = i + j\\n            ans = [v]\\n        elif i + j == best:\\n            ans.append(v)\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```A```\n```B```\n```Aindex[element]```\n```\\ndef findRestaurant(self, A, B):\\n    Aindex = {u: i for i, u in enumerate(A)}\\n    best, ans = 1e9, []\\n\\n    for j, v in enumerate(B):\\n        i = Aindex.get(v, 1e9)\\n        if i + j < best:\\n            best = i + j\\n            ans = [v]\\n        elif i + j == best:\\n            ans.append(v)\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 103674,
                "title": "c-9-lines-hash-table-easy-to-understand",
                "content": "```\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string>res;\\n        unordered_map<string,int>m;\\n        int min = INT_MAX;\\n        for(int i = 0; i < list1.size(); i++) m[list1[i]] = i;\\n        for(int i = 0; i < list2.size(); i++)\\n            if(m.count(list2[i]) != 0)\\n                if(m[list2[i]] + i < min) min = m[list2[i]] + i, res.clear(), res.push_back(list2[i]);\\n                else if(m[list2[i]] + i == min) res.push_back(list2[i]);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string>res;\\n        unordered_map<string,int>m;\\n        int min = INT_MAX;\\n        for(int i = 0; i < list1.size(); i++) m[list1[i]] = i;\\n        for(int i = 0; i < list2.size(); i++)\\n            if(m.count(list2[i]) != 0)\\n                if(m[list2[i]] + i < min) min = m[list2[i]] + i, res.clear(), res.push_back(list2[i]);\\n                else if(m[list2[i]] + i == min) res.push_back(list2[i]);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2119695,
                "title": "best-explanation-on-leetcode-c-do-upvote",
                "content": "See this question demands us to return the minimum sum of indexes!\\nI\\'m sure that you\\'ll be stuck in part where for eg index from 1st array = 1 and from the second array = 4 which sums to 5 and in the second case index from 1st array = 3 and from the second array = 2 which adds to 5, Your code will give the wrong answer and you came here to check the discussion!\\nCool, it\\'s pretty easy to understand!\\n\\n***STEP 1 - CREATE A VECTOR***\\n```\\nvector<string> c;\\n```\\n\\n***STEP 2 - CREATE A VARIABLE TO MAINTAIN THE SUM OF MINIMUM INDEXES***\\n```\\nint min = INT_MAX;\\n```\\n\\n***STEP 3 - USE NESTED FOR LOOP TO TRAVERSE IN BOTH LISTS AND FIND THE COMMON STRINGS***\\n```\\nfor (int i = 0; i < a.size(); i++)\\n            {\\n                for (int j = 0; j < b.size(); j++)\\n                {\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n```\\n\\n***STEP 4 - MAKE A CHECK , WHETHER ELEMENT FROM LIST 1 AND LIST 2 ARE EQUAL***\\n```\\nif (a[i] == b[j])\\n{\\n}\\n```\\n\\n***STEP 5 - IF INDEX OF LIST 1 + INDEX OF LIST 2 IS LESS THAN MIN , THEN CLEAR THE LIST FIRST AND THEN INSERT AND LASTLY UPDATE MIN***\\n```\\nif (i + j < min)\\n                        {\\n                            min = i + j;\\n                            c.clear();\\n                            c.push_back(a[i]);\\n                        }\\n```\\n\\n***STEP 6 - IF INDEX OF LIST 1 + INDEX OF LIST 2 IS EQUAL TO MIN , THEN JUST INSERT IT***\\n```\\nelse if (i + j == min)\\n                        {\\n                            c.push_back(a[i]);\\n                        }\\n```\\n\\n***STEP - 7 LASTLY RETURN VECTOR***\\n```\\nreturn c;\\n```\\n\\n\\n# CODE : \\n```\\nclass Solution\\n{\\n    public:\\n        vector<string> findRestaurant(vector<string> &a, vector<string> &b)\\n        {\\n            vector<string> c;\\n            int min = INT_MAX;\\n            for (int i = 0; i < a.size(); i++)\\n            {\\n                for (int j = 0; j < b.size(); j++)\\n                {\\n                    if (a[i] == b[j])\\n                    {\\n                        if (i + j < min)\\n                        {\\n                            min = i + j;\\n                            c.clear();\\n                            c.push_back(a[i]);\\n                        }\\n                        else if (i + j == min)\\n                        {\\n                            c.push_back(a[i]);\\n                        }\\n                    }\\n                }\\n            }\\n            return c;\\n        }\\n};\\n```\\n\\n# ***DO UPVOTE \\u2764\\uFE0F***",
                "solutionTags": [],
                "code": "```\\nvector<string> c;\\n```\n```\\nint min = INT_MAX;\\n```\n```\\nfor (int i = 0; i < a.size(); i++)\\n            {\\n                for (int j = 0; j < b.size(); j++)\\n                {\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n```\n```\\nif (a[i] == b[j])\\n{\\n}\\n```\n```\\nif (i + j < min)\\n                        {\\n                            min = i + j;\\n                            c.clear();\\n                            c.push_back(a[i]);\\n                        }\\n```\n```\\nelse if (i + j == min)\\n                        {\\n                            c.push_back(a[i]);\\n                        }\\n```\n```\\nreturn c;\\n```\n```\\nclass Solution\\n{\\n    public:\\n        vector<string> findRestaurant(vector<string> &a, vector<string> &b)\\n        {\\n            vector<string> c;\\n            int min = INT_MAX;\\n            for (int i = 0; i < a.size(); i++)\\n            {\\n                for (int j = 0; j < b.size(); j++)\\n                {\\n                    if (a[i] == b[j])\\n                    {\\n                        if (i + j < min)\\n                        {\\n                            min = i + j;\\n                            c.clear();\\n                            c.push_back(a[i]);\\n                        }\\n                        else if (i + j == min)\\n                        {\\n                            c.push_back(a[i]);\\n                        }\\n                    }\\n                }\\n            }\\n            return c;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534789,
                "title": "python3-148ms-94-77-hashmap",
                "content": "\\tclass Solution:\\n\\t\\tdef findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n\\t\\t\\tdic1 = {restaurant:i for i, restaurant in enumerate(list1)}\\n\\t\\t\\tdic2 = {restaurant:dic1[restaurant]+i for i, restaurant in enumerate(list2) if restaurant in dic1}\\n\\t\\t\\t\\n\\t\\t\\tMIN = float(\\'inf\\')\\n\\t\\t\\tres = []\\n\\t\\t\\t\\n\\t\\t\\tfor key, val in dic2.items():\\n\\t\\t\\t\\tif val < MIN:\\n\\t\\t\\t\\t\\tres = [key]\\n\\t\\t\\t\\t\\tMIN = val\\n\\t\\t\\t\\telif val == MIN:\\n\\t\\t\\t\\t\\tres.append(key)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t\\tdef findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n\\t\\t\\tdic1 = {restaurant:i for i, restaurant in enumerate(list1)}",
                "codeTag": "Java"
            },
            {
                "id": 159248,
                "title": "python-hashmap-4-line-solution",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1, list2):\\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        d = {l:i for i,l in enumerate(list1)}\\n        sm = {l:i+d[l] for i,l in enumerate(list2) if l in d}\\n        mn = min(v for v in sm.values())\\n        return [k for k,v in sm.items() if v == mn]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1, list2):\\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        d = {l:i for i,l in enumerate(list1)}\\n        sm = {l:i+d[l] for i,l in enumerate(list2) if l in d}\\n        mn = min(v for v in sm.values())\\n        return [k for k,v in sm.items() if v == mn]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379994,
                "title": "easy-c-solution-96ms-beats-94",
                "content": "Runtime: 96 ms, faster than 94.71% of C++ online submissions for Minimum Index Sum of Two Lists.\\nMemory Usage: 27.9 MB, less than 100.00% of C++ online submissions for Minimum Index Sum of Two Lists.\\n\\n```\\nvector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        \\n        vector<string> res;\\n        int indexSum = INT_MAX;\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(int i=0; i<list1.size(); i++)\\n            mp[list1[i]] = i;\\n        \\n        for(int i=0; i<list2.size(); i++)\\n        {\\n            if(mp.find(list2[i]) != mp.end())\\n            {\\n                if(mp[list2[i]] + i < indexSum)\\n                {\\n                    indexSum = mp[list2[i]] + i;\\n                    res.clear();\\n                    res.push_back(list2[i]);\\n                }\\n                else if(mp[list2[i]] + i == indexSum)\\n                    res.push_back(list2[i]);\\n            }    \\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 96 ms, faster than 94.71% of C++ online submissions for Minimum Index Sum of Two Lists.\\nMemory Usage: 27.9 MB, less than 100.00% of C++ online submissions for Minimum Index Sum of Two Lists.\\n\\n```\\nvector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        \\n        vector<string> res;\\n        int indexSum = INT_MAX;\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(int i=0; i<list1.size(); i++)\\n            mp[list1[i]] = i;\\n        \\n        for(int i=0; i<list2.size(); i++)\\n        {\\n            if(mp.find(list2[i]) != mp.end())\\n            {\\n                if(mp[list2[i]] + i < indexSum)\\n                {\\n                    indexSum = mp[list2[i]] + i;\\n                    res.clear();\\n                    res.push_back(list2[i]);\\n                }\\n                else if(mp[list2[i]] + i == indexSum)\\n                    res.push_back(list2[i]);\\n            }    \\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1902232,
                "title": "python-hashmap-solution-104ms-100-explained",
                "content": "# Basic algorithm: \\n1. Create the hashmap by iterating through list1\\n2. Create an infinite number we can update every time we see a smaller index sum\\n3. Iterates through list2 and does the following (if the current item is in the hashmap):\\n\\t4. Creates a \"sum\" containing the index sum of the 2 items (the common item in both lists)\\n\\t5. If the \"sum\" is less than the current minimum sum: update the minimum sum to this; add         the common item to the result list\\n\\t6. If the \"sum\" is equal to the current minimum sum: this is the edge case \"If there is a                choice tie between answers, output all of them with no order requirement\". Just add the          item to the result list.\\n\\nTime complexity analysis: *O(l1+l2)*\\n(*l1* and *l2* are the lenghts of *list1* and *list2* respectively)\\n\\nSpace complexity analysis: *O(l1 * x)*\\n(*l1* is lenght of the maximum size word, *x* is the lenght of the resultant list)\\n![image](https://assets.leetcode.com/users/images/c9c3031f-3e3d-4150-8e7c-4d98aa751351_1648786287.6091719.png)\\n\\n\\n```\\nclass Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        hashmap = {}\\n        for i in range(len(list1)):   #step 1\\n            hashmap[list1[i]] = i\\n        \\n        res = []\\n\\n        minsum = float(\"inf\")   #step 2\\n        \\n        for j in range(len(list2)):    #step 3\\n            if list2[j] in hashmap:\\n                Sum = j + hashmap[list2[j]]    #step 3a\\n                \\n                if Sum < minsum:   #step 3b\\n                    minsum = Sum\\n                    res = []\\n                    res.append(list2[j])\\n                elif Sum == minsum:     #step 3c\\n                    res.append(list2[j])\\n        return res\\n\\t\\t```\\n\\t\\t\\n\\t\\t\\n\\n\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        hashmap = {}\\n        for i in range(len(list1)):   #step 1\\n            hashmap[list1[i]] = i\\n        \\n        res = []\\n\\n        minsum = float(\"inf\")   #step 2\\n        \\n        for j in range(len(list2)):    #step 3\\n            if list2[j] in hashmap:\\n                Sum = j + hashmap[list2[j]]    #step 3a\\n                \\n                if Sum < minsum:   #step 3b\\n                    minsum = Sum\\n                    res = []\\n                    res.append(list2[j])\\n                elif Sum == minsum:     #step 3c\\n                    res.append(list2[j])\\n        return res\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 440284,
                "title": "faster-than-99-easy-to-understand-simple-javascript-submission",
                "content": "**Please do upvote, this motivates me to write more such post**\\n```\\nvar findRestaurant = function(list1, list2) {\\n    let out = [];\\n    let obj = new Map();\\n    list2.forEach((v, i) =>  obj.set(v, i));\\n    let i = 0, min = Infinity;\\n    while(i<list1.length){\\n        if(obj.has(list1[i])){\\n            let sum = i + obj.get(list1[i]);\\n            if(min===sum){\\n                out.push(list1[i]);\\n            }   \\n            else if(sum<min){\\n                out = [list1[i]];\\n                min = sum;\\n            }\\n        }\\n        i++;\\n    }\\n    \\n    return out;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findRestaurant = function(list1, list2) {\\n    let out = [];\\n    let obj = new Map();\\n    list2.forEach((v, i) =>  obj.set(v, i));\\n    let i = 0, min = Infinity;\\n    while(i<list1.length){\\n        if(obj.has(list1[i])){\\n            let sum = i + obj.get(list1[i]);\\n            if(min===sum){\\n                out.push(list1[i]);\\n            }   \\n            else if(sum<min){\\n                out = [list1[i]];\\n                min = sum;\\n            }\\n        }\\n        i++;\\n    }\\n    \\n    return out;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 554360,
                "title": "python-95-5-lines-explained",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d1,dc = { v:i for i,v in enumerate(list1) }, {}\\n        for i,v in enumerate(list2):\\n            if v in d1:\\n                dc[ d1[v] + i ] = dc.get( d1[v] + i ,[] ) + [v]\\n        return dc[ min(dc) ]\\n```\\n\\nOn a high level, we\\'ll need to check every element in both lists, there is not much we can do about that. But we also need to check if an element in one list is present in the other list. This can be done in different ways and some are better than others. In python, if we ask \"is value X in list L?\" - that would require scanning the whole list L - quite expensive. But if we ask \"is value X i dictionary L?\" - that operation is very fast because it\\'s based on calculating a hash value.\\n\\nOk, how do we implement that idea?\\n\\n1. let\\'s scan `list1` and store `value:index` pairs in dictionary `d1`. We also define dictionary `dc` along the way:\\n\\n```\\n        d1,dc = { v:i for i,v in enumerate(list1) }, {}\\n```\\n\\n2. Now we have to scan `list2`. When we pick a pair of index,value `i,v`, we check if we saw that value in `list1` and if we did, then we have an element present in both lists! Now we add together indexes of that value in `list1` and `list2` and use it as a key in dictionary `dc`. The dictionary values will look like  `i1+i2:[v1,...]`. The idea is that each value will be a list of shared values those indexes together are equal to the same `i1+i2`.  One trick we are using here is  `dc.get( d1[v] + i ,[] )` - this function returns the value from the dictionary if it exists, otherwise it returns an empty list.\\n\\n```\\n        for i,v in enumerate(list2):\\n            if v in d1:\\n                dc[ d1[v] + i ] = dc.get( d1[v] + i ,[] ) + [v]\\n```\\n\\n3. Finally, we return the value for the lowest index in `dc{}`.  We don\\'t have to call `min(dc)`, another option would be to create a variable min_index and update it as we add values to `dc`.  But when i ran a few tests, turns out that using `min(dc)` is actually faster. It also makes code look cleaner.\\n\\n```\\n        return dc[ min(dc) ]\\n```\\n\\nOk, the code is ready. How does it perform? After a few runs it clocked 95%, not bad at all.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d1,dc = { v:i for i,v in enumerate(list1) }, {}\\n        for i,v in enumerate(list2):\\n            if v in d1:\\n                dc[ d1[v] + i ] = dc.get( d1[v] + i ,[] ) + [v]\\n        return dc[ min(dc) ]\\n```\n```\\n        d1,dc = { v:i for i,v in enumerate(list1) }, {}\\n```\n```\\n        for i,v in enumerate(list2):\\n            if v in d1:\\n                dc[ d1[v] + i ] = dc.get( d1[v] + i ,[] ) + [v]\\n```\n```\\n        return dc[ min(dc) ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162780,
                "title": "python-easy-to-understand-solution",
                "content": "Space: **O(min(length1, length2))**\\nTime: **O(m + n) or O(max(m, n))**\\n```\\nclass Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        if len(list1) > len(list2):\\n            return self.findRestaurant(list2, list1)\\n        \\n        d = {s: i for i, s in enumerate(list1)}\\n        \\n        minIdxSum = float(\\'inf\\')\\n        res = []\\n        for i, s in enumerate(list2):\\n            if s in d:\\n                idxSum = d[s] + i \\n                if idxSum < minIdxSum:\\n                    minIdxSum = idxSum\\n                    del res[:]\\n                    res.append(s)\\n                elif idxSum == minIdxSum:\\n                    res.append(s)\\n            \\n        return res\\n        \\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        if len(list1) > len(list2):\\n            return self.findRestaurant(list2, list1)\\n        \\n        d = {s: i for i, s in enumerate(list1)}\\n        \\n        minIdxSum = float(\\'inf\\')\\n        res = []\\n        for i, s in enumerate(list2):\\n            if s in d:\\n                idxSum = d[s] + i \\n                if idxSum < minIdxSum:\\n                    minIdxSum = idxSum\\n                    del res[:]\\n                    res.append(s)\\n                elif idxSum == minIdxSum:\\n                    res.append(s)\\n            \\n        return res\\n        \\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983672,
                "title": "simple-javascript-solution-94-60-using-map-clean",
                "content": "I did not have much time to come up with better solution \\uD83E\\uDD37\\n\\nRuntime: 96 ms, faster than 94.14% of JavaScript online submissions for Minimum Index Sum of Two Lists.\\nMemory Usage: 46.4 MB, less than 60.55% of JavaScript online submissions for Minimum Index Sum of Two Lists.\\n\\n```\\nfunction findRestaurant(list1, list2) {\\n  const map = new Map();\\n  let ret = [];\\n  let min = Infinity;\\n  for (let i = 0; i < list1.length; ++i) {\\n    map.set(list1[i], i);\\n  }\\n  for (let i = 0; i < list2.length; ++i) {\\n    if (map.has(list2[i])) {\\n      let index1 = map.get(list2[i]);\\n      let index2 = i;\\n      ret.push({ val: list2[i], index: index1 + index2 });\\n      min = Math.min(min, index1 + index2);\\n    }\\n  }\\n  // Basically ret should be map as well instead of array\\n  // so we don\\'t have to filter it (it will be faster).\\n  return ret.filter(item => item.index === min).map(item => item.val);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction findRestaurant(list1, list2) {\\n  const map = new Map();\\n  let ret = [];\\n  let min = Infinity;\\n  for (let i = 0; i < list1.length; ++i) {\\n    map.set(list1[i], i);\\n  }\\n  for (let i = 0; i < list2.length; ++i) {\\n    if (map.has(list2[i])) {\\n      let index1 = map.get(list2[i]);\\n      let index2 = i;\\n      ret.push({ val: list2[i], index: index1 + index2 });\\n      min = Math.min(min, index1 + index2);\\n    }\\n  }\\n  // Basically ret should be map as well instead of array\\n  // so we don\\'t have to filter it (it will be faster).\\n  return ret.filter(item => item.index === min).map(item => item.val);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1148822,
                "title": "java-hashmap-faster-than-99",
                "content": "Time complexity: `O(N + M)`.\\nSpace complexity: `O(min(N, M))`.\\n\\n```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        if (list1.length > list2.length) {\\n            return findRestaurant(list2, list1);\\n        }\\n        \\n        Map<String, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < list1.length; i++) {\\n            map1.put(list1[i], i);\\n        }\\n        \\n        List<String> mins = new ArrayList<>();\\n        int minSum = Integer.MAX_VALUE;\\n        for (int i = 0; i < list2.length; i++) {\\n            String rest2 = list2[i];\\n            if (map1.containsKey(rest2)) {\\n                int sum = map1.get(rest2) + i;\\n                if (sum < minSum) {\\n                    mins = new ArrayList<>();\\n                    minSum = sum;\\n                }\\n                if (sum == minSum) {\\n                    mins.add(rest2);\\n                }\\n            }\\n        }\\n        \\n        return mins.toArray(new String[mins.size()]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        if (list1.length > list2.length) {\\n            return findRestaurant(list2, list1);\\n        }\\n        \\n        Map<String, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < list1.length; i++) {\\n            map1.put(list1[i], i);\\n        }\\n        \\n        List<String> mins = new ArrayList<>();\\n        int minSum = Integer.MAX_VALUE;\\n        for (int i = 0; i < list2.length; i++) {\\n            String rest2 = list2[i];\\n            if (map1.containsKey(rest2)) {\\n                int sum = map1.get(rest2) + i;\\n                if (sum < minSum) {\\n                    mins = new ArrayList<>();\\n                    minSum = sum;\\n                }\\n                if (sum == minSum) {\\n                    mins.add(rest2);\\n                }\\n            }\\n        }\\n        \\n        return mins.toArray(new String[mins.size()]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 932010,
                "title": "python-dict-time-o-n-m-space-o-n",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        words1 = {word: idx for idx, word in enumerate(list1)}\\n\\n        min_sum = math.inf\\n        for idx2, word2 in enumerate(list2):\\n            if word2 in words1:\\n                if words1[word2] + idx2 < min_sum:\\n                    min_sum = words1[word2] + idx2\\n                    min_words = [word2]\\n                elif words1[word2] + idx2 == min_sum:\\n                    min_words.append(word2)\\n                   \\n        return min_words\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        words1 = {word: idx for idx, word in enumerate(list1)}\\n\\n        min_sum = math.inf\\n        for idx2, word2 in enumerate(list2):\\n            if word2 in words1:\\n                if words1[word2] + idx2 < min_sum:\\n                    min_sum = words1[word2] + idx2\\n                    min_words = [word2]\\n                elif words1[word2] + idx2 == min_sum:\\n                    min_words.append(word2)\\n                   \\n        return min_words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306264,
                "title": "599-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFind the common elements between both lists using the set intersection operator & and store the result in a variable called common.\\n\\nInitialize a dictionary called index_sum to store the index sum of common elements in list1.\\n\\nIterate through each element r in list1 and for each element:\\n\\nIf r is in common, store the index sum of r in index_sum.\\nIterate through each element r in list2 and for each element:\\n\\nIf r is in common, add the index sum of r to its corresponding value in index_sum.\\nFind the minimum value in index_sum and store it in a variable called min_sum.\\n\\nReturn a list of elements in index_sum whose value is equal to min_sum.\\n\\nEnd of the algorithm.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        common = set(list1) & set(list2)  # Find common elements between both lists\\n        index_sum = {}\\n        for i, r in enumerate(list1):\\n            if r in common:\\n                index_sum[r] = i  # Store index sum of common elements in list1\\n        for i, r in enumerate(list2):\\n            if r in common:\\n                index_sum[r] += i  # Add index sum of common elements in list2\\n        min_sum = min(index_sum.values())  # Find minimum index sum\\n        return [r for r, s in index_sum.items() if s == min_sum]  # Return elements with minimum index sum\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        common = set(list1) & set(list2)  # Find common elements between both lists\\n        index_sum = {}\\n        for i, r in enumerate(list1):\\n            if r in common:\\n                index_sum[r] = i  # Store index sum of common elements in list1\\n        for i, r in enumerate(list2):\\n            if r in common:\\n                index_sum[r] += i  # Add index sum of common elements in list2\\n        min_sum = min(index_sum.values())  # Find minimum index sum\\n        return [r for r, s in index_sum.items() if s == min_sum]  # Return elements with minimum index sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068484,
                "title": "c-the-simplest-solution",
                "content": "```\\nvector<string> findRestaurant(vector<string>& list1, vector<string>& list2){\\n        vector<string> res;\\n        int min_sum = INT_MAX;\\n        for(int i=0;i<list1.size();i++){\\n            for(int j=0;j<list2.size();j++){\\n                if(list1[i]==list2[j]){\\n                    if(i+j == min_sum){\\n                        res.push_back(list1[i]);\\n                    }else if(i+j > min_sum){\\n                        continue;\\n                    }else{\\n                        min_sum = i+j;\\n                        res.clear();\\n                        res.push_back(list1[i]);\\n                    }\\n                }\\n            }\\n        }\\n    return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<string> findRestaurant(vector<string>& list1, vector<string>& list2){\\n        vector<string> res;\\n        int min_sum = INT_MAX;\\n        for(int i=0;i<list1.size();i++){\\n            for(int j=0;j<list2.size();j++){\\n                if(list1[i]==list2[j]){\\n                    if(i+j == min_sum){\\n                        res.push_back(list1[i]);\\n                    }else if(i+j > min_sum){\\n                        continue;\\n                    }else{\\n                        min_sum = i+j;\\n                        res.clear();\\n                        res.push_back(list1[i]);\\n                    }\\n                }\\n            }\\n        }\\n    return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 284421,
                "title": "a-neat-java-solution-from-a-triton",
                "content": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        if (list2.length < list1.length) {\\n            return findRestaurant(list2, list1);\\n        }\\n        int minSum = Integer.MAX_VALUE;\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < list1.length; i++) {\\n            map.put(list1[i], i);\\n        }\\n        List<String> res = new ArrayList<>();\\n        for (int i = 0; i < list2.length; i++) {\\n            if (map.containsKey(list2[i])) {\\n                int sum = map.get(list2[i]) + i;\\n                if (sum < minSum) {\\n                    minSum = sum;\\n                    res = new ArrayList<>();\\n                    res.add(list2[i]);\\n                } else if (sum == minSum) {\\n                    res.add(list2[i]);\\n                }\\n            }\\n        }\\n        String[] result = new String[res.size()];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = res.get(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        if (list2.length < list1.length) {\\n            return findRestaurant(list2, list1);\\n        }\\n        int minSum = Integer.MAX_VALUE;\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < list1.length; i++) {\\n            map.put(list1[i], i);\\n        }\\n        List<String> res = new ArrayList<>();\\n        for (int i = 0; i < list2.length; i++) {\\n            if (map.containsKey(list2[i])) {\\n                int sum = map.get(list2[i]) + i;\\n                if (sum < minSum) {\\n                    minSum = sum;\\n                    res = new ArrayList<>();\\n                    res.add(list2[i]);\\n                } else if (sum == minSum) {\\n                    res.add(list2[i]);\\n                }\\n            }\\n        }\\n        String[] result = new String[res.size()];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = res.get(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 237471,
                "title": "c-100-00-space-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string, int> hashmap1;\\n    unordered_map<string, int> hashmap2;\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        int max_sum = list1.size() + list2.size();\\n        vector<string> res;\\n        for(int i=0; i<list1.size(); i++)\\n            hashmap1.insert(make_pair(list1[i], i));\\n        for(int i=0; i<list2.size(); i++)\\n            hashmap2.insert(make_pair(list2[i], i));\\n        for(auto it:list1) {\\n            if(hashmap2.count(it) > 0 && hashmap1[it]+hashmap2[it] < max_sum)\\n                max_sum = hashmap1[it] + hashmap2[it];\\n        }\\n        // duplicate cases\\n        for(auto it:list1) {\\n            if(hashmap2.count(it) > 0 && hashmap1[it]+hashmap2[it] == max_sum)\\n                res.push_back(it);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string, int> hashmap1;\\n    unordered_map<string, int> hashmap2;\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        int max_sum = list1.size() + list2.size();\\n        vector<string> res;\\n        for(int i=0; i<list1.size(); i++)\\n            hashmap1.insert(make_pair(list1[i], i));\\n        for(int i=0; i<list2.size(); i++)\\n            hashmap2.insert(make_pair(list2[i], i));\\n        for(auto it:list1) {\\n            if(hashmap2.count(it) > 0 && hashmap1[it]+hashmap2[it] < max_sum)\\n                max_sum = hashmap1[it] + hashmap2[it];\\n        }\\n        // duplicate cases\\n        for(auto it:list1) {\\n            if(hashmap2.count(it) > 0 && hashmap1[it]+hashmap2[it] == max_sum)\\n                res.push_back(it);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497084,
                "title": "c-solution-using-only-1-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        int min=INT_MAX;\\n       unordered_map<string,int>un;\\n        vector<string>v;\\n        for(int i=0;i<list1.size();i++){\\n            un[list1[i]]=i;\\n        }\\n        for(int i=0;i<list2.size();i++){\\n            if(un.count(list2[i])!=0){\\n              int sum=i+un[list2[i]];\\n                if(sum<min){\\n                    min=sum;\\n                    v.clear();\\n                    v.push_back(list2[i]);\\n                }else if(sum==min){\\n                     v.push_back(list2[i]);\\n                }\\n            }\\n        }\\n        return v;\\n        \\n        \\n    }\\n    };\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        int min=INT_MAX;\\n       unordered_map<string,int>un;\\n        vector<string>v;\\n        for(int i=0;i<list1.size();i++){\\n            un[list1[i]]=i;\\n        }\\n        for(int i=0;i<list2.size();i++){\\n            if(un.count(list2[i])!=0){\\n              int sum=i+un[list2[i]];\\n                if(sum<min){\\n                    min=sum;\\n                    v.clear();\\n                    v.push_back(list2[i]);\\n                }else if(sum==min){\\n                     v.push_back(list2[i]);\\n                }\\n            }\\n        }\\n        return v;\\n        \\n        \\n    }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203957,
                "title": "o-n-javascript-solution-with-comments",
                "content": "```\\nconst findRestaurant = function (list1, list2) {\\n\\t// For the first array, make a hashmap of all indexes of each interest\\n\\tconst interests = {}\\n\\tfor (let i = 0; i < list1.length; i++) {\\n\\t\\tconst interest = list1[i];\\n\\t\\tinterests[interest] = i\\n\\t}\\n\\n\\tlet commonInterestArr = []\\n\\tlet minSum = Infinity\\n\\tfor (let i = 0; i < list2.length; i++) {\\n\\t\\tconst interest = list2[i];\\n\\n\\t\\t// when there is a common interest, add the current index to the index in the hashmap\\n\\t\\tif (interests[interest] !== undefined) {\\n\\t\\t\\tconst currentSum = interests[interest] + i\\n\\t\\t\\t// if it is lower than the current minimum index, set the array of common interests to an array of the current element and the minimum sum to the current sum\\n\\t\\t\\tif (currentSum < minSum) {\\n\\t\\t\\t\\tcommonInterestArr = [interest]\\n\\t\\t\\t\\tminSum = currentSum\\n\\t\\t\\t}\\n\\t\\t\\t// If they are equal, push the current element to the array of common interests\\n\\t\\t\\telse if (currentSum === minSum) {\\n\\t\\t\\t\\tcommonInterestArr.push(interest)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// return the array of common interests\\n\\treturn commonInterestArr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findRestaurant = function (list1, list2) {\\n\\t// For the first array, make a hashmap of all indexes of each interest\\n\\tconst interests = {}\\n\\tfor (let i = 0; i < list1.length; i++) {\\n\\t\\tconst interest = list1[i];\\n\\t\\tinterests[interest] = i\\n\\t}\\n\\n\\tlet commonInterestArr = []\\n\\tlet minSum = Infinity\\n\\tfor (let i = 0; i < list2.length; i++) {\\n\\t\\tconst interest = list2[i];\\n\\n\\t\\t// when there is a common interest, add the current index to the index in the hashmap\\n\\t\\tif (interests[interest] !== undefined) {\\n\\t\\t\\tconst currentSum = interests[interest] + i\\n\\t\\t\\t// if it is lower than the current minimum index, set the array of common interests to an array of the current element and the minimum sum to the current sum\\n\\t\\t\\tif (currentSum < minSum) {\\n\\t\\t\\t\\tcommonInterestArr = [interest]\\n\\t\\t\\t\\tminSum = currentSum\\n\\t\\t\\t}\\n\\t\\t\\t// If they are equal, push the current element to the array of common interests\\n\\t\\t\\telse if (currentSum === minSum) {\\n\\t\\t\\t\\tcommonInterestArr.push(interest)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// return the array of common interests\\n\\treturn commonInterestArr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2116561,
                "title": "easy-to-understand-c-code",
                "content": "* ***Approach 1 : Brute Force Using Unordered Map***\\n\\n* ***Time Complexity : O(N * M)***\\n\\n* ***Space Complexity : O(M * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        \\n        int n1 = list1.size();\\n        \\n        int n2 = list2.size();\\n        \\n        int mini = INT_MAX;\\n        \\n        unordered_map<int, vector<string>> mp;\\n        \\n        for(int i = 0; i < n1; i++)\\n        {\\n            for(int j = 0; j < n2; j++)\\n            {\\n                if(list1[i] == list2[j])\\n                {\\n                    mp[i + j].push_back(list1[i]);\\n                    \\n                    mini = min(mini, i + j);\\n                }\\n            }\\n        }\\n        \\n        return mp[mini];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        \\n        int n1 = list1.size();\\n        \\n        int n2 = list2.size();\\n        \\n        int mini = INT_MAX;\\n        \\n        unordered_map<int, vector<string>> mp;\\n        \\n        for(int i = 0; i < n1; i++)\\n        {\\n            for(int j = 0; j < n2; j++)\\n            {\\n                if(list1[i] == list2[j])\\n                {\\n                    mp[i + j].push_back(list1[i]);\\n                    \\n                    mini = min(mini, i + j);\\n                }\\n            }\\n        }\\n        \\n        return mp[mini];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772628,
                "title": "easy-hashmap-solution-full-approach-explanation-linear",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe make use of a HashMap to solve the given problem in a different way in this approach. Firstly, we traverse over the whole list1 and create an entry for each element of list1 in a HashMap map, of the form (list[i],i). Here, i refers to the index of the ith element, and list[i] is the ith element itself. Thus, we create a mapping from the elements of list1 to their indices.\\n\\nNow, we traverse over list2. For every element ,list2[j], of list2 encountered, we check if the same element already exists as a key in the map. If so, it means that the element exists in both list1 and list2. Thus, we find out the sum of indices corresponding to this element in the two lists, given by sum = map.get(list[j]) + jsum. If this sum is lesser than the minimum sum obtained till now, we update the resultant list to be returned, res, with the element list2[j] as the only entry in it.\\n\\nIf the sum is equal to the minimum sum obtained till now, we put an extra entry corresponding to the element list2[j] in the res list.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Time complexity : O(l1+l2)\\n   where l1 and l2 are the lengths of list1 and list2 respectively.\\n\\u200B\\n \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(l1\\u2217x)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i=0; i<list1.length; i++){\\n            map.put(list1[i], i);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        ArrayList<String> str = new ArrayList<>();\\n        for(int i=0; i<list2.length; i++){\\n            if(map.containsKey(list2[i])){\\n                int sum = map.get(list2[i])+i;\\n                if(sum < min){\\n                    min = sum;\\n                    str.clear();    //This deletes all elements of arraylist\\n                    str.add(list2[i]);\\n                }\\n                else if(min == sum){\\n                    str.add(list2[i]);\\n                }\\n            }\\n        }\\n        return str.toArray(new String[0]);\\n    }\\n}\\n```\\n![upvoteCat.png](https://assets.leetcode.com/users/images/914a7237-6d00-4fb1-94e1-9a6c39ebd67c_1689496406.0431306.png)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i=0; i<list1.length; i++){\\n            map.put(list1[i], i);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        ArrayList<String> str = new ArrayList<>();\\n        for(int i=0; i<list2.length; i++){\\n            if(map.containsKey(list2[i])){\\n                int sum = map.get(list2[i])+i;\\n                if(sum < min){\\n                    min = sum;\\n                    str.clear();    //This deletes all elements of arraylist\\n                    str.add(list2[i]);\\n                }\\n                else if(min == sum){\\n                    str.add(list2[i]);\\n                }\\n            }\\n        }\\n        return str.toArray(new String[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269812,
                "title": "python3-beats-99-13-using-dictionary-simple-solution",
                "content": "# Please do upvote if you find the solution helpful.\\n![image.png](https://assets.leetcode.com/users/images/07c5515b-82e4-4a49-9f04-628782ab3768_1678213943.2728896.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d={}\\n        for i in range(len(list1)):\\n            for j in range(len(list2)):\\n                if list1[i] == list2[j]:\\n                    d[list1[i]] = i+j\\n        lst=[]\\n        for i,j in d.items():\\n            if j == min(d.values()):\\n                lst.append(i)\\n        return lst\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d={}\\n        for i in range(len(list1)):\\n            for j in range(len(list2)):\\n                if list1[i] == list2[j]:\\n                    d[list1[i]] = i+j\\n        lst=[]\\n        for i,j in d.items():\\n            if j == min(d.values()):\\n                lst.append(i)\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881003,
                "title": "java-simple-easy",
                "content": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String,Integer> map=new HashMap<>();\\n        List<String> list=new ArrayList<>();\\n        int sum=Integer.MAX_VALUE;\\n        for(int i=0;i<list1.length;i++) map.put(list1[i],i);\\n        for(int i=0;i<list2.length;i++){\\n            Integer k=map.get(list2[i]);\\n            if(k!=null && k+i<sum ){\\n                list.clear();\\n                sum=k+i;\\n                list.add(list2[i]);\\n            }\\n            else if(k!=null && k+i<=sum){\\n                list.add(list2[i]);\\n            }\\n        }\\n        return list.toArray(new String[list.size()]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String,Integer> map=new HashMap<>();\\n        List<String> list=new ArrayList<>();\\n        int sum=Integer.MAX_VALUE;\\n        for(int i=0;i<list1.length;i++) map.put(list1[i],i);\\n        for(int i=0;i<list2.length;i++){\\n            Integer k=map.get(list2[i]);\\n            if(k!=null && k+i<sum ){\\n                list.clear();\\n                sum=k+i;\\n                list.add(list2[i]);\\n            }\\n            else if(k!=null && k+i<=sum){\\n                list.add(list2[i]);\\n            }\\n        }\\n        return list.toArray(new String[list.size()]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738689,
                "title": "c-o-n-86ms-hashmap-code-with-comments",
                "content": "\\n        vector<string> res;      \\n        int sum=INT_MAX;\\n        \\n        unordered_map<string,int> map;\\n        for(int j=0;j<list1.size();j++){\\n            map[list1[j]]=j;                    //insert list1 into map\\n        }\\n        \\n        for(int i=0;i<list2.size();i++){        //traverse list 2\\n            if(map.find(list2[i])!=map.end()){  //search for each element and if found\\n                if(map[list2[i]]+i<sum){        //check sum of index less than sum or not\\n                    res.clear();                //if true res is cleared as lesser sum found\\n                    res.push_back(list2[i]);    //value of index i of list2 is added to res\\n                    sum=map[list2[i]]+i;        //update sum for next iteration\\n                }\\n                else if(map[list2[i]]+i==sum)   //if equal then this value is also added to the res\\n                    res.push_back(list2[i]);\\n            }\\n        }\\n        \\n        return res;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n        vector<string> res;      \\n        int sum=INT_MAX;\\n        \\n        unordered_map<string,int> map;\\n        for(int j=0;j<list1.size();j++){\\n            map[list1[j]]=j;                    //insert list1 into map\\n        }\\n        \\n        for(int i=0;i<list2.size();i++){        //traverse list 2\\n            if(map.find(list2[i])!=map.end()){  //search for each element and if found\\n                if(map[list2[i]]+i<sum){        //check sum of index less than sum or not\\n                    res.clear();                //if true res is cleared as lesser sum found\\n                    res.push_back(list2[i]);    //value of index i of list2 is added to res\\n                    sum=map[list2[i]]+i;        //update sum for next iteration\\n                }\\n                else if(map[list2[i]]+i==sum)   //if equal then this value is also added to the res\\n                    res.push_back(list2[i]);\\n            }\\n        }\\n        \\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 322322,
                "title": "2-lines-python",
                "content": "```python\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d = {x: list1.index(x) + list2.index(x) for x in set(list1) & set(list2)}\\n        return [x for x in d if d[x] == min(d.values())]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d = {x: list1.index(x) + list2.index(x) for x in set(list1) & set(list2)}\\n        return [x for x in d if d[x] == min(d.values())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834764,
                "title": "simple-python3-solution-using-sets-and-dictionary",
                "content": "# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        set1 = set(list1)\\n        set2 = set(list2)\\n        common = list(set1 & set2)\\n        d = {}\\n        for i in common:\\n            d[i] = list1.index(i) + list2.index(i)\\n        min_index= min(d.values())\\n        op = []\\n        for i in d:\\n            if d[i] == min_index:\\n                op.append(i)\\n        return op\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        set1 = set(list1)\\n        set2 = set(list2)\\n        common = list(set1 & set2)\\n        d = {}\\n        for i in common:\\n            d[i] = list1.index(i) + list2.index(i)\\n        min_index= min(d.values())\\n        op = []\\n        for i in d:\\n            if d[i] == min_index:\\n                op.append(i)\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663982,
                "title": "c-solution-using-maps",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        map<string,int> m;\\n        vector<string>s;\\n        for(int i=0;i<list1.size();i++){\\n            if(m.find(list1[i])==m.end()){\\n                m.insert({list1[i],i});\\n            }\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<list2.size();i++){\\n            if(m.find(list2[i])!=m.end()){\\n                if(m[list2[i]]+i<res){\\n                    res=m[list2[i]]+i;\\n                }\\n            }\\n        }\\n        for(int i=0;i<list2.size();i++){\\n            if(m.find(list2[i])!=m.end() && m[list2[i]]+i==res){\\n                s.push_back(list2[i]);\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        map<string,int> m;\\n        vector<string>s;\\n        for(int i=0;i<list1.size();i++){\\n            if(m.find(list1[i])==m.end()){\\n                m.insert({list1[i],i});\\n            }\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<list2.size();i++){\\n            if(m.find(list2[i])!=m.end()){\\n                if(m[list2[i]]+i<res){\\n                    res=m[list2[i]]+i;\\n                }\\n            }\\n        }\\n        for(int i=0;i<list2.size();i++){\\n            if(m.find(list2[i])!=m.end() && m[list2[i]]+i==res){\\n                s.push_back(list2[i]);\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886838,
                "title": "javascript-hash",
                "content": "```\\nvar findRestaurant = function(list1, list2) {\\n    let result = []\\n    let map = new Map()\\n    for (let i = 0; i < list1.length; i++) {\\n        map.set(list1[i], i)\\n    }\\n    let min = Infinity\\n    for (let i = 0; i < list2.length; i++) {\\n        if (map.has(list2[i])) {\\n                if (map.get(list2[i]) + i < min) {\\n                    result = [list2[i]]\\n                    min = map.get(list2[i]) + i\\n        } else if (map.get(list2[i]) + i === min) {\\n           result.push(list2[i])\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\nreturn result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findRestaurant = function(list1, list2) {\\n    let result = []\\n    let map = new Map()\\n    for (let i = 0; i < list1.length; i++) {\\n        map.set(list1[i], i)\\n    }\\n    let min = Infinity\\n    for (let i = 0; i < list2.length; i++) {\\n        if (map.has(list2[i])) {\\n                if (map.get(list2[i]) + i < min) {\\n                    result = [list2[i]]\\n                    min = map.get(list2[i]) + i\\n        } else if (map.get(list2[i]) + i === min) {\\n           result.push(list2[i])\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\nreturn result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463926,
                "title": "js-o-m-n-time",
                "content": "```\\nvar findRestaurant = function(list1, list2) {\\n    const map = new Map();\\n    list1.forEach((restaurant, idx) => map.set(restaurant, idx));\\n    \\n    let minIndexSum = Infinity;\\n    const sumMap = new Map();\\n    \\n    list2.forEach((restaurant, idx) => {\\n        if(map.has(restaurant)) {\\n            const sum = map.get(restaurant) + idx;\\n            const value = sumMap.has(sum) ? sumMap.get(sum) : [];\\n            value.push(restaurant);\\n            sumMap.set(sum, value);\\n            minIndexSum = Math.min(minIndexSum, sum);\\n        }\\n    })\\n    return sumMap.get(minIndexSum);\\n};\\n```\\n\\nTime Complexity = O(m + n) [m - list1 length, n - list2 length]\\nSpace Complexity = O(m * k + min(m, n) * k) [k - average length of the strings]\\n\\nWe can optimize the space by not storing all the matching restaurants with or without least index sum. That canbe avoided by adding checks against the `minIndexSum` value.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findRestaurant = function(list1, list2) {\\n    const map = new Map();\\n    list1.forEach((restaurant, idx) => map.set(restaurant, idx));\\n    \\n    let minIndexSum = Infinity;\\n    const sumMap = new Map();\\n    \\n    list2.forEach((restaurant, idx) => {\\n        if(map.has(restaurant)) {\\n            const sum = map.get(restaurant) + idx;\\n            const value = sumMap.has(sum) ? sumMap.get(sum) : [];\\n            value.push(restaurant);\\n            sumMap.set(sum, value);\\n            minIndexSum = Math.min(minIndexSum, sum);\\n        }\\n    })\\n    return sumMap.get(minIndexSum);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1382036,
                "title": "easy-python-solution-memory-usage-less-than-97",
                "content": "# Easy Python Solution (Memory Usage less than 97%)\\n\\n**Runtime: 148 ms.\\nMemory Usage: 14.6 MB, less than 97% of Python3 online submissions for Minimum Index Sum of Two Lists.**\\n\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d = {}\\n        d2 = {}\\n        min_ = 5000\\n        ret = []\\n\\n        for i in range(len(list1)):\\n            d[list1[i]] = i+1\\n\\n        for i in range(len(list2)):\\n            a = d.get(list2[i], 0)\\n            if a:\\n                b = a+i-1\\n                if b <= min_:\\n                    min_ = b\\n                    d2[list2[i]] = b\\n\\n        for k,v in d2.items():\\n            if v <= min_:\\n                ret.append(k)\\n\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d = {}\\n        d2 = {}\\n        min_ = 5000\\n        ret = []\\n\\n        for i in range(len(list1)):\\n            d[list1[i]] = i+1\\n\\n        for i in range(len(list2)):\\n            a = d.get(list2[i], 0)\\n            if a:\\n                b = a+i-1\\n                if b <= min_:\\n                    min_ = b\\n                    d2[list2[i]] = b\\n\\n        for k,v in d2.items():\\n            if v <= min_:\\n                ret.append(k)\\n\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347183,
                "title": "c-easy-to-understand-straightforward-using-map",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n    map<int,vector<string> > mp;\\n        vector<string>::iterator it;\\n        for(int i=0;i<list1.size();i++)\\n        {\\n            it=find(list2.begin(),list2.end(),list1[i]);\\n            if(it!=list2.end())\\n            {\\n                mp[it-list2.begin()+i].push_back(list1[i]);\\n            }\\n        }  \\n          map<int,vector<string> >::iterator itr;\\n          itr=mp.begin();\\n          return itr->second;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n    map<int,vector<string> > mp;\\n        vector<string>::iterator it;\\n        for(int i=0;i<list1.size();i++)\\n        {\\n            it=find(list2.begin(),list2.end(),list1[i]);\\n            if(it!=list2.end())\\n            {\\n                mp[it-list2.begin()+i].push_back(list1[i]);\\n            }\\n        }  \\n          map<int,vector<string> >::iterator itr;\\n          itr=mp.begin();\\n          return itr->second;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172030,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        dic = {}\\n        lst = []\\n        res = []\\n        minSum = float(\\'inf\\')\\n        for i,v in enumerate(list1):\\n            dic[v] = i\\n        for i,v in enumerate(list2):\\n            if v in dic:\\n                summ = dic[v] + i\\n                if summ < minSum:\\n                    res = [v]\\n                    minSum = summ\\n                elif summ == minSum:\\n                    res.append(v)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        dic = {}\\n        lst = []\\n        res = []\\n        minSum = float(\\'inf\\')\\n        for i,v in enumerate(list1):\\n            dic[v] = i\\n        for i,v in enumerate(list2):\\n            if v in dic:\\n                summ = dic[v] + i\\n                if summ < minSum:\\n                    res = [v]\\n                    minSum = summ\\n                elif summ == minSum:\\n                    res.append(v)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103658,
                "title": "python-5-lines-o-n-time-o-n-space",
                "content": "```\\nclass Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        dict1 = {rest : i for i, rest in enumerate(list1)}\\n        dict2 = {rest : i for i, rest in enumerate(list2)}\\n        dictSum = {rest : dict1[rest]+dict2[rest] for rest in dict1 if rest in dict2}\\n        minSum = min(dictSum.values())\\n        return [key for key in dictSum if dictSum[key] == minSum]\\n```\\nOr a little bit faster solution:\\n```\\nclass Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        dict1 = {rest : i for i, rest in enumerate(list1)}\\n        dict2 = {rest : i for i, rest in enumerate(list2)}\\n        dictSum = {rest : dict1[rest]+dict2.get(rest, 2017) for rest in dict1}\\n        minSum = min(dictSum.values())\\n        return [key for key in dictSum if dictSum[key] == minSum]\\n```\\nThe fourth line in both solutions could be in the last one (```return [key for key in dictSum if dictSum[key] == min(dictSum.values())```), but that makes it slower. Is that because it calculates the min again every iteration?",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        dict1 = {rest : i for i, rest in enumerate(list1)}\\n        dict2 = {rest : i for i, rest in enumerate(list2)}\\n        dictSum = {rest : dict1[rest]+dict2[rest] for rest in dict1 if rest in dict2}\\n        minSum = min(dictSum.values())\\n        return [key for key in dictSum if dictSum[key] == minSum]\\n```\n```\\nclass Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        dict1 = {rest : i for i, rest in enumerate(list1)}\\n        dict2 = {rest : i for i, rest in enumerate(list2)}\\n        dictSum = {rest : dict1[rest]+dict2.get(rest, 2017) for rest in dict1}\\n        minSum = min(dictSum.values())\\n        return [key for key in dictSum if dictSum[key] == minSum]\\n```\n```return [key for key in dictSum if dictSum[key] == min(dictSum.values())```",
                "codeTag": "Java"
            },
            {
                "id": 103713,
                "title": "python-easy-understand-solution",
                "content": "1. Get common words\\n2. Calculate index sum using ```collections.Counter```\\n3. Find the minimum\\n4. Return result\\n\\n````\\n    def findRestaurant(self, l1, l2):\\n        d = set(l1) & set(l2)\\n        c = Counter({v: i + 1 for i, v in enumerate(l1) if v in d}) + \\\\\\n            Counter({v: i + 1 for i, v in enumerate(l2) if v in d})\\n        res = min(c.values())\\n        return [i for i, v in c.items() if v == res]",
                "solutionTags": [],
                "code": "```collections.Counter```",
                "codeTag": "Unknown"
            },
            {
                "id": 3458874,
                "title": "easily-understandable-python-code-brute-force-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        m = len(list1) + len(list2)\\n        list3 = []\\n        \\n        for i in range(len(list1)):\\n            for j in range(len(list2)):\\n                if list1[i] == list2[j]:\\n                    if (i+j)<=m:\\n                        if list3 == None:\\n                            list3.append(list2[j])\\n                        \\n                        elif m == i+j:\\n                            list3.append(list2[j])\\n                        \\n                        else:\\n                            list3=[]\\n                            list3.append(list2[j])\\n                        \\n                        m = i + j\\n        return list3\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        m = len(list1) + len(list2)\\n        list3 = []\\n        \\n        for i in range(len(list1)):\\n            for j in range(len(list2)):\\n                if list1[i] == list2[j]:\\n                    if (i+j)<=m:\\n                        if list3 == None:\\n                            list3.append(list2[j])\\n                        \\n                        elif m == i+j:\\n                            list3.append(list2[j])\\n                        \\n                        else:\\n                            list3=[]\\n                            list3.append(list2[j])\\n                        \\n                        m = i + j\\n        return list3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409233,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string,int> mp,m;\\n        vector<string> v;\\n        int mini =INT_MAX;\\n        int mi;\\n        int sum;\\n        for(int i=0;i<list1.size();i++)\\n            m[list1[i]] = i;\\n        for(int j=0;j<list2.size();j++)\\n        {\\n            if(m.find(list2[j]) != m.end())\\n            {\\n                sum = j + m[list2[j]];\\n                if(sum<mini)\\n                {\\n                    v.clear();\\n                    mini = sum;\\n                    v.push_back(list2[j]);\\n                }\\n                else if( sum == mini)\\n                    v.push_back(list2[j]);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n\\n        def result(l1, l2) -> List[str]:\\n            hashmap, res, minInd = {}, [], len(list1) + len(list2) - 2\\n\\n            for ind, val in enumerate(l1):\\n                hashmap[val] = ind\\n\\n            for ind, val in enumerate(l2):\\n                if val in hashmap and hashmap[val] + ind <= minInd:\\n                    if hashmap[val] + ind < minInd:\\n                        res.clear()\\n                        minInd = hashmap[val] + ind\\n                    res.append(val)\\n\\n            return res\\n\\n        return result(list1, list2) if len(list1) < len(list2) else result(list2, list1)\\n```\\n\\n```Java []\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        if (list1.length > list2.length) {\\n            return findRestaurant(list2, list1);\\n        }\\n        HashMap <String, Integer> hm = new HashMap<>();\\n        for(int i=0;i< list1.length;i++) {\\n            hm.put(list1[i], i);\\n        }\\n        int count=0;\\n        int minval = Integer.MAX_VALUE;\\n        List<String> op = new ArrayList<>();\\n        for(int i=0;i< list2.length&& i <= minval;i++) {\\n            Integer x = hm.get(list2[i]);\\n            if(x!=null) {\\n                    if(minval> x+i){\\n                        op.add(0,list2[i]);\\n                        minval=x+i;\\n                        count=1;\\n                    } else if(minval == x+i) {\\n                    op.add(count++, list2[i]);\\n                    }\\n            }\\n        }\\n        return op.subList(0, count).toArray(new String[0]);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string,int> mp,m;\\n        vector<string> v;\\n        int mini =INT_MAX;\\n        int mi;\\n        int sum;\\n        for(int i=0;i<list1.size();i++)\\n            m[list1[i]] = i;\\n        for(int j=0;j<list2.size();j++)\\n        {\\n            if(m.find(list2[j]) != m.end())\\n            {\\n                sum = j + m[list2[j]];\\n                if(sum<mini)\\n                {\\n                    v.clear();\\n                    mini = sum;\\n                    v.push_back(list2[j]);\\n                }\\n                else if( sum == mini)\\n                    v.push_back(list2[j]);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n\\n        def result(l1, l2) -> List[str]:\\n            hashmap, res, minInd = {}, [], len(list1) + len(list2) - 2\\n\\n            for ind, val in enumerate(l1):\\n                hashmap[val] = ind\\n\\n            for ind, val in enumerate(l2):\\n                if val in hashmap and hashmap[val] + ind <= minInd:\\n                    if hashmap[val] + ind < minInd:\\n                        res.clear()\\n                        minInd = hashmap[val] + ind\\n                    res.append(val)\\n\\n            return res\\n\\n        return result(list1, list2) if len(list1) < len(list2) else result(list2, list1)\\n```\n```Java []\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        if (list1.length > list2.length) {\\n            return findRestaurant(list2, list1);\\n        }\\n        HashMap <String, Integer> hm = new HashMap<>();\\n        for(int i=0;i< list1.length;i++) {\\n            hm.put(list1[i], i);\\n        }\\n        int count=0;\\n        int minval = Integer.MAX_VALUE;\\n        List<String> op = new ArrayList<>();\\n        for(int i=0;i< list2.length&& i <= minval;i++) {\\n            Integer x = hm.get(list2[i]);\\n            if(x!=null) {\\n                    if(minval> x+i){\\n                        op.add(0,list2[i]);\\n                        minval=x+i;\\n                        count=1;\\n                    } else if(minval == x+i) {\\n                    op.add(count++, list2[i]);\\n                    }\\n            }\\n        }\\n        return op.subList(0, count).toArray(new String[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100635,
                "title": "java-using-map",
                "content": "# Code\\n```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < list1.length; i++) map.put(list1[i], i);\\n        int min = 2001;\\n        List<String> words = new ArrayList<>();\\n        for (int i = 0; i < list2.length; i++) {\\n            int idx = map.getOrDefault(list2[i], 2001), sum = idx + i;\\n            if (min > sum) min = sum;\\n        }\\n\\n        for (int i = 0; i < list2.length; i++) {\\n            int idx = map.getOrDefault(list2[i], 2001), sum = idx + i;\\n            if (sum == min) words.add(list2[i]);\\n        }\\n\\n        return words.toArray(new String[0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < list1.length; i++) map.put(list1[i], i);\\n        int min = 2001;\\n        List<String> words = new ArrayList<>();\\n        for (int i = 0; i < list2.length; i++) {\\n            int idx = map.getOrDefault(list2[i], 2001), sum = idx + i;\\n            if (min > sum) min = sum;\\n        }\\n\\n        for (int i = 0; i < list2.length; i++) {\\n            int idx = map.getOrDefault(list2[i], 2001), sum = idx + i;\\n            if (sum == min) words.add(list2[i]);\\n        }\\n\\n        return words.toArray(new String[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870719,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        int n = list1.size(), m = list2.size();\\n        unordered_map<string,int> first;\\n        for(int i=0; i<n; ++i) first.insert({list1[i],i+1});\\n        vector<pair<string,int>> v;\\n        vector<string> ans;\\n        for(int i=0; i<m; ++i){\\n            int x = first[list2[i]];\\n            if(x) v.push_back({list2[i],x+i-1});\\n        }\\n        int mn = INT_MAX;\\n        for(auto &[x,y]: v) mn = min(mn,y);\\n        for(auto [s,x]: v) if(x == mn) ans.push_back(s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        int n = list1.size(), m = list2.size();\\n        unordered_map<string,int> first;\\n        for(int i=0; i<n; ++i) first.insert({list1[i],i+1});\\n        vector<pair<string,int>> v;\\n        vector<string> ans;\\n        for(int i=0; i<m; ++i){\\n            int x = first[list2[i]];\\n            if(x) v.push_back({list2[i],x+i-1});\\n        }\\n        int mn = INT_MAX;\\n        for(auto &[x,y]: v) mn = min(mn,y);\\n        for(auto [s,x]: v) if(x == mn) ans.push_back(s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769997,
                "title": "cpp-solution-using-map-in-10-lines",
                "content": "vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        map<string,int> mp;\\n        map<int,vector<string>> ans;\\n        for(int i=1;i<=list1.size();i++)  mp.insert({list1[i-1],i});\\n        \\n        int i=0;\\n        for(auto it:list2){\\n            if(mp[it]!=0)  ans[mp[it]+i].push_back(it);\\n             i++;\\n        }\\n       return  ans.begin()->second;\\n    }",
                "solutionTags": [],
                "code": "vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        map<string,int> mp;\\n        map<int,vector<string>> ans;\\n        for(int i=1;i<=list1.size();i++)  mp.insert({list1[i-1],i});\\n        \\n        int i=0;\\n        for(auto it:list2){\\n            if(mp[it]!=0)  ans[mp[it]+i].push_back(it);\\n             i++;\\n        }\\n       return  ans.begin()->second;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2594187,
                "title": "python-simplest-solution",
                "content": "Example: list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        temp = defaultdict(list)\\n        ind = 0\\n        for i in list1:\\n            if i in list2:\\n                ind = list1.index(i)+list2.index(i)\\n                temp[ind].append(i)\\n        return(temp[min(list(temp))])\\n```\\ntemp = {1: [\\'happy\\', \\'sad\\'], 4: [\\'good\\']}\\nlist(temp) = [1, 4]\\nmin(list(temp)) = 1\\ntemp[1] = [\\'happy\\', \\'sad\\']",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        temp = defaultdict(list)\\n        ind = 0\\n        for i in list1:\\n            if i in list2:\\n                ind = list1.index(i)+list2.index(i)\\n                temp[ind].append(i)\\n        return(temp[min(list(temp))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477820,
                "title": "js-simple-solution-with-hashmap-faster-than-100",
                "content": "```\\nvar findRestaurant = function(list1, list2) {\\n    const hashmap = new Map();\\n    let output;\\n    \\n    for (let i = 0; i < list1.length; i++) {\\n        hashmap.set(list1[i], i);\\n    }\\n    \\n    for (let j = 0; j < list2.length; j++) {\\n        const isExist = hashmap.has(list2[j]);\\n        const indexOfRestaurant = hashmap.get(list2[j]);\\n        if (isExist && (!output || j + indexOfRestaurant < output.sumIndex)) {\\n            output = {\\n                value: [list2[j]],\\n                sumIndex: j + indexOfRestaurant,\\n            }\\n        } else if (isExist && j + indexOfRestaurant === output.sumIndex) {\\n            output.value.push(list2[j]);\\n        }\\n    }\\n    \\n    return output.value;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findRestaurant = function(list1, list2) {\\n    const hashmap = new Map();\\n    let output;\\n    \\n    for (let i = 0; i < list1.length; i++) {\\n        hashmap.set(list1[i], i);\\n    }\\n    \\n    for (let j = 0; j < list2.length; j++) {\\n        const isExist = hashmap.has(list2[j]);\\n        const indexOfRestaurant = hashmap.get(list2[j]);\\n        if (isExist && (!output || j + indexOfRestaurant < output.sumIndex)) {\\n            output = {\\n                value: [list2[j]],\\n                sumIndex: j + indexOfRestaurant,\\n            }\\n        } else if (isExist && j + indexOfRestaurant === output.sumIndex) {\\n            output.value.push(list2[j]);\\n        }\\n    }\\n    \\n    return output.value;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420731,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string> ans;\\n        unordered_map<string, int> Andy;\\n        int i = 0;\\n        for(string &list : list1)\\n        {\\n            Andy[list] = i;\\n            i++;\\n        }\\n        i=-1;\\n        int MinIdx = INT_MAX;\\n        for(string &str : list2)\\n        {\\n            i++;\\n            if(!Andy.count(str)) continue;\\n            int val = Andy[str]+i;\\n            if(val == MinIdx)\\n            {\\n                ans.push_back(str);\\n                continue;\\n            }\\n            else if(val < MinIdx)\\n            {\\n                ans.clear();\\n                MinIdx = val;\\n                ans.push_back(str);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string> ans;\\n        unordered_map<string, int> Andy;\\n        int i = 0;\\n        for(string &list : list1)\\n        {\\n            Andy[list] = i;\\n            i++;\\n        }\\n        i=-1;\\n        int MinIdx = INT_MAX;\\n        for(string &str : list2)\\n        {\\n            i++;\\n            if(!Andy.count(str)) continue;\\n            int val = Andy[str]+i;\\n            if(val == MinIdx)\\n            {\\n                ans.push_back(str);\\n                continue;\\n            }\\n            else if(val < MinIdx)\\n            {\\n                ans.clear();\\n                MinIdx = val;\\n                ans.push_back(str);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120955,
                "title": "c-clever-solution-only-1-traversal",
                "content": "We iterated over both the list only once , so \\nlet n= list1.size() , m = list2.size()\\nand our time complexity will be O(n+m) .\\nSince we also used find function , altough its average time complexity is O(1) but the worst case time complexity is O(n) therefore we can say that our overall time complexity could be a litter higher than O(n+m) \\nSpace complexity : O(n)\\n```\\n vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string> ans;\\n         if(list1[0]==list2[0])\\n        {\\n            ans.emplace_back(list1[0]);\\n            return ans;\\n        }\\n        unordered_map<string , int> m;\\n        int l1=list1.size(),l2=list2.size(),k=INT_MIN,c;\\n        for(int i=0;i<l1;i++)\\n        {\\n            m[list1[i]]=i;\\n        }\\n        for(int i=0;i<l2;i++)\\n        {\\n            if(m.find(list2[i]) != m.end())\\n            {\\n                c=m[list2[i]];\\n                c= -(i+c);\\n                if(c>k) k=c;\\n                m[list2[i]]=c;\\n            }\\n        }\\n        for(auto it : m)\\n        {\\n            if(it.second == k) ans.emplace_back(it.first);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string> ans;\\n         if(list1[0]==list2[0])\\n        {\\n            ans.emplace_back(list1[0]);\\n            return ans;\\n        }\\n        unordered_map<string , int> m;\\n        int l1=list1.size(),l2=list2.size(),k=INT_MIN,c;\\n        for(int i=0;i<l1;i++)\\n        {\\n            m[list1[i]]=i;\\n        }\\n        for(int i=0;i<l2;i++)\\n        {\\n            if(m.find(list2[i]) != m.end())\\n            {\\n                c=m[list2[i]];\\n                c= -(i+c);\\n                if(c>k) k=c;\\n                m[list2[i]]=c;\\n            }\\n        }\\n        for(auto it : m)\\n        {\\n            if(it.second == k) ans.emplace_back(it.first);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2119521,
                "title": "python-two-approaches-dictionary-and-check-all-possible-sums",
                "content": "# Dictionary\\nWe save `list1` in a dictionary where the keys are the restaurants and the values their position in the list. We then traverse `list2` and whenever we find a restaurant that is in both lists, we check their index sum. We keep a list of all the restaurants with the smallest index sum we\\'ve found so far.\\n\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        n, m = len(list1), len(list2)\\n        list1Hash = {restaurant: i for i, restaurant in enumerate(list1)}\\n        \\n        minIndexSum = n + m\\n        for j, restaurant in enumerate(list2):\\n            i = list1Hash.get(restaurant, n)\\n            if i < n and i + j < minIndexSum:\\n                minIndexSum = i + j\\n                minIndexRestaurants = [restaurant]\\n            elif i + j == minIndexSum:\\n                minIndexRestaurants.append(restaurant)\\n                \\n        return minIndexRestaurants\\n```\\n\\n# Check all possible sums\\nFor each possible `indexSum`s we check all valid indexes `i`, and `j` for which `i + j = indexSum`. If we find any such that `list1[i] == list2[j]`, we keep `list1[i]` in a list and return that list once we\\'ve added all possible restaurants to it. Since we are looking for the smallest possible sum, if we check the possible sums from smallest to largest, once we find at least one coincidence for that `indexSum`, that must be the `indexSum` we were looking for. \\n\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        n, m = len(list1), len(list2)       \\n        \\n\\t\\tminIndexRestaurants = []\\n        for indexSum in range(n + m):\\n\\t\\t\\t# we need that 0 <= j <= m - 1 and 0 <= indexSum - j <= n - 1\\n            for j in range(max(indexSum - n + 1, 0), min(m, indexSum + 1)):\\n                if list1[indexSum - j] == list2[j]:\\n                    minIndexRestaurants.append(list2[j])\\n\\t\\t\\t# if minIndexResturants is no longer empty, we\\'ve successfully found the smallest index sum possible\\n            if minIndexRestaurants:\\n                return minIndexRestaurants\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        n, m = len(list1), len(list2)\\n        list1Hash = {restaurant: i for i, restaurant in enumerate(list1)}\\n        \\n        minIndexSum = n + m\\n        for j, restaurant in enumerate(list2):\\n            i = list1Hash.get(restaurant, n)\\n            if i < n and i + j < minIndexSum:\\n                minIndexSum = i + j\\n                minIndexRestaurants = [restaurant]\\n            elif i + j == minIndexSum:\\n                minIndexRestaurants.append(restaurant)\\n                \\n        return minIndexRestaurants\\n```\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        n, m = len(list1), len(list2)       \\n        \\n\\t\\tminIndexRestaurants = []\\n        for indexSum in range(n + m):\\n\\t\\t\\t# we need that 0 <= j <= m - 1 and 0 <= indexSum - j <= n - 1\\n            for j in range(max(indexSum - n + 1, 0), min(m, indexSum + 1)):\\n                if list1[indexSum - j] == list2[j]:\\n                    minIndexRestaurants.append(list2[j])\\n\\t\\t\\t# if minIndexResturants is no longer empty, we\\'ve successfully found the smallest index sum possible\\n            if minIndexRestaurants:\\n                return minIndexRestaurants\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069766,
                "title": "java-easy-solution-hashmap",
                "content": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<list1.length; i++)\\n            map.put(list1[i], i);\\n        \\n        int minSum = Integer.MAX_VALUE;\\n        ArrayList<String> result = new ArrayList<>();\\n        \\n        for(int i=0; i<list2.length; i++) {\\n            if(map.containsKey(list2[i])) {\\n                if(minSum > i+map.get(list2[i])) {\\n                    minSum = i + map.get(list2[i]);\\n                    result.clear();\\n                    result.add(list2[i]);\\n                } else if ( minSum == i+map.get(list2[i])) {\\n                    result.add(list2[i]);\\n                }\\n            }\\n        }\\n        \\n        return result.toArray(new String[result.size()]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<list1.length; i++)\\n            map.put(list1[i], i);\\n        \\n        int minSum = Integer.MAX_VALUE;\\n        ArrayList<String> result = new ArrayList<>();\\n        \\n        for(int i=0; i<list2.length; i++) {\\n            if(map.containsKey(list2[i])) {\\n                if(minSum > i+map.get(list2[i])) {\\n                    minSum = i + map.get(list2[i]);\\n                    result.clear();\\n                    result.add(list2[i]);\\n                } else if ( minSum == i+map.get(list2[i])) {\\n                    result.add(list2[i]);\\n                }\\n            }\\n        }\\n        \\n        return result.toArray(new String[result.size()]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890912,
                "title": "minimum-index-sum-of-two-lists-solution-java",
                "content": "class Solution {\\n  public String[] findRestaurant(String[] list1, String[] list2) {\\n    List<String> ans = new LinkedList<>();\\n    Map<String, Integer> restaurantToIndex = new HashMap<>();\\n    int minSum = Integer.MAX_VALUE;\\n\\n    for (int i = 0; i < list1.length; ++i)\\n      restaurantToIndex.put(list1[i], i);\\n\\n    for (int i = 0; i < list2.length; ++i) {\\n      final String restaurant = list2[i];\\n      if (restaurantToIndex.containsKey(restaurant)) {\\n        final int sum = restaurantToIndex.get(restaurant) + i;\\n        if (sum < minSum) {\\n          minSum = sum;\\n          ans.clear();\\n          ans.add(restaurant);\\n        } else if (sum == minSum) {\\n          ans.add(restaurant);\\n        }\\n      }\\n    }\\n\\n    return ans.toArray(new String[0]);\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "class Solution {\\n  public String[] findRestaurant(String[] list1, String[] list2) {\\n    List<String> ans = new LinkedList<>();\\n    Map<String, Integer> restaurantToIndex = new HashMap<>();\\n    int minSum = Integer.MAX_VALUE;\\n\\n    for (int i = 0; i < list1.length; ++i)\\n      restaurantToIndex.put(list1[i], i);\\n\\n    for (int i = 0; i < list2.length; ++i) {\\n      final String restaurant = list2[i];\\n      if (restaurantToIndex.containsKey(restaurant)) {\\n        final int sum = restaurantToIndex.get(restaurant) + i;\\n        if (sum < minSum) {\\n          minSum = sum;\\n          ans.clear();\\n          ans.add(restaurant);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1356389,
                "title": "python-solution-with-sets",
                "content": "```class Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        common = list(set(list1) & set(list2))\\n        res = {}\\n        for r in common:\\n            sumIndex = list1.index(r) + list2.index(r)\\n            res[r] = sumIndex\\n        temp = min(res.values())\\n        return [key for key in res if res[key] == temp]",
                "solutionTags": [],
                "code": "class Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        common = list(set(list1) & set(list2))\\n        res = {}",
                "codeTag": "Java"
            },
            {
                "id": 1351891,
                "title": "javascript-hashmap",
                "content": "```\\n/**\\n * @param {string[]} list1\\n * @param {string[]} list2\\n * @return {string[]}\\n */\\nvar findRestaurant = function(list1, list2) {\\n    var map = new Map();\\n    var map2 = new Map();\\n    var result = [];\\n    for(let i=0 ;i <list1.length; i++){\\n         map.set(list1[i] , i)\\n    }\\n    var min = +Infinity;\\n    for(let i=0; i<list2.length; i++){\\n        if( map.has(list2[i]) ){\\n            map2.set(list2[i], map.get(list2[i] ) + i);\\n            min = Math.min(min , map2.get(list2[i]) )\\n        }  \\n    }\\n    \\n   map2.forEach((val,key) =>{\\n       if(val === min){\\n           result.push(key)\\n       }\\n   })\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} list1\\n * @param {string[]} list2\\n * @return {string[]}\\n */\\nvar findRestaurant = function(list1, list2) {\\n    var map = new Map();\\n    var map2 = new Map();\\n    var result = [];\\n    for(let i=0 ;i <list1.length; i++){\\n         map.set(list1[i] , i)\\n    }\\n    var min = +Infinity;\\n    for(let i=0; i<list2.length; i++){\\n        if( map.has(list2[i]) ){\\n            map2.set(list2[i], map.get(list2[i] ) + i);\\n            min = Math.min(min , map2.get(list2[i]) )\\n        }  \\n    }\\n    \\n   map2.forEach((val,key) =>{\\n       if(val === min){\\n           result.push(key)\\n       }\\n   })\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1302980,
                "title": "python3-olution-mem-usage-97-better",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        list3 = set(list1) & set(list2)\\n        m, v = 3000, []\\n        for i in list3:\\n            s = list1.index(i) + list2.index(i)\\n            if m > s:\\n                v = [i]\\n                m = s\\n            elif m == s:\\n                v.append(i)\\n        return v\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        list3 = set(list1) & set(list2)\\n        m, v = 3000, []\\n        for i in list3:\\n            s = list1.index(i) + list2.index(i)\\n            if m > s:\\n                v = [i]\\n                m = s\\n            elif m == s:\\n                v.append(i)\\n        return v\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215398,
                "title": "c-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& l1, vector<string>& l2) \\n    {\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<l1.size();i++)\\n        {\\n            mp[l1[i]]=i;\\n        }\\n        int dis=INT_MAX;\\n        for(int i=0;i<l2.size();i++)\\n        {\\n            if(mp.count(l2[i]))\\n            {\\n                dis=min(dis,i+mp[l2[i]]);\\n            }\\n        }\\n        vector<string>v;\\n        for(int i=0;i<l2.size();i++)\\n        {\\n            if(mp.count(l2[i])&&dis==i+mp[l2[i]])\\n            {\\n                v.push_back(l2[i]);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& l1, vector<string>& l2) \\n    {\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<l1.size();i++)\\n        {\\n            mp[l1[i]]=i;\\n        }\\n        int dis=INT_MAX;\\n        for(int i=0;i<l2.size();i++)\\n        {\\n            if(mp.count(l2[i]))\\n            {\\n                dis=min(dis,i+mp[l2[i]]);\\n            }\\n        }\\n        vector<string>v;\\n        for(int i=0;i<l2.size();i++)\\n        {\\n            if(mp.count(l2[i])&&dis==i+mp[l2[i]])\\n            {\\n                v.push_back(l2[i]);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211206,
                "title": "python3-simple-solution-using-set",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        ans = []\\n        min_index = 10**4\\n        for i in set(list1).intersection(set(list2)):\\n            z = list1.index(i) + list2.index(i)\\n            if min_index > z:\\n                min_index = z\\n                ans = [i]\\n            elif min_index == z:\\n                ans.append(i)\\n        return ans\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        ans = []\\n        min_index = 10**4\\n        for i in set(list1).intersection(set(list2)):\\n            z = list1.index(i) + list2.index(i)\\n            if min_index > z:\\n                min_index = z\\n                ans = [i]\\n            elif min_index == z:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200991,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String,Integer> map = new HashMap<>();\\n        for(int i = 0; i < list1.length; i++){\\n            map.put(list1[i], i);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        List<String> list = new ArrayList<>();\\n        for(int i = 0; i < list2.length; i++){\\n            if(map.containsKey(list2[i])){\\n                if(min > map.get(list2[i]) + i){\\n                    list = new ArrayList<>();\\n                    list.add(list2[i]);\\n                    min = map.get(list2[i]) + i;\\n                }else if (min == map.get(list2[i]) + i){\\n                    list.add(list2[i]);\\n                }\\n            }\\n        }\\n        return list.toArray(new String[list.size()]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String,Integer> map = new HashMap<>();\\n        for(int i = 0; i < list1.length; i++){\\n            map.put(list1[i], i);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        List<String> list = new ArrayList<>();\\n        for(int i = 0; i < list2.length; i++){\\n            if(map.containsKey(list2[i])){\\n                if(min > map.get(list2[i]) + i){\\n                    list = new ArrayList<>();\\n                    list.add(list2[i]);\\n                    min = map.get(list2[i]) + i;\\n                }else if (min == map.get(list2[i]) + i){\\n                    list.add(list2[i]);\\n                }\\n            }\\n        }\\n        return list.toArray(new String[list.size()]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127203,
                "title": "swift-100",
                "content": "```\\nclass Solution {\\n    func findRestaurant(_ list1: [String], _ list2: [String]) -> [String] {\\n        var answer: [String] = []\\n        var common: [String: Int] = [:]\\n        var min = Int.max\\n        \\n        for i in 0..<list1.count {\\n            common[list1[i]] = i\\n        }\\n        for i in 0..<list2.count {\\n            if let indexCommon = common[list2[i]] {\\n                let sumIndex = indexCommon + i\\n                if sumIndex == min {\\n                    answer.append(list2[i])\\n                } else if sumIndex < min {\\n                    min = sumIndex\\n                    answer = [list2[i]]\\n                }\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findRestaurant(_ list1: [String], _ list2: [String]) -> [String] {\\n        var answer: [String] = []\\n        var common: [String: Int] = [:]\\n        var min = Int.max\\n        \\n        for i in 0..<list1.count {\\n            common[list1[i]] = i\\n        }\\n        for i in 0..<list2.count {\\n            if let indexCommon = common[list2[i]] {\\n                let sumIndex = indexCommon + i\\n                if sumIndex == min {\\n                    answer.append(list2[i])\\n                } else if sumIndex < min {\\n                    min = sumIndex\\n                    answer = [list2[i]]\\n                }\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955188,
                "title": "python-3-hashtable-one-loop",
                "content": "~~~\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        if list1 == list2 and len(list1) == 1:\\n            return list1\\n        \\n        dlist = collections.defaultdict(list)\\n        minInd = float(\"inf\")\\n        result = []\\n        for ind1, str1 in enumerate(list1):\\n            dlist[str1].append(ind1)\\n        for ind2, str2 in enumerate(list2):\\n            dlist[str2].append(ind2)\\n        for key, vals in dlist.items():\\n            if len(vals) == 2:\\n                if minInd == sum(vals):\\n                    result.append(key)\\n                if minInd > sum(vals):\\n                    minInd = sum(vals)\\n                    result.clear()\\n                    result.append(key)\\n        return result\\n~~~",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "~~~\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        if list1 == list2 and len(list1) == 1:\\n            return list1\\n        \\n        dlist = collections.defaultdict(list)\\n        minInd = float(\"inf\")\\n        result = []\\n        for ind1, str1 in enumerate(list1):\\n            dlist[str1].append(ind1)\\n        for ind2, str2 in enumerate(list2):\\n            dlist[str2].append(ind2)\\n        for key, vals in dlist.items():\\n            if len(vals) == 2:\\n                if minInd == sum(vals):\\n                    result.append(key)\\n                if minInd > sum(vals):\\n                    minInd = sum(vals)\\n                    result.clear()\\n                    result.append(key)\\n        return result\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 770005,
                "title": "java-o-n",
                "content": "```\\n    public String[] findRestaurant(String[] a, String[] b) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i  = 0; i < a.length; i++) map.put(a[i], i);\\n        List<String> res = new ArrayList<>();\\n        for (int i  = 0, min = Integer.MAX_VALUE; i < b.length; i++) {\\n            if (!map.containsKey(b[i]) || i + map.get(b[i]) > min) continue;\\n            if (i + map.get(b[i]) < min) {\\n                min = i + map.get(b[i]);\\n                res.clear();\\n            }\\n            res.add(b[i]);\\n        }\\n        return res.toArray(new String[res.size()]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String[] findRestaurant(String[] a, String[] b) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i  = 0; i < a.length; i++) map.put(a[i], i);\\n        List<String> res = new ArrayList<>();\\n        for (int i  = 0, min = Integer.MAX_VALUE; i < b.length; i++) {\\n            if (!map.containsKey(b[i]) || i + map.get(b[i]) > min) continue;\\n            if (i + map.get(b[i]) < min) {\\n                min = i + map.get(b[i]);\\n                res.clear();\\n            }\\n            res.add(b[i]);\\n        }\\n        return res.toArray(new String[res.size()]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657789,
                "title": "simple-java-solution-using-hashmap",
                "content": "Runtime: 7 ms, faster than 82.11% of Java online submissions for Minimum Index Sum of Two Lists.\\nMemory Usage: 40.2 MB, less than 32.26% of Java online submissions for Minimum Index Sum of Two Lists.\\n\\n```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        \\n        HashMap<String,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<list1.length;i++){\\n            \\n            map.put(list1[i],i);\\n            \\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        \\n        List<String> answer=new ArrayList<>();\\n        \\n        for(int i=0;i<list2.length;i++){\\n            \\n            if(map.containsKey(list2[i])){\\n                \\n                int temp= map.get(list2[i])+i;\\n                \\n                if(min>temp){\\n                    \\n                    min=temp;\\n                    \\n                    answer.clear();\\n                    \\n                    answer.add(list2[i]);\\n                    \\n                }else if(min == temp){\\n                    answer.add(list2[i]);\\n                }\\n                \\n            }\\n             \\n        }\\n        \\n        return answer.toArray(new String[answer.size()]);\\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        \\n        HashMap<String,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<list1.length;i++){\\n            \\n            map.put(list1[i],i);\\n            \\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        \\n        List<String> answer=new ArrayList<>();\\n        \\n        for(int i=0;i<list2.length;i++){\\n            \\n            if(map.containsKey(list2[i])){\\n                \\n                int temp= map.get(list2[i])+i;\\n                \\n                if(min>temp){\\n                    \\n                    min=temp;\\n                    \\n                    answer.clear();\\n                    \\n                    answer.add(list2[i]);\\n                    \\n                }else if(min == temp){\\n                    answer.add(list2[i]);\\n                }\\n                \\n            }\\n             \\n        }\\n        \\n        return answer.toArray(new String[answer.size()]);\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650911,
                "title": "python-hashtable-solution",
                "content": "```\\ndef findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        inter_list = set(list1).intersection(set(list2))\\n        if len(inter_list) == 1:\\n            return [inter_list][0]\\n        else:\\n            inter_list = list(inter_list)\\n            val_dict = {}\\n            for i in inter_list:\\n                val_dict[i] = list1.index(i) + list2.index(i)\\n            temp = min(val_dict.values())\\n            return [key for key in val_dict if val_dict[key] == temp]\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\ndef findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        inter_list = set(list1).intersection(set(list2))\\n        if len(inter_list) == 1:\\n            return [inter_list][0]\\n        else:\\n            inter_list = list(inter_list)\\n            val_dict = {}\\n            for i in inter_list:\\n                val_dict[i] = list1.index(i) + list2.index(i)\\n            temp = min(val_dict.values())\\n            return [key for key in val_dict if val_dict[key] == temp]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 523588,
                "title": "hashmap-priorityqueue-solution",
                "content": "```\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\n    int sum = 0;\\n\\t\\tList<String> result = new ArrayList<>();\\n\\t\\tMap<String, Integer> map = new HashMap<>();\\n\\t\\tMap<String, Integer> map2 = new HashMap<>();\\n\\t\\tfor (int i = 0; i < list1.length; i++) {\\n\\t\\t\\tif (!map.containsKey(list1[i])) {\\n\\t\\t\\t\\tmap.put(list1[i], i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < list2.length; i++) {\\n\\t\\t\\tif (map.containsKey(list2[i])) {\\n\\t\\t\\t\\tsum = map.get(list2[i]) + i;\\n\\t\\t\\t\\tmap2.put(list2[i], sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tPriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());\\n\\t\\tPriorityQueue<String> pq2 = new PriorityQueue<>();\\n\\t\\tpq.addAll(map2.entrySet());\\n\\t\\tint val = 0;\\n\\t\\tboolean track = false;\\n\\t\\twhile (!pq.isEmpty()) {\\n\\t\\t\\tif (pq.peek().getValue() <= val || (val == 0 && track==false)) {\\n\\t\\t\\t\\tval = pq.peek().getValue();\\n\\t\\t\\t\\tpq2.add(pq.poll().getKey());\\n\\t\\t\\t\\ttrack=true;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tpq.poll();\\n\\t\\t\\t}\\n\\t\\t\\tif(!pq2.isEmpty()){\\n\\t\\t\\t result.add(pq2.poll());\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tString[] res = new String[result.size()];\\n\\t\\tfor (int i = 0; i < res.length; i++) {\\n\\t\\t\\tres[i] = result.get(i);\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\n    int sum = 0;\\n\\t\\tList<String> result = new ArrayList<>();\\n\\t\\tMap<String, Integer> map = new HashMap<>();\\n\\t\\tMap<String, Integer> map2 = new HashMap<>();\\n\\t\\tfor (int i = 0; i < list1.length; i++) {\\n\\t\\t\\tif (!map.containsKey(list1[i])) {\\n\\t\\t\\t\\tmap.put(list1[i], i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < list2.length; i++) {\\n\\t\\t\\tif (map.containsKey(list2[i])) {\\n\\t\\t\\t\\tsum = map.get(list2[i]) + i;\\n\\t\\t\\t\\tmap2.put(list2[i], sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tPriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());\\n\\t\\tPriorityQueue<String> pq2 = new PriorityQueue<>();\\n\\t\\tpq.addAll(map2.entrySet());\\n\\t\\tint val = 0;\\n\\t\\tboolean track = false;\\n\\t\\twhile (!pq.isEmpty()) {\\n\\t\\t\\tif (pq.peek().getValue() <= val || (val == 0 && track==false)) {\\n\\t\\t\\t\\tval = pq.peek().getValue();\\n\\t\\t\\t\\tpq2.add(pq.poll().getKey());\\n\\t\\t\\t\\ttrack=true;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tpq.poll();\\n\\t\\t\\t}\\n\\t\\t\\tif(!pq2.isEmpty()){\\n\\t\\t\\t result.add(pq2.poll());\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tString[] res = new String[result.size()];\\n\\t\\tfor (int i = 0; i < res.length; i++) {\\n\\t\\t\\tres[i] = result.get(i);\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 469714,
                "title": "javascript-solution-92-ms-faster-than-87-79-42-9-mb-less-than-100-00",
                "content": "```\\nvar findRestaurant = function(list1, list2) {\\n    let map = new Map();\\n    let arr = [];\\n    var min = Infinity;\\n    for(let i = 0; i < list1.length; i++){\\n        map.set(list1[i], i)\\n    }\\n    for(let i = 0; i < list2.length; i++){\\n        var sum = 0;\\n        if(map.has(list2[i])){\\n            sum = map.get(list2[i]) + i;\\n            if(sum < min){\\n                arr = [];\\n                arr.push(list2[i]);\\n                min = sum\\n            }else if(sum === min) arr.push(list2[i]);\\n        }\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findRestaurant = function(list1, list2) {\\n    let map = new Map();\\n    let arr = [];\\n    var min = Infinity;\\n    for(let i = 0; i < list1.length; i++){\\n        map.set(list1[i], i)\\n    }\\n    for(let i = 0; i < list2.length; i++){\\n        var sum = 0;\\n        if(map.has(list2[i])){\\n            sum = map.get(list2[i]) + i;\\n            if(sum < min){\\n                arr = [];\\n                arr.push(list2[i]);\\n                min = sum\\n            }else if(sum === min) arr.push(list2[i]);\\n        }\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 453683,
                "title": "java-easy-solution-with-explanation",
                "content": "```\\npublic String[] findRestaurant(String[] l1, String[] l2) {\\n\\tHashMap<String, Integer> hm = new HashMap<>();\\n\\tfor(int i=0; i<l1.length; i++) \\n\\t\\thm.put(l1[i],i);              //Create a Map of all the Restaurants and their indices\\n\\tint minSum = Integer.MAX_VALUE;   //This will store the minimum Sum of restaurant indices\\n\\tList<String> sol = new ArrayList<>();\\n\\tfor(int i=0; i<l2.length; i++) {\\n\\t\\tif(!hm.containsKey(l2[i]))    //If the restaurant is not in the other array it is of no use to us. \\n\\t\\t\\tcontinue;\\n\\t\\tint currSum = i+hm.get(l2[i]); //Sum of indices of restaurant in the current iteration. \\n\\t\\tif(currSum < minSum) {\\n\\t\\t\\tsol.clear();               //If the currSum < minSum the previously stored restaurant of higher indices are of no use to us. \\n\\t\\t\\tsol.add(l2[i]);\\n\\t\\t\\tminSum = currSum;          //Dont\\'t forget to update the minimum Sum.\\n\\t\\t} else if(currSum == minSum) {\\n\\t\\t\\tsol.add(l2[i]);            //If the current sum is same as min sum we append our list to return multiple restuarants.\\n\\t\\t}\\n\\t}\\n\\treturn sol.toArray(new String[0]);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String[] findRestaurant(String[] l1, String[] l2) {\\n\\tHashMap<String, Integer> hm = new HashMap<>();\\n\\tfor(int i=0; i<l1.length; i++) \\n\\t\\thm.put(l1[i],i);              //Create a Map of all the Restaurants and their indices\\n\\tint minSum = Integer.MAX_VALUE;   //This will store the minimum Sum of restaurant indices\\n\\tList<String> sol = new ArrayList<>();\\n\\tfor(int i=0; i<l2.length; i++) {\\n\\t\\tif(!hm.containsKey(l2[i]))    //If the restaurant is not in the other array it is of no use to us. \\n\\t\\t\\tcontinue;\\n\\t\\tint currSum = i+hm.get(l2[i]); //Sum of indices of restaurant in the current iteration. \\n\\t\\tif(currSum < minSum) {\\n\\t\\t\\tsol.clear();               //If the currSum < minSum the previously stored restaurant of higher indices are of no use to us. \\n\\t\\t\\tsol.add(l2[i]);\\n\\t\\t\\tminSum = currSum;          //Dont\\'t forget to update the minimum Sum.\\n\\t\\t} else if(currSum == minSum) {\\n\\t\\t\\tsol.add(l2[i]);            //If the current sum is same as min sum we append our list to return multiple restuarants.\\n\\t\\t}\\n\\t}\\n\\treturn sol.toArray(new String[0]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413929,
                "title": "python3-solution-o-n",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        dict1 = {}\\n        dict2 = {}\\n        \\n        for i1, v1 in enumerate(list1):\\n            dict1[v1] = i1\\n        for i2, v2 in enumerate(list2):\\n            dict2[v2] = i2\\n        \\n        result = []\\n        minIndexSum = 1000000\\n        for k in dict1:\\n            if k in dict2:\\n                if dict1[k] + dict2[k] < minIndexSum:\\n                    minIndexSum = dict1[k] + dict2[k]\\n                    result = [k]\\n                elif dict1[k] + dict2[k] == minIndexSum:\\n                    result.append(k)\\n                    \\n        return result",
                "solutionTags": [],
                "code": "class Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        dict1 = {}",
                "codeTag": "Java"
            },
            {
                "id": 371165,
                "title": "go-o-n-m-time-and-o-n-additional-space-solution",
                "content": "```\\nfunc findRestaurant(list1 []string, list2 []string) []string {\\n\\tcache := make(map[string]int)\\n\\tfor i, l := range list1 {\\n\\t\\tcache[l] = i\\n\\t}\\n\\tvar result []string\\n\\tleastIndexSum := 1<<31 - 1\\n\\t\\n\\tfor i1, l := range list2 {\\n\\t\\tif i2, ok := cache[l]; ok {\\n\\t\\t\\tindexSum := i1 + i2\\n\\t\\t\\tif indexSum < leastIndexSum {\\n\\t\\t\\t\\tleastIndexSum = indexSum\\n\\t\\t\\t\\tresult = []string{l}\\n\\t\\t\\t} else if indexSum == leastIndexSum {\\n\\t\\t\\t\\tresult = append(result, l)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findRestaurant(list1 []string, list2 []string) []string {\\n\\tcache := make(map[string]int)\\n\\tfor i, l := range list1 {\\n\\t\\tcache[l] = i\\n\\t}\\n\\tvar result []string\\n\\tleastIndexSum := 1<<31 - 1\\n\\t\\n\\tfor i1, l := range list2 {\\n\\t\\tif i2, ok := cache[l]; ok {\\n\\t\\t\\tindexSum := i1 + i2\\n\\t\\t\\tif indexSum < leastIndexSum {\\n\\t\\t\\t\\tleastIndexSum = indexSum\\n\\t\\t\\t\\tresult = []string{l}\\n\\t\\t\\t} else if indexSum == leastIndexSum {\\n\\t\\t\\t\\tresult = append(result, l)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350057,
                "title": "c-simple-hashmap-solution",
                "content": "Map each element in list 1 to index, then iterate through list2. We know if the map contains the list1 restaurant then it belongs in the intersection both sets. Clear the res if we find sums of indexes that are less than what we already have.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string, int> map1;\\n        for (int i = 0; i < list1.size(); i++) map1.emplace(list1[i], i);\\n        \\n        int minInd = INT_MAX;\\n        vector<string> res;\\n        for (int i = 0; i < list2.size(); i++) {\\n            if (!map1.count(list2[i])) continue;\\n            \\n            int sum = i + map1[list2[i]];\\n            if (sum < minInd) res.clear();\\n            \\n            if (sum <= minInd) {\\n                res.push_back(list2[i]);\\n                minInd = sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string, int> map1;\\n        for (int i = 0; i < list1.size(); i++) map1.emplace(list1[i], i);\\n        \\n        int minInd = INT_MAX;\\n        vector<string> res;\\n        for (int i = 0; i < list2.size(); i++) {\\n            if (!map1.count(list2[i])) continue;\\n            \\n            int sum = i + map1[list2[i]];\\n            if (sum < minInd) res.clear();\\n            \\n            if (sum <= minInd) {\\n                res.push_back(list2[i]);\\n                minInd = sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187533,
                "title": "python-using-defaltdict-14lines",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findRestaurant(self, list1, list2):\\n        C=list(set(list1)&set(list2))\\n        if len(C)==1:\\n            return C\\n        elif len(C)>1:\\n            index_name_dict=defaultdict(list)\\n            for name in C:\\n                index1=list1.index(name)\\n                index2=list2.index(name)\\n                index_sum=index1+index2\\n                index_name_dict[index_sum].append(name)\\n            return index_name_dict[min(index_name_dict.keys())]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findRestaurant(self, list1, list2):\\n        C=list(set(list1)&set(list2))\\n        if len(C)==1:\\n            return C\\n        elif len(C)>1:\\n            index_name_dict=defaultdict(list)\\n            for name in C:\\n                index1=list1.index(name)\\n                index2=list2.index(name)\\n                index_sum=index1+index2\\n                index_name_dict[index_sum].append(name)\\n            return index_name_dict[min(index_name_dict.keys())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103670,
                "title": "simple-swift-solution",
                "content": "Basic idea is first to map restaurants and indexes from the 1st list, and then map ones from the 2nd list and calculate index sums. After that find the ones with the minimum index sum.\\n```\\nfunc findRestaurant(_ list1: [String], _ list2: [String]) -> [String] {\\n\\tvar list1Dictionary = [String: Int]()\\n\\tvar list2Dictionary = [String: Int]()\\n\\t\\n\\tfor (index, restaurant) in list1.enumerated() {\\n\\t\\tlist1Dictionary[restaurant] = index\\n\\t}\\n\\t\\n\\tvar restaurants = [String: Int]()\\n\\t\\n\\tfor (index, restaurant) in list2.enumerated() {\\n\\t\\tlist2Dictionary[restaurant] = index\\n\\t\\t\\n\\t\\tif let index2 = list1Dictionary[restaurant] {\\n\\t\\t\\trestaurants[restaurant] = abs(index2 + index)\\n\\t\\t}\\n\\t}\\n\\t\\n\\tlet minIndexSum = restaurants.values.min()\\n\\t\\n\\treturn restaurants.filter({ $0.value == minIndexSum }).map({ $0.0 })\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc findRestaurant(_ list1: [String], _ list2: [String]) -> [String] {\\n\\tvar list1Dictionary = [String: Int]()\\n\\tvar list2Dictionary = [String: Int]()\\n\\t\\n\\tfor (index, restaurant) in list1.enumerated() {\\n\\t\\tlist1Dictionary[restaurant] = index\\n\\t}\\n\\t\\n\\tvar restaurants = [String: Int]()\\n\\t\\n\\tfor (index, restaurant) in list2.enumerated() {\\n\\t\\tlist2Dictionary[restaurant] = index\\n\\t\\t\\n\\t\\tif let index2 = list1Dictionary[restaurant] {\\n\\t\\t\\trestaurants[restaurant] = abs(index2 + index)\\n\\t\\t}\\n\\t}\\n\\t\\n\\tlet minIndexSum = restaurants.values.min()\\n\\t\\n\\treturn restaurants.filter({ $0.value == minIndexSum }).map({ $0.0 })\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951891,
                "title": "easy-to-understand-hashmap-only-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Hashtable<String , Integer> table = new Hashtable<>();\\n        for(int i = 0 ; i < list1.length ; i++){\\n            table.put(list1[i],i);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        HashMap<Integer , ArrayList<String>> map = new HashMap<>();\\n        for(int i = 0 ; i < list2.length ; i++){\\n            if(table.containsKey(list2[i])){\\n                int indexSum = table.get(list2[i]) + i;\\n                if(map.containsKey(indexSum)){\\n                    ArrayList<String> list = map.get(indexSum);\\n                    list.add(list2[i]);\\n                    map.put(indexSum, list);\\n                }\\n                else{\\n                    ArrayList<String> list = new ArrayList<>();\\n                    list.add(list2[i]);\\n                    map.put(indexSum, list);\\n                }\\n                min = Math.min(indexSum , min);\\n            }\\n        }\\n        ArrayList<String> ans = new ArrayList<>();\\n        for(int i : map.keySet()){\\n            if(i == min){\\n                ArrayList<String> holyFuck = map.get(i);\\n                for(String s : holyFuck){\\n                    ans.add(s);\\n                }\\n            }\\n        }\\n        String[] ansStr = new String[ans.size()];\\n        int i =0;\\n        for(String s  : ans){\\n            ansStr[i++] = s;\\n        }\\n        return ansStr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Hashtable<String , Integer> table = new Hashtable<>();\\n        for(int i = 0 ; i < list1.length ; i++){\\n            table.put(list1[i],i);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        HashMap<Integer , ArrayList<String>> map = new HashMap<>();\\n        for(int i = 0 ; i < list2.length ; i++){\\n            if(table.containsKey(list2[i])){\\n                int indexSum = table.get(list2[i]) + i;\\n                if(map.containsKey(indexSum)){\\n                    ArrayList<String> list = map.get(indexSum);\\n                    list.add(list2[i]);\\n                    map.put(indexSum, list);\\n                }\\n                else{\\n                    ArrayList<String> list = new ArrayList<>();\\n                    list.add(list2[i]);\\n                    map.put(indexSum, list);\\n                }\\n                min = Math.min(indexSum , min);\\n            }\\n        }\\n        ArrayList<String> ans = new ArrayList<>();\\n        for(int i : map.keySet()){\\n            if(i == min){\\n                ArrayList<String> holyFuck = map.get(i);\\n                for(String s : holyFuck){\\n                    ans.add(s);\\n                }\\n            }\\n        }\\n        String[] ansStr = new String[ans.size()];\\n        int i =0;\\n        for(String s  : ans){\\n            ansStr[i++] = s;\\n        }\\n        return ansStr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918912,
                "title": "weird-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        // Create a hashmap for list1, map(string -> index)\\n        // Compare each string in list2, check the hashmap, if there\\'s match -> found common string, store index sum inside another map(string -> indexSum)\\n        // Find the common string\\n        // Calculate and minimum index sum\\n        HashMap<String, Integer> list1Map = new HashMap<>();\\n        HashMap<String, Integer> indexSum = new HashMap<>();\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < list1.length; i++){\\n            list1Map.put(list1[i], i);\\n        }\\n        for(int i = 0; i < list2.length; i++){\\n            if(list1Map.get(list2[i]) != null){\\n                indexSum.put(list2[i], i + list1Map.get(list2[i]));\\n                min = Math.min(min, i + list1Map.get(list2[i]));\\n            }\\n        }\\n        ArrayList<String> result = new ArrayList<String>();\\n        for(Map.Entry<String, Integer> i : indexSum.entrySet()){\\n            if(i.getValue() == min){\\n                result.add(i.getKey());\\n            }\\n        }\\n        return result.toArray(new String[result.size()]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        // Create a hashmap for list1, map(string -> index)\\n        // Compare each string in list2, check the hashmap, if there\\'s match -> found common string, store index sum inside another map(string -> indexSum)\\n        // Find the common string\\n        // Calculate and minimum index sum\\n        HashMap<String, Integer> list1Map = new HashMap<>();\\n        HashMap<String, Integer> indexSum = new HashMap<>();\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < list1.length; i++){\\n            list1Map.put(list1[i], i);\\n        }\\n        for(int i = 0; i < list2.length; i++){\\n            if(list1Map.get(list2[i]) != null){\\n                indexSum.put(list2[i], i + list1Map.get(list2[i]));\\n                min = Math.min(min, i + list1Map.get(list2[i]));\\n            }\\n        }\\n        ArrayList<String> result = new ArrayList<String>();\\n        for(Map.Entry<String, Integer> i : indexSum.entrySet()){\\n            if(i.getValue() == min){\\n                result.add(i.getKey());\\n            }\\n        }\\n        return result.toArray(new String[result.size()]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891603,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String,Integer> map=new HashMap<>();\\n        List<String> list=new ArrayList<>();\\n        int sum=Integer.MAX_VALUE;\\n        for(int i=0;i<list1.length;i++) map.put(list1[i],i);\\n        for(int i=0;i<list2.length;i++){\\n            Integer k=map.get(list2[i]);\\n            if(k!=null && k+i<sum ){\\n                list.clear();\\n                sum=k+i;\\n                list.add(list2[i]);\\n            }\\n            else if(k!=null && k+i<=sum){\\n                list.add(list2[i]);\\n            }\\n        }\\n        return list.toArray(new String[list.size()]);\\n    }\\n}\\n```\\n```c++ []\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string>res;\\n        unordered_map<string,int>m;\\n        int min = INT_MAX;\\n        for(int i = 0; i < list1.size(); i++) m[list1[i]] = i;\\n        for(int i = 0; i < list2.size(); i++)\\n            if(m.count(list2[i]) != 0)\\n                if(m[list2[i]] + i < min) min = m[list2[i]] + i, res.clear(), res.push_back(list2[i]);\\n                else if(m[list2[i]] + i == min) res.push_back(list2[i]);\\n        return res;\\n    }\\n```\\n```python3 []\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        m = len(list1) + len(list2)\\n        list3 = []\\n        \\n        for i in range(len(list1)):\\n            for j in range(len(list2)):\\n                if list1[i] == list2[j]:\\n                    if (i+j)<=m:\\n                        if list3 == None:\\n                            list3.append(list2[j])\\n                        \\n                        elif m == i+j:\\n                            list3.append(list2[j])\\n                        \\n                        else:\\n                            list3=[]\\n                            list3.append(list2[j])\\n                        \\n                        m = i + j\\n        return list3\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String,Integer> map=new HashMap<>();\\n        List<String> list=new ArrayList<>();\\n        int sum=Integer.MAX_VALUE;\\n        for(int i=0;i<list1.length;i++) map.put(list1[i],i);\\n        for(int i=0;i<list2.length;i++){\\n            Integer k=map.get(list2[i]);\\n            if(k!=null && k+i<sum ){\\n                list.clear();\\n                sum=k+i;\\n                list.add(list2[i]);\\n            }\\n            else if(k!=null && k+i<=sum){\\n                list.add(list2[i]);\\n            }\\n        }\\n        return list.toArray(new String[list.size()]);\\n    }\\n}\\n```\n```c++ []\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string>res;\\n        unordered_map<string,int>m;\\n        int min = INT_MAX;\\n        for(int i = 0; i < list1.size(); i++) m[list1[i]] = i;\\n        for(int i = 0; i < list2.size(); i++)\\n            if(m.count(list2[i]) != 0)\\n                if(m[list2[i]] + i < min) min = m[list2[i]] + i, res.clear(), res.push_back(list2[i]);\\n                else if(m[list2[i]] + i == min) res.push_back(list2[i]);\\n        return res;\\n    }\\n```\n```python3 []\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        m = len(list1) + len(list2)\\n        list3 = []\\n        \\n        for i in range(len(list1)):\\n            for j in range(len(list2)):\\n                if list1[i] == list2[j]:\\n                    if (i+j)<=m:\\n                        if list3 == None:\\n                            list3.append(list2[j])\\n                        \\n                        elif m == i+j:\\n                            list3.append(list2[j])\\n                        \\n                        else:\\n                            list3=[]\\n                            list3.append(list2[j])\\n                        \\n                        m = i + j\\n        return list3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870699,
                "title": "java-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String,Integer>H=new LinkedHashMap<>();\\n        for(int i=0;i<list1.length;i++){\\n            H.put(list1[i],i);\\n        }\\n        \\n        ArrayList<String>A=new ArrayList<>();\\n        int sum=Integer.MAX_VALUE;\\n        // int least=0;\\n\\n        for(int i=0;i<list2.length;i++){\\n          if(H.containsKey(list2[i])){\\n              int tempsum=i+H.get(list2[i]);\\n              if(tempsum<sum){\\n                  sum=tempsum;\\n            }\\n          }\\n        }\\n          for(int i=0;i<list2.length;i++){\\n          if(H.containsKey(list2[i])){\\n              int tempsum=i+H.get(list2[i]);\\n              if(tempsum==sum){\\n                  A.add(list2[i]);\\n            }\\n          }\\n        }\\n        String[]ans=new String[A.size()];\\n\\n        for(int i=0;i<A.size();i++){\\n            ans[i]=A.get(i);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String,Integer>H=new LinkedHashMap<>();\\n        for(int i=0;i<list1.length;i++){\\n            H.put(list1[i],i);\\n        }\\n        \\n        ArrayList<String>A=new ArrayList<>();\\n        int sum=Integer.MAX_VALUE;\\n        // int least=0;\\n\\n        for(int i=0;i<list2.length;i++){\\n          if(H.containsKey(list2[i])){\\n              int tempsum=i+H.get(list2[i]);\\n              if(tempsum<sum){\\n                  sum=tempsum;\\n            }\\n          }\\n        }\\n          for(int i=0;i<list2.length;i++){\\n          if(H.containsKey(list2[i])){\\n              int tempsum=i+H.get(list2[i]);\\n              if(tempsum==sum){\\n                  A.add(list2[i]);\\n            }\\n          }\\n        }\\n        String[]ans=new String[A.size()];\\n\\n        for(int i=0;i<A.size();i++){\\n            ans[i]=A.get(i);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791188,
                "title": "java-not-efficient-but-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRestaurant(String[] ll1, String[] ll2) {\\n          List<String> l1= Arrays.stream(ll1).toList();\\n        List<String> l2 = Arrays.stream(ll2).toList();\\n        int min = Integer.MAX_VALUE;\\n        List<String> result = new ArrayList<>();\\n        int index = 0;\\n        for(int i=0;i<l1.size();i++){\\n                if(l2.contains(l1.get(i))){\\n                    int k = l2.indexOf(l1.get(i)) + i;\\n                    if(k<min){\\n                        min = k;\\n                        index = i;\\n                    }else if(k == min){\\n                        result.add(l1.get(index));\\n                        result.add(l1.get(i));\\n                    }\\n            }\\n        }\\n        if(result.size()==0){\\n             String[] a = new String[1];\\n             a[0] = l1.get(index);\\n             return a;\\n        }else{\\n   Set<String> values = new HashSet<>(result);\\n            String[] array = values.stream()\\n                    .toArray(String[]::new);\\n            return array;\\n        }\\n    }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] ll1, String[] ll2) {\\n          List<String> l1= Arrays.stream(ll1).toList();\\n        List<String> l2 = Arrays.stream(ll2).toList();\\n        int min = Integer.MAX_VALUE;\\n        List<String> result = new ArrayList<>();\\n        int index = 0;\\n        for(int i=0;i<l1.size();i++){\\n                if(l2.contains(l1.get(i))){\\n                    int k = l2.indexOf(l1.get(i)) + i;\\n                    if(k<min){\\n                        min = k;\\n                        index = i;\\n                    }else if(k == min){\\n                        result.add(l1.get(index));\\n                        result.add(l1.get(i));\\n                    }\\n            }\\n        }\\n        if(result.size()==0){\\n             String[] a = new String[1];\\n             a[0] = l1.get(index);\\n             return a;\\n        }else{\\n   Set<String> values = new HashSet<>(result);\\n            String[] array = values.stream()\\n                    .toArray(String[]::new);\\n            return array;\\n        }\\n    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460635,
                "title": "easy-to-understand-using-arraylist-and-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        ArrayList<String> arrayList = new ArrayList<>();\\n        Map<String,Integer> map = new HashMap<>();\\n        int min = 999999999;\\n        for (int i = 0; i < list1.length; i++) {\\n            for (int j = 0; j < list2.length; j++) {\\n                if (list1[i].equalsIgnoreCase(list2[j])) {\\n                    int a = i;\\n                    int b = j;\\n                    int count = a+b;\\n                    if(min>count){\\n                        min = count;\\n                    }\\n                    map.put(list1[i],count);\\n                }\\n            }\\n        }\\n        for(Map.Entry<String,Integer> entry:map.entrySet()){\\n            if(entry.getValue()==min){\\n                arrayList.add(entry.getKey());\\n            }\\n        }\\n        return arrayList.toArray(new String[0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        ArrayList<String> arrayList = new ArrayList<>();\\n        Map<String,Integer> map = new HashMap<>();\\n        int min = 999999999;\\n        for (int i = 0; i < list1.length; i++) {\\n            for (int j = 0; j < list2.length; j++) {\\n                if (list1[i].equalsIgnoreCase(list2[j])) {\\n                    int a = i;\\n                    int b = j;\\n                    int count = a+b;\\n                    if(min>count){\\n                        min = count;\\n                    }\\n                    map.put(list1[i],count);\\n                }\\n            }\\n        }\\n        for(Map.Entry<String,Integer> entry:map.entrySet()){\\n            if(entry.getValue()==min){\\n                arrayList.add(entry.getKey());\\n            }\\n        }\\n        return arrayList.toArray(new String[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208468,
                "title": "python3-easy-peasy-solution",
                "content": "# Intuition\\nThe time complexity of both solutions is O(m * n), where m and n are the lengths of the two input lists. In the worst case, we have to compare every element of list1 to every element of list2 to find the common strings, which requires m * n comparisons. However, both solutions use a dictionary to keep track of the index sum for each common string, which allows them to identify the minimum index sum in O(m * n) time. Therefore, the overall time complexity is O(m * n).\\n\\nThe space complexity of both solutions is also O(m * n), because in the worst case, every element of list1 is a common string with every element of list2, and we need to store the index sum for each pair of common strings in the dictionary. However, in practice, the space complexity is likely to be much lower, because we will usually have only a small number of common strings.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        \\'\\'\\'\\n        # Solution 1: Brute force\\n        min_val = -1\\n        res = {}\\n        tmp = []\\n        for i, l1 in enumerate(list1):\\n            for j, l2 in enumerate(list2):\\n                if l1 == l2:\\n                    res[l1] = i+j\\n                    if min_val == -1:\\n                        min_val = i+j                    \\n                    else:\\n                        min_val = min(min_val, i+j)\\n                    \\n        \\n        for k, v in res.items():\\n            if v == min_val:\\n               tmp.append(k) \\n        return tmp\\'\\'\\'\\n\\n        # Solution 2: Optimised\\n\\n        l1 = {list1[i]: i for i in range(len(list1))}\\n        l2 = {list2[i]: i for i in range(len(list2))}\\n        min_val = float(\\'inf\\')\\n        res = []\\n        for k, v in l1.items():\\n            if k in l2:\\n                if (l1[k] + l2[k]) < min_val:\\n                    res = [k]\\n                    min_val = l1[k] + l2[k]\\n                elif (l1[k] + l2[k]) == min_val:\\n                    res.append(k)\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        \\'\\'\\'\\n        # Solution 1: Brute force\\n        min_val = -1\\n        res = {}\\n        tmp = []\\n        for i, l1 in enumerate(list1):\\n            for j, l2 in enumerate(list2):\\n                if l1 == l2:\\n                    res[l1] = i+j\\n                    if min_val == -1:\\n                        min_val = i+j                    \\n                    else:\\n                        min_val = min(min_val, i+j)\\n                    \\n        \\n        for k, v in res.items():\\n            if v == min_val:\\n               tmp.append(k) \\n        return tmp\\'\\'\\'\\n\\n        # Solution 2: Optimised\\n\\n        l1 = {list1[i]: i for i in range(len(list1))}\\n        l2 = {list2[i]: i for i in range(len(list2))}\\n        min_val = float(\\'inf\\')\\n        res = []\\n        for k, v in l1.items():\\n            if k in l2:\\n                if (l1[k] + l2[k]) < min_val:\\n                    res = [k]\\n                    min_val = l1[k] + l2[k]\\n                elif (l1[k] + l2[k]) == min_val:\\n                    res.append(k)\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091526,
                "title": "brute-force-arraylist-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        // Do ArrayList leker list1 and list2 ki values compare kara lo jaha same aaye index store kar lo then see this \\n        ArrayList<Integer> a = new ArrayList<Integer>();\\n        ArrayList<String> b=new ArrayList<String>();\\n        int temp=0;\\n        for(int i=0; i<list1.length; i++){\\n            for(int j=0; j<list2.length; j++){\\n                if(list1[i].compareTo(list2[j])==0){\\n                    temp=i+j;\\n                    a.add(temp);\\n                    b.add(list1[i]);\\n                }\\n                temp=0;\\n            }\\n\\n        }\\n        int g=Collections.min(a);\\n        ArrayList<String> kl = new ArrayList<String>();\\n        for(int i=0; i<a.size(); i++){\\n            if(a.get(i)==g){\\n                kl.add(b.get(i));\\n            }\\n        }\\n        String mk[] = new String[kl.size()];\\n        for(int i=0; i<kl.size(); i++){\\n            mk[i]=kl.get(i);\\n        }\\n        return mk;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        // Do ArrayList leker list1 and list2 ki values compare kara lo jaha same aaye index store kar lo then see this \\n        ArrayList<Integer> a = new ArrayList<Integer>();\\n        ArrayList<String> b=new ArrayList<String>();\\n        int temp=0;\\n        for(int i=0; i<list1.length; i++){\\n            for(int j=0; j<list2.length; j++){\\n                if(list1[i].compareTo(list2[j])==0){\\n                    temp=i+j;\\n                    a.add(temp);\\n                    b.add(list1[i]);\\n                }\\n                temp=0;\\n            }\\n\\n        }\\n        int g=Collections.min(a);\\n        ArrayList<String> kl = new ArrayList<String>();\\n        for(int i=0; i<a.size(); i++){\\n            if(a.get(i)==g){\\n                kl.add(b.get(i));\\n            }\\n        }\\n        String mk[] = new String[kl.size()];\\n        for(int i=0; i<kl.size(); i++){\\n            mk[i]=kl.get(i);\\n        }\\n        return mk;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043425,
                "title": "python-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep the sum of indices for each word in a dict.\\nstore the min sum of indices\\nreturn keys from the dict which have the min sum as a list\\n\\n\\n# Complexity\\n- Time complexity:\\nRuntime\\n343 ms\\nBeats\\n54.45%\\n\\n- Space complexity:\\nMemory\\n14.4 MB\\nBeats\\n86.19%\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        res = len(list1)+len(list2)\\n        ans = {}\\n        x = []\\n        for word in list1:\\n            if word == \" \":\\n                continue\\n            if word in list2:\\n                ln = list1.index(word)+list2.index(word)\\n                res = min(res,ln)\\n                ans[word]=ln\\n        \\n        for key, val in ans.items():\\n            if val==res:\\n                x.append(key)\\n                \\n        return x\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        res = len(list1)+len(list2)\\n        ans = {}\\n        x = []\\n        for word in list1:\\n            if word == \" \":\\n                continue\\n            if word in list2:\\n                ln = list1.index(word)+list2.index(word)\\n                res = min(res,ln)\\n                ans[word]=ln\\n        \\n        for key, val in ans.items():\\n            if val==res:\\n                x.append(key)\\n                \\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928898,
                "title": "python-brute-force-solution",
                "content": "# Intuition\\nbeats 99.9%\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      n(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d2={}\\n        l=[]\\n        for i in range(len(list2)):\\n            d2[list2[i]]=i\\n        for i in range(len(list1)):\\n            if list1[i] in d2:\\n                l.append([i+d2[list1[i]],list1[i]])\\n        l1=[]\\n        l.sort()\\n        l1.append(l[0][1])\\n        for i in range(1,len(l)):\\n            if l[i][0]==l[i-1][0]:\\n                l1.append(l[i][1])\\n            else:\\n                break\\n        return l1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d2={}\\n        l=[]\\n        for i in range(len(list2)):\\n            d2[list2[i]]=i\\n        for i in range(len(list1)):\\n            if list1[i] in d2:\\n                l.append([i+d2[list1[i]],list1[i]])\\n        l1=[]\\n        l.sort()\\n        l1.append(l[0][1])\\n        for i in range(1,len(l)):\\n            if l[i][0]==l[i-1][0]:\\n                l1.append(l[i][1])\\n            else:\\n                break\\n        return l1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904103,
                "title": "my-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& l1, vector<string>& l2) {\\n        int li=INT_MAX;\\n        vector<string> res;\\n        vector<vector<int>> ind;\\n        vector<string> ans;\\n        for(int i=0;i<l1.size();i++){\\n            for(int j=0;j<l2.size();j++){\\n                if(l1[i]==l2[j] && i+j<=li){\\n                    res.push_back(l1[i]);\\n                    ind.push_back({i,j});\\n\\n                    li=i+j;\\n                    break;\\n\\n                }\\n               \\n            }\\n        }\\n        \\n        for(int i=0;i<ind.size();i++){\\n            for(int j=0;j<ind[i].size()-1;j++){\\n                if(ind[i][j]+ind[i][j+1]==li){\\n                    ans.push_back(res[i]);\\n                }\\n            }\\n        }\\n  return ans;  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& l1, vector<string>& l2) {\\n        int li=INT_MAX;\\n        vector<string> res;\\n        vector<vector<int>> ind;\\n        vector<string> ans;\\n        for(int i=0;i<l1.size();i++){\\n            for(int j=0;j<l2.size();j++){\\n                if(l1[i]==l2[j] && i+j<=li){\\n                    res.push_back(l1[i]);\\n                    ind.push_back({i,j});\\n\\n                    li=i+j;\\n                    break;\\n\\n                }\\n               \\n            }\\n        }\\n        \\n        for(int i=0;i<ind.size();i++){\\n            for(int j=0;j<ind[i].size()-1;j++){\\n                if(ind[i][j]+ind[i][j+1]==li){\\n                    ans.push_back(res[i]);\\n                }\\n            }\\n        }\\n  return ans;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869060,
                "title": "golang-simple-solution-and-using-o-n-2",
                "content": "# Code\\n```\\nfunc findRestaurant(list1 []string, list2 []string) []string {\\n    min := math.MaxInt\\n\\n    res := make([]string, 1)\\n    for i, s := range list1 {\\n        for j, str := range list2 {\\n            if s == str {\\n                if i + j < min {\\n                    min = i + j\\n                    res[0] = s\\n                }else if i + j == min {\\n                    res = append(res, s)\\n                }\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findRestaurant(list1 []string, list2 []string) []string {\\n    min := math.MaxInt\\n\\n    res := make([]string, 1)\\n    for i, s := range list1 {\\n        for j, str := range list2 {\\n            if s == str {\\n                if i + j < min {\\n                    min = i + j\\n                    res[0] = s\\n                }else if i + j == min {\\n                    res = append(res, s)\\n                }\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2721299,
                "title": "hashmap-and-pythonic",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        minsum, hashmap, out = float(\"inf\"), {}, []\\n        for i in range(len(list1)):\\n            hashmap[list1[i]] = i\\n        for j in range(len(list2)):\\n            if list2[j] in hashmap:\\n                currsum = j + hashmap[list2[j]]\\n                if currsum < minsum:\\n                    minsum = currsum\\n                    out = []\\n                    out.append(list2[j])\\n                elif currsum == minsum:\\n                    out.append(list2[j])\\n        return out\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6038c28c-5d66-4874-bab7-a947d2c6f857_1666163674.5828006.png)\\n\\n_Similar but short and slow_\\n```\\ndata = {i: list1.index(i) + list2.index(i) for i in set(list1) & set(list2)}\\nreturn [e for e in data if data[e] == min(data.values())]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        minsum, hashmap, out = float(\"inf\"), {}, []\\n        for i in range(len(list1)):\\n            hashmap[list1[i]] = i\\n        for j in range(len(list2)):\\n            if list2[j] in hashmap:\\n                currsum = j + hashmap[list2[j]]\\n                if currsum < minsum:\\n                    minsum = currsum\\n                    out = []\\n                    out.append(list2[j])\\n                elif currsum == minsum:\\n                    out.append(list2[j])\\n        return out\\n```\n```\\ndata = {i: list1.index(i) + list2.index(i) for i in set(list1) & set(list2)}\\nreturn [e for e in data if data[e] == min(data.values())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496013,
                "title": "easy-to-understand-two-approaches-intuitive",
                "content": "Approach 1: without use of any space in O(m*n) time and  O(1) space \\n\\n```\\n   vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) \\n    {\\n        int mn=INT_MAX;\\n        string ans;\\n        for(int i=0;i<list1.size();i++)\\n        {\\n            string s=list1[i];\\n            for(int j=0;j<list2.size();j++)\\n            {\\n               if(list2[j]==s)\\n               {\\n                   if(mn>(i+j))\\n                  {    mn=i+j;\\n                       ans=list2[j];\\n                  }\\n               }\\n            }\\n        }\\n        \\nvector<string> temp;        \\n         for(int i=0;i<list1.size();i++)\\n        {\\n            string s=list1[i];\\n            for(int j=0;j<list2.size();j++)\\n            {\\n               if(list2[j]==s)\\n               {\\n                   if(mn==(i+j))\\n                  {    \\n                       temp.push_back(list2[j]);\\n                  }\\n               }\\n            }\\n        }       \\n        \\n        \\n        return temp;\\n```\\n\\n\\nApproach 2: using Hashmap in O(m*n) time and  O(n) space (n>=m)\\n\\n```\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) \\n    {\\n        int mn=INT_MAX;\\n        vector<string>ans;\\n        unordered_map<string,int>mp;\\n        \\n        for(int i=0;i<list1.size();i++) mp[list1[i]]=i+1;\\n\\n        \\n        for(int i=0;i<list2.size();i++)\\n        {\\n            string s=list2[i];\\n            if(mp.count(s)>0)\\n            {\\n                if(mn>(mp[s]+i))\\n                {\\n                    mn=mp[s]+i;  //find the minimum indexes\\n                }\\n            }\\n        }\\n        \\n      for(int i=0;i<list2.size();i++)\\n        {\\n            string s=list2[i];\\n            if(mp.count(s)>0)\\n            {\\n                if(mn==(mp[s]+i))  //fetch all the candidate words that is also least index\\n                {                 // this condition is use to handle the duplicate count of same min index words\\n                    mn=mp[s]+i;  //find the minimum indexes\\n                    ans.push_back(s);\\n                }\\n            }\\n        }      \\n        \\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n   vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) \\n    {\\n        int mn=INT_MAX;\\n        string ans;\\n        for(int i=0;i<list1.size();i++)\\n        {\\n            string s=list1[i];\\n            for(int j=0;j<list2.size();j++)\\n            {\\n               if(list2[j]==s)\\n               {\\n                   if(mn>(i+j))\\n                  {    mn=i+j;\\n                       ans=list2[j];\\n                  }\\n               }\\n            }\\n        }\\n        \\nvector<string> temp;        \\n         for(int i=0;i<list1.size();i++)\\n        {\\n            string s=list1[i];\\n            for(int j=0;j<list2.size();j++)\\n            {\\n               if(list2[j]==s)\\n               {\\n                   if(mn==(i+j))\\n                  {    \\n                       temp.push_back(list2[j]);\\n                  }\\n               }\\n            }\\n        }       \\n        \\n        \\n        return temp;\\n```\n```\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) \\n    {\\n        int mn=INT_MAX;\\n        vector<string>ans;\\n        unordered_map<string,int>mp;\\n        \\n        for(int i=0;i<list1.size();i++) mp[list1[i]]=i+1;\\n\\n        \\n        for(int i=0;i<list2.size();i++)\\n        {\\n            string s=list2[i];\\n            if(mp.count(s)>0)\\n            {\\n                if(mn>(mp[s]+i))\\n                {\\n                    mn=mp[s]+i;  //find the minimum indexes\\n                }\\n            }\\n        }\\n        \\n      for(int i=0;i<list2.size();i++)\\n        {\\n            string s=list2[i];\\n            if(mp.count(s)>0)\\n            {\\n                if(mn==(mp[s]+i))  //fetch all the candidate words that is also least index\\n                {                 // this condition is use to handle the duplicate count of same min index words\\n                    mn=mp[s]+i;  //find the minimum indexes\\n                    ans.push_back(s);\\n                }\\n            }\\n        }      \\n        \\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2478209,
                "title": "java-stream-solution",
                "content": "`THIS CODE IS NOT FASTER `\\n\\n```\\npublic class Solution {\\n    public static String[] findRestaurant(String[] list1, String[] list2) {\\n        List<String[]> strings = Arrays.asList(list1, list2);\\n        AtomicInteger minValue = new AtomicInteger(Integer.MAX_VALUE);\\n        return strings.stream()\\n                .flatMap(item -> IntStream.range(0, item.length).mapToObj(index -> Map.entry(item[index], index)))\\n                .collect(Collectors.groupingBy(Map.Entry::getKey, Collectors.mapping(Map.Entry::getValue, Collectors.toList())))\\n                .entrySet()\\n                .stream()\\n                .map(item -> Map.entry(item.getKey(), item.getValue().stream().collect(Collectors.summarizingInt(index -> index))))\\n                .filter(item -> item.getValue().getCount() != 1)\\n                .sorted(Comparator.comparingLong(item -> item.getValue().getSum()))\\n                .peek(item -> minValue.getAndAccumulate((int) item.getValue().getSum(), Math::min))\\n                .filter(item -> (int) item.getValue().getSum() == minValue.get())\\n                .map(Map.Entry::getKey)\\n                .toArray(String[]::new);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public static String[] findRestaurant(String[] list1, String[] list2) {\\n        List<String[]> strings = Arrays.asList(list1, list2);\\n        AtomicInteger minValue = new AtomicInteger(Integer.MAX_VALUE);\\n        return strings.stream()\\n                .flatMap(item -> IntStream.range(0, item.length).mapToObj(index -> Map.entry(item[index], index)))\\n                .collect(Collectors.groupingBy(Map.Entry::getKey, Collectors.mapping(Map.Entry::getValue, Collectors.toList())))\\n                .entrySet()\\n                .stream()\\n                .map(item -> Map.entry(item.getKey(), item.getValue().stream().collect(Collectors.summarizingInt(index -> index))))\\n                .filter(item -> item.getValue().getCount() != 1)\\n                .sorted(Comparator.comparingLong(item -> item.getValue().getSum()))\\n                .peek(item -> minValue.getAndAccumulate((int) item.getValue().getSum(), Math::min))\\n                .filter(item -> (int) item.getValue().getSum() == minValue.get())\\n                .map(Map.Entry::getKey)\\n                .toArray(String[]::new);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467989,
                "title": "easy-python-solution-using-2-sets-easyaf-p",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        s = list(set(list1).intersection(set(list2)))\\n        res = []\\n        mn = float(\\'inf\\')\\n        for i in s:\\n            ss = list1.index(i)+list2.index(i)\\n            if ss<mn:\\n                res = [i]\\n                mn = ss\\n            elif ss == mn:\\n                res.append(i)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        s = list(set(list1).intersection(set(list2)))\\n        res = []\\n        mn = float(\\'inf\\')\\n        for i in s:\\n            ss = list1.index(i)+list2.index(i)\\n            if ss<mn:\\n                res = [i]\\n                mn = ss\\n            elif ss == mn:\\n                res.append(i)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2455193,
                "title": "c-easy-solution-using-two-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string, int> temp;\\n        unordered_map<int, string> sum;\\n        vector<string> sameSum;\\n        \\n        for(int i = 0; i < list1.size(); i++)\\n            temp[list1[i]] = i;\\n        \\n        int minSum = 2001;\\n        \\n        for(int i = 0; i < list2.size(); i++)\\n            if(temp.find(list2[i]) != temp.end()){\\n                \\n                if(sum.find(i + temp[list2[i]]) == sum.end()){\\n                    sum[i + temp[list2[i]]] = list2[i];\\n                    if(sameSum.size() == 0 || i + temp[list2[i]] < minSum){\\n                        sameSum.clear();\\n                        minSum = i + temp[list2[i]];\\n                        sameSum.push_back(list2[i]);\\n                    }\\n                }  \\n                else{\\n                    if(i + temp[list2[i]] < minSum){\\n                        sameSum.clear();\\n                        minSum = i + temp[list2[i]];\\n                        sameSum.push_back(list2[i]);\\n                    }\\n                    else if(i + temp[list2[i]] == minSum){\\n                        sameSum.push_back(list2[i]);\\n                    }\\n                }\\n            }\\n                \\n        \\n        return sameSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string, int> temp;\\n        unordered_map<int, string> sum;\\n        vector<string> sameSum;\\n        \\n        for(int i = 0; i < list1.size(); i++)\\n            temp[list1[i]] = i;\\n        \\n        int minSum = 2001;\\n        \\n        for(int i = 0; i < list2.size(); i++)\\n            if(temp.find(list2[i]) != temp.end()){\\n                \\n                if(sum.find(i + temp[list2[i]]) == sum.end()){\\n                    sum[i + temp[list2[i]]] = list2[i];\\n                    if(sameSum.size() == 0 || i + temp[list2[i]] < minSum){\\n                        sameSum.clear();\\n                        minSum = i + temp[list2[i]];\\n                        sameSum.push_back(list2[i]);\\n                    }\\n                }  \\n                else{\\n                    if(i + temp[list2[i]] < minSum){\\n                        sameSum.clear();\\n                        minSum = i + temp[list2[i]];\\n                        sameSum.push_back(list2[i]);\\n                    }\\n                    else if(i + temp[list2[i]] == minSum){\\n                        sameSum.push_back(list2[i]);\\n                    }\\n                }\\n            }\\n                \\n        \\n        return sameSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439706,
                "title": "python-easy-solution-for-beginners-using-lists-only",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        res = []\\n        min_ind_sum = -1\\n        if len(list1) < len(list2):\\n            for i in range(len(list1)):\\n                if list1[i] in list2:\\n                    ind_sum = i + list2.index(list1[i])\\n                    if min_ind_sum == -1 or ind_sum < min_ind_sum:\\n                        res.clear()\\n                        res.append(list1[i])\\n                        min_ind_sum = ind_sum\\n                    elif ind_sum == min_ind_sum:\\n                        res.append(list1[i])\\n        else:\\n            for i in range(len(list2)):\\n                if list2[i] in list1:\\n                    ind_sum = i + list1.index(list2[i])\\n                    if min_ind_sum == -1 or ind_sum < min_ind_sum:\\n                        res.clear()\\n                        res.append(list2[i])\\n                        min_ind_sum = ind_sum\\n                    elif ind_sum == min_ind_sum:\\n                        res.append(list2[i])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        res = []\\n        min_ind_sum = -1\\n        if len(list1) < len(list2):\\n            for i in range(len(list1)):\\n                if list1[i] in list2:\\n                    ind_sum = i + list2.index(list1[i])\\n                    if min_ind_sum == -1 or ind_sum < min_ind_sum:\\n                        res.clear()\\n                        res.append(list1[i])\\n                        min_ind_sum = ind_sum\\n                    elif ind_sum == min_ind_sum:\\n                        res.append(list1[i])\\n        else:\\n            for i in range(len(list2)):\\n                if list2[i] in list1:\\n                    ind_sum = i + list1.index(list2[i])\\n                    if min_ind_sum == -1 or ind_sum < min_ind_sum:\\n                        res.clear()\\n                        res.append(list2[i])\\n                        min_ind_sum = ind_sum\\n                    elif ind_sum == min_ind_sum:\\n                        res.append(list2[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2435320,
                "title": "easy-java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> l1 = Arrays.asList(list1);\\n        List<String> l2 = Arrays.asList(list2);\\n        List<String> common = new ArrayList<>();\\n        for(String s:list2){\\n            if(l1.contains(s))common.add(s);\\n        }\\n        ans.add(common.get(0));\\n        int firstind = l1.indexOf(common.get(0))+l2.indexOf(common.get(0));\\n        for(int i=1;i<common.size();i++){\\n            int minind = l1.indexOf(common.get(i))+l2.indexOf(common.get(i));\\n            if(minind < firstind){   \\n                ans.clear();\\n                ans.add(common.get(i));\\n            }\\n            else if(minind == firstind){\\n                ans.add(common.get(i));\\n            }\\n            else{\\n                continue; \\n            }\\n        }            \\n        return ans.toArray(new String[ans.size()]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> l1 = Arrays.asList(list1);\\n        List<String> l2 = Arrays.asList(list2);\\n        List<String> common = new ArrayList<>();\\n        for(String s:list2){\\n            if(l1.contains(s))common.add(s);\\n        }\\n        ans.add(common.get(0));\\n        int firstind = l1.indexOf(common.get(0))+l2.indexOf(common.get(0));\\n        for(int i=1;i<common.size();i++){\\n            int minind = l1.indexOf(common.get(i))+l2.indexOf(common.get(i));\\n            if(minind < firstind){   \\n                ans.clear();\\n                ans.add(common.get(i));\\n            }\\n            else if(minind == firstind){\\n                ans.add(common.get(i));\\n            }\\n            else{\\n                continue; \\n            }\\n        }            \\n        return ans.toArray(new String[ans.size()]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369450,
                "title": "python-solution-faster-than-95-7",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        dict = {}\\n        result = []\\n        for i in range(len(list1)):\\n            dict.update({list1[i]: i})\\n\\n        sum = (len(list2) - 1) + len(dict.values()) - 1\\n\\n        for j in range(len(list2)):\\n            if list2[j] in dict:\\n                if j + dict[list2[j]] < sum:\\n                    sum = j + dict[list2[j]]\\n                    result.clear()\\n                    result.append(list2[j])\\n                elif j + dict[list2[j]] == sum:\\n                    result.append(list2[j])\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        dict = {}\\n        result = []\\n        for i in range(len(list1)):\\n            dict.update({list1[i]: i})\\n\\n        sum = (len(list2) - 1) + len(dict.values()) - 1\\n\\n        for j in range(len(list2)):\\n            if list2[j] in dict:\\n                if j + dict[list2[j]] < sum:\\n                    sum = j + dict[list2[j]]\\n                    result.clear()\\n                    result.append(list2[j])\\n                elif j + dict[list2[j]] == sum:\\n                    result.append(list2[j])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362984,
                "title": "easy-solution-in-c-using-pair-and-hashmap-o-n-solution",
                "content": "class Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        \\n        unordered_map<string,pair<bool,int>> umap;\\n        vector<string> v;\\n        \\n        for(int i=0;i<list1.size();i++){\\n            umap[list1[i]] = make_pair(false,i);\\n        }\\n        \\n        for(int i=0;i<list2.size();i++){\\n            if(umap.find(list2[i])!=umap.end()){\\n                int k = umap[list2[i]].second;\\n                umap[list2[i]].first = true;\\n                umap[list2[i]].second = k+i;\\n            }\\n        }\\n        \\n        int minlength = INT_MAX;\\n        \\n        for(auto itr=umap.begin();itr!=umap.end();itr++){\\n            if((itr->second).first == true){\\n                \\n                if((itr->second).second < minlength){\\n                    minlength = (itr->second).second;\\n                    v.clear();\\n                    v.push_back(itr->first);\\n                }\\n                \\n                else if((itr->second).second==minlength){\\n                    v.push_back(itr->first);\\n                }\\n                \\n            }\\n        }\\n        \\n        return v;\\n        \\n        //Code contributed by Omkar Maindre.\\n\\t\\t\\n    }\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        \\n        unordered_map<string,pair<bool,int>> umap;\\n        vector<string> v;\\n        \\n        for(int i=0;i<list1.size();i++){\\n            umap[list1[i]] = make_pair(false,i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2343020,
                "title": "easy-c-solution-using-maps",
                "content": "```\\nvector<string> findRestaurant(vector<string>& l1, vector<string>& l2) {\\n        unordered_map<string,int>m;\\n        for(int i=0;i<l1.size();i++)\\n            m[l1[i]]=i;\\n       \\n       vector<string>ans;\\n       int mn=1e9;\\n       for(int i=0;i<l2.size();i++){\\n           if(m.find(l2[i])!=m.end()){\\n               if(mn>i+m[l2[i]]){\\n                   mn=i+m[l2[i]];\\n                   ans.clear();\\n                   ans.push_back(l2[i]);\\n               }else if(mn==i+m[l2[i]])ans.push_back(l2[i]);\\n           }\\n       }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<string> findRestaurant(vector<string>& l1, vector<string>& l2) {\\n        unordered_map<string,int>m;\\n        for(int i=0;i<l1.size();i++)\\n            m[l1[i]]=i;\\n       \\n       vector<string>ans;\\n       int mn=1e9;\\n       for(int i=0;i<l2.size();i++){\\n           if(m.find(l2[i])!=m.end()){\\n               if(mn>i+m[l2[i]]){\\n                   mn=i+m[l2[i]];\\n                   ans.clear();\\n                   ans.push_back(l2[i]);\\n               }else if(mn==i+m[l2[i]])ans.push_back(l2[i]);\\n           }\\n       }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2342252,
                "title": "java-o-n-no-nested-loop",
                "content": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String,Integer> hash = new HashMap<>();\\n        int sum=0, prev=Integer.MAX_VALUE;\\n        String result = null;\\n        \\n        for(int i=0;i< list1.length;i++){\\n            hash.put(list1[i],i);\\n        }\\n        for (int i=0;i<list2.length;i++){\\n            if(hash.containsKey(list2[i])){\\n                sum = i + hash.get(list2[i]);\\n                if(prev>sum){\\n                    prev = sum;\\n                    result = list2[i];\\n                } else if(prev == sum){\\n                    prev = sum;\\n                    result += \"  \"+list2[i];\\n                }\\n            }\\n        }\\n        return result.split(\"  \");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String,Integer> hash = new HashMap<>();\\n        int sum=0, prev=Integer.MAX_VALUE;\\n        String result = null;\\n        \\n        for(int i=0;i< list1.length;i++){\\n            hash.put(list1[i],i);\\n        }\\n        for (int i=0;i<list2.length;i++){\\n            if(hash.containsKey(list2[i])){\\n                sum = i + hash.get(list2[i]);\\n                if(prev>sum){\\n                    prev = sum;\\n                    result = list2[i];\\n                } else if(prev == sum){\\n                    prev = sum;\\n                    result += \"  \"+list2[i];\\n                }\\n            }\\n        }\\n        return result.split(\"  \");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308346,
                "title": "java-99",
                "content": "```\\n public static String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int min = Integer.MAX_VALUE;\\n        int count = 0;\\n        for (int i = 0; i < list1.length; i++) {\\n            map.put(list1[i], i);\\n        }\\n\\n        for (int j = 0; j < list2.length; j++) {\\n            Integer l1Indx = map.get(list2[j]);\\n            if (l1Indx != null) {\\n                int sum = l1Indx + j;\\n                if (sum < min) {\\n                    min = sum;\\n                    list1[0] = list2[j];\\n                    count = 1;\\n                } else if (sum == min) {\\n                    list1[count++] = list2[j];\\n                }\\n            }\\n        }\\n\\n        String[] result = new String[count];\\n        for (int i = 0; i < count; i++) {\\n            result[i] = list1[i];\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public static String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int min = Integer.MAX_VALUE;\\n        int count = 0;\\n        for (int i = 0; i < list1.length; i++) {\\n            map.put(list1[i], i);\\n        }\\n\\n        for (int j = 0; j < list2.length; j++) {\\n            Integer l1Indx = map.get(list2[j]);\\n            if (l1Indx != null) {\\n                int sum = l1Indx + j;\\n                if (sum < min) {\\n                    min = sum;\\n                    list1[0] = list2[j];\\n                    count = 1;\\n                } else if (sum == min) {\\n                    list1[count++] = list2[j];\\n                }\\n            }\\n        }\\n\\n        String[] result = new String[count];\\n        for (int i = 0; i < count; i++) {\\n            result[i] = list1[i];\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2205630,
                "title": "java-iterative-solution",
                "content": "class Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        int min = Integer.MAX_VALUE;\\n        String str = new String();        \\n        for(int i=0;i<list1.length;i++){\\n            for(int j=0;j<list2.length;j++){\\n                if(list1[i].equals(list2[j]) && i+j<min){\\n                    min = i+j;\\n                    str=list1[i]+\"_\";\\n                    break;\\n                }else if(list1[i].equals(list2[j]) && i+j==min){\\n                    str+=list1[i]+\"_\";\\n                    break;\\n                }\\n            }\\n        }\\n        return str.split(\"_\");\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        int min = Integer.MAX_VALUE;\\n        String str = new String();        \\n        for(int i=0;i<list1.length;i++){\\n            for(int j=0;j<list2.length;j++){\\n                if(list1[i].equals(list2[j]) && i+j<min){\\n                    min = i+j;\\n                    str=list1[i]+\"_\";\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2193642,
                "title": "easy-2-solution-c-code-easy-to-understand-check-it",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2)\\n    {\\n        int x = INT_MAX;\\n        vector<string> ans;\\n        for (int i = 0; i < list1.size(); ++i)\\n        {\\n            for (int j = 0; j < list2.size(); ++j)\\n            {\\n                if (list1[i] == list2[j])\\n                {\\n                    if (i+j == x)  ans.push_back(list1[i]);\\n                    else if (i+j > x) continue;\\n                    else\\n                    {\\n                        x = i+j;\\n                        ans.clear();\\n                        ans.push_back(list1[i]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n        unordered_map<int, vector<string>> m;\\n        int x = INT_MAX;\\n        for (int i = 0; i < list1.size(); ++i)\\n        {\\n            for (int j = 0; j < list2.size(); ++j)\\n            {\\n                if (list1[i] == list2[j])\\n                {\\n                    m[i+j].push_back(list1[i]);\\n                    x = min(x, i+j);\\n                }\\n            }\\n        }\\n        return m[x];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2)\\n    {\\n        int x = INT_MAX;\\n        vector<string> ans;\\n        for (int i = 0; i < list1.size(); ++i)\\n        {\\n            for (int j = 0; j < list2.size(); ++j)\\n            {\\n                if (list1[i] == list2[j])\\n                {\\n                    if (i+j == x)  ans.push_back(list1[i]);\\n                    else if (i+j > x) continue;\\n                    else\\n                    {\\n                        x = i+j;\\n                        ans.clear();\\n                        ans.push_back(list1[i]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n        unordered_map<int, vector<string>> m;\\n        int x = INT_MAX;\\n        for (int i = 0; i < list1.size(); ++i)\\n        {\\n            for (int j = 0; j < list2.size(); ++j)\\n            {\\n                if (list1[i] == list2[j])\\n                {\\n                    m[i+j].push_back(list1[i]);\\n                    x = min(x, i+j);\\n                }\\n            }\\n        }\\n        return m[x];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189398,
                "title": "simple-python-solution",
                "content": "```\\ndef findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n\\tresult = []\\n\\tminIndex = 99999\\n\\tfor restaurant in list1:\\n\\t\\tif restaurant in list2:\\n\\t\\t\\tidx1 = list1.index(restaurant)\\n\\t\\t\\tidx2 = list2.index(restaurant)\\n\\t\\t\\tif(idx1 + idx2 < minIndex):\\n\\t\\t\\t\\tminIndex = idx1 + idx2\\n\\t\\t\\t\\tresult = [restaurant]\\n\\t\\t\\telif idx1 + idx2 == minIndex:\\n\\t\\t\\t\\tresult.append(restaurant)\\n\\treturn result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n\\tresult = []\\n\\tminIndex = 99999\\n\\tfor restaurant in list1:\\n\\t\\tif restaurant in list2:\\n\\t\\t\\tidx1 = list1.index(restaurant)\\n\\t\\t\\tidx2 = list2.index(restaurant)\\n\\t\\t\\tif(idx1 + idx2 < minIndex):\\n\\t\\t\\t\\tminIndex = idx1 + idx2\\n\\t\\t\\t\\tresult = [restaurant]\\n\\t\\t\\telif idx1 + idx2 == minIndex:\\n\\t\\t\\t\\tresult.append(restaurant)\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2167095,
                "title": "simple-typescript-javascript-solution",
                "content": "```\\nfunction findRestaurant(list1: string[], list2: string[]): string[] {\\n    if (list1.length == 0 || list2.length == 0) return [\"\"];\\n    let map = new Map();\\n    for (let i = 0; i < list1.length; i++) map.set(list1[i], i);\\n    \\n    let min = Number.MAX_SAFE_INTEGER;\\n    let res = [];\\n    let total;\\n    for (let j = 0; j < list2.length; j++) {\\n        if (map.has(list2[j])) {\\n            total = j + map.get(list2[j]);\\n            if (total < min) {\\n                res = [];\\n                res.push(list2[j]);\\n                min = total;\\n            } else if (total == min) {\\n                res.push(list2[j]);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction findRestaurant(list1: string[], list2: string[]): string[] {\\n    if (list1.length == 0 || list2.length == 0) return [\"\"];\\n    let map = new Map();\\n    for (let i = 0; i < list1.length; i++) map.set(list1[i], i);\\n    \\n    let min = Number.MAX_SAFE_INTEGER;\\n    let res = [];\\n    let total;\\n    for (let j = 0; j < list2.length; j++) {\\n        if (map.has(list2[j])) {\\n            total = j + map.get(list2[j]);\\n            if (total < min) {\\n                res = [];\\n                res.push(list2[j]);\\n                min = total;\\n            } else if (total == min) {\\n                res.push(list2[j]);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2118900,
                "title": "c-o-n-solution-testing-not-done-properly-hashmap",
                "content": "I have **commented one line** in following code, then it gives **wrong output** for following testcase,\\n\\n**Testcase :**\\n```\\n[\"S\",\"BK\",\"TEXP\",\"KFC\"]\\n[\"KFC\",\"BK\",\"S\"]\\n```\\n**Output :**\\n```\\n[\"S\"]\\n```\\n**Expexted Output :**\\n```\\n[\"BK\",\"S\"]\\n```\\n\\n**But it, still get accepted.**\\n\\n```\\nvector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string,int>m;\\n        \\n        for(int i=0; i<list1.size(); i++){\\n            m[list1[i]]=i+1;\\n        }\\n        \\n        int mini=0;\\n        vector<string>ans;\\n        for(int i=0; i<list2.size(); i++){\\n            if(m[list2[i]]>0){\\n                if(ans.size()==0){\\n                    ans.push_back(list2[i]);\\n                    mini=i+m[list2[i]];\\n                }\\n                else if(mini>m[list2[i]]+i){\\n                    ans.clear();\\n                    ans.push_back(list2[i]);\\n                    //mini=i+m[list2[i]];\\n                }\\n                else if(mini==m[list2[i]]+i){\\n                    ans.push_back(list2[i]);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n```\\n\\nIf I **uncomment that line**, then **code is also working** for above testcase, and **also accepted**.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n[\"S\",\"BK\",\"TEXP\",\"KFC\"]\\n[\"KFC\",\"BK\",\"S\"]\\n```\n```\\n[\"S\"]\\n```\n```\\n[\"BK\",\"S\"]\\n```\n```\\nvector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string,int>m;\\n        \\n        for(int i=0; i<list1.size(); i++){\\n            m[list1[i]]=i+1;\\n        }\\n        \\n        int mini=0;\\n        vector<string>ans;\\n        for(int i=0; i<list2.size(); i++){\\n            if(m[list2[i]]>0){\\n                if(ans.size()==0){\\n                    ans.push_back(list2[i]);\\n                    mini=i+m[list2[i]];\\n                }\\n                else if(mini>m[list2[i]]+i){\\n                    ans.clear();\\n                    ans.push_back(list2[i]);\\n                    //mini=i+m[list2[i]];\\n                }\\n                else if(mini==m[list2[i]]+i){\\n                    ans.push_back(list2[i]);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053680,
                "title": "js-javascript-solution",
                "content": "```\\nvar findRestaurant = function(list1, list2) {\\n    const map = {};\\n    \\n    list1.forEach((x, i) => {\\n        map[x] = (i + 1) * -1;\\n    });\\n    \\n    list2.forEach((x, i) => {\\n        if (map[x]) {\\n            map[x] *= -1;\\n            map[x] += (i + 1);\\n        } \\n    });\\n\\n    return Object.keys(map)\\n        .filter(x => map[x] >= 0)\\n        .sort((a, b) => map[a] - map[b])\\n        .reduce((res, x) => {\\n            const prev = res[res.length - 1];\\n        \\n            if (!prev || map[prev] === map[x]) {\\n                res.push(x);\\n            }\\n        \\n            return res;\\n        }, []);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findRestaurant = function(list1, list2) {\\n    const map = {};\\n    \\n    list1.forEach((x, i) => {\\n        map[x] = (i + 1) * -1;\\n    });\\n    \\n    list2.forEach((x, i) => {\\n        if (map[x]) {\\n            map[x] *= -1;\\n            map[x] += (i + 1);\\n        } \\n    });\\n\\n    return Object.keys(map)\\n        .filter(x => map[x] >= 0)\\n        .sort((a, b) => map[a] - map[b])\\n        .reduce((res, x) => {\\n            const prev = res[res.length - 1];\\n        \\n            if (!prev || map[prev] === map[x]) {\\n                res.push(x);\\n            }\\n        \\n            return res;\\n        }, []);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2041371,
                "title": "simple-and-fastest-java-solution",
                "content": "java code is:\\n\\n```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String,Integer>map=new HashMap<>();\\n        for(int i=0;i<list2.length;i++)map.put(list2[i],i);\\n        List<String>list=new ArrayList<>();\\n        int sum=Integer.MAX_VALUE;\\n        for(int i=0;i<list1.length;i++){\\n            if(!map.containsKey(list1[i]))continue;\\n            int s=i+map.get(list1[i]);\\n            if(s<sum){\\n                list.clear();\\n                list.add(list1[i]);\\n                sum=s;\\n            }\\n            else if(s==sum) list.add(list1[i]);\\n        }\\n        String ans[]=new String[list.size()];\\n        for(int i=0;i<list.size();i++)\\n            ans[i]=list.get(i);\\n        return ans;\\n    }\\n}\\n# ```\\n# \\n# Time : O(n) linear\\n# Space : O(n) linear\\n# \\n# Please Upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String,Integer>map=new HashMap<>();\\n        for(int i=0;i<list2.length;i++)map.put(list2[i],i);\\n        List<String>list=new ArrayList<>();\\n        int sum=Integer.MAX_VALUE;\\n        for(int i=0;i<list1.length;i++){\\n            if(!map.containsKey(list1[i]))continue;\\n            int s=i+map.get(list1[i]);\\n            if(s<sum){\\n                list.clear();\\n                list.add(list1[i]);\\n                sum=s;\\n            }\\n            else if(s==sum) list.add(list1[i]);\\n        }\\n        String ans[]=new String[list.size()];\\n        for(int i=0;i<list.size();i++)\\n            ans[i]=list.get(i);\\n        return ans;\\n    }\\n}\\n# ```",
                "codeTag": "Java"
            },
            {
                "id": 2014518,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {string[]} list1\\n * @param {string[]} list2\\n * @return {string[]}\\n */\\nvar findRestaurant = function(list1, list2) {\\n    \\n    // map list1 items with their indexes\\n    const map = new Map();\\n    for(let i=0; i<list1.length; i++){\\n        map.set(list1[i], i);\\n    }\\n    \\n    const common = [];\\n    \\n    // loop through the list2\\n    for(let i=0; i<list2.length; i++){\\n        const title = list2[i];\\n        \\n        // if the title is not common for 2 lists --> ignore it\\n        if(!map.has(title)) continue;\\n        \\n        // add common item to the \\'common\\' array\\n        // the index of array == sum of indexes list1 & list2\\n        // each index may be mapped to multiple restaurants\\n        const sum = i + map.get(title);\\n        common[sum] = common[sum] || [];\\n        common[sum].push(title);\\n    }\\n    \\n    // return the first restaurant (with the least sum)\\n    for(let i=0; i<common.length; i++){\\n        if(common[i] !== undefined) return common[i];\\n    }\\n    \\n    return [];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} list1\\n * @param {string[]} list2\\n * @return {string[]}\\n */\\nvar findRestaurant = function(list1, list2) {\\n    \\n    // map list1 items with their indexes\\n    const map = new Map();\\n    for(let i=0; i<list1.length; i++){\\n        map.set(list1[i], i);\\n    }\\n    \\n    const common = [];\\n    \\n    // loop through the list2\\n    for(let i=0; i<list2.length; i++){\\n        const title = list2[i];\\n        \\n        // if the title is not common for 2 lists --> ignore it\\n        if(!map.has(title)) continue;\\n        \\n        // add common item to the \\'common\\' array\\n        // the index of array == sum of indexes list1 & list2\\n        // each index may be mapped to multiple restaurants\\n        const sum = i + map.get(title);\\n        common[sum] = common[sum] || [];\\n        common[sum].push(title);\\n    }\\n    \\n    // return the first restaurant (with the least sum)\\n    for(let i=0; i<common.length; i++){\\n        if(common[i] !== undefined) return common[i];\\n    }\\n    \\n    return [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2003678,
                "title": "java-help-me-out",
                "content": "can someone tell that why this program is always returning null array of string here.\\nWHY THE HELL IT ISN\\'T SATISFYING THE IF CONDITION?\\n\\nThe question is-\\n\\nSuppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.\\n\\nYou need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.\\n\\nExample 1:\\n\\nInput: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\nOutput: [\"Shogun\"]\\nExplanation: The only restaurant they both like is \"Shogun\".\\nExample 2:\\n\\nInput: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\\nOutput: [\"Shogun\"]\\nExplanation: The restaurant they both like and have the least index sum is \"Shogun\" with index sum 1 (0+1).\\n```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        int n=list1.length;\\n        int m=list2.length;\\n        int curr=Integer.MAX_VALUE;\\n        String[] list3 = new String[1];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(list1[i]==list2[j]) {\\n                    if(i+j<curr){\\n                    curr=i+j;\\n                    list3[0]=list1[i];\\n                    }\\n                }\\n            }\\n        }\\n        return list3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        int n=list1.length;\\n        int m=list2.length;\\n        int curr=Integer.MAX_VALUE;\\n        String[] list3 = new String[1];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(list1[i]==list2[j]) {\\n                    if(i+j<curr){\\n                    curr=i+j;\\n                    list3[0]=list1[i];\\n                    }\\n                }\\n            }\\n        }\\n        return list3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999122,
                "title": "dictionary-solution",
                "content": "```\\n\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        l = []\\n        k = {}\\n        g = {}\\n        m = 0\\n        n = 0\\n        r = []\\n        flag = []\\n        h = []\\n        o =0\\n        slag = 0\\n        for i in list1:\\n            k.update({i : m})\\n            m+=1\\n        for i in list2:\\n            g.update({i : n})\\n            n+=1\\n        for keys1,values1 in k.items():\\n            for keys2,values2 in g.items():\\n                if keys1==keys2 and o==0:\\n                    o+=1\\n                    r.append(keys1)\\n                    h.append(values1 + values2)\\n                elif keys1==keys2 and (values1 + values2) in h:\\n                    r.append(keys1)\\n                elif keys1==keys2 and (values1+values2)<h[0]:\\n                    flag.append(keys1)\\n                    slag =1\\n        \\n        if slag == 1:\\n            return flag\\n        else:\\n                     \\n            return r\\n\\n                \\n                \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        l = []\\n        k = {}\\n        g = {}\\n        m = 0\\n        n = 0\\n        r = []\\n        flag = []\\n        h = []\\n        o =0\\n        slag = 0\\n        for i in list1:\\n            k.update({i : m})\\n            m+=1\\n        for i in list2:\\n            g.update({i : n})\\n            n+=1\\n        for keys1,values1 in k.items():\\n            for keys2,values2 in g.items():\\n                if keys1==keys2 and o==0:\\n                    o+=1\\n                    r.append(keys1)\\n                    h.append(values1 + values2)\\n                elif keys1==keys2 and (values1 + values2) in h:\\n                    r.append(keys1)\\n                elif keys1==keys2 and (values1+values2)<h[0]:\\n                    flag.append(keys1)\\n                    slag =1\\n        \\n        if slag == 1:\\n            return flag\\n        else:\\n                     \\n            return r\\n\\n                \\n                \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932962,
                "title": "python-easy-solution-for-beginner-99-7-faster-using-dictionary",
                "content": "```\\n\\n```class Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        has={}\\n        total=len(list1)+len(list2)\\n        ans=[]\\n        for i in range(len(list1)):\\n            has[list1[i]]=i\\n        for j in range(len(list2)):\\n            if list2[j] in has and has[list2[j]]+j<total:\\n                if ans:\\n                    ans=[]\\n                ans.append(list2[j])\\n                total=min(total,has[list2[j]]+j)\\n            elif list2[j] in has and has[list2[j]]+j==total:\\n                ans.append(list2[j])\\n        return ans``\\n\\tPlease upvote if you like it",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1898544,
                "title": "c-clear-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string,int> mp2;\\n        \\n        for(int i=0;i<list2.size();i++){\\n            mp2[list2[i]]=i;\\n        }\\n    vector<string> ans;\\n        int a=INT_MAX;\\n        for(int i=0;i<list1.size();i++){\\n            if(mp2.find(list1[i])!=mp2.end()&&(i+mp2[list1[i]]<=a)){\\n                if(a!=i+mp2[list1[i]]){\\n                ans.clear();\\n                }\\n                a=i+mp2[list1[i]];\\n                ans.push_back(list1[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string,int> mp2;\\n        \\n        for(int i=0;i<list2.size();i++){\\n            mp2[list2[i]]=i;\\n        }\\n    vector<string> ans;\\n        int a=INT_MAX;\\n        for(int i=0;i<list1.size();i++){\\n            if(mp2.find(list1[i])!=mp2.end()&&(i+mp2[list1[i]]<=a)){\\n                if(a!=i+mp2[list1[i]]){\\n                ans.clear();\\n                }\\n                a=i+mp2[list1[i]];\\n                ans.push_back(list1[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885546,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        interest_map, res, min_sum = {}, [], sys.maxsize\\n        for i, s1 in enumerate(list1):\\n            interest_map[s1] = i\\n        for i, s2 in enumerate(list2):\\n            if s2 in interest_map:\\n                index_sum = interest_map[s2]+i\\n                if index_sum < min_sum:\\n                    res.clear()\\n                    res.append(s2)\\n                    min_sum = index_sum\\n                elif index_sum == min_sum:\\n                    res.append(s2)\\n        return res`\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        interest_map, res, min_sum = {}, [], sys.maxsize\\n        for i, s1 in enumerate(list1):\\n            interest_map[s1] = i\\n        for i, s2 in enumerate(list2):\\n            if s2 in interest_map:\\n                index_sum = interest_map[s2]+i\\n                if index_sum < min_sum:\\n                    res.clear()\\n                    res.append(s2)\\n                    min_sum = index_sum\\n                elif index_sum == min_sum:\\n                    res.append(s2)\\n        return res`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821037,
                "title": "88ms-98-typescript-using-maps",
                "content": "# Solution:\\nTIme Complexity: **O(N+M)**\\nSpace Complexity: **O(N+M)**\\n\\n```\\nconst findRestaurant = (list1: string[], list2: string[]): string[] => {\\n\\tconst firstMap: Map<string, number> = new Map<string, number>();\\n\\tconst secondMap: Map<string, number> = new Map<string, number>();\\n\\tconst result: string[] = [];\\n\\n\\t// move first list into first map\\n\\tfor (let i = 0; i <= list1.length; i++) {\\n\\t\\tfirstMap.set(list1[i], i);\\n\\t}\\n\\n\\t// move second list into second map\\n\\tfor (let i = 0; i <= list2.length; i++) {\\n\\t\\tsecondMap.set(list2[i], i);\\n\\t}\\n\\n\\t// find min counter\\n\\tlet minCounter = Number.MAX_SAFE_INTEGER;\\n\\tfor (let [key, value] of firstMap.entries()) {\\n\\t\\tconst secondMapValue = secondMap.get(key);\\n\\n\\t\\tif (typeof secondMapValue === \"undefined\") {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tconst indexSum = secondMapValue + value;\\n\\t\\tminCounter = Math.min(minCounter, indexSum);\\n\\t}\\n\\n\\t// find target restaurants\\n\\tfor (let [key, value] of firstMap.entries()) {\\n\\t\\tconst secondMapValue = secondMap.get(key);\\n\\n\\t\\tif (typeof secondMapValue === \"undefined\") {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tconst indexSum = secondMapValue + value;\\n\\t\\tif (indexSum === minCounter) {\\n\\t\\t\\tresult.push(key);\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst findRestaurant = (list1: string[], list2: string[]): string[] => {\\n\\tconst firstMap: Map<string, number> = new Map<string, number>();\\n\\tconst secondMap: Map<string, number> = new Map<string, number>();\\n\\tconst result: string[] = [];\\n\\n\\t// move first list into first map\\n\\tfor (let i = 0; i <= list1.length; i++) {\\n\\t\\tfirstMap.set(list1[i], i);\\n\\t}\\n\\n\\t// move second list into second map\\n\\tfor (let i = 0; i <= list2.length; i++) {\\n\\t\\tsecondMap.set(list2[i], i);\\n\\t}\\n\\n\\t// find min counter\\n\\tlet minCounter = Number.MAX_SAFE_INTEGER;\\n\\tfor (let [key, value] of firstMap.entries()) {\\n\\t\\tconst secondMapValue = secondMap.get(key);\\n\\n\\t\\tif (typeof secondMapValue === \"undefined\") {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tconst indexSum = secondMapValue + value;\\n\\t\\tminCounter = Math.min(minCounter, indexSum);\\n\\t}\\n\\n\\t// find target restaurants\\n\\tfor (let [key, value] of firstMap.entries()) {\\n\\t\\tconst secondMapValue = secondMap.get(key);\\n\\n\\t\\tif (typeof secondMapValue === \"undefined\") {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tconst indexSum = secondMapValue + value;\\n\\t\\tif (indexSum === minCounter) {\\n\\t\\t\\tresult.push(key);\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1808099,
                "title": "python-hashmap-min-heap-faster-than-91",
                "content": "```\\nimport heapq\\n\\nEntry = collections.namedtuple(\"Entry\", [\\'sum\\', \\'restuarant\\'])\\n\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        index_map = {}\\n        for index, restaurant in enumerate(list1):\\n            index_map[restaurant] = index\\n        \\n        leastIndexSumHeap : List[Entry] = []\\n        for i, restaurant in enumerate(list2):\\n            if restaurant in index_map:\\n                heappush(leastIndexSumHeap, Entry(i + index_map[restaurant], restaurant))\\n        \\n        leastIndexSum = leastIndexSumHeap[0][0]\\n        result = []\\n        while leastIndexSumHeap and leastIndexSumHeap[0].sum == leastIndexSum:\\n            entry = heappop(leastIndexSumHeap)\\n            result.append(entry.restuarant)\\n            \\n        return result\\n```\\n\\nO(N + NlogN) -> O(NlogN) time\\nO(N) space",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\n\\nEntry = collections.namedtuple(\"Entry\", [\\'sum\\', \\'restuarant\\'])\\n\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        index_map = {}\\n        for index, restaurant in enumerate(list1):\\n            index_map[restaurant] = index\\n        \\n        leastIndexSumHeap : List[Entry] = []\\n        for i, restaurant in enumerate(list2):\\n            if restaurant in index_map:\\n                heappush(leastIndexSumHeap, Entry(i + index_map[restaurant], restaurant))\\n        \\n        leastIndexSum = leastIndexSumHeap[0][0]\\n        result = []\\n        while leastIndexSumHeap and leastIndexSumHeap[0].sum == leastIndexSum:\\n            entry = heappop(leastIndexSumHeap)\\n            result.append(entry.restuarant)\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753714,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn find_restaurant(list1: Vec<String>, list2: Vec<String>) -> Vec<String> {\\n        use std::cmp::Ordering;\\n        use std::collections::HashMap;\\n\\n        let map = list1.iter().zip(0..).collect::<HashMap<_, usize>>();\\n        let mut res = vec![];\\n        let mut min_sum = usize::MAX;\\n\\n        for (i2, s2) in list2.into_iter().enumerate() {\\n            if let Some(&i1) = map.get(&s2) {\\n                let new_sum = i1 + i2;\\n                match new_sum.cmp(&min_sum) {\\n                    Ordering::Less => {\\n                        min_sum = new_sum;\\n                        res = vec![s2];\\n                    }\\n                    Ordering::Equal => res.push(s2),\\n                    _ => (),\\n                }\\n            }\\n            if i2 > min_sum {\\n                break;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_restaurant(list1: Vec<String>, list2: Vec<String>) -> Vec<String> {\\n        use std::cmp::Ordering;\\n        use std::collections::HashMap;\\n\\n        let map = list1.iter().zip(0..).collect::<HashMap<_, usize>>();\\n        let mut res = vec![];\\n        let mut min_sum = usize::MAX;\\n\\n        for (i2, s2) in list2.into_iter().enumerate() {\\n            if let Some(&i1) = map.get(&s2) {\\n                let new_sum = i1 + i2;\\n                match new_sum.cmp(&min_sum) {\\n                    Ordering::Less => {\\n                        min_sum = new_sum;\\n                        res = vec![s2];\\n                    }\\n                    Ordering::Equal => res.push(s2),\\n                    _ => (),\\n                }\\n            }\\n            if i2 > min_sum {\\n                break;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1716492,
                "title": "brute-force-o-n2-not-fast-but-good-to-understand",
                "content": "The basic algorithm of this question is to find the common restaurants between two lists (this is the main criteria of search) then we are looking forward to find the minmum sum of indices if the the restaurant is in common between the lists. \\n\\n``` \\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        // 1. brute force \\n        size_t s1=list1.size();\\n        size_t s2=list2.size();\\n\\n        vector<string> result;\\n        int minsum=INT_MAX;\\n        for(int i=0;i<s1;i++){\\n            for(int j=0;j<s2;j++){\\n                if(list1[i]==list2[j] && i+j<minsum){  // first we check if the indices less than the minimum and we enter to clear the previous array because there is a value found less than the previous // \\n                    result.clear();\\n                    result.push_back(list1[i]);\\n                    minsum=i+j;\\n                }\\n\\t\\t\\t\\t// here we enter to push not to clear because the sums are equals and the restaurants are ditinct \\n                else if(list1[i]==list2[j]&&i+j==minsum){\\n                    result.push_back(list1[i]);\\n                    minsum=i+j;\\n                } \\n            }\\n        }\\n    return result;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        // 1. brute force \\n        size_t s1=list1.size();\\n        size_t s2=list2.size();\\n\\n        vector<string> result;\\n        int minsum=INT_MAX;\\n        for(int i=0;i<s1;i++){\\n            for(int j=0;j<s2;j++){\\n                if(list1[i]==list2[j] && i+j<minsum){  // first we check if the indices less than the minimum and we enter to clear the previous array because there is a value found less than the previous // \\n                    result.clear();\\n                    result.push_back(list1[i]);\\n                    minsum=i+j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1702113,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string>v;\\n        unordered_map<string, int>mp;\\n        for(int i=0;i<list1.size();i++){\\n            mp[list1[i]]=i;\\n        }\\n        int min1=INT_MAX, sum;\\n        for(int i=0;i<list2.size();i++){\\n            if(mp.find(list2[i])!=mp.end()){\\n                sum=mp[list2[i]]+i;\\n                if(sum<min1){\\n                    min1=sum;\\n                    v.clear();\\n                    v.push_back(list2[i]);\\n                }else if(sum==min1){\\n                    v.push_back(list2[i]);\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string>v;\\n        unordered_map<string, int>mp;\\n        for(int i=0;i<list1.size();i++){\\n            mp[list1[i]]=i;\\n        }\\n        int min1=INT_MAX, sum;\\n        for(int i=0;i<list2.size();i++){\\n            if(mp.find(list2[i])!=mp.end()){\\n                sum=mp[list2[i]]+i;\\n                if(sum<min1){\\n                    min1=sum;\\n                    v.clear();\\n                    v.push_back(list2[i]);\\n                }else if(sum==min1){\\n                    v.push_back(list2[i]);\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700451,
                "title": "java-solution-using-arraylist",
                "content": "class Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        int min=Integer.MAX_VALUE;\\n         List<String> list=new ArrayList<String>();\\n        for(int i=0;i<list1.length;i++){\\n            for(int j=0;j<list2.length;j++){\\n                if(list1[i].equals(list2[j]) && i+j<=min){\\n                    if(i+j<min)\\n                        list.clear();\\n                    list.add(list1[i]);\\n                    min=i+j;\\n                }\\n            }   \\n        }\\n        String[] res = new String[list.size()];\\n        int i=0;\\n        for(String ele:list){\\n            res[i++] = ele;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        int min=Integer.MAX_VALUE;\\n         List<String> list=new ArrayList<String>();\\n        for(int i=0;i<list1.length;i++){\\n            for(int j=0;j<list2.length;j++){\\n                if(list1[i].equals(list2[j]) && i+j<=min){\\n                    if(i+j<min)\\n                        list.clear();\\n                    list.add(list1[i]);\\n                    min=i+j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1682094,
                "title": "python-simple-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        seen={}\\n        minsum=float(\"inf\")\\n        ans=[]\\n        for i in range(len(list1)):\\n            seen[list1[i]]=i\\n        for i in range(len(list2)):\\n            if list2[i] in seen:\\n                if i+seen[list2[i]]==minsum:\\n                    ans.append(list2[i])\\n                elif i+seen[list2[i]]<minsum:\\n                    minsum=i+seen[list2[i]]\\n                    ans=[list2[i]]\\n        return ans\\n                    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        seen={}\\n        minsum=float(\"inf\")\\n        ans=[]\\n        for i in range(len(list1)):\\n            seen[list1[i]]=i\\n        for i in range(len(list2)):\\n            if list2[i] in seen:\\n                if i+seen[list2[i]]==minsum:\\n                    ans.append(list2[i])\\n                elif i+seen[list2[i]]<minsum:\\n                    minsum=i+seen[list2[i]]\\n                    ans=[list2[i]]\\n        return ans\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680867,
                "title": "simple-to-understand-java-hashmap",
                "content": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String,Integer> map =new HashMap<>();\\n        \\n        for(int i=0;i<list1.length;i++){\\n            map.put(list1[i],i);\\n        }\\n        ArrayList<String> s =new ArrayList<>();\\n        int sum=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<list2.length;i++){\\n            if(map.containsKey(list2[i])){\\n                int a=i+map.get(list2[i]);\\n                if(a<=sum){\\n                    if(a!=sum){\\n                        s.clear();\\n                    }\\n                    sum=a;\\n                    s.add(list2[i]);\\n                }\\n            }\\n        }\\n        \\n        String[] st =new String[s.size()];\\n        for(int i=0;i<s.size();i++){\\n            st[i]=s.get(i);\\n        }\\n        return st;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String,Integer> map =new HashMap<>();\\n        \\n        for(int i=0;i<list1.length;i++){\\n            map.put(list1[i],i);\\n        }\\n        ArrayList<String> s =new ArrayList<>();\\n        int sum=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<list2.length;i++){\\n            if(map.containsKey(list2[i])){\\n                int a=i+map.get(list2[i]);\\n                if(a<=sum){\\n                    if(a!=sum){\\n                        s.clear();\\n                    }\\n                    sum=a;\\n                    s.add(list2[i]);\\n                }\\n            }\\n        }\\n        \\n        String[] st =new String[s.size()];\\n        for(int i=0;i<s.size();i++){\\n            st[i]=s.get(i);\\n        }\\n        return st;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664161,
                "title": "simple-unordered-map-c",
                "content": "``\\n vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n     \\n        unordered_map<string,int>mp;\\n        \\n        for(int i=0;i<list1.size();i++)\\n            mp[list1[i]]=i;\\n        \\n        vector<string>st;\\n        int sum=INT_MAX;\\n        for(int i=0;i<list2.size();i++)\\n        {\\n            if(mp.find(list2[i])!=mp.end())\\n            {\\n                \\n                if(i+mp[list2[i]]<sum)\\n                {\\n                  sum=i+mp[list2[i]];\\n                      if(!st.empty())\\n                          st.clear();\\n                  st.push_back(list2[i]);\\n                        \\n                }else if(i+mp[list2[i]]==sum)\\n                    st.push_back(list2[i]);\\n                    \\n            }\\n        }\\n        return st;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "``\\n vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n     \\n        unordered_map<string,int>mp;\\n        \\n        for(int i=0;i<list1.size();i++)\\n            mp[list1[i]]=i;\\n        \\n        vector<string>st;\\n        int sum=INT_MAX;\\n        for(int i=0;i<list2.size();i++)\\n        {\\n            if(mp.find(list2[i])!=mp.end())\\n            {\\n                \\n                if(i+mp[list2[i]]<sum)\\n                {\\n                  sum=i+mp[list2[i]];\\n                      if(!st.empty())\\n                          st.clear();\\n                  st.push_back(list2[i]);\\n                        \\n                }else if(i+mp[list2[i]]==sum)\\n                    st.push_back(list2[i]);\\n                    \\n            }\\n        }\\n        return st;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1632541,
                "title": "python-3-lines",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        \\n        hashmap1 = {element: index for index, element in enumerate(list1)}\\n        hashmap = {element: hashmap1[element] + index for index, element in enumerate(list2) if element in hashmap1}            \\n        return [element for element in hashmap if hashmap[element] == min(hashmap.values())]",
                "solutionTags": [],
                "code": "class Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        \\n        hashmap1 = {element: index for index, element in enumerate(list1)}",
                "codeTag": "Java"
            },
            {
                "id": 1620029,
                "title": "javascript-o-n-simple",
                "content": "```\\n/**\\n * @param {string[]} list1\\n * @param {string[]} list2\\n * @return {string[]}\\n */\\nvar findRestaurant = function(list1, list2) {\\n       let obj1 = {}\\n    let obj2 = {}\\n    for (let x in list1) {\\n        obj1[list1[x]] = Number(x)+1;\\n    }\\n    for (let x in list2) {\\n        obj2[list2[x]] = Number(x)+1;\\n    }\\n    //console.log(obj1)\\n    //console.log(obj2)\\n    let finalObj = {};\\n    for (let rest in obj1) {\\n        if (obj2[rest]) { finalObj[rest] = obj1[rest] + obj2[rest] }\\n    }\\n    //console.log(finalObj)\\n    let minIndex = Math.min(...Object.values(finalObj));\\n    let resArr = [];\\n    for (let key in finalObj) {\\n        if (finalObj[key] === minIndex) { resArr.push(key) }\\n    }\\n    return resArr; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} list1\\n * @param {string[]} list2\\n * @return {string[]}\\n */\\nvar findRestaurant = function(list1, list2) {\\n       let obj1 = {}\\n    let obj2 = {}\\n    for (let x in list1) {\\n        obj1[list1[x]] = Number(x)+1;\\n    }\\n    for (let x in list2) {\\n        obj2[list2[x]] = Number(x)+1;\\n    }\\n    //console.log(obj1)\\n    //console.log(obj2)\\n    let finalObj = {};\\n    for (let rest in obj1) {\\n        if (obj2[rest]) { finalObj[rest] = obj1[rest] + obj2[rest] }\\n    }\\n    //console.log(finalObj)\\n    let minIndex = Math.min(...Object.values(finalObj));\\n    let resArr = [];\\n    for (let key in finalObj) {\\n        if (finalObj[key] === minIndex) { resArr.push(key) }\\n    }\\n    return resArr; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1540611,
                "title": "simple-c-solution-using-map-beats-95",
                "content": "**Simple C++ solution, using map, 95% faster**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string , int> mp;\\n        map<int , vector<string>> temp;\\n        vector<string> res;\\n        for(int i = 0; i < list1.size(); i++){\\n            mp[list1[i]] = i;\\n        }\\n        \\n        for(int j = 0; j < list2.size(); j++){\\n            if(mp.find(list2[j]) != mp.end()) temp[j + mp[list2[j]]].push_back(list2[j]);\\n        }\\n        \\n        for(auto x : temp){\\n            if(x.second.size() != 0){\\n                return x.second;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string , int> mp;\\n        map<int , vector<string>> temp;\\n        vector<string> res;\\n        for(int i = 0; i < list1.size(); i++){\\n            mp[list1[i]] = i;\\n        }\\n        \\n        for(int j = 0; j < list2.size(); j++){\\n            if(mp.find(list2[j]) != mp.end()) temp[j + mp[list2[j]]].push_back(list2[j]);\\n        }\\n        \\n        for(auto x : temp){\\n            if(x.second.size() != 0){\\n                return x.second;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539323,
                "title": "simple-c-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string> ans;\\n        unordered_map<string, int> mp1;\\n        int mini = INT_MAX;\\n        \\n        for(int i=0; i<list1.size(); i++){\\n            mp1[list1[i]] = i;\\n        }\\n        for(int i=0; i<list2.size(); i++){\\n            if(mp1.find(list2[i]) != mp1.end()){\\n                if(mp1[list2[i]]+i < mini){\\n                    mini = mp1[list2[i]]+i;\\n                    ans.clear();\\n                    ans.push_back(list2[i]);\\n                }\\n                else if(mp1[list2[i]]+i == mini){\\n                    ans.push_back(list2[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string> ans;\\n        unordered_map<string, int> mp1;\\n        int mini = INT_MAX;\\n        \\n        for(int i=0; i<list1.size(); i++){\\n            mp1[list1[i]] = i;\\n        }\\n        for(int i=0; i<list2.size(); i++){\\n            if(mp1.find(list2[i]) != mp1.end()){\\n                if(mp1[list2[i]]+i < mini){\\n                    mini = mp1[list2[i]]+i;\\n                    ans.clear();\\n                    ans.push_back(list2[i]);\\n                }\\n                else if(mp1[list2[i]]+i == mini){\\n                    ans.push_back(list2[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1468964,
                "title": "c-simle-map-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string>ans;\\n        int max_sum=list1.size()+list2.size();\\n        unordered_map<string, int>um1;\\n        unordered_map<string, int>um2;\\n\\n        for(int i=0;i<list1.size();i++){\\n            um1[list1[i]]=i;\\n        }\\n        for(int i=0;i<list2.size();i++){\\n            um2[list2[i]]=i;\\n        }\\n        for(auto it:list1) {\\n            if(um2.count(it) > 0 && um1[it]+um2[it] < max_sum)\\n                max_sum = um1[it]+um2[it];\\n        }\\n        for(auto it:list1) {\\n            if(um2.count(it) > 0 && um1[it]+um2[it] == max_sum)\\n                ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string>ans;\\n        int max_sum=list1.size()+list2.size();\\n        unordered_map<string, int>um1;\\n        unordered_map<string, int>um2;\\n\\n        for(int i=0;i<list1.size();i++){\\n            um1[list1[i]]=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1386168,
                "title": "succinct-solution-in-python",
                "content": "Succinct solution in Python:\\n\\n```\\nclass Solution:\\n\\tdef findRestaurant(self, list1: [str], list2: [str]) -> [str]:\\n\\t\\tcommon_restaurants = set(list1) & set(list2)\\n\\t\\tcommon_restaurant_index = {common_restaurant: list1.index(common_restaurant) + list2.index(common_restaurant) for common_restaurant in common_restaurants}\\n\\t\\tleast_index_sum = min(dict.values(common_restaurant_index))\\n\\t\\treturn [common_restaurant for common_restaurant in common_restaurants if common_restaurant_index[common_restaurant] == least_index_sum]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef findRestaurant(self, list1: [str], list2: [str]) -> [str]:\\n\\t\\tcommon_restaurants = set(list1) & set(list2)\\n\\t\\tcommon_restaurant_index = {common_restaurant: list1.index(common_restaurant) + list2.index(common_restaurant) for common_restaurant in common_restaurants}\\n\\t\\tleast_index_sum = min(dict.values(common_restaurant_index))\\n\\t\\treturn [common_restaurant for common_restaurant in common_restaurants if common_restaurant_index[common_restaurant] == least_index_sum]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385367,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public String[] findRestaurant(String[] l1, String[] l2) {\\n        HashMap<String,Integer> nm=new HashMap<>();\\n        int i,j=Integer.MAX_VALUE;\\n        List<String> kk = new ArrayList<>();\\n        for(i=0;i<l1.length;i++)\\n        {\\n            nm.put(l1[i],i);\\n        }\\n        for(i=0;i<l2.length;i++)\\n        {\\n            if(nm.containsKey(l2[i]))\\n            {\\n                int k=nm.get(l2[i])+i;\\n                if(k==j)\\n                {\\n                   kk.add(l2[i]); \\n                }\\n                else if(j>k)\\n                {\\n                    if(j!=Integer.MAX_VALUE)\\n                    {\\n                        kk.clear();\\n                    }\\n                    kk.add(l2[i]);\\n                    j=k;\\n                }\\n            }\\n        }\\n        String a[]=new String[kk.size()];\\n        a=kk.toArray(a);\\n        return a;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public String[] findRestaurant(String[] l1, String[] l2) {\\n        HashMap<String,Integer> nm=new HashMap<>();\\n        int i,j=Integer.MAX_VALUE;\\n        List<String> kk = new ArrayList<>();\\n        for(i=0;i<l1.length;i++)\\n        {\\n            nm.put(l1[i],i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1369025,
                "title": "simple-java-solution-with-hashmap",
                "content": "```\\npublic String[] findRestaurant(String[] list1, String[] list2) \\n{\\n        HashMap<String, Integer> hashMap = new HashMap<>(); \\n        List<String> res = new ArrayList<>();\\n        int distance  = Integer.MAX_VALUE;\\n        for (int i=0; i<list1.length; ++i)\\n        {\\n            hashMap.put(list1[i], i);\\n        }\\n        for (int i=0; i< list2.length; ++i)\\n        {\\n            if (hashMap.containsKey(list2[i]))\\n            {\\n                Integer tempDistance = hashMap.get(list2[i]) + i;\\n                if (distance == tempDistance)\\n                {\\n                    res.add(list2[i]);\\n                }\\n                else if (distance > tempDistance)\\n                {\\n                  \\n                    if (distance != Integer.MAX_VALUE) \\n                    {\\n                        res.clear();\\n                    }\\n                    res.add(list2[i]);\\n                    distance = tempDistance;\\n                }\\n            }\\n        }\\n        String[] resArray = new String[res.size()];\\n        resArray = res.toArray(resArray);\\n        return resArray;\\n\\t}",
                "solutionTags": [],
                "code": "```\\npublic String[] findRestaurant(String[] list1, String[] list2) \\n{\\n        HashMap<String, Integer> hashMap = new HashMap<>(); \\n        List<String> res = new ArrayList<>();\\n        int distance  = Integer.MAX_VALUE;\\n        for (int i=0; i<list1.length; ++i)\\n        {\\n            hashMap.put(list1[i], i);\\n        }\\n        for (int i=0; i< list2.length; ++i)\\n        {\\n            if (hashMap.containsKey(list2[i]))\\n            {\\n                Integer tempDistance = hashMap.get(list2[i]) + i;\\n                if (distance == tempDistance)\\n                {\\n                    res.add(list2[i]);\\n                }\\n                else if (distance > tempDistance)\\n                {\\n                  \\n                    if (distance != Integer.MAX_VALUE) \\n                    {\\n                        res.clear();\\n                    }\\n                    res.add(list2[i]);\\n                    distance = tempDistance;\\n                }\\n            }\\n        }\\n        String[] resArray = new String[res.size()];\\n        resArray = res.toArray(resArray);\\n        return resArray;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1362800,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        mapl1 = {each : i for i, each in enumerate(list1)}\\n        temp = {}\\n        low = (len(list1) + len(list2))-1\\n        for i, each in enumerate(list2):\\n          if each in mapl1.keys():\\n              val = mapl1[each]\\n              if val+i < low:\\n                low = val+i\\n                temp.clear()\\n                temp[each] = val + i\\n              elif low == val+i:\\n                low = val+i\\n                temp[each] = val + i\\n        \\n        return temp.keys()\\n        \\n        \\n  ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        mapl1 = {each : i for i, each in enumerate(list1)}\\n        temp = {}\\n        low = (len(list1) + len(list2))-1\\n        for i, each in enumerate(list2):\\n          if each in mapl1.keys():\\n              val = mapl1[each]\\n              if val+i < low:\\n                low = val+i\\n                temp.clear()\\n                temp[each] = val + i\\n              elif low == val+i:\\n                low = val+i\\n                temp[each] = val + i\\n        \\n        return temp.keys()\\n        \\n        \\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 1332999,
                "title": "using-maps-c-solution",
                "content": "```\\n vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        \\n        map<string,int> mp1,mp2;\\n        \\n        for(int i=0;i<list1.size();i++){\\n            mp1[list1[i]]=i;\\n        }\\n        \\n        for(int i=0;i<list2.size();i++){\\n            mp2[list2[i]]=i;\\n        }\\n        \\n        vector<pair<int,string>> v;\\n        \\n        for(auto x: mp1){\\n            if(mp2.find(x.first)!=mp2.end()){\\n                v.push_back({mp1[x.first]  + mp2[x.first] , x.first});\\n            }\\n        }\\n    \\n        sort(v.begin(),v.end());\\n        \\n        int check=v[0].first;\\n        \\n        vector<string> ans;\\n        for(auto x: v){\\n            if(x.first==check){\\n                ans.push_back(x.second);\\n            }\\n        }\\n        return ans;\\n            \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        \\n        map<string,int> mp1,mp2;\\n        \\n        for(int i=0;i<list1.size();i++){\\n            mp1[list1[i]]=i;\\n        }\\n        \\n        for(int i=0;i<list2.size();i++){\\n            mp2[list2[i]]=i;\\n        }\\n        \\n        vector<pair<int,string>> v;\\n        \\n        for(auto x: mp1){\\n            if(mp2.find(x.first)!=mp2.end()){\\n                v.push_back({mp1[x.first]  + mp2[x.first] , x.first});\\n            }\\n        }\\n    \\n        sort(v.begin(),v.end());\\n        \\n        int check=v[0].first;\\n        \\n        vector<string> ans;\\n        for(auto x: v){\\n            if(x.first==check){\\n                ans.push_back(x.second);\\n            }\\n        }\\n        return ans;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1303525,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        a,b = set(list1), set(list2)\\n        c = a.intersection(b)\\n        # print(c)\\n        minindex = 10000\\n        ans = []\\n        for i in c:\\n            chk = list1.index(i)+list2.index(i)\\n            if (chk) < minindex:\\n                minindex = chk\\n                ans = [i]\\n            elif (chk) ==  minindex:\\n                minindex = chk\\n                ans.append(i)\\n                \\n        return (ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        a,b = set(list1), set(list2)\\n        c = a.intersection(b)\\n        # print(c)\\n        minindex = 10000\\n        ans = []\\n        for i in c:\\n            chk = list1.index(i)+list2.index(i)\\n            if (chk) < minindex:\\n                minindex = chk\\n                ans = [i]\\n            elif (chk) ==  minindex:\\n                minindex = chk\\n                ans.append(i)\\n                \\n        return (ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276388,
                "title": "simple-javascript-o-n-solution-99-faster",
                "content": "Runtime: 92 ms, faster than 99.53% of JavaScript online submissions for Minimum Index Sum of Two Lists.\\nMemory Usage: 45.8 MB, less than 71.70% of JavaScript online submissions for Minimum Index Sum of Two Lists.\\n```\\n/**\\n * @param {string[]} list1\\n * @param {string[]} list2\\n * @return {string[]}\\n */\\nvar findRestaurant = function(list1, list2) {\\n    const re1 = new Map()\\n    const common = []\\n    for (let i = 0; i < list1.length; i++) {\\n        re1.set(list1[i], i)\\n    }\\n    let min = Infinity\\n    for (let i = 0; i < list2.length; i++) {\\n        if (re1.has(list2[i])) {\\n            const sum = i + re1.get(list2[i])\\n            min = Math.min(min, sum)\\n            common.push({\\n                name: list2[i],\\n                sum\\n            })   \\n        }\\n    }\\n    \\n    return common.filter(val => val.sum === min).map(val => val.name)\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} list1\\n * @param {string[]} list2\\n * @return {string[]}\\n */\\nvar findRestaurant = function(list1, list2) {\\n    const re1 = new Map()\\n    const common = []\\n    for (let i = 0; i < list1.length; i++) {\\n        re1.set(list1[i], i)\\n    }\\n    let min = Infinity\\n    for (let i = 0; i < list2.length; i++) {\\n        if (re1.has(list2[i])) {\\n            const sum = i + re1.get(list2[i])\\n            min = Math.min(min, sum)\\n            common.push({\\n                name: list2[i],\\n                sum\\n            })   \\n        }\\n    }\\n    \\n    return common.filter(val => val.sum === min).map(val => val.name)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1269858,
                "title": "golang-o-n-m-o-n-solution",
                "content": "``` go\\nfunc findRestaurant(list1 []string, list2 []string) []string {\\n\\tm := make(map[string]int)\\n\\tres := []string{}\\n\\tminimum := 2001\\n\\n\\tfor i, s := range list1 {\\n\\t\\tm[s] = i\\n\\t}\\n\\n\\tfor i, s := range list2 {\\n\\t\\tif _, ok := m[s]; ok {\\n\\t\\t\\tindexSum := m[s] + i\\n\\t\\t\\tif indexSum < minimum {\\n\\t\\t\\t\\tminimum = indexSum\\n\\t\\t\\t\\tres = []string{s}\\n\\t\\t\\t} else if indexSum == minimum {\\n\\t\\t\\t\\tres = append(res, s)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc findRestaurant(list1 []string, list2 []string) []string {\\n\\tm := make(map[string]int)\\n\\tres := []string{}\\n\\tminimum := 2001\\n\\n\\tfor i, s := range list1 {\\n\\t\\tm[s] = i\\n\\t}\\n\\n\\tfor i, s := range list2 {\\n\\t\\tif _, ok := m[s]; ok {\\n\\t\\t\\tindexSum := m[s] + i\\n\\t\\t\\tif indexSum < minimum {\\n\\t\\t\\t\\tminimum = indexSum\\n\\t\\t\\t\\tres = []string{s}\\n\\t\\t\\t} else if indexSum == minimum {\\n\\t\\t\\t\\tres = append(res, s)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1201351,
                "title": "problem-599-easy-c-solution-with-explanations",
                "content": "### Solution\\n\\nMy first idea was to use a map. That\\'s because a map has 2 properties that are very useful in this problem: fast membership checking and key-value pairs. We\\'ll use the first one to check if a restaurant is shared by both lists. We\\'ll use the second property to find the index of shared restaurants.\\n\\nIt\\'s pretty straightforward. Make a map of restaurant names to indexes for one of the lists. Go through the other list and for each restaurant, check if it was present in the other list. If it was, add the restaurant and the sum of indexes to a new list.\\n\\nFinally, go through and find the restaurants with the minimum sum.\\n\\n```cpp\\nvector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n  // go through list 1, make a map from name to index\\n  unordered_map<string, int> name_ind_map;\\n  for (int i = 0; i < list1.size(); i++) {\\n    name_ind_map[list1[i]] = i;\\n  }\\n\\n  int min_sum = INT_MAX;\\n  vector<string> ans;\\n  for (int i = 0; i < list2.size(); i++) {\\n    auto restau_l1 = name_ind_map.find(list2[i]);\\n    if (restau_l1 != name_ind_map.end()) { // the restaurant was also in list 1\\n      int curr_ind_sum = i + restau_l1->second;\\n      if (curr_ind_sum < min_sum) {\\n        min_sum = curr_ind_sum;\\n        ans.clear();\\n        ans.push_back(list2[i]);\\n      } else if (curr_ind_sum == min_sum) {\\n        ans.push_back(list2[i]);\\n      }\\n    }\\n  }\\n\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nvector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n  // go through list 1, make a map from name to index\\n  unordered_map<string, int> name_ind_map;\\n  for (int i = 0; i < list1.size(); i++) {\\n    name_ind_map[list1[i]] = i;\\n  }\\n\\n  int min_sum = INT_MAX;\\n  vector<string> ans;\\n  for (int i = 0; i < list2.size(); i++) {\\n    auto restau_l1 = name_ind_map.find(list2[i]);\\n    if (restau_l1 != name_ind_map.end()) { // the restaurant was also in list 1\\n      int curr_ind_sum = i + restau_l1->second;\\n      if (curr_ind_sum < min_sum) {\\n        min_sum = curr_ind_sum;\\n        ans.clear();\\n        ans.push_back(list2[i]);\\n      } else if (curr_ind_sum == min_sum) {\\n        ans.push_back(list2[i]);\\n      }\\n    }\\n  }\\n\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1196479,
                "title": "python-two-dictionary-solution-easy",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        def defval():\\n            return []\\n        \\n        cache = {}\\n        output= defaultdict(defval)\\n        \\n        for i in range(len(list1)):\\n            cache[list1[i]]=i\\n        \\n        for i in range(len(list2)):\\n            if list2[i] in cache:\\n                output[cache[list2[i]]+i].append(list2[i])\\n        \\n        return output[min(output)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        def defval():\\n            return []\\n        \\n        cache = {}\\n        output= defaultdict(defval)\\n        \\n        for i in range(len(list1)):\\n            cache[list1[i]]=i\\n        \\n        for i in range(len(list2)):\\n            if list2[i] in cache:\\n                output[cache[list2[i]]+i].append(list2[i])\\n        \\n        return output[min(output)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183624,
                "title": "c-44ms-hashmap-based-solution-explained-100-time-70-space",
                "content": "Neat one: given the maximum size of the input, it might be tempting to brute force it in quadratic time for a quick and dirty solution.\\n\\nBut we can do better, can\\'t we?\\n\\nWe will start declaring 2 support variables:\\n* `res` is going to be our usual accumulator variable to store our matches as we go;\\n* `m` is going to be a map where we store the position of each restaurant in `list1`.\\n\\nAnd populating `m` is indeed our first step, with a trivial parse of `list1`.\\n\\nParsing `list2` comes next, with some more magic involved. We will iterate with `i` all the elements and for each one of them, after also declaring the support variables `rank` and `minV`, with the latter initialised to be `INT_MAX`:\\n* assign the pointer of the position of the current element (`list2[i]`) in `m` to `prev`;\\n* if `prev` tells us such element was not seen before (`== end(m)`), we can just `continue`;\\n* otherwise, we can compute `rank` as the sum of the previous index (`prev->second`) and the current one (`i`);\\n* we consider now 2 possible scenarios:\\n\\t* if `miinV == rank`, then it means we have found another value with the same priority as the ones we found before and thus just push `list2[i]` into `res`;\\n\\t* if `miinV > rank`, then it means we have found a higher priority, so we:\\n\\t\\t* reset `res` to contain only `list2[i]`;\\n\\t\\t* update `minV` to be `rank`;\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        // support variables\\n        vector<string> res;\\n        unordered_map<string, int> m;\\n        // parsing list1\\n        for (int i = 0, lmt = list1.size(); i < lmt; i++) m[list1[i]] = i;\\n        // parsing list2\\n        for (int i = 0, lmt = list2.size(), rank, minV = INT_MAX; i < lmt; i++) {\\n            // checking if list2[i] was found before\\n            auto prev = m.find(list2[i]);\\n            if (prev == end(m)) continue;\\n            // computing the current rank\\n            rank = prev->second + i;\\n            // updating res accordingly\\n            if (minV == rank) res.push_back(list2[i]);\\n            else if (minV > rank) {\\n                res = {list2[i]};\\n                minV = rank;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        // support variables\\n        vector<string> res;\\n        unordered_map<string, int> m;\\n        // parsing list1\\n        for (int i = 0, lmt = list1.size(); i < lmt; i++) m[list1[i]] = i;\\n        // parsing list2\\n        for (int i = 0, lmt = list2.size(), rank, minV = INT_MAX; i < lmt; i++) {\\n            // checking if list2[i] was found before\\n            auto prev = m.find(list2[i]);\\n            if (prev == end(m)) continue;\\n            // computing the current rank\\n            rank = prev->second + i;\\n            // updating res accordingly\\n            if (minV == rank) res.push_back(list2[i]);\\n            else if (minV > rank) {\\n                res = {list2[i]};\\n                minV = rank;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177349,
                "title": "c-fast-solution",
                "content": "***Do upvote if you found it helpful to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n***Explanation in the comments section***\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string,int> u1;\\n        int i , curr_sum , min_sum = INT_MAX;\\n        vector<string> v;\\n        for(i=0 ; i < list1.size() ; i++)\\n        {\\n            u1[list1[i]] = i; \\n        }\\n        for(i=0 ; i < list2.size() ; i++)\\n        {\\n            if(u1.find(list2[i])!=u1.end())\\n            {\\n                curr_sum = u1[list2[i]] + i; \\n                if(curr_sum < min_sum) \\n                {\\n                    min_sum = curr_sum;\\n                    v.clear();\\n                    v.push_back(list2[i]);\\n                }\\n                else if(min_sum == curr_sum)\\n                    v.push_back(list2[i]); \\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        unordered_map<string,int> u1;\\n        int i , curr_sum , min_sum = INT_MAX;\\n        vector<string> v;\\n        for(i=0 ; i < list1.size() ; i++)\\n        {\\n            u1[list1[i]] = i; \\n        }\\n        for(i=0 ; i < list2.size() ; i++)\\n        {\\n            if(u1.find(list2[i])!=u1.end())\\n            {\\n                curr_sum = u1[list2[i]] + i; \\n                if(curr_sum < min_sum) \\n                {\\n                    min_sum = curr_sum;\\n                    v.clear();\\n                    v.push_back(list2[i]);\\n                }\\n                else if(min_sum == curr_sum)\\n                    v.push_back(list2[i]); \\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159237,
                "title": "python3",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        map=defaultdict(list)\\n        for i in range(len(list1)):\\n            if list1[i] in list2:\\n                if map[i+list2.index(list1[i])]:\\n                    map[i+list2.index(list1[i])].append(list1[i])\\n                else:\\n                    map[i+list2.index(list1[i])]=[list1[i]]\\n        arr=list(sorted(map.keys()))\\n        return map[min(arr)]",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        map=defaultdict(list)\\n        for i in range(len(list1)):\\n            if list1[i] in list2:\\n                if map[i+list2.index(list1[i])]:\\n                    map[i+list2.index(list1[i])].append(list1[i])\\n                else:\\n                    map[i+list2.index(list1[i])]=[list1[i]]\\n        arr=list(sorted(map.keys()))\\n        return map[min(arr)]",
                "codeTag": "Java"
            },
            {
                "id": 1148750,
                "title": "rust-functional-approach",
                "content": "Avoiding chaning state by using `iter` and `collect` .\\n\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn find_restaurant(list1: Vec<String>, list2: Vec<String>) -> Vec<String> {\\n        let m1: HashMap<&String, usize> = list1.iter().enumerate().map(|(x, y)| (y, x)).collect();\\n\\n        let result: Vec<(usize, &String)> = list2\\n            .iter()\\n            .enumerate()\\n            .flat_map(|(l2_pos, rest)| {\\n                m1.get(rest)\\n                    .map(|l1_pos| (l1_pos + l2_pos, rest))\\n                    .into_iter()\\n            })\\n            .collect();\\n\\n        match result.iter().map(|(pos, _)| pos).min() {\\n            Some(&min) => result\\n                .iter()\\n                .filter(|&&(pos, _)| pos == min)\\n                .map(|&(_, rest)| String::from(rest))\\n                .collect(),\\n            None => vec![],\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn find_restaurant(list1: Vec<String>, list2: Vec<String>) -> Vec<String> {\\n        let m1: HashMap<&String, usize> = list1.iter().enumerate().map(|(x, y)| (y, x)).collect();\\n\\n        let result: Vec<(usize, &String)> = list2\\n            .iter()\\n            .enumerate()\\n            .flat_map(|(l2_pos, rest)| {\\n                m1.get(rest)\\n                    .map(|l1_pos| (l1_pos + l2_pos, rest))\\n                    .into_iter()\\n            })\\n            .collect();\\n\\n        match result.iter().map(|(pos, _)| pos).min() {\\n            Some(&min) => result\\n                .iter()\\n                .filter(|&&(pos, _)| pos == min)\\n                .map(|&(_, rest)| String::from(rest))\\n                .collect(),\\n            None => vec![],\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1124504,
                "title": "java-soln-with-6ms-run-time",
                "content": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i=0;i<list1.length;i++){\\n            map.put(list1[i],i);\\n        }\\n        List<String> result = new LinkedList<>();\\n        int minSum = Integer.MAX_VALUE;\\n        for(int j=0;j<list2.length;j++){\\n            Integer k= map.get(list2[j]);\\n            if(k!=null && k+j<=minSum){\\n                if(k+j<minSum){\\n                    result.clear();\\n                    minSum=k+j;\\n                }\\n                result.add(list2[j]);\\n            }\\n        }\\n        return result.toArray(new String[result.size()]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i=0;i<list1.length;i++){\\n            map.put(list1[i],i);\\n        }\\n        List<String> result = new LinkedList<>();\\n        int minSum = Integer.MAX_VALUE;\\n        for(int j=0;j<list2.length;j++){\\n            Integer k= map.get(list2[j]);\\n            if(k!=null && k+j<=minSum){\\n                if(k+j<minSum){\\n                    result.clear();\\n                    minSum=k+j;\\n                }\\n                result.add(list2[j]);\\n            }\\n        }\\n        return result.toArray(new String[result.size()]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101445,
                "title": "scala-hashmap-beats-100-recursive",
                "content": "```\\n  def findRestaurant(list1: Array[String], list2: Array[String]): Array[String] = {\\n    val map = list1.zipWithIndex.toMap\\n    def go(acc: List[String], i: Int, arr: Array[String], min: Int): Array[String] = {\\n      if (i == arr.length) acc.toArray\\n      else {\\n        map\\n          .get(arr(i))\\n          .fold {\\n            go(acc, i + 1, arr, min)\\n          } { j =>\\n            val newMin = i + j\\n            if (newMin < min) go(List(arr(i)), i + 1, arr, newMin)\\n            else if (newMin == min) go(acc :+ arr(i), i + 1, arr, min)\\n            else go(acc, i + 1, arr, min)\\n          }\\n      }\\n    }\\n\\n    go(Nil, 0, list2, Int.MaxValue)\\n  }\\n  ```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```\\n  def findRestaurant(list1: Array[String], list2: Array[String]): Array[String] = {\\n    val map = list1.zipWithIndex.toMap\\n    def go(acc: List[String], i: Int, arr: Array[String], min: Int): Array[String] = {\\n      if (i == arr.length) acc.toArray\\n      else {\\n        map\\n          .get(arr(i))\\n          .fold {\\n            go(acc, i + 1, arr, min)\\n          } { j =>\\n            val newMin = i + j\\n            if (newMin < min) go(List(arr(i)), i + 1, arr, newMin)\\n            else if (newMin == min) go(acc :+ arr(i), i + 1, arr, min)\\n            else go(acc, i + 1, arr, min)\\n          }\\n      }\\n    }\\n\\n    go(Nil, 0, list2, Int.MaxValue)\\n  }\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 1056857,
                "title": "python-100-ms-beat-100-first-time",
                "content": "```\\nclass Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def s1(l1,l2):\\n            d = {}\\n            re = []\\n            for index, val in enumerate(l1):\\n                d[val] = index\\n            for index,val in enumerate(l2):\\n                if val in d: re.append([val, index + d[val]])\\n            min_index = min(x[1] for x in re )\\n            re =[ x[0] for x in re if x[1]== min_index]\\n            return re\\n        \\n        return s1(list1,list2)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def findRestaurant(self, list1, list2):\\n        \"\"\"\\n        :type list1: List[str]\\n        :type list2: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def s1(l1,l2):\\n            d = {}",
                "codeTag": "Java"
            },
            {
                "id": 1038853,
                "title": "fast-and-simple-c",
                "content": "```\\nvector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n\\tunordered_map<string,int> hashmap;\\n\\tfor(int i=0;i<list1.size();i++)\\n\\t{\\n\\t\\thashmap[list1[i]]=i;\\n\\t}\\n\\tvector<string> res;\\n\\tint mini=INT_MAX;\\n\\tfor(int i=0;i<list2.size();i++)\\n\\t{\\n\\t\\tif(hashmap.find(list2[i])!=hashmap.end())\\n\\t\\t{\\n\\t\\t\\tif(i+hashmap[list2[i]]<mini)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres.clear();\\n\\t\\t\\t\\tmini=i+hashmap[list2[i]];\\n\\t\\t\\t\\tres.push_back(list2[i]);\\n\\t\\t\\t}\\n\\t\\t\\telse if(mini==i+hashmap[list2[i]])\\n\\t\\t\\t{\\n\\t\\t\\t\\tres.push_back(list2[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n\\tunordered_map<string,int> hashmap;\\n\\tfor(int i=0;i<list1.size();i++)\\n\\t{\\n\\t\\thashmap[list1[i]]=i;\\n\\t}\\n\\tvector<string> res;\\n\\tint mini=INT_MAX;\\n\\tfor(int i=0;i<list2.size();i++)\\n\\t{\\n\\t\\tif(hashmap.find(list2[i])!=hashmap.end())\\n\\t\\t{\\n\\t\\t\\tif(i+hashmap[list2[i]]<mini)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres.clear();\\n\\t\\t\\t\\tmini=i+hashmap[list2[i]];\\n\\t\\t\\t\\tres.push_back(list2[i]);\\n\\t\\t\\t}\\n\\t\\t\\telse if(mini==i+hashmap[list2[i]])\\n\\t\\t\\t{\\n\\t\\t\\t\\tres.push_back(list2[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 903063,
                "title": "java-beats-95-hashmap-easy-to-understand",
                "content": "// Time (m+n) \\n// Space (m) | size of the hashMap \\n// where m is the length of list1, n is the length of list2\\n\\n```\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\n\\tList<String> res = new ArrayList<>();\\n\\tMap<String, Integer> map = new HashMap<>(); // {name : index}\\n\\tint minIndexSum = Integer.MAX_VALUE;\\n\\n\\t// Loop through list1, fill the hashMap with list1 items\\n\\tfor (int i = 0; i < list1.length; i++) {\\n\\t\\tmap.put(list1[i], i);\\n\\t}\\n\\n\\t// Loop through list2\\n\\tfor (int i = 0; i < list2.length; i++) {\\n\\t\\tif (map.containsKey(list2[i])) { // Note: time complexity for map.containsKey() is assumed to be O(1) here\\n\\t\\t\\tint sum = map.get(list2[i]) + i;\\n\\n\\t\\t\\tif (sum < minIndexSum) {\\n\\t\\t\\t\\tminIndexSum = sum;\\n\\t\\t\\t\\tres.clear();\\n\\t\\t\\t\\tres.add(list2[i]);\\n\\t\\t\\t} else if (minIndexSum == sum) {\\n\\t\\t\\t\\tres.add(list2[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tString[] ans = res.toArray(new String[res.size()]);\\n\\treturn ans;\\n}\\n```\\n\\n\\nA question here, is\\n\\n\\t\\t\\tif (sum <= minIndexSum) {\\n\\t\\t\\t\\tif (sum < minIndexSum) {\\n\\t\\t\\t\\t\\tminIndexSum = sum;\\n\\t\\t\\t\\t\\tres.clear();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres.add(list2[i]);\\n\\t\\t\\t}\\nbetter, or \\n\\n\\t\\t\\tif (sum < minIndexSum) {\\n\\t\\t\\t\\tminIndexSum = sum;\\n\\t\\t\\t\\tres.clear();\\n\\t\\t\\t\\tres.add(list2[i]);\\n\\t\\t\\t} else if (minIndexSum == sum) {\\n\\t\\t\\t\\tres.add(list2[i]);\\n\\t\\t\\t}\\n\\nbetter? :)",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\n\\tList<String> res = new ArrayList<>();\\n\\tMap<String, Integer> map = new HashMap<>(); // {name : index}\\n\\tint minIndexSum = Integer.MAX_VALUE;\\n\\n\\t// Loop through list1, fill the hashMap with list1 items\\n\\tfor (int i = 0; i < list1.length; i++) {\\n\\t\\tmap.put(list1[i], i);\\n\\t}\\n\\n\\t// Loop through list2\\n\\tfor (int i = 0; i < list2.length; i++) {\\n\\t\\tif (map.containsKey(list2[i])) { // Note: time complexity for map.containsKey() is assumed to be O(1) here\\n\\t\\t\\tint sum = map.get(list2[i]) + i;\\n\\n\\t\\t\\tif (sum < minIndexSum) {\\n\\t\\t\\t\\tminIndexSum = sum;\\n\\t\\t\\t\\tres.clear();\\n\\t\\t\\t\\tres.add(list2[i]);\\n\\t\\t\\t} else if (minIndexSum == sum) {\\n\\t\\t\\t\\tres.add(list2[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tString[] ans = res.toArray(new String[res.size()]);\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 901330,
                "title": "c-hashmap-solution-with-documentation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector <string> ans;\\n        // Using hashmap or unordered_map because we also have to take care of index sum\\n        unordered_map <string, int> umap;\\n        int minSum = INT_MAX;\\n        \\n        // looping through the first list and pushing all values and index to hashmap\\n        for(int i=0; i<list1.size(); i++)\\n            umap[list1[i]] = i;\\n        \\n        // finding if both list have anything in common and have least index sum\\n        for(int i=0; i<list2.size(); i++)\\n        {\\n            // if element in common in lists\\n            if(umap.find(list2[i]) != umap.end())\\n            {\\n                // finding sum of index if element is common\\n                int sum = i + umap[list2[i]];\\n                // if we found new minimum, we clear the answer array as new minSum is present\\n                if(sum < minSum)\\n                    ans.clear();\\n                // if sum is same or less than minmum index, push it and assign minSum to sum\\n                if(sum <= minSum)\\n                {\\n                    ans.push_back(list2[i]);\\n                    minSum = sum;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector <string> ans;\\n        // Using hashmap or unordered_map because we also have to take care of index sum\\n        unordered_map <string, int> umap;\\n        int minSum = INT_MAX;\\n        \\n        // looping through the first list and pushing all values and index to hashmap\\n        for(int i=0; i<list1.size(); i++)\\n            umap[list1[i]] = i;\\n        \\n        // finding if both list have anything in common and have least index sum\\n        for(int i=0; i<list2.size(); i++)\\n        {\\n            // if element in common in lists\\n            if(umap.find(list2[i]) != umap.end())\\n            {\\n                // finding sum of index if element is common\\n                int sum = i + umap[list2[i]];\\n                // if we found new minimum, we clear the answer array as new minSum is present\\n                if(sum < minSum)\\n                    ans.clear();\\n                // if sum is same or less than minmum index, push it and assign minSum to sum\\n                if(sum <= minSum)\\n                {\\n                    ans.push_back(list2[i]);\\n                    minSum = sum;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892494,
                "title": "simple-c-o-n-beats-90",
                "content": "\\tvector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        if(list1.size()==0||list2.size()==0)\\n            return {};\\n        vector<string> S;\\n        unordered_map<string,int> hashmap;\\n        int min=INT_MAX,index=0;\\n        for(int i=0;i<list1.size();i++)\\n        {\\n            hashmap[list1[i]]=i+1;\\n        }\\n        for(int i=0;i<list2.size();i++)\\n        {\\n            if(hashmap[list2[i]])\\n            {\\n                index=hashmap[list2[i]]+i+1;\\n                if(index<min)\\n                {\\n                    min=index;\\n                    S.clear();\\n                    S.push_back(list2[i]);\\n                }\\n                else if(index==min)\\n                {\\n                    S.push_back(list2[i]);\\n                }\\n            }\\n        }      \\n        return S;\\n    }",
                "solutionTags": [],
                "code": "\\tvector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        if(list1.size()==0||list2.size()==0)\\n            return {};\\n        vector<string> S;\\n        unordered_map<string,int> hashmap;\\n        int min=INT_MAX,index=0;\\n        for(int i=0;i<list1.size();i++)\\n        {\\n            hashmap[list1[i]]=i+1;\\n        }\\n        for(int i=0;i<list2.size();i++)\\n        {\\n            if(hashmap[list2[i]])\\n            {\\n                index=hashmap[list2[i]]+i+1;\\n                if(index<min)\\n                {\\n                    min=index;\\n                    S.clear();\\n                    S.push_back(list2[i]);\\n                }\\n                else if(index==min)\\n                {\\n                    S.push_back(list2[i]);\\n                }\\n            }\\n        }      \\n        return S;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 888763,
                "title": "rust-8ms-solution-100",
                "content": "*O(l1+l2)* complexity, *O(min(l1, l2))* space.\\nNever allocates space for strings, only for map and result vec.\\n```\\nimpl Solution {\\n    pub fn find_restaurant(list1: Vec<String>, list2: Vec<String>) -> Vec<String> {\\n        \\n        let (list1, list2) = if list1.len() < list2.len(){\\n            (list1, list2)\\n        }\\n        else{\\n            (list2, list1)\\n        };\\n        \\n        use std::collections::HashMap;\\n        let l1map: HashMap<_, _> = list1\\n                .into_iter()\\n                .enumerate()\\n                .map(|(i,v)|(v,i))\\n                .collect();\\n        let mut minimum = std::usize::MAX;\\n        let mut results = Vec::new();\\n        for (idx2, place) in list2.into_iter().enumerate(){\\n            if idx2 > minimum{\\n                break;\\n            }\\n            if let Some(idx1) = l1map.get(&place){\\n                use std::cmp::Ordering;\\n                \\n                let sum = idx1 + idx2;\\n                match sum.cmp(&minimum){\\n                    Ordering::Less=>{\\n                        minimum = sum;\\n                        results.clear();\\n                        results.push(place);\\n                    },\\n                    Ordering::Equal=>results.push(place),\\n                    _ =>{},\\n                }\\n            }\\n        }\\n        results\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn find_restaurant(list1: Vec<String>, list2: Vec<String>) -> Vec<String> {\\n        \\n        let (list1, list2) = if list1.len() < list2.len(){\\n            (list1, list2)\\n        }\\n        else{\\n            (list2, list1)\\n        };\\n        \\n        use std::collections::HashMap;\\n        let l1map: HashMap<_, _> = list1\\n                .into_iter()\\n                .enumerate()\\n                .map(|(i,v)|(v,i))\\n                .collect();\\n        let mut minimum = std::usize::MAX;\\n        let mut results = Vec::new();\\n        for (idx2, place) in list2.into_iter().enumerate(){\\n            if idx2 > minimum{\\n                break;\\n            }\\n            if let Some(idx1) = l1map.get(&place){\\n                use std::cmp::Ordering;\\n                \\n                let sum = idx1 + idx2;\\n                match sum.cmp(&minimum){\\n                    Ordering::Less=>{\\n                        minimum = sum;\\n                        results.clear();\\n                        results.push(place);\\n                    },\\n                    Ordering::Equal=>results.push(place),\\n                    _ =>{},\\n                }\\n            }\\n        }\\n        results\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 819707,
                "title": "clean-python-high-speed-set-matching",
                "content": "**Clean Python | High Speed | Set Matching**\\n\\nClean Python Solution using HashMaps and HashSets to find the answer with Linear Time/Space complexity. It\\'s a nice way to see the problem. I thought in posting since the last official solution was only for Java. Enjoy,\\n\\n```\\nclass Solution:\\n    def findRestaurant(self, A,B):\\n        d = defaultdict(int)\\n        for X,Y in [[A,set(B)],[B,set(A)]]:\\n            for i,a in enumerate(X):\\n                if a in Y:\\n                    d[a] += i\\n        m = min(d.values())\\n        return [ k for k,v in d.items() if v==m ]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, A,B):\\n        d = defaultdict(int)\\n        for X,Y in [[A,set(B)],[B,set(A)]]:\\n            for i,a in enumerate(X):\\n                if a in Y:\\n                    d[a] += i\\n        m = min(d.values())\\n        return [ k for k,v in d.items() if v==m ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763194,
                "title": "python-very-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        res = {}\\n        ans = []\\n        for i,word in enumerate(list1):\\n            for j, cha in enumerate(list2):\\n                # print(word,cha,i,j,i+j,word==cha)\\n                if word == cha:\\n                    res[word] = i+j\\n        minn = min(res.values())\\n        for key,value in res.items():\\n            if value == minn:\\n                ans.append(key)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        res = {}\\n        ans = []\\n        for i,word in enumerate(list1):\\n            for j, cha in enumerate(list2):\\n                # print(word,cha,i,j,i+j,word==cha)\\n                if word == cha:\\n                    res[word] = i+j\\n        minn = min(res.values())\\n        for key,value in res.items():\\n            if value == minn:\\n                ans.append(key)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753634,
                "title": "easy-acc-java-solution",
                "content": "```\\n public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String,Integer> map = new HashMap<>();\\n        List<String> ls = new ArrayList<>();\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int i =0;i<list1.length;i++){\\n            map.put(list1[i],i);\\n        }\\n        \\n        for(int i =0;i<list2.length;i++){\\n            if(map.containsKey(list2[i])){\\n                if(min > i+map.get(list2[i])){\\n                    min = Math.min(min, i + map.get(list2[i]));\\n                    ls.clear();\\n                    ls.add(list2[i]);\\n                    \\n                }else if(min == i + map.get(list2[i])){\\n                    ls.add(list2[i]);\\n                }\\n            }\\n        }\\n        \\n        return ls.toArray(new String[0]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String,Integer> map = new HashMap<>();\\n        List<String> ls = new ArrayList<>();\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int i =0;i<list1.length;i++){\\n            map.put(list1[i],i);\\n        }\\n        \\n        for(int i =0;i<list2.length;i++){\\n            if(map.containsKey(list2[i])){\\n                if(min > i+map.get(list2[i])){\\n                    min = Math.min(min, i + map.get(list2[i]));\\n                    ls.clear();\\n                    ls.add(list2[i]);\\n                    \\n                }else if(min == i + map.get(list2[i])){\\n                    ls.add(list2[i]);\\n                }\\n            }\\n        }\\n        \\n        return ls.toArray(new String[0]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 735853,
                "title": "javascript-solution",
                "content": "> Runtime: 172 ms, faster than 12.58% of JavaScript online submissions for Minimum Index Sum of Two Lists.\\nMemory Usage: 43.7 MB, less than 46.81% of JavaScript online submissions for Minimum Index Sum of Two Lists.\\n\\n```JS\\nvar findRestaurant = function(list1, list2) {\\n    const map = {}\\n    for(let i=0;i<list1.length;i++) {\\n        const e = list1[i]\\n        const index = list2.indexOf(e)\\n        if(index>-1) {\\n            if (map[index+i]) {\\n                map[index+i].push(e)\\n            }else{\\n                map[index+i] = [e]\\n            }\\n        }\\n    }\\n    return Object.values(map)[0]\\n};\\n```",
                "solutionTags": [],
                "code": "```JS\\nvar findRestaurant = function(list1, list2) {\\n    const map = {}\\n    for(let i=0;i<list1.length;i++) {\\n        const e = list1[i]\\n        const index = list2.indexOf(e)\\n        if(index>-1) {\\n            if (map[index+i]) {\\n                map[index+i].push(e)\\n            }else{\\n                map[index+i] = [e]\\n            }\\n        }\\n    }\\n    return Object.values(map)[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732709,
                "title": "c",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        \\n        unordered_map<string, int> record1;\\n        unordered_map<string, int> record2;\\n        \\n        for(int i = 0; i < list1.size(); i++)\\n        {\\n            record1[list1[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < list2.size(); i++)\\n        {\\n            record2[list2[i]] = i;\\n        }\\n        \\n        int indexSum = INT_MAX;\\n        map<int, vector<string>> ans;\\n        \\n        for (int i = 0; i < list1.size(); i++)\\n        {\\n            \\n            if (record1.count(list1[i]) && record2.count(list1[i]))\\n            {\\n                indexSum = min(indexSum, record1[list1[i]] + record2[list1[i]]);\\n                \\n                ans[record1[list1[i]] + record2[list1[i]]].push_back(list1[i]);\\n            }\\n        }\\n        \\n        return ans[indexSum];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        \\n        unordered_map<string, int> record1;\\n        unordered_map<string, int> record2;\\n        \\n        for(int i = 0; i < list1.size(); i++)\\n        {\\n            record1[list1[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < list2.size(); i++)\\n        {\\n            record2[list2[i]] = i;\\n        }\\n        \\n        int indexSum = INT_MAX;\\n        map<int, vector<string>> ans;\\n        \\n        for (int i = 0; i < list1.size(); i++)\\n        {\\n            \\n            if (record1.count(list1[i]) && record2.count(list1[i]))\\n            {\\n                indexSum = min(indexSum, record1[list1[i]] + record2[list1[i]]);\\n                \\n                ans[record1[list1[i]] + record2[list1[i]]].push_back(list1[i]);\\n            }\\n        }\\n        \\n        return ans[indexSum];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717514,
                "title": "easy-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String,Integer> map1=new HashMap<String,Integer>();\\n        HashMap<String,Integer> map2=new HashMap<String,Integer>();\\n        ArrayList<String> aa=new ArrayList<String>();\\n        ArrayList<Integer> ar=new ArrayList<Integer>();\\n        \\n        for(int i=0;i<list1.length;i++){\\n            map1.put(list1[i],i);\\n        }\\n        for(int i=0;i<list2.length;i++){\\n            map2.put(list2[i],i);\\n        }\\n        for(String str:map1.keySet()){\\n            int small=0;\\n            if(map2.containsKey(str)){\\n                int sum=map1.get(str)+map2.get(str);\\n                ar.add(sum);\\n                //aa.add(str);}\\n        }\\n        }\\n        int min = Collections.min(ar);\\n        for(String str:map1.keySet()){\\n            if(map2.containsKey(str) && map1.get(str)+map2.get(str)==min){\\n                aa.add(str);\\n            }\\n        }\\n            String[] array = new String[aa.size()];\\n        aa.toArray(array);\\n        return (array); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        HashMap<String,Integer> map1=new HashMap<String,Integer>();\\n        HashMap<String,Integer> map2=new HashMap<String,Integer>();\\n        ArrayList<String> aa=new ArrayList<String>();\\n        ArrayList<Integer> ar=new ArrayList<Integer>();\\n        \\n        for(int i=0;i<list1.length;i++){\\n            map1.put(list1[i],i);\\n        }\\n        for(int i=0;i<list2.length;i++){\\n            map2.put(list2[i],i);\\n        }\\n        for(String str:map1.keySet()){\\n            int small=0;\\n            if(map2.containsKey(str)){\\n                int sum=map1.get(str)+map2.get(str);\\n                ar.add(sum);\\n                //aa.add(str);}\\n        }\\n        }\\n        int min = Collections.min(ar);\\n        for(String str:map1.keySet()){\\n            if(map2.containsKey(str) && map1.get(str)+map2.get(str)==min){\\n                aa.add(str);\\n            }\\n        }\\n            String[] array = new String[aa.size()];\\n        aa.toArray(array);\\n        return (array); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710302,
                "title": "python-3-for-those-who-are-just-starting",
                "content": "**Idea**: create two dictionaries storing restaurants and their indices. Create a third dictionary that contains overlapping restaurants with keys equal to the sum of respective keys from the first two dictionaries. Return a key with the smallest value\\n\\n```\\ndef findRestaurant(list1, list2):\\n    shorter = list1 if len(list1) < len(list2) else list2\\n    longer = list1 if len(list1) >= len(list2) else list2\\n    shorter_d, longer_d, combined_d = {}, {}, {}\\n    for k, v in enumerate(shorter):\\n        shorter_d[v] = k\\n    for k, v in enumerate(longer):\\n        longer_d[v] = k\\n\\n    for key in shorter_d:\\n        if key in longer_d:\\n            combined_d[key] = shorter_d[key] + longer_d[key]\\n\\n    return [k for k, v in combined_d.items() if v == min(combined_d.values())]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef findRestaurant(list1, list2):\\n    shorter = list1 if len(list1) < len(list2) else list2\\n    longer = list1 if len(list1) >= len(list2) else list2\\n    shorter_d, longer_d, combined_d = {}, {}, {}\\n    for k, v in enumerate(shorter):\\n        shorter_d[v] = k\\n    for k, v in enumerate(longer):\\n        longer_d[v] = k\\n\\n    for key in shorter_d:\\n        if key in longer_d:\\n            combined_d[key] = shorter_d[key] + longer_d[key]\\n\\n    return [k for k, v in combined_d.items() if v == min(combined_d.values())]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 617462,
                "title": "readable-python-ac-code-fyi",
                "content": "```\\ndef findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d1 = {}\\n        for idx,name in enumerate(list1):\\n            d1[name] = idx\\n        d2 = {}\\n        for idx,name in enumerate(list2):\\n            d2[name] = idx\\n            \\n        min_idx_sum = float(\"inf\")\\n        res = []\\n        for name in d1.keys():\\n            if name in d2.keys():\\n                if d1[name]+d2[name] == min_idx_sum:\\n                    res.append(name)\\n                if d1[name]+d2[name] < min_idx_sum:\\n                    min_idx_sum = d1[name]+d2[name]\\n                    res = [name]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d1 = {}\\n        for idx,name in enumerate(list1):\\n            d1[name] = idx\\n        d2 = {}\\n        for idx,name in enumerate(list2):\\n            d2[name] = idx\\n            \\n        min_idx_sum = float(\"inf\")\\n        res = []\\n        for name in d1.keys():\\n            if name in d2.keys():\\n                if d1[name]+d2[name] == min_idx_sum:\\n                    res.append(name)\\n                if d1[name]+d2[name] < min_idx_sum:\\n                    min_idx_sum = d1[name]+d2[name]\\n                    res = [name]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 491804,
                "title": "python-10-lines-solution-beats-100",
                "content": "```\\nclass Solution(object):\\n    def findRestaurant(self, list1, list2):\\n                           res={}\\n                           for i in range(len(list1)):\\n                                if list1[i] in list2:\\n                                        y=list2.index(list1[i])\\n                                        res[list1[i]]=i+y\\n                         \\n                           if len(set(list(res.values())))==1:\\n                                            test=list(res.keys())\\n                                            return test\\n                \\n                           mini=min(res,key=res.get)\\n                           return [mini]\\n        # Naveen Vadlamudi",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def findRestaurant(self, list1, list2):\\n                           res={}",
                "codeTag": "Java"
            },
            {
                "id": 471747,
                "title": "c-80-100-using-hash-with-comments",
                "content": "```\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string> ret;\\n        unordered_map<string, int> hash;\\n        unordered_map<string, int>::iterator it;\\n        int size1 = list1.size();\\n        int size2 = list2.size();\\n        int cursum;\\n        int minsum = INT_MAX;\\n        \\n        //load all of list 1 into the hash\\n        for(int i = 0; i < size1; i++){\\n            hash[list1[i]] = i;\\n        }\\n\\n        //now look for matches to second list.  if a match is found\\n        //that has a new minsum, then clear the vector and add new entry.\\n        for(int i = 0; i < size2; i++){\\n            it = hash.find(list2[i]);\\n            if(it != hash.end()){\\n                cursum = it->second + i;\\n                if(cursum < minsum){\\n                    //this match has a new minimum sum\\n                    minsum = cursum;\\n                    ret.clear();\\n                    ret.push_back(it->first);\\n                }\\n                else if(cursum == minsum){\\n                    //this match has the same sum as the current minimum\\n                    //return all that match the minimum sum\\n                    ret.push_back(it->first);\\n                }\\n            }\\n        }\\n        \\n        return(ret);\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\\n        vector<string> ret;\\n        unordered_map<string, int> hash;\\n        unordered_map<string, int>::iterator it;\\n        int size1 = list1.size();\\n        int size2 = list2.size();\\n        int cursum;\\n        int minsum = INT_MAX;\\n        \\n        //load all of list 1 into the hash\\n        for(int i = 0; i < size1; i++){\\n            hash[list1[i]] = i;\\n        }\\n\\n        //now look for matches to second list.  if a match is found\\n        //that has a new minsum, then clear the vector and add new entry.\\n        for(int i = 0; i < size2; i++){\\n            it = hash.find(list2[i]);\\n            if(it != hash.end()){\\n                cursum = it->second + i;\\n                if(cursum < minsum){\\n                    //this match has a new minimum sum\\n                    minsum = cursum;\\n                    ret.clear();\\n                    ret.push_back(it->first);\\n                }\\n                else if(cursum == minsum){\\n                    //this match has the same sum as the current minimum\\n                    //return all that match the minimum sum\\n                    ret.push_back(it->first);\\n                }\\n            }\\n        }\\n        \\n        return(ret);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432095,
                "title": "java-solution-using-hashmap",
                "content": "```java\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        // key: name, value: index\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < list1.length; i++){\\n            map.put(list1[i], i);\\n        }\\n        \\n        int shortest = Integer.MAX_VALUE;\\n        List<String> result = new ArrayList<>();\\n        for(int i = 0; i < list2.length; i++){\\n            if(map.containsKey(list2[i])){\\n                int currentSum = i + map.get(list2[i]);\\n                if(currentSum < shortest){\\n                    shortest = currentSum;\\n                    result.clear();\\n                    result.add(list2[i]);\\n                } else if(currentSum == shortest){\\n                    result.add(list2[i]);\\n                }\\n            }\\n        }\\n        \\n        return result.toArray(new String[0]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String[] findRestaurant(String[] list1, String[] list2) {\\n        // key: name, value: index\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < list1.length; i++){\\n            map.put(list1[i], i);\\n        }\\n        \\n        int shortest = Integer.MAX_VALUE;\\n        List<String> result = new ArrayList<>();\\n        for(int i = 0; i < list2.length; i++){\\n            if(map.containsKey(list2[i])){\\n                int currentSum = i + map.get(list2[i]);\\n                if(currentSum < shortest){\\n                    shortest = currentSum;\\n                    result.clear();\\n                    result.add(list2[i]);\\n                } else if(currentSum == shortest){\\n                    result.add(list2[i]);\\n                }\\n            }\\n        }\\n        \\n        return result.toArray(new String[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564652,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1777983,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1776881,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1780530,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1780300,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1572184,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2009651,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1870709,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1780675,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2059253,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1564652,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1777983,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1776881,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1780530,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1780300,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1572184,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2009651,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1870709,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1780675,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2059253,
                "content": [
                    {
                        "username": "nickyaopang1000",
                        "content": "I wonder if this question is posted by a UCSD kid? \\n\\nYou will get sick of these restaurants before your second year."
                    },
                    {
                        "username": "jkaiser21",
                        "content": "Result always returns  `WRONG ANSWER`, and doesn\\'t give me the full test case to debug. Please fix!"
                    },
                    {
                        "username": "goldrushkl168",
                        "content": "[@hetpatelcse](/hetpatelcse)  +1, missing list2 as parameter."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "+1  \\uD83D\\uDE16"
                    },
                    {
                        "username": "Mooooowoong",
                        "content": "Result always returns `Wrong Answer` without any testcases even if correct answer.\nI've tried others code from Solutions, symptom is same, symptom is same. \n\nHere is my code(But it doesn't matter cuz when I submit correct answer then Result always returns Wrong Answer)\n```\nclass Solution {\npublic:\n    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n    unordered_map<string, int> mp1;\n    priority_queue<pair<int, string>, vector<pair<int,string>>, greater<pair<int,string>>> pq;\n    vector<string> ret;\n    for (int i = 0; i < list1.size(); i++) {\n        mp1.insert(pair<string, int>(list1[i], i));\n    }\n\n    for (int i = 0; i < list2.size(); i++) {\n        int idx = 0;\n        auto found = mp1.find(list2[i]);\n        if (found == mp1.end()) {\n            continue;\n        }\n        else {\n            pq.push(make_pair(found->second + i, list2[i]));\n        }\n    }\n    auto prev = pq.top();\n    while (!pq.empty()) {\n        if (pq.top().first == prev.first) {\n            ret.push_back(pq.top().second);\n            prev = pq.top();\n            pq.pop();\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n    }\n};\n```\n\nI can not imagine what is the problem. "
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "Team LeetCode I am facing the same problem, please do solve this bug asap.\\n"
                    },
                    {
                        "username": "racheltian",
                        "content": "I have the same issue. i think it is just a bug"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Wow it doesn\\'t even show us the test case which gives incorrect output. It simply says \"WRONG ANSWER\". Please fix it!!!"
                    },
                    {
                        "username": "Coder1309",
                        "content": "The official solution itself gives WRONG ANSWER . Please fix the test case."
                    },
                    {
                        "username": "asantinc",
                        "content": "Given the input:\\n[\"Shogun\",\"x\",\"Tapioca Express\",\"Burger King\",\"KFC\",\"Shogun\"]\\n[\"Piatti\",\"The Grill at Torrey Pines\",\"Tapioca Express\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\\n\\nIf I submit the input in the order above, the \\'Expected Result\\' returned is: [\"Shogun\"].\\n\\nHowever, if order of the two input lists is flipped, the output becomes: [\"Shogun\",\"Tapioca Express\"].\\n\\nI believe it should be [\"Shogun\",\"Tapioca Express\"] in both cases"
                    },
                    {
                        "username": "bohdandrahan",
                        "content": "Among others constraints there are those two:\\nAll the strings of list1 are unique.\\nAll the strings of list2 are unique.\\n\\nyour input is invalid because of that"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Use a dictionary to store the indices of strings in `list1` for quick lookup. Then, iterates through `list2`, checking for common strings and compare their index sums to find the minimum sum. Keep track of the minimum sum and updates the `result` list accordingly.\n`Here the Python Implementation with Explanation - Beats 99% in Runtime & 100% in Memory:`\nhttps://leetcode.com/problems/minimum-index-sum-of-two-lists/solutions/3895553/almost-perfect-o-n-k-solution-beats-99-in-runtime-100-in-memory/"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "Can somebody explain me why my code shows error for test case number 88?\\n       # res = 30\\n        # common = []\\n        # for i, word in enumerate (list1):\\n        #     if word in list2:\\n        #         j = list2.index(word)\\n        #         if i + j < res:\\n        #             res = i + j\\n        #             common = [word]\\n        #         elif i + j == res:\\n        #             common.append(word)\\n        # return common"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "The question is now broken. Old solutions don't work and I get a wrong answer without being shown the test case that breaks things. Report the question."
                    },
                    {
                        "username": "C_Monish",
                        "content": "Can some one Help me please...!\\n `\\n\\nclass Solution {\\npublic String[] findRestaurant(String[] list1, String[] list2) {\\nHashMap<String,Integer> hm=new HashMap<>();\\nfor(int i=0;i<list1.length;i++) {\\nfor(int j=0;j<list2.length;j++) {\\nif(list1[i].equals(list2[j])) {\\nhm.put(list1[i], i+j);\\n}\\n}\\n}\\nint a=Collections.min(hm.values());\\nString so=\"\";\\nfor (Map.Entry<String, Integer> i:hm.entrySet()) {\\nif(i.getValue()==a) {\\nso+=i.getKey();\\nso+=\" \";\\n}\\n}\\n\\n\\tString sol[]=so.split(\" \");\\n    return sol;\\n}\\n}                     `\\n\\n\\n\\nOutput:\\nlist1 =\\n[\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\\nlist2 =\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\nOutput\\n[\"Tapioca\",\"Express\",\"Shogun\",\"KFC\",\"Burger\",\"King\"]\\nExpected\\n[\"KFC\",\"Burger King\",\"Tapioca Express\",\"Shogun\"]\\n\\n\\n\\n"
                    }
                ]
            }
        ]
    }
]